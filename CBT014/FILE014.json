{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011046000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 529074, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE014.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE014.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\n\\x04'", "DS1TRBAL": "b'\\xa8\\x02'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00*\\x00\\x06\\x00+\\x00\\x01\\x00\\x0b'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00I\\x01\\x19\\x19o\\x01\\x19\\x19o\\x11\\x14\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-07-15T00:00:00", "modifydate": "2019-07-15T11:14:49", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-498"}, "text": "REGULAR CBT TAPE - VERSION 498    FILE:  014\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT498.FILE014\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 16 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,831 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/15/19    11:14:49    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$INTRO": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x95\\x08\\x0f\\x01\\x00)\\x9f\\x113\\x00N\\x00N\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-03-21T00:00:00", "modifydate": "2000-10-25T11:33:00", "lines": 78, "newlines": 78, "modlines": 0, "user": "WSBG"}, "text": "               INTRODUCTION TO THE INSTRUCTIONAL MATERIAL\n\n      This file consists of articles submitted by Sam Golob of\nNewsweek Incorporated to \"Technical Support\" magazine of NaSPA, the\nNational Systems Programmers Association, headquartered in\nMilwaukee, Wisconsin.  The material pertains largely to programs on\nthe CBT tape, and to topics of general systems programmer interest.\nWith the kind permission of Bob Becker, the editor of \"Technical\nSupport\", they are being distributed with the CBT tape to further\nthe usefulness of other files on the tape, and the tape in general.\nIt is the avowed purpose of NaSPA to increase the knowledgeability\nof the system programmer community, and the distribution of this\nmaterial to the public is consistent with this purpose.\n\n      The address of NaSPA is:\n\n             National Systems Programmers Association\n             7044 S. 13th Street\n             Oak Creek, Wisconsin 53154\n             ( 414 ) 768-8000\n\n      My address is:\n\n             Sam Golob\n             P.O. Box 906\n             Tallman, NY 10982-0906\n\n        email:  sbgolob@attglobal.net   and/or  sbgolob@aol.com\n\n      A TABLE OF CONTENTS follows:\n\n$$$INTRO  -  You are reading it.\n\nCBTCNR1   -  A column on useful programs on the CBT tape.  Originally\n               meant to be monthly.  This is installment 1.\n\nCBTCNR2   -  A column on useful programs on the CBT tape.  Originally\n               meant to be monthly.  This is installment 2.\n\nCBTINTRO  -  An introduction to the CBT tape in general.  The article\n               shows how the CBT tape can improve your installation\n               greatly by providing powerful tools.  This is meant as\n               an introduction only, and suggests a few of the tools\n               which the author has found useful in his work.\n\nIOCOUNT   -  Description of the amazing IO-count zap to the operating\n               system, which provides EXCP-count information in JCL\n               listings, for all allocated DDNAMES.  The modification\n               is found on File 369 of the CBT tape.  This is a\n               detailed description of how to install it.\n\nJESART    -  This is a description of how to convert from JES2 version\n               1.3.4 to the higher releases of JES2.\n\nSMPART    -  I believe this material is found nowhere else in this form.\n               This article is meant to introduce new and old systems\n               programmers to the CONCEPTS OF SMP.  It can be used as a\n               \"how-to-do-it\" introduction to any level of SMP.  It is\n               clear, conceptual, and completely step-by-step.  It\n               covers concepts of all releases of SMP, both SMP4\n               and SMP/E.  The article was tested by being given to\n               non-systems-programmers to read, and is meant for anyone\n               who has anything to do with MVS system maintenance.\n               This means non-technical managers as well as technical\n               people.\n\n\n       A series of three articles has been written as a course to\nteach the subcommands of the fantastic \"PDS\" program that can be found\non file 182 of the CBT tape (with utilities on file 296).  These\narticles are now distributed with the PDS package on file 182, and\nwill not be repeated here.\n\n       My thanks also go to Arnie Casinghino for his cooperation and\nhis unflagging dedication to the system programmer community.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$IEFU83": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x0e\\x00\\x00\\x00\\x01\\x02\\x01\\x8f\\x01\\x02\\x01\\x8f\\x13&\\x04\\xe8\\x04\\xe8\\x00\\x00\\xe2\\xc5\\xd8`\\xd7\\xc4\\xe2@@@'", "ispf": {"version": "14.00", "flags": 0, "createdate": "2002-01-18T00:00:00", "modifydate": "2002-01-18T13:26:00", "lines": 1256, "newlines": 1256, "modlines": 0, "user": "SEQ-PDS"}, "text": ">< ADD NAME=$U83ASM  0100-00227-00227-1623-00018-00018-00000-ZGXP30\n//ZGXP30A  JOB (HUB00100),G.PRICE,CLASS=A,MSGCLASS=X,MSGLEVEL=(1,1),\n//             NOTIFY=ZGXP30,REGION=2048K,COND=(0,NE)\n//ASM     EXEC PGM=ASMA90,\n//             PARM='NODECK,OBJECT,TERM,RENT'\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(MOD,PASS),SPACE=(CYL,(1,1)),\n//             UNIT=VIO,DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSIN    DD  DSN=ZGXP30.IEFU83.DATA(IEFU83),DISP=SHR\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//SYSTERM  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DSN=NULLFILE\n//SYSUT1   DD  UNIT=VIO,SPACE=(CYL,(6,1))\n//LKED    EXEC PGM=IEWL,PARM='MAP,LIST,LET,REUS,RENT,REFR'\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DSN=ZGXP30.XA.LOAD(IEFU83),DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//\n>< ADD NAME=$U83INDX 0101-92351-00248-1652-00013-00011-00000-ZGXP30\n\n     LIST OF MEMBERS IN THIS PACKAGE:\n\n     $U83ASM  - SAMPLE JOB TO ASSEMBLE THE IEFU83 EXIT.\n     $U83INDX - YOU GUESSED IT, YOU ARE INDEED LOOKING AT IT!\n     $U83INFO - SOME THOUGHTS ON THE WHOLE KIT AND CABOODLE.\n     IEFU83   - SMF EXIT SOURCE (ISSUE MESSAGES FOR SOME RECORD TYPES).\n     MPFLST83 - SAMPLE MPF PARAMETERS.\n     MSGFLUSH - MPF EXIT SOURCE (FLUSH MESSAGE WITH ONLY A TRACE).\n     MSGJOBLG - MPF EXIT SOURCE (LIMIT MESSAGE TO JOBLOG).\n     MSGNOJLG - MPF EXIT SOURCE (SUPPRESS MESSAGE FROM JOBLOG).\n     MSGNOLOG - MPF EXIT SOURCE (SUPPRESS MESSAGE FROM LOG).\n\n>< ADD NAME=$U83INFO 0100-92351-92351-1423-00061-00061-00000-ZGIP01\n\n   This package consists of an IEFU83 SMF exit and several MPF exits.\n   Assembler source is supplied in each case.\n\n   This package represents an example of issuing messages to the log,\n   consoles, and/or users from the IEFU83 SMF exit.  These messages\n   can contain information from SMF records which is not usually\n   available at run-time, without the need for any post-processing\n   effort.\n\n   The main function of this code is to report the I/O activity of\n   a job in the job's own print output.  This is a very handy source\n   of run-time characteristic information often of great value to\n   programmers during debugging and testing.  The idea was that the\n   I/O count for a file would be shown next to the relevant data set\n   name and not just in a DD summary often produced by IEFACTRT SMF\n   exits.\n\n   The famous \"I/O count zap\" was an ideal solution because the\n   information was supplied on existing printlines, so output volumes\n   were not increased.  Alas, this is just one of many facilities\n   no longer available to us since the dreaded OCO was introduced.\n\n   MVS messages in the \"job messages\" data set provide the link\n   between the devices and the DD name at allocation-time, and\n   show the final disposition of the data set at deallocation-time.\n   The messages of the IEFU83 exit, written at file-close-time, show\n   the link between the DD name and the data set name, as well as\n   showing the access method used, type of access, I/O count, the\n   physical block size, and, where calculable, the approximate\n   byte-transfer count.\n\n   The variation of the '?' character in the U83?14I and U83?15I\n   message-ids is for installations that are only interested in\n   a subset of data sets (eg. only TAPE data sets, only non-VIO\n   data sets, or only updated data sets).\n\n   The MPFLST83 member contains sample statements for the \"proper\"\n   distribution of these messages.  It is assumed that these messages\n   would be unwelcome on the console, hence the MPF suppression.\n\n   MSGJOBLG is used to keep U83021I off the SYSLOG.  If you want it\n   on the SYSLOG then no exit is necessary for this message.\n   MSGNOLOG is used to keep data set I/O messages from appearing\n   on the job log.\n\n   To keep U83?14I, U83?15I and U83064I from being written to the\n   SYSLOG you will probably have to remove routecode 11 from the\n   SYSLOG.  Routecode 11 is essential for these messages so that\n   they go to the \"job messages\" data set.\n\n   Remember, if you want the message but don't want the SMF record,\n   change the SMF parameters to collect the record, and change the\n   exit to delete the record.\n\n                                    Greg Price,\n                                                 16th December 1992.\n\n   P.S.  The comments under FUNCTION in the MSGNOLOG source may seem\n   confusing, but they ARE correct.\n\n>< ADD NAME=IEFU83   0114-92289-02018-1415-00897-00645-00347-ZGXP30\nIEFU83   TITLE 'SMF RECORD (SVC 83 ENTRY) CONFIRMATION USER EXIT'\n***********************************************************************\n*                                                                     *\n* MODULE: IEFU83 - SMF RECORD WRITE CONFIRMATION EXIT (SVC ENTRY)     *\n*                                                                     *\n* FUNCTION: TO ALLOW OR SUPPRESS THE WRITING OF SMF RECORDS           *\n*           ACCORDING TO USER SPECIFICATION.  IN ADDITION, TO         *\n*           PERFORM USER SPECIFIC PROCESSING.                         *\n*                                                                     *\n* MACROS: FROM SYS1.MACLIB AND SYS1.MODGEN.                           *\n*                                                                     *\n* ENTRY:  THIS MODULE RECEIVES CONTROL FROM SVC83/IGC0008C BEFORE     *\n*         IT WRITES EACH SMF RECORD TO THE SMF DATASET.  NOTE THAT    *\n*         THIS ROUTINE DOES NOT RECEIVE CONTROL FOR RECORDS FOR       *\n*         WHICH WRITING HAS BEEN SUPPRESSED BY THE SYSTEM SMF OPTIONS *\n*         OR RECORDS WHICH ARE WRITTEN VIA THE SMF BRANCH ENTRY.      *\n*                                                                     *\n*         REGISTERS AT ENTRY:                                         *\n*         R1  -  ADDRESS OF SMF RECORD RDW                            *\n*         R13 -  ADDRESS OF 72 BYTE SAVEAREA                          *\n*         R14 -  RETURN ADDRESS                                       *\n*         R15 -  ADDRESS OF IEFU83 (ENTRY POINT)                      *\n*                                                                     *\n* EXIT:   THIS MODULE MUST RESTORE ALL REGISTERS EXCEPT R15 WHICH     *\n*         CONTAINS A RETURN CODE.  THE SMF RECORD MAY BE MODIFIED     *\n*         BY THIS EXIT.                                               *\n*                                                                     *\n*         RETURN CODES:                                               *\n*         0   -  WRITE THE SMF RECORD TO THE SMF DATASET.             *\n*         4   -  SUPPRESS THE WRITING OF THE SMF RECORD.              *\n*                                                                     *\n* ATTRIBUTES: REUS,RENT,REFR, KEY 0, ENABLED, AMODE=31, RMODE=ANY.    *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* WRITTEN BY:  GREG PRICE    FERNTREE COMPUTER SERVICES (MELB. AUST.) *\n*              15 OCT 92     MVS/SP4.2.0                              *\n*                                                                     *\n*              20 OCT 92     DISPLAY 'VTOC FOR VOLSER' INSTEAD OF     *\n*                            44X'04' WHEN VTOC IS ACCESSED (14/15).   *\n*                                                                     *\n*              22 OCT 92     REARRANGE 14/15/64 MESSAGES SO THERE     *\n*                            IS ALWAYS ROOM TO SHOW THE BLOCK SIZE.   *\n*                                                                     *\n*              17 DEC 92     ISSUE MESSAGE FOR TAPE E-O-V AND SHOW    *\n*                            VOLUME SERIAL NUMBER FOR TAPE RECORDS.   *\n*                            SHOW '<1KB' FOR 1 TO 1023 BYTES RATHER   *\n*                            THAN '0KB' WHICH COULD BE MISLEADING.    *\n*                                                                     *\n*              29 JAN 93     SUPPRESS MESSAGE IF DDNAME IS 'SMPPTS'   *\n*                            AND AN INPUT BPAM FILE IS ACCESSED TO    *\n*                            VASTLY REDUCE SMP APPLY AND ACCEPT       *\n*                            PROCESSING MESSAGE VOLUMES.              *\n*                                                                     *\n*              09 FEB 93     NEW TAPE PROCESSING: MAKE AN \"M\" MESSAGE *\n*                            FOR EACH TAPE VOLUME (E-O-V AND CLOSE)   *\n*                            SHOWING BLOCK COUNT AND BYTE COUNT WHERE *\n*                            PRACTICABLE.                             *\n*                            ALSO, MAKE A \"C\" MESSAGE FOR CLOSE WITH  *\n*                            THE TOTAL EXCP COUNT FOR THE WHOLE FILE. *\n*                                                                     *\n*              19 FEB 93     SUPPRESS PROBABLY MISLEADING BYTE        *\n*                            COUNT FOR VARIABLE-LENGTH UNBLOCKED      *\n*                            RECORDS, AS IS ALSO DONE FOR RECFM=U.    *\n*                                                                     *\n*              31 MAY 93     SHOW BYTE TRANSFERRED COUNT ESTIMATE     *\n*                            IF RECFM=VB BY CORRECTING JFCRFO IN      *\n*                            PREVIOUS CHANGE TO JFCRFB.               *\n*                                                                     *\n*              03 MAY 94     INCLUDE KEY IN BYTE COUNT FOR DISK       *\n*                            FILES.  FOR VARIABLE LENGTH RECORDS      *\n*                            ONLY ESTIMATE BYTE COUNT WHEN BLOCKED    *\n*                            AND ONLY FOR OUTPUT (TYPE 15) BUT NOT    *\n*                            IF QSAM LOCATE MODE IS USED.  BYTE       *\n*                            COUNT COULD BE WRONG ON INPUT BECAUSE    *\n*                            THE FILE MAY HAVE BEEN CREATED WITH      *\n*                            QSAM LOCATE MODE.  QSAM LOCATE MODE      *\n*                            ON OUTPUT (DSORG=PS,MACRF=PL) WILL       *\n*                            ALWAYS PRODUCE SHORT BLOCKS (UNLESS      *\n*                            ALL RECORDS HAVE MAXIMUM LENGTH, IN      *\n*                            WHICH CASE THERE IS NO BLOCKING).        *\n*                            EXPECTED \"SHORTNESS\" IS BLOCKSIZE        *\n*                            MINUS LOGICAL-RECORD-LENGTH BYTES.       *\n*                            REPLACE BYTE COUNT ESTIMATE FOR QSAM     *\n*                            PUT LOCATE FOR VARIABLE LENGTH RECORDS   *\n*                            WITH 'BLKNG=1' WHEN BLKSIZE = LRECL+4    *\n*                            AND WITH 'BLKNG<2' WHEN BLKSIZE IS NOT   *\n*                            GREATER THAN TWICE THE LRECL.            *\n*                                                                     *\n*              14 MAY 96     USE 4K AS BLOCK SIZE WHEN CALCULATING    *\n*                            PDSE BYTE TRANSFER COUNT.                *\n*                            (REASSEMBLE REQUIRED FOR SP5.2.2/DFSMS.) *\n*                                                                     *\n*              04 JUN 96     ALWAYS ISSUE U83064I UNLESS TSO USER.    *\n*                            REMOVE ROUTCDE 11 FROM U83021I.          *\n*                            USE U83E14I AND U83E15I FOR EXTENDED     *\n*                            FORMAT (AS WELL AS PDSE) FILES.          *\n*                                                                     *\n*              28 JAN 98     EXTEND OPNTYPES TABLE TO FULL SIZE.      *\n*                            ADD 'OUTINX' AND 'EXTEND' TO OPNTYPES.   *\n*                                                                     *\n*              15 AUG 00     CHANGED WORKING STORAGE SUBPOOL FROM     *\n*                            231 (ECSA) TO 230 (PRIVATE HIGH) TO      *\n*                            AVOID ANY IMPACT ON (E)CSA.              *\n*                            OVERLAY JOB STEP PROGRAM NAME IF PRESENT *\n*                            IN TYPE 14/15 WITH THE REAL NAME OF THE  *\n*                            PROGRAM OF THE ACTIVE PRB.               *\n*                                                                     *\n*              09 JUL 01     USE JOB ID IN JSAB RATHER THAN ASCBJBNI  *\n*                            TO CHECK FOR BATCH JOB SO AS TO SUPPRESS *\n*                            MESSAGES FOR SPAWNED JOBS.               *\n*                                                                     *\n*              18 JAN 02     DO NOT OVERLAY JOB STEP PROGRAM NAME     *\n*                            FOR TAPE DATA SETS BECAUSE THIS MAY BE   *\n*                            USED BY TOOLS SUCH AS THE VOLUME MOUNT   *\n*                            ANALYSER TO MATCH TYPE 14/15 RECORDS TO  *\n*                            SPECIFIC JOB STEPS.                      *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*             PERFORMED PROCESSING:                                   *\n*                                                                     *\n*  TYPE 14  - ISSUE A WTO MESSAGE CONTAINING VARIOUS FILE DETAILS     *\n*             INCLUDING THE EXCP COUNT FOR BATCH JOBS ONLY.           *\n*             UPDATE SMF RECORD TO REPLACE THE JOB STEP PROGRAM NAME  *\n*             WITH THE ACTIVE PRB REAL (NOT ALIAS) PROGRAM NAME.      *\n*                                                                     *\n*  TYPE 15  - ISSUE A WTO MESSAGE CONTAINING VARIOUS FILE DETAILS     *\n*             INCLUDING THE EXCP COUNT FOR BATCH JOBS ONLY.           *\n*             UPDATE SMF RECORD TO REPLACE THE JOB STEP PROGRAM NAME  *\n*             WITH THE ACTIVE PRB REAL (NOT ALIAS) PROGRAM NAME.      *\n*                                                                     *\n*  TYPE 21  - ISSUE A WTO MESSAGE SIMILAR TO THE MVT IEC209I MESSAGE. *\n*                                                                     *\n*  TYPE 64  - ISSUE A WTO MESSAGE CONTAINING VARIOUS FILE DETAILS     *\n*             INCLUDING THE EXCP COUNT UNLESS FOR TSO USER.           *\n*                                                                     *\n*         MPF CAN BE USED TO ADVANTAGE TO CONTROL THE DISTRIBUTION    *\n*         OF MESSAGES ISSUED BY THIS EXIT.                            *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*     IT IS EXPECTED THAT MOST INSTALLATIONS WOULD NOT WANT THE       *\n*  MESSAGES GENERATED BY THIS EXIT TO BE DISPLAYED ON SYSTEM OPERATOR *\n*  CONSOLES.  MPF IS THE BEST PLACE TO EFFECT THIS.  'MCS=HRDCPY'     *\n*  COULD BE SPECIFIED ON THE WTO MACROS, BUT THIS INTRODUCES SOME     *\n*  COMPLICATIONS WHEN MESSAGE HANDLING IS FURTHER CUSTOMIZED BY       *\n*  INSTALLATION-SUPPLIED MPF EXITS SUCH AS 'MSGNOLOG'.                *\n*                                                                     *\n*     THE IDEA IS THAT 'U83021I' APPEARS IN THE JOB LOG WITH THE      *\n*  TAPE MOUNT AND DEMOUNT MESSAGES.  HENCE, ROUTCDE=(3,5) FOR THIS    *\n*  MESSAGE.  THE MPF EXIT 'MSGJOBLG' CAN BE USED TO PREVENT THIS      *\n*  MESSAGE APPEARING ON THE SYSTEM LOG.                               *\n*                                                                     *\n*     IT IS INTENDED THAT THE FILE ACTIVITY MESSAGES APPEAR IN THE    *\n*  JOB MESSAGES, BUT NOT THE JOB LOG.  ROUTCDE=(11) IS USED FOR THE   *\n*  JOB MESSAGES DATA SET.  THE MPF EXIT 'MSGNOJLG' CAN BE USED TO     *\n*  PREVENT THE MESSAGES APPEARING IN THE JOB LOG DATA SET.            *\n*                                                                     *\n*     IN SUMMARY, MESSAGES ARE ISSUED HERE WITH THE WIDEST DESIRABLE  *\n*  DISTRIBUTION, TO BE LIMITED ACCORDING TO INSTALLATION REQUIREMENTS *\n*  BY MPF (MESSAGE PROCESSING FACILITY).  THUS, MESSAGE DISTRIBUTION  *\n*  CAN BE CUSTOMIZED DYNAMICALLY WITH THE 'SET MPF' MVS COMMAND,      *\n*  WITHOUT THE NEED TO RE-INSTALL THIS EXIT OR EVEN RE-IPL.           *\n*                                                                     *\n*     IF A REQUIRED MESSAGE IS BASED UPON AN SMF RECORD TYPE NOT      *\n*  USUALLY COLLECTED BY AN INSTALLATION, THE SMF OPTIONS CAN BE       *\n*  ALTERED TO REQUEST THAT THE SMF RECORD TYPE IS TO BE COLLECTED,    *\n*  AND THIS EXIT CAN BE CHANGED TO DELETE THE SMF RECORD AFTER THE    *\n*  APPROPRIATE MESSAGE HAS BEEN ISSSUED.  THE SOURCE CODE ALTERATION  *\n*  FOR THIS IS SIMPLY TO CHANGE THE RELEVANT 'B     WRITEREC'         *\n*  INSTRUCTION TO 'B     SUPRSREC'.                                   *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*  REGISTER USAGE                                                     *\n*                                                                     *\nR0       EQU   0                                                      *\nR1       EQU   1                                                      *\nR2       EQU   2                    SMF RECORD BASE                   *\nR3       EQU   3                    WORK (MESSAGE BUFFER POINTER)     *\nR4       EQU   4                    WORK                              *\nR5       EQU   5                    WORK                              *\nR6       EQU   6                                                      *\nR7       EQU   7                                                      *\nR8       EQU   8                                                      *\nR9       EQU   9                    WORK AREA BASE                    *\nR10      EQU   10                                                     *\nR11      EQU   11                                                     *\nR12      EQU   12                   PROGRAM BASE                      *\nR13      EQU   13                   CALLER'S SAVE AREA BASE           *\nR14      EQU   14                   RETURN ADDRESS                    *\nR15      EQU   15                   ENTRY POINT, WORK, RETURN CODE    *\n*                                                                     *\n***********************************************************************\n         TITLE 'MAINLINE - GLOBAL PROCESSING AND RECORD TYPE CHECK'\nIEFU83   CSECT\nIEFU83   AMODE 31\nIEFU83   RMODE ANY\n         USING IEFU83,R15\n         B     U83$\n         DC    AL1(15),CL15'IEFU83 &SYSDATE'\n         DROP  R15                  IEFU83\nU83$     STM   R14,R12,12(R13)      SAVE REGISTERS\n         LR    R12,R15              R12 - PROGRAM BASE REGISTER\n         USING IEFU83,R12\n         ICM   R2,15,0(R1)          R2  - SMF RECORD BASE REGISTER\n         BZ    WRITEREC             ZERO ADDRESS - CAN'T FIND RECORD\n         USING SMFRECD,R2\n         SPACE\n         CLI   SMF14RTY,14          TYPE 14 RECORD?\n         BE    REC1415$             YES\n         CLI   SMF14RTY,15          TYPE 15 RECORD?\n         BE    REC1415$             YES\n         CLI   SMF21RTY,21          TYPE 21 RECORD?\n         BE    REC21$               YES\n         CLI   SMF64RTY,64          TYPE 64 RECORD?\n         BE    REC64$               YES\n         SPACE\nWRITEREC LM    R14,R12,12(R13)      EXIT AND WRITE RECORD\n         SR    R15,R15                       RC=0\n         BR    R14\n         SPACE\nSUPRSREC LM    R14,R12,12(R13)      EXIT AND SUPPRESS RECORD\n         LA    R15,4                         RC=4\n         BR    R14\n         SPACE 2\n         USING PSA,0\n         TITLE 'SMF RECORD 14 AND 15 - NON-VSAM DATA SET CLOSE/E-O-V'\n***********************************************************************\n*                                                                     *\n* RECORD TYPE 14 AND 15 PROCESSING: OVERLAY SMF14PGN IF PRESENT       *\n*  WITH ACTIVE PROGRAM NAME, AND THEN FORMAT AND WRITE A U83@##I      *\n*  MESSAGE WHERE ## IS '14' OR '15', AS APPROPRIATE, AND @ IS (IN     *\n*  ORDER OF PRECEDENCE) 'M' FOR EACH MAGNETIC TAPE VOLUME E-O-V AND   *\n*  CLOSE, 'C' FOR CLOSE ON MAGNETIC TAPE DATA SETS, 'I' FOR ISAM      *\n*  DATA SETS, 'D' FOR BDAM DATA SETS, 'V' FOR VIO DATA SETS, 'T' FOR  *\n*  OTHER TEMPORARY DATA SETS, 'E' FOR PDSE DATA SETS, AND OTHERWISE   *\n*  'P' FOR OTHER (DISK) PERMANENT DATA SETS.                          *\n*                                                                     *\n* U83@##I ???PUT ??AM FILE DDDDDDDD CLOSED 123456789 EXCPS FOR        *\n*         12345678901234567890123456789012345678901234 BLKSZ=12345    *\n*         12345KB                                                     *\n***********************************************************************\n         SPACE\nREC1415$ TM    SMF14RIN+1,SMF14XSG  ANY EXTENDED INFORMATION SECTION?\n         BNO   ACTPGMOK             NO, SO CAN'T UPDATE IT\n         TM    SMF14RIN,SMF14DAD    TAPE DATA SET?\n         BZ    ACTPGMOK             YES, USED BY VIRTUAL TAPE MODELLING\n         TM    SMF14RIN,SMF14IS+SMF14JIS   ANY HINT OF ISAM?\n         BNZ   ACTPGMOK             YES, MAY BE ISAM SECTION PRESENT\n         TM    SMF14RIN+1,SMF14HBT  HIPERBATCH SECTION PRESENT?\n         BNZ   ACTPGMOK             YES, SKIP IT, TOO HARD\n         SLR   R0,R0                CLEAR FOR INSERT\n         ICM   R0,1,SMF14NUC        GET THE NUMBER OF UCB SECTIONS\n         BZ    ACTPGMOK             HANDLE BAD DATA\n         SLR   R9,R9\n         ICM   R9,1,SMF14SUC        GET UCB SECTION SIZE\n         BZ    ACTPGMOK             HANDLE BAD DATA\n         LA    R15,SMF14UCB         POINT TO THE FIRST UCB SECTION\nUCB14LP  ALR   R15,R9               POINT TO THE NEXT UCB SECTION\n         BCT   R0,UCB14LP\n         DROP  R2                   SMFRECD\n         USING SMF14XIS,R15\n         SLR   R5,R5\n         ICM   R5,3,SMF14SXS        GET EXTENDED SECTION SIZE\n         BNP   ACTPGMOK             IGNORE BAD DATA\n         LA    R0,0(R5,R15)         POINT PAST EXTENDED INFORMATION\n         DROP  R15                  SMF14XIS\n         USING SMFRECD,R2\n         SR    R0,R2                GET REQUIRED RECORD LENGTH\n         CLM   R0,3,SMF14LEN        RECORD LONG ENOUGH TO HOLD SECTION?\n         BH    ACTPGMOK             NO, IGNORE BAD DATA\n         LA    R0,SMF14XIC-SMF14XIS POINT TO PAST EXTENDED INFO HEADER\n         DROP  R2                   SMFRECD\n         USING SMF14XIC,R15\nXTRA14LP SR    R5,R0                ANY EXTENDED INFORMATION LEFT?\n         BNP   ACTPGMOK             NO\n         AR    R15,R0               YES, POINT TO IT\n         ICM   R0,3,SMF14ESL        GET LENGTH OF THIS SECTION\n         BZ    ACTPGMOK             AVOID LOOP IF ZERO LENGTH SECTION\n         CLI   SMF14STY,SMF14STP    STEP INFORMATION SECTION?\n         BNE   XTRA14LP             NO, CHECK FOR ANOTHER SECTION\n         L     R5,PSATOLD           POINT TO CURRENT TCB\n         USING TCB,R5\n         L     R5,TCBRBP            POINT TO CURRENT RB\n         DROP  R5                   TCB\n         USING RBBASIC,R5\nRBLP1415 CLI   RBSTAB1,RBFTPRB      IS RB A PRB?\n         BE    PRB1415              YES\n         TM    RBSTAB2,RBTCBNXT     END OF RB CHAIN?\n         BO    ACTPGMOK             YES, THAT'S FUNNY\n         ICM   R5,7,RBLINKB         NO, POINT TO INVOKING RB\n         B     RBLP1415\nPRB1415  ICM   R5,7,RBCDE1          POINT TO ACTIVE CDE\n         BZ    ACTPGMOK             SKIP IF ZERO\n         DROP  R5                   RBBASIC\n         USING CDENTRY,R5\n         TM    CDATTR,CDMIN         IS THIS AN ALIAS?\n         BNO   MAJR1415             NO\n         L     R5,CDXLMJP           YES, POINT TO CDE WITH REAL NAME\nMAJR1415 TM    CDATTR3,CDPATHN      OPENMVS MODULE?\n         BO    ACTPGMOK             YES, CANNOT USE MODULE NAME\n         MVC   SMF14PGN,CDNAME      OVERLAY JOB STEP PGM WITH ACTIVE\n         DROP  R15,R5               SMF14XIC, CDENTRY\n         USING SMFRECD,R2\nACTPGMOK L     R4,PSAAOLD           POINT TO CURRENT ASCB\n         USING ASCB,R4\n**       ICM   R1,B'1111',ASCBJBNI  BATCH JOB?\n**       BZ    WRITEREC             NO, DO NOT DISPLAY ANY MESSAGE\n         ICM   R4,15,ASCBASSB       POINT TO ASSB\n         BZ    WRITEREC             NO ASSB FOUND\n         DROP  R4                   ASCB\n         USING ASSB,R4\n         ICM   R4,15,ASSBJSAB       POINT TO JSAB\n         BZ    WRITEREC             NO JSAB FOUND\n         DROP  R4                   ASSB\n         USING JSAB,R4\n         CLI   JSABJBID,C'J'        BATCH JOB?\n         BNE   WRITEREC             NO, DO NOT DISPLAY ANY MESSAGE\n         DROP  R4                   JSAB\n         TM    SMF14RIN,SMF14EOV+SMF14DAD\n         BO    WRITEREC             NO MESSAGE FOR DASD E-O-V RECORDS\n         GETMAIN RC,LV=WK14LEN,SP=230,LOC=(ANY)\n         LTR   R15,R15              TEST FOR SUCCESSFUL GETMAIN\n         BNZ   WRITEREC             FAILURE - JUST WRITE SMF RECORD\n         LR    R9,R1                ADDRESS GETMAINED AREA\n         USING WK83AREA,R9\n         MVC   WTOU83D(WTO1415L),WTO1415S INITIALIZE WTO PARAMETER LIST\n         CLI   SMF14RTY,14          TYPE 14 SMF RECORD?\n         BE    T1415OK              YES, CORRECT NUMBER IN MESSAGE\n         MVI   WTOMSGID+5,C'5'      NO, MUST BE A TYPE 15 SMF RECORD\nT1415OK  TM    SMF14RIN,SMF14DAD    MAGNETIC TAPE VOLUME (CLOSE/E-O-V)?\n         BZ    DSOR1415             YES, MESSAGE ID AND TEXT IS CORRECT\nCLOS1415 MVI   WTOMSGID+3,C'C'      TRY FOR CLOSE ON MAGNETIC TAPE\n         TM    SMF14RIN,SMF14DAD    MAGNETIC TAPE DATA SET?\n         BZ    ID1415OK             YES, MESSAGE ID IS CORRECT\n         MVI   WTOMSGID+3,C'I'      NO, TRY FOR ISAM\n         TM    SMF14RIN,SMF14IS+SMF14JIS  ISAM?\n         BNZ   ID1415OK             YES, MESSAGE ID IS CORRECT\n         MVI   WTOMSGID+3,C'D'      NO, TRY FOR BDAM\n         TM    SMF14RIN,SMF14DDA    BDAM?\n         BNZ   ID1415OK             YES, MESSAGE ID IS CORRECT\n         MVI   WTOMSGID+3,C'V'      NO, TRY FOR VIO\n         TM    SMF14RIN,SMF14VIO    VIO?\n         BNZ   ID1415OK             YES, MESSAGE ID IS CORRECT\n         MVI   WTOMSGID+3,C'T'      NO, TRY FOR NON-VIO TEMPORARY\n         TM    SMF14RIN,SMF14TDS    TEMPORARY?\n         BNZ   ID1415OK             YES, MESSAGE ID IS CORRECT\n         MVI   WTOMSGID+3,C'E'      NO, TRY FOR PDSE OR STRIPED\n         TM    SMF14RIN+1,SMF14IPD+SMF14STR  PDSE OR EXTENDED FORMAT?\n         BNZ   ID1415OK             YES, MESSAGE ID IS CORRECT\n         MVI   WTOMSGID+3,C'P'      NO, SIGNAL PERMANENT DISK FILE\nID1415OK MVC   WTOAMDES,=C' EXCPS FOR '   LOAD CORRECT DESCRIPTION\nDSOR1415 TM    SMFDCBMF,X'80'       EXCP PROCESSING USED?\n         BNZ   AM1415OK             YES, MESSAGE IS CORRECT\n         TM    SMFDCBOR,JFCORGIS+JFCORGPS+JFCORGDA+JFCORGPO\n*                                   KNOWN DATA SET ORGANIZATION?\n         BZ    AM1415OK             NO, JUST SAY EXCP\n         MVC   WTOAMNAM,=C'ISAM'    YES\n         TM    SMFDCBOR,JFCORGIS    DCBDSORG=IS?\n         BO    AM1415OK             YES\n         MVC   WTOAMNAM,=C'BDAM'    NO\n         TM    SMFDCBOR,JFCORGDA    DCBDSORG=DA?\n         BO    AM1415OK             YES\n         MVC   WTOAMNAM,=C'BPAM'    NO\n         TM    SMFDCBOR,JFCORGPO    DCBDSORG=PO?\n         BO    PTSCHECK             YES, GO CHECK FOR SMPPTS INPUT\n         MVC   WTOAMNAM,=C'BSAM'    NO, DCBDSORG=PS\n         LA    R1,SMFDCBMF          POINT TO DCBMACRF\n         LA    R0,2                 2 BYTES TO TEST (INPUT AND OUTPUT)\nMACR14LP TM    0(R1),X'60'          TEST BASIC AND QUEUED BITS\n         BM    PS14TEST             DIFFERENT SO SEE WHICH TYPE\n         LA    R1,1(,R1)            POINT TO NEXT BYTE\n         BCT   R0,MACR14LP\n         B     AM1415OK             SHOULD NOT HAPPEN BUT LEAVE AS BSAM\nPTSCHECK TM    SMFDEBOP,X'0F'       BPAM FILE OPENED FOR INPUT?\n         BNZ   AM1415OK             NO, PRODUCE THE MESSAGE\n         CLC   =CL8'SMPPTS  ',SMFTIOE5  TEST FOR SMP PTS FILE TO\n         BE    MS1415FM                 REDUCE APPLY/ACCEPT MSG VOLUMES\n         B     AM1415OK             OTHERWISE, PRODUCE THE MESSAGE\nPS14TEST TM    0(R1),X'40'          IS THE QUEUED BIT ON?\n         BZ    AM1415OK             NO, SO THE BASIC BIT IS ON\n         MVC   WTOAMNAM,=C'QSAM'    YES\nAM1415OK MVC   WTOAMDDN,SMFTIOE5    SHOW THE DDNAME (LOGICAL FILE NAME)\n         IC    R1,SMFDEBOP          NO, GET DEBOPATB I/O METHOD FLAGS\n         SLL   R1,28                SHIFT OUT DISPOSITION FLAGS\n         SRL   R1,28-3              MULTIPLY BY EIGHT FOR INDEX\n         LA    R1,OPNTYPES(R1)      POINT TO OPEN TYPE LITERAL\n         MVC   WTOAMOPN,0(R1)       SHOW THE OPEN TYPE\nOPND1415 TM    SMF14RIN,SMF14DAD    DASD DATA SET?\n         BZ    LD1415DS             NO, SHOW DATA SET NAME\n         CLI   JFCBDSNM,X'04'       YES, ACCESSING THE VTOC?\n         BNE   LD1415DS             NO, SHOW DATA SET NAME\n         MVC   WTOAMDSN(7),=C'VTOC OF'  YES, DO NOT SHOW X'04' BYTES\n         MVC   WTOAMDSN+8(6),JFCBVOLS        BUT 'VTOC OF VOLSER'\n         B     DS1415OK             DATA SET NAME FIELD NOW LOADED\nLD1415DS MVC   WTOAMDSN,JFCBDSNM    SHOW THE DSN (PHYSICAL FILE NAME)\n         CLI   WTOMSGID+3,C'M'      MAGNETIC TAPE VOLUME MESSAGE?\n         BNE   DS1415OK             NO, GO LOOP THROUGH UCB SECTIONS\n         MVI   WTOAMSLA,C'/'        YES, SO INDICATE ON THIS TAPE ONLY\n         MVC   WTOAMVOL,SMFSRTEV    SHOW TAPE VOLUME WITH THIS EXCP CT\n         ICM   R5,15,SMFDCBBL       LOAD VOLUME EXCP COUNT\n         B     UN1415EX             DISPLAY THIS AS THE EXCP COUNT\nDS1415OK SLR   R5,R5                CLEAR EXCP COUNT ACCUMULATOR\n         SLR   R0,R0                CLEAR FOR INSERT\n         ICM   R0,1,SMF14NUC        GET THE NUMBER OF UCB SECTIONS\n         BZ    UN1415EX             HANDLE BAD DATA\n         SLR   R1,R1                CLEAR FOR INSERT\n         ICM   R1,1,SMF14SUC        GET THE UCB SECTION SIZE\n         BZ    UN1415EX             HANDLE BAD DATA\n         LA    R15,SMF14UCB         POINT TO THE FIRST UCB SECTION\n         DROP  R2                   SMFRECD\n         USING SMF14UCB,R15         NO\nUN1415LP ICM   R4,15,SMFEXCP        GET THE EXCP COUNT FOR THIS UNIT\n         ALR   R5,R4                ADD TO THE ACCUMULATOR\n         ALR   R15,R1               POINT TO THE NEXT UCB SECTION\n         BCT   R0,UN1415LP          PROCESS NEXT UCB SECTION IF ANY\n         DROP  R15                  SMF14UCB\n         USING SMFRECD,R2\nUN1415EX CVD   R5,WORK              GET DECIMAL TOTAL EXCP COUNT\n         MVC   WTOAMXCP,ED9         LOAD EDIT MASK\n         ED    WTOAMXCP,WORK+3      SHOW EXCP COUNT UP TO (10**9)-1\n         SLR   R15,R15              CLEAR FOR INSERT\n         ICM   R15,3,JFCBLKSI       GET THE DATA SET BLOCK SIZE\n         TM    SMF14RIN+1,SMF14IPD  PDSE?\n         BNZ   PDSE1415             YES\n         LTR   R15,R15              TEST THE BLOCK SIZE\n         BZ    MS1415OK             ZERO, SO SKIP CALCULATION\n         TM    JFCRECFM,JFCUND      UNDEFINED RECORD FORMAT?\n         BNM   BLSZ1415             YES, JUST SHOW BLOCK SIZE\n         TM    JFCRECFM,JFCFIX      FIXED FORMAT?\n         BO    NVPL1415             YES, \"NOT VARIABLE PUT LOCATE\"\n         TM    JFCRECFM,JFCRFB      VARIABLE RECORDS, BUT BLOCKED?\n         BZ    BLSZ1415             NO, JUST SHOW BLOCK SIZE\n         CLI   SMF14RTY,14          OPENED FOR INPUT (OR RDBACK)?\n         BE    BLSZ1415             YES, FILE MAY BE FROM PUT LOCATE\n         TM    SMFDCBMF+1,X'48'     OUTPUT, BUT IS IT QSAM PUT LOCATE?\n         BNO   NVPL1415             NO, \"NOT VARIABLE PUT LOCATE\"\n         SLR   R0,R0\n         ICM   R0,3,JFCLRECL        GET THE LOGICAL RECORD LENGTH\n         BNP   BLSZ1415             JUST SHOW BLOCK SIZE IF STRANGE\n         LR    R14,R15              COPY BLOCK SIZE\n         SR    R14,R0               SUBTRACT LRECL\n         CR    R14,R0               IS DIFFERENCE BIGGER THAN LRECL?\n         BH    BLSZ1415             YES, JUST SHOW BLOCK SIZE\n         MVC   WTOAMSIZ+1(7),=C'BLKNG<2'  NO, GETTING SHORT BLOCKS\n         LA    R0,4                 GET FOUR\n         CR    R14,R0               IS IT TRUE THAT BLKSIZE=LRECL+4?\n         BH    BLSZ1415             NO, CAN'T PROVE NO BLOCKING AT ALL\n         MVC   WTOAMSCL,=C'=1'      YES, INDICATE ABSOLUTELY UNBLOCKED\n         B     BLSZ1415             NOW SHOW THE BLOCK SIZE\nPDSE1415 LTR   R5,R5                ANY EXCPS?\n         BNZ   PDSEEXCP             YES\n         LTR   R15,R15              IS THE BLOCK SIZE ZERO?\n         BZ    MS1415OK             YES, SO SKIP ITS DISPLAY\n         B     BLSZ1415             NO, SHOW THE BLOCK SIZE\nPDSEEXCP SLR   R4,R4                CLEAR FOR SHIFT\n         SLDL  R4,12                MULTIPLY EXCP COUNT BY 4096\n         B     PDSEBLKS             GO SHOW THE BYTE TRANSFER COUNT\nNVPL1415 TM    SMFDCBOR,JFCORGPS    SEQUENTIAL FILE PROCESSING?\n         BZ    BLSZ1415             NO, JUST SHOW BLOCK SIZE\n         CLI   WTOMSGID+3,C'M'      MAGNETIC TAPE VOLUME MESSAGE?\n         BE    SQ1415OK             YES, CAN SHOW BYTE COUNT RELIABLY\n         TM    SMFDCBMF,X'80'       EXCP ACCESS METHOD USED?\n         BNZ   BLSZ1415             YES, JUST SHOW BLOCK SIZE\n         CLI   SMF14RTY,14          OPENED FOR INPUT (OR RDBACK)?\n         BNE   PMBR1415             NO\n         BCTR  R5,0                 YES, DECREMENT FOR E-O-F (OR TM)\nPMBR1415 TM    JFCDSORG,JFCORGPO    SEQUENTIAL ACCESS OF A PDS?\n         BZ    SQ1415OK             NO\n         LA    R15,256              YES, GET PDS DIRECTORY BLOCK SIZE\n         CLC   JFCBELNM,=CL8' '     SEQUENTIAL ACCESS OF A PDS MEMBER?\n         BE    SQ1415OK             NO\n         BCTR  R5,0                 YES, DECREMENT EXCP COUNT FOR BLDL\n         LA    R15,WTOAMDSN+43      POINT TO LAST DSNAME CHARACTER\nNVSDSNLP CLI   0(R15),C' '          TRAILING BLANK?\n         BNE   NVSMEMNM             NO\n         BCT   R15,NVSDSNLP         YES, BACK UP ONE AND TEST AGAIN\nNVSMEMNM CLI   11(R15),C' '         ROOM FOR '(*MEMBER*)'?\n         BNE   NVSMEMDN             NO, DO NOT SHOW MEMBER NAME\n         MVI   1(R15),C'('          YES, SUPPLY LEFT PARENTHESIS\n         MVC   2(8,R15),JFCBELNM    LOAD PDS MEMBER NAME\nNVSMEMLP CLI   9(R15),C' '          TRAILING BLANK?\n         BNE   NVSMEMOK             NO\n         BCT   R15,NVSMEMLP         YES, BACK UP ONE AND TEST AGAIN\nNVSMEMOK MVI   10(R15),C')'         SUPPLY RIGHT PARENTHESIS\nNVSMEMDN SLR   R15,R15              CLEAR FOR INSERT\n         ICM   R15,3,JFCBLKSI       GET THE DATA SET BLOCK SIZE\nSQ1415OK LTR   R5,R5                POSITIVE EXCP COUNT?\n         BNP   BLSZ1415             NO, JUST SHOW BLOCK SIZE\n         TM    SMF14RIN,SMF14DAD    DASD DATA SET?\n         BZ    SEQKEYOK             NO, CAN'T HAVE A KEY\n         SLR   R0,R0                YES\n         IC    R0,JFCKEYLE          GET THE KEY LENGTH USED\n         AR    R15,R0               ALSO COUNT KEY BYTES TRANSFERRED\nSEQKEYOK MR    R4,R15               GET BYTES (BLOCK_COUNT*SIZE)\nPDSEBLKS MVC   WTOAMSIZ+4(2),=C'<1' REPLACE '0KB' WITH '<1KB'\n         LA    R1,=C'KMGT'          POINT TO KILO/MEGA/GIGA/TERA FLAGS\nSZ1415LP SRDA  R4,10                DIVIDE BY 1024\n         BZ    SZ1415DN             IF ZERO THEN LESS THAN ONE\n         LTR   R4,R4                NUMBER LARGER THAN ONE FULLWORD?\n         BNZ   SZ1415BG             YES, TOO BIG\n         CL    R5,=F'99999'         NO, IS NUMBER BIGGER THAN 99,999?\n         BNH   SZ1415OK             NO, SHOW THE NUMBER\nSZ1415BG LA    R1,1(,R1)            POINT TO NEXT SCALE INDICATOR\n         B     SZ1415LP             CONTINUE TO SCALE DOWN\nSZ1415OK CVD   R5,WORK              SHOW THE APPROXIMATE BYTE COUNT\n         MVC   WTOAMSIZ,ED5         LOAD EDIT MASK\n         ED    WTOAMSIZ,WORK+5\nSZ1415DN MVC   WTOAMSCL(1),0(R1)    SHOW SCALING INDICATOR\n         MVI   WTOAMSCL+1,C'B'      INDICATE BYTES\n         ICM   R15,3,JFCBLKSI       GET THE DATA SET BLOCK SIZE AGAIN\n         BZ    MS1415OK             HANDLE PDSE WITH ZERO BLOCK SIZE\nBLSZ1415 CVD   R15,WORK             SHOW BLOCK SIZE\n         OI    WORK+7,15            PREPARE FOR UNPACK\n         MVC   WTOAMBLK,=C'BLKSZ='\n         UNPK  WTOAMBLS,WORK+5(3)   LOAD BLOCK SIZE NUMERICS\nBLSZ14LP CLI   WTOAMBLS,C'0'        LEADING ZERO?\n         BNE   MS1415OK             NO, FORMATTING COMPLETE\n         MVC   WTOAMBLS,WTOAMBLS+1  YES, SHUFFLE UP TO SUPPRESS IT\n         B     BLSZ14LP             CONTINUE WITH LEADING ZERO CHECK\nMS1415OK DS    0H                   MESSAGE NOW READY FOR DISPLAY\n         SPACE\n         WTO   MF=(E,WTOU83D)       DISPLAY U83?14I OR U83?15I\n         SPACE\n         CLI   WTOMSGID+3,C'M'      MAGNETIC TAPE VOLUME MESSAGE?\n         BNE   MS1415FM             NO, GO TIDY UP AND EXIT\n         TM    SMF14RIN,SMF14EOV    CLOSE OF TAPE FILE?\n         BO    MS1415FM             NO, JUST E-O-V FOR THIS VOLUME\n         MVI   WTOAMSLA,C' '        YES, PRODUCE EXTRA MESSAGE TO SHOW\n         MVC   WTOAMVOL,=C'CLOSED'       EXCP (AS OPPOSED TO BLOCK)\n         MVI   WTOAMBLK,C' '             COUNT FOR WHOLE FILE\n         MVC   WTOAMBLK+1(18),WTOAMBLK\n         B     CLOS1415\n         SPACE\n         DROP  R9                   WK83AREA\n         SPACE\nMS1415FM DS    0H                   FREE GETMAINED STORAGE\n         FREEMAIN RU,LV=WK14LEN,A=(R9),SP=230\n         B     WRITEREC             ALL DONE, GO WRITE TYPE 14/15 REC\n         TITLE 'SMF RECORD 21 - ERROR STATISTICS BY VOLUME (TAPE ONLY)'\n***********************************************************************\n*                                                                     *\n* RECORD TYPE 21 PROCESSING:  FORMAT AND WRITE A U83021I MESSAGE      *\n*  BASED ON IEC209I FROM OS/MVT.  COUNTERS ARE ONLY SHOWN IF          *\n*  NON-ZERO, EXCEPT THE SSCH COUNT WHICH IS ALWAYS SHOWN.             *\n*                                                                     *\n* U83021I JJJJJJJJ,VVVVVV,DEV,SIO=12345,DEN=1,BLKSIZE=12345,          *\n*         TR=123,TW=123,PR=123,PW=123,NB=123,ERG=12345,CLN=12345,     *\n*         TRF=12345,TRB=12345,TRW=12345,BR=123456789,BW=123456789     *\n*                                                                     *\n***********************************************************************\n         SPACE\nREC21$   GETMAIN RC,LV=WK21LEN,SP=230,LOC=(ANY)\n         LTR   R15,R15              TEST FOR SUCCESSFUL GETMAIN\n         BNZ   WRITEREC             FAILURE - JUST WRITE SMF RECORD\n         LR    R9,R1                ADDRESS GETMAINED AREA\n         USING WK83AREA,R9\n         MVC   WTOU83D(WTO21L),WTO21S     INITIALIZE WTO PARAMETER LIST\n         L     R4,548               POINT TO CURRENT ASCB\n         USING ASCB,R4\n         ICM   R1,B'1111',ASCBJBNI  POINT TO ADDRESS SPACE NAME\n         BNZ   LDJOB21              USE IT IF FOUND\n         ICM   R1,B'1111',ASCBJBNS  POINT TO ADDRESS SPACE NAME\n         BNZ   LDJOB21              USE IT IF FOUND\n         DROP  R4                   ASCB\n         LA    R1,=C'STARTING'      IN CASE OF NULL JOB NAME POINTER\nLDJOB21  MVC   WTOTEXT(8),0(R1)     LOAD ADDRESS SPACE NAME\n         LA    R3,WTOTEXT+7         POINT TO LAST BYTE OF JOB NAME\nJOB21LP  CLI   0(R3),C' '           TRAILING BLANK?\n         BNE   JOB21OK              NO\n         BCT   R3,JOB21LP           YES, BACK UP ONE AND TEST AGAIN\nJOB21OK  MVI   1(R3),C','           SUPPLY SEPARATOR\n         MVC   2(6,R3),SMF21VOL     LOAD TAPE VOLUME SERIAL NUMBER\nVOL21LP  CLI   7(R3),C' '           TRAILING BLANK?\n         BNE   VOL21OK              NO\n         BCT   R3,VOL21LP           YES, BACK UP ONE AND TEST AGAIN\nVOL21OK  MVI   8(R3),C','           SUPPLY SEPARATOR\n         UNPK  9(5,R3),SMF21CA(3)   LOAD DEVICE NUMBER\n         TR    9(4,R3),HEX-240      MAKE PRINTABLE HEX CHARACTERS\n         MVI   13(R3),C','          SUPPLY SEPARATOR\n         CLI   9(R3),C'0'           LEADING ZERO IN DEVICE NUMBER?\n         BNE   DEV21OK              NO\n         MVC   9(5,R3),10(R3)       YES, SUPPRESS IT\n         BCTR  R3,0                 ADJUST POINTER\nDEV21OK  LA    R3,14(,R3)           POINTER TO FIRST BLANK AFTER COMMA\n         SLR   R0,R0                CLEAR FOR INSERTS\n         ICM   R0,3,SMF21SIO        LOAD SSCH COUNT\n         LA    R1,=C'SIO'           POINT TO LABEL\n         BAS   R14,CNTR3FST         SHOW I/O COUNT\n         TM    SMF21DEN,X'03'       VALID DENSITY?\n         BNO   DEN21OK              NO\n         IC    R0,SMF21DEN          YES, GET DENSITY BYTE FOR 2400/3400\n         LR    R1,R0                COPY IT\n         SLL   R0,24+2\n         SRL   R0,24+2+4            GET BITS 2 AND 3 AS A NUMBER\n         SLL   R1,6                 GET BITS 0 AND 1 AS A NUMBER\n         AR    R1,R0                ADD THE TWO NUMBERS (GET 0 TO 6)\n         MVC   0(5,R3),=C',DEN='    SUPPLY DENSITY LABEL\n         STC   R1,5(,R3)            SUPPLY DENSITY VALUE\n         OI    5(R3),X'F0'          MAKE PRINTABLE (ASSUME < 10)\n         LA    R3,6(,R3)            ADJUST DISPLAY LINE POINTER\nDEN21OK  DS    0H\n         ICM   R0,3,SMF21BLS        LOAD BLOCKSIZE\n         BZ    BLS21OK              ZERO SO DON'T SHOW IT\n*        LA    R1,=C'BLS'           POINT TO LABEL\n         MVC   0(5,R3),=C',BLKS'    WANT 'BLKSIZE=', NOT 'BLS='\n         LA    R3,5(,R3)            ADJUST DISPLAY LINE POINTER\n         LA    R1,=C'IZE'           POINT TO LABEL\n         BAS   R14,CNTR3FST         SHOW BLOCKSIZE\n         SPACE\nBLS21OK  IC    R0,SMF21TR           LOAD TEMPORARY READ ERROR COUNT\n         LA    R1,=C'TR'            POINT TO LABEL\n         BAS   R14,COUNTER2         SHOW TEMPORARY READ ERROR COUNT\n         SPACE\n         IC    R0,SMF21TW           LOAD TEMPORARY WRITE ERROR COUNT\n         LA    R1,=C'TW'            POINT TO LABEL\n         BAS   R14,COUNTER2         SHOW TEMPORARY WRITE ERROR COUNT\n         SPACE\n         IC    R0,SMF21PR           LOAD PERMANENT READ ERROR COUNT\n         LA    R1,=C'PR'            POINT TO LABEL\n         BAS   R14,COUNTER2         SHOW PERMANENT READ ERROR COUNT\n         SPACE\n         IC    R0,SMF21PW           LOAD PERMANENT WRITE ERROR COUNT\n         LA    R1,=C'PW'            POINT TO LABEL\n         BAS   R14,COUNTER2         SHOW PERMANENT WRITE ERROR COUNT\n         SPACE\n         IC    R0,SMF21NB           LOAD NOISE BLOCK COUNT\n         LA    R1,=C'NB'            POINT TO LABEL\n         BAS   R14,COUNTER2         SHOW NOISE BLOCK COUNT\n         SPACE\n         ICM   R0,3,SMF21ERG        LOAD ERASE GAP COUNT\n         LA    R1,=C'ERG'           POINT TO LABEL\n         BAS   R14,COUNTER3         SHOW ERASE GAP COUNT\n         SPACE\n         ICM   R0,3,SMF21CLN        LOAD CLEANER ACTION COUNT\n         LA    R1,=C'CLN'           POINT TO LABEL\n         BAS   R14,COUNTER3         SHOW CLEANER ACTION COUNT\n         SPACE\n         ICM   R0,3,SMF21TRF        LOAD TEMP READ FORWARD ERROR COUNT\n         LA    R1,=C'TRF'           POINT TO LABEL\n         BAS   R14,COUNTER3         SHOW TEMP READ FORWARD ERROR COUNT\n         SPACE\n         ICM   R0,3,SMF21TRB        LOAD TEMP READ BACKWARD ERROR COUNT\n         LA    R1,=C'TRB'           POINT TO LABEL\n         BAS   R14,COUNTER3         SHOW TEMP READ BACKWARD ERROR COUNT\n         SPACE\n         ICM   R0,3,SMF21TWF        LOAD TEMPORARY WRITE ERROR COUNT\n         LA    R1,=C'TWF'           POINT TO LABEL\n         BAS   R14,COUNTER3         SHOW TEMPORARY WRITE ERROR COUNT\n         SPACE\n         ICM   R0,7,SMF21BR         LOAD 4K BYTES READ COUNT\n         LA    R1,=C'BR'            POINT TO LABEL\n         BAS   R14,COUNTER2         SHOW 4K BYTES READ COUNT\n         SPACE\n         ICM   R0,7,SMF21BW         LOAD 4K BYTES WRITTEN COUNT\n         LA    R1,=C'BW'            POINT TO LABEL\n         BAS   R14,COUNTER2         SHOW 4K BYTES WRITTEN COUNT\n         SPACE\n         WTO   MF=(E,WTOU83D)       DISPLAY U83021I\n         SPACE\n         FREEMAIN RU,LV=WK21LEN,A=(R9),SP=230\n         B     WRITEREC             ALL DONE, GO AND WRITE TYPE 21 REC\n         SPACE\nCOUNTER2 DS    0H                   SHOW COUNTER WITH 2-CHARACTER LABEL\n         LTR   R0,R0                NON-ZERO VALUE?\n         BZR   R14                  NO, SUPPRESS DISPLAY OF ZERO\n         MVI   0(R3),C','           SUPPLY SEPARATOR\n         CVD   R0,WORK              GET DECIMAL VALUE\n         OI    WORK+7,15            PREPARE FOR UNPACK\n         MVC   1(2,R3),0(R1)        LOAD VALUE LABEL (2 CHARACTERS)\n         B     CNTRCMN              BRANCH TO COMMON CODE\n         SPACE\nCOUNTER3 DS    0H                   SHOW COUNTER WITH 3-CHARACTER LABEL\n         LTR   R0,R0                NON-ZERO VALUE?\n         BZR   R14                  NO, SUPPRESS DISPLAY OF ZERO\n         MVI   0(R3),C','           SUPPLY SEPARATOR\n         LA    R3,1(,R3)            POINT PAST SEPARATOR\nCNTR3FST CVD   R0,WORK              GET DECIMAL VALUE\n         OI    WORK+7,15            PREPARE FOR UNPACK\n         MVC   0(3,R3),0(R1)        LOAD VALUE LABEL (3 CHARACTERS)\nCNTRCMN  MVI   3(R3),C'='\n         UNPK  4(9,R3),WORK+3(5)    LOAD NUMERIC COUNT\n         LA    R0,13                GET LENGTH OF TEXT ADDED\nCNTR0LP  CLI   4(R3),C'0'           LEADING ZERO?\n         BNE   CNTROKAY             NO\n         MVC   4(9,R3),5(R3)        YES, SUPPRESS IT\n         BCT   R0,CNTR0LP           CONTINUE LEADING ZERO CHECK\nCNTROKAY ALR   R3,R0                POINT PAST ADDED MESSAGE TEXT\n         BR    R14                  RETURN TO CALLER\n         SPACE\n         DROP  R9                   WK83AREA\n         TITLE 'SMF RECORD 64 - VSAM DATA SET CLOSE'\n***********************************************************************\n*                                                                     *\n* RECORD TYPE 64: FORMAT AND WRITE A U83064I MESSAGE.                 *\n*                                                                     *\n* U83064I ???PUT VSAM FILE DDDDDDDD CLOSED 123456789 EXCPS FOR        *\n*         12345678901234567890123456789012345678901234 BLKSZ=12345    *\n*         12345KB                                                     *\n***********************************************************************\n         SPACE\nREC64$   L     R4,PSAAOLD           POINT TO CURRENT ASCB\n         USING ASCB,R4\n         ICM   R1,B'1111',ASCBTSB   TIME SHARING USER?\n         BNZ   WRITEREC             YES, DO NOT DISPLAY ANY MESSAGE\n         DROP  R4                   ASCB\n         TM    SMF64RIN,X'80'       RECORD WRITTEN BY CLOSE?\n         BZ    WRITEREC             NO, BY EOV, SO DO NOT MAKE A MSG\n         GETMAIN RC,LV=WK64LEN,SP=230,LOC=(ANY)\n         LTR   R15,R15              TEST FOR SUCCESSFUL GETMAIN\n         BNZ   WRITEREC             FAILURE - JUST WRITE SMF RECORD\n         LR    R9,R1                ADDRESS GETMAINED AREA\n         USING WK83AREA,R9\n         MVC   WTOU83D(WTO64L),WTO64S INITIALIZE WTO PARAMETER LIST\n         SLR   R3,R3                CLEAR FOR INSERT\n         ICM   R3,3,SMF64ESL        GET EXTENT SECTION LENGTH\n         LA    R3,SMF64FEX(R3)      POINT PAST EXTENT SECTION\n         DROP  R2                   SMFRECD\n         USING SMF64STS,R3          STATISTICS SECTION ADDRESSABILITY\n         LA    R0,176\n         CLM   R0,15,SMF64SLN       STATISTICS SECTION LONG ENOUGH?\n         BH    REC64XIT             NO, DO NOT WRITE ANY MESSAGE\n         MVC   WTOAMDDN,SMF64DDN    SHOW THE DDNAME (LOGICAL FILE NAME)\n         IC    R1,SMF64MC1          GET ACBMACR1 FLAGS\n         SLL   R1,29                SHIFT OUT UNWANTED FLAGS\n         SRL   R1,30                GET GET/PUT READ/WRITE FLAGS\n         SLA   R1,3                 MULTIPLY BY EIGHT FOR INDEX\n         BZ    OPENED64             BOTH FLAGS OFF SO LEAVE BLANK\n         LA    R1,VOPNTYPS-8(R1)    POINT TO OPEN TYPE LITERAL\n         MVC   WTOAMOPN,0(R1)       SHOW THE OPEN TYPE\n         DROP  R3                   SMF64STS\n         USING SMFRECD,R2\nOPENED64 MVC   WTOAMDSN,SMF64DNM    SHOW THE DSN (PHYSICAL FILE NAME)\n         DROP  R2                   SMFRECD\n         USING SMF64STS,R3          STATISTICS SECTION ADDRESSABILITY\n         CLI   WTOAMDSN,C'$'        VALID NAME?\n         BNL   DSN64OK              POSSIBLY, ASSUME THAT IT IS\n         MVC   WTOAMDSN,SMF64CLN    NO, SHOW THE JCL DATA SET NAME\nDSN64OK  ICM   R5,15,SMF64DEP       GET THE EXCP COUNT CHANGE\n         BM    REC64XIT             DO NOT ISSUE MESSAGE IF NEGATIVE\n         CVD   R5,WORK              GET DECIMAL TOTAL EXCP COUNT\n         MVC   WTOAMXCP,ED9         LOAD EDIT MASK\n         ED    WTOAMXCP,WORK+3      SHOW EXCP COUNT UP TO (10**9)-1\n         ICM   R15,15,SMF64DBS      GET THE DATA SET BLOCK SIZE\n         BNP   MESG64OK             ZERO SO SKIP CALCULATION\n         CVD   R15,WORK             SHOW BLOCK SIZE\n         OI    WORK+7,15            PREPARE FOR UNPACK\n         MVC   WTOAMBLK,=C'BLKSZ='\n         UNPK  WTOAMBLS,WORK+5(3)   LOAD BLOCK SIZE NUMERICS\nBLSZ64LP CLI   WTOAMBLS,C'0'        LEADING ZERO?\n         BNE   BLSZ64OK             NO, FORMATTING COMPLETE\n         MVC   WTOAMBLS,WTOAMBLS+1  YES, SHUFFLE UP TO SUPPRESS IT\n         B     BLSZ64LP             CONTINUE WITH LEADING ZERO CHECK\nBLSZ64OK LTR   R5,R5                ANY EXCPS?\n         BZ    MESG64OK             NO, SUPPRESS DISPLAY OF '0KB'\n         MR    R4,R15               YES, GET BYTES (BLOCK COUNT*SIZE)\n         MVC   WTOAMSIZ+4(2),=C'<1' REPLACE '0KB' WITH '<1KB'\n         LA    R1,=C'KMGT'          POINT TO KILO/MEGA/GIGA/TERA FLAGS\nSIZE64LP SRDA  R4,10                DIVIDE BY 1024\n         BZ    SIZE64DN             IF ZERO THEN LESS THAN ONE\n         LTR   R4,R4                NUMBER LARGER THAN ONE FULLWORD?\n         BNZ   SIZE64BG             YES, TOO BIG\n         CL    R5,=F'99999'         NO, IS NUMBER BIGGER THAN 99,999?\n         BNH   SIZE64OK             NO, SHOW THE NUMBER\nSIZE64BG LA    R1,1(,R1)            POINT TO NEXT SCALE INDICATOR\n         B     SIZE64LP             CONTINUE TO SCALE DOWN\nSIZE64OK CVD   R5,WORK              SHOW THE APPROXIMATE BYTE COUNT\n         MVC   WTOAMSIZ,ED5         LOAD EDIT MASK\n         ED    WTOAMSIZ,WORK+5\nSIZE64DN MVC   WTOAMSCL(1),0(R1)    SHOW SCALING INDICATOR\n         MVI   WTOAMSCL+1,C'B'      INDICATE BYTES\nMESG64OK DS    0H                   MESSAGE NOW READY FOR DISPLAY\n         SPACE\n         WTO   MF=(E,WTOU83D)       DISPLAY U83064I\n         SPACE\n         DROP  R9,R3                WK83AREA, SMF64STS\nREC64XIT DS    0H\n         SPACE\n         FREEMAIN RU,LV=WK64LEN,A=(R9),SP=230\n         B     WRITEREC             ALL DONE, GO WRITE TYPE 64 RECORD\n         TITLE 'STATIC AREA AND LITERAL POOL'\nHEX      DC    C'0123456789ABCDEF'\nED5      DC    XL6'402020202120'\nED9      DC    XL10'40202020202020202120'\n*                 OPEN TYPE      DEBOPATB SETTING\nOPNTYPES DC    CL8' INPUT  '       0000      0\n         DC    CL8'RDBACK  '       0001      1\n         DC    CL8'?0010?  '       0010      2\n         DC    CL8' INOUT  '       0011      3\n         DC    CL8'UPDATE  '       0100      4\n         DC    CL8'?0101?  '       0101      5\n         DC    CL8'OUTINX  '       0110      6\n         DC    CL8' OUTIN  '       0111      7\n         DC    CL8'?1000?  '       1000      8\n         DC    CL8'?1001?  '       1001      9\n         DC    CL8'?1010?  '       1010      A\n         DC    CL8'?1011?  '       1011      B\n         DC    CL8'?1100?  '       1100      C\n         DC    CL8'?1101?  '       1101      D\n         DC    CL8'EXTEND  '       1110      E\n*        DC    CL8'OUTPUT  '       1111      F\n*                 OPEN TYPE      ACBMACR1 SETTING\nVOPNTYPS DC    CL8'OUTPUT  '       .01.      2\n         DC    CL8' INPUT  '       .10.      4\n         DC    CL8'UPDATE  '       .11.      6\n         SPACE\n*        WTO TEMPLATES - 125 CHARS (MSGID + ' ' + UP TO 117 TEXT)\n         SPACE\nWTO1415S WTO   'U83M14I OUTPUT EXCP FILE *DDNAME* CLOSED 123456789 BLOC+\n               KS OF DSNAME                                            +\n                             ',ROUTCDE=(11),MF=L\nWTO1415L EQU   *-WTO1415S\n         SPACE\nWTO21S   WTO   'U83021I JOB-NAME                                       +\n                                                                       +\n                             ',ROUTCDE=(3,5),MF=L\nWTO21L   EQU   *-WTO21S\n         SPACE\nWTO64S   WTO   'U83064I        VSAM FILE *DDNAME* CLOSED 123456789 EXCP+\n               S FOR 12345678.12345678.12345678.12345678.12345678      +\n                             ',ROUTCDE=(11),MF=L\nWTO64L   EQU   *-WTO64S\n         SPACE 2\n         LTORG\n         SPACE 2\n         DS    0D                   END OF CSECT\n         TITLE 'DYNAMIC AREA DEFINITIONS'\nWK83AREA DSECT\nWORK     DS    D\nWTOU83D  WTO   '1234567890123456789012345678901234567890123456789012345+\n               67890123456789012345678901234567890123456789012345678901+\n               23456789012345',ROUTCDE=(11),MF=L\n         ORG   WTOU83D+4\nWTOMSGID DS    CL8                  U83###I\nWTOTEXT  DS    CL112\n         ORG   WTOTEXT\nWTOAMOPN DS    CL6                  OPEN TYPE\n         DS    CL1                  ' '\nWTOAMNAM DS    CL4                  ACCESS METHOD\n         DS    CL6                  ' FILE '\nWTOAMDDN DS    CL8                  DDNAME\nWTOAMSLA DS    CL1                  ' ' OR '/'\nWTOAMVOL DS    CL6                  'CLOSED' OR TAPE VOLSER\nWTOAMXCP DS    CL10                 EXCP COUNT\nWTOAMDES DS    CL11                 ' EXCPS FOR ' OR ' BLOCKS OF '\nWTOAMDSN DS    CL44                 DSNAME\n         DS    CL1                  ' '\nWTOAMBLK DS    CL6                  'BLKSZ='\nWTOAMBLS DS    CL5                  DATA SET BLOCK SIZE\nWTOAMSIZ DS    CL6                  UPPER LIMIT TO BYTE COUNT\nWTOAMSCL DS    CL2                  'KB'/'MB'/'GB'/'TB'\n         ORG\n         SPACE\n         DS    0D\nWK14LEN  EQU   *-WK83AREA\nWK21LEN  EQU   *-WK83AREA\nWK64LEN  EQU   *-WK83AREA\n         EJECT\n         TITLE 'SMF RECORD STRUCTURES'\nSMFRECD  DSECT\n         IFASMFR (14)\n         SPACE\n         ORG   SMFJFCB1\n         IEFJFCBN\n         EJECT\n         ORG   SMFRECD\n         IFASMFR (21)\n         EJECT\n         ORG   SMFRECD\n         IFASMFR (64)\n         EJECT\n         TITLE 'SYSTEM CONTROL BLOCKS'\n         IHAPSA\n         SPACE 3\n         IHAASCB\n         SPACE 3\n         IHAASSB\n         SPACE 3\n         IAZJSAB\n         SPACE 3\n         IKJTCB\n         SPACE 3\n         IHARB\n         SPACE 3\n         IHACDE\n         SPACE 3\n         END   IEFU83\n>< ADD NAME=MPFLST83 0111-92352-98028-1731-00010-00009-00000-T$QGP75\nU83C1*,SUP(YES),USEREXIT(MSGFLUSH)  IEFU83 CLOSE TAPE FILE MESSAGE\nU83M1*,SUP(YES),USEREXIT(MSGFLUSH)  IEFU83 TAPE END-OF-VOLUME MESSAGE\nU83I1*,SUP(YES),USEREXIT(MSGFLUSH)  IEFU83 CLOSE ISAM FILE MESSAGE\nU83D1*,SUP(YES),USEREXIT(MSGFLUSH)  IEFU83 CLOSE BDAM FILE MESSAGE\nU83V1*,SUP(YES),USEREXIT(MSGFLUSH)  IEFU83 CLOSE VIO FILE MESSAGE\nU83T1*,SUP(YES),USEREXIT(MSGFLUSH)  IEFU83 CLOSE TEMPORARY FILE MESSAGE\nU83E1*,SUP(YES),USEREXIT(MSGFLUSH)  IEFU83 CLOSE PDSE FILE MESSAGE\nU83P1*,SUP(YES),USEREXIT(MSGFLUSH)  IEFU83 CLOSE PERMANENT FILE MESSAGE\nU83021I,SUP(YES),USEREXIT(MSGJOBLG) IEFU83 TAPE DEMOUNT MESSAGE\nU83064I,SUP(YES),USEREXIT(MSGFLUSH) IEFU83 CLOSE VSAM FILE MESSAGE\n>< ADD NAME=MSGFLUSH 0100-92282-92282-1227-00063-00063-00000-ZGIP01\nMSGFLUSH TITLE 'MPF EXIT TO DELETE WTO MESSAGE FROM CONSOLES AND LOGS'\n*\n*        PURPOSE: TO SUPPRESS WTO MESSAGE DISPLAY ON EVERY\n*                 CONSOLE AS WELL AS THE SYSTEM LOG AND JOB LOG.\n*                 THIS ALLOWS INSTALLATION CODE SUCH AS SMF EXITS\n*                 LIKE IEFU83 TO SUPPLY NUMEROUS MESSAGES WHICH\n*                 CAN BE SELECTIVELY DISCARDED TO REDUCE CONSOLE\n*                 AND LOG MESSAGE CLUTTER.  THESE DISCARDED MESSAGES\n*                 WILL ONLY APPEAR IN THE MASTER TRACE TABLE, AND\n*                 WTP MESSAGES (ROUTCDE=11) WILL NOT BE TPUT UNDER\n*                 TSO EVEN IF 'PROFILE WTPMSG' IS ACTIVE.\n*\n*       FUNCTION: TURN ON THE \"DELETE THE MESSAGE\" BIT AS WELL AS\n*                 THE \"SUPPRESS FROM JOBLOG\" BIT.\n*                 SELECTIVITY IS PROVIDED BY THE ACTIVE MPFLST__\n*                 MEMBER OF SYS1.PARMLIB.\n*\n*        WRITTEN: GREG PRICE OF FERNTREE COMPUTER SERVICES 08 OCT 1992.\n*\n*     ATTRIBUTES: REUS,RENT,REFR,AMODE=31,RMODE=ANY.\n*\n*         MACROS: IEZVX100 MAPPING MACRO FROM SYS1.MODGEN.\n*\n         SPACE 2\nMSGFLUSH CSECT\nMSGFLUSH AMODE 31                 31 BIT ADDRESSING MODE\nMSGFLUSH RMODE ANY                31 BIT RESIDENCY MODE\n         SPACE\n         USING MSGFLUSH,R12\n         STM   R14,R12,12(R13)    SAVE CALLER'S REGISTERS\n         LR    R12,R15            ESTABLISH MODULE'S BASE REGISTER\n         L     R9,0(R1)           R9==> WTO EXIT PARAMETER LIST\n         USING CTXT,R9            ESTABLISH ADDRESSABLITY TO IT\n         OI    CTXTRFB2,CTXTRDTM  DELETE THE MESSAGE\n         OI    CTXTERF3,CTXTESJL  SUPPRESS MESSAGE FROM THE JOBLOG\n         DROP  R12,R9             MSGFLUSH, CTXT\n         LM    R14,R12,12(R13)    RESTORE CALLER'S REGISTERS\n         BR    R14                RETURN TO CALLER\n         SPACE 2\n         LTORG\n         SPACE 2\n         DS    0D                 END OF CSECT\n         TITLE 'EQUATES AND DSECTS'\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 2\n         IEZVX100\n         SPACE 2\n         END   MSGFLUSH\n>< ADD NAME=MSGJOBLG 0100-92282-92282-1227-00062-00062-00000-ZGIP01\nMSGJOBLG TITLE 'MPF EXIT TO DELETE WTO MESSAGE FROM CONSOLES AND LOG'\n*\n*        PURPOSE: TO SUPPRESS WTO MESSAGE DISPLAY ON EVERY\n*                 CONSOLE AS WELL AS THE SYSTEM LOG.\n*                 THIS ALLOWS INSTALLATION CODE SUCH AS SMF EXITS\n*                 LIKE IEFU83 TO SUPPLY NUMEROUS MESSAGES WHICH\n*                 CAN BE SELECTIVELY DISCARDED TO REDUCE CONSOLE\n*                 AND SYSTEM LOG MESSAGE CLUTTER.  THESE DISCARDED\n*                 MESSAGES WILL ONLY APPEAR IN THE MASTER TRACE\n*                 TABLE AND THE JOB LOG, AND WTP MESSAGES (ROUTCDE=11)\n*                 WILL NOT BE TPUT UNDER TSO EVEN IF 'PROFILE WTPMSG'\n*                 IS ACTIVE.\n*\n*       FUNCTION: TURN ON THE \"DELETE THE MESSAGE\" BIT.\n*                 SELECTIVITY IS PROVIDED BY THE ACTIVE MPFLST__\n*                 MEMBER OF SYS1.PARMLIB.\n*\n*        WRITTEN: GREG PRICE OF FERNTREE COMPUTER SERVICES 08 OCT 1992.\n*\n*     ATTRIBUTES: REUS,RENT,REFR,AMODE=31,RMODE=ANY.\n*\n*         MACROS: IEZVX100 MAPPING MACRO FROM SYS1.MODGEN.\n*\n         SPACE 2\nMSGJOBLG CSECT\nMSGJOBLG AMODE 31                 31 BIT ADDRESSING MODE\nMSGJOBLG RMODE ANY                31 BIT RESIDENCY MODE\n         SPACE\n         USING MSGJOBLG,R12\n         STM   R14,R12,12(R13)    SAVE CALLER'S REGISTERS\n         LR    R12,R15            ESTABLISH MODULE'S BASE REGISTER\n         L     R9,0(R1)           R9==> WTO EXIT PARAMETER LIST\n         USING CTXT,R9            ESTABLISH ADDRESSABLITY TO IT\n         OI    CTXTRFB2,CTXTRDTM  DELETE THE MESSAGE\n         DROP  R12,R9             MSGJOBLG, CTXT\n         LM    R14,R12,12(R13)    RESTORE CALLER'S REGISTERS\n         BR    R14                RETURN TO CALLER\n         SPACE 2\n         LTORG\n         SPACE 2\n         DS    0D                 END OF CSECT\n         TITLE 'EQUATES AND DSECTS'\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 2\n         IEZVX100\n         SPACE 2\n         END   MSGJOBLG\n>< ADD NAME=MSGNOJLG 0100-92282-92282-1227-00057-00057-00000-ZGIP01\nMSGNOJLG TITLE 'MPF EXIT TO DELETE WTO MESSAGE FROM JOBLOG'\n*\n*        PURPOSE: TO SUPPRESS WTO MESSAGE DISPLAY ON THE JOB LOG.\n*                 THIS ALLOWS INSTALLATION CODE SUCH AS SMF EXITS\n*                 LIKE IEFU83 TO SUPPLY NUMEROUS MESSAGES TO THE\n*                 JOB MESSAGES DATA SET (ASSUMING ROUTCDE=11)\n*                 WITHOUT CAUSING EXTRA JOB LOG MESSAGE CLUTTER.\n*\n*       FUNCTION: TURN ON THE \"SUPPRESS FROM JOBLOG\" BIT.\n*                 SELECTIVITY IS PROVIDED BY THE ACTIVE MPFLST__\n*                 MEMBER OF SYS1.PARMLIB.\n*\n*        WRITTEN: GREG PRICE OF FERNTREE COMPUTER SERVICES 08 OCT 1992.\n*\n*     ATTRIBUTES: REUS,RENT,REFR,AMODE=31,RMODE=ANY.\n*\n*         MACROS: IEZVX100 MAPPING MACRO FROM SYS1.MODGEN.\n*\n         SPACE 2\nMSGNOJLG CSECT\nMSGNOJLG AMODE 31                 31 BIT ADDRESSING MODE\nMSGNOJLG RMODE ANY                31 BIT RESIDENCY MODE\n         SPACE\n         USING MSGNOJLG,R12\n         STM   R14,R12,12(R13)    SAVE CALLER'S REGISTERS\n         LR    R12,R15            ESTABLISH MODULE'S BASE REGISTER\n         L     R9,0(R1)           R9==> WTO EXIT PARAMETER LIST\n         USING CTXT,R9            ESTABLISH ADDRESSABLITY TO IT\n         OI    CTXTERF3,CTXTESJL  SUPPRESS MESSAGE FROM THE JOBLOG\n         DROP  R12,R9             MSGNOJLG, CTXT\n         LM    R14,R12,12(R13)    RESTORE CALLER'S REGISTERS\n         BR    R14                RETURN TO CALLER\n         SPACE 2\n         LTORG\n         SPACE 2\n         DS    0D                 END OF CSECT\n         TITLE 'EQUATES AND DSECTS'\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 2\n         IEZVX100\n         SPACE 2\n         END   MSGNOJLG\n>< ADD NAME=MSGNOLOG 0100-92282-92282-1227-00065-00065-00000-ZGIP01\nMSGNOLOG TITLE 'MPF EXIT TO DELETE WTO MESSAGE FROM SYSLOG AND JOBLOG'\n*\n*        PURPOSE: TO SUPPRESS WTO MESSAGE DISPLAY ON THE SYSTEM\n*                 LOG AS WELL AS THE JOB LOG.\n*                 THIS ALLOWS INSTALLATION CODE SUCH AS SMF EXITS\n*                 LIKE IEFU83 TO SUPPLY NUMEROUS MESSAGES TO THE\n*                 JOB MESSAGES DATA SET (ASSUMING ROUTCDE=11)\n*                 WITHOUT CAUSING EXTRA LOG MESSAGE CLUTTER.\n*\n*       FUNCTION: TURN ON THE \"FORCE NO HARDCOPY\" BIT AS WELL AS\n*                 THE \"SUPPRESS FROM JOBLOG\" BIT.\n*                 SELECTIVITY IS PROVIDED BY THE ACTIVE MPFLST__\n*                 MEMBER OF SYS1.PARMLIB.  IF 'SUP(YES)' IS SPECIFIED\n*                 THEN THE MESSAGE WILL BE SHOWN ON THE SYSTEM LOG,\n*                 UNLESS MCSFLAG=HRDCPY IS SPECIFIED WHEREUPON THE\n*                 MESSAGE WILL BE DISPLAY ON THE SYSTEM CONSOLE(S).\n*                 WTP MESSAGES CAN STILL BE TPUT UNDER TSO SUBJECT\n*                 TO 'PROFILE WTPMSG' BEING ACTIVE.\n*\n*        WRITTEN: GREG PRICE OF FERNTREE COMPUTER SERVICES 08 OCT 1992.\n*\n*     ATTRIBUTES: REUS,RENT,REFR,AMODE=31,RMODE=ANY.\n*\n*         MACROS: IEZVX100 MAPPING MACRO FROM SYS1.MODGEN.\n*\n         SPACE 2\nMSGNOLOG CSECT\nMSGNOLOG AMODE 31                 31 BIT ADDRESSING MODE\nMSGNOLOG RMODE ANY                31 BIT RESIDENCY MODE\n         SPACE\n         USING MSGNOLOG,R12\n         STM   R14,R12,12(R13)    SAVE CALLER'S REGISTERS\n         LR    R12,R15            ESTABLISH MODULE'S BASE REGISTER\n         L     R9,0(R1)           R9==> WTO EXIT PARAMETER LIST\n         USING CTXT,R9            ESTABLISH ADDRESSABLITY TO IT\n         OI    CTXTRFB2,CTXTRNHC  FORCE NO HARDCOPY\n         OI    CTXTERF3,CTXTESJL  SUPPRESS MESSAGE FROM THE JOBLOG\n         DROP  R12,R9             MSGNOLOG, CTXT\n         LM    R14,R12,12(R13)    RESTORE CALLER'S REGISTERS\n         BR    R14                RETURN TO CALLER\n         SPACE 2\n         LTORG\n         SPACE 2\n         DS    0D                 END OF CSECT\n         TITLE 'EQUATES AND DSECTS'\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 2\n         IEZVX100\n         SPACE 2\n         END   MSGNOLOG\n>< ENDUP       \"REVIEW\" PDS MEMBER OFFLOAD AT 13:24 ON 02/01/18\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE014": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00C\\x01\\x19\\x19o\\x01\\x19\\x19o\\x11\\x14\\x00R\\x00R\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-07-15T00:00:00", "modifydate": "2019-07-15T11:14:43", "lines": 82, "newlines": 82, "modlines": 0, "user": "CBT-498"}, "text": "//***FILE 014 IS FROM SAM GOLOB AND CONTAINS A SERIES OF ARTICLES   *   FILE 014\n//*           WRITTEN FOR TECHNICAL SUPPORT MAGAZINE OF NASPA.      *   FILE 014\n//*           THIS FILE IS IN IEBUPDTE SYSIN FORMAT.  FOR           *   FILE 014\n//*           ADDITIONAL INFORMATION, SEE THE MEMBER CALLED         *   FILE 014\n//*           $$$INTRO.  THESE ARE SAM'S OLDER ARTICLES. (SEE       *   FILE 014\n//*           FILE 120 FOR THE COLLECTION OF SAM'S \"MVS TOOLS AND   *   FILE 014\n//*           TRICKS OF THE TRADE\" COLUMNS.)                        *   FILE 014\n//*                                                                 *   FILE 014\n//*           email:  sbgolob@cbttape.org                           *   FILE 014\n//*                                                                 *   FILE 014\n//*           This file now contains an IEFACTRT exit that (it      *   FILE 014\n//*           is believed) can replace the I/O Count system         *   FILE 014\n//*           modification, on modern systems.                      *   FILE 014\n//*                                                                 *   FILE 014\n//*           Even better, Greg Price's IEFU83 exit (included       *   FILE 014\n//*           here as member $$IEFU83), will show a lot of          *   FILE 014\n//*           information as well.  See member IOCOUN$$ for         *   FILE 014\n//*           more detail about this package.                       *   FILE 014\n//*                                                                 *   FILE 014\n//*           THIS FILE CONSISTS OF ARTICLES SUBMITTED BY SAM       *   FILE 014\n//*           GOLOB TO \"TECHNICAL SUPPORT\" MAGAZINE OF NASPA,       *   FILE 014\n//*           THE NATIONAL SYSTEMS PROGRAMMERS ASSOCIATION,         *   FILE 014\n//*           HEADQUARTERED IN MILWAUKEE, WISCONSIN.                *   FILE 014\n//*                                                                 *   FILE 014\n//*           THE MATERIAL PERTAINS LARGELY TO PROGRAMS ON THE CBT  *   FILE 014\n//*           TAPE, AND TO TOPICS OF GENERAL SYSTEMS PROGRAMMER     *   FILE 014\n//*           INTEREST.  WITH THE KIND PERMISSION OF BOB BECKER,    *   FILE 014\n//*           FORMER EDITOR OF \"TECHNICAL SUPPORT\", THEY ARE BEING  *   FILE 014\n//*           DISTRIBUTED WITH THE CBT TAPE TO FURTHER THE          *   FILE 014\n//*           USEFULNESS OF OTHER FILES ON THE TAPE, AND THE TAPE   *   FILE 014\n//*           IN GENERAL.                                           *   FILE 014\n//*                                                                 *   FILE 014\n//*           CBTCNR1   -  A COLUMN ON USEFUL PROGRAMS ON THE CBT   *   FILE 014\n//*                          TAPE.  INSTALLMENT 1.                  *   FILE 014\n//*                                                                 *   FILE 014\n//*           CBTCNR2   -  A COLUMN ON USEFUL PROGRAMS ON THE CBT   *   FILE 014\n//*                          TAPE.  INSTALLMENT 2.                  *   FILE 014\n//*                                                                 *   FILE 014\n//*           CBTINTRO  -  AN INTRODUCTION TO THE CBT TAPE IN       *   FILE 014\n//*                          GENERAL.  THE ARTICLE SHOWS HOW THE    *   FILE 014\n//*                          CBT TAPE CAN IMPROVE YOUR INSTALLATION *   FILE 014\n//*                          GREATLY BY PROVIDING POWERFUL TOOLS.   *   FILE 014\n//*                          THIS IS MEANT AS AN INTRODUCTION ONLY, *   FILE 014\n//*                          AND SUGGESTS A FEW OF THE TOOLS WHICH  *   FILE 014\n//*                          THE AUTHOR HAS FOUND USEFUL IN HIS     *   FILE 014\n//*                          WORK.                                  *   FILE 014\n//*                                                                 *   FILE 014\n//*           IOCOUNT   -  DESCRIPTION OF THE AMAZING IO-COUNT ZAP  *   FILE 014\n//*                          TO THE OPERATING SYSTEM, WHICH         *   FILE 014\n//*                          PROVIDES EXCP-COUNT INFORMATION IN JCL *   FILE 014\n//*                          LISTINGS, FOR ALL ALLOCATED DDNAMES.   *   FILE 014\n//*                          THE MODIFICATION IS FOUND ON FILE 369  *   FILE 014\n//*                          OF THE CBT TAPE.  THIS IS A DETAILED   *   FILE 014\n//*                          DESCRIPTION OF HOW TO INSTALL IT.      *   FILE 014\n//*                                                                 *   FILE 014\n//*           JESART    -  THIS IS A DESCRIPTION OF HOW TO CONVERT  *   FILE 014\n//*                          FROM JES2 VERSION 1.3.4 TO THE HIGHER  *   FILE 014\n//*                          RELEASES OF JES2.                      *   FILE 014\n//*                                                                 *   FILE 014\n//*           SMPART    -  I BELIEVE THIS MATERIAL IS FOUND NOWHERE *   FILE 014\n//*                          ELSE IN THIS FORM.  THIS ARTICLE IS    *   FILE 014\n//*                          MEANT TO INTRODUCE NEW AND OLD SYSTEMS *   FILE 014\n//*                          PROGRAMMERS TO THE CONCEPTS OF SMP.    *   FILE 014\n//*                          IT CAN BE USED AS A \"HOW-TO-DO-IT\"     *   FILE 014\n//*                          INTRODUCTION TO ANY LEVEL OF SMP.  IT  *   FILE 014\n//*                          IS CLEAR, CONCEPTUAL, AND COMPLETELY   *   FILE 014\n//*                          STEP-BY-STEP.  IT COVERS CONCEPTS OF   *   FILE 014\n//*                          ALL RELEASES OF SMP, BOTH SMP4 AND     *   FILE 014\n//*                          SMP/E.  THE ARTICLE WAS TESTED BY      *   FILE 014\n//*                          BEING GIVEN TO NON-SYSTEMS-PROGRAMMERS *   FILE 014\n//*                          TO READ, AND IS MEANT FOR ANYONE WHO   *   FILE 014\n//*                          HAS ANYTHING TO DO WITH MVS SYSTEM     *   FILE 014\n//*                          MAINTENANCE.  THIS MEANS NON-TECHNICAL *   FILE 014\n//*                          MANAGERS AS WELL AS TECHNICAL PEOPLE.  *   FILE 014\n//*                                                                 *   FILE 014\n//*           A SERIES OF THREE ARTICLES HAS BEEN WRITTEN AS        *   FILE 014\n//*           A COURSE TO TEACH THE SUBCOMMANDS OF THE FANTASTIC    *   FILE 014\n//*           \"PDS\" PROGRAM THAT CAN BE FOUND ON FILE 182 OF THE    *   FILE 014\n//*           CBT TAPE (WITH UTILITIES ON FILE 296).  THESE         *   FILE 014\n//*           ARTICLES ARE NOW DISTRIBUTED WITH THE PDS PACKAGE ON  *   FILE 014\n//*           FILE 182, AND WILL NOT BE REPEATED HERE.              *   FILE 014\n//*                                                                 *   FILE 014\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CBTCNR1": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x08\\x0f\\x01\\x01\\x03\\x8f\\x14#\\x00R\\x00S\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-03-20T00:00:00", "modifydate": "2001-02-07T14:23:00", "lines": 82, "newlines": 83, "modlines": 0, "user": "WSBG"}, "text": "                  FREE SOFTWARE CORNER - Installment 1\n\n\n       This is a new column which is designed to benefit the readership\nof \"Technical Support\" by discussion of individual valuable tools from\nthe CBT Tape and other Public Domain tapes.  Large packages such as\nPDS merit full feature articles, but many smaller and valuable \"single\nutilities\" might go unnoticed and unused by a public which needs them,\nwithout a forum such as this.\n\n       The original idea for this column came to me from Steve Smith,\none of the authors of PDS, who was trying to go through the CBT tape\nto find things he could use.  A clearinghouse for discussion of the\npopularly used public offerings would help him a lot, he told me,\nand I brought up the subject with Scott Sherer and Bob Becker, who\ngraciously offered the space in the magazine.  So here we are!\n\n       This month, I'd like to talk about several nice things to have.\nBecause space is short and our readers are clever, we won't tell you\nhow to install these tools.  You can read the instructions and do it\nyourself.  We'll point you to them and say a few things about them,\nand let you do the rest.\n\n       Item number one is called JCLSCAN.  It can be found on File 32\nof a NEW CBT tape (version 275 or later) or on File 313 of an older\ntape (version 260 or older).  It is a TSO command processor that you\npoint to a dataset of JCL to check it for converter errors.  It gives\nthe same result as TYPRUN=SCAN, except that:  A. Only the errors are\ndisplayed.  B. The results are nicely formatted and go to the TSO tube.\nC. You don't have to wait for an initiator to test for JCL errors.\nD. This program actually calls IBM's converter module (through a user\nSVC) so you are guaranteed to get the same results as in running the\nactual job.  Neat tool, especially if you are developing new PROCs.\n\n       Next great little gimmick is called CVTCLIST, and it can be found\non File 187 of most of the recent CBT tapes.  It instantly converts\na CLIST pds from the RECFM(FB) LRECL(80) format to RECFM(VB) LRECL(255)\nand vice-versa.  The VB to FB direction has a few bugs (which I intend\nto fix when I have time someday) but the FB to VB conversion absolutely\nruns rings around anything IBM has ever publicly come up with.  It is\nalmost instantaneous, and it converts an entire pds effortlessly.\n\n       People interested in MVS maintenance may like File 118 of the\nCBT tape, which contains a package to \"pre-process\" a PUT tape before\nany version of SMP gets a hand on it.  The main program in this file\nis called PUTXREF, which produces a report that lists all sysmods on\na PUT tape, sorted by FMID.  This is followed by a program SMPFMUPV,\nwhich can read this report and produce card-image SMP input of all the\nsysmod numbers SEPARATED FMID by FMID.  I have just finished a new\nprogram, called SMPUPD, which should appear on this file shortly, that\ntakes a sequential PTF file and creates a PDS from it, with the\nindividual PTFs as members.  This will let you research new PTFs before\nyou RECEIVE them.  File 428 is related to File 118, but File 428 will\nbe primarily of interest to people who still have SMP4.  I have used\nthe tools on File 428 to do an entire PUT with SMP4, without looking\nat a single hard copy!  Some of it is definitely adaptable to SMP/E.\n\n       I have to mention the EXCP-count zap to IBM's JCL allocation\nmessages, which can be found on File 369 of the CBT tape, and which\ncomes from the Planning Research Corporation in Virginia.  This zap\nis easily maintained, although it requires a special technique, and\nI intend to discuss it in detail in a future article.  Meanwhile, if\nyou want the best way to get EXCP counts (in my opinion), look into\nthis.  There is an XA version and a MVS/370 version on this file.\n(I'm not mentioning the other goodies, such as the AUTOIPL program,\nwhich are there.)\n\n       I'll conclude this month's sampling with the SUPRNAME program\nfrom the excellent collection in File 270 from the State of Washington.\nThis is a cool tool that will eliminate a lot of your vtoc-zapping.\nIt is a front-end to AMASPZAP that somehow finds the name of a file\non a vtoc, and renames or deletes the file without having to worry\nabout enqueue.  If you have a scrap copy of SYS1.VTAMLIB lying around\nand you can't delete it while VTAM is up, this is definitely for you.\nSample JCL is included to run this program, including the case where\nthe pack is indexed, and you have to \"un-index\" it before the delete\nand \"re-index\" it afterward.\n\n       Good luck and good hunting.  If you have suggestions for\nprograms to mention in this column, you can write to me, Sam Golob,\nat sbgolob@attglobal.net .\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CBTCNR2": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x08\\x0f\\x01\\x01\\x03\\x8f\\x14$\\x00\\x98\\x00\\xa4\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-03-20T00:00:00", "modifydate": "2001-02-07T14:24:00", "lines": 152, "newlines": 164, "modlines": 0, "user": "WSBG"}, "text": "                    FREE SOFTWARE CORNER - Installment 2\n\n                              by Sam Golob\n\n       This column is designed to benefit the readership of \"Technical\nSupport\" by discussion of individual valuable tools from the CBT Tape\nand other Public Domain tapes. Large packages such as PDS merit full\nfeature articles, but many smaller and useful \"single utilities\" might\ngo unnoticed and unused by a public which needs them.  This is the\npurpose of the column.  If you have any suggestions for a good utility\nthat is worth mentioning in this column, kindly drop a note to me\nthrough the editor, Bob Becker.\n\n       Our concentration this month will be on Jim Marshall's Air\nForce collection of TSO commands and batch utilities.  These are Files\n300 and 316 of the CBT tape.  We'll discuss some of the offerings\nwhich I feel are especially useful, but remember, since it's all free,\nyou're welcome always to pick and choose and take.  One observation is\nin order, that sometimes a more advanced or improved version of the\nsame program can be found elsewhere on the CBT tape if you look hard.\nHowever, this collection is a useful and fruitful starting point.\n\n       Let's start out with good old CDSCB, or \"change the DSCB\" on\nFile 300.  (This TSO command bailed me out just last night.)  It\nallows you to change any FORMAT1 DSCB fields.  In other words, you\ncan alter any attribute of a dataset by changing a field in its VTOC\nentry.  Of course, you could use fullscreen ZAP from this file to zap\nthe VTOC directly, but CDSCB is far less tedious and it eliminates the\npossibility of zapping at the wrong displacement.  Many of the fields\nin the VTOC entry can be changed by name, such as RECFM, LRECL,\nBLKSIZE, secondary allocation (called \"SPACE\"), and many others.  Just\nto cover the rest of the ground, a subcommand to zap at any\ndisplacement, using a \"VER\" and \"REP\" scheme, has been made available\nin CDSCB.  Very powerful stuff.  The command was written by  Bill\nGodfrey.\n\n       Another lovely one is MODREP from File 316.  (A second version\nof MODREP is on File 235.)  This program allows replacement of any LPA\nmodule or SVC on the fly, for testing purposes, and this replacement\ncan be either temporary or be made permanent, to last until the next\nIPL.  Some of the expensive monitoring packages for MVS have a feature\nwhich can do this, but MODREP is free.  You put the replacement module\nin an authorized library and start the MODREP procedure that points to\nthat library.  With MODREP running, you merely enter the console\ncommand:  F MODREP,modname and the module or SVC gets loaded.  If you\nenter the real name of a module first, and then do the aliases one at\na time, the alias names will also be properly loaded.  The new copy is\npage-fixed so it will not disappear by being paged out.  Help members\nhave been provided with both MODREP and CDSCB.\n\n      Here's a goody, originally from IBM, and in ancient days, only\navailable in object code.  Source was created by Bill Godfrey, and we\nare now in possession of the program DELINK, to \"UN-linkedit\" csects.\nYes, Virginia, you start with a LOAD MODULE and end up with an OBJECT\nDECK.  If the load module has more than one csect, you must DELINK one\ncsect at a time.  The source in File 316 is called DELINK0.  I used\nDELINK (to suggest a useful application ) to ISOLATE ALL MY USER SVCs\nfrom an old, running MVS NUCLEUS, so as to make them installable on\nany other nucleus via an IBM-style sysmod.  I had to chop down the\nsize  of the nucleus first, by using many \"REPLACE\" linkedit cards and\nrelinkediting to eliminate most of the other csects in the nucleus.\nWhen only the SVCs and a bit more remained, DELINK was able to isolate\nthe object code for each of the SVCs.  My user SVCs are now all neatly\ntucked away as SMP usermods.\n\n       While we're on the subject of Bill Godfrey's disassembly of old\nIBM utilities, here's an inspiring story.  The program INCORZAP is a\nbatch utility that zaps (and page-fixes) the IN-CORE version of a\nnucleus module or LPA module.  You run it with the same JCL that you\nuse for AMASPZAP, which changes the DISK version of the program, only\nyou EXEC PGM=INCORZAP instead of PGM=AMASPZAP. INCORZAP operates by\nexamining the DISK copy of the load module first.  It figures out the\ncsect pattern of the load module and the displacements using the disk\ncopy, and then proceeds to its load point in virtual storage.\nUtilizing the csect displacement information it obtained from the disk\ncopy of the program, it locates the virtual addresses to be zapped IN\nCORE, and it does the VER and REP things to the copy in CORE.  Then it\nfixes that page of memory so it won't go away.  In order for this to\nwork, you obviously have to have the same version on disk as you have\nin core.\n\n       Now listen to this story.  Bill Godfrey went to the effort of\ndisassembling the object code of INCORZAP and creating documented\nsource, as well as he could.  This source is found on File 316 of the\nCBT tape.  The original author of INCORZAP is Rob Budge, who wrote\nINCORZAP while working for IBM.  Originally, INCORZAP was written in\nPL/S, which is IBM's private higher-level language for system\ndevelopment.  PL/S is not available outside the confines of IBM.\nApparently, when Rob Budge saw Bill Godfrey's disassembly of his\nprogram into the PUBLIC IBM/370 assembler language, he was no longer\nworking for IBM.  With HIS knowledge of the workings of the program,\nBudge was able to improve the code to work on XA as well as MVS/370,\nand to circumvent the segment protection and page protection of main\nstorage which is present on the newer 308x and 309x hardware.  His\nproduct, the beautiful XACORZAP, can now be found on File 421 of the\nCBT tape.  XACORZAP is a complete replacement for INCORZAP, and it\nruns on any MVS release from 3.8 to XA.  Nice.\n\n       Let's conclude with a discussion of TAPE COPY programs.  If you\nwant to do a full tape-to-tape copy, including standard labels if\npresent, the program of choice is the Air Force tape copy program\nCOPYMODS, which is on File 229 of the CBT tape.  COPYMODS will copy\nthe entire tape from beginning to end-of-data, including all labels.\nIt will wipe out whatever was originally on the target tape(s).  From\none input tape, you can make as many as ten copies in one run, if you\nhave enough tape drives.  Arnie Casinghino uses this program to make\nYOUR copy of the CBT tape.  It is very handy.\n\n       Now please note that the COPYMODS program can be fooled in one\nsituation. This is if you have a standard-labeled tape with a NULL\nFILE, that is, one of the files on an SL tape has nothing in it, just\nthe header label and the trailer label.  COPYMODS thinks that this\ncombination is a double tape mark, and considers it as end-of-data.\nThe situation occurs if you did an IEBCOPY unload of a PDS that has NO\nMEMBERS.  (The condition can be revealed by doing  a TAPEMAP of the\ninput tape, using the tape mapping program on File 299.)  Any files\nBEYOND the null file on the input tape are not copied by COPYMODS,\nbecause the program considers them beyond the end-of-data.\n\n       We can get around the problem using another program, which\ndeals with STANDARD LABEL tapes SPECIFICALLY.  This is the COPYFILE\nprogram from File 316 of the CBT tape. COPYFILE works between two\nstandard-label tapes having different names.  You can use it to copy\nSOME, or ALL files, from one tape to the other.  The amazing thing\nwith this program is that it allows you to cut-and-paste.  You can\ncopy files 5, 7, 23, and 55 of the input tape to files 8, 9, 10 and 11\nof the output tape.  You can string together files from several input\ntapes into one big output tape.  You can also customize an output tape\nto send to someone, and create it from various files on a number of\ndifferent input tapes in your tape library, all in one job step.  The\ntape manipulation capability opened up by this tool is mind-boggling,\nespecially when you use TAPEMAP (from File 299) to monitor what you've\nbeen doing.  COPYFILE will get around the problem of the null\nstandard-label file, and will faithfully copy all standard-label files\nfrom an input tape to the output tape.\n\n       So we've come to the end of the discussion for this month.  As\na quick postscript, I'd like to encourage you to also look at the\nLASTIPL TSO command on File 300, and the VTOC program, also on File\n300.  LASTIPL accurately formats and displays on the tube, the date\nand time of the running CPU's last IPL.  You'll never have to ask the\noperators again.  I have LASTIPL in my LOGON clist, and the last IPL\ntime is displayed as soon as I logon to TSO.\n\n       VTOC displays the contents of a disk pack with speed and with\ndazzling versatility and flexibility.  Study the HELP that comes with\nthe VTOC program for some really eye-opening possibilities.\n\n       You can get CBT materials from the web site:\n\n            www.cbttape.org\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CBTINTRO": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x08\\x0f\\x01\\x01\\x03\\x8f\\x14&\\x01$\\x012\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-03-20T00:00:00", "modifydate": "2001-02-07T14:26:00", "lines": 292, "newlines": 306, "modlines": 0, "user": "WSBG"}, "text": "                   PUBLIC MVS SOFTWARE - THE CBT TAPES\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      It is my belief that an MVS shop cannot \"live well\" with IBM's\nofferings alone.  I have a funny feeling that this may be IBM's position\ntoo.  (This statement, believe it or not, is to IBM's praise.)  I hope\nthat the matter will soon become clear to you.\n\n      IBM, in designing the MVS operating system, has been omniscient\nenough to provide a wide variety of system interfaces and system\nservices together with it.  This gives users the opportunity to access\nmany parts of the system and \"hack around\" in them.  Such activities\nare not the exclusive domain of the software vendors.  Anyone can do it.\nIn fact, the vendors do the exact thing we do.  They also write\nassembler-language programs and use the standard interfaces.  IBM is\nusually nice enough to provide helpful and accurate documentation in\nits various manuals, source materials, and fiche.\n\n      So who has taken advantage of this, you say?  Many people sitting\nin MVS installations have, and some of them are very skilled.  Each has\naddressed a need, or a whim, and has written tools for his company and\nfor himself.  If you'll take a tour of MVS shops around your area, I'm\nsure you'll find many programs being used which didn't come from IBM\nand didn't come from vendors.\n\n      Most of them probably didn't come from that shop either.  If so,\nhow did they get there?\n\n      I asked myself that too, and for a long time I didn't know.  It\nwas only after a visit to a friend in his shop, as my mouth hung open\nwatching him do undreamed-of miracles and wonders, that he introduced\nme to the great secret.  He gave me a copy of my first CBT tape.\n\n      Once you've been initiated, tapping into that great gold mine is\nnot that big a deal.  It is a vast collection of public software for\nMVS.  It fills (I mean FILLS) a 2400 foot tape reel.  (This is after\nmost of the stuff has been compressed.)  Its administrator, Arnold\nCasinghino of the Connecticut Bank and Trust Company (hence the name\nCBT) has had to make sweeping deletions on three recent occasions, just\nto have room on the tape for new stuff.  This article aims to guide the\nreader through the tape, and to discuss some of its offerings.\n\n     First things first.  How do you get the CBT Tape materials?\nThey are available at web site:     www.cbttape.org  .\n\n     The tape is non-labeled (NL) and currently has 600 files.  (Yes,\nthat's what I said--six hundred files.)  It is true that some of\nthem are empty.  The first three files are RECFM=FB, LRECL=80,\nBLKSIZE=32720.  These are the key to the rest of the tape.  When I\nget a new tape, I load these first three files onto a PDS\n(appropriately titled PREFIX.CBT.PDS) which has LRECL=80.  File 1 is\nthe documentation.  It describes every file on the tape, and\ndocuments the updates and differences between each level and the\nprevious ones.  File 2 is assembler source for the compress-\ndecompress program used for many of the files on the tape.  File 3 is\nJCL needed to load down the entire tape.  You can customize this JCL\non a separate member of the CBT.PDS to load back a few files at a\ntime.  After doing this, you should print a copy of File 1, and spend\nsome time leafing through it.\n\n     Our aim in the rest of this article is to describe some of the more\nnotable offerings on the tape, at least for getting started.  In future\narticles on this subject, I hope to delve into more of the useful\nproducts and tools you can use.\n\n     In my opinion, the best files to start on are:  300 and 316,\n(Air Force utility collection), 182 and 296 (PDS command product),\nand 299 (tapemap).  File 300 has close to one hundred TSO commands, and\nfile 316 has a like number of batch utilities.  The one thing from file\n300 which every systems programmer should install is the full-screen\nzap program, appropriately called \"ZAP\".  It need only be assembled and\nlink-edited into any load library that your TSO account can get a hold\nof, preferably an authorized one (authorization is only necessary for\nzapping VTOCs).  You get a full-screen view of a few-hundred bytes of\nany disk file, and you can change anything in a jiffy.  There is a\n\"find\" command for any string, hex or EBCDIC, and there are many other\nuseful features.  If you zap a load module, an IDR record with your TSO\nid is created to leave a trail.  A zap log records all the changes.\nTry it.  You'll not only like it--you won't be able to do without it!\nType a question mark \"?\" and you get a full tutorial.  From the\ntutorial, type a \"U\", and you're back where you were.\n\n     File 299 (TAPEMAP program) is another \"indispensable\" one, once\nyou know about it.  It makes possible the complete cataloging and\nquick recall of information from tape libraries, when used together\nwith the PDS command (from file 182).  I'll show you a bit later how to\nset this up.  If you have a private \"tech support\" collection of tapes\n(and who hasn't), you can implement this program to find anything you\nwant from your tape library, quickly.  By the way, the TAPEMAP program\nwill even do what a tapemap program is supposed to do, and tell you\nwhat files are on an individual tape!\n\n     Why is this TAPEMAP program different from all other tapemap\nprograms, you ask?  Because it produces TWO reports.  Report number one\nis not too different from that of other such programs.  It dumps the\ncontents of the labels for labeled tapes, and for non-labeled tapes,\nit will report on the RECFM and blocksizes and number of blocks.  Upon\ncloser examination, you'll see that it's a good deal more thorough than\nother programs in the information it presents.  One of the notable\nextras, and this is important, is that it calculates the length in\nfeet, quite accurately, of each file.  It also reports on the total\nlength in feet, taken up by all files up to the end of the current\nfile.  If the tape had a bad spot, the first report will also interpret\nall the bits in the sense information.\n\n     We haven't gotten there yet with this TAPEMAP.  Its capabilities\nare far greater.  As it reads the tape, the program will examine each\nfile for conformity to one of 10 or 11 different formats:  IEBCOPY,\nIEBUPDTE, FDR, SMPPTFIN, and others.  If the format of a tape file is\nknown to the program, its name appears in Report One, but for many of\nthe special formats, the NAMES OF ALL THE PDS MEMBERS (in the case of\nIEBCOPY or IEBUPDTE), or the PTF NUMBERS (in the case of SMPPTFIN) are\nLISTED in Report TWO.  An FDR backup tape produces a COMPAKTOR-like\nlisting of the backed-up files, in REPORT TWO.  You can really find out\nwhat's on a tape.  You can see if a missing module appeared on last\nmonth's tape, before a change was made, for example.  The answer is\nobtained by merely reading through the tape.  You don't have to go to\nthe trouble of dumping the contents.\n\n     Taking this a step further, suppose you have a private tape\nlibrary, and you want to inquire about a tape.  Or, you have a file\non a tape somewhere and you don't know what tape it's on.  STORING\nTHESE TAPEMAPS ON DISK will help you.  Now think a moment.  What is\nan efficient way to store the maps on disk?  You can put them on a PDS,\nor on a PANVALET library or its equivalent.  You can then use ISPF\nbrowse or edit to search the members.  In the case of PANVALET or\nequivalent, if you had an ISPF interface, this would amount to the same\nthing.  If you knew which member to look at, you'd eventually find out\nabout the tape contents without having to mount a tape.\n\n     We haven't arrived at a really efficient tape library inquiry\nsystem yet.  Suppose that you mapped each tape in your library to two\nPANVALET members, or to two members of a \"tapemap pds\" whose names\nreflect the VOLSER of the tape being mapped.  Remember that the record\nlength of the file is 133 for the reports on disk.  A SCAN of these\nmembers to look for a file name or a module name would quickly yield\nthe desired results.  The PANVALET ++SCAN option (of the PAN#8 program)\ncan be run.  This is fine if your shop has PANVALET, but it's also\nslow.  In the case of the \"tapemap pds\", a faster (and FREE)\nalternative is available with the PDS program from file 182 of the CBT\ntape.  You can search the members of the \"map pds\" ONLINE, with short\nresponse time, and this results in a FULL TAPE LIBRARY INQUIRY SYSTEM.\n\n     The PDS command from file 182, about which we will talk at length,\nhas as one of its features a \"global find\" capability which locates a\ngiven string in an entire pds library, or in a subset of members.  (The\nfeature is so powerful that an entire pds of any block size or RECFM\nmay be searched.)  If you have the PDS program pointing to your\n\"tapemap pds\", and you issue a PDS subcommand of the type:\n              FIND : /string/\nyou will quickly get a report of all members of the \"tapemap pds\" which\ncontain the string, and you'll graphically see all the occurrences of\nthe name you searched for.  This will yield which tape(s) and which\nfile(s) you have to load.  Once the PDS program is set up, our tape\nlibrary inquiry system will be complete.  (At this writing, I have\nheard that the newest version of ISPF from IBM has a \"global find\"\nalso, but this does not detract from the worthiness of PDS, which is\nextremely multi-faceted.)\n\n     From here, it doesn't take much to figure out that you could now\nfind source modules on the IBM symbolic (source module) tapes, which\nare in IEBUPDTE format.  You can also locate any PTF on your PUT TAPES\nwith the greatest of ease, if this is set up.  This is not to mention\nyour system backups and private backups.  There are a lot of\npossibilities.  See file 188 on the CBT tape for an example of how\nto retrieve IBM machine-readable source.  I must therefore talk about\nthe inquiry tool, the PDS command product, to complete the picture.\nBut meanwhile, before you set up PDS, you can start using TAPEMAP to\nfind out what's on your individual tapes.  Just run it and get the\nreports on paper.\n\n     The PDS command from file 182 and 296 merits an entire article by\nitself, maybe even two or three or four installments.  It is probably\nthe biggest single piece of software on the CBT tape.  Although it's\nfree, if it sold for money, it would sell for a lot of money.  I have\ntaught a two-day course to INTRODUCE the TSO user to PDS.  It is a world\nin itself, and it incorporates the function of a hundred separate\nutilities into one package.\n\n     PDS is an outgrowth of an old utility called \"PDS\", or \"LPDS\",\nwhich does certain functions in partitioned data sets, and which is\nquite widespread in MVS shops.  The original version was written at THE\nFIREMEN'S FUND in 1972.  You can rename, delete, list, or add an alias\nto a pds member.  You can map load modules or view the linkedit history\nof their component csects.  These functions are useful, and the program\nin its original form is still a popular tool.  The current program, now\nat version 8.1, has thirty-fold more function, but it still has all the\nold function of the original program.  Bruce Leland and Steve Smith, in\nCalifornia, support PDS expertly.  (Their addresses and phone numbers\nare on the CBT tape.)  I will try here to do the difficult job of\ntelling you in a short space what the new PDS is about.  Perhaps a\nlonger article will follow later.\n\n     PDS manipulates partitioned or sequential datasets.  It can do\nalmost ANYTHING to them.  Besides incorporating utility functions, such\nas finding strings, listing attributes of members, renaming members,\nassigning load module attributes, etc., it has the great strength of\ndealing with GROUPS of members together, in one shot.  For example, you\ncan delete or rename all members beginning with the letters ADR.  You\ncan also select all load modules containing a company's logo, for\nexample, so if you have a vendor's package installed, and he puts his\nlogo on all the load modules, you can delete them or copy them to\nanother dataset all at once.  This just gives you a taste of how\npowerful PDS is.  It is the tiniest tip of the iceberg.  I have used\nPDS for two years.  I have given a course on it, and I have yet to\nfathom it to its depths.  I haven't even come close.\n\n     To install PDS quickly, you can copy its load module from file 35\nof the CBT tape into one of your TSO load libraries.  This will only\nget you \"line-mode\".  To get \"ISPMODE\", you have to copy its ISPF\npanels and messages into your ISPF libraries from file 182.  There is a\njob on file 182 that does this all at once.  A proper installation from\nfiles 182 and 296 is much better.  PDS has many \"generation options\",\nand you should examine the #PDSGEN options member on file 182\ncarefully.  Follow the installation instructions to the letter, and\nyou'll be pleased with the result.  You can call the authors (phone\nnumbers are listed on the file) or you can call me (file 428 or any of\nmy other files) if you want help.\n\n     When you execute PDS, you must point it at a dataset, which can be\neither partitioned or sequential.  There must always be a \"current\ndataset\", but once you are in PDS, the current dataset can be changed\neasily with a \"change\" subcommand.  PDS operates in two modes.  They\nare called \"line-mode\" and \"ISPMODE\".  PDS in line-mode is purely a\nTSO command processor, with the results of the subcommands going to the\nterminal (the SYSTSPRT ddname).  In ISPMODE, PDS is an ISPF dialog,\nwith results of the subcommands going to a special scrollable log,\nwhich occupies the bottom of the screen.  PDS can also be run in\nline-mode under TSO IN BATCH.\n\n     Most of the line-mode functions of PDS are also available under\nISPMODE.  In ISPMODE, PDS is a full dialog, such as SPFEDIT is, for\nexample, but it is far more inclusive and has much more function\nincluded in the dialog.  There are approximately 48 options, or\n\"subcommands\", and most of these have myriad variations and multiple\nfunctions.  There is a 6000-line TSO help member, but if PDS is\nproperly installed, with all the utilities from file 296, there is a\nfull-screen help facility that is quick.  (Installation hint:  The\nhelp member must be called PDS81 - in the current level PDS 8.1 -\nfor this to work properly.)\n\n     Why ISPMODE?  For one thing, ISPMODE has a log of all the PDS\ncommands and their results, that came during the current session.  This\nlog can be browsed and scrolled in its entirety, and it can be spliced\nand/or copied to a dataset.  Then there is MEMLIST in ISPMODE, which\nprovides a list of all or some of the PDS members.  This may not seem\nlike much at first glance, but there are over 20 options that you\ncan exercise from this member list.  You can BROWSE or SPFEDIT or\nRENAME from the same list, without having to go to a different list,\nas in normal ISPF.  Once you are familiar, you will see that the\npossibilities go much farther.  ISPMODE has two other modes:  LISTA,\nwhich lists the datasets and ddnames allocated to your session,\nand LISTV, which lists mounted disk volumes and their attributes.\nPDS version 8.1 provides four separate ISPF tables for these four\nmodes, and you can easily switch from one to another.  Steve Smith,\nwho supports the ISPMODE part of PDS, tells me that he plans other\nISPMODE functions in future releases of PDS.\n\n     Now, to complete our tape library inquiry system, suppose for\nexample that all our tapes were mapped into the pds called TAPELIB.MAPS.\nSuppose for simplicity that we have one tape, called MYTAPE, mapped\nwith TAPEMAP, and the two reports were copied into TAPELIB.MAPS.\nREPORT ONE was copied to member MYTAPE, and REPORT TWO was copied to\nmember MYTAPEM.  The tape has five files on it in IEBCOPY format,\nand there is a module called IEFAB4B0 on file 3.  We would get\ninto PDS in ISPMODE by entering:\n        PDS 'TAPELIB.MAPS' ISPMODE\nfrom TSO READY.  (This requires that the ISPF panels and messages in\nCBT tape file 182 have been copied to your appropriate libraries.)\nYou will see the ISPMODE header and the ISPMODE log on your screen.\nThen we enter:\n        FIND : /IEFAB4B0/\nThis will yield a report in the log, detailing on which maps the\nmodule IEFAB4B0 appears.  A quick BROWSE or EDIT of the member\nMYTAPEM, done by entering from the command line:\n        B MYTAPEM  or  E MYTAPEM     followed by\n        F IEFAB4B0\nwhile in the browse or edit, will show that IEFAB4B0 is on file 3.\n\n     We shall postpone more detailed discussion of PDS for future\narticles.  I hope to have achieved the purpose here, of giving you a\nglimpse at how tremendously useful the free software on the CBT tape\ncan be.\n\n\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEFACTRT": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87\\x12\\x7f\\x01\\x01\\x06_\\x18\\x11\\x05\\xfa\\x06\\x05\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-05-07T00:00:00", "modifydate": "2001-03-06T18:11:00", "lines": 1530, "newlines": 1541, "modlines": 0, "user": "WSBG"}, "text": "IEFACTRT TITLE 'SMF JOB/STEP TERMINATION EXIT ROUTINE     '\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = IEFACTRT                                  *\n*                                                                     *\n*             DESCRIPTIVE NAME =  SMF EXIT ROUTINE TO PRINT JOB       *\n*                STATS IN JCL LOG AT END OF STEP AND JOB              *\n*                                                                     *\n*             COPYRIGHT = NONE                                        *\n*                                                                     *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 DEPENDENCIES = CHARACTER SET IS EBCDIC.  REASSEMBLE *\n*                    IF A DIFFERENT CHARACTER SET IS NEEDED.          *\n*                                                                     *\n*                 RESTRICTIONS = NONE                                 *\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0 TO 1  = PARAMETER REGISTERS ON ENTRY *\n*                    REGISTERS 2 TO 5  = UNUSED                       *\n*                    REGISTER  6       = OUTPUT LINE REGISTER         *\n*                    REGISTER  7       = COMMON PARAMETER AREA        *\n*                    REGISTERS 8 TO 10 = UNUSED                       *\n*                    REGISTER  11      = BASE REGISTER FOR CSECT      *\n*                    REGISTER  12      = POINTER TO IEFYS INTERFACE   *\n*                                        PARMS(PASSED UPON ENTRY)     *\n*                    REGISTER  13      = ADDRESSIBILITY TO SAVEAREA   *\n*                    REGISTERS 14,15   = WORK REGISTERS               *\n*                                                                     *\n*        R0 AND R1 WORK REGISTERS                                     *\n*        R2    WORK                                                   *\n*        R3    WORK                                                   *\n*        R4    WORK                                                   *\n*        R5    WORK                                                   *\n*        R6    PRINTLINE BASE REG                                     *\n*        R7    LINK                                                   *\n*        R8    WORKAREA BASE REG                                      *\n*        R9    SMF RECORD BASE REG                                    *\n*        R10   PARMLIST POINTER                                       *\n*        R12   SECOND BASE                                            *\n*        R13   SPECIAL WORK                                           *\n*        R15   SMF RECORD SUB SEGMENT BASE                            *\n*              AND ENTRY POINT ADDRESS TO IEFYS                       *\n*                                                                     *\n*                PATCH LABEL = PATCH (UNUSED AND INTIALIZED TO        *\n*                   BINARY ZEROES)                                    *\n*                                                                     *\n*             MODULE TYPE = PROCEDURE                                 *\n*                                                                     *\n*                PROCESSOR = ASM                                      *\n*                                                                     *\n*                MODULE SIZE =                                        *\n*                                                                     *\n*                ATTRIBUTES = KEY 0, REENTRANT,                       *\n*                   SUPERVISOR STATE, ENABLED, NO LOCKS HELD          *\n*                                                                     *\n*             ENTRY POINTS = IEFACTRT (ONLY ENTRY POINT)              *\n*                                                                     *\n*                LINKAGE =                                            *\n*                                                                     *\n*                                                                     *\n*             INPUT = REG1 POINTS TO LIST OF FULLWORD ADDRESSES       *\n*                     AS FOLLOWS.                                     *\n*                 1.  PTR TO COMMON EXIT PARAMETER AREA               *\n*                 2.  PTR TO STEPNAME FIELD                           *\n*                 3.  PTR TO PROGRAMMER NAME FIELD                    *\n*                 4.  PTR TO JOB CPU TIME FIELD                       *\n*                 5.  PTR TO JOB ACCOUNTING FIELDS                    *\n*                 6.  PTR TO STEP CPU TIME FIELD                      *\n*                 7.  PTR TO STEP ACCOUNTING FIELDS                   *\n*                 8.  PTR TO CANCEL FLAG & STEP NUMBER                *\n*                 9.  PTR TO CONDITION CODE FIELD                     *\n*                10.  PTR TO SMF RECORD TO BE WRITTEN                 *\n*                                                                     *\n*             OUTPUT = NONE                                           *\n*                                                                     *\n*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXIT - ERROR = NONE                                     *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXTERNAL REFERENCES =                                   *\n*                                                                     *\n*                ROUTINES = NONE                                      *\n*                                                                     *\n*                DATA AREAS = NONE                                    *\n*                                                                     *\n*                CONTROL BLOCKS = NONE                                *\n*                                                                     *\n*             TABLES = NONE                                           *\n*                                                                     *\n*             MACROS = SAVE, RETURN, GETMAIN, FREEMAIN,               *\n*                      IFASMFR, IEFJMR,                               *\n*                                                                     *\n*             CHANGE ACTIVITY = NONE                                  *\n*                                                                     *\n*             MESSAGES =                                              *\n*                STEP TERMINATION LINE AND JOB TERMINATION LINE.      *\n*                                                                     *\n*             ABEND CODES = NONE                                      *\n*                                                                     *\n***********************************************************************\n         TITLE 'IEFACTRT HOUSEKEEPING'\nIEFACTRT CSECT\nIEFACTRT AMODE 31\nIEFACTRT RMODE ANY\n         SAVE  (14,12)\n         USING IEFACTRT,R11,R12    SET UP CSECT ADDRESSABILITY\n         LR    R11,R15             LOAD BASE REGISTER\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        DETERMINE REASON FOR ENTRY  CODE 20 CONTINUE                 *\n*                                    CODE 12, 16, 24 EXIT             *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         LR    R9,R0              SAVE R0 FOR LATER USAGE\n         C     R0,=F'20'           NOT INTERESTED IN CODES OTHER THAN\n         BE    CONTINUE            20\n         C     R0,=F'00123456'    ANNA'A SPECIAL TEST GARBAGE ?\n         BNE   RETURN             NO, GO ON HOME\nCONTINUE LR    R10,R1              SAVE PARM LIST ADDRESS\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*GET STORAGE FOR WORK AREA AND SAVE REGS                              *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         GETMAIN R,LV=WORKEND-WORKSTRT   STORAGE FOR WORKAREA DSECT\n         LR    R8,R1               SAVE GETMAINED STORE ADDRESS\n         USING WORKAREA,R8         ESTABLISH ADDRESSABILITY TO IT\n         LR    R1,R13              SAVE OS SAVEAREA\n         LA    R13,SAVEAREA        LOAD ADDRESS OF OUT SAVEAREA\n         ST    R13,8(R1)           SAVE OUR SAVEAREA IN OS LSA\n         ST    R1,4(R13)           SAVE OS SAVEAREA IN OUR HSA\n         ST    R12,R12SAVE         SAVE PARMS ADDRESS\n         ST    R9,R0SAVE           SAVE R0\n         LA    R12,4095(R11)       ESTABLISH SECOND ABSE\n         LA    R12,1(R12)\n         USING PARMS,R10           SET UP ADDRESSABILITY TO PARM LIST\n         L     R9,PARMRECD         LOAD ADDRESS OF SMF RECORD\n         CLC   R0SAVE,=F'00123456' TEST MODE?\n         BNE   STEPJOB             NO, DON'T DO OPEN\n         MVC   SYSPRINT(SYSPRTED-SYSPRTDC),SYSPRTDC  SET UP DCB IN WORK\n         MVC   OPENL(OPENLDCE-OPENLDC),OPENLDC        SET UP OPEN LIST\n         OPEN  (SYSPRINT,(OUTPUT)),MF=(E,OPENL)    USED FOR TESTING\n         SPACE 4\n***********************************************************************\n*                                                                     *\n*        DETERMINE IF JOB TERMINATION OR STEP TERMINATION             *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         USING SMFRCD30,R9         ESTABLISH ADDRESSABILITY TO RECORD\nSTEPJOB  CLI   SMF30SON+1,X'01'    CHECK IF SSSEGMENT IS THERE\n         BL    EXIT1               NO - EXIT\n         LR    R15,R9               GET RECORD ADDRESS\n         A     R15,SMF30SOF         POINT TO SS SEGMENT\n         USING SMF30PSS,R15         ESTABLISH ADDRESSABILITY\n         CLC   SMF30TYP,R30JOB     WAS IT JOB TERMINATION\n         BE    JOBEND              YES\n         CLC   SMF30TYP,R30STEP    WAS IT STEP TERMINATION\n         BE    STEPEND             YES\n         B     EXIT1               NO - EXIT\n         DROP  R15\n         TITLE 'STEP END PROCESSING'\n***********************************************************************\n*    STEP END PROCESSING                                              *\n***********************************************************************\n         SPACE 2\nSTEPEND  EQU   *\n         L     R1,16              CVT POINTER\n         L     R1,0(,R1)          GET TCB POINTER\n         L     R1,4(,R1)          GET CURRENT TCB ADDRESS\n         L     R1,180(,R1)        GET ADDRESS OF JSCB\n         L     R1,260(,R1)        GET JCT PREFIX ADDRESS\n*        TM    23(R1),X'80'       MSGLEVEL=(,1)\n*        BNO   EXIT1                NO EXIT  MSGLEVEL=(,0)\n         MVC   WTOANP02(WTO02END-WTOSTC02),WTOSTC02\n         MVI   PRTLINE,C' '        SET UP CLEAR\n         MVC   PRTLINE+1(L'PRTLINE-1),PRTLINE\n         BAS   R7,PUTLINE          BLANK LINE\n         MVC   PRTLINE,BASELINE    SET UP ROW OF *'S\n         MVC   PRTLINE+1(L'PRTLINE-1),PRTLINE\n         LA    R1,PRTLINE+46       LOAD ADDRESS FOR HEADER GEN\n         BAS   R7,HDRSETP          GO SET UP HEADER\nCKUSER1  BAS   R7,PUTLINE                           AND GO PRINT IT\n         MVC   PRTLINE,BASELINE                     SET UP A SEPARATOR\n         BAS   R7,PUTLINE                           LINE AND PRINT\n         SPACE 2\n***********************************************************************\n* BUILD AND PRINT HEADER FOR STEP END:                                *\n*                                                                     *\n*  OS/MVS    STATISTICS FOR STEP 001 - STEPNAME    STEP COND CODE XX  *\n***********************************************************************\n         SPACE 2\n         LA    R6,PRTLINE          SET BASE FOR PRTLINE DSECT\n         USING SH1,R6\n         MVC   SHEAD1(L'USERID),USERID       MOVE USER IDENTIFICATION\n         L     R15,16               GET CVT POINTER\n         LA    R7,24                RELOCATION FACTOR\n         SR    R15,R7\n         CLC   0(8,R15),BINZERO     CHECK FOR ZEROS\n         BE    *+10\n         MVC   SHEAD1A(16),0(R15)            USER SYSTEM DESC.\n         MVC   SHEAD11A(L'IPSTEP),IPSTEP     STEP END  CONSTANT\n         CLI   SMF30ION+1,X'01'        IDENTIFICATION SEGMENT PRESENT\n         BL    STEP1                   NO BYPASS INFORMATION\n         LR    R15,R9                        SMF RECORD ADDRESS\n         A     R15,SMF30IOF              IDENTIFICATION SEGMENT OFFSET\n         USING SMF30ID,R15              ESTABLISH ADDRESSABILITY\n         SR    R2,R2                         GET STEP NUMBER\n         IC    R2,SMF30STN+1                  INTO R3\n         CVD   R2,TEMP                       TO EBCDIC\n         MVC   SHEAD11A+L'IPSTEP(4),=X'40202120'\n         ED    SHEAD11A+L'IPSTEP(4),TEMP+6\n         MVC   ANP02ST#,SHEAD11A+L'IPSTEP    MOVE INTO WTO MESSAGE\n         MVI   SHEAD11A+L'IPSTEP+5,C'-'\n         MVC   SHEAD11A+L'IPSTEP+7(8),SMF30STM  MOVE STEP NAME\n         MVC   ANP02JBN,SMF30JBN             MOVE INTO WTO MESSAGE\n         MVC   ANP02STN,SMF30STM             MOVE INTO WTO MESSAGE\n         MVC   STEPCL,CONDLINE\n         DROP  R15\nSTEP1    EQU   *\n         CLI   SMF30TON+1,X'01'    COMPLETION SEGMENT PRESENT\n         BL    PRTCOND              NO BYPASS INFORMATION\n         LR    R15,R9                     SMF RECORD ADDRESS\n         A     R15,SMF30TOF            COMPLETION SEGMENT OFFSET\n         USING SMF30CMP,R15           ESTABLISH ADDRESSABILITY\n         TM    SMF30STI,X'01'       WAS STEP FLUSHED ?\n         BZ    CONNORM             NO,CONDITION NORMAL\n         MVC   STEPFLSH(11),=C'WAS FLUSHED'  CONDITION ABNORMAL\n         B     PRTCOND\nCONNORM  EQU   *\n         CLC   SMF30SCC(2),X'0000'  CONDITION CODE ZERO ?\n         BNE   CONNZERO\n         MVC   STEPCOND,=C'0000'   CONDITION NORMAL\n         B     PRTCOND\nCONNZERO TM    SMF30STI,X'02'       ABEND ??\n         BO    CONABEND            YES\n         LH    R2,SMF30SCC          NO, HANDLE STEP COMPLETION CODES\n         CVD   R2,TEMP             *\n         MVC   STEPCOND-1(6),=X'402020212020'\n         ED    STEPCOND-1(6),TEMP+5\n         B     PRTCOND\n         SPACE 1\nCONABEND MVC   STEPFLSH(7),=C'ABEND ('\n         TM    SMF30SCC,X'80'       USER ABEND ??\n         BZ    SYSABEND            NO SYSTEM ABEND\n         MVC   STEPFLSH+7(6),=C'USER) '\n         MVC   ANP02UAT,=C'USER  '\n         LH    R2,SMF30SCC\n         N     R2,=A(X'FFF')       TURN OFF FLAGS\n         CVD   R2,TEMP\n         MVC   STEPFLSH+13(6),=X'402120202020'\n         ED    STEPFLSH+13(6),TEMP+5\n         MVC   ANP02UAB,STEPFLSH+13\n         CLI   SMF30ION+1,X'01'     IS ID SECTION PRESENT?\n         BL    PRTCOND              NO, SKIP MESSAGE\n         LR    R15,R9\n         A     R15,SMF30IOF\n         USING SMF30ID,R15\n         CLI   SMF30CLS,C' '        IS THIS A BATCH JOB?\n         BE    PRTCOND              NO, SKIP PRINTING MESSAGE\n         DROP  R15\n         LA    R1,WTOANP02          ISSUE ANP002I MESSAGE\n         WTO   MF=(E,(1))\n         B     PRTCOND\n         SPACE 1\nSYSABEND DS    0H\n         USING SMF30CMP,R15           ESTABLISH ADDRESSABILITY\n         UNPK  TEMP(5),SMF30SCC(3)  DISPLAY SYSTEM CODE IN HEX\n         MVC   STEPFLSH+7(8),=C'SYSTEM) '\n         MVC   ANP02SAT,=C'SYSTEM'\n         TR    TEMP+1(3),TOHEX-C'0'\n         MVC   STEPFLSH+15(3),TEMP+1\n         MVC   ANP02SAB,STEPFLSH+15\n         MVC   ANP02SBL,=C'   '\n         CLI   SMF30ION+1,X'01'     IS ID SECTION PRESENT?\n         BL    PRTCOND              NO, SKIP MESSAGE\n         LR    R15,R9\n         A     R15,SMF30IOF\n         USING SMF30ID,R15\n         CLI   SMF30CLS,C' '        IS THIS A BATCH JOB?\n         BE    PRTCOND              NO, SKIP PRINTING MESSAGE\n         DROP  R15\n         LA    R1,WTOANP02\n         WTO   MF=(E,(1))\n         SPACE 1\nPRTCOND  BAS   R7,PUTLINE          GO PRINT 1ST LINE\n         MVC   PRTLINE,BASELINE              PREPARE SPACER\n         BAS   R7,PUTLINE                    AND PRINT\n         SPACE 2\n***********************************************************************\n*  FIRST STEP REPORT LINE                                             *\n***********************************************************************\n         SPACE 2\n         MVC   PRTLINE,STEPLN1     1ST INFO LINE\n         CLI   SMF30ION+1,X'01'       IDENTIFICATION SEGMENT PRESENT\n         BL    FRSTLNE                  NO BYPASS INFORMATION\n         LR    R15,R9                         SMF RECORD ADDRESS\n         A     R15,SMF30IOF              IDENTIFICATION SEGMENT OFFSET\n         USING SMF30ID,R15              ESTABLISH ADDRESSABILITY\n         MVC   SLN1P(,R6),SMF30PGM  PGM NAME\n         MVC   TIME,SMF30SIT        STEP INIT TIME\n         LA    R5,SLN1I(R6)        SET UP PARAMETERS\n         BAL   R7,TIMEX\n         DROP  R15\nFRSTLNE  EQU   *\n         CLI   SMF30CON+1,X'01'    PROCESSOR ACCOUNTING SEGMENT PRESENT\n         BL    FRSTLNE0              NO BYPASS INFORMATION\n         LR    R15,R9                         SMF RECORD ADDRESS\n         A     R15,SMF30COF        PROCESSOR ACCOUNTING SEGMENT OFFSET\n         USING SMF30CAS,R15              ESTABLISH ADDRESSABILITY\n         L     R2,SMF30CPT         GET STEP CPU TIME\n         ST    R2,TIME              CPU TIME\n         LA    R5,SLN1TC(R6)       *\n         BAL   R7,TIMEX1           *\n         DROP  R15\nFRSTLNE0 CLI   SMF30PON+1,X'01'    PERFORMANCE SEGMENT PRESENT\n         BL    FRSTLNE1              NO BYPASS INFORMATION\n         LR    R15,R9              GET SMF RECORD ADDRESS\n         A     R15,SMF30POF        PERFORMANCE SEGMENT OFFSET\n         USING SMF30PRF,R15        ESTABLISH ADDRESSABILITY\n         L     R1,SMF30SRV           TOTAL SERVICE\n         BAS   R14,PCOUNT\n         MVC   SLN1TOTS(5,R6),TEMP+3\n         L     R1,SMF30CSU         CPU SERVICE\n         BAS   R14,PCOUNT\n         MVC   SLN1TCS(5,R6),TEMP+3\n         DROP  R15\nFRSTLNE1 BAS   R7,PUTLINE          GO PRINT STEP STATS -- LINE 1\n         SPACE 2\n***********************************************************************\n* BUILD AND PRINT 2ND LINE                                            *\n***********************************************************************\n         SPACE 2\n         MVC   PRTLINE,STEPLN2\n         BAL   R7,GETTIME           GET CURRENT TIME FOR STEP END\n         L     R0,TIMEND            GET TIME GOTTEN INTO\n         ST    R0,TIME              TIME FOR CALL\n         LA    R5,SLN2END(R6)      *\n         BAL   R7,TIMEX            *\n         CLI   SMF30RON+1,X'01'     STORAGE AND PAGING SEGMENT PRESENT\n         BL    SECDLNE              NO BYPASS INFORMATION\n         LR    R15,R9                         SMF RECORD ADDRESS\n         A     R15,SMF30ROF          STORAGE AND PAGING SEGMENT OFFSET\n         USING SMF30SAP,R15              ESTABLISH ADDRESSABILITY\n         L     R1,SMF30URB         * PRIVATE STOR BELOW 16 M\n         BAS   R14,HCOUNT\n         MVC   SLN2PRBL(6,R6),TEMP+2\n         L     R1,SMF30EUR         * PRIVATE STOR ABOVE 16 M\n         BAS   R14,HCOUNT\n         MVC   SLN2PRAB(6,R6),TEMP+2\n         L     R1,SMF30NSW          TOTAL SWAPS\n         BAS   R14,PCOUNT\n         MVC   SLN2SWAP(5,R6),TEMP+3\n         DROP  R15\nSECDLNE  EQU   *\n         CLI   SMF30CON+1,X'01'    PROCESSOR ACCOUNTING SEGMENT PRESENT\n         BL    SECDLNE1              NO BYPASS INFORMATION\n         LR    R15,R9                         SMF RECORD ADDRESS\n         A     R15,SMF30COF        PROCESSOR ACCOUNTING SEGMENT OFFSET\n         USING SMF30CAS,R15              ESTABLISH ADDRESSABILITY\n         L     R2,SMF30CPS          SRB CPU TIME\n         ST    R2,TIME\n         LA    R5,SLN2SRBC(R6)\n         BAL   R7,TIMEX1           *\n         DROP  R15\nSECDLNE1 EQU   *\n         CLI   SMF30PON+1,X'01'      PERFORMANCE SEGMENT PRESENT\n         BL    SECDLNE2               NO BYPASS INFORMATION\n         LR    R15,R9                         SMF RECORD ADDRESS\n         A     R15,SMF30POF          PERFORMANCE SEGMENT OFFSET\n         USING SMF30PRF,R15              ESTABLISH ADDRESSABILITY\n         L     R1,SMF30SRB          SRB SERVICE\n         BAS   R14,PCOUNT\n         MVC   SLN2SRBS(5,R6),TEMP+3\n         DROP  R15\nSECDLNE2 BAS   R7,PUTLINE\n         SPACE 2\n***********************************************************************\n* BUILD AND PRINT 3RD LINE                                            *\n***********************************************************************\n         SPACE 2\n         MVC   PRTLINE,STEPLN3\n         CLI   SMF30RON+1,X'01'     STORAGE AND PAGING SEGMENT PRESENT\n         BL    THRDLNE              NO BYPASS INFORMATION\n         LR    R15,R9                         SMF RECORD ADDRESS\n         A     R15,SMF30ROF          STORAGE AND PAGING SEGMENT OFFSET\n         USING SMF30SAP,R15              ESTABLISH ADDRESSABILITY\n         L     R1,SMF30ARB         * LSQA/SWA STOR BELOW 16 M\n         BAS   R14,HCOUNT\n         MVC   SLN3SPBL(6,R6),TEMP+2\n         L     R1,SMF30EAR         * LSQA/SWA STOR ABOVE 16 M\n         BAS   R14,HCOUNT\n         MVC   SLN3SPAB(6,R6),TEMP+2\n         L     R1,SMF30PSC+4       PAGE SECONDS (MILLSECS)\n         BAS   R14,PCOUNT\n         MVC   SLN3PS(8,R6),TEMP\n         L     R1,SMF30PSI          SWAP PAGES IN\n         BAS   R14,PCOUNT\n         MVC   SLN3SPI(5,R6),TEMP+3\n         DROP  R15\nTHRDLNE  CLI   SMF30PON+1,X'01'    PERFORMANCE SEGMENT PRESENT\n         BL    THRDLNE1            NO BYPASS INFORMATION\n         LR    R15,R9              GET SMF RECORD ADDRESS\n         A     R15,SMF30POF        PERFORMANCE SEGMENT OFFSET\n         USING SMF30PRF,R15        ESTABLISH ADDRESSABILITY\n         MVC   TIME,SMF30TAT        STEP ACTIVE TIME\n         LA    R5,SLN3AT(R6)       SET UP PARAMETERS\n         BAL   R7,TIMEX2\n         L     R1,SMF30IO          I/O SERVICE\n         BAS   R14,PCOUNT\n         MVC   SLN3IOS(5,R6),TEMP+3\n         DROP  R15\nTHRDLNE1 EQU   *\n         BAS   R7,PUTLINE          GO PRINT 3RD LINE\n         SPACE 2\n***********************************************************************\n* BUILD AND PRINT 4TH LINE                                            *\n***********************************************************************\n         SPACE 2\n         MVC   PRTLINE,STEPLN4\n         CLI   SMF30RON+1,X'01'    STORAGE AND PAGING SEGMENT PRESENT\n         BL    FRTHLNE             NO  BYPASS INFORMATION\n         LR    R15,R9              GET SMF RECORD ADDRESS\n         A     R15,SMF30ROF        STORAGE AND PAGING SEGMENT OFFSET\n         USING SMF30SAP,R15        ESTABLISH ADDRESSABILITY\n         L     R1,SMF30RGN          REGION SIZE\n         SLA   R1,10               ADJUST REGION TO BYTES\n         BAS   R14,HCOUNT\n         MVC   SLN4RG(6,R6),TEMP+2\n         L     R1,SMF30PST         PAGES STOLEN\n         BAS   R14,PCOUNT\n         MVC   SLN4PS(8,R6),TEMP\n         L     R1,SMF30PSO          SWAP PAGES OUT\n         BAS   R14,PCOUNT\n         MVC   SLN4SPO(5,R6),TEMP+3\n         DROP  R15\nFRTHLNE  EQU   *\n         CLI   SMF30PON+1,X'01'    PERFORMANCE SEGMENT PRESENT\n         BL    FRTHLNE1            NO  BYPASS INFORMATION\n         LR    R15,R9              GET SMF RECORD ADDRESS\n         A     R15,SMF30POF        PERFORMANCE SEGMENT OFFSET\n         USING SMF30PRF,R15        ESTABLISH ADDRESSABILITY\n         MVC   TIME,SMF30RES       STEP RESIDENCY TIME\n         LA    R5,SLN4RT(R6)       SET UP PARAMETERS\n         BAL   R7,TIMEX2\n         L     R1,SMF30MSO          MSO SERVICE\n         BAS   R14,PCOUNT\n         MVC   SLN4MSO(5,R6),TEMP+3\n         DROP  R15\nFRTHLNE1 BAS   R7,PUTLINE          GO PRINT 4TH LINE\n         SPACE  2\n***********************************************************************\n* BUILD INTERMEDIATE HEADER FOR I/O EXCP COUNTS                       *\n***********************************************************************\n         SPACE 2\n         MVC   PRTLINE,BASELINE    SET SPACERS\n         BAS   R7,PUTLINE          PUT OUT\n         SPACE 1\n         CLI   SMF30TON+1,X'01'    COMPLETION SEGMENT PRESENT\n         BL    EXCP1              NO  BYPASS INFORMATION\n         LR    R15,R9              GET SMF RECORD ADDRESS\n         A     R15,SMF30TOF        COMPLETION SEGMENT OFFSET\n         USING SMF30CMP,R15        ESTABLISH ADDRESSABILITY\n         TM    SMF30STI,X'01'       WAS STEP FLUSHED ?\n         BO    EXIT                YES. NO EXCP-S\n         DROP  R15\n         SPACE 1\n         USING SH2,R6              SET BASE\nEXCP1    EQU   *\n         MVC   SHEAD2,EXCPSTAT        GET HEADING IN THERE\n         BAS   R7,PUTLINE             AND PRINT IT\n         MVC   PRTLINE,BASELINE       PRINT SEPARATOR\n         BAS   R7,PUTLINE             LINE\n         MVI   SUPSW,X'00'            INITIALIZE SUPPRESSION SWITCH\n         SPACE 3\n***********************************************************************\n* CONSTRUCT I/O EXCP COUNTS (7  ENTRIES PER LINE)                     *\n***********************************************************************\n         SPACE 2\n         CLI   SMF30EON+1,X'01'    EXCP SEGMENT PRESENT\n         BL    CNTDONE             NO BYPASS INFORMATION\n         LR    R15,R9              GET SMF RECORD ADDRESS\n         A     R15,SMF30EOF        EXCP SEGMENT OFFSET\n         USING SMF30EXP,R15        ESTABLISH ADDRESSABILITY\n         LH    R4,SMF30EON         NUMBER OF EXCP SEGMENTS\n         LA    R2,SMF30DEV          GET START OF ENTRIES\n         MVC   DDNSVE,=CL8'        '  INITIALIZE WORK AREA\n         MVC   CONCATNO,=F'0'         INITIALIZE WORK AREA\n         DROP  R15\n         USING SMF30DEV,R2        ESTABLISH ADDRESSABILITY\n         CLC   SMF30DDN,=C'ALLZERO '  IS THIS DDNAME FIRST ONE\n         BNE   *+8                    NO\n         MVI   SUPSW,X'01'            YES  RESET SUPPRESSION SWITCH\nLOOP1    EQU   *\n         LA    R5,7                ONLY 7  ENTRIES PER LINE\n         LA    R6,PRTLINE+4        GET ADDR OF 1ST COUNT AREA\n         MVC   PRTLINE,BASELINE\nLOOP2    EQU   *\n         BAL   R7,EXCP             GET ENTRIES INTO PRINT LINE\n         CLC   SMF30BLK,BINZERO    THIS ENTRY ZERO\n         BNE   LOOP2A               NO\n         CLI   SUPSW,X'00'         SUPPRESS SWITCH ON\n         BNE   LOOP2A              NO\n         AH    R2,SMF30ELN         STEP UP TO NEXT ENTRY\n         BCT   R4,LOOP2\n         B     LOOP4\nLOOP2A   AH    R2,SMF30ELN         STEP UP TO NEXT ENTRY\n         LA    R6,17(R6)           NEXT POSITION IN PRINT LINE\n         BCT   R4,*+8              BR AROUND EXIT TIL DONE\n         B     LOOP3               EXIT WHEN R4 IS ZERO\n         BCT   R5,LOOP2            DO ENTRIES UNTIL 7  IS REACHED\n         LR    R5,R2               SAVE R2 FROM PUTLINE\n         BAS   R7,PUTLINE          PUT OUT THIS ONE\n         LR    R2,R5               RESTORE R2\n         B     LOOP1               GO START ANOTHER LINE\nLOOP3    BCT   R5,LOOP4            ACCOUNT FOR LAST ENTRY\n         LR    R5,R2               SAVE R2 FROM PUTLINE\n         BAS   R7,PUTLINE          PUT OUT THIS ONE\n         LR    R2,R5               RESTORE R2\n         LA    R5,7                ONLY 7  ENTRIES PER LINE\n         LA    R6,PRTLINE+4        GET ADDR OF 1ST COUNT AREA\n         MVC   PRTLINE,BASELINE\n         B     LOOP4               GO START ANOTHER LINE\n         SPACE 2\n***********************************************************************\n*  CONVERT AND PLACE UNIT ADDRESS AND EXCP COUNTS IN PRINT LINE       *\n***********************************************************************\n         SPACE 2\nEXCP     EQU   *\n         USING S4,R6\n         MVC   TEMP(4),SMF30BLK    GET I/O EXCP COUNT\n         L     R3,TEMP                AND CONVERT IT\n         CVD   R3,TEMP                   TO DECIMAL\n         MVC   SCOUNT-1(8),=X'4020202020202120'\n         ED    SCOUNT-1(8),TEMP+4\n         CLC   SMF30DDN,DDNSVE         SAME DDNAME\n         BE    EXCP01                  YES IT IS A CONCATENATION\n         MVC   DDNSVE,SMF30DDN\n         MVC   SDDNME,SMF30DDN\n         SR    R3,R3\n         ST    R3,CONCATNO\n         B     EXCP02\nEXCP01   EQU   *\n         L     R3,CONCATNO           GET NUMBER OF CONCATENTATION\n         A     R3,=F'1'              INCREASE IT BY ONE\n         ST    R3,CONCATNO           SAVE CONCAT. NUMBER\n         CVD   R3,TEMP               CONVERT TO DECIMAL\n         LA    R1,SDDNME+7\n         MVC   SDDNME(8),=X'4020202020202120'\n         EDMK  SDDNME(8),TEMP+4\n         BCTR  R1,R0\n         MVI   0(R1),C'+'            INSERT PLUS SIGN\n         MVC   SDDNME(4),=C'CCAT'    INDICATE BACK REFERENCE\nEXCP02   BR    R7                    RETURN TO CALLER\n         SPACE 2\n         DROP  R2\n***********************************************************************\n*  CONVERT AND PLACE TPUTS AND TGETS IN PRINT LINE                    *\n***********************************************************************\n         SPACE 2\nLOOP4    CLI   SMF30UON+1,X'01'    UNIT RECORD SEGMENT PRESENT\n         BL    CNTDONE             NO BYPASS INFORMATION\n         LR    R15,R9              GET SMF RECORD ADDRESS\n         A     R15,SMF30UOF        UNIT RECORD SEGMENT OFFSET\n         LR    R2,R15              GET ADDRESSABILITY\n         USING SMF30URA,R2         ESTABLISH ADDRESSABILITY\n         LA    R4,2                NUMBER OF FIELDS TO PRINT\n         MVC   TEMP(4),SMF30TPT    GET TPUTS COUNT\n         MVC   SDDNME,=C'TPUTS   '\nLOOP5    EQU   *\n         USING S4,R6\n         L     R3,TEMP                AND CONVERT IT\n         CVD   R3,TEMP                   TO DECIMAL\n         MVC   SCOUNT-1(8),=X'4020202020202120'\n         ED    SCOUNT-1(8),TEMP+4\n         CLC   TEMP(4),BINZERO     ENTRY ZERO\n         BNE   LOOP05A             NO\n         CLI   SUPSW,X'00'         SUPPRESSION ON\n         BNE   LOOP05A             NO\n         BCT   R4,LOOP5A           YES CONTINUE\n         MVI   0(R6),C' '\n         MVC   1(16,R6),0(R6)      CLEAR LAST ENTRY\n         B     CNTDONE\nLOOP05A  LA    R6,17(R6)           NEXT POSITION IN PRINT LINE\n         BCT   R4,*+8              BR AROUND EXIT TIL DONE\n         B     CNTDONE             EXIT WHEN R4 IS ZERO\n         BCT   R5,LOOP5A           DO ENTRIES UNTIL 7  IS REACHED\n         LR    R5,R2               SAVE R2 FROM PUTLINE\n         BAS   R7,PUTLINE          PUT OUT THIS ONE\n         LR    R2,R5               RESTORE R2\n         B     LOOP6               GO START ANOTHER LINE\nLOOP5A   EQU   *\n         MVC   TEMP(4),SMF30TGT    GET TGETS COUNT\n         MVC   SDDNME,=C'TGETS   '\n         B     LOOP5\nLOOP6    EQU   *\n         LA    R6,PRTLINE+4        GET ADDR OF FIRST PRINT AREA\n         MVC   PRTLINE,BASELINE\n         B     LOOP5A\n         SPACE 2\n         DROP  R2\nCNTDONE  EQU   *\n         BAS   R7,PUTLINE          LAST OF THE EXCP I/O COUNTS LINE\n         MVC   PRTLINE,BASELINE    SET UP A SEPARATOR LINE\n         BAS   R7,PUTLINE            AND PRINT IT\n         SPACE 2\n***********************************************************************\n*   BUILD AND PRINT 6TH LINE (PAGING ACTIVITIES)                      *\n***********************************************************************\n         SPACE 2\nSTEPCONT EQU   *\n         LA    R6,PRTLINE          GET BASE BACK\n         MVC   PRTLINE,STEPLN6     SET UP PAGE STAT LINE\n         SPACE 2\n***********************************************************************\n* TOTAL NUMBER OF DEMAND PAGE-INS AND PAGE-OUTS                       *\n***********************************************************************\n         SPACE 1\n         CLI   SMF30RON+1,X'01'    STORAGE AND PAGING SEGMENT PRESENT\n         BL    SXTHLNE             NO BYPASS INFORMATION\n         LR    R15,R9              GET SMF RECORD ADDRESS\n         A     R15,SMF30ROF        STORAGE AND PAGING SEGMENT OFFSET\n         USING SMF30SAP,R15        ESTABLISH ADDRESSABILITY\n         L     R1,SMF30PGI         NO OF PAGE INS.\n         BAS   R14,PCOUNT          CONVERT TO DECIMAL\n         MVC   SLN6DI(5,R6),TEMP+3 THEN TO EBCDIC\n         L     R1,SMF30PGO         NO OF PAGE OUTS\n         BAS   R14,PCOUNT          CONVERT TO DECIMAL\n         MVC   SLN6DO(5,R6),TEMP+3 THEN TO EBCDIC\n*        L     R1,SMF30REC         NO OF PAGE RECLAIMS\n*        BAS   R14,PCOUNT          CONVERT TO DECIMAL\n*        MVC   SLN6DR(5,R6),TEMP+3 THEN TO EBCDIC\n         L     R1,SMF30VPI          NO OF VIO PAGE INS.\n         BAS   R14,PCOUNT          CONVERT TO DECIMAL\n         MVC   SLN6VI(5,R6),TEMP+3 THEN TO EBCDIC\n         L     R1,SMF30VPO          NO OF VIO PAGE OUTS\n         BAS   R14,PCOUNT          CONVERT TO DECIMAL\n         MVC   SLN6VO(5,R6),TEMP+3 THEN TO EBCDIC\n         L     R1,SMF30VPR          NO OF VIO PAGE RECLAIMS\n         BAS   R14,PCOUNT          CONVERT TO DECIMAL\n         MVC   SLN6VR(5,R6),TEMP+3 THEN TO EBCDIC\n         L     R1,SMF30CPI         NO OF COMMON PAGE INS.\n         S     R1,SMF30LPI         REMOVE LPA TO GET CSA\n         BAS   R14,PCOUNT          CONVERT TO DECIMAL\n         MVC   SLN6CI(5,R6),TEMP+3 THEN TO EBCDIC\n*        L     R1,SMF30CPR          NO OF COMMON AREA PAGE RECLAIMS\n*        S     R1,SMF30LPR         REMOVE LPA TO GET CSA\n*        BAS   R14,PCOUNT          CONVERT TO DECIMAL\n*        MVC   SLN6CR(5,R6),TEMP+3 THEN TO EBCDIC\n         L     R1,SMF30LPI         NO OF LPA PAGE INS\n         BAS   R14,PCOUNT          CONVERT TO DECIMAL\n         MVC   SLN6LI(5,R6),TEMP+3 THEN TO EBCDIC\n*        L     R1,SMF30LPR         NO OF LPA PAGE RECLAIMS\n*        BAS   R14,PCOUNT          CONVERT TO DECIMAL\n*        MVC   SLN6LR(5,R6),TEMP+3 THEN TO EBCDIC\n         DROP  R15\nSXTHLNE  BAS   R7,PUTLINE          GO PRINT THE PAGING ACTIVITIES\n         SPACE 2\n         MVC   PRTLINE,BASELINE    SET UP A SEPARATOR LINE\n         BAS   R7,PUTLINE            AND PRINT IT\n         SPACE 2\n***********************************************************************\n* BUILD AND PRINT SEVENTH LINE                                        *\n***********************************************************************\n         SPACE 2\n         LA    R6,PRTLINE          GET BASE BACK\n         MVC   PRTLINE,STEPLN7     SET UP PAGE STAT LINE\n         SPACE 2\n***********************************************************************\n* OPERATOR INFORMATION                                                *\n***********************************************************************\n         SPACE 1\n         CLI   SMF30OON+1,X'01'    OPERATOR SEGMENT PRESENT\n         BL    SVTHLNE1            NO BYPASS INFORMATION\n         LR    R15,R9              GET SMF RECORD ADDRESS\n         A     R15,SMF30OOF        OPERATOR SEGMENT OFFSET\n         USING SMF30OPS,R15          ESTABLISH ADDRESSABILITY\n         L     R1,SMF30PDM           NO OF NON-SPECIFIC DASD MOUNTS\n         BAS   R14,PCOUNT            CONVERT TO DECIMAL\n         MVC   SLN7NSDM(5,R6),TEMP+3 THEN TO EBCDIC\n         L     R1,SMF30PRD           NO OF SPECIFIC DASD MOUNTS\n         BAS   R14,PCOUNT            CONVERT TO DECIMAL\n         MVC   SLN7SDM(5,R6),TEMP+3  THEN TO EBCDIC\n         L     R1,SMF30PTM           NO OF NON-SPECIFIC TAPE MOUNTS\n         BAS   R14,PCOUNT            CONVERT TO DECIMAL\n         MVC   SLN7NSTM(5,R6),TEMP+3 THEN TO EBCDIC\n         L     R1,SMF30TPR           NO OF SPECIFIC TAPE MOUNTS\n         BAS   R14,PCOUNT            CONVERT TO DECIMAL\n         MVC   SLN7STM(5,R6),TEMP+3  THEN TO EBCDIC\n         L     R1,SMF30MTM           NO OF NON-SPECIFIC MSS MOUNTS\n         BAS   R14,PCOUNT            CONVERT TO DECIMAL\n         MVC   SLN7NSMS(5,R6),TEMP+3 THEN TO EBCDIC\n         L     R1,SMF30MSR           NO OF SPECIFIC MSS MOUNTS\n         BAS   R14,PCOUNT            CONVERT TO DECIMAL\n         MVC   SLN7SMS(5,R6),TEMP+3  THEN TO EBCDIC\n         DROP  R15\nSVTHLNE1 CLI   SMF30PON+1,X'01'      PERFORMANCE SEGMENT PRESENT\n         BL    SVTHLNE               NO BYPASS INFORMATION\n         LR    R15,R9                 GET SMF RECORD ADDRESS\n         A     R15,SMF30POF          PERFORMANCE SEGMENT OFFSET\n         USING SMF30PRF,R15          ESTABLISH ADDRESSABILITY\n         L     R1,SMF30TRS           NO OF TRANACTIONS\n         BAS   R14,PCOUNT             CONVERT TO DECIMAL\n         MVC   SLN7TRNS(5,R6),TEMP+3  THEN TO EBCDIC\n         DROP  R15\nSVTHLNE  BAS   R7,PUTLINE          GO PRINT THE PAGING ACTIVITIES\n         B     EXIT\n         TITLE 'JOB END PROCESSING'\n***********************************************************************\n*                                                                     *\n*      JOB END PROCESSING                                             *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nJOBEND   EQU   *\n         MVI   PRTLINE,C' '        SET UP CLEAR\n         MVC   PRTLINE+1(L'PRTLINE-1),PRTLINE\n         BAS   R7,PUTLINE          BLANK LINE\n         MVC   PRTLINE,BASELINE    SET UP ROW OF *'S\n         MVC   PRTLINE+1(L'PRTLINE-1),PRTLINE\n         LA    R1,PRTLINE+46       LOAD ADDRESS FOR HEADER GEN\n         BAS   R7,HDRSETP          GO SET UP HEADER\nCKUSER2  BAS   R7,PUTLINE                           AND GO PRINT IT\n         MVC   PRTLINE,BASELINE                     SET UP A SEPARATOR\n         BAS   R7,PUTLINE                           LINE AND PRINT\n         SPACE 2\n***********************************************************************\n*  BUILD AND PRINT JOB END HEADERS                                    *\n***********************************************************************\n         SPACE 2\n         USING SH1,R6\n         LA    R6,PRTLINE\n         MVC   SHEAD1(L'USERID),USERID     USER IDENTIFICATION\n         L     R15,16               GET CVT POINTER\n         LA    R7,24                RELOCATION FACTOR\n         SR    R15,R7\n         CLC   0(8,R15),BINZERO     CHECK FOR ZEROS\n         BE    *+10\n         MVC   SHEAD1A(16),0(R15)             USER SYSTEM DESC.\n         MVC   SHEAD1J,IPJOB               JOB END IDENTIFICATION\n         MVC   SHEAD1PH,PROGMER                PROGRAMMER'S\n         L     R7,PARMPROG                    NAME\n         MVC   SHEAD1PR(20),0(R7)\n         BAS   R7,PUTLINE                  PRINT THE JOB END HEADING\n         MVC   PRTLINE,BASELINE            SET UP A SEPARATOR LINE\n         BAS   R7,PUTLINE                     AND PRINT IT\n         SPACE 2\n***********************************************************************\n* BUILD AND PRINT THE 1ST JOB LINE                                    *\n***********************************************************************\n         SPACE 2\n         USING J1,R6\n         MVC   PRTLINE,JOBLN1      PUT UP JOBNAME\n         CLI   SMF30ION+1,X'01'     IDENTIFICATION SEGMENT PRESENT\n         BL    JOBEND1              NO BYPASS INFORMATION\n         LR    R15,R9                         SMF RECORD ADDRESS\n         A     R15,SMF30IOF              IDENTIFICATION SEGMENT OFFSET\n         USING SMF30ID,R15              ESTABLISH ADDRESSABILITY\n         MVC   JNM,SMF30JBN           INTO LINE\n         MVC   TIME,SMF30RSD        RDR START DATE\n         LA    R5,JRDDT            PLACE IN LINE\n         BAL   R7,DAYS             GO DO IT\n         MVC   TIME,SMF30STD        INIT DATE\n         LA    R5,JINITDT          PLACE IN LINE\n         BAL   R7,DAYS             PUT IT THERE\n         MVC   DATE,SMF30STD        GET START DATE\n         MVC   TIME,SMF30SIT        STRT TIME\n         BAL   R7,GETTIME          GO AND GET DATE/TIME\n         LA    R5,JELAPSTM         GET ELAPSED TIME'S PRINT POSITION\n         BAL   R7,ELAPSED          GO WORK OUT ELAPSED TIME\nJOBEND1  BAS   R7,PUTLINE          GO PRINT THE LINE\n         DROP  R15\n         SPACE 2\n***********************************************************************\n* BUILD AND PRINT 2ND JOB END LINE                                    *\n***********************************************************************\n         SPACE 2\n         USING J2,R6\n         MVC   PRTLINE,JOBLN2\n         CLI   SMF30ION+1,X'01'       IDENTIFICATION SEGMENT PRESENT\n         BL    JOBEND2A               NO BYPASS INFORMATION\n         LR    R15,R9                         SMF RECORD ADDRESS\n         A     R15,SMF30IOF              IDENTIFICATION SEGMENT OFFSET\n         USING SMF30ID,R15              ESTABLISH ADDRESSABILITY\n         MVC   JCLASS,SMF30CLS      GET JOB CLASS\n         MVC   TIME,SMF30RST        READ  TIME\n         LA    R5,JRDTM            LOCATE PRINT POSITION\n         BAL   R7,TIMEX            GO CONVERT TIME TO HH:MM:SS:\n         MVC   TIME,SMF30SIT        GET INIT TIME\n         LA    R5,JINITTM          LOCATE ITS PRINT POSITION\n         BAL   R7,TIMEX            GO CONVERT TO HH:MM:SS\n         DROP  R15\nJOBEND2A CLI   SMF30CON+1,X'01'    PROCESSOR ACCOUNTING SEGMENT PRESENT\n         BL    JOBEND2               NO BYPASS INFORMATION\n         LR    R15,R9                         SMF RECORD ADDRESS\n         A     R15,SMF30COF        PROCESSOR ACCOUNTING SEGMENT OFFSET\n         USING SMF30CAS,R15              ESTABLISH ADDRESSABILITY\n         MVC   TIME,SMF30CPT       GET JOB CPU TIME\n         DROP  R15\n         LA    R5,JCPUTM           PLACE IN LINE\n         BAL   R7,TIMEX1           PUT IT INTO LINE\nJOBEND2  BAS   R7,PUTLINE\n         SPACE 2\n***********************************************************************\n* BUILD AND PRINT 3RD JOB END LINE                                    *\n***********************************************************************\n         SPACE 2\n         USING J3,R6\n         MVC   PRTLINE,JOBLN3\n         MVC   JSUBS,SMF30WID        SUBSYSTEM IDENTIFIER\n         CLI   SMF30ION+1,X'01'     IDENTIFICATION SEGMENT PRESENT\n         BL    JOBEND3A             NO BYPASS INFORMATION\n         LR    R15,R9                         SMF RECORD ADDRESS\n         A     R15,SMF30IOF              IDENTIFICATION SEGMENT OFFSET\n         USING SMF30ID,R15              ESTABLISH ADDRESSABILITY\n         MVC   DATE,SMF30RSD        RDR START DATE\n         MVC   TIME,SMF30RST        RDR START TIME\n         DROP  R15\n         BAL   R7,GETTIME          GO AND GET DATE/TIME\n         LA    R5,JSYSTM           PLACE INTO LINE\n         BAL   R7,ELAPSED          GET DIFFERENCE\nJOBEND3A L     R0,TIMEND             GET JOB END TIME IN 0.01 OF SEC\n         ST    R0,TIME\n         LA    R5,JENDTM           GET PLACE IN LINE\n         BAL   R7,TIMEX            PUT IT THERE\n         CLI   SMF30CON+1,X'01'    PROCESSOR ACCOUNTING SEGMENT PRESENT\n         BL    JOBEND3               NO BYPASS INFORMATION\n         LR    R15,R9                         SMF RECORD ADDRESS\n         A     R15,SMF30COF        PROCESSOR ACCOUNTING SEGMENT OFFSET\n         USING SMF30CAS,R15              ESTABLISH ADDRESSABILITY\n         MVC   TIME,SMF30CPS       GET JOB SRB TIME\n         DROP  R15\n         LA    R5,JSRBTM           PLACE IN LINE\n         BAL   R7,TIMEX1           PUT IT INTO LINE\nJOBEND3  BAS   R7,PUTLINE\n         SPACE 2\n***********************************************************************\n* ISSUE APPROPRIATE WTO MESSAGE FOR JOB COMPLETION                    *\n***********************************************************************\n         SPACE 2\n         CLI   SMF30TON+1,X'01'    COMPLETION SEGMENT PRESENT?\n         BL    EXIT                NO, DONT ISSUE WTO\n         LR    R15,R9              SMF RECORD ADDRESS\n         A     R15,SMF30TOF        COMPLETION SEGMENT OFFSET\n         USING SMF30CMP,R15           ESTABLISH ADDRESSABILITY\n         TM    SMF30STI,X'01'      WAS JOB FLUSHED?\n         BO    EXIT                YES, DONT ISSUE MESSAGE\n         TM    SMF30STI,X'02'      DID JOB ABEND?\n         BO    JOBABND             YES, GO HANDLE JOB ABEND STUFF\n         LH    R2,SMF30SCC         HANDLE STEP COMPLETION CODE\n         LTR   R2,R2               IS COMPLETION CODE ZERO?\n         BZ    EXIT                YES, DONT ISSUE MESSAGE\n         MVC   WTOANP03(WTO03END-WTOSTC03),WTOSTC03\n         CVD   R2,TEMP             *\n         MVC   ANP03JCC,=X'40202120'\n         ED    ANP03JCC,TEMP+6\n         CLI   SMF30ION+1,X'01'    IDENTIFICATION SEGMENT PRESENT?\n         BL    EXIT                NO, DONT ISSUE WTO\n         LR    R1,R9                          SMF RECORD ADDRESS\n         A     R1,SMF30IOF              IDENTIFICATION SEGMENT OFFSET\n         USING SMF30ID,R1               ESTABLISH ADDRESSABILITY\n         CLI   SMF30CLS,C' '       IS THIS A BATCH JOB?\n         BE    EXIT                NO, DONT ISSUE WTO\n         MVC   ANP03JBN,SMF30JBN   MOVE IN JOB NAME\n         DROP  R1\n         LA    R1,WTOANP03         LOAD ADDRESS OF PARM LIST\n         WTO   MF=(E,(1))          ISSUE MESSAGE\n         B     EXIT\nJOBABND  MVC   WTOANP04(WTO04END-WTOSTC04),WTOSTC04\n         LR    R1,R9                          SMF RECORD ADDRESS\n         A     R1,SMF30IOF              IDENTIFICATION SEGMENT OFFSET\n         USING SMF30ID,R1               ESTABLISH ADDRESSABILITY\n         MVC   ANP04JBN,SMF30JBN   MOVE IN JOB NAME\n         DROP  R1\n         TM    SMF30SCC,X'80'       USER ABEND ??\n         BZ    JBSABEND            NO SYSTEM ABEND\n         MVC   ANP04UAT,=C'USER  '\n         LH    R2,SMF30SCC\n         N     R2,=A(X'FFF')       TURN OFF FLAGS\n         CVD   R2,TEMP\n         MVC   ANP04UAB,=X'402120202020'\n         ED    ANP04UAB,TEMP+5\n         B     JOBEWTO\nJBSABEND UNPK  TEMP(5),SMF30SCC(3)  DISPLAY SYSTEM CODE IN HEX\n         MVC   ANP04SAT,=C'SYSTEM'\n         TR    TEMP+1(3),TOHEX-C'0'\n         MVC   ANP04SAB,TEMP+1\n         MVC   ANP04SBL,=C'   '\nJOBEWTO  DS    0H\n         CLI   SMF30ION+1,X'01'     IS ID SECTION PRESENT?\n         BL    EXIT                 NO, SKIP MESSAGE\n         LR    R15,R9\n         A     R15,SMF30IOF\n         USING SMF30ID,R15\n         CLI   SMF30CLS,C' '        IS THIS A BATCH JOB?\n         BE    EXIT                 NO, SKIP PRINTING MESSAGE\n         LA    R1,WTOANP04\n         WTO   MF=(E,(1))\n         DROP  R15\n         TITLE 'IEFACTRT EXITS'\n         SPACE 2\nEXIT     EQU   *\n         MVC   PRTLINE,BASELINE\n         BAS   R7,PUTLINE\n         MVC   PRTLINE+1(L'PRTLINE-1),PRTLINE\n         BAS   R7,PUTLINE\n         MVI   PRTLINE,C' '        CLEAR FOR BLANK LINE\n         MVC   PRTLINE+1(L'PRTLINE-1),PRTLINE\n         BAS   R7,PUTLINE\n         SPACE 2\nEXIT1    CLC   R0SAVE,=F'00123456'\n         BNE   EXIT2               NO, DON'T DO CLOSE\n         MVC   CLOSEL(CLOSLDCE-CLOSELDC),CLOSELDC    SET UP CLOSE LIST\n         CLOSE (SYSPRINT,DISP),MF=(E,CLOSEL)\n***********************************************************************\n* FREE DYNAMIC WORKAREAS                                              *\n***********************************************************************\n         SPACE 2\nEXIT2    L     R13,4(R13)          RELOAD OS SAVEAREA\n         LR    R1,R8               AREA TO BE FREED\n         FREEMAIN R,A=(1),LV=WORKEND-WORKSTRT\n         SPACE 2\nRETURN   EQU   *\n         LM    R14,R12,12(R13)     RESTORE OS REGISTERS\n         SR    R1,R1               ALLOW SMF RECORD TO BE WRITTEN\n         SR    R15,R15             DON'T CANCEL JOB\n         BR    R14\n         TITLE 'IEFACTRT SUBROUTINES'\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  COUNT CONVERSION ROUTINE: CONVERTS BINARY TO BINARY- OR DECIMAL-   *\n*   ORIENTED CHARACTER OUTPUT (PCOUNT SCALES 1K = 1000, 1M=1000000,   *\n*   WHILE HCOUNT SCALES 1K = 1024, 1M = 1048576)                      *\n*        INPUT   REG 1 HAS COUNT TO BE CONVERTED                      *\n*        OUTPUT  TEMP  CONTAINS CHARACTER OUTPUT FIELD                *\n*                                                                     *\n***********************************************************************\nHCOUNT   C     R1,=F'1023488'      SHOULD WE SCALE IN MEGS (2 ** 20)?\n         BL    HCOUNT1             NO\n         MVI   TEMP+7,C'M'         MOVE IN 'M' FOR MEGS (2 ** 20)\n         SRA   R1,19               SHIFT RIGHT 19 BITS\n         AH    R1,=H'1'            ADD ONE FOR ROUNDING\n         MH    R1,=H'5'            MULT BY FIVE (FOR ROUNDING AND 'M')\n         B     HCOUNT3\nHCOUNT1  C     R1,=F'9995'         SHOULD WE SCALE IN K'S (2 ** 10)?\n         BL    HCOUNT2             NO\n         MVI   TEMP+7,C'K'         MOVE IN 'K' FOR K'S (2 ** 10)\n         SRA   R1,9                SHIFT RIGHT 9 BITS\n         AH    R1,=H'1'            ADD ONE FOR ROUNDING\n         MH    R1,=H'5'            MULT BY FIVE (FOR ROUNDING AND 'K')\n         B     HCOUNT3\nHCOUNT2  MVI   TEMP+7,X'20'        DO NOT SCALE\nHCOUNT3  CVD   R1,TEMP1\n         B     CNTCOMM\nPCOUNT   CVD   R1,TEMP1            CONVERT TO DECIMAL\n         CP    TEMP1,=P'999500'    SHOULD WE SCALE IN MILLIONS?\n         BL    PCOUNT1             NO\n         MVI   TEMP+7,C'M'         MOVE IN 'M' FOR MILLIONS\n         SRP   TEMP1,64-6,5        SHIFT AND ROUND RIGHT\n         SRP   TEMP1,1,0           SHIFT LEFT (FOR 'M')\n         B     CNTCOMM\nPCOUNT1  CP    TEMP1,=P'9995'      SHOULD WE SCALE IN THOUSANDS?\n         BL    PCOUNT2             NO\n         MVI   TEMP+7,C'K'         MOVE IN 'K' FOR THOUSANDS\n         SRP   TEMP1,64-3,5        SHIFT AND ROUND RIGHT\n         SRP   TEMP1,1,0           SHIFT LEFT (FOR 'K')\n         B     CNTCOMM\nPCOUNT2  MVI   TEMP+7,X'20'        DO NOT SCALE\nCNTCOMM  MVC   TEMP(7),=X'40202020202021'\n         LA    R1,TEMP1+4\n         ED    TEMP(8),0(R1)       MOVE IN UNFLOATED COUNT\n         BR    R14\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  CONVERT PACKED DATE TO EBCDIC FORMAT                               *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nDAYS     EQU   *\n         UNPK  1(5,R5),TIME+1(3)   PUT EBCDIC INTO FIELD\n         OI    5(R5),F0            MAKE IT PRINTABLE\n         MVC   0(2,R5),1(R5)       SEPARATE\n         MVI   2(R5),DOT           SEPARATOR\n         BR    R7                  RETURN\n         EJECT\n***********************************************************************\n*                                                                     *\n*  THIS ROUTINE CALCULATES THE ELAPSED TIME WHICH IS THE DIFFERENCE   *\n*                     BETWEEN TWO BINARY TIME                         *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nELAPSED  EQU   *\n         L     R2,TIME             GET BEGIN TIME\n         L     R3,TIMEND           GET END\n         CP    DATE+2(2),DATEND+2(2)  SAME DAY?\n         BNL   *+18          YES, GO AROUND ADD ON\n         AP    DATE+2(2),=P'1'   ADD ON 1 DAY\n         A     R3,ONEDAY     AND 24 HOURS TO TIME\n         B     *-20          TRY FOR MATCH AGAIN\n         SR    R3,R2               GET DIFFERENCE\n         ST    R3,TIME             SAVE\n         B     TIMEX               FALL INTO TIME CONVERSION\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*          THIS ROUTINE GETS THE TIME AND DATE AND STORES             *\n*                                                                     *\n*               THEM AT TIMEND AND DATEND RESPECTIVELY                *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nGETTIME  CLC   R0SAVE,=F'00123456'   BATCH TEST?\n         BNE   GETTIME1             NO GO ISSUE TIME\n         MVC   TIMEND,SMF30TME    MOVE TIME\n         MVC   DATEND,SMF30DTE    MOVE DATE\n         BR    R7                 RETURN\nGETTIME1 TIME  BIN\n         ST    R0,TIMEND               SAVE TIME\n         ST    R1,DATEND               SAVE DATE\n         BR    R7                      RETURN\n***********************************************************************\n*                                                                     *\n*    THIS ROUTINE TRANSLATES  BINARY TIME TO HH:MM:SS FORMAT          *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nTIMEX1   EQU   *\n         MVI   8(R5),DOT           INITIALIZE SEPARATOR\n         L     R3,TIME             LOAD TIME\n         LA    R4,100              GET DIVISOR\n         SR    R2,R2               CLEAR HIGH ORDER\n         DR    R2,R4               R2 NOW HAS HUNDRETHS OF SECS\n         CVD   R2,TEMP             CONVERT TO EBCDIC\n         UNPK  9(2,R5),TEMP        *\n         OI    10(R5),F0           *\n         B     TIMEX               CONTINUE WITH REST OF FIELD\n         SPACE 2\nTIMEX2   EQU   *\n         SR    R2,R2               CLEAR REGISTER 2\n         L     R3,TIME             LOAD TIME IN 1024 MICROSEC. UNITS\n         M     R2,=F'1024'         MULTIPLY BE 1024\n         D     R2,=F'1000000'      DIVIDE BY 1 MILLION R3 NOW HAS SECS\n         MVI   2(R5),COLON          INITIALIZE SEPARATORS\n         MVI   5(R5),COLON         *\n         B     TIMEX0               CONTINUE WITH FIELD CONVERSION\n         SPACE 2\nTIMEX    EQU   *\n         MVI   2(R5),COLON         INITIALIZE SEPARATORS\n         MVI   5(R5),COLON\n         L     R3,TIME             LOAD TIME\n         LA    R4,100              GET DIVISOR\n         SR    R2,R2               CLEAR HIGH ORDER\n         DR    R2,R4               R3 NOW IN SECONDS\nTIMEX0   SR    R2,R2               CLEAR\n         LA    R4,60               60 SECS/MIN\n         DR    R2,R4               R2 HAS SECS, R3 HAS BALANCE\n         CVD   R2,TEMP             CONVERT SECS TO EBCDIC\n         UNPK  6(2,R5),TEMP        *\n         OI    7(R5),F0            *\n         SR    R2,R2               CLEAR AGAIN\n         DR    R2,R4               R2 HAS MINUTES,R3 HAS HOURS\n         CVD   R2,TEMP             CONVERT MINUTES TO EBCDIC\n         UNPK  3(2,R5),TEMP        *\n         OI    4(R5),F0            *\n         CVD   R3,TEMP             CONVERT HOURS\n         UNPK  0(2,R5),TEMP        *\n         OI    1(R5),F0            *\n         BR    R7                  RETURN\n         EJECT\n***********************************************************************\n*                                                                     *\n*     THIS ROUTINE INTERFACES WITH SYSOUT WRITER TO PRINT A LINE      *\n*            SEE SMF MANUAL FOR LINKAGE CONVENTIONS                   *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nPUTLINE  EQU   *\n         CLC   R0SAVE,=F'00123456'\n         BNE   PUTLINE1            NO, DON'T DO PUT\n         PUT   SYSPRINT,PRTLINE\n         BR    R7                 RETURN\nPUTLINE1 ST    R12,R12SAVE2        SAVE BASE ADDRESS\n         L     R12,R12SAVE         RESTORE PARMS\n         LA    R2,PRTLINE          FOLLOW IEFYS CONVENTIONS\n         ST    R2,36(R12)          SEE SMF MANUAL\n         LA    R2,130              IEFACTRT CODING INSTRUCTIONS\n         STH   R2,42(R12)          *\n         L     R15,VIEFYS          GET IEFYS ADDR\n         BALR  R14,R15             GO PUT LINE\n         L     R12,R12SAVE2        RESTORE BASE ADDRESS\n         BR    R7                  RETURN TO CALLER\n         EJECT\n***********************************************************************\n* SET UP COMMON HEADING LINE:                                         *\n*  OS/SPXXXXXX FMIDXXX CPU MODEL XXXX                                 *\n***********************************************************************\n         SPACE 2\nHDRSETP  MVC   0(37,R1),RELSTAT    MOVE IN STATIC INFORMATION FOR HDR\n         USING RELDYN,R1           ADDRESS WORK AREA FOR HEADER LINE\n         L     R15,16              GET CVT POINTER\n         LA    R4,40               RELOCATION FACTOR\n         SR    R15,R4              ADDRESS CVT PREFIX\n         SLR   R4,R4               CLEAR OUT R7\n         ICM   R4,3,34(R15)        INSERT MODEL # INTO REGISTER\n         SLL   R4,4                SHIFT FOR SIGN\n         STCM  R4,7,TEMP1          STORE INTO TEMP1 FOR UNPACK\n         OI    TEMP1+2,X'0F'       INSERT SIGN FOR UNPACK\n         UNPK  MODEL(4),TEMP1(3)\n         MVC   SPREL(8),0(R15)     MOVE IN CONTROL PROG PROD NAME\n         MVC   FMID(8),8(R15)      MOVE IN CONTROL PROG FMID NAME\n         BR    R7                  RETURN TO CALLER\n         DROP  R1\n         TITLE 'IEFACTRT CONSTANTS'\n***********************************************************************\n*                                                                     *\n*              DATA  CONSTANTS                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nSYSPRTDC DCB   MACRF=PM,LRECL=130,DSORG=PS,BLKSIZE=130,                X\n               RECFM=F,DDNAME=SYSPRINT\nSYSPRTED EQU   *\nOPENLDC  OPEN  (,(OUTPUT)),MF=L\nOPENLDCE EQU   *\nCLOSELDC CLOSE (,DISP),MF=L\nCLOSLDCE EQU   *\nWTOSTC02 WTO   'ANP002I JOB XXXXXXXX STEP ZZZ (CCCCCCCC) XXXXXX ABEND CX\n               ODE 999999',ROUTCDE=(11),MF=L\nWTO02END EQU   *\nWTOSTC03 WTO   'ANP003I JOB XXXXXXXX HIGHEST NON-ZERO COMPLETION CODE WX\n               AS 999',ROUTCDE=(11),MF=L\nWTO03END EQU   *\nWTOSTC04 WTO   'ANP004I JOB XXXXXXXX XXXXXX ABEND CODE 999999',        X\n               ROUTCDE=(11),MF=L\nWTO04END EQU   *\nR30STEP  DC    H'4'                  STEP TERMINATION\nR30JOB   DC    H'5'                  JOB TERMINATION\nVIEFYS   DC    V(IEFYS)\nONEDAY   DC    A(24*60*60*100)\nHEXTRAN  DC    C'0123456789ABCDEF'\nBASELINE DC    C'*',CL128' ',C'*'\nUSERID   DC    C'IBM SYSTEM OS/MVS '\nIPSTEP   DC    C'STATISTICS FOR STEP'\nIPJOB    DC    C'JOB  END STATISTICS'\nPROGMER  DC    C'PROGRAMMER'\nEXCPSTAT DC    C'EXCP STATISTICS'\nBINZERO  DC    8X'00'\n         LTORG\nRELSTAT  DS    0CL37\n         DC    C' OS/'\n         DC    C'        '\n         DC    C' '\n         DC    C'        '\n         DC    C' CPU MODEL '\n         DC    C'    '\n         DC    C' '\nCONDLINE DC    C'STEP COND-CODE'\n         SPACE 3\nSTEPLN1  DS    0CL130\n         DC    C'*  PROGRAM NAME     '\nSLN1P    EQU   *-STEPLN1,8         PROGRAM NAME\n         DC    C'        ',C'  '\n         DC    C'  STEP INIT TIME  '\nSLN1I    EQU   *-STEPLN1,8         STEP INITIATION TIME\n         DC    C'        '\n         DC    C'  TASK CPU TIME '\nSLN1TC   EQU   *-STEPLN1,11        TASK CPU TIME\n         DC    C'           '\n         DC    C'  TOTAL SERVICE  '\nSLN1TOTS EQU   *-STEPLN1,8         TOTAL SERVICE\n         DC    C'     '\n         DC    C'  TCB SERVICE   '\nSLN1TCS  EQU   *-STEPLN1,8         TCB SERVICE\n         DC    C'     '\n         DC    CL30' '\n         ORG   STEPLN1+129\n         DC    C'*'\n         SPACE 3\nSTEPLN2  DS    0CL130\n         DC    C'*  PRIVATE  '\nSLN2PRBL EQU   *-STEPLN2,6         PRIVATE USE BELOW 16M\n         DC    C'      ',C' / '\nSLN2PRAB EQU   *-STEPLN2,6         PRIVATE USE ABOVE 16M\n         DC    C'      ',C'   '\n         DC    C'  STEP END TIME   '\nSLN2END  EQU   *-STEPLN2,8         STEP END TIME\n         DC    C'        '\n         DC    C'  SRB  CPU TIME '\nSLN2SRBC EQU   *-STEPLN2,11        SRB CPU TIME\n         DC    C'           '\n         DC    C'  SWAPS          '\nSLN2SWAP EQU   *-STEPLN2,5         SWAPS (IN+OUT) FOR THIS STEP\n         DC    C'     '\n         DC    C'  SRB SERVICE   '\nSLN2SRBS EQU   *-STEPLN2,5         SRB SERVICE UNITS\n         DC    C'     '\n         DC    CL30' '\n         ORG   STEPLN2+129\n         DC    C'*'\n         SPACE 3\nSTEPLN3  DS    0CL130\n         DC    C'*  LSQA/SWA '\nSLN3SPBL EQU   *-STEPLN3,6                 SYSTEM PRIVATE BELOW 16M\n         DC    C'      ',C' / '\nSLN3SPAB EQU   *-STEPLN3,6                 SYSTEM PRIVATE ABOVE 16M\n         DC    C'      ',C'   '\n         DC    C'  ACTIVE TIME     '\nSLN3AT   EQU   *-STEPLN3,8                 ACTIVE STEP TIME\n         DC    C'        '\n         DC    C'  PAGE SECONDS     '\nSLN3PS   EQU   *-STEPLN3,8                 PAGES IN CORE * CPU SECONDS\n         DC    C'        '\n         DC    C'  SWAP PAGES IN  '\nSLN3SPI  EQU   *-STEPLN3,5                 PAGES IN BECAUSE OF SWAPPING\n         DC    C'     '\n         DC    C'  I/O SERVICE   '\nSLN3IOS  EQU   *-STEPLN3,5                 I/O SERVICE UNITS\n         DC    C'     '\n         DC    CL30' '\n         ORG   STEPLN3+129\n         DC    C'*'\n         SPACE 3\nSTEPLN4  DS    0CL130\n         DC    C'*  REGION SIZE       '\nSLN4RG   EQU   *-STEPLN4,6                 REGION AVAILABLE\n         DC    C'      ',C'   '\n         DC    C'  RESIDENCY TIME  '\nSLN4RT   EQU   *-STEPLN4,8\n         DC    C'        '\n         DC    C'  PAGES STOLEN     '\nSLN4PS   EQU   *-STEPLN4,8\n         DC    C'        '\n         DC    C'  SWAP PAGES OUT '\nSLN4SPO  EQU   *-STEPLN4,5\n         DC    C'     '\n         DC    C'  MSO SERVICE   '\nSLN4MSO  EQU   *-STEPLN4,5\n         DC    C'     '\n         DC    CL30' '\n         ORG   STEPLN4+129\n         DC    C'*'\n         SPACE 2\nSTEPLN6  DS    0CL130\n         DC    C'*  ',C'PAGING: '\n         DC    C'DEMAND'\n         DC    C' IN ',C'     '\nSLN6DI   EQU   *-5-STEPLN6,5\n         DC    C' OUT ',C'     '\nSLN6DO   EQU   *-5-STEPLN6,5\n*        DC    C' RLM ',C'     '\n         DC    C'     ',C'     '\nSLN6DR   EQU   *-5-STEPLN6\n         DC    C'  VIO'\n         DC    C' IN ',C'     '\nSLN6VI   EQU   *-5-STEPLN6,5\n         DC    C' OUT ',C'     '\nSLN6VO   EQU   *-5-STEPLN6,5\n         DC    C' RLM ',C'     '\nSLN6VR   EQU   *-5-STEPLN6\n         DC    C'  CSA'\n         DC    C' IN ',C'     '\nSLN6CI   EQU   *-5-STEPLN6,5\n*        DC    C' RLM ',C'     '\n         DC    C'     ',C'     '\nSLN6CR   EQU   *-5-STEPLN6,5\n         DC    C'  LPA'\n         DC    C' IN ',C'     '\nSLN6LI   EQU   *-5-STEPLN6,5\n*        DC    C' RLM ',C'     '\n         DC    C'     ',C'     '\nSLN6LR   EQU   *-5-STEPLN6,5\n         DC    CL32' '\n         ORG   STEPLN6+129\n         DC    C'*'\n         SPACE 2\nSTEPLN7  DS    0CL130\n         DC    C'*  ',C'MOUNTS: '\n         DC    C'DASD ',C'NON-'\n         DC    C'SPEC. ',C'     '\nSLN7NSDM EQU   *-5-STEPLN7,5\n         DC    C' SPEC. ',C'     '\nSLN7SDM  EQU   *-5-STEPLN7,5\n         DC    C' TAPE ',C'NON-'\n         DC    C'SPEC. ',C'     '\nSLN7NSTM EQU   *-5-STEPLN7\n         DC    C' SPEC. ',C'     '\nSLN7STM  EQU   *-5-STEPLN7,5\n         DC    C' MSS ',C'NON-'\n         DC    C'SPEC. ',C'     '\nSLN7NSMS EQU   *-5-STEPLN7,5\n         DC    C' SPEC. ',C'     '\nSLN7SMS  EQU   *-5-STEPLN7\n         DC    C'  TRANSACTIONS ',C'     '\nSLN7TRNS EQU   *-5-STEPLN7\n         DC    CL32' '\n         ORG   STEPLN7+129\n         DC    C'*'\n         SPACE 3\nJOBLN1   DS    0CL130\n         DC    C'*   ',C'JOB NAME   '\n         DC    CL8' ',CL3' ',C'JOB READ DATE  '\n         DC    C'      ',CL8' ',C'JOB INIT DATE  '\n         DC    C'      ',CL8' ',C'JOB ELAPSED TIME  '\n         DC    C'        ',CL132' '\n         ORG   JOBLN1+129\n         DC    C'*'\n         SPACE 2\nJOBLN2   DS    0CL130\n         DC    C'*   ',C'JOB CLASS  '\n         DC    C' ',CL10' ',C'JOB READ TIME  '\n         DC    C'        ',CL6' ',C'JOB INIT TIME  '\n         DC    C'        ',CL6' ',C'JOB CPU TIME',CL6' '\n         DC    C'           ',CL132' '\n         ORG   JOBLN2+129\n         DC    C'*'\n         SPACE 2\nJOBLN3   DS    0CL130\n         DC    C'*   ',C'SUBSYSTEM  '\n         DC    C'    ',CL7' ',C'TIME IN SYSTEM '\n         DC    C'        ',CL6' ',C'JOB END TIME   '\n         DC    C'        ',CL6' ',C'JOB SRB TIME',CL6' '\n         DC    C'           ',CL132' '\n         ORG   JOBLN3+129\n         DC    C'*'\nTOHEX    DC    C'0123456789ABCDEF' TRANSLATE TABLE FOR PRINTABLE HEX\n         SPACE 2\nCOLON    EQU   C':'\nF0       EQU   X'F0'\nDOT      EQU   C'.'\nVIRT     EQU   X'80'\n         EJECT\n***********************************************************************\n*                                                                     *\n*        REGISTER EQUATES                                             *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         TITLE 'IEFACTRT DSECTS'\n*---------------------------------------------------------------------*\n*                                                                     *\n*        PARM LIST                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 2\nPARMS    DSECT\nPARMEPRM DS    F                PTR TO COMMON EXIT PARAMETER AREA\nPARMSTEP DS    F                PTR TO STEPNAME FIELD\nPARMPROG DS    F                PTR TO PROGRAMMER NAME FIELD\nPARMJOBC DS    F                PTR TO JOB CPU TIME FIELD\nPARMACCT DS    F                PTR TO JOB ACCOUNTING FIELDS\nPARMSTPC DS    F                PTR TO STEP CPU TIME FIELD\nPARMSACT DS    F                PTR TO STEP ACCOUNTING FIELDS\nPARMINDC DS    F                PTR TO CANCEL FLAG & STEP NUMBER\nPARMCOND DS    F                PTR TO CONDITION CODE FIELD\nPARMRECD DS    F                PTR TO SMF RECORD TO BE WRITTEN\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*       DYNAMIC WORK STORAGE                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nWORKAREA DSECT\nWORKSTRT EQU   *\nTEMP     DS    D\nTEMP1    DS    D\nR13SAVE  DS    F\nR12SAVE  DS    F\nR12SAVE2 DS    F\nR0SAVE   DS    F\nTIME     DS    F\nTIMEND   DS    F\nDATE     DS    F\nDATEND   DS    F\nSAVEAREA DS    45F\n         SPACE 2\nDDNSVE   DS    CL8           DDNAME SAVE AREA\nCONCATNO DS    F             CONCATENATION NUMBER ON DD STATEMENT\nSUPSW    DS    C\n         SPACE 2\n         DS    0D\n         DS    0F                 ASSURE FULLWORD/ NOT DBLWORD ALIGN\nPRTLINE  DS    CL130\nSYSPRINT DCB   MACRF=PM,LRECL=130,DSORG=PS,BLKSIZE=130,                X\n               RECFM=F,DDNAME=SYSPRINT\nOPENL    OPEN  (,(OUTPUT)),MF=L\nCLOSEL   CLOSE (,DISP),MF=L\nWTOANP02 WTO   'ANP002I JOB XXXXXXXX STEP ZZZ (CCCCCCCC) XXXXXX ABEND CX\n               ODE 999999',ROUTCDE=(11),MF=L\nANP02JBN EQU   WTOANP02+16,8      JOB NAME OFFSET\nANP02ST# EQU   WTOANP02+29,4      STEP # OFFSET\nANP02STN EQU   WTOANP02+35,8      STEP NAME OFFSET\nANP02UAT EQU   WTOANP02+45,6      OFFSET FOR USER ABEND TEXT\nANP02UAB EQU   WTOANP02+63,6      OFFSET FOR USER ABEND CODE\nANP02SAT EQU   WTOANP02+45,6      OFFSET FOR SYSTEM ABEND TEXT\nANP02SAB EQU   WTOANP02+63,3      OFFSET FOR SYSTEM ABEND CODE\nANP02SBL EQU   WTOANP02+66,3      OFFSET FOR BLANKS IN SYSTEM ABEND\nWTOANP03 WTO   'ANP003I JOB XXXXXXXX HIGHEST NON-ZERO COMPLETION CODE WX\n               AS 999',ROUTCDE=(11),MF=L\nANP03JBN EQU   WTOANP03+16,8      JOB NAME OFFSET\nANP03JCC EQU   WTOANP03+61,4      JOB COMPLETION CODE\nWTOANP04 WTO   'ANP004I JOB XXXXXXXX XXXXXX ABEND CODE 999999',        X\n               ROUTCDE=(11),MF=L\nANP04JBN EQU   WTOANP04+16,8      JOB NAME OFFSET\nANP04UAT EQU   WTOANP04+25,6      OFFSET FOR USER ABEND TEXT\nANP04UAB EQU   WTOANP04+43,6      OFFSET FOR USER ABEND CODE\nANP04SAT EQU   WTOANP04+25,6      OFFSET FOR SYSTEM ABEND TEXT\nANP04SAB EQU   WTOANP04+43,3      OFFSET FOR SYSTEM ABEND CODE\nANP04SBL EQU   WTOANP04+46,3      OFFSET FOR BLANK IN SYSTEM ABEND\nWORKEND  EQU   *\n         SPACE 2\nRELDYN   DSECT                    RELEASE INFORMATION\n         DS    C' OS/'\nSPREL    DS    C'        '\n         DS    C' '\nFMID     DS    C'        '\n         DS    C' CPU MODEL '\nMODEL    DS    C'    '\n         DS    C' '\n***********************************************************************\n*     PRINT IMAGES FOR STEP END AND JOB END LINES                     *\n***********************************************************************\n         SPACE 2\nSH1      DSECT\n         DS    4C\nSHEAD1   DS    CL18\nSHEAD1A  DS    CL23\n         DS    CL3\nSHEAD11A DS    CL47\n         DS    3C\nSTEPCL   DS    CL15\nSTEPCOND DS    CL5\nSTEPFLSH EQU   *-15\nSHEAD1B  DS    CL13\n         ORG   SHEAD11A\nSHEAD1J  DS    CL19\n         DS    CL17\nSHEAD1PH DS    CL10\n         DS    CL3\nSHEAD1PR DS    CL20\n         SPACE 2\nSH2      DSECT\n         DS    52C\nSHEAD2   DS    CL15\n         SPACE 2\nS4       DSECT\nSDDNME   DS    CL8\nSCOUNT   DS    CL7\n         SPACE 2\nJ1       DSECT\n         DS    15C\nJNM      DS    CL8\n         DS    18C\nJRDDT    DS    CL6\n         DS    23C\nJINITDT  DS    CL6\n         DS    26C\nJELAPSTM DS    CL8\n         SPACE 2\nJ2       DSECT\n         DS    15C\nJCLASS   DS    C\n         DS    25C\nJRDTM    DS    CL8\n         DS    21C\nJINITTM  DS    CL8\n         DS    24C\nJCPUTM   DS    CL11\n         SPACE 2\nJ3       DSECT\n         DS    15C\nJSUBS    DS    CL4\n         DS    22C\nJSYSTM   DS    CL8\n         DS    21C\nJENDTM   DS    CL8\n         DS    24C\nJSRBTM   DS    CL11\n         SPACE 2\n***********************************************************************\n*     DATA MACRO (IFASMFR) IS DISTRIBUTED IN SYS1.AMODGEN             *\n***********************************************************************\n         SPACE 2\n         PRINT   GEN\nSMF30    DSECT\n         IFASMFR 30                SMF TYPE 30 RECORD           MSEIPO4\n         IEFJMR                    JMR MAPS COMMON PARAMETER AREA\n         PRINT GEN\nIEFACTRT CSECT\n         END   IEFACTRT\n//LKED.SYSLMOD DD DISP=SHR,DSN=S$.OS390.LPALIB\n//LKED.AOSB3   DD DISP=SHR,DSN=STDL.OS390.R3.AOSB3\n//LKED.SYSIN   DD *\n  INCLUDE AOSB3(IEFTB724)\n  ENTRY IEFACTRT\n  NAME  IEFACTRT(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IOCOUN$$": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x18\\x01\\x19\\x19_\\x01\\x19\\x19_\\x14\\x16\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-07-14T00:00:00", "modifydate": "2019-07-14T14:16:18", "lines": 24, "newlines": 24, "modlines": 0, "user": "SBGOLOB"}, "text": "                   Note about IO counts in your jobs\n\nI have included Greg Price's IEFU83 exit package that is in member\n$$IEFU83.  This exit will effectively report on all the I/O counts\nand further information that is related, using the SMF exit IEFU83\nwhich Greg has coded.\n\nExample of IEFU93 output (folded over to fit into 80 columns:\n\nU83P14I  INPUT QSAM FILE SYSIN    CLOSED  3 EXCPS FOR SBGOLOB.B.ASM(NUMREPL)\n                                  BLKSZ=27920    27KB\nU83P14I  INPUT BPAM FILE SYSLIB   CLOSED 94 EXCPS FOR SYS1.MACLIB\n                                  BLKSZ=27920\nU83V15I OUTPUT QSAM FILE SYSLIN   CLOSED  2 EXCPS FOR\n                                  SYS19195.T094202.RA000.SBGOLOBU.TEMP.H01\n                                  BLKSZ=3200      6KB\nIEF142I SBGOLOBU ASMH - STEP WAS EXECUTED - COND CODE 0000\n\nSo you see the kind of information which this exit supplies.  It is even\nbetter than the old I/O count zap, which became difficult to implement,\nonce IBM developed System Managed Storage (SMS) which caused many module\nchanges and code path changes.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IOCOUNT": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x08\\x0f\\x01\\x01\\x06_\\x18\\x15\\x00\\x9e\\x00\\x96\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-03-20T00:00:00", "modifydate": "2001-03-06T18:15:00", "lines": 158, "newlines": 150, "modlines": 0, "user": "WSBG"}, "text": "                       THE EXCP-COUNT MODIFICATION\n\nNote:  On recent MVS Operating Systems which support SMS, this\n       system modification doesn't work anymore.  An alternative\n       solution is an SMF exit which writes I/O counts into the\n       job log.  See File 134, IEFU83, for an example, but I\n       believe there are IEFACTRT exits that do it too.\n\n       See member IEFACTRT that is included.  I think this program\n       can report EXCP counts for each ddname, and it works for\n       modern systems.\n\n                                   by Sam Golob\n\n       Nearly every computer user who runs a job wants to know what\nhis job DID.  If it read files and produced reports, and everything\nlooks good, it probably did what it was supposed to.  But you can't\nsay much more than that.  Very often you don't KNOW more than that.\n\n       Trust the machine?  We all have to, but it would be better if\nthe machine would tell us more.\n\n       There is one way to get the machine to tell you quite a bit\nmore.  We'll show you how to make it tell you all of its file I/O\nactivity.  For FREE.\n\n       File I/O in IBM/370 architecture is done by \"executing channel\nprograms\" (EXCP for short).  This means that the \"channels\", which can\nbe viewed as connectors between the CPU and peripheral devices, are\ninstructed (or programmed) how to transmit data between the computer\nitself and the connected device.\n\n       EXCP is the \"rock bottom\" of File I/O, in the same sense as\nMACHINE INSTRUCTIONS are the \"rock bottom\" of program execution in a\nCPU.  You can write a program in a higher-level language, such as\nCOBOL or PL/1, but before it can be run, it must be converted (or\n\"compiled\") into machine instructions. It is the machine instructions\nwhich actually RUN.\n\n       Same with File I/O.  You can tell the machine using ACCESS\nMETHODS such as QSAM, BSAM, or VSAM, what you want it to do with\nfiles, with reading or writing data.  But the \"access method source\"\ncannot do any transfer of data itself, just as COBOL SOURCE statements\ncannot tell a CPU what to do.  The \"access methods\" must first convert\nyour I/O orders into EXCP before any data transfers can be done.  The\ndata transfer machinery only understands EXCP; it does not understand\n\"access method source\" directly.\n\n       Counting the NUMBER OF TIMES a channel program was executed to\na particular file gives some indication of how much file I/O activity\nthere was.  This measure of file activity is called EXCP COUNTS.  A\nnumber of vendor products are available to supply that kind of\ninformation for your jobs.  I personally haven't done a survey of them\nbecause I have a FREE method of providing the data, which is probably\nbetter than all of them.  We can actually MAKE THE MVS OPERATING\nSYSTEM ITSELF supply us with EXCP counts to EACH ALLOCATED DD NAME,\nright in the JCL allocation messages themselves!\n\n       How can we accomplish this wonderful thing?\n\n       First let me tell you what you'll get.  If you're running MVS,\nyou've all seen JCL allocation messages for files on your job printouts.\nThey look like:\n\n  IEF285I   SYS1.LINKLIB       KEPT\n  IEF285I   VOL SER NOS= MVSRES.\n\nAfter you've done our magic, you get:\n\n  IEF285I   SYS1.LINKLIB       KEPT  *----1,294\n  IEF285I   VOL SER NOS= MVSRES.\n\nYou get this for all allocated ddnames.  On my system, I've even\nseen the counts on the MASTER JCL that was executed at IPL time.\nThe counts can be seen on the SYSLOG from the very beginning of\nsystem initialization. MVS itself is made to provide them.  You\ndon't have to rely on SMF records, as many of the vendor packages\ndo.\n\n       OK, OK. I'll tell you how it's done.  The system module which\nproduces the IEF285I messages is called IEFAB4B0.  On MVS/370, the\nmodule has not changed since base version 3.8.  On MVS/XA, it has also\nnot changed since the base level.  This is how the counts are obtained.\nIEFAB4B0 is expanded to add a patch area at the end.  Code is inserted\ninto the patch area which obtains the counts and puts them into the\nIEF285I message.  The code works as follows:  It goes back into the\nmodule which CALLS IEFAB4B0 (its name is IEFAB4A2) by accessing the\nsaved registers from the calling program.  It is this calling program,\nIEFAB4A2, which has access to the DSAB control block that contains the\nEXCP-count information.  The patched code in IEFAB4B0 uses ITS CALLER's\nREGISTERS and acts for a while as if it were really executing in the\ncaller, IEFAB4A2. After the information is obtained, it is formatted\nand inserted into the IEF285I message.\n\n       Cool!  This is the concept.  Now how can you install it?\n\n       The code is on the Connecticut Bank and Trust MVS Mods Tape,\nknown as the CBT tape, FILE 369, and it was donated by Dick Sziede and\nhis staff of the Planning Research Corporation at Dulles Airport in\nVirginia.  Dick is running MVS/XA in his shop.  His old MVS/370\nversion is maintained by me, and that code is in File 369 also.  The\nzap is applied to IEFAB4B0 in the form of an SMP usermod, but the\nusermod is generated in a very novel manner.\n\n       Howard Gilbert of Yale University Computer Center, one of the\ngeniuses of user-written MVS software, has a PL/1 program called\nASMTOZAP, whose SOURCE is on File 369 of the CBT tape. (The LOAD MODULE\nis on FILE 035 of most recent versions of the CBT tape.)  ASMTOZAP\nallows you to code SYSTEM ZAPS as if they were ASSEMBLER PROGRAMS.\n\n       This is how ASMTOZAP works.  Certain control statements are\ncoded as comments in your assember source code telling ASMTOZAP where\nto start the VER statements and where to start the REP statements.\n(You don't have to do this in the EXCP-count mod, because it is already\ndone.)  You assemble the source code (NO LINKEDIT please) and create a\nLISTING on a disk file.  You then run the PL/1 program ASMTOZAP against\nthe LISTING. In our case, it produces an already-coded SMP USERMOD,\nwhich has the zap in it.\n\n       Now.  After editing the generated usermod to your installation's\ntaste, and applying it, the LMOD, which is called IEFW21SD, is changed\nin LPALIB, and an IPL with CLPA will allow you to test the mod.\n\n       ONE WARNING is in order.  The calling mod IEFAB4A2 is sensitive\nto IBM maintenance.  Whenever IEFAB4A2 is changed, you must look into\nthe FICHE of the new PTF level for the field called DSABPTR.  In my\ncurrent version on MVS/370, this is at displacement +138 hex, into\nIEFAB4A2.  This displacement must be hard-coded into your usermod.\nNotes in the assembler source will tell you where to code it.  The\ndisplacement of the DSABPTR has been known to change with fairly recent\nmodifications of IEFAB4A2, and you must check it with every change to\nthat module.  I safeguard myself by doing a UCLIN of my USERMOD NUMBER\nas a UMID to IEFAB4A2, even though IEFAB4A2 is not itself affected by\napplying the usermod.  This gives me an ID check in SMP whenever\nmaintenance hits this module.  The other module IEFAB4B0 which has the\nzap in it, never has gotten maintenance to it.\n\n       There are 2 versions of the mod, one for MVS/370 and one for XA.\nThe one for XA has been worked over at Planning Research Corp.  to\nhandle I/O counts to multi-volume disk datasets, whereas the MVS/370\none has not been so reworked.  It is on my wish list to rework it.  The\n370 version shows the I/O's to the last volume only.  The mod is still\ngreat, however.\n\n       Just a final note.  The USERMOD as supplied by File 369 has a\nlinkedit EXPAND statement in it.  This EXPAND only has to be done once.\nIn my shop, I separated the EXPAND into a separate USERMOD that PREs\nthe zap.  This way, if I have to repeat the APPLYing of the zap, it\nwon't keep expanding the size of the IEFAB4B0 module.\n\n       You are referred to additional members of this file which will\nshow you what this modification looks like, both in original assembler\nsource and in generated zap form as it is applied at my shop.  Also\nincluded is ASMTOZAP execution JCL.\n\n       Good luck.  Everyone in your shop will enjoy this one!\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IOCOUNTA": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x08\\x0f\\x00\\x88\\x08\\x0f\\x15\\x00\\x00\\x8f\\x00\\x8f\\x00\\x00\\xe3\\xe2\\xe3\\xf2\\xe2\\xe2\\xc7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-03-20T00:00:00", "modifydate": "1988-03-20T15:00:00", "lines": 143, "newlines": 143, "modlines": 0, "user": "TST2SSG"}, "text": "*-------\n*------- TITLE LM02301...I/O COUNT  IN MSG IEF285I\n*-------\n*------- AUTHOR LARRY KRAUSE...LITTON COMPUTER SERVICES 1978\n*-------        DICK SZIEDE....GENERAL ELECTRIC 1983\n*-------\n*------- BACKGROUND AS FAR AS I KNOW,LARRY IS THE ONLY ONE TO\n*-------       WRITE A MVS VERSION  OF THIS MOD,  ALTHOUGH IT\n*-------       COMMON IN MVT (RICK  DUVALL...CSC) AND SVS (AUTHOR\n*-------       UNKNOWN).  THIS VERSION HAS BEEN RECODED IN ASMTOZAP\n*-------       FORMAT FOR MVS SP1.3, WITH SOME COSMETIC CHANGES.\n*-------       ...DICK SZIEDE...CSC 1982.\n*-------       MAKE WORK UNDER VS ASSEMBLER INSTEAD OF ASMH, AND\n*-------       MORE COSMETIC CHANGES...DICK SZIEDE, GE 1983.\n*-------\n*ZAP     CARD ++ USERMOD(LM02301) /* I.O COUNTS IN IEF285I */.\n*ZAP     CARD ++ VER(Z038) FMID(EBB1102) PRE(JBB1326).\n*ZAP     CARD ++ ZAP (IEFAB4B0).\n*ZAP     CARD  NAME IEFAB4B0\n*ZAP     CARD  EXPAND IEFAB4B0(128)\nLM02301A CSECT\nIEFAB4B0 DS    0H\n         PRINT ON,GEN,DATA\n         ORG   @PSTART\n         USING *,@12\n         USING @DATD,@11\n*ZAP     START VER\n         ORG   CLRKEY\n         STC   @02,@OLDKEY\n         ORG   CLRTXT\n         MVC   MSGBUFFR+1(73),MSGBUFFR  BLANK ENTIRE BUFFER\n         ORG   STEAL\n         MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n         ORG   @EL00001\n         IC    @02,@OLDKEY\n         ORG   @SIZDATD\n         DC    AL1(230),AL3(@ENDATD-@DATD)\n         ORG   PATCH\n         DC    4F'0'\n*ZAP     START REP\n         ORG   CLRKEY\n         STC   @02,@NEWKEY\n         ORG   CLRTXT\n         MVC   MSGBUFFR+1(78),MSGBUFFR  BLANK ENTIRE BUFFER\n         ORG   STEAL\n         B     PATCH\nMAINLINE EQU   *\n         ORG   @EL00001\n         IC    @02,@NEWKEY\n         ORG   @SIZDATD\n         DC    AL1(230),AL3(@NEWDATD-@DATD)\n         ORG   PATCH\nPATCHOUT MVI   MSGLNGTH+3,79       SET MSGLNGTH TO 79\n*        L     @10,@PC00001        ADDR OF MSGID\n*        TM    0(@10),X'01'        MSGID=1 ?\n*        BNO   PATEXIT                 NO ==> WE EXIT.\n         L     @10,4(,@13)         ADDR OF IEFAB4A2'S SAVE AREA\n         L     @10,X'3C'(,@10)     IEFAB4A2'S R10\n         ICM   @10,15,X'138'(@10)  ADDR OF DSAB (IEFAB4A2 DSABPTR\n*                                       LEVEL JBB1329 UZ84610)\n         BZ    PATEXIT             EXIT IF NO DSAB\n         L     @10,DSABTIOT(,@10)  ADDR OF TIOT ENTRY\n         SLR   @06,@06             CLEAR WORK REG\n         CH    @06,TIOPSTTB(,@10)  IS THERE A UCB ENTRY IN TIOT?\n         BZ    PATEXIT                NO ==> WE QUIT.\n         L     @01,@PC00001+16     ADDR OF JSCB PTR\n         L     @01,0(,@01)         ADDR OF JSCB\n         L     @04,JSCBTCBP(,@01)  ADDR OF INIT'S TCB\n         L     @01,JSCTMCOR(,@01)  ADDR OF TIOT MGMT AREA\n         S     @10,X'18'(,@01)     CALC TIOT ENTRY OFFSET\n         ICM   @04,15,TCBTCT(@04)  ADDR OF TIMING CONTROL TABLE\n         BZ    PATEXIT             EXIT IF NONE\n         L     @04,TCTIOTBL(,@04)  ADDR OF TCT I/O TABLE\n         LA    @05,TCTDCBTD(,@04)  ADDR OF 1ST DD LOOKUP TABLE ENTRY\nPATDDLOP CH    @06,0(,@05)         LAST ENTRY IS ZERO\n         BZ    PATEXIT                  EXIT IF ZERO.\n         CH    @10,0(,@05)         DO THE TIOT DISPLACEMENTS MATCH?\n         BE    PATPRINT                 YES ==> PRINT I/O COUNT.\n         LA    @05,4(,@05)         BUMP TO NEXT DD TABLE ENTRY\n         B     PATDDLOP\n         SPACE\nPATPRINT AH    @04,TCTIOTSD(,@05)  OFFSET TO THE DEVICE ENTRY\n*                                  (TCTDDENT OR TCBUCBP)\n         L     @06,TCTDCTR(,@04)   GET THE I/O COUNT\n         CVD   @06,MSGDISP+1       INTO PACKED FORMAT\n         MVC   MSGCOUNT(L'EDMSK1),EDMSK1 PREPARE TO EDIT\n         ED    MSGCOUNT(L'EDMSK1),MSGDISP+5 STICK IN SOME COMMAS\n         MVI   MSGCOUNT,C'*'       MARK WITH A SPLAT\nPATEXIT  MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n         B     MAINLINE\n*\nEDMSK1   DC    X'60206B2020206B202120'\n*ZAP     END\n@DATD    DSECT\n         ORG   @DATD+X'48'\n@PC00001 DS    5F\n         ORG   @DATD+X'B4'\nMSGLNGTH DS    F\n         DS    2F\nMSGBUFFR DS    C\n         ORG   @DATD+X'F7'\nMSGDISP  DS    X\n         ORG   @DATD+X'105'\nMSGCOUNT DS    CL6\n@OLDKEY  DS    AL1\n@ENDATD  EQU   *\n         ORG   @DATD+X'120'\n@NEWKEY  DS    AL1\n         DS    D                   ALIGN TO DUBBLEWORD FOR GETMAIN\n@NEWDATD EQU   *\n         SPACE\nLM02301A CSECT\n*        ***** EQUATES FOR DSECTS  I'M TOO LAZY TO DO THE DROPS\n*        ***** 'N USINGS FOR.\nDSABTIOT EQU   X'10'\nTIOPSTTB EQU   X'12'\nJSCBTCBP EQU   X'D0'                   '\nJSCTMCOR EQU   X'14C'                  '\nTCBTCT   EQU   X'A4'\nTCTIOTBL EQU   X'C'\nTCTDCBTD EQU   X'8'\nTCTIOTSD EQU   X'2'\nTCTDCTR  EQU   X'4'\n*\n*        ***** EQUATES FOR LOCATIONS WITHIN IEFAB4B0\n@PSTART  EQU   IEFAB4B0+X'1C'\nCLRKEY   EQU   IEFAB4B0+X'52'\nCLRTXT   EQU   IEFAB4B0+X'76'\nSTEAL    EQU   IEFAB4B0+X'156'\n@EL00001 EQU   IEFAB4B0+X'2EE'\n@SIZDATD EQU   IEFAB4B0+X'3E8'\nPATCH    EQU   IEFAB4B0+X'45C'\n*        ***** AND OF COURSE, THE REGISTERS\n@01      EQU   01\n@02      EQU   02\n@04      EQU   04\n@05      EQU   05\n@06      EQU   06\n@10      EQU   10\n@11      EQU   11\n@12      EQU   12\n@13      EQU   13\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IOCOUNTB": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x08\\x0f\\x00\\x88\\x08\\x0f\\x15\\x00\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe3\\xe2\\xe3\\xf2\\xe2\\xe2\\xc7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-03-20T00:00:00", "modifydate": "1988-03-20T15:00:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "TST2SSG"}, "text": "++ USERMOD(NZPIO05) /* I.O COUNTS IN IEF285I\n DOCUMENTATION:        S. GOLOB - NEWSWEEK INCORPORATED - 12/16/85\n   THIS USERMOD WAS INSTALLED FROM FILE 369 OF THE CBT254 SHARE MODS\n   TAPE FOR MVS.  THIS PART OF THE USERMOD EXPANDS THE MODULE IEFAB4B0\n   TO PROVIDE A PATCH AREA FOR THE ZAP.  THE USERMOD NZPIO06 INSERTS\n   THE ZAP CODE.\n\n   */.\n++ VER(Z038) FMID(EBB1102) PRE(JBB1329 UZ84610).\n++ ZAP (IEFAB4B0).\n NAME IEFAB4B0\n EXPAND IEFAB4B0(128)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IOCOUNTC": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x08\\x0f\\x00\\x88\\x08\\x0f\\x15\\x00\\x00_\\x00_\\x00\\x00\\xe3\\xe2\\xe3\\xf2\\xe2\\xe2\\xc7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-03-20T00:00:00", "modifydate": "1988-03-20T15:00:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "TST2SSG"}, "text": "++ USERMOD(NZPIO06) /* I.O COUNTS IN IEF285I */  .\n++ VER(Z038) FMID(EBB1102)\n             PRE(JBB1329 UZ84610 NZPIO05)\n /*\n DOCUMENTATION:        S. GOLOB - NEWSWEEK INCORPORATED - 01/21/87\n   THIS USERMOD WAS INSTALLED FROM FILE 369 OF THE CBT254 SHARE MODS\n   TAPE FOR MVS.  IT WAS NOT CORRECT AS FOUND THERE BECAUSE OF AN\n   INCORRECT DSAB POINTER (DSABPTR) IN MODULE IEFAB4A2, WHICH BELONGS\n   TO FMID JBB1329 (MVS SP 1.3.3) AND IS ON OUR SYSTEM AT RMID UZ75725\n   (PUT TAPE 8409).  THE OLD POINTER OF 013C NOW POINTS TO THE JFCB\n   AND IF YOU LEAVE IT THIS WAY, THIS MOD ABENDS JES2.  IT SHOULD BE\n   0138 INSTEAD.\n\n   NOTE:  YOU MUST DO THE FOLLOWING UCLIN TO DISABLE IBM MAINTENANCE\n            ON MODULE IEFAB4A2, WHICH CHANGES MORE FREQUENTLY.\n\n     UCLIN CDS.\n     REP MOD(IEFAB4A2) RMID(NZPIO06).\n     ENDUCL.\n\n   */  .\n++ ZAP (IEFAB4B0).\n NAME IEFAB4B0\n*                            ORG   CLRKEY\nVER 0052 4220,B10B           STC   @02,@OLDKEY\n*                            ORG   CLRTXT\nVER 0076 D248,B0C1,B0C0      MVC   MSGBUFFR+1(73),MSGBUFFR  BLANK ENTIRE BUFFER\n*                            ORG   STEAL\nVER 0156 9240,B0F8           MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n*                            ORG   @EL00001\nVER 02EE 4320,B10B           IC    @02,@OLDKEY\n*                            ORG   @SIZDATD\nVER 03E8 E600,010C           DC    AL1(230),AL3(@ENDATD-@DATD)\n*                            ORG   PATCH\nVER 045C 0000,0000,0000,0000 DC    4F'0'\nVER 0464 0000,0000,0000,0000\n*                            ORG   CLRKEY\nREP 0052 4220,B120           STC   @02,@NEWKEY\n*                            ORG   CLRTXT\nREP 0076 D24D,B0C1,B0C0      MVC   MSGBUFFR+1(78),MSGBUFFR  BLANK ENTIRE BUFFER\n*                            ORG   STEAL\nREP 0156 47F0,C440           B     PATCH\n*                   MAINLINE EQU   *\n*                            ORG   @EL00001\nREP 02EE 4320,B120           IC    @02,@NEWKEY\n*                            ORG   @SIZDATD\nREP 03E8 E600,0130           DC    AL1(230),AL3(@NEWDATD-@DATD)\n*                            ORG   PATCH\n*                   PATCHOUT EQU   *\nREP 045C 924F,B0B7           MVI   MSGLNGTH+3,79       SET MSGLNGTH TO 79\nREP 0460 58A0,B048           L     @10,@PC00001        ADDR OF MSGID\nREP 0464 9101,A000           TM    0(@10),X'01'        MSGID=1 ?\nREP 0468 47E0,C4C6           BNO   PATEXIT                 NO ==> WE EXIT.\nREP 046C 58A0,D004           L     @10,4(,@13)         ADDR OF IEFAB4A2'S SAVE A\nREP 0470 58A0,A03C           L     @10,X'3C'(,@10)     IEFAB4A2'S R10\nREP 0474 BFAF,A138           ICM   @10,15,X'138'(@10)  ADDR OF DSAB (IEFAB4A2 DS\n*                                       LEVEL JBB1329 RMID UZ75725)\nREP 0478 4780,C4C6           BZ    PATEXIT             EXIT IF NO DSAB\nREP 047C 58A0,A010           L     @10,DSABTIOT(,@10)  ADDR OF TIOT ENTRY\nREP 0480 1F66                SLR   @06,@06             CLEAR WORK REG\nREP 0482 4960,A012           CH    @06,TIOPSTTB(,@10)  IS THERE A UCB ENTRY IN T\nREP 0486 4780,C4C6           BZ    PATEXIT                NO ==> WE QUIT.\nREP 048A 5810,B058           L     @01,@PC00001+16     ADDR OF JSCB PTR\nREP 048E 5810,1000           L     @01,0(,@01)         ADDR OF JSCB\nREP 0492 5840,10D0           L     @04,JSCBTCBP(,@01)  ADDR OF INIT'S TCB\nREP 0496 5810,114C           L     @01,JSCTMCOR(,@01)  ADDR OF TIOT MGMT AREA\nREP 049A 5BA0,1018           S     @10,X'18'(,@01)     CALC TIOT ENTRY OFFSET\nREP 049E BF4F,40A4           ICM   @04,15,TCBTCT(@04)  ADDR OF TIMING CONTROL TA\nREP 04A2 4780,C4C6           BZ    PATEXIT             EXIT IF NONE\nREP 04A6 5840,400C           L     @04,TCTIOTBL(,@04)  ADDR OF TCT I/O TABLE\nREP 04AA 4150,4008           LA    @05,TCTDCBTD(,@04)  ADDR OF 1ST DD LOOKUP TAB\n*                   PATDDLOP EQU   *\nREP 04AE 4960,5000           CH    @06,0(,@05)         LAST ENTRY IS ZERO\n*\nREP 04B2 4780,C4C6           BZ    PATEXIT                  EXIT IF ZERO.\nREP 04B6 49A0,5000           CH    @10,0(,@05)         DO THE TIOT DISPLACEMENTS\nREP 04BA 4780,C4AA           BE    PATPRINT                 YES ==> PRINT I/O CO\nREP 04BE 4150,5004           LA    @05,4(,@05)         BUMP TO NEXT DD TABLE ENT\nREP 04C2 47F0,C492           B     PATDDLOP\n*                   PATPRINT EQU   *\nREP 04C6 4A40,5002           AH    @04,TCTIOTSD(,@05)  OFFSET TO THE DEVICE ENTR\n*                                  (TCTDDENT OR TCBUCBP)\nREP 04CA 5860,4004           L     @06,TCTDCTR(,@04)   GET THE I/O COUNT\nREP 04CE 4E60,B0F8           CVD   @06,MSGDISP+1       INTO PACKED FORMAT\nREP 04D2 D209,B105,C4CE      MVC   MSGCOUNT(L'EDMSK1),EDMSK1 PREPARE TO EDIT\nREP 04D8 DE09,B105,B0FC      ED    MSGCOUNT(L'EDMSK1),MSGDISP+5 STICK IN SOME CO\nREP 04DE 925C,B105           MVI   MSGCOUNT,C'*'       MARK WITH A SPLAT\n*                   PATEXIT  EQU   *\nREP 04E2 9240,B0F8           MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\nREP 04E6 47F0,C13E           B     MAINLINE\n*\n*                   EDMSK1   EQU   *\nREP 04EA 6020,6B20,2020,6B20 DC    X'60206B2020206B202120'\nREP 04F2 2120\n* DECK PRODUCED BY THE ASMTOZAP UTILITY 85/12/16 165820\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IOCOUNTD": {"ttr": 2062, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x08\\x0f\\x00\\x88\\x08\\x0f\\x15\\x00\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe3\\xe2\\xe3\\xf2\\xe2\\xe2\\xc7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-03-20T00:00:00", "modifydate": "1988-03-20T15:00:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "TST2SSG"}, "text": "//TST2DP2S JOB ,'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TST2SSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//******************************************************************//\n//*   ASMTOZAP EXECUTION - FILE 317 OF CBT254 TAPE                 *//\n//******************************************************************//\n//*\n//COPY1   EXEC PGM=ASMTOZAP\n//STEPLIB  DD  DISP=SHR,DSN=TST.TSO.CMDLIB\n//*        DD  DISP=SHR,DSN=TSY2.PLILINK\n//SYSPRINT DD  SYSOUT=*\n//PL1DUMP  DD  SYSOUT=*\n//IN       DD  DISP=SHR,DSN=TST2SSG.NZPIO.ASM    ASMBLR LISTING ON DISK\n//OUT      DD  DISP=SHR,DSN=TST2SSG.NZPIO.PLI,   OUTPUT OF ASMTOZAP PGM\n//      DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JESART": {"ttr": 2064, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x08\\x0f\\x00\\x88\\x08\\x0f\\x15\\x00\\x00o\\x00o\\x00\\x00\\xe3\\xe2\\xe3\\xf2\\xe2\\xe2\\xc7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-03-20T00:00:00", "modifydate": "1988-03-20T15:00:00", "lines": 111, "newlines": 111, "modlines": 0, "user": "TST2SSG"}, "text": "        SOME NOTES ON JES2 1.3.6 (AND ITS EQUIVALENT, 2.1.5)\n\n      I enjoyed the article in the September issue concerning the\ninstallation of the JES2 1.3.6 8701 level set.  This 8701 level set of\nJES2 is non-trivial, even to seasoned systems programmers, because of\nthe changes in format of JES2 internal control blocks which were made\nat that time.  It would not be entirely inaccurate to call that level\nset a mini-release change.  As you stated, one running JES2 can now\nsupport 9999 printers, whereas only 99 were supported before.\n\n      I have a couple of addenda to the topics talked about.\nFirst but not least, you must reassemble and relinkedit all of your\nuser exits at this level.  You must also pray that this will be enough\nto do, to make them run.  When I first installed 8701 for JES2 1.3.6,\nthe system crashed as soon as the first exit was invoked.  It took\nseveral dozen IPLs of my test MVS system to get a handle on what was\nflying, plus several calls to Level 2.  Now they tell me I should have\nread the fine print in the documentation!  The truth finally came to\nlight when I disabled all the exits before attempting to bring up\nJES2, and it came up.\n\n      Second, (also not least), I should like to emphasize the\nadvantage of JES2 1.3.6 (or the XA equivalent 2.1.5) over the previous\n1.3.4 release level.\n\n      Number one, it saves you a considerable number of cold starts.\nMany of the parameters which previously required cold starts now can\nbe changed with warm starts or operator commands.  Number two, console\ndisplays of JES2 status and parameter settings have been considerably\nimproved.  Also, more parm settings can be changed with operator\ncommands, so that much more operator flexibility is possible than\nheretofore.  Number three, that old bugaboo SPOOL OFFLOAD has been\nrewritten practically from scratch.  Believe it or not, it is now\nconvenient to use, and you no longer have to dream wistfully of your\nold spool-unloader friend HJSTP from Release 4.1.  This new spool\noffload is GOOD.\n\n      My experience is that if you can swing it, it pays to convert\nto 1.3.6 (2.1.5).  It is very considerably better than 1.3.4.\n\n      Now for the flip side... the WORK.\n\n      You'd better have a Washington Systems Center book on hand,\nespecially if you have exits.  Its name is \"JES2 1.3.6 Migration\nConsiderations\".  It has all the useful hints, and it documents the\nchanges to the field names, label names, and DSECT names in JES2\nmain line code and macros.  I think that's the only place where\nyou'll find these necessary things documented.  It is extremely\nimportant to have a \"JES2 Initialization and Tuning\" book for 1.3.6.\nIf you have the 8701 level set, there is an upgraded edition which\ncovers the changes made at that level.  A \"JES2 Commands\" book for\n1.3.6 can't hurt.  And if you have exits, you need \"JES2 User\nModifications and Macros\" for 1.3.6.\n\n      The SMP work is trivial.  It is no harder than installing any\nother small new function.  The tough part is the new JES2 Init Parm\ndeck.  Almost all of the parameter formats have changed.  It took me\na solid week to recode my deck, with many adjustments made later.\nThe consolation is that once this has been done, it is probable that\nIBM will not further change the format for many years to come.  My\ndeck grew in size from 238 lines to over 1600 lines.  IBM recommends\nthat you take it out of SYS1.PARMLIB, which is unblocked, and put it\nin a blocked library, such as SYS1.PROCLIB.\n\n      The sample JES2PARM deck, which IBM provides in the install\nprocess, proved to be a useful starting point.  It codes most of the\ntypical items in a normal deck, and gives the 1.3.4 old-style format\ninside of comments at the right side of each parameter.  I made a copy\nof it and changed it, item by item, to correspond to my existing deck.\nThis took a solid week, working all day.  It had to be checked over\nand over.  I kept two JES2 \"I and T\" books handy at the time to check\nfor default values--one was the 1.3.4 book, the other was the 1.3.6.\n\n      When you're doing this monstrous job (it's not really so bad),\nyou have to keep abreast of default settings, both for 1.3.6 and for\n1.3.4.  In some cases they have changed. Your goal is to keep the\nnew 1.3.6 system as transparent to the user as possible, and if you\nget a default wrong in a JES2PARM deck parameter, it will be noticed\nby the users sooner or later (usually sooner).  It IS possible to get\nthe new system to work just about the same as the old one did.\n\n      All exits have to be converted.  The \"JES2 1.3.6 Migration\nConsiderations\" is a must for this, even more than the \"JES2 Usermods\nand Macros\", though both are needed.  My technique for conversion\nwas to assemble my old source with the new macro library for 1.3.6,\nand to correct the assembly errors by substituting the new label\nnames I found in the \"Migration\" book for the names reported in error\nby the assembler.  This may not be sufficient for your exits.  You\nmust check these books for all their notes on each particular exit.\nThe acid test for exits, of course, is to see if they work on the\nnew JES2 system.  Exits are sensitive in JES2, as anyone with\nexperience knows, and you must test them in action.\n\n      The final point is to make sure that any products which depend\non JES2 are available for the new release.  We use the QUEUE program\nfrom the CBT tape to read spool datasets.  I had a version installed\nfor 1.3.4 (file 393 on the CBT tape).  I called Jack Schudel, who\nadministers the JES2 User Mods tape, to make sure that a 1.3.6 version\nwas available.  He sent me an equivalent version which had been changed\nfor 1.3.6 (2.1.5) which I tried, and which we had to debug.  A good\nversion is now available on the CBT tape file 394.  My point is that\nif you have a JES2-dependent product, such as SDSF, IOF, or QUEUE,\nyou must be sure that a 1.3.6 version is available, before you install\n1.3.6 or 2.1.5.\n\n      Well, good luck, and don't forget that you'll need a cold\nstart!  This conversion may require work, but it will have to be made\neventually, as IBM drops support for the old release level.  It also\nresults in considerable convenience and reliability benefits, and I\nthink you'll be glad you did it in the end.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMPARTCL": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x01\\x03\\x9f\\x01\\x01\\x03\\x9f\\x19\\x07\\x03\\x15\\x03\\x13\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-02-08T00:00:00", "modifydate": "2001-02-08T19:07:00", "lines": 789, "newlines": 787, "modlines": 0, "user": "WSBG"}, "text": "./ ADD NAME=SMPINTRO 0100-01039-01039-1901-00055-00055-00000-WSBG\n\n                 INTRODUCTION TO MY 1988 SMP ARTICLE\n\n\n      My article, which explains the basic concepts of SMP and SMP/E,\nwas written in 1988, and is still almost completely applicable today.\nI'm going to show you, in a few pages, how to understand SMP/E.  Let's\nfirst just say a few vitriolic, but true, introductory words.\n\n      IBM has a habit of \"only touting its latest stuff\".  They tell\nus:  \"Here's our product SMP/E, which helps you maintain your MVS\nsystem!\"  What they don't tell you are the concepts that are necessary\nto grasp, so an intelligent person can get a basic understanding of\nSMP/E ideas in a reasonable amount of time.\n\n      In order to understand SMP/E, you have to understand where it\ncame from.  SMP/E came from an effort to automate and keep track of\nthe SYSGEN process, and how to put subsequent fixes on an already-\ngenerated MVS operating system.  It is my fervent and passionate\nbelief, that if you don't understand the SYSGEN process, you'll never\nhave a clue to really understanding what SMP/E is all about.\n\n      Problem:  We don't do SYSGENs any more today, to construct an\nMVS system.  The reason is that IBM has done them for us, before they\nshipped us the new system.  The information from their SYSGEN of our\nsystem is buried in the JCLIN information, in the target SMP/E control\ndatasets, of the system that they ship us.\n\n      Previously, we could not dig that information out.  Now we can.\nIn the newer SMP/E releases, after Release 1.3, there is an \"un-JCLIN\"\nprocess in SMP/E, otherwise known as the GENERATE command.  Using\nGENERATE, we can re-create assembly and link-edit information which\nis buried in the SMP/E datasets--the same information, like the SYSGEN\ninformation, that tells us how the pieces of our system were put\ntogether in the first place.\n\n      So, we begin our journey as I take you back in time--to a time\nthat IBM will never admit ever existed--to the (ancient) time when\nSYSGENs were done, to build MVS systems.  We must go back there.\nBecause, if we don't ever go back there, we'll never have a clue to\nunderstanding what IBM is selling us now--this nice, neat, clever,\nintricate SMP/E product.\n\n      This is the truth.  Isn't \"official IBM\" great?  They don't give\nus what we need, because it's based on history, and they can't admit\nthat history exists, because they want to sell us their newest stuff!\n\n      That's why we have USERS helping each other, and that's why I'm\nhelping you.  It took me 4 long years to learn what could have taken 3\nweeks, with a decent explanation, that wasn't there.  Once I learned\nthe stuff, I vowed to provide the explanation too!\n\n      So let's go learn about SMP/E from the beginning--the beginning\nof time!\n\n./ ADD NAME=SMPART   0101-88080-01038-1339-00732-00734-00000-WSBG\n\n                           SMP DE-MYSTIFIED\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n       Many otherwise-expert MVS systems programmers shy away from\ndoing operating system maintenance.  Many new MVS systems programmers\nhave a very hard time getting started with doing this necessary work.\nThat is not because the work is intrinsically difficult, but because\nIBM, until recently, has not provided to-the-point introduction to\ntheir very good SMP maintenance products.  We propose to do so.  After\nthese several pages, the reader should feel much more confident with\nIBM's SMP products and SMP literature.\n\n       SMP stands for \"System Modification Program\".  It is exactly\nthat.  SMP does every operation necessary to maintain the MVS operating\nsystem:  source updates, assemblies, linkedits, copy operations, and\nzaps.  It keeps a thorough accounting of everything it did, and it also\nallows the user to back out bad changes to the system.  Every facility\nprovided in SMP is for this purpose, and this purpose only.\n\n       The PURPOSE OF SMP must be constantly borne in mind when trying\nto navigate its forbidding vocabulary.  All of the strange words:\nJCLIN, UCLIN, FUNCTION, DLIB, RESTORE, RELFILE, and so forth, are only\nlabels for things that are NECESSARY TO KEEP TRACK OF THE OPERATING\nSYSTEM MAINTENANCE.  THEY ARE NOTHING MORE THAN THAT.  We'll try to\nstraighten you out on most of them, so they are put in their proper\nperspective and their purpose is understood.\n\n       Just for the record, IBM distributes two types of SMP.  SMP\nRelease 4, known as SMP4, is the old version.  It is provided free\nwith the operating system, and it works.  It just doesn't have so many\nbells and whistles.  IBM has a much more enhanced product, known as\nSMP Extended, or SMP/E.  A large majority of MVS installations use\nSMP/E, and its use is recommended.  Most of the principles I will\ndiscuss apply equally to both versions, since my purpose is to provide\nenough insight and perspective for the reader to be comfortable with\nthe IBM literature.  The name \"SMP\" will suffice for reference to things\napplicable to both versions.  Features particular to SMP/E will be\nlabeled as such.\n\n       We must begin by describing how IBM has historically distributed\nits MVS Operating System releases.  That process is known as \"SYSGEN\".\nHow the SYSGEN process works must be clearly understood before one can\nhope to get a clear picture of how SMP works.  IBM does not describe the\ncontrast and connection between SYSGEN and SMP clearly enough in its SMP\nliterature.  Therefore, we will now discuss how the SYSGEN process\nworks.\n\n       MVS was always (and is still) extremely flexible to the\nindividual customer's needs and hardware configuration.  Each customer's\noperating system was intended to be configured by the customer, and not\njust dumped in by the manufacturer, as is true with many other operating\nsystems.  IBM therefore distributes the individual pieces of the system,\nand it is up to the customer to put them together so that he creates a\ncomplete working system that is appropriate to his needs.  Since the\ncustomer does not have the smarts of the IBM system designers, IBM gives\nhim the means to accomplish the feat of system construction in a rather\nstraightforward way.  This is what the SYSGEN is.\n\n       The individual components of MVS, whether they be assembler\nmacros, source, linkedited csects, sample JCL, or other ELEMENTS, are\ndistributed to the customer in individual partitioned datasets or\nlibraries.  These are called DISTRIBUTION LIBRARIES appropriately.\nMembers of Distribution Libraries can be pictured as the BRICKS FROM\nWHICH THE BUILDING WILL BE BUILT.  Where then is the PATTERN or DESIGN\nfor the building?  The pattern is put into a system of assembler\nmacros known as \"SYSGEN MACROS\".  The SYSGEN MACROS contain the smarts\nfor building the operating system, and we must trust that IBM supports\nthem correctly.\n\n       What must the customer do, then?  The customer must code a\nsystem configuration deck of assembler statements which contain the\nSYSGEN MACROS that are appropriate for his installation's hardware and\nsoftware configuration.  IBM refers to this deck as the STAGE I SYSGEN\nDECK.  A working operating system, called the TARGET SYSTEM, cannot be\nmade unless a STAGE I SYSGEN DECK has been coded, either by IBM in a\nsample generated system, or by the customer.\n\n       What next?  The STAGE I DECK is assembled, using the\nDISTRIBUTION LIBRARIES as the source for the SYSGEN MACROS.  The\nassembler output is a large JCL stream divided into a number of JOBS,\nusually six of them.  This output, which has assembly, linkedit, copy,\nand other steps in it, is called the STAGE II DECK.  The STAGE II DECK\nhas the actual JCL which creates the executing operating system\nlibraries (called the \"TARGET LIBRARIES\") from the building blocks in\nthe distribution libraries.  In essence, the STAGE II DECK BUILDS THE\nBUILDING FROM THE BRICKS.  This is the gist of the SYSGEN process.\nMost of its smarts come from IBM, which coded the SYSGEN macros to\ncorrectly build the TARGET OPERATING SYSTEM.\n\n       The logical next question is:  What if a piece of the system\ndoesn't work?  How do you correctly replace that piece in the context\nof the whole system?  Do you have to do the entire SYSGEN all over\nagain?  The answer of course is NO, but the principle of what happens\nhere is of utmost importance to our topic.  THIS IS WHAT SMP AND ITS\nPREDECESSORS ARE ALL ABOUT.\n\n       Let us begin to answer the question of how to replace a bad\npiece of the system--a bad brick, so to speak.  Put a good brick into\nthe same place.  If the bad component is in source form, an update\nto the source and a reassembly and relinkedit must be done.  If the\ncomponent was distributed in object code form, the new object code\nmust be relinkedited to replace the old csect in the appropriate load\nmodule(s).  Again, how do we know the PATTERN where the new csect fits\ninto the system?  We know it from the SYSGEN STAGE II DECK.  That's how\nthat csect got there originally.  IBM fixes to the system, called \"PTFs\"\nor \"Program Temporary Fixes\" were originally applied to the system\nlibraries by pulling out the appropriate job steps from the SYSGEN\nSTAGE II deck and replacing the offending csects by IBM's replacements.\nA program called AMAPTFLE, which is probably not used today, was an aid\nin that process.  This historical anecdote, if you will, gives insight\ninto what SMP was designed to do automatically.\n\n       We have to answer one more question before we get into how SMP\noperates.  What if IBM changes the PATTERN of how it is putting the\nsystem together.  Suppose for example, that IBM breaks one module into\ntwo or three modules.  In that case, IBM will change the appropriate\nSYSGEN MACRO(S), and a new SYSGEN STAGE II DECK will have to be\nassembled.  The STAGE I DECK that was coded by the user does not have\nto be changed.  It must only be reassembled against the changed macros.\nThe part of the SYSGEN STAGE II that is affected by the module change\nwill have to be rerun.  The new TARGET LOAD MODULES to be executed\nwill then be linkedited correctly according to the new pattern\ndesigned by IBM.\n\n       Now we are in a position to start talking about what SMP does.\nSMP automatically accomplishes the processes we just talked about,\nwith the exception of assembling the STAGE II SYSGEN DECK.  Once the\nSTAGE II DECK is created and fed into SMP (through a process known\nas \"JCLIN\"), SMP \"knows the pattern\" of how the TARGET SYSTEM is put\ntogether, and it can apply system changes in an automated and audited\nway.\n\n       I must emphasize from the start that SMP is designed primarily\nfor APPLYING FIXES TO AN ALREADY CREATED SYSTEM.  Its accommodation to\ncreating a completely new system is just that--a necessary\naccommodation, but once the structure of a new system is fed into SMP,\nusing the SMP process called \"JCLIN\" of the SYSGEN STAGE II DECK,\nfixes can be applied to that new system speedily and efficiently.\n\n       There is one more fact of great value here.  IBM made an\nimportant decision once SMP (which is an efficient way of applying\nsystem fixes) was invented and debugged.  It was no longer necessary\nfor them to REPLACE ENTIRE RELEASES OF MVS, and require a NEW SYSGEN\neach time.  With SMP comfortably in place, many extensive system\nrevisions could be accomplished as A SUM OF INDIVIDUAL MODULE\nREPLACEMENTS, or PTFs.  The application of a large number of PTFs thus\nELIMINATED THE FREQUENT DISTRIBUTION OF NEW MVS RELEASES.  Therefore\nthe PRESENCE OF SMP CHANGED MVS MAINTENANCE from NEW RELEASE orientation\nto INCREMENTAL PTF organization.  This means, in other words, a change\nin emphasis from RUNNING ENTIRE SYSGENS to the SUCCESSIVE APPLICATION\nOF PTF FIXES TO THE SYSTEM.\n\n       Now, onward and upward to the mechanics of SMP, both in handling\nfixes, and in handling a major system change.\n\n       The single basic unit of work in SMP is called a \"SYSMOD\", or\n\"system modification\".  There are four kinds of SYSMODs:  these are\n\"FUNCTION\" sysmods, \"PTFS\", \"APARS\", and \"USERMODS\".  Every SYSMOD\nhas a seven-character ID, which must begin with an alphabetic character.\n\n       A FUNCTION SYSMOD basically represents A SEPARATE PRODUCT.  One\npiece of MVS, such as \"data management\", may be composed of a number of\nseparate FUNCTIONs, each of which owns a distinct \"piece of the piece\".\nThe currently consolidated data management package of MVS/370, known as\nDFP, consists of three FUNCTIONs.  DFP replaces a conglomeration of\nover thirty separate FUNCTIONS which covered the data-management area\nbefore.  The seven-character SYSMOD ID of a FUNCTION has a special\nname.  It is called an \"FMID\", or \"Function Modification IDentifier\".\nEVERY SYSMOD OF ANY TYPE MUST BE OWNED BY AN FMID.  In other words,\nevery SYSMOD must belong to a product (a FUNCTION) which OWNS it.\nEvery piece or ELEMENT of the system MUST ALSO BE OWNED by a unique\nFMID.\n\n       A FUNCTION SYSMOD can belong to another FUNCTION or FMID, or\nit may be a PRIMARY FUNCTION.  A PRIMARY FUNCTION SYSMOD is the only\nSYSMOD that is not owned by another FMID, since it is, by definition,\nthe base level of a program product.\n\n       A real illustration of this is the control program of MVS/370.\nThe BASE FUNCTION of MVS/370 has the FMID of EBB1102.  EBB1102 is the\noriginal MVS release 3.8, and it does not belong to any other product.\nMVS SP 1.3.0 is a rewriting of many (but not all) of the modules of\nMVS 3.8.  MVS SP 1.3.0 has its own FMID of JBB1326, which BELONGS TO\nTHE FMID EBB1102.  The modules that were rewritten BELONG to FMID\nJBB1326.  Now MVS SP 1.3.3 is in turn a partial rewriting of MVS SP\n1.3.0.  Therefore, the FMID of MVS SP 1.3.3, which is JBB1329, BELONGS\nto the FMID JBB1326, which in turn belongs to EBB1102, the base MVS\nrelease.  The MVS SP 1.3.3 revised modules belong to FMID JBB1329.\nFinally, the current MVS/370 release, MVS SP 1.3.5, is a rewriting of\nsome of the modules of MVS SP 1.3.3.  Therefore all of its rewritten\npieces belong to its FMID of JBB1356.  JBB1356 itself belongs to\nJBB1329, which in turn belongs to JBB1326, whose primary FMID is\nEBB1102.  Please notice that EBB1102 was never superseded by the\nhigher levels of MVS/370.  This illustrates the product relationship\nof FMID numbers, when whole sections of a base product have been\nrevised by IBM.\n\n       On the other hand, separate non-overlapping products will have\nseparate, completely unrelated FMIDS.  The important fact is that\nevery SYSMOD that is not a FUNCTION SYSMOD, and many FUNCTION SYSMODS\nthemselves, MUST BE OWNED BY AN FMID.  No SYSMOD or system objects\n(called \"ELEMENTS\" in general) can belong to more than one FMID.  All\nELEMENTS (macros, load module csects, etc.) must belong to one and\nonly one FMID.\n\n       We are now at the point where we want to know several things.\nFirst, what does an SMP environment consist of?  Second, how do SYSMODS\nget onto an SMP-controlled system.  Third, how do the ELEMENTS, the\nPIECES OF THE SYSTEM, relate to the SYSMODS.  Fourth, how does all\nthis SMP stuff fit in with what we already know about the SYSGEN\nprocess, and how does SMP build an actual working operating system?\n\n       Answering these four questions constitutes the goal of this\narticle.  With an understanding of the answers, any person can easily\nnegotiate IBM's SMP literature and thereby gain real competence in\nSMP use.  (BOB, PLEASE PUT EMPHASIS ON THIS PARAGRAPH - - -.)\n\n       Let us discuss the SMP environment.  Roughly, the concept of\nan SMP environment breaks down to two things:  first, a set of\nLIBRARIES controlled by SMP, and second, special SMP CONTROL DATASETS\nwhich keep accounting of all the system changes that occurred.  A\nsequential SMP LOG records and time-stamps all significant actions\nwhich are occurring during SMP processing.\n\n       The set of libraries controlled by SMP is broken down into\ntwo types of libraries.  There are TARGET LIBRARIES, which contain\ncopies of actual working system code.  And there are DISTRIBUTION\nLIBRARIES, which have the pieces from which the system is built.  The\nconcept of DISTRIBUTION LIBRARIES and TARGET (or \"SYSTEM\") LIBRARIES\ncorresponds exactly to what we discussed before, concerning the SYSGEN\nprocess.  In fact, there is no difference.  We have seen that with the\nSYSGEN process, the DISTRIBUTION libraries are SUPPLIED INITIALLY by\nIBM and the TARGET libraries are CREATED FROM THE DISTRIBUTION\nLIBRARIES using the STAGE II SYSGEN DECK.  With SMP however, (once an\ninitial operating system has been created) the TARGET LIBRARIES are\nsupplied first, using material sent by IBM in the form of SYSMODS.\nThese are plugged into the actual working operating system libraries\nby SMP.  Then they are tested, and if the changes are good, they can\nthen be put into the DISTRIBUTION LIBRARIES PERMANENTLY.  Thus, the\nusual SMP flow is from IBM-supplied SYSMODS, to TARGET LIBRARIES, and\nthen to DISTRIBUTION LIBRARIES.  This is the opposite of the flow of\nchanges during the SYSGEN PROCESS.\n\n       Our discussion of control datasets must be based on the three\nPROCESSES OF SMP FLOW.  These are called \"RECEIVE\", \"APPLY\", and\n\"ACCEPT\".  RECEIVE, APPLY, and ACCEPT are the SMP-language equivalent\nof:  taking a new SYSMOD into the SMP environment, putting its pieces\ninto the TARGET libraries into the proper places, and finally, storing\nits pieces in the DISTRIBUTION libraries for archival and possible\nlater use.  Again, the flow is:  IBM-supplied SYSMODS, to TARGET\nlibraries, to DISTRIBUTION libraries.\n\n       How do the RECEIVE, APPLY, and ACCEPT processes work?  We shall\ndiscuss them briefly in order.  Please bear in mind that our aim is to\nsimplify the discussion and keep it conceptual.  Once the concepts are\nunderstood, and the vocabulary words associated with them are learned,\nthen the IBM literature will become quite readable.\n\n       RECEIVE basically involves STORING A NEW SYSMOD and recording\nsome vital statitstics about it, so that it is pre-digested a bit by\nSMP.  The text of the entire SYSMOD is stored in a partitioned dataset\ncalled the \"PTS\" or \"PTF Temporary Store Data Set\".  In the older\nversion of SMP, SMP4, the control information taken during the RECEIVE\nprocess is stored in the PTS also.  However, in the new SMP/E, all\ncontrol information is stored in VSAM files known as \"ZONES\".  The\nVSAM file which stores the control information from the RECEIVE process\nis known as the \"GLOBAL ZONE\".  The text of the SYSMOD thus goes to\nthe PTS as before, but the control information is stored in the\nGLOBAL ZONE.\n\n       There are certain SYSMODS which are RECEIVED a bit\ndifferently.  These are SYSMODS which have what are known in SMP\nlanguage as \"RELFILES\".  The word RELFILE roughly translates to\n\"IEBCOPY\".  If a modification has large numbers of linkedited\ncsects, macros, ISPF panels, or other ELEMENTS, which are suitable for\ndirect IEBCOPY into TARGET LIBRARIES, then those ELEMENTs included in\nthe SYSMOD which have SIMILAR RECORD FORMAT AND RECORD LENGTH can be\nloaded into a single pds.  This pds is unloaded onto the SYSMOD\ndistribution tape using IEBCOPY, and its file sequence order on the\ntape is very important.  If the Sysmod Specification File on the\ntape (known as the \"SMPMCS\") calls for THREE RELFILES for instance,\nthen the next three files on the tape, hopefully IEBCOPY unloaded,\nare known as RELFILE(1), RELFILE(2), and RELFILE(3) respectively.\n\n       The RECEIVE process on a SYSMOD with RELFILES is then the\nfollowing:  The SMPMCS, which contains the SMP control statements of\nthe SYSMOD, is read from the tape.  The number of RELFILES (3 in our\nexample) is determined from the \"RELFILES (3)\" keyword in the SMPMCS.\nThe three files on the tape which follow the SMPMCS file are then\nunloaded to a disk pack (determined by the \"SMPTLIB\" DD statement in\nthe SMP job) and given special names, which SMP will understand during\nlater APPLY and ACCEPT processing of the SYSMOD.  These names are of\nthe format:  PREFIX.sysmodid.Fn, where n is 1, for the first relfile,\n2 for the second, and so forth.  The prefix is set in the global zone\nfor SMP/E (or in the PTS system entry in SMP4) and is not changed\nduring the entire process.  Therefore, when a SYSMOD with RELFILES is\nRECEIVED, the relfile libraries are loaded from tape to disk.  The\nelements they contain are thus readied, so that the APPLY and ACCEPT\nprocesses to follow can selectively copy them to where they will be\nneeded.  Meanwhile, the SMPMCS is itself copied to the PTS, and its\ncontrol information is dealt with as we discussed before.\n\n       With SMP/E there is a bit more to the RECEIVE process.  Besides\nthe RECEIVE of SYSMODS, one must also RECEIVE SYSMOD ERROR INFORMATION.\nThis is known as \"HOLDDATA\".  HOLDDATA consists of a list of \"++HOLD\"\nand \"++RELEASE\" control statements in sequential order.  Each such\nstatement points to a PTF or an APAR SYSMOD.  The purpose of the ++HOLD\nstatement is to prevent SMP/E from APPLYing a PTF that is in error,\nknown as a \"PE PTF\".  A ++RELEASE statement that is RECEIVED AFTER a\n++HOLD statement against the same SYSMOD will UNDO THE EFFECT of the\n++HOLD statement.  The ORDER in which the statements are RECEIVED is\nof paramount importance.  SMP/E will honor the ++RELEASE only if it\noccurs AFTER ALL ++HOLD statements for that particular SYSMOD.  The\nHOLDDATA is kept in the SMP/E GLOBAL ZONE.\n\n       A quick word about UN-doing the RECEIVE of a SYSMOD.  A RECEIVE\ncan be undone by an SMP process called \"REJECT\".  To REJECT a SYSMOD\nthat has been RECEIVEd causes the SYSMOD to be erased from the PTS and\nits control information associated with the RECEIVE process to be\nwiped out.  If the SYSMOD has RELFILES, the disk-loaded copies are\ndeleted.  The SYSMOD cannot then be RE-APPLIED or RE-ACCEPTED unless\nit is RE-RECEIVED.  REJECTing a SYSMOD WILL NOT AFFECT THE STATUS of a\nSYSMOD that has ALREADY BEEN APPLIED OR ACCEPTED.  It stays in the\nTARGET libraries and in the DLIBs.\n\n       OK, we've talked about getting the SYSMOD into SMP.  Now is a\ngood time to mention the syntax of SMP MODIFICATION CONTROL STATMENTS,\nbefore going to the details of APPLY and ACCEPT processing.\n\n       Rule number one is that all SYSMOD control statements (known\nin IBMese as MCS or \"Modification Control Statements\") must begin\nwith the characters \"++\" in columns 1 and 2 of the SYSMOD's card-image\nrecords.  The other keywords and parameters in SYSMOD syntax are\nfree-flowing.  Extra blanks don't count.  Columns 73 to 80 are\nnot used in the SYSMOD statements themselves, but they are required\nfor IEBUPDTE source and macro update cards, so you have to be careful\nand one can't renumber a SYSMOD.  Comments are as in the PL/I language.\nThey begin with the characters \"/*\" and end with the characters \"*/\".\nEverything in between these specific strings, even on many successive\nlines, is treated by SMP as a comment.  All SMP statements must end in\na period, \".\".  The period is the delimiter for statements in SMP\nsyntax, and one must be EXCEEDINGLY careful with them.\n\n       Every SYSMOD must begin with the statements:  \"++ FUNCTION\",\n\"++ PTF\", \"++ APAR\", or \"++ USERMOD\", followed by the seven character\nSYSMOD ID enclosed in parentheses, and delimited by a period.  We've\nalready discussed FUNCTION sysmods.  PTF sysmods or \"PTFs\" are (after\nthe invention of SMP and the change in IBM's maintenance philosophy)\nreally PERMANENT SYSTEM FIXES, although their name stands for \"Program\nTemporary Fix\".  The TEMPORARY fixes are called \"APARs\", which is\nreally a short term for \"APAR FIX\".  APAR stands for \"Authorized\nProgram Analysis Report\", and it really refers to a problem that was\nreported to IBM.  IBM assigns a number to each problem, and when the\nproblem is fixed, the temporary fix itself is assigned the same\nnumber.  This number (or something very close to it) is what SMP uses\nfor the APAR SYSMOD ID.  APAR SYSMODS are intended to be replaced, or\n\"SUPERSEDED\" by permanent fixes, or PTFs.  They are therefore not\nusually \"ACCEPTED\" into the distribution libraries.  More about this\nlater.\n\n       USERMODs are packaged SMP SYSMODS written by the individual\ninstallation for its own needs, usually to modify some IBM code.  They\nlook like PTFs or APARs, but SMP puts them in a special category so\nthat they stay a bit distant from the real IBM maintenance.  The user\nhas flexibility to assign almost any seven character SYSMOD ID to his\nUSERMOD, but each different SYSMOD must have a unique ID, and it is\nwise to steer clear of IBM-type names.  USERMODs are also usually\nnot ACCEPTed into IBM distribution libraries (also known as \"DLIBS\")\nbecause they are likely to overlay IBM code there.  USERMODs should\nonly be ACCEPTed if you really know what you are doing.\n\n       We'll quickly explain the concepts of the other strange keywords\nyou're likely to find at the top of SMP SYSMODS.  I don't intend to\nbe exhaustive.  The idea is to cut through the ice and give you some\nidea of what is happening.\n\n       \"++ VER\" means \"version of the operating system\", or perhaps\n\"domain of SMP activity\" would also be an appropriate explanation.\nThe values for this parameter have 4 characters, and there aren't too\nmany valid choices.  \"Z038\" means MVS 3.8 and upwards thru XA.  (\"Z037\"\nor MVS 3.7 probably isn't used anymore.)  \"C150\" means CICS 1.5 and\nupwards.  There are a few more of them.  These values almost never\nchange, and within the same domain of activity, you always find the\nsame value.  The ++VER values were originally intended to differentiate\nbetween similar maintenance on different MVS releases, but because of\nthe evolution of the SMP product since those \"old\" days, it doesn't\nhave that importance any more.  The purpose of the ++VER statement has\nbeen largely taken over by the FMID.  It is necessary and required,\nhowever; it must be included in all SYSMODs.\n\n       Inside of the ++VER sentence (and before the period) you'll\nmost likely see the FMID, PRE, REQ, and SUP keywords.  FMID has been\ndiscussed.  Every SYSMOD must belong to a unique FMID.  In the\nparentheses following the FMID keyword, the FMID which will own the\nSYSMOD must be specified.  PRE and SUP are quite simple.  In the\nparentheses following the PRE keyword, and separated by spaces or\ncommas, is a list of SYSMOD IDs which have to be present before OUR\nSYSMOD can be put onto the system, or \"APPLIED\".  The \"prerequisite\nSYSMODs\" must have been already APPLIED themselves, or else they have\nto be APPLIED together with this new SYSMOD.  Otherwise if all the\nPREs or prerequisites are not present, the new SYSMOD will not go on.\n\n       REQ is like PRE, but the SYSMODs that are REQuired for the\nnew SYSMOD, must BE APPLIED IN THE SAME RUN as the new SYSMOD.  It\nis seldom necessary to use the \"REQ\" keyword.  Ususally \"PRE\" will\nsuffice.\n\n       Following the SUP keyword is a list of SYSMODS that are\neffectively replaced, or \"SUPERSEDED\" by the new SYSMOD.  This keyword\nis used when the intent is that the new material to be added to the\nsystem COMPLETELY OBSOLETES all the material from all of the SYSMODs\nin the SUP list.  If only SOME of the material in a previous SYSMOD\nor PTF will be replaced, that SYSMOD should be placed in the PRE list\nor \"prerequisite list\".  For a SYSMOD to be superseded or \"SUPed\"\n(to use the common parlance) its purpose in the operating system\nshould be COMPLETELY REPLACED by the later SYSMOD.\n\n       Our new SYSMOD may have a sequence of \"++IF FMID(fmidnam) THEN\nREQ(sysmdid).\" statements.  This will happen if we have different\nlevels of the same product, as we mentioned earlier regarding the\nvarious MVS/370 product levels.  If our SYSMOD is for a lower level of\nthe product, and the installation has both that level and a higher\nlevel, it may be necessary to apply another fix to satisfy the\nrequirements of the higher level.  SMP is informed of this by means of\na coded ++IF statement in the lower level SYSMOD.  If the higher level\nreferred to (in the ++IF statement) is not present on our system, then\nour fix suffices for us, and it will go on to our system normally.  If\nour installation has the higher level of the product also, the lower\nlevel SYSMOD will not go on without the sysmod id in the REQ keyword\nof the ++IF statement also being present.  The FMID name within the\n++IF statement is usually for a higher level of the product than the\ncurrent SYSMOD is for.\n\n       Below all this \"version\", PRE, SUP and IF stuff is the actual\nfix.  A \"++MOD\" statement followed by object code signifies an object\nmodule replacement of a CSECT.  A \"++SRC\" statement followed by source\ncode is a complete source code replacement.  A \"++SRCUPD\" statement or\n\"++ MACUPD\" statement followed by IEBUPDTE control cards signifies\nupdates to an existing source module or macro.  A \"++MAC\" statement\nis followed by the complete replacement for the macro.  Keywords in\nthese statements supply necessary additional instructions so that the\nchange is done according to the author's or IBM's specifications and\nrequirements.  Specification of the destination libraries for the\nELEMENT to be changed is also accomplished by these keywords.\n\n       A single SYSMOD can contain fixes for many system ELEMENTS.\nEach element to be changed must have its own ++SRC, ++MOD, +SRCUPD,\n++MAC or ++MACUPD control card, followed by the new replacement or\nadditional material for that element.  An approximate limit to the\nnumber of element fixes in one SYSMOD is set by a global SMP parameter\ncalled \"PEMAX\".  It is advisable to set PEMAX to a high number, usually\nto 9999.\n\n       One more important note.  Libraries in SMP control statements\nare referred to by their DDNAMES ONLY.  These must be one to eight\ncharacters long.  It is safe and wise practice in SMP work to ALWAYS\nMAKE THE DDNAME OF THE LIBRARY CORRESPOND TO THE LOWEST-LEVEL\nQUALIFIER OF ITS DATASET NAME.  DATASET NAME PREFIXES DON'T COUNT TO\nTHE SMP PROGRAM.  It is therefore advisable to use the SAME SMP JCL\nPROCEDURE when doing system modifications to one system.  The JCL of\nthat PROC will uniquely and unchangeably determine the destination\nlibraries of the SMP action.  Thus, the SMP control information and\nthe actual contents of the affected libraries will always be kept in\nsynchronization.  (SMP/E has a facility for determining dataset names\nby dynamic allocation.  These dynamically determined library names are\ncalled \"DDDEFs\".  I want to keep the discussion here simple, and I\nwill not dwell on DDDEFS, except to say that they DYNAMICALLY\naccomplish what DD cards do in a JCL procedure.)\n\n       This will take some of the mystery away from what a SYSMOD\nlooks like.  Now once it is RECEIVEd, how do we APPLY it to the\nTARGET LIBRARIES?\n\n       When thinking about APPLYing SYSMODS to our system, we must\nnever forget that the PURPOSE OF A SYSMOD IS TO SUPPLY NEW COMPONENTS\nfor our operating system or our product.  THE APPLY PROCESS PUTS THE\nNEW PIECES OR ELEMENTS INTO THEIR PROPER PLACES IN THE EXECUTING\nLIBRARIES OF THE SYSTEM, the TARGET LIBRARIES.  IT ALSO KEEPS DETAILED\nTRACK OF WHAT IT HAS DONE.\n\n       APPLY can ONLY be done to a SYSMOD that has been RECEIVED.  The\nRECEIVE process has put the SYSMOD into the SMP staging areas, the PTS\nand possibly the UNLOADED RELFILES, and has done some preliminary\naccounting in the SMP/E GLOBAL ZONE or the SMP4 PTS.  The APPLY\nprocess will pick the SYSMOD up from there.  Accounting for the APPLY\nprocess is done in SMP/E using a VSAM cluster called the TARGET ZONE,\nand in SMP4 using several partitioned datasets, the most important of\nwhich is called the \"CDS\" or \"Control Data Set\".\n\n       A word about ELEMENT ACCOUNTING.  If a SYSMOD will replace an\nELEMENT (a macro or a module or source code - a MAC, a MOD, or SRC),\nthat ELEMENT acquires an \"RMID\" (or \"Replacement Module ID\") equal to\nthe SYSMOD ID of the SYSMOD which replaced it.  Since the piece\nwas completely replaced, each MAC, MOD, or SRC ELEMENT can have ONLY\nONE RMID.  If on the other hand, the SYSMOD will UPDATE A MACRO,\nUPDATE SOURCE, or ZAP A LOAD MODULE, then that ELEMENT acquires a\n\"UMID\" (\"Update Module ID\") equal to the SYSMOD ID that updated it.\nOne macro or module can have MANY UMIDS, because it is possible to\nupdate a single ELEMENT many times, and in many ways.\n\n       Now back to APPLY processing.  Many SYSMODS can be APPLIED\ntogether in one run.  This is one of the great conveniences of the SMP\nproduct.  When APPLYing more than one SYSMOD, the programmer can\nSELECT a list of individual SYSMODS by their seven-character SYSMOD\nIDs.  This is done in the SMPCNTL DD statement, where one enters the\n\"APPLY\" parameter into the SMP job.  One simply states \"APPLY SELECT\n(sysmdid,sysmdid, ...).\".  We can also select just one SYSMOD to\nAPPLY, if that is what we want.\n\n       Before we get too far, I must mention \"APPLY CHECK\", which is\na dry run of the APPLY process.  By inclusion of the word \"CHECK\"\nin an APPLY request, SMP will do a dry run.  All SMP control\ninformation will be verified, just as if the real APPLY was being\ndone.  With APPLY CHECK however, no real library updates are done, and\nthe SYSMODS will not really be APPLIED to the system.  A report will\nbe generated that tells us what WOULD be done.  \"ACCEPT\" and \"RESTORE\"\nprocessing, to be mentioned later, also have the \"CHECK\" facility.  IT\nIS ALMOST ALWAYS ADVISABLE TO DO APPLY CHECK BEFORE DOING THE REAL\nAPPLY.\n\n       We continue.  It is also possible to do what is called a MASS\nAPPLY.  MASS APPLY works as follows.  By simply stating the word APPLY\nin the SMPCNTL DD statement of an SMP job, SMP will ATTEMPT TO APPLY\nALL RECEIVED SYSMODS THAT ARE ELIGIBLE FOR THE SYSTEM but have not\nbeen APPLIED yet.  SMP will look at ALL THE UNAPPLIED RECEIVED SYSMODS\nand will BUILD A SYSMOD SELECT LIST.  It will then proceed to APPLY\nALL THE SELECTED SYSMODS to your system.  It is possible to EXCLUDE a\nlist of SYSMODS specifically from a MASS APPLY, by using the EXCLUDE\nor \"E\" parameter in the APPLY control statement.  In SMP/E (but not in\nSMP4) there is an additional way to exclude a SYSMOD from an APPLY.\nThis is through the use of a \"++HOLD\" modification control statement\nwhich has been RECEIVED previous to this APPLY request.  MASS APPLY\nis the normal means of APPLYing IBM's periodic system maintenance\nknown as \"PUTs\" (Program Update Tapes) to the system, because this\nmaintenance consists of large numbers of PTFs, perhaps several hundred\nof them, and it is inconvenient to SELECT them individually.\n\n       There is another APPLY option called APPLY with the GROUP\nparameter.  \"APPLY GROUP\" works very much like \"APPLY SELECT\" for\nAPPLYing a list of SYSMODS.  The difference concerns missing\nprerequisites.  If \"APPLY GROUP(sysmdid,...)\" is coded instead of\n\"APPLY SELECT\", and if a necessary prerequisite SYSMOD has not been\nincluded in the explicit SELECT list, SMP will go to the trouble of\nadding all such necessary prerequisites to the SELECT list before\ndoing the APPLY.  It is only necessary that the added SYSMODS have\nbeen previously RECEIVED.  \"APPLY GROUP\" is good if you are not sure\nwhat other PTFs are necessary to include, when you are APPLYing new\nPTFs that you really want.  It does use extra overhead, but it should\nbe used for avoiding multiple SMP runs when some prerequisites may be\nmissing.\n\n       BYPASS.  This is a useful facility of SMP APPLY processing,\nespecially during APPLY CHECK, when you're determining if the APPLY\nshould work.  The BYPASS parameter of APPLY (and ACCEPT) allows SYSMODS\nto be APPLIED to the system, even though they are missing prerequisites\nor other requirements.  During a real APPLY situation, the BYPASS\nparameter will allow the putting on of a SYSMOD in an exceptional\ncircumstance, when there is no other way of getting it on.  During\na CHECK situation however, it is advisable to BYPASS ALL OR MOST ERROR\nCONDITIONS on the first try.  This is because SMP WILL OFTEN STOP\nFURTHER ACTION when it encounters the FIRST ERROR.\n\n       For instance (to use an SMP/E example), suppose SYSMODS B and C\nboth require SYSMOD A, and SYSMOD A has a ++HOLD against it.  When we\ntry to APPLY CHECK SELECT SYSMODS A, B, and C together, and we don't\nhave a BYPASS (HOLDERROR) coded, SMP will not tell us how the three\nSYSMODS will APPLY, and what ELEMENTS they will affect.  It will\nsimply say that it cannot APPLY SYSMODS B and C because it could not\nAPPLY SYSMOD A.  On our next try, if we did code BYPASS (HOLDERROR) in\nthe APPLY CHECK, SMP/E would give us a complete report of the ELEMENTs\naffected by all three SYSMODS, because the BYPASS allowed the\nsimulation of a completed APPLY, and all the consequences of the APPLY\nwill show in the report.\n\n       As a matter of procedure, most people BYPASS every error\ncondition during APPLY CHECK, but some try not to use BYPASS on the\nreal APPLY.  They exert much effort to completely clean up the APPLY\nCHECK so that they can avoid coding a BYPASS for the real APPLY run.\nI personally leave the BYPASS in during the REAL APPLY runs too.  I\njust make sure that the APPLY CHECK will show the exact result that\nI want to achieve.  My approach avoids an excessive number of APPLY\nCHECK runs, which can take a long time.  This is a matter of personal\npreference.  The important thing is that THE REAL APPLY SHOULD ALWAYS\nBE DONE WITH THE SAME PARAMETERS AS THE LAST SATISFACTORY APPLY CHECK\nRUN.\n\n       Our final word on APPLY processing will be to show how the\nPATTERN OF THE SYSTEM is determined or changed during APPLY.  SYSTEM\nPATTERNS are communicated to SMP by means of the \"JCLIN\" facility.\nJCLIN consists of MODEL JCL statements for ASSEMBLY, LINKEDIT or COPY\nsteps.  SMP reads these statements, and uses them to determine how\nsource can be reassembled after a MACRO change, or how load modules\nof one or many csects (called LMODs by SMP) are linkedited from\ncomponent parts, including all linkedit control statements and\nattributes.  JCLIN is only associated with TARGET LIBRARIES and the\nTARGET ZONE, not with DISTRIBUTION LIBRARIES, which have only separate\npieces of the system.  JCLIN tells SMP how to construct the working\nprograms of the system from their component pieces.\n\n       This is reminiscent of our discussion of the SYSGEN process.\nIn fact, JCLIN is the means of communicating the contents of the\nSYSGEN STAGE II DECK to SMP.  A JCLIN stream can be put into SMP in\ntwo ways.  The first way is by means of a dataset of JCL, which is\nreferred to the SMP job by the SMPJCLIN DD statement.  The second\nmeans is from within a SYSMOD itself.  This second way is called\n\"INLINE JCLIN\".  The JCL stream is included in the text of the SYSMOD\nand preceded with a \"++ JCLIN.\" statement.  This will cause the JCL\npattern to be read into the TARGET ZONE or CDS when the SYSMOD is\nAPPLIED.\n\n       The APPLY process is reversed with the RESTORE process.  RESTORE\ntakes off SYSMODS that have already been APPLIED but NOT ACCEPTED.\nSMP provides a RESTORE CHECK facility so the user can determine in\nadvance if the RESTORE will work.  RESTORE allows you to back off bad\nSYSMODS if they are causing trouble during your system tests, after\nAPPLYs have been done.\n\n       We shall talk about ACCEPTing the APPLIED SYSMODS into the DLIBS.\nThe ACCEPT process of SMP takes the ELEMENT REPLACEMENTS which have\nalready been APPLYed to the system (and presumably tested), and puts\nthem into the DISTRIBUTION LIBRARIES to archive them. This also allows\nthem to be used in a subsequent SYSGEN or IOGEN (a partial SYSGEN to\nrearrange IO-configuration related ELEMENTS).  ACCEPT is thus a very\nimportant process.\n\n       Control information for the ACCEPT processing is kept, for SMP/E,\nin a VSAM cluster known as a DLIB ZONE.  Each DLIB ZONE must be paired\nwith a corresponding TARGET ZONE.  This is because SMP will normally\nACCEPT only SYSMODS that have already been APPLIED, and the TARGET\nZONE has the control information for the APPLIED SYSMODS.  It is\npossible for ONE GLOBAL ZONE to control SEVERAL PAIRS OF TARGET AND\nDLIB ZONES, so that several sets of system libraries can be maintained\nout of one SMP/E configuration.\n\n       For SMP4, control information for ACCEPT is kept in two\npartitioned data sets, the \"ACDS\" or \"Alternate Control Data Set\"\nand the \"ACRQ\" or \"Alternate Conditional Requisite Queue Data Set\".\n(There is also a \"CRQ\" dataset for APPLY information.)  These datasets\ncorrespond to the information that is kept in the DLIB ZONE for SMP/E.\n\n       ACCEPT control parameters are similar to those for APPLY,\nas we discussed above.  It is always advisable to do ACCEPT CHECK\nruns before doing a real ACCEPT run, just to make sure the job will\nachieve the desired result.  Doing ACCEPT CHECK runs will make it\npossible to fix errors before the ACCEPT run.  Once a SYSMOD has been\nACCEPTed on the SYSTEM, it cannot be removed, except by another SYSMOD\nthat will SUPERSEDE it and replace all its ELEMENTS.\n\n       In order for an ELEMENT to be used in a subsequent SYSGEN or\nIOGEN, its SYSMOD must first be ACCEPTED.  This loads the ELEMENT into\nits proper DISTRIBUTION LIBRARY.  As we stated before, the SYSGEN\nPROCESS uses the material in the DLIBS to build the system, and one\ndoesn't want back-level code to creep into his system after an IOGEN\nhas been done.  It is therefore mandatory to do a MASS ACCEPT before\na SYSGEN or IOGEN is done.\n\n       There is a special case of ACCEPT processing which allows SMP\nto simulate the SYSGEN process.  This type of ACCEPT processing is\ncalled \"ACCEPT NOAPPLY\", and its purpose is to replace SYSGEN MACROS\nand other pieces of the DISTRIBUTION LIBRARIES so a newly updated\nSYSGEN STAGE II DECK can be created.  This new STAGE II DECK will\nreflect the NEW PATTERN that IBM has planned for the new version of\nthe operating system.  ACCEPT NOAPPLY processing replenishes the\nDLIBS directly from RECEIVED SYSMODS, bypassing the TARGET LIBRARIES\nentirely.  After the ACCEPT NOAPPLY has been done, and the DLIBS\nreflect the state of the new system, a STAGE II SYSGEN DECK is assembled\nfrom the installation's STAGE I DECK, and the new STAGE II DECK\nis made known to SMP through the JCLIN process.  When a subsequent\nAPPLY of the same SYSMODS is done, all their ELEMENTS will fit into\nthe system according to their proper new pattern.\n\n       We shall finish our discussion with the topics of \"UCLIN\" and\n\"LIST\".  Then I'll let you try your hand at the SMP books.  You'll\nprobably find them clear and well-written now, because you're past the\n\"vocabulary barrier\".  Any words I haven't defined here can probably\nbe found in the glossaries of the SMP publications, and you can be on\nyour way.\n\n       UCLIN for SMP CONTROL DATASETS roughly corresponds to ZAP for\ndata.  UCLIN provides the facility for ARBITRARILY CHANGING SMP\nCONTROL INFORMATION.  Sometimes SMP control entries must be adjusted\nto allow a PTF to be APPLIED or ACCEPTED properly.  For example,\nsuppose PTF B is intended to replace ELEMENT A, but our installation\nhas modified ELEMENT A with a USERMOD.  Our intention is to replace\nELEMENT A with IBM's new version of it, supplied by PTF B.  After the\nelement is replaced, we will refit our USERMOD to the new version.\nThis is what we want, but SMP will not let us do it.  That is because\nPTF B doesn't \"know\", in its \"PRE\" and \"SUP\" keywords about our\nUSERMOD, which tagged ELEMENT A with a UMID equal to the USERMOD's\nSYSMOD ID.  The APPLY CHECK run to APPLY PTF B will report an ID\nCHECK, stopping PTF B from going on.\n\n       One way to get around this situation is to use UCLIN processing\nto remove the strange UMID from ELEMENT A before doing the APPLY for\nPTF B.  Then PTF B can be APPLIED without any trouble, and it will\nreplace ELEMENT A on the system, achieving the result that we want.\n(Another approach is to BYPASS ID CHECKS and force PTF B on.  The\nUCLIN approach seems cleaner to me.)\n\n       UCLIN can also be used to replace large pieces of SMP control\ndata.  SMP has a facility called UNLOAD, that converts entire SMP\nentries, or even an entire ZONE into UCLIN control statements.  This\nmay prove useful to some users.  The point is that the UCLIN facility\ngives us fine control on the SMP entries, outside of the RECEIVE,\nAPPLY, ACCEPT milieu.  We must obviously be very careful with UCLIN,\nand we should only use it when we know exactly what we are doing.\nSometimes an IBM-supplied PTF will recommend the application of UCLIN.\nThis should also be done with care, because a previous SYSMOD may\nhave done the proper adjustment already.\n\n       \"LIST\" allows the SMP user to DISPLAY ALL SMP CONTROL\nINFORMATION, and it is obviously the tool to use when determining if\nUCLIN is necessary, and if your UCLIN worked properly.  LIST has much\nmore general-purpose use in SMP.  It is THE WAY TO DO SMP INQUIRY.\nWith SMP4, it is practically the only way find out SMP control\ninformation.  (There are a few other tools around, including a\n\"LISTCDS\" TSO command on file 300 of the CBT tape.)  With SMP/E, there\nis an extensive ISPF INQUIRY SYSTEM that takes the place of the LIST\nfunction for most routine lookups.  LIST can still be used for big\ninquiries in batch.  The SMP books have much information on the use\nof the LIST command.\n\n       That's all for now, but I hope it's enough to achieve our\npurpose.  Now you can hit the books, and use SMP carefully, but with\nconfidence.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT014/FILE014.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT014", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}