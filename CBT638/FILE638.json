{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012516000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE638.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE638.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x08\\x03'", "DS1TRBAL": "b'\\xb7\\xd0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x92\\x00\\x08\\x04\\x93\\x00\\x01\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04H\\x00\\x00\\x01\\x06\\x11_\\x01\\x06\\x11_\\x10\\x02\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf2@@@'", "ispf": {"version": "04.72", "flags": 0, "createdate": "2006-04-25T00:00:00", "modifydate": "2006-04-25T10:02:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-472"}, "text": "REGULAR CBT TAPE - VERSION 472    FILE:  638\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT472.FILE638\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 9 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,706 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/25/06    10:02:24    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04(O\\x01\\x04(O\\x11\\x11\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-10-10T00:00:00", "modifydate": "2004-10-10T11:11:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SBGOLOB"}, "text": "Here I have updated the CBT #638 package with following enhancements:\n\n1. Add support Mail 'FROM:' statement in SYSIN DD.\n2. Get the system hostname and domain name automatically.\n3. Add web link for the attachment file in email body.\n4. Enhance the MIME support, including:\n    Encode the email body to avoid the possible '.' command.\n    Use single boundary\n    Automatic recognize application for MIME file types\n5. Enhancement for attachments:\n    Support DDNAME in Dataset Name field.\n6. Enhancement for encoding program:\n    Support different input and output DD name via EXEC PARM.\n7. Remove the record length restriction of SYSIN DD.\n\n        October 5, 2004\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE2": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x06\\x11_\\x01\\x06\\x11_\\t!\\x00\\x1a\\x00\\x14\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-04-25T00:00:00", "modifydate": "2006-04-25T09:21:31", "lines": 26, "newlines": 20, "modlines": 0, "user": "SBGOLOB"}, "text": "Note from Sam Golob:\n\n   I have made adjustments to the support information in\n   this file, according to the email address and (cell)\n   phone number for Hunter Zhou, which is listed here.\n\nSubject:     Good Luck!\nFrom:        \"Zhou, Hunter\" <hunter.zhou@sobeys.com>\nDate:        Fri, 21 Apr 2006 08:42:57 -0400\nTo:          <zhough2000@yahoo.com>\n\nDear All,\n\nAs you might already know, today is my last day in Sobeys.\n\nI wish you continue to success and enjoy everyday in Sobeys.\nPlease keep in touch, and I can be reached at my personal email\naddress zhough2000@yahoo.com.\n\nThanks again for everything.\n\nYours Sincerely,\n\nHunter Zhou\nEmail: zhough2000@yahoo.com\nCell: (416) 602-9567\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE638": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04H\\x00\\x00\\x01\\x06\\x11_\\x01\\x06\\x11_\\x10\\x02\\x005\\x005\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf2@@@'", "ispf": {"version": "04.72", "flags": 0, "createdate": "2006-04-25T00:00:00", "modifydate": "2006-04-25T10:02:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "CBT-472"}, "text": "//***FILE 638 is a package to Send Email With Attachments, from     *   FILE 638\n//*           Hunter Zhou.                                          *   FILE 638\n//*                                                                 *   FILE 638\n//*           Hunter Guanghui Zhou                                  *   FILE 638\n//*           Phone: 1-(416)-602-9567                               *   FILE 638\n//*           E-mail: zhough2000@yahoo.com                          *   FILE 638\n//*                                                                 *   FILE 638\n//*           The package SENDMAIL is from Hunter Zhou.             *   FILE 638\n//*           The package SENDMAIL can send emails with             *   FILE 638\n//*           attachments in Mainframe OS/390 and z/OS systems.     *   FILE 638\n//*                                                                 *   FILE 638\n//*       Program: SENDMAIL (REXX)                                  *   FILE 638\n//*       Purpose: Interpret the SYSIN DD and ATTACH DD and send    *   FILE 638\n//*                email messages for TCP/IP SMTP service with      *   FILE 638\n//*                following features:                              *   FILE 638\n//*           1. Support Email Header                               *   FILE 638\n//*              . The header supports To: Cc: Bcc: and Subject:    *   FILE 638\n//*              . Multiple email addresses are supported.          *   FILE 638\n//*              . Supprt comments                                  *   FILE 638\n//*           2. Support HTML tags                                  *   FILE 638\n//*              . Read SYSIN column 1-72.                          *   FILE 638\n//*              . Support HTML tags.                               *   FILE 638\n//*           3. Attachements support:                              *   FILE 638\n//*              . Text and Binary files                            *   FILE 638\n//*              . Multiple attachements                            *   FILE 638\n//*              . Descriptions for each attachements               *   FILE 638\n//*              . Better performance as calling EMAILENC program.  *   FILE 638\n//*                                                                 *   FILE 638\n//*       Calling JCL:                                              *   FILE 638\n//*           // job card here                                      *   FILE 638\n//*           //SENDMAIL EXEC PGM=IKJEFT01,PARM=SENDMAIL            *   FILE 638\n//*           //SYSEXEC  DD  DISP=SHR,DSN=SYS1.USER.REXXLIB         *   FILE 638\n//*           //SYSTSPRT DD  SYSOUT=*                               *   FILE 638\n//*           //SYSTSIN  DD  DUMMY                                  *   FILE 638\n//*           //ATTACH   DD  *                                      *   FILE 638\n//*             attachment statements                               *   FILE 638\n//*           /*                                                    *   FILE 638\n//*           //SYSIN    DD  *                                      *   FILE 638\n//*             email statements                                    *   FILE 638\n//*           /*                                                    *   FILE 638\n//*                                                                 *   FILE 638\n//*      Program: EMAILENC (HLASM)                                  *   FILE 638\n//*      Purpose: Encode squential file for email attachement.      *   FILE 638\n//*               The supported encoding algorithms are:            *   FILE 638\n//*                                                                 *   FILE 638\n//*      Format Encoding Algorithm       Sample data                *   FILE 638\n//*      ====== ================== =============================    *   FILE 638\n//*      TEXT   Quoted Printable   Any plain text, source code      *   FILE 638\n//*      BINARY Base64             Images, program readable data    *   FILE 638\n//*                                                                 *   FILE 638\n//*      The statistics information is also provided in SYSPRINT    *   FILE 638\n//*      DD. The program is designed for better performance.        *   FILE 638\n//*                                                                 *   FILE 638\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@INSTALL": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x01\\x01\\x03\\x18?\\x01\\x06\\x11_\\tU\\x00\\xa5\\x00\\xbd\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2003-07-02T00:00:00", "modifydate": "2006-04-25T09:55:01", "lines": 165, "newlines": 189, "modlines": 0, "user": "ZHOU"}, "text": " **********************************************************************\n * PACKAGE: SENDMAIL\n * Design:  Hunter Guanghui Zhou\n *          Phone: 1-(416)-602-9567\n *          E-mail: zhough2000@yahoo.com\n * Date:    October 2004\n **********************************************************************\n\n INSTALLATION GUIDE\n ==================\n The package contains two programs:\n   Program  Source   Description\n   ======== ======== ==============================================\n   EMAILENC HLASM    Encoding files with BASE64 or Quoted Printable\n   SENDMAIL REXX     Read SYSIN and ATTACH to prepare SMTP email.\n\n Prerequisites\n =============\n   The SENDMAIL package is based on OS/390 TCP/IP SMTP services.\n   Please refer Following IBM Manual to implement SMTP service:\n\n   Chapter   : Configuring the SMTP Server\n   Book Title: IBM Communications Server: IP Configuration Guide\n   Document  : SC31-8725\n\n Installation Procedures\n =======================\n\n I. Customize Assembler Program EMAILENC\n\n    The encoding algorithm Quoted Printable for text data will\n    use EBCDIC to ASCII translation table. The default translation\n    table is Canadian Bilingual CECP Code Page 037. If you require\n    different translation table. You need to copy and paste the\n    translation table to following location of the source program:\n    starting from following DS statement:\n\n    E2ATAB   DS 0CL256\n\n    The translation table can be found in your installation at:\n    TCPIP.SEZATCPX\n\n    Contact your system administrator for the source translation\n    table for following default binary table:\n    TCPIP.STANDARD.TCPXLBIN\n\n    Do not copy the ASCII to EBCDIC translation table.\n\n II. Compile Assembler Program EMAILENC\n\n    This program is re-entrent 31 bit mode program. You should use\n  RENT parm in link editor. Here is the sample JCL to compile this\n  program:\n\n    //COMPILE EXEC ASMACL,PARM.L='LIST,RENT'\n    //C.SYSIN   DD DISP=SHR,DSN=SP2487.ASM.SOURCE(EMAILENC)\n    //C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB\n    //          DD DISP=SHR,DSN=SYS1.MODGEN\n    //L.SYSLMOD DD DISP=SHR,DSN=SYS1.USER.LINKLIB\n    //L.SYSIN   DD *\n      NAME EMAILENC(R)\n    /*\n\n   The target load library can be in your system LINKLST or LPA list.\n   To refresh the LINKLST, issue following MVS command:\n      F LLA,REFRESH\n\n   Or, you can edit the member COMPILE and submit it.\n\n III. Customize REXX program SENDMAIL\n\n   The REXX program SENDMAIL will interpret the SYSIN and ATTACH\n   DD, and prepare email body and attachements for SMTP service.\n   Please refer the member @USERGDE for the usage of SENDMAIL.\n\n   The SENDMAIL program is required to customize to meet your\n   system environment. Edit the program SENDMAIL and locate at\n   following statement:\n\n    Init_Main:\n\n   Follow this statement, there are 6 variables need to be customized:\n\n   SenderEmail\n   -----------\n     SenderEmail tell SMTP server which email address to be\n     used in SENDFROM field. This email address should be\n     generic email address representing your mainframe.\n\n    Example:\n      SenderEmail  = '\"Mainframe System\" <hostname@company.com>'\n\n   SMTP_Writer\n   ----------\n     SMTP Wirter Name. Refer to your SMTP configurations.\n     The default is SMTP.\n   Example:\n     SMTP_Writer  = 'SMTP'\n\n   SMTP_Class\n   ----------\n     SMTP output class, Refer to your SMTP configurations.\n     The default is B\n   Example:\n     SMTP_Class   = 'B'\n\n   TimeZone\n   --------\n     The time zone of your system.\n     The default is EST\n   Example:\n     SMTP_Class   = 'EST'\n\n IV. Install REXX Program SENDMAIL\n    The REXX program should be installed in your TSO command libarary.\n  such as SYS1.CLIST.\n     Copy the member SENDMAIL from this installation library to your\n  TSO command library.\n\n\n V. Check list for installation\n   Item  Task                                       Status/Value\n   ==== ==========================================  ============\n    1.  Implement your SMTP server                  ______\n\n    2.  Cusomize Translation Table in EMAILENC      ______\n\n    3.  Compile the encoding program EMAILENC       ______\n        LOADLIB Dataset Name (in LINKLST)           ___________________\n\n    4.  Cusomize the SENMAIL REXX program values    ______\n\n    5.  Install SENDMAIL REXX program               ______\n        REXXLIB Dataset Name (used in SYSEXEC)      ___________________\n\n VI. Test the SENDMAIL program\n\n  Refer the member @USERGDE for syntax of ATTACH and SYSIN DD.\n  The JCL batch syntax is:\n\n  // job card here\n  //SENDMAIL EXEC PGM=IKJEFT01,PARM=SENDMAIL\n  //* If the EMAILENC is in LINKLST, remove STEPLIB\n  //*STEPLIB  DD  DISP=SHR,DSN=SYS1.USER.LINKLIB\n  //SYSEXEC  DD  DISP=SHR,DSN=SYS1.USER.REXXLIB\n  //SYSTSPRT DD  SYSOUT=*\n  //SYSTSIN  DD  DUMMY\n  //ATTACH   DD  *\n    attachment statements\n  /*\n  //SYSIN    DD  *\n    email statements\n  /*\n\nQuestions & suggestions\n=======================\n Should you have any question, please contact Hunter Zhou at\n zhough2000@yahoo.com\n\n October, 2003\n\n Hunter Guanghui Zhou\n Phone: 1-(416)-602-9567\n E-mail: zhough2000@yahoo.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@USERGDE": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x12\\x01\\x04\\x15\\x9f\\x01\\x06\\x11_\\tW\\x01g\\x01U\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-06-07T00:00:00", "modifydate": "2006-04-25T09:57:12", "lines": 359, "newlines": 341, "modlines": 0, "user": "ZHOU"}, "text": " **********************************************************************\n * PACKAGE: SENDMAIL\n * Design:  Hunter Guanghui Zhou\n *          Phone: 1-(416)-602-9567\n *          E-mail: zhough2000@yahoo.com\n * Date:    October, 2004\n **********************************************************************\n The package SENDMAIL can send emails in JCL batch with attachments.\n\n USER GUIDE\n ==========\n\n The SENDMAIL program is designed for Mainframe OS/390, z/OS systems.\n All the mail will be sent via TCP/IP SMTP mail server.\n Please refer the installation guide for the SMTP customization\n information.\n\n Syntax of JCL\n =============\n E-mail messages are given through SYSIN DD.\n All attachments are given through ATTACH DD.\n If the EMAILENC is in LINKLST, remove STEPLIB DD.\n\n  // job card here\n  //SENDMAIL EXEC PGM=IKJEFT01,PARM=SENDMAIL\n  //* If the EMAILENC is in LINKLST, remove STEPLIB\n  //*STEPLIB  DD  DISP=SHR,DSN=SYS1.USER.LINKLIB\n  //SYSEXEC  DD  DISP=SHR,DSN=SYS1.USER.REXXLIB\n  //SYSTSPRT DD  SYSOUT=*\n  //SYSTSIN  DD  DUMMY\n  //ATTACH   DD  *\n    attachment statements\n  /*\n  //SYSIN    DD  *\n    email statements\n  /*\n\n Syntax of SYSIN DD\n ==================\n The program will just read the column 1-72, the column 73-80 will be\n ignored.\n\n The SYSIN DD have two sections: Header and Body.\n\n Email Header\n ------------\n   Header is from the first line to the line begin with Subject:\n   There are 4 keywords supported:\n     1. \"From:\" The Email address to send email from (Optional).\n              The default address is TSOID@hostname.domain.name\n\n     2. \"To:\" The email list for sending this email to (Madatory).\n              One email address must be in single line\n              The email address syntax is :\n                 \"name\" <email.address>\n              The <email.address> is mandatory and \"name\" is optional.\n              Multiple addresses are continued by ',' or ';' or space.\n              Example 1:\n              To: \"my friend1\" <my.friend1@his.company.com>\n\n              Example 2:\n              To: \"my friend1\" <my.friend1@his.company.com>,\n                  \"my friend2\" <my.friend2@his.company.com>,\n                  \"my friend3\" <my.friend3@his.company.com>\n\n     3. \"Cc:\" The email list for copying this email to (Optional).\n              The syntax of email address is the same as To:\n\n     4. \"Bcc:\" The email list for copying this email with hide (Optional)\n              The syntax of email address is the same as To:\n\n     5. \"Subject:\" The email subject.(Mandatory)\n\n   Header support comments, while the email body does not.\n   Any text beyond \"#\" will be interpreted as comments.\n   Except the keyword \"Subject:\", the value for the all\n   other keywords support multiple line, and one email address\n   must be in one line.\n\n Email Body\n ----------\n   Email body is the lines after the line of \"Subject:\".\n   There is no comment allowed in the body, which will be sent as is.\n   The body supports HTML tags.\n   You may provide your own signature at the end of body.\n\n   Example 1: Simple version.\n     Dear Friend,\n     This is a sample email send to you from mainframe.\n     Please ignore this email as it's a test one.\n\n     Thanks\n\n     Hunter\n\n   Example 2: HTML version:\n     Dear <B><I>Friend</I></B>,\n     This is a sample email send to you from <font size=\"+1\">\n     mainframe</font>.\n\n     Please ignore this email as it's a test one.\n\n     <I>Thanks<I>\n\n     <B>Hunter</B>\n\n\n Syntax of ATTACH DD\n ===================\n  This is a text file to instruct SENMAIL batch to send the attachments.\n  You can send multiple attachments in this DD.\n  ATTACH DD is optional. If you don't code this DD, there will be\n  no attachment in the email batch.\n\n  The file must be sequential file (QSAM) in catalog.\n  Supported Files:\n   .Sequential file (QSAM)\n   .PDS member\n   .GDG files: The GDG generations is allowed.\n   .DD  Name:  You can specify DD Names  to be attached in the email,\n               The DD name must be pre-allocated in submit JCL.\n\n  According to SMTP standard RFC 1521, the attchements will be encoded\n  depending on their formats:\n\n    Format Encoding Algorithm       Sample data\n    ====== ================== ========================================\n    TEXT   Quoted Printable   Any plain text, source code\n    BINARY Base64             Images, program readable data (zip,doc...)\n\n  You must correctly specify the format of each attachment, otherwise\n  the receivers will not get what they want.\n\n  Guidelines in ATTACH DD\n  -----------------------\n    Please follow following guidelines while preparing this DD:\n    1. Any lead or tailed space(' ') will be ingored.\n    2. Any text beyond '#' will be comments.\n    3. Each attachment will have a separate section leaded by\n       keyword ATTACHMENT:\n    4. There are four sub-keywords for each attachment:\n       'DATASET     =' One of following dataset name:\n            .Sequential file (QSAM)\n            .GDG file\n            .PDS member\n            .DD Name, pre-allocated DD name in JCL.\n            This statement is mandatory.\n       'RENAME      =' The new name to be used in e-mail.\n            You may use this field to specify the common name in emails\n            such as: Report.txt, Summary.txt, Install.Package.zip.\n            This statement is optional.\n       'FORMAT      =' The format of the dataset:\n            Format Encoding Algorithm       Sample data\n            ====== ================== =============================\n            TEXT   Quoted Printable   Any plain text, source code\n            BINARY Base64             Images, program readable data\n            This statement is optional (TEXT is default)\n       'DESCRIPTION =' The description shown in e-mail. (optional)\n            This statement is optional.\n    5. If there is no attachment DD, the email batch will ignore this\n       file, and just sent the e-mail message defined in SYSIN DD.\n\n  Examples for ATTACH DD\n  ----------------------\n\n    Example 1: Single attachment\n     //ATTACH DD  *\n     #--Begin--\n     Attachment:\n       Dataset      = SYS1.USER.JCL(SENDMAIL)\n       Rename       = Sample SENDMAIL JCL.txt\n       Format       = text\n       Description  = The sample JCL for send email from mainframe\n     #--end--\n     /*\n\n    Example 2: Multiple attachments\n     //ATTACH DD  *\n     # Attachement No. 1\n     Attachment:\n       Dataset      = SYS1.RMF.REPORT(0)\n       Rename       = Latest RMF Report.txt\n       Format       = text\n       Description  = The Latest System Performance Report\n     # Attachement No. 2\n     Attachment:\n       Dataset      = SYS1.RMF.REPORT.PARM\n       Rename       = System Report Parameters\n       Format       = text\n       Description  = The parameters for RMF report\n     #--end--\n     /*\n\n    Example 3: Single attachment via DD Name\n     //OUTPUT DD DISP=SHR,DSN=SYS1.RMF.REPORT(0)\n     //ATTACH DD  *\n     Attachment:\n       Dataset      = OUTOUT\n       Rename       = Sample SENDMAIL JCL.txt\n       Format       = text\n       Description  = The sample JCL for send email from mainframe\n     /*\n\n Send Mail Exmaple\n =================\n\n//job card here\n//*\n//*This job is created by Hunter Zhou in year 2001.\n//*Contact:  zhough2000@yahoo.com\n//*\n//*Purpose: Send e-mail with attachments.\n//*\n//SENDMAIL EXEC PGM=IKJEFT01,PARM=SENDMAIL\n//SYSEXEC  DD  DSN=SYS1.USER.CMDPROC,DISP=SHR\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  DUMMY\n//ATTACH   DD  *\n#######################################################################\n#File Type: ATTACH (OPTIONAL)                                         #\n#Purpose:                                                             #\n#  This is a text file to instruct SENMAIL batch send the attachments.#\n#  You may send multiple attachments in a single batch.               #\n#Guidelines:                                                          #\n# Please follow following guidelines:                                 #\n# 1. Any line lead with '#' will be comments.                         #\n# 2. Each attachment will have a separate section leaded by           #\n#    keyword 'ATTACHMENT:'                                            #\n# 3. There are three lines in each attachment:                        #\n#      DATASET     = Dataset name, sequential, PDS member or GDG file #\n#      RENAME      = The new name to be used in e-mail. (optional)    #\n#      FORMAT      = The format of the dataset, TEXT or BINARY        #\n#      DESCRIPTION = The description shown in e-mail. (optional)      #\n# 4. If there is no attachment DD, or an invalid format in this file, #\n#    The email batch will ignore this file, and just sent the e-mail  #\n#    defined in SYSIN DD.                                             #\n#######################################################################\n#--Begin--\nAttachment:\n  Dataset      = SP2487.ZHOUGH.JCL(SENDMAIL)\n  Rename       = Sample SENDMAIL JCL.txt\n  Format       = text\n  Description  = The sample JCL for send email from mainframe\n#--end--\n#\n/*\n//SYSIN   DD  *\n#Use leading '#' for comments.\n#File Type: SYSIN (MANDATORY)\n#<Mail Header>\n#Use ',' for continuation.\n#To: Send to list.                                    (Mandatory)\nTo: \"Hunter Zhou\"     guanghui.zhou@sobeys.com,\n    \"Guanghui Zhou\"   guanghui.zhou@sobeys.com,\n    \"Hunter Zhou\"     guanghui.zhou@sobeys.com\n#\n#Cc: Copy to list.                                    (Optional)\nCc: \"Hunter Zhou\" guanghui.zhou@sobeys.com\n#\n#Bcc: Hide the copy to list.                          (Optional)\n#Bcc: \"Some body\"     hide_email@company.com\n#\n#Subject: The email subject.                          (Mandatory)\n#'Subject:' is the last line of the header.\n#Only one line allowed for subject (No continuation)\n#\n#Mail Content: Any line after Subject line            (Optional)\nSubject: The Sample Mail Sent From Mainframe.\nHi Hunter,\n\n  This is a sample email from Sobeys Ontario Mainframe.\n\n  Here is the <B>usage</B> of <B STYLE=\"color:red size=+1\">SENDMAIL</B>.\n\n  The SENDMAIL program is designed for Sobeys Ontario Mainframe.\n  All the mail will be sent via Sobeys internal mail server.\n  E-mail messages are given through <B>SYSIN DD</B>.\n  All attachments are given through <B>ATTACH DD</B>.\n\n  <H3>Syntax of SYSIN DD:</H3>\n  The SYSIN DD have two sections: Header and Body.\n\n  <B>Header:</B>\n    Header is from the first line to the line begin with Subject:\n    There are 4 keywords supported:\n      1. \"To:\" The email list for sending this email to.\n      2. \"Cc:\" The email list for copying this email to.\n      3. \"Bcc:\" The email list for copying this email with hide.\n      3. \"Subject:\" The email subject.\n    Header support comments, while the body does not.\n    Any line begin with \"#\" will be interpreted as comments.\n    Except for the keyword \"Subject:\", the value for the all\n    other keywords support multiple line, but one email address\n    must be in one line.\n\n  <B>Body:</B>\n    Email body is the lines after the line of \"Subject:\".\n    There is no comment allowed in the body, which will be sent\n    as part of email.\n    The body supports HTML formats\n    You may provide your own signature at the end of body.\n\n  <H3>Syntax of ATTACH DD:</H3>\n   This is text file to instruct SENMAIL batch to send the attachments.\n   You may send multiple attachments in this DD.\n   ATTACH DD is an <B>optional</B>. If you do not code this DD,\n   there will be no attachment in the email batch.\n\n   According to SMTP standard RFC 1521, the attchements will be encoded\n   depending on their formats:\n   <PRE>\n    Format  Encoding Algorithm        Sample data\n    ======  ==================  ==============================\n    TEXT    Quoted Printable    Any plain text, source code\n    BINARY  Base64              Images, program readable data\n   </PRE>\n   You must correctly specify the format of each attachment, otherwise\n   the receivers will not get what they want.\n\n   <B>Guidelines:</B>\n    Please follow following guidelines while preparing this DD:\n    1. Any lead or tailed space(' ') will be ingored.\n    2. Any line begin with '#' will be comments.\n    3. Each attachment will have a separate section leaded by\n &nbsp keyword <FONT FACE=\"COURIER\">ATTACHMENT:</FONT>\n    4. There are four sub-keywords for each attachment:\n &nbsp 'DATASET     =' The dataset name, must be sequential text.\n &nbsp 'RENAME      =' The new name to be used in e-mail. (optional)\n &nbsp 'FORMAT      =' The format of the dataset, TEXT or BINARY\n &nbsp 'DESCRIPTION =' The description shown in e-mail. (optional)\n    5. If there is no attachment DD, the email batch will ignore this\n &nbsp file, and just sent the e-mail message defined in SYSIN DD.\n\n The contents supports <B>HTML Format</B>. Here are examples:\n <BR><B><FONT COLOR=\"GREEN\">\n <EM>Production Mainframe</EM>\n Information Technology\n Sobeys Ontario\n 6355 Viscount Road\n Mississauga, Ontario\n L4V 1W2\n </FONT></B>\n\n This is the last line of email. The attachement messages will be\n inserted after this line by the SENDMAIL program, if any.\n/*\n\n\nQuestions & suggestions\n=======================\n Should you have any question, please contact Hunter Zhou at\n zhough2000@yahoo.com\n\n June, 2003\n\n Hunter Guanghui Zhou\n Phone: 1-(416)-602-9567\n E-mail: zhough2000@yahoo.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPILE": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x03\\x17O\\x01\\x06\\x11_\\tX\\x00\\x16\\x009\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2003-06-23T00:00:00", "modifydate": "2006-04-25T09:58:00", "lines": 22, "newlines": 57, "modlines": 0, "user": "ZHOU"}, "text": "//SP2487CP JOB (DCTS2INF),HUNTER.Z,MSGCLASS=X,MSGLEVEL=(1,1),CLASS=9,   JOB02090\n//             NOTIFY=&SYSUID\n//********************************************************************\n//*Purpose: Generate LOAD MODULES FOR EMAILENC\n//*Design : Hunter Guanghui Zhou\n//*         Phone: 1-(416)-602-9567\n//*         E-mail: zhough2000@yahoo.com\n//*Update : May, 2003\n//*********************************************************************\n//* COMPILE TIME UPDATES:                                             *\n//*********************************************************************\n// SET  SRCLIB='SYS1.PACKAGE.SENDMAIL.INSTALL',   <==THIS PDS LIBRARY\n//      LOADLIB='SYS1.USER.LINKLIB'               <==Linklst Library\n//********************************************************************\n//COMPILE EXEC ASMACL,PARM.L='LIST,RENT'\n//C.SYSIN   DD DISP=SHR,DSN=&SRCLIB(EMAILENC)\n//C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//L.SYSLMOD DD DISP=SHR,DSN=&LOADLIB\n//L.SYSIN   DD *\n  NAME EMAILENC(R)\n/*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EMAILENC": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x1c\\x00W\\x01\\x04'/\\x01\\x06\\x11_\\tY\\x05\\xfe\\x05+\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@\"", "ispf": {"version": "01.28", "flags": 0, "createdate": "2004-09-28T00:00:00", "modifydate": "2006-04-25T09:59:57", "lines": 1534, "newlines": 1323, "modlines": 0, "user": "ZHOU"}, "text": "EMAILENC TITLE 'ENCODE QSAM FILE FOR EMAIL ATTACHMENTS'\n***********************************************************************\n*               Encode QSAM file for Email Attachment                 *\n*---------------------------------------------------------------------*\n* Program: EMAILENC                                                   *\n* Purpose: Encode QSAM file for Email Attachment                      *\n* Design : Hunter Guanghui Zhou                                       *\n*          Phone: 1-(416)-602-9567                                    *\n*          E-mail: zhough2000@yahoo.com                               *\n* Date   : June 2003                                                  *\n* Description:                                                        *\n*   This program is designed to encode QSAM file into following file  *\n*   formats:                                                          *\n*                                                                     *\n* Source Type Encode Algorithm EXEC PARM        Description           *\n* =========== ================ ================ ======================*\n* Text file   Quoted Printable TEXT or QTEPRT   For normal text file  *\n* Binary file BASE 64          BINARY or BASE64 For normal binary file*\n*                                                                     *\n*   The encode mode is determinated by EXEC PARM.                     *\n*                                                                     *\n* All attachments in email via SMTP protocol must use one of these    *\n* two encoding algorithm, depending on the format of the attachment.  *\n*                                                                     *\n* Installation Instruction                                            *\n* ========================                                            *\n* 1. Compile                                                          *\n*                                                                     *\n*    This program is re-entrent 31 bit mode program. You should use   *\n* RENT parm in link editor. Here is the sample JCL to compile this    *\n* program:                                                            *\n*                                                                     *\n*   //COMPILE EXEC ASMACL,PARM.L='LIST,RENT'                          *\n*   //C.SYSIN   DD DISP=SHR,DSN=SP2487.ASM.SOURCE(EMAILENC)           *\n*   //C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB                           *\n*   //          DD DISP=SHR,DSN=SYS1.MODGEN                           *\n*   //L.SYSLMOD DD DISP=SHR,DSN=SYS1.USER.LINKLIB                     *\n*   //L.SYSIN   DD *                                                  *\n*     NAME EMAILENC(R)                                                *\n*   /*                                                                *\n*                                                                     *\n*  The target load library can be in your system LINKLST or LPA list. *\n*  To refresh the LINKLST, issue following MVS command:               *\n*     F LLA,REFRESH                                                   *\n*                                                                     *\n* User Guide                                                          *\n* ==========                                                          *\n*                                                                     *\n*  The program is usually used with send email programs with SMTP.    *\n*  The send mail program can call this program with following         *\n*  requirements.                                                      *\n*                                                                     *\n*  1. Required File Allocation:                                       *\n*   INPUT    : The QSAM (Sequential) file to be encoded for email     *\n*              attachment. This file can be any format (F,V or U).    *\n*              The input DD name can be any pre-allocated DD name.    *\n*              If you choose the DD name other than INPUT, you must   *\n*              specify the DD name in the second option of EXEC PARM. *\n*   OUTPUT   : The encoded file to be saved to. This file must be     *\n*              sequential file with fixed block, record length of     *\n*              76. The size of this output file should be 33% more    *\n*              than the INPUT file. If the input file is 30 tracks,   *\n*              the output file should be 40 tracks.                   *\n*              The output DD name can be any pre-allocated DD name.   *\n*              If you choose the DD name other than OUTPUT, you must  *\n*              specify the DD name in the third option of EXEC PARM.  *\n*   SYSPRINT : The message file for this program.                     *\n*              This DD statement is optional.                         *\n*                                                                     *\n*  2. Required parameters                                             *\n*                                                                     *\n*   The parameters is to tell the program to use which algorithm      *\n*   to encode the input file. The paramenter is given by EXEC PARM    *\n*   The syntax:                                                       *\n*                                                                     *\n*   PARM='algorithm,inddname,outddname'                               *\n*   PARM='algorithm,inddname'                                         *\n*   PARM='algorithm'                                                  *\n*   PARM=''                                                           *\n*                                                                     *\n*   algorithm                                                         *\n*   =========                                                         *\n*                                                                     *\n*   First parameter is the encode algorithm as follows:               *\n*                                                                     *\n*   TEXT or QTEPRT: Use Quoted Printable algorithm to encode the      *\n*                   input file. This encoding is for text files.      *\n*                   This encoding will truncate all trailing spaces   *\n*                   of each record.                                   *\n*                                                                     *\n*   BINARY or BASE64: Use BASE 64 algorithm to encode the input file. *\n*                   This encoding is for binary files, such as ZIP    *\n*                   files.                                            *\n*                                                                     *\n*   inddname                                                          *\n*   ========                                                          *\n*                                                                     *\n*   The second DD name is the DD name for input file, this DD name    *\n*   must be pre-allocated before the program is executed.             *\n*                                                                     *\n*   outddname                                                         *\n*   =========                                                         *\n*                                                                     *\n*   The third  DD name is the DD name for output file, this DD name   *\n*   must be pre-allocated before the program is executed.             *\n*                                                                     *\n*                                                                     *\n*   If there is no EXEC PARM, the program will use TEXT as default.   *\n*       Algorithm:      TEXT                                          *\n*       Input DD name:  INPUT                                         *\n*       Output DD Name: OUTPUT                                        *\n*                                                                     *\n*  Examples                                                           *\n*                                                                     *\n*   1. Example for encoding text input file:                          *\n*                                                                     *\n*  //ENCODE  EXEC PGM=EMAILENC,PARM=TEXT                              *\n*  //INPUT     DD DISP=SHR,DSN=DC.DSD.TELINK.UPLOAD.MERGED.G1370V00   *\n*  //OUTPUT    DD DISP=OLD,DSN=SP2487.TEMP.OUTPUT                     *\n*  //SYSPRINT  DD SYSOUT=*                                            *\n*                                                                     *\n*   2. Example for encoding binary input file:                        *\n*                                                                     *\n*  //ENCODE  EXEC PGM=EMAILENC,PARM=BINARY                            *\n*  //INPUT     DD DISP=SHR,DSN=SP2487.SOFTWARE.ZIP                    *\n*  //OUTPUT    DD DISP=OLD,DSN=SP2487.TEMP.OUTPUT                     *\n*  //SYSPRINT  DD SYSOUT=*                                            *\n*                                                                     *\n*   3. Example for using different DD names:                          *\n*                                                                     *\n*  //ENCODE  EXEC PGM=EMAILENC,PARM='TEXT,IN001,OUT001'               *\n*  //IN001     DD DISP=SHR,DSN=DC.DSD.TELINK.UPLOAD.MERGED.G1370V00   *\n*  //OUT001    DD DISP=OLD,DSN=SP2487.TEMP.OUTPUT                     *\n*  //SYSPRINT  DD SYSOUT=*                                            *\n*                                                                     *\n*  There is a REXX program SENDMAIL to use this program to send email *\n*  via OS/390 SMTP server.                                            *\n*  If you need this REXX program, contact with Hunter Zhou.           *\n*                                                                     *\n*  Here is example to use SENDMAIL program which use this encoding    *\n*  program:                                                           *\n*                                                                     *\n*   //SENDMAIL EXEC PGM=IKJEFT01,PARM=SENDMAIL                        *\n*   //SYSEXEC  DD  DSN=SP2487.ZHOUGH.REXX,DISP=SHR                    *\n*   //SYSTSPRT DD  SYSOUT=*                                           *\n*   //SYSTSIN  DD  DUMMY                                              *\n*   //ATTACH   DD  *                                                  *\n*   Attachment:                                                       *\n*     Dataset      = SP2487.TEMP.SOFTWARE.ZIP                         *\n*     Rename       = Software.zip                                     *\n*     Format       = BINARY                                           *\n*     Description  = Software Installation Package                    *\n*   #--end--                                                          *\n*   #                                                                 *\n*   /*                                                                *\n*   //SYSIN   DD  *                                                   *\n*   To: \"Hunter Zhou\"     guanghui.zhou@sobeys.com                    *\n*   Subject: The software installation package.                       *\n*   Hi Hunter,                                                        *\n*                                                                     *\n*     This is a sample email from Mainframe.                          *\n*                                                                     *\n*     For any further support, please contact:                        *\n*                                                                     *\n*     Hunter Zhou                                                     *\n*     Tel: (905) 671-5208                                             *\n*     guanghui.zhou@sobeys.com                                        *\n*   /*                                                                *\n*                                                                     *\n***********************************************************************\nEMAILENC CSECT\nEMAILENC AMODE 31\nEMAILENC RMODE ANY\n         YREGS\n         USING EMAILENC,R15       R15 IS CURRENT ADDRESS, USING IT\n         B     START              BRANCH AROUND CONSTANTS\n         DC    C' Program Name(EMAILENC)'       MODULE IDENTIFIER\n         DC    C' Compile Time(&SYSDATE &SYSTIME)'\n         DC    C' Purpose: Encode Sequential file for TCP/IP'\n         DC    C' SMTP Email attachment.'\n         DC    C' Usage of EXEC PARM: TEXT|QTEPRT for text encoding,'\n         DC    C' BINARY|BASE64 for binary encoding.'\n         DC    C' Design: Hunter Zhou, zhough2000@yahoo.com     '\nSTART    DS    0H\n         SAVE  (14,12)            ;SAVE CALLER'S REGISTERS\n         LR    R12,R15            ;COPY THE MY START ADDRESS\n         LA    R11,2048(,R12)     ;LOAD R11=R12+4096\n         LA    R11,2048(,R11)\n         DROP  R15                ;DROP THE TEMPORARY USING\n         USING EMAILENC,R12,R11   ;USE R12,R11 AS BASE REGISTERS.\n         LR    R7,R1              ;COPY THE CURRENT PARM ADDRESS\n         LR    R8,R13             ;COPY THE CALLER'S SAVE AREA ADDR\n* DYNAMICALLY ALLOCATE STORAGE FOR DATA AREAS\n         GETMAIN RU,LV=DSALEN,LOC=BELOW ;OBTAIN STORAGE FOR DATA AREAS\n* AS THE SAVE AREA IS AT START OF DSA DSECT, THE R13 CAN BE BOTH OF\n* THE ADDRESSING REGISTER FOR THIS DSECT, AND THE ADDRESS OF OUR SAVE\n* AREA, WHICH IS REQUIRED BY LINKAGE FOR LINKAGE CONVENTION.\n         LR    R13,R1             ;LOAD STORAGE ADDRESS INTO R13\n         USING DSA,R13            ;USING R13 AS DSA ADDRESSING REGS.\n         ST    R8,SAVEAREA+4      ;SET OUR BACKWARD LINKAGE\n         ST    R13,8(,R8)         ;SET MY SAVE AREA AT CALLER'S AREA\n         ST    R7,PARMADR         ;SAVE THE EXEC PARM ADDRESS\n* INITIALIZE BUFFERS\n         BAL   R2,INITIAL         ;INITIALIZE BUFFERS\n         CLI   RETCODE,ZERO       ;TEST RETURN CODE\n         BNE   RETURN\n* READ THE EXEC PARM\n         BAL   R2,READPARM        ;INITIALIZE BUFFERS\n         CLI   RETCODE,ZERO       ;TEST RETURN CODE\n         BNE   MAIN2000\n* OPEN FILES\n         BAL   R2,OPENFILE        ;OPEN FILES\n         CLI   RETCODE,ZERO       ;TEST RETURN CODE\n         BNE   MAIN2000\n* PROCESS FILE\n         BAL   R2,PROCFILE\n         CLI   RETCODE,ZERO       ;TEST RETURN CODE\n         BNE   MAIN2000\n* CLOSE FILE\nMAIN2000 EQU   *\n         BAL   R2,SHOWINFO        ;RETURN CODE IS IN R9\n         BAL   R2,CLOSFILE        ;CLOSE ALL FILES\n*  RETURN LINKAGE\nRETURN   EQU   *\n         XR    R9,R9              ;CLEAR R9\n         IC    R9,RETCODE         ;LOAD RETURN CODE TO R9\n         L     R8,SAVEAREA+4      ;LOAD THE CALLER'S SAVE AREA\n         FREEMAIN RU,LV=DSALEN,A=(R13)  ; FREE ALLOCATED STOR\n         LR    R13,R8             ;RESTORE CALL'S SAVE AREA\n         LR    R15,R9             ;SET RETURN CODE TO R15\n         RETURN (14,12),RC=(15)   ;RESTORE CALLER'S REGS AND RETURN\n*---------------------------------------------------------------------*\n* ROUTINE: INITIAL\n* DESCRIPTION: INITIALIZE ALL BUFFERS\n* INPUT:\n*    R2  : RETURN CONTROL\n* RETURN :\n*---------------------------------------------------------------------*\nINITIAL  EQU    *\n         MVI   RETCODE,ZERO       ;RESET RETURN CODE\n* SET THE DEFAULT VALUES\n         MVI   DATAFMT,QTEPRT              DEFAULT DATA IS QTEPRT\n         MVC   INDDNAME,DEFTINDD           DEFAULT INPUT DDNAME\n         MVC   OUDDNAME,DEFTOUDD           DEFAULT OUTPUT DDNAME\n* INITIALIZE INPUT DCB\n         MVC   INPDCB(CINPDCBL),CINPDCB    COPY DCB\n         MVC   INPDCBE(DCBE$LEN),CINPDCBE  COPY DCBE\n         MVC   INPOPNLF(CINPOPLL),CINPOPL  COPY OPEN LIST FORM\n         MVC   INPCLSLF(CINPCLSL),CINPCLS  COPY CLOSE LIST\n         LA    R4,INPDCBE\n         ST    R4,INPDCB+(DCBDCBE-IHADCB)  UPDATE DCBE IN DCB\n         LA    R4,INPDCB\n         ST    R4,INPOPNLF+4               UPDATE DCB IN OPEN LIST\n         ST    R4,INPCLSLF+4               UPDATE DCB IN CLOSE LIST\n         MVI   INPOPNFL,NO                 SET OPEN FLAG TO NO\n* INITIALIZE OUTPUT DCB\n         MVC   OUTDCB(COUTDCBL),COUTDCB    COPY DCB\n         MVC   OUTDCBE(DCBE$LEN),COUTDCBE  COPY DCBE\n         MVC   OUTOPNLF(COUTOPLL),COUTOPL  COPY OPEN LIST\n         MVC   OUTCLSLF(COUTCLSL),COUTCLS  COPY CLOSE LIST\n         LA    R4,OUTDCBE\n         ST    R4,OUTDCB+(DCBDCBE-IHADCB)  UPDATE DCBE IN DCB\n         LA    R4,OUTDCB\n         ST    R4,OUTOPNLF+4               UPDATE DCB IN OPEN LIST\n         ST    R4,OUTCLSLF+4               UPDATE DCB IN CLOSE LIST\n         MVI   OUTOPNFL,NO                 SET OPEN FLAG TO NO\n* INITIALIZE SYSPRINT DCB\n         MVC   SPRDCB(CSPRDCBL),CSPRDCB    COPY DCB\n         MVC   SPRDCBE(DCBE$LEN),CSPRDCBE  COPY DCBE\n         MVC   SPROPNLF(CSPROPLL),CSPROPL  COPY OPEN LIST\n         MVC   SPRCLSLF(CSPRCLSL),CSPRCLS  COPY CLOSE LIST\n         LA    R4,SPRDCBE\n         ST    R4,SPRDCB+(DCBDCBE-IHADCB)  UPDATE DCBE IN DCB\n         LA    R4,SPRDCB\n         ST    R4,SPROPNLF+4               UPDATE DCB IN OPEN LIST\n         ST    R4,SPRCLSLF+4               UPDATE DCB IN CLOSE LIST\n         MVI   SPROPNFL,NO                 SET OPEN FLAG TO NO\n* INITIALIZE OTHER STUFF\n         XC    INBUFADR(4),INBUFADR        CLEAR INPUT RECORD BUF ADR\n         MVI   REMCTR,ZERO                 RESET THE REMAIN COUNTER\n         LA    R6,OUTREC                   LOAD ADDRESS OF OUTPUT REC\n         ST    R6,OUTPOS                   SAVE TO CURRENT POSITION\n         ZAP   MSGCTR,P0                   RESET THE MSG LINE COUNTER\n* OPEN SYSPRINT DCB\n         OPEN  (SPRDCB,(OUTPUT)),MODE=31,MF=(E,SPROPNLF)\n         LTR   R15,R15              OPEN SUCCESS?\n         BNZ   INI8000              NO, SKIP THE SYSPRINT\n         MVI   SPROPNFL,YES         SET OPEN FLAG TO YES\nINI8000  EQU   *\n* RETURN\n         BR    R2\n* END OF SUB-ROUTINE INITIAL\n*---------------------------------------------------------------------*\n* ROUTINE: READPARM\n* DESCRIPTION: READ AND VALIDATE THE EXEC PARM\n*\n* STEPS:\n*   PARSE THE PARM TEXT\n*  READ EACH WORD IN PARM\n*     IF THIS IS THE FIRST PARM, CALL FORMAT ROUTINE\n*     IF THIS IS THE SECOND PARM, CALL INPUT DD ROUTINE\n*     IF THIS IS THE THIRD PARM, CALL OUTPUT DD ROUTINE\n*\n*  FORMAT ROUTINE:\n*     IF THE WORD MATCH 'TEXT' OR 'QTEPRT' USE TEXT\n*     IF THE WORD MATCH 'BINARY' OR 'BASE64' USE BINARY\n*     OTHERWISE SHOW THE ERROR MESSAGE\n*\n*  INPUT DD ROUTINE:\n*     IF THE LENGTH IS LESS THAN 8, COPY THE DD NAME\n*     OTHERWISE SHOW THE ERROR MESSAGE\n*\n*  OUTPUT DD ROUTINE:\n*     IF THE LENGTH IS LESS THAN 8, COPY THE DD NAME\n*     OTHERWISE SHOW THE ERROR MESSAGE\n*\n* INPUT:\n*    R2  : RETURN CONTROL\n*    R7  : EXEC PARM ADDRESS\n* RETURN :\n*   DATAFMT: EITHER TEXT OR BINARY\n*   RETCODE: 0 IF VALID PARM, 8 IF INVALID PARM\n*---------------------------------------------------------------------*\nREADPARM EQU    *\n         STM   R0,R15,SVLVL1      ;SAVE THE REGISTERS\n         MVI   RETCODE,ZERO       ;RESET RETURN CODE\n* PRINT WELCOME MESSAGE\n         MVI   MSGID,MSG001I\n         BAL   R4,WRITELOG\n         MVI   MSGID,MSG002I\n         BAL   R4,WRITELOG\n         MVI   MSGID,MSG003I\n         BAL   R4,WRITELOG\n* READ PARM\n         XR    R1,R1\n         STH   R1,PRMWSEQ         ;RESET THE SEQUENCE ID\n         L     R7,PARMADR         ;READ PARM ADDRESS\n         L     R7,0(R7)           ;PARM ADDRESS\n         LH    R5,0(R7)           ;LENGTH OF PARM\n         LTR   R5,R5              ;TEST IF PARM IS ZERO\n         BZ    RDP7000            ;IF NO PARM, USE DEFAULT\n* START TO PARSE THE PARMTEXT\n* R10: COUNTER, THE LENGTH OF PARM\n* R8: THE START OF WORD\n* R9: THE CURRENT OF THE WORD (LAST POSITION OF THE WORD)\n         LR    R10,R5             ;\n         LA    R8,2(,R7)          ;R8: START OF THE DATA\n         LR    R9,R8              ;R9: CURRENT POINT POSITION\nRDP1000  EQU   *\n         CLI   0(R9),C' '         ;TEST IF THIS IS A SEPARATOR\n         BE    RDP2000            ;IF YES, GET A WORD, TEST IT\n         CLI   0(R9),C','         ;TEST IF THIS IS A SEPARATOR\n         BE    RDP2000            ;IF YES, GET A WORD, TEST IT\n         LA    R9,1(0,R9)         ;MOVE TO THE NEXT BYTE\nRDP1500  BCT   R10,RDP1000        ;CONTINUE TO TILL THE END\n* GET A WORD.\nRDP2000  EQU   *\n         CR    R8,R9              COMPARE THE START AND END POINTER\n         BE    RDP4000            SKIP TO PROCESS THIS EMPTY WORD\n* TEST THIS WORD\n         MVI   PRMWORD,C' '\n         MVC   PRMWORD+1(L'PRMWORD),PRMWORD\n*\n         LA    R6,PRMWORD\n         LR    R7,R8\n         LR    R5,R9\n         SR    R5,R8\n         BCTR  R5,0\n* TEST THE LENGTH OF THE WORD\n         LA    R1,7               SET THE MAXIMUM LENGTH TO 7 (0-7)\n         CR    R5,R1              COMPARE THE CURRENT WORD LENGTH\n         BH    RDP0800            MESSAGE IS TOO LONG\n         EX    R5,MVCREC          COPY THE WORD\n         STH   R5,PRMWLEN         SAVE THE WORD LENGTH\n         LH    R1,PRMWSEQ         ADD THE SEQUENCE\n         LA    R1,1(0,R1)\n         STH   R1,PRMWSEQ         ;SET THE SEQ TO FIRST.\n* IF THE SEQUENCE IS 1, CALL THE FORMAT PARMETER\n         CLI   PRMWSEQ+1,X'01'\n         BNE   RDP3000\n         BAL   R3,RDPFMT00        CALL READ FORMAT PARAMETER\n         B     RDP4000\n* IF THE SEQUENCE IS 2, CALL THE INPUT DD PARMETER\nRDP3000  EQU   *\n         CLI   PRMWSEQ+1,X'02'\n         BNE   RDP3500\n         LA    R7,PRMWORD         LOAD THE START OF THE WORD\n         LA    R6,INDDNAME        LOAD THE INPUT DD STORAGE ADDRESS\n         LH    R5,PRMWLEN         LOAD THE LENGTH OF THE WORD\n         EX    R5,MVCREC\n         B     RDP4000\n* IF THE SEQUENCE IS 3, CALL THE OUTPUT DD PARMETER\nRDP3500  EQU   *\n         CLI   PRMWSEQ+1,X'03'\n         BNE   RDP4000            MORE THAN 3 PARAMETERS\n         LA    R7,PRMWORD         LOAD THE START OF THE WORD\n         LA    R6,OUDDNAME        LOAD THE INPUT DD STORAGE ADDRESS\n         LH    R5,PRMWLEN         LOAD THE LENGTH OF THE WORD\n         EX    R5,MVCREC\n         B     RDP4000\n* PREPARE FOR NEXT MOVE\nRDP4000  EQU   *\n         LA    R9,1(0,R9)         MOVE WORD START POINTER TO NEXT\n         LR    R8,R9\n         LTR   R10,R10\n         BNZ   RDP1500            ;IF THE LENGTH IS NOT 0, CONTINUE\n         B     RDP7000\n* END OF THE LOOP\nRDP7000  EQU   *\n         LA    R10,INPDCB\n         USING IHADCB,R10\n         MVC   DCBDDNAM(8),INDDNAME  COPY THE DDNAME\n         DROP  R10\n         LA    R10,OUTDCB\n         USING IHADCB,R10\n         MVC   DCBDDNAM(8),OUDDNAME  COPY THE DDNAME\n         DROP  R10\n* Show the input DD infomration\n         MVC   MSGBUFTX(34),=CL34'EME024I The input data is from DD '\n         MVC   MSGBUFTX+34(8),INDDNAME\n         MVI   MSGBUFTX+42,C'.'\n         MVI   MSGBUFLN,43\n         MVI   MSGID,MSGCUST\n         BAL   R4,WRITELOG\n* Show the input DD infomration\n         MVC   MSGBUFTX(33),=CL33'EME025I The output data is to DD '\n         MVC   MSGBUFTX+33(8),OUDDNAME\n         MVI   MSGBUFTX+41,C'.'\n         MVI   MSGBUFLN,42\n         MVI   MSGID,MSGCUST\n         BAL   R4,WRITELOG\n         B     RDP9000\nRDP0800  EQU   *\n         MVI   RETCODE,X'08'      ;SET THE RETURN CODE AS 8\n         MVI   MSGID,MSG015I\n         BAL   R4,WRITELOG\n         B     RDP9000\nRDP0810  EQU   *\n         MVI   RETCODE,X'08'      ;SET THE RETURN CODE AS 8\n         MVI   MSGID,MSG016I\n         BAL   R4,WRITELOG\n         B     RDP9000\nRDP9000  EQU   *\n         LM    R0,R15,SVLVL1      RESTORE THE SAVED REGISTERS\n         BR    R2\n\n************************************************\n* READ FORMAT WORD OF THE PARAMETER\nRDPFMT00 EQU   *\n         STM   R0,R15,SVLVL2      ;SAVE THE REGISTERS\n         LA    R7,PRMWORD         LOAD THE START OF THE WORD\n         LH    R5,PRMWLEN         LOAD THE LENGTH OF THE WORD\n* TEST IF THE PARM IS 4 BYTES\n         CLI   PRMWLEN+1,X'03'\n         BNE   RDPF1000\n         CLC   0(4,R7),PARMTXT\n         BE    RDPF3000\n         B     RDPF8000\n* TEST IF THE PARM IS 6 BYTES\nRDPF1000 EQU   *\n         CLI   PRMWLEN+1,X'05'\n         BNE   RDPF8000\n         CLC   0(6,R7),PARMQTE\n         BE    RDPF3000\n         CLC   0(6,R7),PARMBIN\n         BE    RDPF4000\n         CLC   0(6,R7),PARMBSE\n         BE    RDPF4000\n         B     RDPF8000\n* SET encoding algorithm: Test: Quoted Printable\nRDPF3000 MVI   DATAFMT,QTEPRT     ;DEFAULT DATA IS QTEPRT\n         MVI   MSGID,MSG004I\n         B     RDPF9000\n* SET encoding algorithm: Binary: BASE 64\nRDPF4000 MVI   DATAFMT,BASE64\n         MVI   MSGID,MSG005I\n         B     RDPF9000\nRDPF8000 MVI   RETCODE,X'08'      ;SET THE RETURN CODE AS 8\n         MVI   MSGID,MSG010I\nRDPF9000 BAL   R4,WRITELOG\n         LM    R0,R15,SVLVL2      RESTORE THE SAVED REGISTERS\n         BR    R3\n*---------------------------------------------------------------------*\n* ROUTINE: PROCFILE\n* DESCRIPTION: PROCESS THE INPUT FILE\n* INPUT:\n*    R2  : RETURN CONTROL\n* RETURN :\n*  INPRECST : THE START OF THE RECORD\n*  INPLRECL : THE LENGTH OF RECORD, THE TRAILING SPACES NOT INCLUDED\n*---------------------------------------------------------------------*\nPROCFILE EQU   *\n         ST    R2,SVLVL1           SAVE R2\n         XR    R2,R2               CLEAR THE RECORD COUNTER\nPRF1000  EQU   *\n         BAL   R3,READREC          READ NEXT RECORD\n         CLI   INPEOF,YES          REACH AT THE END OF INPUT FILE?\n         BE    PRF2000             YES, FINISH TO PROCESS\n         LA    R2,1(,R2)           ADD THE COUNTER\n         CLI   DATAFMT,QTEPRT      TEST THE DATA FORMAT IS TEXT?\n         BE    PRF1500             YES, PROCESS THE TEXT RECORD\n         BAL   R3,PRBASE64         PROCESS THE BINARY RECORD\n         B     PRF1000\nPRF1500  BAL   R3,PRQTEPRT         PROCESS THE TEXT RECORD\n         B     PRF1000\nPRF2000  EQU   *\n* PROCESS THE LAST OUTPUT RECORD\n         CLI   DATAFMT,BASE64      TEST THE DATA FORMAT IS BINARY?\n         BNE   PRF9000             NO, SKIP THE REST RECORD\n         XR    R3,R3               SET R3 AS 0\n         ST    R3,INPLRECL         SET THE RECORD LENGTH AS 0.\n         BAL   R3,PRBASE64         PROCESS THE LAST OUTPUT RECORD\nPRF9000  EQU   *\n         ST    R2,TOLIRCBI         SAVE THE TOTAL RECORD\n         L     R2,SVLVL1           RESTORE R2\n         BR    R2\n*---------------------------------------------------------------------*\n* ROUTINE: PRBASE64\n* DESCRIPTION: PROCESS ONE RECORD OF THE INPUT FILE AS BASE64\n* INPUT:\n*       R3  : RETURN CONTROL\n*  INPRECST : THE START OF THE RECORD\n*  INPLRECL : THE LENGTH OF RECORD\n* RETURN    :  none\n* HOW IT WORKS:\n* ============\n*  BASE64 Concept:\n*\n*  The BASE 64 is to convert the three 8 bit group data (24 bits) into\n*  four 6 bit group displayable data, which is converted on the table\n*  of base 64 alphabet characters as follows:\n*      0 - 25: A-Z\n*     26 - 51: a-z\n*     52 - 61: 0-9\n*     62 - 63: +/\n*  At the end of the file, the input bytes should pad with binary 0\n*  to build the last 3 byte group, and the converted 4 bytes should\n*  be padded with the same number of '='. i.e. If there are 2 binary\n*  zeros padded into 3 byte group (just one byte left in last record),\n*  the third and fourth byte of converted 4 byte group are filled\n*  with '='.\n*\n*  The output record must be 76 bytes long. The last record will\n*  padding with spaces if it less than 76 bytes.\n*\n*  Program Logic:\n*\n*  1. Read next 3 byte from input record into R5.\n*  2. Convert 3 byte group into BASE64 by call sub-rountine CONVERTB,\n*     the 4 byte output is also in R5.\n*  3. Save the converted 4 bytes in R5 into output record.\n*  4. If the output record is full, save the output record.\n*  5. Repeat from step 1 till the end of the record.\n*  6. If there is any byte left (0, 1 or 2), save the bytes in REMBYTES\n*     and the number of bytes in REMCTR.\n*  7. Before process next record, process these 1 or 2 left byte in\n*     in previous record. Read 1 or 2 bytes from next record to\n*     build up first one 3 byte group. Then continue at step 1.\n*  8. When the record length is 0, process the last output record.\n*\n*---------------------------------------------------------------------*\nPRBASE64 EQU   *\n         L     R6,OUTPOS           LOAD CURRENT ADDRESS OF OUTPUT REC\n         L     R7,INPRECST         LOAD THE RECORD START ADDRESS\n         L     R8,INPLRECL         LOAD THE RECORD LENGTH\n         LA    R9,OUTREC           LOAD THE START ADDRESS OF OUTPUT\n         LA    R9,76(,R9)          LOAD THE END OF OUTPUT RECORD\n         LA    R10,3               LOAD THE GROUP BYTE LENGTH\n* TEST IF REQUEST THE LAST OUTPUT RECORD (INPUT LRECL==0)\n         LTR   R8,R8\n         BZ    PRB5000             IF RECLEN==0, THEN PROCESS LAST REC\n* TEST IF ANY BYTE LEFT OF PREVIOUS RECORD\n         CLI   REMCTR,ZERO         IS THERE NO BYTE LEFT?\n         BE    PRB1000             YES, SKIP THE PROCESS THE REST BYTES\n* PROCESS THE REST BYTES IN PREVIOUS RECORD\n         XR    R5,R5\n         CLI   REMCTR,TWO          THE REST BYTES ARE 2?\n         BE    PRB0200             YES, PROCESS THE TWO BYTES\n* PROCESS ONLY ONE BYTE\n         IC    R5,REMBYTES         READ ONLY ONE BYTE\n         SLL   R5,16               SHIFT R5 BY 16 BITS\n         ICM   R5,B'0011',0(R7)    READ 2 NEW BYTES FROM CURRENT INPUT\n         LA    R7,2(,R7)           MOVE CURRENT INPUT LOCATION\n         BCTR  R8,0                DECREASE THE RECORD LENGTH BY 2\n         BCTR  R8,0\n         B     PRB0500\n* PROCESS TWO BYTES\nPRB0200  EQU   *\n         ICM   R5,B'0011',REMBYTES READ TWO BYTES\n         SLL   R5,8                SHIFT R5 BY 16 BITS\n         IC    R5,0(R7)            READ 1 NEW BYTE FROM CURRENT INPUT\n         LA    R7,1(,R7)           MOVE CURRENT INPUT LOCATION\n         BCTR  R8,0                DECREASE THE RECORD LENGTH BY 1\n* PROCESS THE REMAIN 3 BYTE GROUP\nPRB0500  EQU   *\n         BAL   R4,CONVERTB         CONVERT BYTE GROUP INTO BASE64 IN R5\n         STCM  R5,B'1111',0(R6)    SAVE CONVERTED BYTES INTO OUTPUT\n         LA    R6,4(,R6)           MOVE R6 TO NEW OUTPUT LOCATION\n* PROCESS THE INCOMING RECORD\nPRB1000  EQU   *\n         CR    R6,R9               TEST IF OUTPUT RECORD IS FULL\n         BL    PRB1500             NO, CONTINUE TO PROCESS\n         BAL   R4,SAVEREC          SAVE OUTPUT RECORD AND RESET R6\nPRB1500  EQU   *\n         CR    R8,R10              TEST IF LESS 3 BYTES LEFT\n         BL    PRB4000             YES, JUMP OUT OF LOOP\n* PROCESS THIS 3 BYTE GROUP\n         ICM   R5,B'0111',0(R7)    READ NEXT 3 BYTES\n         BAL   R4,CONVERTB         CONVERT BYTE GROUP INTO BASE64 IN R5\n         STCM  R5,B'1111',0(R6)    SAVE CONVERTED BYTES INTO OUTPUT\n         LA    R6,4(,R6)\n         AR    R7,R10              MOVE TO NEXT 3 GROUP BYTES\n         SR    R8,R10              DECREASE THE INPUT LENGTH BY 3\n         B     PRB1000             PROCESS NEXT GROUP\n* PROCESS LAST BYTES IN CURRENT RECORD\nPRB4000  EQU   *\n         ST    R6,OUTPOS           SAVE THE CURRENT OUTPUT POSITION\n         STC   R8,REMCTR           SAVE THE REST BYTE LENGTH\n         LTR   R8,R8               TEST IF ANY LEFT\n         BZ    PRB9000             IF NOT, JUST RETURN\n         MVC   REMBYTES(2),0(R7)   COPY THE MAXIMUM TWO BYTES\n         B     PRB9000             END OF THE RECORD PROCESSING\n* PROCESS THE LAST OUTPUT RECORD\nPRB5000  EQU   *\n         CLI   REMCTR,ZERO         IS NO BYTE LEFT?\n         BE    PRB5500             YES, SKIP THE PROCESS THE REST BYTE\n         XR    R5,R5               CLEAR R5\n         CLI   REMCTR,TWO          THE REST BYTES ARE 2?\n         BE    PRB5200             YES, PROCESS TWO BYTES\n* PROCESS ONLY ONE BYTE\n         IC    R5,REMBYTES         LOAD THE LAST BYTE\n         SLL   R5,16               SHIFT LEFT BY 2 BYTES\n         BAL   R4,CONVERTB         CONVERT BYTE GROUP INTO BASE64 IN R5\n         STCM  R5,B'1111',0(R6)    SAVE CONVERTED BYTES INTO OUTPUT\n         MVI   2(R6),C'='          PAD THE THIRD BYTE W/ =\n         MVI   3(R6),C'='          PAD THE LAST(FOURTH) BYTE W/ =\n         LA    R6,4(,R6)           MOVE R6 TO NEW OUTPUT LOCATION\n         B     PRB5500\n* PROCESS TWO BYTES\nPRB5200  EQU   *\n         ICM   R5,B'0011',REMBYTES\n         SLL   R5,8                SHIFT LEFT BY 1 BYTE\n         BAL   R4,CONVERTB         CONVERT BYTE GROUP INTO BASE64 IN R5\n         STCM  R5,B'1111',0(R6)    SAVE CONVERTED BYTES INTO OUTPUT\n         MVI   3(R6),C'='          PAD THE LAST(FOURTH) BYTE W/ =\n         LA    R6,4(,R6)           MOVE R6 TO NEW OUTPUT LOCATION\n* SAVE THE LAST OUTPUT RECORD\nPRB5500  EQU   *\n         BAL   R4,SAVEREC          SAVE LAST RECORD\nPRB9000  EQU   *\n         BR    R3\n*---------------------------------------------------------------------*\n* ROUTINE: PRQTEPRT\n* DESCRIPTION: PROCESS ONE RECORD OF THE INPUT FILE AS TEXT FORMAT\n* INPUT:\n*       R3  : RETURN CONTROL\n*  INPRECST : THE START OF THE RECORD\n*  INPLRECL : THE LENGTH OF RECORD, THE TRAILING SPACES NOT INCLUDED\n* RETURN    :\n*           :\n* WORK      :\n*   THE PROCESS USE THE EBCDIC TABLE TO LOCATE THE CHARSET, TO GET\n*   BETTER PERFORMANCE. SAVE UP TO 3 TIMES OF PROCESSING TIME COMPARING\n*   TO USING SRST TO SEARCH AGAINST THE CHARSET TABLE.\n*\n*       R4  : WORK\n*       R5  : THE CONTENT OF CURRENT BYTE\n*       R6  : CURRENT POSITION OF OUTREC\n*       R7  : CURRENT POSITION OF INPUT RECORD\n*       R8  : RECORD LENGTH\n*       R9  : THE LAST POSITION FOR NORMAL CHAR\n*       R10 : THE LAST POSITION FOR =HEX  CHAR\n*\n* HOW IT WORKS\n* ============\n*\n*  Quoted Printable Concept\n*\n*  Quoted Printable encoding is for text data. It will test each byte\n*  of input data to test if it is in printable table. If not, it will\n*  be translated into 3 byte group: = and two displayble HEX of the\n*  byte. The displayable HEX is ASCII HEX, not EBCDIC. If it's in the\n*  displayable table, it will not be changed. The table are 65 bytes:\n*  A-Z,a-z,0-9,+/ and space.\n*\n*  The output record must be 76 bytes long. If the record is more\n*  than 76 bytes, the record will be wrapped around, and the last\n*  byte (76th) will be '=' to indicate the record continuation.\n*\n*  If the record, or continuation of record is less than 76 bytes,\n*  it will be padded with spaces.\n*\n*  Program Logic\n*\n*  1. Read next byte of the input record.\n*  2. Test the byte is in displayable table.\n*  3. If yes, just copy the byte from input record to output record\n*     If not, convert the byte (in R5) to displayable ASCII HEX text.\n*     leading with '=', i.e. The charater '*' will translated into\n*     =2A in output record.\n*  4. If the output record is full, save the output record.\n*  5. Repeat the step 1 till the end of the input record.\n*\n*---------------------------------------------------------------------*\nPRQTEPRT EQU *\n         XR    R5,R5               CLEAR CURRENT BYTE\n         LA    R6,OUTREC           LOAD THE ADDRESS OF OUTPUT REC\n         L     R7,INPRECST         LOAD THE RECORD START ADDRESS\n         L     R8,INPLRECL         LOAD THE RECORD LENGTH\n         LA    R9,74(,R6)          SET LAST POSITION FOR CHAR\n         LA    R10,72(,R6)         SET LAST POSITION FOR HEX\nPRQ1000  EQU   *\n         IC    R5,0(R7)            READ NEXT BYTE\n* SEARCH THE CHARSET TABLE TO SEE IF THE BYTE IS IN TABLE\n* PROCESS +/ AND SPACE\n         LA    R4,C' '\n         CR    R5,R4\n         BE    PRQ2000\n         LA    R4,C'+'\n         CR    R5,R4\n         BE    PRQ2000\n         LA    R4,C'/'\n         CR    R5,R4\n         BE    PRQ2000\n* process a-i\n         LA    R4,C'a'\n         CR    R5,R4\n         BL    PRQ3000             IF < a THEN CONVERT IT\n         LA    R4,C'i'             BETWEEN a AND i, COPY IT\n         CR    R5,R4\n         BNH   PRQ2000\n* process j-r\n         LA    R4,C'j'\n         CR    R5,R4\n         BL    PRQ3000             IF < a THEN CONVERT IT\n         LA    R4,C'r'             BETWEEN j AND r, COPY IT\n         CR    R5,R4\n         BNH   PRQ2000\n* process s-z\n         LA    R4,C's'\n         CR    R5,R4\n         BL    PRQ3000             IF < a THEN CONVERT IT\n         LA    R4,C'z'             BETWEEN s AND z, COPY IT\n         CR    R5,R4\n         BNH   PRQ2000\n* process A-I\n         LA    R4,C'A'\n         CR    R5,R4\n         BL    PRQ3000             IF < a THEN CONVERT IT\n         LA    R4,C'I'             BETWEEN A AND I, COPY IT\n         CR    R5,R4\n         BNH   PRQ2000\n* process J-R\n         LA    R4,C'J'\n         CR    R5,R4\n         BL    PRQ3000             IF < J THEN CONVERT IT\n         LA    R4,C'R'             BETWEEN J AND R, COPY IT\n         CR    R5,R4\n         BNH   PRQ2000\n* process S-Z\n         LA    R4,C'S'\n         CR    R5,R4\n         BL    PRQ3000             IF < S THEN CONVERT IT\n         LA    R4,C'Z'             BETWEEN S AND Z, COPY IT\n         CR    R5,R4\n         BNH   PRQ2000\n* process 0-9\n         LA    R4,C'0'\n         CR    R5,R4\n         BL    PRQ3000             IF < 0 THEN CONVERT IT\n         LA    R4,C'9'             BETWEEN 0 AND 9, COPY IT\n         CR    R5,R4\n         BH    PRQ3000             For >9, CONVERT IT\n* CHAR IS FOUND IN CHARSET\nPRQ2000  EQU   *\n         CR    R6,R9               IS AT THE LAST OF OUTPUT RECORD?\n         BL    PRQ2500             NO, CONTINUE TO PROCESS\n         MVI   0(R6),C'='          SET RECORD CONTINUATION CHAR =\n         LA    R6,1(,R6)           MOVE TO NEXT BYTE OF OUTPUT REC\n         BAL   R4,SAVEREC          SAVE THE CURRENT OUTPUT RECORD\nPRQ2500  EQU   *\n         STC   R5,0(R6)            SAVE THE CURRENT BYTE\n         LA    R6,1(,R6)           MOVE THE CURRENT OUTPUT POSITION\n         B     PRQ4000             CONTINUE NEXT BYTE\n* CHAR IS NOT FOUND IN CHARSET\nPRQ3000  EQU   *\n         CR    R6,R10              IS AT THE LAST OF OUTPUT RECORD?\n         BL    PRQ3200             NO, CONTINUE TO PROCESS\n         MVI   0(R6),C'='          SET RECORD CONTINUATION CHAR =\n         LA    R6,1(,R6)           MOVE TO NEXT BYTE OF OUTPUT REC\n         BAL   R4,SAVEREC          SAVE THE CURRENT OUTPUT RECORD\n* CONVERT THE CURRENT BYTE TO DISPLAYABLE HEX TEXT.\nPRQ3200  EQU   *\n         MVI   0(R6),C'='          SAVE HEX = LEADING CHAR\n         BAL   R4,CONVERTX         CALL CONVERT HEX TO TEXT IN R5\n         STCM  R5,B'0011',1(R6)    SAVE THE TWO BYTES TO OUTREC\n         XR    R5,R5               CLEAR R5\n         LA    R6,3(,R6)           MOVE THE CURRENT OUTPUT POSITION\n* CONTINUE TO PROCESS NEXT BYTE\nPRQ4000  EQU   *\n         LA    R7,1(,R7)           MOVE TO NEXT BYTE\n         BCT   R8,PRQ1000          PROCESS NEXT BYTE\n         BAL   R4,SAVEREC          SAVE THE LAST OUTPUT RECORD\n         BR    R3\n*---------------------------------------------------------------------*\n* ROUTINE: SAVEREC\n* DESCRIPTION: SAVE ONE RECORD OF THE OUTPUT FILE\n* INPUT:\n*       R4  : RETURN CONTROL\n*       R6  : THE LAST POSITION OF OUTPUT RECORD\n*   OUTREC  : THE OUTPUT RECORD\n* RETURN :\n*       R6  : THE START ADDRESS OF OUTPUT RECORD\n* WORK:\n*       R14 : THE COPY OF R5\n*       R15 : THE COPY OF R7\n*---------------------------------------------------------------------*\nSAVEREC  EQU   *\n* FILL THE TRAILING BYTES WITH SPACES\n         STM   R5,R7,SVLVL2        SAVE R5 TO R7\n         LA    R5,OUTREC           LOAD THE OUTPUT ADDRESS\n         CR    R6,R5               IS THE CURRRENT POSITION AT START\n         BE    SVR9000             YES, SKIP TO SAVE THE RECORD\n         LA    R5,76(,R5)          MOVE TO THE END OF THE RECORD\n         CR    R6,R5               IS THE CURRRENT POSITION AT THE END?\n         BE    SVR4000             YES, JUST PROCESS SAVE RECORD\n         MVI   0(R6),C' '          SAVE CURRENT BYTE AS SPACE\n         BCTR  R5,0\n         CR    R6,R5               IS THE RECORD THE LAST BUT ONE?\n         BH    SVR4000             YES, JUST SAVE THE RECORD\n         LA    R7,0(,R6)           LOAD COPY FROM IN R7\n         LA    R6,1(,R6)           LOAD COPY TO   IN R6\n         LA    R5,2(,R5)           INCREASE R5 BY 2\n         SR    R5,R6               LOAD THE COPY LENGTH IN R5\n         EX    R5,MVCREC           COPY THE SPACES\n* SAVE THE CURRENT OUTPUT RECORD\nSVR4000  EQU   *\n         PUT   OUTDCB,OUTREC       SAVE THE CURRENT OUTPUT RECORD\n         L     R5,TOLORCBI\n         LA    R5,1(,R5)\n         ST    R5,TOLORCBI\nSVR9000  EQU   *\n         LM    R5,R7,SVLVL2        SAVE R5 TO R7\n         LA    R6,OUTREC           UPDATE R6 WITH START ADDRESS OF OUT\n         BR    R4\n*---------------------------------------------------------------------*\n* ROUTINE: READREC\n* DESCRIPTION: READ ONE RECORD FROM INPUT FILE\n* INPUT:\n*    R3  : RETURN CONTROL\n* RETURN :\n*  INPRECST : THE START OF THE RECORD\n*  INPLRECL : THE LENGTH OF RECORD, THE TRAILING SPACES NOT INCLUDED\n*---------------------------------------------------------------------*\nREADREC  EQU    *\n         LA    R4,INPDCB\n         USING IHADCB,R4\n         L     R7,INBUFADR         LOAD THE INPUT RECORD BUFFER\n         GET   INPDCB,((R7))       GET NEXT RECORD INTO BUFFER\n* PROCESSING RECORD FORMATS\n         XR    R5,R5               CLEAR R5\n         CLI   INPRECFM,C'V'       THE RECORD FORMAT IS VARIABLE?\n         BE    RDR1200             PROCESS VARIABLE LENGTH\n* PROCESSING FIXED LENGTH AND UNDEFINED LENGTH\n         ICM   R5,B'0011',DCBLRECL LOAD THE RECORD LENGTH FROM DCBLRECL\n         B     RDR2000\n* PROCESSING VARIABLE LENGTH\nRDR1200  EQU   *\n         ICM   R5,B'0011',0(R7)    LOAD THE RECORD LENGTH FROM RDW\n         LA    R6,4                SET THE RDW LENGTH\n         SR    R5,R6               SUBTRACT R5 BY 4 TO SKIP THE RDW\n         AR    R7,R6               SKIP THE RDW\nRDR2000  EQU   *\n         ST    R7,INPRECST         UPDATE THE RECORD START ADDRESS\n         CLI   DATAFMT,QTEPRT      IS THE DATA TEXT FORMAT\n         BNE   RDR2200             NO, SKIP TO TRUNCATE THE SPACES\n* TRUNCATE THE TRAILING SPACES\n         AR    R7,R5               MOVE R7 TO THE END OF THE RECORD\n         BCTR  R7,0\nRDR2100  EQU   *\n         BCTR  R7,0\n         CLI   0(R7),C' '          COMPARE BYTE WITH SPACE\n         BNE   RDR2200             NON-SPACE, OUT OF LOOP\n         BCT   R5,RDR2100          TEST NEXT BYTE TILL THE LENGTH IS 0\n         LA    R5,1                AT LEAST ONE SPACE FOR SPACE LINE\nRDR2200  EQU   *\n         ST    R5,INPLRECL         SAVE THE RECORD LENGTH\n         B     RDR9000\nEODADRTN EQU   *                   INDICATE END-OF-FILE\n         MVI   INPEOF,YES\nRDR9000  EQU   *\n         DROP  R4\n         BR    R3\n*---------------------------------------------------------------------*\n* ROUTINE: OPENFILE\n* DESCRIPTION: OPEN THE FILES\n* INPUT:\n*    R2  : RETURN CONTROL\n* RETURN :\n*---------------------------------------------------------------------*\nOPENFILE EQU   *\n* OPEN INPUT DCB\n         OPEN  (INPDCB,(INPUT)),MODE=31,MF=(E,INPOPNLF)\n         LTR   R15,R15              OPEN SUCCESS?\n         BNZ   OPN8000              NO, JUMP TO ERROR PROCESSING\n         MVI   INPOPNFL,YES         SET OPEN FLAG TO YES\n         MVI   INPEOF,NO            SET EOF FLAG TO NO\n* OPEN OUTPUT DCB\n         OPEN  (OUTDCB,(OUTPUT)),MODE=31,MF=(E,OUTOPNLF)\n         LTR   R15,R15              OPEN SUCCESS?\n         BNZ   OPN8100              NO, JUMP TO ERROR PROCESSING\n         MVI   OUTOPNFL,YES         SET OPEN FLAG TO YES\n* READ INPUT FILE INFORMATION\n         LA    R4,INPDCB              LOAD DCB ADDRESS\n         USING IHADCB,R4              ADDRESSABILITY OF INPUT DCB\n         XR    R5,R5\n* READ RECORD BLOCK SIZE\n         ICM   R5,B'0011',DCBBLKSI    COPY THE RECORD LENGTH\n         ST    R5,INPBLKSI            CLEAR INPLRECL\n* READ RECORD LENGTH\n         ICM   R5,B'0011',DCBLRECL    COPY THE RECORD LENGTH\n         ST    R5,INPLRECL            CLEAR INPLRECL\n* READ RECORD FORMAT\n         LA    R7,RECFMTBL\nOPN2000  EQU   *\n         CLC   DCBRECFM(1),4(R7)      COMPARE THE RECORD FORMAT\n         BE    OPN2200\n         LA    R7,5(,R7)              MOVE TO NEXT RECORD\n         CLI   0(R7),X'FF'\n         BNE   OPN2000\n         B     OPN8300\n         DROP  R4\nOPN2200  EQU   *\n         MVC   INPRECFM(4),0(R7)      COPY THE RECORD FORMAT\n* ALLOCATE THE INPUT RECORD BUFFER\n         LTR   R5,R5                  TEST IF RECORD LENGTH IS 0\n         BNZ   OPN2500\n         L     R5,INPBLKSI            LOAD BLOCK SIZE AS RECORD LENGTH\nOPN2500  EQU   *\n         GETMAIN R,LV=(R5)            GET THE STORAGE\n         LTR   R15,R15                TEST THE ALLOCATION CODE\n         BNZ   OPN8300                FAILED, PROCESS ERROR MESSAGES\n         ST    R1,INBUFADR            SAVE THE STORAGE ADDRESS\n         ST    R5,INBUFLEN            SAVE THE STORAGE LENGTH\n         B     OPN9000\n* INPUT DD IS MISSING\nOPN8000  EQU   *\n         STC   R15,RETCODE\n         MVI   MSGID,MSG006I\n         BAL   R4,WRITELOG\n         MVC   MSGBUFTX(31),=CL31'EME027I Make sure the input DD '\n         MVC   MSGBUFTX+31(8),INDDNAME\n         MVC   MSGBUFTX+39(15),=CL15' is allocated.'\n         MVC   MSGBUFTX+54(1),RETCODE\n         MVI   MSGBUFLN,56\n         MVI   MSGID,MSGCUST\n         BAL   R4,WRITELOG\n         B     OPN8900\n* OUTPUT DD IS MISSING\nOPN8100  EQU   *\n         STC   R15,RETCODE\n         MVI   MSGID,MSG007I\n         BAL   R4,WRITELOG\n         MVC   MSGBUFTX(32),=CL32'EME029I Make sure the output DD '\n         MVC   MSGBUFTX+32(8),OUDDNAME\n         MVC   MSGBUFTX+40(15),=CL15' is allocated.'\n         MVI   MSGBUFLN,55\n         MVI   MSGID,MSGCUST\n         BAL   R4,WRITELOG\n         B     OPN8900\n* SYSPRINT DD IS MISSING\nOPN8200  EQU   *\n         MVI   MSGID,MSG008I\n         BAL   R4,WRITELOG\n         B     OPN8900\n* INPUT RECORD BUFFER ALLCOATION FAILED.\nOPN8300  EQU   *\n         MVI   MSGID,MSG009I\n         BAL   R4,WRITELOG\nOPN8900  EQU   *\n         MVI   RETCODE,X'08'        SET THE RETURN CODE 10\nOPN9000  EQU   *\n         BR    R2\n*---------------------------------------------------------------------*\n* ROUTINE: CLOSFILE\n* DESCRIPTION: CLOSE THE FILES\n* INPUT:\n*    R2  : RETURN CONTROL\n* RETURN :\n*---------------------------------------------------------------------*\nCLOSFILE EQU  *\n* CLOSE INPUT DCB IF IT'S OPENED.\n         CLI   INPOPNFL,YES\n         BNE   CLS1000\n         CLOSE INPDCB,MODE=31,MF=(E,INPCLSLF)\nCLS1000  EQU   *\n* CLOSE OUTPUT DCB IF IT'S OPENED.\n         CLI   OUTOPNFL,YES\n         BNE   CLS2000\n         CLOSE OUTDCB,MODE=31,MF=(E,OUTCLSLF)\nCLS2000  EQU   *\n* CLOSE SYSPRINT DCB IF IT'S OPENED.\n         CLI   SPROPNFL,YES\n         BNE   CLS3000\n         CLOSE SPRDCB,MODE=31,MF=(E,SPRCLSLF)\nCLS3000  EQU   *\n* UNALLOCATE INPUT RECORD BUFFER IF IT'S ALLOCATED.\n         L     R4,INBUFADR\n         LTR   R4,R4\n         BZ    CLS4000\n         L     R5,INBUFLEN\n         FREEMAIN R,LV=(R5),A=(R4)\nCLS4000  EQU   *\n         BR    R2\n*======================================================================\n*---------------------------------------------------------------------*\n* ROUTINE: CONVERTX\n* DESCRIPTION: CONVERT ONE BYTE INTO ASCII, THEN DISPLAYABLE HEX TEXT.\n* INPUT:\n*    R4   : RETURN CONTROL\n*    R5   : THE BYTE TO BE CONVERTED (BIT 24-31)\n* RETURN\n*    R5   : THE LOWER 16 BITS ARE THE CONVERTED HEX TEXT\n* WORK\n*    R14  : THE HIGHER HALF BYTE OF R5\n*    R15  : THE LOWER  HALF BYTE OF R5\n*---------------------------------------------------------------------*\nCONVERTX EQU   *                       *\n* CONVERT R5 FROM EBCDIC TO ASCII IN R15\n         XR    R15,R15               CLEAR R15\n         IC    R15,E2ATAB(R5)        CONVERT R5 INTO ASCII TO R15\n* SPLTE THE BYTE INTO R14 AND R15\n         XR    R14,R14               CLEAR R14\n         SLDL  R14,28                SHIFT R14,R15 LEFT 28 BITS\n         SRL   R15,28                SHIFT R15 RIGHT 28 BITS BACK\n* NOW, HIGHER HALF BYTE IN R14, LOWER HALF BYTE IN R15\n         IC    R5,HEXTABLE(R14)      HIGHER HALF BYTE IN R14-> R5\n         SLL   R5,8                  SHIFT CONVERTED BYTE LEFT\n         IC    R5,HEXTABLE(R15)      LOWER  HALF BYTE IN R15-> R5\n* THE CONVERTED TWO BYTES IS IN LOWER 16 BITS OF R5\n         BR    R4\n*======================================================================\n*---------------------------------------------------------------------*\n* ROUTINE: CONVERTB\n* DESCRIPTION: CONVERT 3 BYTES INTO 4 BYTES IN BASE64\n* INPUT:\n*    R4   : RETURN CONTROL\n*    R5   : THE 3 BYTES TO BE CONVERTED (BIT 08-31)\n* RETURN\n*    R5   : THE CONVERTED 4 BYTES IN BASE64\n* WORK    :\n*    R1   : LOOP COUNTER FOR 4 TIMES IN REGISTER\n*    R14  : THE CURRENT 6 BITS TO BE PROCESSED, SHIFT 6 BITS FROM R15\n*    R15  : THE BYTES LEFT AFTER SHIFTED TO R14\n*---------------------------------------------------------------------*\nCONVERTB EQU   *                       *\n         LR    R15,R5                COPY R5 TO R15\n         SLL   R15,8                 SHIFT R15 ONE BYTE LEFT\n         LA    R1,4                  LOAD COUNTER\n* PROCESS 6 BITS A TIME, TOTAL 4 TIMES.\nCVB1000  EQU   *\n         XR    R14,R14               CLEAR R14\n         SLDL  R14,6                 SHIFT R14,R15 LEFT 6 BITS\n         SLL   R5,8                  SHIFT R5 BY 1 BYTE (8 BITS)\n         IC    R5,BASE64TB(R14)      SAVE CODE (6->8 BITS) IN R5\n         BCT   R1,CVB1000            PROCESS NEXT 6 BITS\n* CONVERTED 4 BYTES IS IN R5, USING STM TO GET THEM.\n         BR    R4\n*======================================================================\n*---------------------------------------------------------------------*\n* ROUTINE: SHOWINFO\n* DESCRIPTION: SHOW STATISTICS INFORMATION\n* INPUT:\n*    R2  : RETURN CONTROL\n* RETURN :\n*---------------------------------------------------------------------*\nSHOWINFO EQU   *\n* TEST THE RETURN CODES FOR LAST MESSAGE\n         CLI RETCODE,ZERO\n         BNE SIF2000\n* SHOW THE STATISTICS FOR INPUT RECORDS\n         LA  R9,TOLIRCBI\n         LA  R10,MSG013\n         BAL R3,SHOWRECS\n* SHOW THE STATISTICS FOR OUTPUT RECORDS\n         LA  R9,TOLORCBI\n         LA  R10,MSG014\n         BAL R3,SHOWRECS\n* STOP NORMALLY\n         MVI MSGID,MSG011I\n         B   SIF9000\n* STOP WITH WARN MESSAGE\nSIF2000  EQU   *\n         MVI MSGID,MSG012I\nSIF9000  BAL R4,WRITELOG\n         BR  R2\n*---------------------------------------------------------------------*\n* ROUTINE: SHOWRECS\n* DESCRIPTION: SHOW STATISTICS INFORMATION FOR ONE TYPE OF RECORD\n* INPUT:\n*    R3  : RETURN CONTROL\n*    R9  : THE FULL WORD ADDRESS OF TOTAL NUMBER OF RECORDS.\n*    R10 : THE MESSAGE ADDRESS TO BE SHOWN BEFORE THE NUMBER.\n* RETURN :\n*---------------------------------------------------------------------*\nSHOWRECS EQU   *\n*  COPY THE LEADING MESSAGE.\n         LH  R5,0(R10)               LOAD THE MESSAGE LENGTH\n         LA  R7,2(,R10)              LOAD THE ADDRESS OF MESSAGE\n         LA  R6,MSGBUFTX             LOAD THE TARGET STORAGE\n         BCTR R5,0\n         EX  R5,MVCREC               COPY THE LEADING MESSAGES\n         AR  R6,R5                   MOVE R6 TO THE END OF MESSAGE\n         LA  R6,1(,R6)\n* CONVERT THE RECORD NUMBERS INTO PACKED NUMBER\n         L   R5,0(R9)               LOAD THE RECORD NUMBER\n         CVD R5,TOLRECPK            CONVERT BIN-TO-DECIMAL\n* SET THE EDIT PATTERN 4020...202120\n         MVI TOLRECNM,X'40'\n         MVI TOLRECNM+1,X'20'\n         MVC TOLRECNM+2(14),TOLRECNM+1     INITIAL STORAGE WITH X'20'\n         MVI TOLRECNM+14,X'21'             SET SIGNIFICANT BYTE\n         ED  TOLRECNM(16),TOLRECPK         EDIT THE LAST 5 BYTES\n* REMOVE LEADING SPACES\n         LA  R7,TOLRECNM\n         LA  R5,16\nSRC1000  EQU *\n         CLI 0(R7),C' '\n         BNE SRC1500\n         LA  R7,1(,R7)\n         BCT R5,SRC1000\n         BCTR R7,0\n         MVI 0(R7),C'0'\n* SHOW THE STATISTICS MESSAGE\nSRC1500  EQU *\n         LA  R5,TOLRECNM+16\n         SR  R5,R7\n         EX  R5,MVCREC                     COPY THE NUMBER\n         AR  R6,R5\n         MVI 0(R6),C'.'                    SET THE LAST BYTE AS PERIOD\n         LA  R6,1(,R6)\n         LA  R5,MSGBUFTX                   SAVE THE MESSAGE LENGTH\n         SR  R6,R5\n         STC R6,MSGBUFLN\n         MVI MSGID,MSGCUST\n         BAL R4,WRITELOG                   SHOW THE FINAL MESSAGE\n         BR R3\n*======================================================================\n*---------------------------------------------------------------------*\n* ROUTINE: WRITELOG\n* DESCRIPTION: WRITE LOG TO SYSPRINT DD\n* INPUT:\n*    R4  : RETURN CONTROL\n*  MSDID : MESSAGE ID TO BE DISPLAYED\n*        : FOR MSGCUST, DISPLAY CUSTOMIZED MESSAGES.\n* RETURN\n*---------------------------------------------------------------------*\nWRITELOG EQU   *\n         CLI  SPROPNFL,YES       IS THE SYSPRINT PROVIDED?\n         BNE  WTL9900            NO, JUST SKIP THE LOG\n         STM  R5,R7,SVLVL3       SAVE R5-R7 REGISTERS\n         CLI  MSGID,MSGCUST      MESSAGE IS PROVIDED IN MESSAGE BUFFER?\n         BE   WTL4000\n* SEARCH MESSAGE INDEX FOR GIVEN MESSAGE ID IN MSGID\n         XR   R6,R6              CLEAR R6\n         XR   R7,R7              CLEAR R7\n         LA   R5,MSGIDX          LOAD THE START OF THE TABLE\n         IC   R6,MSGID           LOAD THE GIVEN MESSAGE ID\nWTL1000  EQU   *\n         IC   R7,0(R5)           LOAD THE CURRENT MESSAGE ID\n         CR   R6,R7              COMPARE THIS ONE TO THE GIVEN ONE.\n         BE   WTL2000\n         CLI  0(R5),MSGIXEND     GET THE END OF THE TABLE?\n         BE   WTL9000            YES, THE GIVEN MSGID IS NOT FOUND\n         LA   R5,5(,R5)          MOVE TO NEXT INDEX RECORD\n         B    WTL1000            TEST NEXT MESSAGE\n* PROCESS MESSAGE ID\nWTL2000  EQU   *\n         L    R7,1(R5)           LOAD THE MESSAGE ADDRESS\n         LH   R5,0(R7)           LOAD THE MESSAGE LENGTH\n         LA   R7,2(,R7)          LOAD THE MESSAGE BODY POSITION\n         STC  R5,MSGBUFLN        SAVE THE MESSAGE LENGTH TO MSGBUFLN\n         BCTR R5,0\n         LA   R6,MSGBUFTX        COPY TO MESSAGE BUFFER\n         EX   R5,MVCREC          COPY MESSAGE TO SYSPRINT MSG BUFFER\n* PROCESS MESSAGES IN MSGBUF BUFFER.\nWTL4000 EQU   *\n* CLEAN ALL REST OF BUFFER WITH SPACES\n         XR   R6,R6\n         IC   R6,MSGBUFLN        LOAD MESSAGE BUFFER LENGTH\n         LA   R7,MSGBUFTX        LOAD THE MESSAGE ADDRESS\n         AR   R7,R6              MOVE TO THE END OF MESSAGE\n         MVI  0(R7),C' '         SET BYTE AFTER LAST AS SPACE\n         LA   R5,130             MAXIMUM RECORD LENGTH\n         SR   R5,R6              GET THE REST RECORD LENGTH\n         LA   R6,1(,R7)          MOVE TO NEXT BYTE\n         EX   R5,MVCREC          CLEAN REST BUFFER WITH SPACES.\n* MESSAGE PAGE BREAK PROCESSING\n         CP   MSGCTR,P0          PAGE BREAKER?\n         BE   WTL4100\n         CP   MSGCTR,P50         PAGE BREAKER?\n         BNE  WTL4200\n         ZAP  MSGCTR,P0          RESET THE COUNTER\n* PAGE BREAK\nWTL4100 MVI   MSGBUFCC,C'1'      SET CC BYTE TO SPACE\n         B    WTL4300\n* NORMAL LINES\nWTL4200  MVI  MSGBUFCC,C' '\nWTL4300  AP   MSGCTR,P1\n         PUT  SPRDCB,MSGBUF      WRITE THE MESSAGE TO SYSPRINT\nWTL9000  EQU  *\n         LM   R5,R7,SVLVL3       RESTORE R5-R7 REGISTERS\nWTL9900  BR   R4\n***********************************************************************\n*    THIS ROUTINE IS EXECUTED WHEN AN UNRECOVERABLE I/O ERROR HAS     *\n*    BEEN ENCOUNTERED DURING AN I/O REQUEST TO A QSAM FILE. THE ERROR *\n*    FLAG IS SET, AND DESCRIPTIVE ERROR MESSAGE RETURNED TO THE CALLER*\n***********************************************************************\nSYNADRTN SYNADAF ACSMETH=QSAM,         SYNAD ERROR ANALYSIS FUNCTION   X\n               PARM1=(1),              QSAM STATUS INDICATORS          X\n               PARM2=(0)               QSAM DCB\n         SYNADRLS                      RELEASE SYNADAF BUFFERS\n         B     RETURN                  RETURN TO CALLER\n*---------------------------------------------------------------------*\n*  DATA  AREAS                                                        *\n*---------------------------------------------------------------------*\nMVCREC   MVC   0(0,R6),0(R7)      ;COPY RECORD FROM R7 to R6,length R5\nYES      EQU   X'01'\nNO       EQU   X'00'\nZERO     EQU   X'00'              ZERO IN HEX BINARY\nTWO      EQU   X'02'              TWO IN HEX BINARY\n* VALID EXEC PARMS\nPARMTXT  DC    CL4'TEXT'          TEXT FOR QUOTED PRINTABLE\nPARMBIN  DC    CL6'BINARY'        BINARY FOR BASE 64\nPARMQTE  DC    CL6'QTEPRT'        QTEPRT FOR QUOTED PRINTABLE\nPARMBSE  DC    CL6'BASE64'        BASE64 FOR BASE 64\nDEFTINDD DC    CL8'INPUT'         DEFAULT INPUT DD NAME\nDEFTOUDD DC    CL8'OUTPUT'        DEFAULT OUTPUT DD NAME\n* RECORD FORMAT TABLE\nRECFMTBL DS    0C                 RECFM TABLE\n         DC    CL4'F   ',XL1'80'\n         DC    CL4'FA  ',XL1'84'\n         DC    CL4'FM  ',XL1'82'\n         DC    CL4'FB  ',XL1'90'\n         DC    CL4'FBA ',XL1'94'\n         DC    CL4'FBM ',XL1'92'\n         DC    CL4'FBS ',XL1'98'\n         DC    CL4'FBSA',XL1'9C'\n         DC    CL4'FBSM',XL1'9A'\n         DC    CL4'V   ',XL1'40'\n         DC    CL4'VA  ',XL1'44'\n         DC    CL4'VM  ',XL1'42'\n         DC    CL4'VB  ',XL1'50'\n         DC    CL4'VBA ',XL1'54'\n         DC    CL4'VBM ',XL1'52'\n         DC    CL4'VBS ',XL1'58'\n         DC    CL4'VBSA',XL1'5C'\n         DC    CL4'VBSM',XL1'5A'\n         DC    CL4'U   ',XL1'C0'\n         DC    CL4'    ',XL1'00'\n         DC    5X'00'\n*---------------------------------------------------------------------*\n*EBCDIC-to-ASCII table for Canadian Bilingual CECP Code Page 037\n*             000102030405060708090A0B0C0D0E0F\nE2ATAB   DS 0CL256\n         DC X'00010203DC09C37FCAB2D50B0C0D0E0F' ;00;\n         DC X'10111213DBDA08C11819C8F21C1D1E1F' ;10;\n         DC X'C4B3C0D9BF0A171BB4C2C5B0B1050607' ;20;\n         DC X'CDBA16BCBBC9CC04B9CBCEDF1415FE1A' ;30;\n         DC X'20FF838485A0C68687A4BD2E3C282B7C' ;40;\n         DC X'268288898AA18C8B8DE121242A293BAA' ;50;\n         DC X'2D2FB68EB7B5C78F80A5DD2C255F3E3F' ;60;\n         DC X'9B90D2D3D4D6D7D8DE603A2340273D22' ;70;\n         DC X'9D616263646566676869AEAFD0ECE7F1' ;80;\n         DC X'F86A6B6C6D6E6F707172A6A791F792CF' ;90;\n         DC X'E67E737475767778797AADA8D1EDE8A9' ;A0;\n         DC X'5E9CBEFAB8F5F4ACABF35B5DEEF9EF9E' ;B0;\n         DC X'7B414243444546474849F0939495A2E4' ;C0;\n         DC X'7D4A4B4C4D4E4F505152FB968197A398' ;D0;\n         DC X'5CF6535455565758595AFDE299E3E0E5' ;E0;\n         DC X'30313233343536373839FCEA9AEBE99F' ;F0;\n**HEX TABLE FOR UNPACK THE BINARY TO TEXT\nHEXTABLE DC CL16'0123456789ABCDEF'\n**BASE64 TRANSLATION TABLE\nBASE64TB DC C'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n         DC C'0123456789+/'\n*---------------------------------------------------------------------*\n* CINPDCB CONSTANT DCB/DCBE/OPENLIST\n*---------------------------------------------------------------------*\nCINPDCB  DCB   DSORG=PS,                                               X\n               MACRF=GM,                                               X\n               DCBE=CINPDCBE\nCINPDCBL EQU   *-CINPDCB               LENGTH OF THE OPENLIST\nCINPDCBE DCBE  RMODE31=BUFF,                                           X\n               SYNAD=SYNADRTN,         SYNAD ROUTINE ADDRESS           X\n               EODAD=EODADRTN          END OF FILE ADDRESS\nCINPOPL  OPEN  (CINPDCB,(INPUT)),MODE=31,MF=L\nCINPOPLL EQU   *-CINPOPL               LENGTH OF THE OPENLIST\nCINPCLS  CLOSE CINPDCB,MODE=31,MF=L\nCINPCLSL EQU   *-CINPCLS               LENGTH OF THE CLOSE LIST FORM\n* COUTPUT: CONSTANT DCB FOR OUTPUT DCB\nCOUTDCB  DCB   DSORG=PS,                                               X\n               MACRF=PM,                                               X\n               RECFM=FB,                                               X\n               LRECL=76,                                               X\n               DCBE=COUTDCBE\nCOUTDCBL EQU   *-COUTDCB               LENGTH OF THE OPENLIST\nCOUTDCBE DCBE  RMODE31=BUFF\nCOUTOPL  OPEN  (COUTDCB,(OUTPUT)),MODE=31,MF=L\nCOUTOPLL EQU   *-COUTOPL               LENGTH OF THE OPENLIST\nCOUTCLS  CLOSE COUTDCB,MODE=31,MF=L\nCOUTCLSL EQU   *-COUTCLS               LENGTH OF THE CLOSE LIST FORM\n* CSPRDCB: CONSTANT DCB FOR SYSPRINT WITH WRITE\nCSPRDCB  DCB   DSORG=PS,                                               X\n               MACRF=PM,                                               X\n               DDNAME=SYSPRINT,                                        X\n               RECFM=FBA,                                              X\n               LRECL=133,                                              X\n               DCBE=CSPRDCBE\nCSPRDCBL EQU   *-CSPRDCB               LENGTH OF THE OPENLIST\nCSPRDCBE DCBE  RMODE31=BUFF\nCSPROPL  OPEN  (CSPRDCB,(OUTPUT)),MODE=31,MF=L\nCSPROPLL EQU   *-CSPROPL               LENGTH OF THE OPENLIST\nCSPRCLS  CLOSE CSPRDCB,MODE=31,MF=L\nCSPRCLSL EQU   *-CSPRCLS               LENGTH OF THE CLOSE LIST FORM\n*************************************************************\n* PACKED DECIMAL CONSTANTS FOR MESSAGE PROCESSING\nP50      DC    PL2'50'       PAGE BREAKER LINES\nP1       DC    PL1'1'\nP0       DC    PL1'0'\n* MESSAGE INDEX TABLE\nMSGIDX   DS    0C\n*              MSGID    MESSAGE TEXT LOCATION\n*              ======== =======================\n         DC    AL1(MSG001I),AL4(MSG001)        01\n         DC    AL1(MSG002I),AL4(MSG002)        02\n         DC    AL1(MSG003I),AL4(MSG003)        03\n         DC    AL1(MSG004I),AL4(MSG004)        04\n         DC    AL1(MSG005I),AL4(MSG005)        05\n         DC    AL1(MSG006I),AL4(MSG006)        06\n         DC    AL1(MSG007I),AL4(MSG007)        07\n         DC    AL1(MSG008I),AL4(MSG008)        08\n         DC    AL1(MSG009I),AL4(MSG009)        09\n         DC    AL1(MSG010I),AL4(MSG010)        0A\n         DC    AL1(MSG011I),AL4(MSG011)        0B\n         DC    AL1(MSG012I),AL4(MSG012)        0C\n         DC    AL1(MSG013I),AL4(MSG013)        0D\n         DC    AL1(MSG014I),AL4(MSG014)        0E\n         DC    AL1(MSG015I),AL4(MSG015)        0F\n         DC    AL1(MSG016I),AL4(MSG016)        10\n         DC    AL1(MSGIXEND),AL4(0)            END OF TABLE\n* END OF MESSAGE INDEX TABLE\n***********************************************************\n* MESSAGE BODY TABLE\nMSG001   DC  AL2(MSG001L)\nMSG001T  DC  C'EME001I Welcome to Email Attachment Encoding Program.'\nMSG001L  EQU *-MSG001T\nMSG001I  EQU X'01'\n*\nMSG002   DC  AL2(MSG002L)\nMSG002T  DC  C'EME002I Design: Hunter Zhou, zhough2000@yahoo.com.    '\nMSG002L  EQU *-MSG002T\nMSG002I  EQU X'02'\n*\nMSG003   DC  AL2(MSG003L)\nMSG003T  DC  C'EME003I Purpose: Encode Sequential file for TCP/IP '\n         DC  C'SMTP Email attachment.'\nMSG003L  EQU *-MSG003T\nMSG003I  EQU X'03'\n*\nMSG004   DC  AL2(MSG004L)\nMSG004T  DC  C'EME005I Encoding input file using Quoted Printable '\n         DC  C'algorithm.'\nMSG004L  EQU *-MSG004T\nMSG004I  EQU X'04'\n*\nMSG005   DC  AL2(MSG005L)\nMSG005T  DC  C'EME004I Encoding input file using BASE 64 algorithm.'\nMSG005L  EQU *-MSG005T\nMSG005I  EQU X'05'\n*\nMSG006   DC  AL2(MSG006L)\nMSG006T  DC  C'EME010E There is a problem while opening input file.'\nMSG006L  EQU *-MSG006T\nMSG006I  EQU X'06'\n*\nMSG007   DC  AL2(MSG007L)\nMSG007T  DC  C'EME011E There is a problem while opening output file.'\nMSG007L  EQU *-MSG007T\nMSG007I  EQU X'07'\n*\nMSG008   DC  AL2(MSG008L)\nMSG008T  DC  C'EME012E There is a problem while opening SYSPRINT file.'\nMSG008L  EQU *-MSG008T\nMSG008I  EQU X'08'\n*\nMSG009   DC  AL2(MSG009L)\nMSG009T  DC  C'EME013E There is a problem while reading input file.'\nMSG009L  EQU *-MSG009T\nMSG009I  EQU X'09'\n*\nMSG010   DC  AL2(MSG010L)\nMSG010T  DC  C'EME020E ERROR: The PARM is invalid, it must be '\n         DC  C'TEXT, BINARY, QTEPRD or BASE64!'\nMSG010L  EQU *-MSG010T\nMSG010I  EQU X'0A'\n*\nMSG011   DC  AL2(MSG011L)\nMSG011T  DC  C'EME030I The EMAILENC program finished normally.'\nMSG011L  EQU *-MSG011T\nMSG011I  EQU X'0B'\n*\nMSG012   DC  AL2(MSG012L)\nMSG012T  DC  C'EME031W The EMAILENC program finished abnormally.'\nMSG012L  EQU *-MSG012T\nMSG012I  EQU X'0C'\n*\nMSG013   DC  AL2(MSG013L)\nMSG013T  DC  C'EME040I The total input records processed : '\nMSG013L  EQU *-MSG013T\nMSG013I  EQU X'0D'\n*\nMSG014   DC  AL2(MSG014L)\nMSG014T  DC  C'EME041I The total output records generated: '\nMSG014L  EQU *-MSG014T\nMSG014I  EQU X'0E'\n*\nMSG015   DC  AL2(MSG015L)\nMSG015T  DC  C'EME042E The given parameter is longer than 8.'\nMSG015L  EQU *-MSG015T\nMSG015I  EQU X'0F'\n*\nMSG016   DC  AL2(MSG016L)\nMSG016T  DC  C'EME043E There are more than 3 parameters.'\nMSG016L  EQU *-MSG016T\nMSG016I  EQU X'10'\n*---------------------------------------------------------------------*\n*  DSECT DATA, ALLOCATED DYNAMICALLY                                  *\n*---------------------------------------------------------------------*\nDSA      DSECT\n* SAVE AREA MUST BE THE FIRST OF DSA DSECT,\n* BECAUSE R13 WILL BE THE BASE REGISTERS FOR THIS DSA,\n* AND THE ADDRESS OF OUR SAVE AREA FOR LINKAGE CONVENTION.\nSAVEAREA DS    18F                ;REGISTER SAVE AREA\nSVLVL1   DS    16F                ;REGISTER SAVE AREA ROUTINE LEVEL 1\nSVLVL2   DS    16F                 ;REGISTER SAVE AREA ROUTINE LEVEL 2\nSVLVL3   DS    16F                 ;REGISTER SAVE AREA ROUTINE LEVEL 3\nRETCODE  DS    XL1                ;RETURN CODE\nPARMADR  DS    F                  ;EXEC PARM ADDRESS\n* DATA FORMAT, DETERMINATED BY EXEC PARM\nPRMWORD  DS    CL8                THE PARMETER WORD TO BE PROCESSED\nPRMWSEQ  DS    H                  THE SEQUENCE OF THE CURRENT WORD\nPRMWLEN  DS    H                  THE LENGTH OF THE CURRENT WORD\n* DATA FORMAT, DETERMINATED BY EXEC PARM\nDATAFMT  DS    XL1                DATA FORMAT: TEXT OR BINARY\nBASE64   EQU   X'00'              DATA FORMAT: TEXT\nQTEPRT   EQU   X'01'              DATA FORMAT: BINARY\n* INPUT RECORD BUFFER\nINBUFADR DS    F                  INPUT RECORD BUFFER START ADDRESS\nINBUFLEN DS    F                  INPUT RECORD BUFFER LENGTH\nINPLRECL DS    F                  INPUT: RECORD LENGTH\nINPBLKSI DS    F                  INPUT: RECORD BLOCK SIZE\nINPRECFM DS    CL4                INPUT: RECORD FORMAT IN TEXT\nINPEOF   DS    XL1                OPEN TAG: TELL IF DCB IS OPEN\nINPRECST DS    F                  INPUT RECORD DATA START ADDRESS\n* OUTPUT RECORD BUFFER\nOUTREC   DS    CL76               OUTPUT RECORD\nOUTPOS   DS    F                  CURRENT POSITION\n* DATA STORAGE FOR BASE 64 ENCODING\n* REMAIN BYTES: AT THE END OF RECORDS, THE LEFT BYTES MAY BE\n* 0,1 OR 2. THE BYTES WILL BE SAVED IN REMBYTES AND COUNTER WILL\n* BE SAVED IN REMCTR\nREMBYTES DS    CL2                THE REMAIN BYTES (0, 1 OR 2)\nREMCTR   DS    X                  THE TOTOAL BYTES LEFT\n* INPUT READ DCB\n         DS    0F\nINPDCB   DS    XL(CINPDCBL)       DCB FOR QSAM\n         DS    0F\nINPDCBE  DS    XL(DCBE$LEN)       DCBE FOR QSAM\n         DS    0F\nINPOPNLF DS    XL(CINPOPLL)       OPEN LIST\n         DS    0F\nINPCLSLF DS    XL(CINPCLSL)       CLOSE LIST FORM\nINPOPNFL DS    XL1                OPEN TAG: TELL IF DCB IS OPEN\nINDDNAME DS    CL8                INPUT DDNAME, DEFAULT: INPUT\n* OUTPUT WRITE DCB\n         DS    0F\nOUTDCB   DS    XL(COUTDCBL)       DCB FOR QSAM\n         DS    0F\nOUTDCBE  DS    XL(DCBE$LEN)       DCBE FOR QSAM\n         DS    0F\nOUTOPNLF DS    XL(COUTOPLL)       OPEN LIST\n         DS    0F\nOUTCLSLF DS    XL(COUTCLSL)       CLOSE LIST FORM\nOUTOPNFL DS    XL1                OPEN TAG: TELL IF DCB IS OPEN\nOUDDNAME DS    CL8                OUTPUT DDNAME, DEFAULT: OUTPUT\n* SYSPRINT DCB\n         DS    0F\nSPRDCB   DS    XL(CSPRDCBL)       DCB FOR QSAM\n         DS    0F\nSPRDCBE  DS    XL(DCBE$LEN)       DCBE FOR QSAM\n         DS    0F\nSPROPNLF DS    XL(CSPROPLL)       OPEN LIST FORM\n         DS    0F\nSPRCLSLF DS    XL(CSPRCLSL)       CLOSE LIST FORM\nSPROPNFL DS    XL1                OPEN TAG: TELL IF DCB IS OPEN\n* DCBE LENGTH\nDCBE$LEN EQU   DCBEEND-DCBE       DCBE length\n* MESSAGE BUFFER\nMSGBUFLN DS    XL1\nMSGBUF   DS    0CL133\nMSGBUFCC DS    CL1\nMSGBUFTX DS    CL132              ;SYSPRINT MESSAGE BUFFER\nMSGCTR   DS    PL2                ;MESSAGE COUNTER\n* FLAGS FOR MESSAGE\nMSGID    DS    X\nMSGCUST  EQU   X'FF'          MESSAGE IS PROVIDED IN MSGBUF, NOT MSGID\nMSGIXEND EQU   X'00'              END OF MESSAGE INDEX TABLE TAG\n*---------------------------------------------------------------------*\nTOLIRCBI DS    F                  INPUT RECORDS IN BINARY NUNBER\nTOLORCBI DS    F                 OUTPUT RECORDS IN BINARY NUNBER\nTOLRECPK DS    D                  RECORDS IN PACKED DECIMAL\nTOLRECNM DS    CL16               RECORDS IN DISPLAYABLE NUMBER\n*---------------------------------------------------------------------*\nDSALEN   EQU   *-DSA              ;LENGTH OF DATA AREA\n*  SYSTEM DSECTS FOR DCB/DCBE\n*        Data Control Block (DCB)\n         DCBD  DSORG=PS,DEVD=DA\n*        DCB Extension (DCBE)\n         IHADCBE\n*---------------------------------------------------------------------*\n*  END OF PROGRAM                                                     *\n*---------------------------------------------------------------------*\n         END   EMAILENC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SENDMAIL": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00H\\x01\\x04\\x02\\x9f\\x01\\x06\\x11_\\x10\\x01\\x05\\xee\\x04\\x1c\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2004-01-29T00:00:00", "modifydate": "2006-04-25T10:01:48", "lines": 1518, "newlines": 1052, "modlines": 0, "user": "ZHOU"}, "text": "/*REXX*****************************************************************\n * Program: SENDMAIL\n * Author:  Hunter Guanghui Zhou\n *          Phone: 1-(416)-602-9567\n *          E-mail: zhough2000@yahoo.com\n * Date:    October 2004\n **********************************************************************\n The SENDMAIL program is designed for zSeries Mainframe.\n All the mail will be sent via internal SMTP mail server.\n E-mail messages are given through <B>SYSIN DD</B>.\n All attachments are given through <B>ATTACH DD</B>.\n\n <H3>Syntax of SYSIN DD:</H3>\n There is no restriction on SYSIN DD in record length.\n\n The SYSIN DD have two sections: Header and Body.\n\n <B>Header:</B>\n   Header is from the first line to the line begin with Subject:\n   There are 4 keywords supported:\n     1. \"From:\" The email address to send this email (optional)         )\n     2. \"To:\" The email list for sending this email to (Madatory).\n     3. \"Cc:\" The email list for copying this email to (Optional).\n     4. \"Bcc:\" The email list for copying this email with hide (Optional)\n     5. \"Subject:\" The email subject.(Mandatory)\n   Header support comments, while the body does not.\n   Any text behind \"#\" will be interpreted as comments.\n   Except for the keyword \"Subject:\", the value for the all\n   other keywords support multiple line, but one email address\n   must be in one line.\n\n <B>Body:</B>\n   Email body is the lines after the line of \"Subject:\".\n   There is no comment allowed in the body, which will be sent\n   as part of email.\n   The body supports HTML formats\n   You may provide your own signature at the end of body.\n\n <H3>Syntax of ATTACH DD:</H3>\n  This is a text file to instruct SENMAIL batch to send the attachments.\n  You may send multiple attachments in this DD.\n\n  ATTACH DD is an <B>optional</B>. If you do not code this DD, there will be\n  no attachment in the email batch.\n\n  The file must be sequential file (QSAM) in catalog.\n  Special Files:\n    GDG files: The GDG generations is allowed.\n    DD Name:   You can specify DD Names  to be attached in the email,\n               The DD name must be pre-allocated in submit JCL.\n\n   According to SMTP standard RFC 1521, the attchements will be encoded\n   depending on their formats:\n   <PRE>\n    Format  Encoding Algorithm        Sample data\n    ======  ==================  ========================================\n    TEXT    Quoted Printable    Any plain text, source code\n    BINARY  Base64              Images, program readable data (zip,doc...)\n   </PRE>\n   So, you must correctly specify the format of each attachment, otherwise\n   the receivers will not get what they want.\n\n   <B>Guidelines:</B>\n    Please follow following guidelines while preparing this DD:\n    1. Any lead or tailed space(' ') will be ingored.\n    2. Any test beyond '#' will be comments.\n    3. Each attachment will have a separate section leaded by\n       keyword <FONT FACE=\"COURIER\">ATTACHMENT:</FONT>\n    4. There are four sub-keywords for each attachment:\n       'DATASET     =' PS Dataset name, PDS member, GDG file, or DDNAME\n       'RENAME      =' The new name to be used in e-mail. (optional)\n       'FORMAT      =' The format of the dataset, must be TEXT (Optional)\n       'DESCRIPTION =' The description shown in e-mail. (optional)\n    5. If there is no attachment DD, the email batch will ignore this\n       file, and just sent the e-mail message defined in SYSIN DD.\n\n  SYMBOLS:\n     The SYSIN and ATTACH DD support following symbols:\n\n       The SYSIN DD and ATTACH DD can contain following symbols. They\n       will be replaced by correspondant values:\n       SYMBOL     DESCRIPTION                   VALUE\n       ========  ====================       ================================\n       %DATE%    The current date           Current date in yyyymmdd\n       %TIME%    The current time           Current time in hhmmss\n       %YEAR%    The current year           Current date in yyyy\n       %RAND%    Any random value           number between 100000 to 999999\n\n  For any further support, please contact:\n\n  Hunter Guanghui Zhou\n  Phone: 1-(416)-602-9567\n  E-mail: zhough2000@yahoo.com\n\n =====================================================================\n */\n\n /*==========================================================\n  *=Change Following Value to meet your system configuration\n  *==========================================================\n  */\n\n   /* Tell SMTP server which email address to be sended from.\n    * If the SenderEmail is empty, use the default email address:\n    *\n    *  tsoid@hostname.domain.name\n    */\n   SenderEmail = '\"Sobeys Ontario Mainframe\" it.ontario@sobeys.com'\n\n   /* SMTP Wirter Name. Refer to your SMTP configurations.     */\n   /* Default is SMTP if its empty.                            */\n   SMTP_Writer = 'SMTP'\n\n   /* SMTP output class, Refer to your SMTP configurations.    */\n   /* Default is B is its empty.                               */\n   SMTP_Class  = 'B'\n\n   /* Tell me the time zone of your location                   */\n   /* Default is EST if its empty.                             */\n   TimeZone    = 'EST'\n\n /*==========================================================\n  *=Do not change from here.                                =\n  *==========================================================\n  */\nSIGNAL ON NOVALUE\nSIGNAL ON HALT\nmain:\n   address tso\n   x = Init_Main()\n   x = GetMailSource();    if exitcode \\=0 then Exit_Program()\n   x = GetAttachments();   if exitcode \\=0 then Exit_Program()\n   x = SendMail()\n   Exit_Program()\n\nInit_Main:\n\n   exitcode   = 0  /* exit code */\n   x=ShowLogo()\n\n   /* Special Thanks to Mau Tran from RDC to provide following\n      code to resolve the TCP/IP host name dynamically\n    */\n   /* get TCP/IP host name and domain name */\n   parse value Socket('Version') with rc . tcp_info\n   parse value Socket('Initialize','myId') with rc .\n   parse value Socket('GetHostName') with rc hostname .\n   parse value Socket('GetDomainName') with rc domain_name .\n\n   /* Set Host Name with domain */\n   HostName     = hostname\".\"domain_name\n\n   /* set defaults */\n   if SMTP_Writer=='' then SMTP_Writer='SMTP'\n   if SMTP_Class =='' then SMTP_Class ='B'\n   if TimeZone   =='' then TimeZone   ='EST'\n   if SenderEmail=='' then,\n      SenderEmail= '\"Mainframe' hostname'\" 'SYSVAR('SYSUID')'@'HostName\n   SenderAddrOnly= ''  /* the email address only, set by ParseEm...() */\n\n   /* Verify and Reformat the default Send From Address */\n   x=ParseEmailAddress(SenderEmail, 'FROM:')\n\n   Drop AttachDataset. AttachRename. AttachFormat. AttachDesp.\n   Drop AttachType. MailMsg. OutLines. iOutLine Header.\n   drop Receiverfull. Receiveraddr. SendCCaddr. SendCCfull.\n   drop SendTOaddr. SendTOfull. SendBCCaddr. SendBCCfull.\n   Header.1 = 'FROM:'\n   Header.2 = 'TO:'\n   Header.3 = 'CC:'\n   Header.4 = 'BCC:'\n   Header.5 = 'SUBJECT:'\n   Header.0 = 5\n   ireceivers = 0  /* the number of receivers */\n   irecto     = 0  /* number of to */\n   ireccc     = 0  /* number of cc */\n   irecbcc    = 0  /* number of bcc users */\n\n   OutLines.0 = 0  /* mail output file array */\n   iOutLine   = 0  /* mail output records    */\n   fOutFileOpen = 0  /* The flag of output file: 0:closed 1: opened */\n   AttachDataset.0= 0\n   SendTOfull.0   = 0\n   SendTOaddr.0   = 0\n   SendCCfull.0   = 0\n   SendCCaddr.0   = 0\n   SendBCCfull.0  = 0\n   SendBCCaddr.0  = 0\n\n   TimeStamp = Date('S')'.'Time('L')\n   DateStamp = 'Date: 'Date('W')',' Date() Time() TimeZone\n   BoundaryA =  '_----_=_ZOS_SENDMAIL.'TimeStamp\n   BoundaryAS=  '--'BoundaryA\n   BoundaryAE=  BoundaryAS'--'\n\n   x=SetMIMETypes()\n   return 0\n\n/*===================================================================*/\n/* Generate the SMTP statements.            */\n/* Send the SMTP statements to SMTP Server. */\nSendMail:\n  X=log('SDM020I Building up the SMTP & MIME statements...')\n  x=allocate_mailfile()     /* allocate and open the mail file  */\n  if exitcode \\=0 then return exitcode\n  x=addSMTPCommands()       /* Build up the SMTP HELO commands. */\n  if exitcode \\=0 then return exitcode\n  x=addEmailBody()          /* Build up the EMAIL main body     */\n  if exitcode \\=0 then return exitcode\n  x=addAttachments()        /* Add all attachement files        */\n  if exitcode \\=0 then return exitcode\n  x=CopyMailToSMTP()        /* Copy the email body to SMTP      */\n  if exitcode \\=0 then return exitcode\n  x=Clean_mailfile()        /* Remove the mail file             */\n  x=log(\"SDM801I The SENDMAIL program finished successfully.\")\n  return exitcode\n/*===================================================================*/\n\n/* Add SMTP start commands */\naddSMTPCommands:\n  x=add('HELO 'HostName)\n  x=add('MAIL FROM: 'SenderAddrOnly)\n  do irc=1 to ReceiverAddr.0\n    x=add('RCPT TO: 'ReceiverAddr.irc)\n  end\n  x=add('DATA')\n  return 0\n\n/* Add MIME Header: The very first MIME header */\naddEmailBody:\n  x=add('Content-Transfer-Encoding: binary')\n  x=add('Content-Type: multipart/related;')\n  x=add('        boundary=\"'BoundaryA'\"')\n  x=add('MIME-Version: 1.0')\n  x=add('X-Mailer: CBTTAPE # 638 Sendmail Package')\n  x=add(DateStamp)\n  x=PrepareReceiverList()  /* prepare To: and Cc: */\n  x=add('Subject: 'HeaderSubject)\n  x=add('')\n  x=add(BoundaryAS)\n  x=add('Content-Transfer-Encoding: quoted-printable')\n  x=add('Content-Disposition: inline')\n  x=add('Content-Type: text/html; charset=\"iso-8859-1\"')\n  x=add('')\n  x=BuildMailBody()   /* Build the mail body in HTML */\n  x=EncodeMailBody()  /* Encode Mail Body in quoted-printable */\n  /* End Of E-Mail Body. */\n  return 0\n\n/* Build The Main Body of the email in pure text.*/\n/* The result is in array:  MailBody.   */\nBuildMailBody:\n  drop MailBody. ibody\n  MailBody.0 = 0\n  ibody  = 0\n  /* add email body HTML text */\n  x=addbody('<HTML><HEAD>')\n  x=addbody('<TITLE>'HeaderSubject'</TITLE></HEAD>')\n  x=addbody('<BODY><FONT FACE=\"Arial\">')\n  /*\n  x=addbody('<CENTER><font face=\"Times New Roman,Times\"',\n        'size=+1 color=\"Red\">')\n  x=addbody('<B>This is an automatic e-mail from 'SenderName'.<BR>')\n  x=addbody('Please do not reply this mail.</B></FONT></CENTER><HR>')\n  */\n  /* insert the mail body */\n  do Item=1 to MailMsg.0\n    x=addbody(MailMsg.Item)\n  end\n\n  /* Show Email Attachments Info in email body.  */\n  if AttachDataset.0 > 0 then do\n    x=addbody('<HR><FONT SIZE=\"+1\"><B>Attachments: Total',\n          AttachDataset.0)\n    x=addbody(' Files in This Email.</B></FONT><P>')\n    x=addbody('<TABLE BORDER=\"1\" STYLE=\"font-size=10pt\" FRAME=\"box\" ',\n          ||'ALIGN=\"LEFT\"><TBODY>')\n    DO iAtts=1 to AttachDataset.0\n      x=addbody('<TR ALIGN=\"CENTER\" BGCOLOR=\"#C0C0C0\">')\n      x=addbody('<TH COLSPAN=2>Attachment # ',\n          ||iAtts' of 'AttachDataset.0'</TH><TR>')\n      x=addbody('<TR ALIGN=\"LEFT\"><TD>File Name</TD>',\n          ||'<TH><FONT FACE=\"Courier\">')\n      x=addbody('<A HREF=\"cid:ATTACHID'iAtts,\n          ||'\">'AttachRename.iAtts'</A>')\n      x=addbody('</FONT></TH></TR>',\n          ||'<TR ALIGN=\"LEFT\"><TD>Description</TD><TH><I>')\n      x=addbody(AttachDesp.iAtts)\n      x=addbody('</I></TH></TR>',\n          ||'<TR ALIGN=\"LEFT\"><TD>File Format</TD><TH>',\n          ||AttachFormat.iAtts'</TH></TR>')\n    end\n    x=addbody('</TBODY></TABLE><P>')\n  end\n  x=addbody('</FONT></BODY></HTML>')\n  MailBody.0 = ibody\n\n  return 0\n\naddbody:\n  parse arg givenline\n  ibody  = ibody + 1\n  MailBody.ibody = givenline\nreturn 0\n\n/* Add all attachement files     */\naddAttachments:\n  /* Preparing the email attachment. */\n  if AttachDataset.0 > 0 then do\n    X=log('SDM200I Preparing the attachments...')\n    do iAtts=1 to AttachDataset.0\n      acode = EnCodeAttachment(iAtts)\n      if acode >0 then leave\n    end\n    if acode > 0 then do\n       x=log('SDM250E There is a problem while preparing attachments.')\n       return acode\n    end\n    X=log('SDM280I The attachments are all prepared.')\n  END  /* There is attachments  */\n\n  return 0\n\n/***************************/\nallocate_mailfile:\n  File_mailfile = GetRandomDsn()\n  if File_mailfile=='' then do\n      x=log('SDM012E Cannot get the temporary mail file name.')\n      x=log('SDM011E Send Mail program initialization failed.')\n      exitcode = 8\n      return 8\n  end\n  \"ALLOC F(SDM$MAIN) DA('\"File_mailfile\"') SPACE(15,15) CYLINDERS\",\n     \"RECFM(F B) LRECL(76) NEW CATALOG\"\n  if RC\\=0 then do\n      x=log('SDM014E Cannot allocate the temporary mail file.')\n      x=log('SDM015E Send Mail program initialization failed.')\n      exitcode = 8\n      return 8\n  end\n  /* keep the file open */\n  fOutFileOpen = 1\n return 0\n\nopen_mailfile:\n  if fOutFileOpen == 1 then return 0\n  \"ALLOC F(SDM$MAIN) DA('\"File_mailfile\"') MOD REUSE\"\n  \"EXECIO 0 DISKW SDM$MAIN (OPEN\"\n  Drop OutLines. iOutLine\n  OutLines.0 = 0\n  iOutLine   = 0\n  fOutFileOpen = 1\n return 0\n\nclose_mailfile:\n  if fOutFileOpen == 0 then return 0\n  OutLines.0 = iOutLine\n  if iOutLine>0 then    /* save and close the file */\n     \"EXECIO * DISKW SDM$MAIN (STEM OutLines. FINIS\"\n  else     /* just close the file */\n     \"EXECIO 0 DISKW SDM$MAIN (FINIS\"\n  \"FREE F(SDM$MAIN)\"\n  Drop OutLines. iOutLine\n  OutLines.0 = 0\n  iOutLine   = 0\n  fOutFileOpen = 0\nreturn 0\n\nadd:\n  parse arg givenline\n  if givenline == '' then givenline = ' '\n  iOutLine = iOutLine + 1\n  OutLines.iOutLine = givenline\nreturn 0\n\nclean_mailfile:\n  parse arg msg\n  if Msg \\= '' then x=log(Msg)\n  if fOutFileOpen == 1 then x=close_mailfile()\n  if File_mailfile \\= '' then do\n     X=MSG('OFF')\n     \"DELETE '\"File_mailfile\"' SCRATCH NONVSAM\"\n     X=MSG('ON')\n  end\nreturn 0\n\n\n/* copy the generated dataset to SMTP */\nCopyMailToSMTP:\n  X=log('SDM300I Sending the SMTP statements to SMTP server...')\n  /* add the end of boundary */\n  x=add(BoundaryAE)\n  x=close_mailfile()        /* Close the mail file              */\n  /*Send The mail message. */\n  x=Msg('off')\n  \"FREE F(SYSIN)\"\n  \"FREE F(SYSUT1)\"\n  \"FREE F(SYSUT2)\"\n  \"FREE F(SYSPRINT)\"\n  \"ALLOC F(SYSUT1) DA('\"File_mailfile\"') SHR REUSE\"\n  \"ALLOC F(SYSUT2) SYSOUT(\"SMTP_Class\") WRITER(\"SMTP_Writer\")\"\n  \"ALLOC F(SYSPRINT) DUMMY\"\n  \"ALLOC F(SYSIN) DUMMY\"\n  \"CALL *(IEBGENER)\"\n  if rc\\=0 then,\n     x=setrc(rc,'SDM304E There is a error while copying data to SMTP')\n  \"FREE F(SYSIN)\"\n  \"FREE F(SYSUT1)\"\n  \"FREE F(SYSUT2)\"\n  \"FREE F(SYSPRINT)\"\n  x=Msg('ON')\n  X=log('SDM301I E-Mail has been sent to SMTP Server.')\n  return 0\n\n/* add email body HTML text */\nEncodeMailBody:\n  iErr = 0\n  x=close_mailfile()  /* Close the mail file for encode program */\n  x=CleanENC(\"SDM110I Encoding Email Body in Quoted Printable Mode\")\n  \"ALLOC F(SDM$INDD) NEW REUSE RECFM(F B) LRECL(255) SPACE(15,15) TRACK\"\n  if RC \\= 0 then do\n     x=setrc(8,\"SDM110E Cannot allocate temporary file for email body.\")\n     return exitcode\n  end\n  /* save the email body to the end of current email file.*/\n  \"EXECIO * DISKW SDM$INDD (STEM MailBody. FINIS\"\n  if RC \\= 0 then do\n     x=setrc(8,\"SDM110E Cannot update temporary file for email body.\")\n     return exitcode\n  end\n  \"ALLOC F(SDM$OUDD) DA('\"File_mailfile\"') MOD REUSE\"\n  \"ALLOC F(SYSPRINT) DUMMY\"\n  rc=EncodeFile('TEXT')\n  if rc\\=0 then do\n    x=log(\"SDM114E Error while encoding email body.\")\n    return exitcode\n  end\n  x=CleanENC(\"SDM118I Finished encoding the email body.\")\n  x=open_mailfile()\n  return 0\n\n/*===================================================================*/\nEnCodeAttachment:\n  parse arg iAtts\n  ecode = 0\n  appl = getmimeappl(AttachRename.iAtts,AttachFormat.iAtts)\n  x=add(BoundaryAS)\n  x=add('Content-Type: 'appl)\n  x=add('        name=\"'AttachRename.iAtts'\"')\n  if pos('TEXT',AttachFormat.iAtts)==1 then\n     x=add('Content-Transfer-Encoding: quoted-printable')\n  else\n     x=add('Content-Transfer-Encoding: base64')\n  x=add('Content-Id: ATTACHID'iAtts)\n  x=add('Content-Disposition: attachment;')\n  x=add('        filename=\"'AttachRename.iAtts'\"')\n  x=add(' ')\n  x=close_mailfile()\n  inddname= 'SDM$INDD'\n  /* save the email body to the end of current email file.*/\n  x=CleanENC(\"SDM200I Encoding\" AttachDataset.iAtts' in',\n             AttachFormat.iAtts' mode.')\n  if AttachType.iAtts == 'DDNAME' then\n     inddname = AttachDataset.iAtts\n  else do\n     \"ALLOC F(SDM$INDD) DA('\"AttachDataset.iAtts\"') REUSE SHR\"\n     if rc \\= 0 then do\n        X = log(\"SDM202E Cannot allocate \"AttachDataset.iAtts)\n        return 8\n     end\n  end\n  \"ALLOC F(SDM$OUDD) DA('\"File_mailfile\"') MOD REUSE\"\n  \"ALLOC F(SYSPRINT) SPACE(2,2) TRACK RECFM(F B) LRECL(133) NEW DELETE\"\n  acode=EncodeFile(AttachFormat.iAtts,inddname)\n  if acode\\=0 then do\n    \"EXECIO * DISKR SYSPRINT (STEM SYSPOUT. FINIS\"\n    if rc ==0 then do\n       X=log('SDM204I The output the email encode program:')\n       do iso=1 to SyspOut.0\n         say '     'strip(SyspOut.iso,'T')\n       end\n    end\n    x=CleanENC(\"SDM206E Error while encoding \" AttachDataset.iAtts)\n    return 8\n  end\n  x=CleanENC(\"SDM208I Finished encoding\" AttachDataset.iAtts)\n  x=open_mailfile()\nreturn acode\n\nEncodeFile:\n  parse arg dataformat,indd,outdd\n  if indd =='' then indd='SDM$INDD'\n  if outdd=='' then outdd='SDM$OUDD'\n  \"CALL *(EMAILENC) '\"dataformat\",\"indd\",\"outdd\"'\"\n  if rc\\=0 then x=setrc(rc)\n  return rc\n\nCleanENC:\n  parse arg msg\n  if Msg \\= '' then x=log(Msg)\n  X=MSG('OFF')\n  \"FREE F(SDM$OUDD)\"\n  \"FREE F(SDM$INDD)\"\n  \"FREE F(SYSPRINT)\"\n  X=MSG('ON')\nreturn 0\n\n/*===================================================================*/\n/* Get the SYSIN DD.\n   Header: From:   Somebody <emailaddress>\n           Cc:     \"Name1\" <email1>,\n                   \"Name2\" <email2>,\n                   \"Name3\" <email3>\n           Bcc:    \"Name1\" <email1>,\n                   \"Name2\" <email2>,\n                   \"Name3\" <email3>\n           Subject:  Any subject in one line.\n   Subject will be the last line in the header.\n   Any line after the subject line will be sent as is.\n\n*/\nGetMailSource:\n\n  X=log(\"SDM030I Reading the data in SYSIN DD...\")\n  Drop InSource.   /*The SYSIN lines. */\n  if CheckDDName('SYSIN')==0 then do\n     X=log(\"SDM032E There is no SYSIN DD.\")\n     return 8\n  end\n\n  \"EXECIO * DISKR SYSIN (STEM INSource. FINIS\"\n  if RC\\=0 then do\n     X=log(\"SDM034E There is a problem while read SYSIN DD.\")\n     return 8\n  end\n  EMailSendFrom    = 1\n  EMailSendTo      = 2\n  EMailSendCc      = 3\n  EMailSendBcc     = 4\n  EMailSendSubject = 5\n  EMailSendAllAddr = 6  /*All receivers email address list.*/\n\n  isHeader = 1\n  im       = 1\n  Continue = 0   /* There is no continuation. */\n  iErr     = 0\n  addbr    = 1   /* add <BR> at the end of message body record */\n  itype    = '';\n  DO item=1 to INSource.0\n     /* just get the first 72 characters, column 73-80 are ignored */\n     /*  INSource.Item=replace_symbols(substr(INSource.Item,1,72))\n      */\n\n     if isHeader == 0 then do  /* Normal email body. */\n        MailMsg.im = strip(INSource.item,'T')\n        OneLine = MailMsg.im\n        upper OneLine\n        if pos('<PRE>', OneLine) > 0 then addbr = 0\n        if pos('</PRE>', OneLine) > 0 then addbr= 2\n        if addbr == 1 & right(OneLine,3) \\= '<P>' &,\n           right(OneLine,4) \\= '<BR>' then\n           MailMsg.im = MailMsg.im||'<BR>'\n        if addbr == 2 then addbr = 1\n        im=im+1\n        iterate\n     end\n\n     /* Processing header only. */\n     Line = strip(INSource.item)\n     if left(line,1) == '#' | line == '' then iterate\n     if pos('#', line) > 0 then\n        Line = strip(substr(Line,1,pos('#',Line)-1))\n     ULine = Line\n     Upper ULine\n\n     /* SUBJECT: is the last line of header */\n     if pos('SUBJECT:', ULine) == 1 then do\n          HeaderSubject = strip(substr(Line,9))\n          isHeader = 0\n          iterate\n     end\n\n     Found = 0\n     if pos(':', line) > 0 then do  /* a new header type */\n       do ih=1 to 4 /* Scan Headers Tags */\n         if pos(Header.ih, Strip(ULine)) == 1 then do\n           Found = 1\n           itype = Header.ih\n           gms1addr=strip(substr(line, pos(itype, ULine)+Length(itype)))\n           x=ParseEmailAddress(gms1addr, itype)\n           leave\n         end\n       end\n     end /* end of if */\n     else do /* continued address or error */\n        if itype \\= '' then x=ParseEmailAddress(Line, itype)\n        else do\n            X=log(\"SDM036E The following head message is invalid:\")\n            say INSource.item\n        end\n     end\n\n  END  /* do loop */\n\n  MailMsg.0   = im -1\n  if iErr > 0 then return 8\n\n  if irecto==0 then do  /* no SEND TO.  */\n     X=log('SDM038E There is no email address for TO: in SYSIN DD:.')\n     call HelpMessage\n     return 8\n  end\n\n  Receivers = ''       /* save all addresses. */\n\n  /*Check and reformat the address lists */\n  X=log('SDM040I Inputs from SYSIN DD:')\n  X=log('SDM041I Email Address of From:')\n  say '    'SenderEmail\n\n  X=log('SDM042I Email Address of To:')\n  do irc=1 to  SendTOfull.0\n     if irc == 1 then say '    'SendTOfull.irc\n     else             say '    'SendTOfull.irc\n  end\n  if ireccc > 0 then do\n     X=log('SDM043I Email Address of CC:')\n     do irc=1 to ireccc\n        if irc == 1 then say '    'SendCCfull.irc\n        else             say '    'SendCCfull.irc\n     end\n  end\n\n  if irecbcc > 0 then do\n     X=log('SDM044I Email Address of BCC:')\n     do irc=1 to irecbcc\n        if irc == 1 then say '    'SendBCCfull.irc\n        else             say '    'SendBCCfull.irc\n     end\n  end\n\n  x=log('SDM046I All Receivers lists:')\n  do irc=1 to Receiveraddr.0\n     say '    'Receiveraddr.irc\n  end\n\n  X=log(\"SDM048I Finished reading the data in SYSIN DD.\")\n  if iErr > 0 then return 8\n  return 0\n\n/*\n  add the email address information into array\n    ReceiverAddr and ReceiverFull\n  Type:\n   TO, CC, BCC\n*/\naddreceiver:\n  parse arg emailaddr,emailfull,type\n  if type == '' then type = 'TO'\n  found = 0\n\n  /* remove any duplicate email address */\n  if ireceivers > 0 then do\n     do irc=1 to ireceivers\n        if emailaddr == Receiveraddr.ireceivers then do\n           found = 1\n           leave\n        end\n     end\n  end\n\n  if found then do\n    x=log('SDM050W The duplicated address 'emailaddr' is ignored.')\n    return 0\n  end\n\n  ireceivers = ireceivers + 1\n  Receiverfull.ireceivers = emailfull\n  Receiveraddr.ireceivers = emailaddr\n  Receiverfull.0 = ireceivers\n  Receiveraddr.0 = ireceivers\n\n  if type == 'TO:' then do\n     irecto = irecto + 1\n     SendTOfull.irecto = emailfull\n     SendTOaddr.irecto = emailaddr\n     SendTOfull.0 = irecto\n     SendTOaddr.0 = irecto\n  end\n\n\n  if type == 'CC:' then do\n     ireccc = ireccc + 1\n     SendCCfull.ireccc = emailfull\n     SendCCaddr.ireccc = emailaddr\n     SendCCfull.0 = ireccc\n     SendCCaddr.0 = ireccc\n  end\n\n  if type == 'BCC:' then do\n     irecbcc = irecbcc + 1\n     SendBCCfull.irecbcc = emailfull\n     SendBCCaddr.irecbcc = emailaddr\n     SendBCCfull.0 = irecbcc\n     SendBCCaddr.0 = irecbcc\n  end\n\n  return 0\n\n/*===================================================================*/\n/* add the from: to: cc: bcc: into MIME header. */\nPrepareReceiverList:\n  x=add('From: 'SenderEmail)\n\n  do irc=1 to  SendTOfull.0\n     if SendTOfull.0==1 then x=add('To: 'SendTOfull.irc)\n     else if irc == 1 then x=add('To: 'SendTOfull.irc',')\n     else if irc\\=SendTOfull.0 then x=add('    'SendTOfull.irc',')\n     else x=add('    'SendTOfull.irc)\n  end\n\n  do irc=1 to  SendCCfull.0\n     if SendCCfull.0==1 then x=add('Cc: 'SendCCfull.irc)\n     else if irc == 1 then x=add('Cc: 'SendCCfull.irc',')\n     else if irc\\=SendCCfull.0 then x=add('    'SendCCfull.irc',')\n     else x=add('    'SendCCfull.irc)\n  end\n\n  do irc=1 to  SendBCCfull.0\n     if SendBCCfull.0==1 then x=add('Bcc: 'SendBCCfull.irc)\n     else if irc == 1 then x=add('Bcc: 'SendBCCfull.irc',')\n     else if irc\\=SendBCCfull.0 then x=add('    'SendBCCfull.irc',')\n     else x=add('    'SendBCCfull.irc)\n  end\n\nreturn 0\n\n/*===================================================================\n  Parse Email Address:\n    Verify the email address format.\n    Reformat the email address as follows:\n        email: <address@company.com>\n        full : \"First Last\" <address@company.com>\n    Add the email address to send arrays\n*/\nParseEmailAddress:\n  parse arg AddrSource, AddrType\n  if AddrSource == '' then return 0\n  iErr = 0\n  NoNames=1\n  do while AddrSource \\= ''\n     parse var AddrSource OneAddress ';' AddrSource\n     OneAddress = strip(OneAddress)\n     AddrSource = Strip(AddrSource)\n     if pos(' ', OneAddress) >0 then do\n        LastSpace=length(OneAddress)-pos(' ',reverse(OneAddress))\n        EMail = substr(OneAddress, LastSpace+1)\n        Name  = substr(OneAddress, 1, LastSpace)\n     end\n     else do\n        Name = '';\n        Email = OneAddress\n     end\n     Name = Strip(Name)\n     EMail= Strip(EMail)\n     rEMail = reverse(EMail)\n\n     if pos('@', EMail) <= 1 then do\n        X=log(\"SDM060E The Email address(\"EMail\") in \"AddrType\" is invalid:\",\n              \"There is no '@' in address.\")\n        iErr = iErr+1\n     end\n\n     if pos('@', EMail) > 1,\n      & pos('@', rEMail) < pos('.', rEMail) then do\n        X=log(\"SDM062E The Email address(\"EMail\") in \"AddrType\" is invalid:\",\n              \"There is no '.' in domain.\")\n        iErr = iErr+1\n     end\n\n     if pos('\"', Name) > 1,\n      & pos('\"', Name) \\= length(Name) then do\n        X=log(\"SDM064E The Email address(\"EMail\") in \"AddrType\" is invalid:\",\n              'The \" is improper.')\n        iErr = iErr+1\n     end\n\n     if left(Name,1)== '\"',\n      & right(Name,1)\\= '\"' then do\n        X=log(\"SDM066E The Email address(\"EMail\") in \"AddrType\" is invalid:\",\n              'The \" is unmatch.')\n        iErr = iErr+1\n     end\n\n     if left(Name,1)== \"'\",\n      & right(Name,1)\\= \"'\" then do\n        X=log(\"SDM068E The Email address(\"EMail\") in \"AddrType\" is invalid:\",\n              \"The ' is unmatch.\")\n        iErr = iErr+1\n     end\n\n     if left(Name,1)\\='\"'&left(Name,1)\\=\"'\" then Name = '\"'Name\n\n     if right(Name,1)\\='\"'&right(Name,1)\\=\"'\" then do\n        if left(Name, 1) ==\"'\" then Name = Name\"'\"\n        else Name=Name'\"'\n     end\n     if left(EMail,1)  \\= '<' then Email = '<'Email\n     if right(EMail,1) == ',' then,\n        Email = substr(Email,1,length(Email)-1)\n     if right(EMail,1) \\= '>' then Email = Email'>'\n\n     if AddrType=='TO:' | AddrType=='CC:' | AddrType=='BCC:' then\n        x=addreceiver(EMail, Name' 'Email, AddrType)\n     else do /* send from */\n        SenderEmail= Name' 'Email\n        SenderAddrOnly = Email\n     end\n  end\n\nreturn iErr\n\n/*===================================================================*/\n/*    AttachDataset. The Dataset name\n      AttachRename.  The new name shown in attachement.\n      AttachFormat.  The format for dataset\n      AttachDesp.    The description for dataset\n*/\nGetAttachments:\n  parse arg AttachDD\n  if AttachDD == '' then AttachDD = 'ATTACH' /*Default is ATTACH DD*/\n  ValidChars='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n             '0123456789._@'\n  if CheckDDName(AttachDD)==0 then return 0\n\n  Drop AttachDataset.\n  Drop AttachRename.\n  Drop AttachFormat.\n  Drop AttachDesp.\n  Drop Attachs.     /* Store all source lines in ATTACH DD. */\n  Drop ErrorMsg.    /* Store all Error Messages.            */\n\n  AttachDataset.0 =0\n  AttachRename.0  =0\n  AttachFormat.0  =0\n  AttachDesp.0    =0\n  Attachs.0       =0\n  ErrorMsg.0      =0\n  iErr = 1\n\n  X=log(\"SDM230I Reading the data in ATTACH DD...\")\n\n  \"EXECIO * DISKR ATTACH (STEM Attachs. FINIS\"\n  if RC\\=0 then do\n     X=log(\"SDM234E There is an error while access ATTACH DD.\")\n     X=log(\"SDM236W All the attachement are ignored.\")\n     return 0\n  end\n\n  if RC > 4 then return RC\n\n  if Attachs.0 == 0 then do; AttachDataset.0 = 0; return 0; end\n  iAtts = 0         /* Number of attachments. */\n  NewAttaches  = 0  /* Whether there is a new section. */\n  do il=1 to Attachs.0\n    if left(strip(Attachs.il), 1) == '#' then iterate\n    Attachs.il = replace_symbols(substr(Attachs.il,1,72))\n    OneLine = strip(Attachs.il); upper Oneline\n    if pos('ATTACHMENT:', OneLine) == 1 then do /*New Section*/\n      if iAtts > 0 then do /*validate keywords of previous attach file*/\n           X=ValidateAttachment(iAtts)\n           if x \\= 0 then leave /* There is an error. */\n      end\n      NewAttaches  = 1\n      iAtts = iAtts + 1\n      AttachFormat.iAtts = 'TEXT'\n      AttachDesp.iAtts   = ''\n      AttachRename.iAtts = ''\n    end /* if new section. */\n    else do /* Get the keywords and values. */\n      if NewAttaches < 1 then do\n         ErrorMsg.iErr='The line 'il' is invalid:'\n         ErrorMsg.0 = iErr; iErr = iErr + 1\n         ErrorMsg.iErr=Attachs.il\n         ErrorMsg.0 = iErr; iErr = iErr + 1\n      end\n      parse var Attachs.il AttKeyword '=' AttValue\n      AttKeyword = Strip(AttKeyword)\n      upper AttKeyword\n      AttValue   = Strip(AttValue)\n      OneLine    = AttValue\n      upper OneLine\n      SELECT\n        when AttValue=='' then iterate\n        when AttKeyword=='DATASET'     then\n        do\n             AttachDataset.iAtts=AttValue\n             upper AttachDataset.iAtts\n             if length(AttValue) <= 8 & pos('.', AttValue) ==0 then\n                AttachType.iAtts   = 'DDNAME'  /* This is a DD Name */\n             else\n                AttachType.iAtts   = 'DSNAME'  /* This is a Dataset */\n        end\n        when AttKeyword=='RENAME' then AttachRename.iAtts = AttValue\n        when AttKeyword=='FORMAT' then AttachFormat.iAtts = OneLine\n        when AttKeyword=='DESCRIPTION' then AttachDesp.iAtts   =AttValue\n        otherwise do\n          ErrorMsg.iErr='The line 'il' is invalid:'\n          ErrorMsg.0 = iErr; iErr = iErr + 1\n          ErrorMsg.iErr=Attachs.il\n          ErrorMsg.0 = iErr; iErr = iErr + 1\n        end /*Otherwise*/\n      END /*select */\n    end /*else*/\n  END /*do loop*/\n\n  /* Validate the last one. */\n  if NewAttaches > 0 then X=ValidateAttachment(iAtts)\n\n  AttachDataset.0 = iAtts\n  if iAtts > 0 then do\n     if iAtts == 1 then\n          X=log('SDM240I There is just one attachement:')\n     else\n          X=log('SDM242I There are 'AttachDataset.0' attachements in',\n                    'ATTACH DD. Here are they:')\n     do item = 1 to AttachDataset.0\n          say '      Attachment #'item\n          say '        Dataset Name: 'AttachDataset.item\n          say '        Format      : 'AttachFormat.item\n          say '        New Name    : 'AttachRename.item\n          say '        Description : 'AttachDesp.item\n     end\n  end\n  else X=log('SDM244W There is no attachment specified.')\n  X=log(\"SDM250I Finished reading the data in ATTACH DD.\")\n\n  if ErrorMsg.0 > 0 then do\n     x=log('SDM250W There is an error while reading the attachment.')\n     do iErr=1 to ErrorMsg.0\n        X=log(ErrorMsg.iErr)\n     end\n     return 8\n  end\n\n  Drop Attachs.     /* Store all source lines in ATTACH DD. */\n  Drop ErrorMsg.    /* Store all Error Messages.            */\nreturn 0\n\n/*===================================================================*/\nValidateAttachment:\n   parse arg iAttach\n   iAtts  = iAttach\n\n   /* If the file is a DD name verify the DD name is allocated. */\n   if AttachType.iAtts == 'DDNAME' then do\n      if CheckDDName(AttachDataset.iAtts)==0 then do\n         ErrorMsg.iErr='SDM260E The DD Name ('AttachDataset.iAtts')',\n                       'in ATTACHMENT #'iAtts 'is not allocated.'\n         ErrorMsg.0 = iErr; iErr = iErr + 1; return iErr\n      end\n      else return 0\n   end\n\n   DSName = GetRealDatasetName(AttachDataset.iAtts)\n\n   if DSName == '' then do\n      ErrorMsg.iErr='SDM262E The dataset ('AttachDataset.iAtts')',\n                    'in ATTACHMENT #'iAtts 'is invalid.'\n      ErrorMsg.0 = iErr; iErr = iErr + 1; return iErr\n   end /* if no dataset name */\n\n   AttachDataset.iAtts = DSName\n   x=listdsi(\"'\"AttachDataset.iAtts\"'\")\n   if ( SYSDSORG \\= 'PO' | pos('(', AttachDataset.iAtts) ==0 ),\n      & SYSDSORG \\= 'PS' then do\n        ErrorMsg.iErr='SDM264E The dataset('AttachDataset.iAtts')',\n           'format ('SYSDSORG') is not a sequential file.'\n        ErrorMsg.0 = iErr; iErr = iErr + 1; return iErr\n   end /*if */\n\n   if AttachFormat.iAtts == '' then AttachFormat.iAtts = 'TEXT'\n   upper AttachFormat.iAtts\n   if pos('TEXT', AttachFormat.iAtts)==0,\n    & pos('BINARY', AttachFormat.iAtts) == 0 then do\n      ErrorMsg.iErr='SDM266E The format ('AttachFormat.iAtts,\n            ') of dataset('AttachDataset.iAtts') is not supported.'\n      ErrorMsg.0 = iErr; iErr = iErr + 1; return iErr\n   end\n\n   if AttachRename.iAtts == '' then do\n      if pos('(', AttachDataset.iAtts)>1, /* For PDS member. */\n       & pos(')', AttachDataset.iAtts)>1 then do\n           parse var AttachDataset.iAtts,\n              PDSName '(' AttachRename.iAtts ')'\n           AttachRename.iAtts = AttachRename.iAtts'.txt'\n      end\n      else AttachRename.iAtts=AttachDataset.iAtts\n   end /*if ==0  */\n   else do /*Validate the new name of the attachments. */\n      DO iC1=1 to length(AttachRename.iAtts)\n         Found = 0\n         ThisChar = substr(AttachRename.iAtts, iC1, 1)\n         DO iC2=1 to length(ValidChars)\n            if ThisChar == substr(ValidChars, iC2, 1) then do\n               Found = 1; leave\n            end\n         END\n         if Found == 0 then do\n            ErrorMsg.iErr='SDM268E The rename ('AttachRename.iAtts,\n              ') of dataset('AttachDataset.iAtts') is not invalid.'\n            ErrorMsg.0 = iErr; iErr = iErr + 1; return iErr\n         END /* IF */\n      end /*DO IC1 loop */\n   end   /*else if */\n\n   if AttachDesp.iAtts == '' then,\n       AttachDesp.iAtts = 'The original file: 'AttachDataset.iAtts\n\nreturn 0\n\n/************************************************\n*  Verify if given DD name is allocated or not. *\n*  If not found, return 0                       *\n*  If found, return nnn dataset names           *\n*     nnn is total number of datasets allocated.*\n*     the dataset names separated by spaces.    *\n*************************************************/\nCheckDDName:\n  parse Arg reqdd .\n  tcb = d2x(C2d(Storage('21c', 4)) + 12)\n  tiot = c2d(Storage(tcb, 4))+24\n  xlen = 0\n  xstring = ''\n  dsnames = 0\n  Do Forever\n    tiot = tiot + xlen\n    addr = tiot\n    xlen = C2d(Storage(D2x(addr), 1))\n    If xlen = 0 Then leave\n    If Bitand(Storage(d2x(addr + 1), 1), '80'x) = '80'x Then iterate\n    addr = tiot + 4\n    ddname = Strip(Storage(D2x(addr), 8))\n    if ddname \\='' & dsnames>0 then leave\n    if ddname == reqdd | dsnames>0 then do\n        addr = tiot + 12\n        dsnaddr = d2x(c2d(Storage(d2x(addr),3)) + 16)\n        dsname  = strip(Storage(dsnaddr, 44), 'T')\n        xstring = xstring dsname\n        dsnames = dsnames + 1\n    end\n  End\n  drop tcb tiot xlen addr ddname\n  if dsnames==0 then return 0\n  else Return dsnames||xstring\n\n/*===================================================================*/\nHelpMessage:\n   SAY '**************************************************************'\n   SAY 'Usage of SENDMAIL.'\n   SAY ''\n   SAY 'This is a sendmail program designed for zSeries Mainframe.'\n   SAY 'All the mail will be sent via SMTP internal mail server.'\n   SAY 'Mail message must be given through SYSIN DD.'\n   SAY ''\n   SAY 'Syntax of SYSIN DD:'\n   SAY 'The SYSIN DD have two sections: Header and Body.'\n   SAY ''\n   SAY 'Header:'\n   SAY '  Header is from the first line to the line begin with Subject:'\n   SAY '  There are 4 keywords supported:'\n   SAY '    1. \"From:\" The email address for the sender.'\n   SAY '    2. \"To:\" The email list for sending this email to.'\n   SAY '    3. \"Cc:\" The email list for copying this email to.'\n   SAY '    4. \"Bcc:\" The email list for copying this email with hide.'\n   SAY '    5. \"Subject:\" The email subject.'\n   SAY '  Header support comments, while the body does not. '\n   SAY '  Any line begin with \"#\" will be interpreted as comments.'\n   SAY '  Except for the keyword \"Subject:\", the value for the all'\n   SAY '  other keywords support multiple line, but one email address'\n   SAY '  must be in one line.'\n   SAY ''\n   SAY 'Body:'\n   SAY '  Body is all lines after the line of \"Subject:\"'\n   SAY '  There is no comment allowed in the body, which will be sent'\n   SAY '  as part of email.'\n   SAY '  The body support HTML formats'\n   SAY ''\n   SAY 'Symbols:'\nsay '  The SYSIN DD and ATTACH DD can contain following symbols. They '\nsay '  will be replaced by correspondant values:'\nsay '  SYMBOL     DESCRIPTION                   VALUE'\nsay '  ========  ====================       ================================'\nsay '  %DATE%    The current date           Current date in yyyymmdd'\nsay '  %TIME%    The current time           Current time in hhmmss'\nsay '  %YEAR%    The current year           Current date in yyyy'\nsay '  %RAND%    Any random value           number between 100000 to 999999'\nsay ''\n   SAY ''\n   SAY 'For any further support, please contact:'\n   SAY ''\n   SAY 'Hunter Zhou'\n   SAY 'Tel: (905) 671-5208'\n   SAY 'guanghui.zhou@sobeys.com'\n   SAY ''\n   RETURN\n\n/*===================================================================*/\n/******************************************************/\n/* Function: log()                                    */\n/******************************************************/\ndebug:\nlog:\n   parse arg Msg\n   say date('S')\", \"time()\", \"Msg\n   return 0\n\n/******************************************************/\n/* Generate a ramdon dataset name.\n   Format:\n   Prefix.DTyyddd.Nnnnnnnn.Suffix\n     yyyy   : 4 digits of year\n     ddd    : 3 digits of day of the year.\n     nnnnnnn: 7 digits in random number.\n*/\nGetRandomDSN:\n  parse arg rPrefix,rSuffix\n  retrylimit = 20\n  if rPrefix='' then rPrefix=SYSVAR('SYSUID')||'.SENDMAIL.TEMPFILE'\n  /* make sure the dataset does not exists. */\n  do i=0 to retrylimit\n     rDSN = rPrefix||'.S'||rand(6)\n     if rSuffix\\='' then rDSN = rDSN||'.'||rSuffix\n     if LISTDSI(\"'\"rDSN\"'\") > 4 then leave\n     if i==retrylimit then do\n       x=log(\"SDM080E Cannot allocate the temporary dataset\")\n       x=log(\"SDM082E Dataset: \"||rDSN)\n       rDSN = ''\n       leave\n     end\n  end\nreturn rDSN\n\n/*===================================================================*/\n/*GetRealDatasetName:\n  Get GDG list for given GDG name, the list is in GDGList.\n  The function will return the latest generation of GDG.\n  HLQ....LLQ(-1)\n*/\nGetRealDatasetName:\n  parse arg SrcDSN\n  DROP GDGResult. GDGList. Generation iDGD iTgt DSName Minus\n  iGDG  = 0        /*Number of GDG Generation.*/\n  Minus = 0\n  Generation = 0\n  upper SrcDSN\n  if pos('(', SrcDSN)>0 then\n        parse var SrcDSN DSName '(' Generation ')'\n  else do /* normal sequential file */\n    x=listdsi(\"'\"SrcDSN\"'\")\n    if x>4 | SYSDSORG \\= 'PS' then return ''\n    return SrcDSN\n  end\n\n  /* Test if this is a PDS */\n  if pos('-', Generation)==0 & pos('+', Generation)==0 &,\n     Generation \\= '0' then do\n     x=listdsi(\"'\"DSName\"'\")\n     if x>4 then return '' | SYSDSORG \\= 'PO' then return ''\n     return SrcDSN\n  end\n\n  /* Process GDG files */\n  Generation = strip(Generation)\n  if Generation == '' | Generation == '-0' | Generation == '+0' then,\n     Generation=0\n\n  if pos('-', Generation) == 1 then do /* minus */\n     parse var Generation '-' Generation\n     minus = 1\n  end\n  x=Msg('OFF')\n  \"FREE F(SYSIN)\"\n  \"FREE F(SYSPRINT)\"\n  \"ALLOCATE F(SYSIN) SPACE(1,1) TRACK LRECL(80) NEW DELETE\"\n  \"ALLOCATE F(SYSPRINT) SPACE(1,2) CYLINDER LRECL(133) NEW DELETE\"\n  GDGResult.0 = 1\n  GDGResult.1 = \"  LISTCAT ENTRY(\"DSNAME\")\"\n  \"EXECIO * DISKW SYSIN (STEM GDGRESULT. FINIS\"\n  \"CALL *(IDCAMS)\"\n  \"EXECIO * DISKR SYSPRINT (STEM GDGResult. FINIS\"\n  \"FREE F(SYSIN)\"\n  \"FREE F(SYSPRINT)\"\n  x=Msg('ON')\n  Begin = 0\n  /* This is not a GDG file. */\n  if pos('GDG BASE', GDGResult.4) == 0 then return ''\n\n  DO iG=1 TO GDGResult.0\n    if pos('0   NONVSAM ---- ', GDGResult.iG) ==1 then do\n       parse var GDGResult.iG rest1 '----' GDGName1\n       iGDG=iGDG+1\n       GDGList.iGDG=strip(GDGName1)\n    end\n  END\n  if iGDG == 0 then return ''\n  select\n     when Generation == 0 then iTgt = iGDG\n     when minus then           iTgt = iGDG - Generation\n     otherwise                 iTgt = iGDG + Generation\n  end\n  /* out of range. */\n  if iTgt > iGDG | iTgt < 0 then return ''\n  GDGName = GDGList.iTgt\n  DROP GDGResult. GDGList. Generation iDGD iTgt DSName Minus\nreturn GDGName\n\n/* ================================================================*/\n/* subroutine: Replace_Symbols() */\nreplace_symbols:\n  parse arg record\n  testrec  = record\n  upper testrec\n  today = Date('S')\n  /* convert the date format to standard format yyyymmdd   */\n  if pos('%DATE%', testrec)>0 then\n     record = replace_string(record, '%DATE%', today)\n  /* convert the year format to standard format yyyy  */\n  if pos('%YEAR%', testrec)>0 then\n     record = replace_string(record, '%YEAR%', substr(today,1,4))\n  /* convert the time format to standard format hhmmss */\n  if pos('%TIME%', testrec)>0 then do\n     now = time()\n     thistime = substr(now,1,2)||substr(now,4,2)||substr(now,7,2)\n     record = replace_string(record, '%TIME%', thistime)\n  end\n  if pos('%RAND%', testrec) > 0 then\n     record=replace_string(record, '%RAND%', rand(6))\nreturn record\n\n/* ================================================================*/\n/* subroutine: Replace_STRING() */\nreplace_string:\n  parse arg string,fromstr,tostr\n  strloc = pos(fromstr, string)\n  if strloc == 0 then return fromstr\n  if strloc == 1 then do\n     newstring = tostr||substr(string, length(fromstr)+1)\n  end\n  else do\n     newstring = substr(string, 1, strloc-1)||tostr\n     strloc = strloc + length(fromstr)\n     if strloc < length(string)-1 then,\n       newstring=newstring||substr(string,strloc)\n  end\nreturn newstring\n\nShowLogo:\n   x=log('SDM001I Welcome to SENDMAIL for Mainframe.')\n   x=log('SDM002I Purpose : Send mail with attachments via SMTP.')\n   x=log('SDM003I Designer: Hunter Zhou (zhough2000@yahoo.com)'    )\n   x=log('SDM004I Support : Hunter Zhou (905) 671-5208')\n   x=log('SDM005I Update  : October, 2004')\n   return 0\n\nSetMIMETypes:\n MIMEType.1  ='323';     MIMEAppl.1  ='text/h323'\n MIMEType.2  ='acx';     MIMEAppl.2  ='application/internet-property-stream'\n MIMEType.3  ='ai';      MIMEAppl.3  ='application/postscript'\n MIMEType.4  ='aif';     MIMEAppl.4  ='audio/x-aiff'\n MIMEType.5  ='aifc';    MIMEAppl.5  ='audio/x-aiff'\n MIMEType.6  ='aiff';    MIMEAppl.6  ='audio/x-aiff'\n MIMEType.7  ='asf';     MIMEAppl.7  ='video/x-ms-asf'\n MIMEType.8  ='asr';     MIMEAppl.8  ='video/x-ms-asf'\n MIMEType.9  ='asx';     MIMEAppl.9  ='video/x-ms-asf'\n MIMEType.10 ='au';      MIMEAppl.10 ='audio/basic'\n MIMEType.11 ='avi';     MIMEAppl.11 ='video/x-msvideo'\n MIMEType.12 ='axs';     MIMEAppl.12 ='application/olescript'\n MIMEType.13 ='bas';     MIMEAppl.13 ='text/plain'\n MIMEType.14 ='bcpio';   MIMEAppl.14 ='application/x-bcpio'\n MIMEType.15 ='bin';     MIMEAppl.15 ='application/octet-stream'\n MIMEType.16 ='bmp';     MIMEAppl.16 ='image/bmp'\n MIMEType.17 ='c';       MIMEAppl.17 ='text/plain'\n MIMEType.18 ='cat';     MIMEAppl.18 ='application/vnd.ms-pkiseccat'\n MIMEType.19 ='cdf';     MIMEAppl.19 ='application/x-cdf'\n MIMEType.20 ='cer';     MIMEAppl.20 ='application/x-x509-ca-cert'\n MIMEType.21 ='class';   MIMEAppl.21 ='application/octet-stream'\n MIMEType.22 ='clp';     MIMEAppl.22 ='application/x-msclip'\n MIMEType.23 ='cmx';     MIMEAppl.23 ='image/x-cmx'\n MIMEType.24 ='cod';     MIMEAppl.24 ='image/cis-cod'\n MIMEType.25 ='cpio';    MIMEAppl.25 ='application/x-cpio'\n MIMEType.26 ='crd';     MIMEAppl.26 ='application/x-mscardfile'\n MIMEType.27 ='crl';     MIMEAppl.27 ='application/pkix-crl'\n MIMEType.28 ='crt';     MIMEAppl.28 ='application/x-x509-ca-cert'\n MIMEType.29 ='csh';     MIMEAppl.29 ='application/x-csh'\n MIMEType.30 ='css';     MIMEAppl.30 ='text/css'\n MIMEType.31 ='dcr';     MIMEAppl.31 ='application/x-director'\n MIMEType.32 ='der';     MIMEAppl.32 ='application/x-x509-ca-cert'\n MIMEType.33 ='dir';     MIMEAppl.33 ='application/x-director'\n MIMEType.34 ='dll';     MIMEAppl.34 ='application/x-msdownload'\n MIMEType.35 ='dms';     MIMEAppl.35 ='application/octet-stream'\n MIMEType.36 ='doc';     MIMEAppl.36 ='application/msword'\n MIMEType.37 ='dot';     MIMEAppl.37 ='application/msword'\n MIMEType.38 ='dvi';     MIMEAppl.38 ='application/x-dvi'\n MIMEType.39 ='dxr';     MIMEAppl.39 ='application/x-director'\n MIMEType.40 ='eps';     MIMEAppl.40 ='application/postscript'\n MIMEType.41 ='etx';     MIMEAppl.41 ='text/x-setext'\n MIMEType.42 ='evy';     MIMEAppl.42 ='application/envoy'\n MIMEType.43 ='exe';     MIMEAppl.43 ='application/octet-stream'\n MIMEType.44 ='fif';     MIMEAppl.44 ='application/fractals'\n MIMEType.45 ='flr';     MIMEAppl.45 ='x-world/x-vrml'\n MIMEType.46 ='gif';     MIMEAppl.46 ='image/gif'\n MIMEType.47 ='gtar';    MIMEAppl.47 ='application/x-gtar'\n MIMEType.48 ='gz';      MIMEAppl.48 ='application/x-gzip'\n MIMEType.49 ='h';       MIMEAppl.49 ='text/plain'\n MIMEType.50 ='hdf';     MIMEAppl.50 ='application/x-hdf'\n MIMEType.51 ='hlp';     MIMEAppl.51 ='application/winhlp'\n MIMEType.52 ='hqx';     MIMEAppl.52 ='application/mac-binhex40'\n MIMEType.53 ='hta';     MIMEAppl.53 ='application/hta'\n MIMEType.54 ='htc';     MIMEAppl.54 ='text/x-component'\n MIMEType.55 ='htm';     MIMEAppl.55 ='text/html'\n MIMEType.56 ='html';    MIMEAppl.56 ='text/html'\n MIMEType.57 ='htt';     MIMEAppl.57 ='text/webviewhtml'\n MIMEType.58 ='ico';     MIMEAppl.58 ='image/x-icon'\n MIMEType.59 ='ief';     MIMEAppl.59 ='image/ief'\n MIMEType.60 ='iii';     MIMEAppl.60 ='application/x-iphone'\n MIMEType.61 ='ins';     MIMEAppl.61 ='application/x-internet-signup'\n MIMEType.62 ='isp';     MIMEAppl.62 ='application/x-internet-signup'\n MIMEType.63 ='jfif';    MIMEAppl.63 ='image/pipeg'\n MIMEType.64 ='jpe';     MIMEAppl.64 ='image/jpeg'\n MIMEType.65 ='jpeg';    MIMEAppl.65 ='image/jpeg'\n MIMEType.66 ='jpg';     MIMEAppl.66 ='image/jpeg'\n MIMEType.67 ='js';      MIMEAppl.67 ='application/x-javascript'\n MIMEType.68 ='latex';   MIMEAppl.68 ='application/x-latex'\n MIMEType.69 ='lha';     MIMEAppl.69 ='application/octet-stream'\n MIMEType.70 ='lsf';     MIMEAppl.70 ='video/x-la-asf'\n MIMEType.71 ='lsx';     MIMEAppl.71 ='video/x-la-asf'\n MIMEType.72 ='lzh';     MIMEAppl.72 ='application/octet-stream'\n MIMEType.73 ='m13';     MIMEAppl.73 ='application/x-msmediaview'\n MIMEType.74 ='m14';     MIMEAppl.74 ='application/x-msmediaview'\n MIMEType.75 ='m3u';     MIMEAppl.75 ='audio/x-mpegurl'\n MIMEType.76 ='man';     MIMEAppl.76 ='application/x-troff-man'\n MIMEType.77 ='mdb';     MIMEAppl.77 ='application/x-msaccess'\n MIMEType.78 ='me';      MIMEAppl.78 ='application/x-troff-me'\n MIMEType.79 ='mht';     MIMEAppl.79 ='message/rfc822'\n MIMEType.80 ='mhtml';   MIMEAppl.80 ='message/rfc822'\n MIMEType.81 ='mid';     MIMEAppl.81 ='audio/mid'\n MIMEType.82 ='mny';     MIMEAppl.82 ='application/x-msmoney'\n MIMEType.83 ='mov';     MIMEAppl.83 ='video/quicktime'\n MIMEType.84 ='movie';   MIMEAppl.84 ='video/x-sgi-movie'\n MIMEType.85 ='mp2';     MIMEAppl.85 ='video/mpeg'\n MIMEType.86 ='mp3';     MIMEAppl.86 ='audio/mpeg'\n MIMEType.87 ='mpa';     MIMEAppl.87 ='video/mpeg'\n MIMEType.88 ='mpe';     MIMEAppl.88 ='video/mpeg'\n MIMEType.89 ='mpeg';    MIMEAppl.89 ='video/mpeg'\n MIMEType.90 ='mpg';     MIMEAppl.90 ='video/mpeg'\n MIMEType.91 ='mpp';     MIMEAppl.91 ='application/vnd.ms-project'\n MIMEType.92 ='mpv2';    MIMEAppl.92 ='video/mpeg'\n MIMEType.93 ='ms';      MIMEAppl.93 ='application/x-troff-ms'\n MIMEType.94 ='mvb';     MIMEAppl.94 ='application/x-msmediaview'\n MIMEType.95 ='nws';     MIMEAppl.95 ='message/rfc822'\n MIMEType.96 ='oda';     MIMEAppl.96 ='application/oda'\n MIMEType.97 ='p10';     MIMEAppl.97 ='application/pkcs10'\n MIMEType.98 ='p12';     MIMEAppl.98 ='application/x-pkcs12'\n MIMEType.99 ='p7b';     MIMEAppl.99 ='application/x-pkcs7-certificates'\n MIMEType.100='p7c';     MIMEAppl.100='application/x-pkcs7-mime'\n MIMEType.101='p7m';     MIMEAppl.101='application/x-pkcs7-mime'\n MIMEType.102='p7r';     MIMEAppl.102='application/x-pkcs7-certreqresp'\n MIMEType.103='p7s';     MIMEAppl.103='application/x-pkcs7-signature'\n MIMEType.104='pbm';     MIMEAppl.104='image/x-portable-bitmap'\n MIMEType.105='pdf';     MIMEAppl.105='application/pdf'\n MIMEType.106='pfx';     MIMEAppl.106='application/x-pkcs12'\n MIMEType.107='pgm';     MIMEAppl.107='image/x-portable-graymap'\n MIMEType.108='pko';     MIMEAppl.108='application/ynd.ms-pkipko'\n MIMEType.109='pma';     MIMEAppl.109='application/x-perfmon'\n MIMEType.110='pmc';     MIMEAppl.110='application/x-perfmon'\n MIMEType.111='pml';     MIMEAppl.111='application/x-perfmon'\n MIMEType.112='pmr';     MIMEAppl.112='application/x-perfmon'\n MIMEType.113='pmw';     MIMEAppl.113='application/x-perfmon'\n MIMEType.114='pnm';     MIMEAppl.114='image/x-portable-anymap'\n MIMEType.115='pot,';    MIMEAppl.115='application/vnd.ms-powerpoint'\n MIMEType.116='ppm';     MIMEAppl.116='image/x-portable-pixmap'\n MIMEType.117='pps';     MIMEAppl.117='application/vnd.ms-powerpoint'\n MIMEType.118='ppt';     MIMEAppl.118='application/vnd.ms-powerpoint'\n MIMEType.119='prf';     MIMEAppl.119='application/pics-rules'\n MIMEType.120='ps';      MIMEAppl.120='application/postscript'\n MIMEType.121='pub';     MIMEAppl.121='application/x-mspublisher'\n MIMEType.122='qt';      MIMEAppl.122='video/quicktime'\n MIMEType.123='ra';      MIMEAppl.123='audio/x-pn-realaudio'\n MIMEType.124='ram';     MIMEAppl.124='audio/x-pn-realaudio'\n MIMEType.125='ras';     MIMEAppl.125='image/x-cmu-raster'\n MIMEType.126='rgb';     MIMEAppl.126='image/x-rgb'\n MIMEType.127='rmi';     MIMEAppl.127='audio/mid'\n MIMEType.128='roff';    MIMEAppl.128='application/x-troff'\n MIMEType.129='rtf';     MIMEAppl.129='application/rtf'\n MIMEType.130='rtx';     MIMEAppl.130='text/richtext'\n MIMEType.131='scd';     MIMEAppl.131='application/x-msschedule'\n MIMEType.132='sct';     MIMEAppl.132='text/scriptlet'\n MIMEType.133='setpay';  MIMEAppl.133='application/set-payment-initiation'\n MIMEType.134='setreg';  MIMEAppl.134='application/set-registration-initiation'\n MIMEType.135='sh';      MIMEAppl.135='application/x-sh'\n MIMEType.136='shar';    MIMEAppl.136='application/x-shar'\n MIMEType.137='sit';     MIMEAppl.137='application/x-stuffit'\n MIMEType.138='snd';     MIMEAppl.138='audio/basic'\n MIMEType.139='spc';     MIMEAppl.139='application/x-pkcs7-certificates'\n MIMEType.140='spl';     MIMEAppl.140='application/futuresplash'\n MIMEType.141='src';     MIMEAppl.141='application/x-wais-source'\n MIMEType.142='sst';     MIMEAppl.142='application/vnd.ms-pkicertstore'\n MIMEType.143='stl';     MIMEAppl.143='application/vnd.ms-pkistl'\n MIMEType.144='stm';     MIMEAppl.144='text/html'\n MIMEType.145='sv4cpio'; MIMEAppl.145='application/x-sv4cpio'\n MIMEType.146='sv4crc';  MIMEAppl.146='application/x-sv4crc'\n MIMEType.147='t';       MIMEAppl.147='application/x-troff'\n MIMEType.148='tar';     MIMEAppl.148='application/x-tar'\n MIMEType.149='tcl';     MIMEAppl.149='application/x-tcl'\n MIMEType.150='tex';     MIMEAppl.150='application/x-tex'\n MIMEType.151='texi';    MIMEAppl.151='application/x-texinfo'\n MIMEType.152='texinfo'; MIMEAppl.152='application/x-texinfo'\n MIMEType.153='tgz';     MIMEAppl.153='application/x-compressed'\n MIMEType.154='tif';     MIMEAppl.154='image/tiff'\n MIMEType.155='tiff';    MIMEAppl.155='image/tiff'\n MIMEType.156='tr';      MIMEAppl.156='application/x-troff'\n MIMEType.157='trm';     MIMEAppl.157='application/x-msterminal'\n MIMEType.158='tsv';     MIMEAppl.158='text/tab-separated-values'\n MIMEType.159='txt';     MIMEAppl.159='text/plain'\n MIMEType.160='uls';     MIMEAppl.160='text/iuls'\n MIMEType.161='ustar';   MIMEAppl.161='application/x-ustar'\n MIMEType.162='vcf';     MIMEAppl.162='text/x-vcard'\n MIMEType.163='vrml';    MIMEAppl.163='x-world/x-vrml'\n MIMEType.164='wav';     MIMEAppl.164='audio/x-wav'\n MIMEType.165='wcm';     MIMEAppl.165='application/vnd.ms-works'\n MIMEType.166='wdb';     MIMEAppl.166='application/vnd.ms-works'\n MIMEType.167='wks';     MIMEAppl.167='application/vnd.ms-works'\n MIMEType.168='wmf';     MIMEAppl.168='application/x-msmetafile'\n MIMEType.169='wps';     MIMEAppl.169='application/vnd.ms-works'\n MIMEType.170='wri';     MIMEAppl.170='application/x-mswrite'\n MIMEType.171='wrl';     MIMEAppl.171='x-world/x-vrml'\n MIMEType.172='wrz';     MIMEAppl.172='x-world/x-vrml'\n MIMEType.173='xaf';     MIMEAppl.173='x-world/x-vrml'\n MIMEType.174='xbm';     MIMEAppl.174='image/x-xbitmap'\n MIMEType.175='xla';     MIMEAppl.175='application/vnd.ms-excel'\n MIMEType.176='xlc';     MIMEAppl.176='application/vnd.ms-excel'\n MIMEType.177='xlm';     MIMEAppl.177='application/vnd.ms-excel'\n MIMEType.178='xls';     MIMEAppl.178='application/vnd.ms-excel'\n MIMEType.179='xlt';     MIMEAppl.179='application/vnd.ms-excel'\n MIMEType.180='xlw';     MIMEAppl.180='application/vnd.ms-excel'\n MIMEType.181='xof';     MIMEAppl.181='x-world/x-vrml'\n MIMEType.182='xpm';     MIMEAppl.182='image/x-xpixmap'\n MIMEType.183='xwd';     MIMEAppl.183='image/x-xwindowdump'\n MIMEType.184='z';       MIMEAppl.184='application/x-compress'\n MIMEType.185='zip';     MIMEAppl.185='application/zip'\n MIMEType.0 = 185\n MIMEAppl.0 = 185\n return 0\n\ngetmimeappl:\n  parse arg filename,filetype\n  /* default is text/plain */\n  if pos('.', filename) == 0 then return 'text/plain'\n  extension = filename\n  do while strip(extension) \\= ''\n     parse var extension name '.' extension\n     extension = strip(extension)\n     if pos('.', extension) == 0 then leave\n  end\n  upper extension\n  thisappl = 'text/plain'\n  do imt = 1 to MIMEType.0\n     if MIMEType.imt == extension then do\n        thisappl = MIMEAppl.imt\n        leave\n     end\n  end\n  return thisappl\n\n/*===================================================================*/\n/* return a radmon number ranged from the server port */\nrand:\n  parse arg length\n  if length == '' then length = 6\n  if \\datatype(length,'NUM') then length = 6\n  min=left(1,length,'0')\n  return left(random(min,min+99999),length,'0')\n\n\n/* set the return code */\nsetrc:\n  parse arg thiscode,msg\n  if thiscode==0 then return 0\n  if thiscode<0 | exitcode==0 then exitcode = thiscode\n  if msg\\='' then x=log(msg)\n  return exitcode\n\n/* exit program from here. */\nExit_Program:\n  parse arg msg\n  if msg\\='' then x=log(msg)\n  x=Clean_mailfile()             /* Remove the temp mail file */\n  x=log(\"SDM800I SENDMAIL program is finished with return code\",\n        exitcode\".\")\n  exit(exitcode)\n\nHALT:\n  exitcode = 16\n  x=Exit_Program('SDM074W This program has been halt.')\n\nNOVALUE:\n   if SIGL > 0 then sl = sourceLine(SIGL)\n   else sl=''\n   say condition('C') 'SDM070E Runtime condition has been raised:'\n   say '  variable name   :' condition('D')\n   say '  error line nr   :' SIGL\n   say '  error line text :' sl\n   say 'SDM072I Please contact the Hunter Zhou to fix this problem.'\n   exitcode = 16\n   x=Exit_Program('SDM076W This program is stopped ',\n       'because of internal REXX syntax error.')\n/*************END OF REXX******************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT638/FILE638.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT638", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}