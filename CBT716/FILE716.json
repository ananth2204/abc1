{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012644000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE716.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE716.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x0f'", "DS1TRBAL": "b'\\x18\\xb4'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xf4\\x00\\x06\\x04\\xf4\\x00\\t\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00\\x16\\x01\\x18!/\\x01\\x18!/\\x13U\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-07-31T00:00:00", "modifydate": "2018-07-31T13:55:16", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-496"}, "text": "REGULAR CBT TAPE - VERSION 496    FILE:  716\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT496.FILE716\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 10 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,030 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/31/18    13:55:15    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ARTICLE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x08\\x01\\x05\\x15\\x1f\\x01\\x05\\x15\\x1f\\x00U\\x00\\xad\\x00\\xa8\\x00\\x00\\xd4\\xd6\\xd6\\xd9\\xc5@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-05-31T00:00:00", "modifydate": "2005-05-31T00:55:08", "lines": 173, "newlines": 168, "modlines": 0, "user": "MOORE"}, "text": "                A WHOHAS Dialog Using QUERYENQ\n\nRecently, I have been experimenting with the new z/OS-only\nISPF service named QUERYENQ. Initially, when reading about\nand experimenting with the QUERYENQ service, I found one\nthing about the service a bit strange. What was so strange?\n\nUnlike any other ISPF service, it returns an open ISPF table\npositioned at the top (current row pointer set to zero). If\nany ENQUEUE is being held on the Qname / Rname pair passed\nto QUERYENQ, the returned table contains one row for every\nENQUEUE held.\n\nAfter working with QUERYENQ for a while using a few practice\nREXX EXECs, this table method began to make sense to me. In\nfact, I kept thinking about the advice that I have given out\nover the years: An ISPF dialog doesn't have to be the one\nthat created a table in order to manipulate the table.\n\nWhy not have ISPF services create a standard ISPF table?\nOnce I got comfortable with this, everything was good.\n\nWHOHAS as a TSO Command\n\nOver the years, I have encountered a TSO command named\nWHOHAS at some MVS installations (but not all). It is not an\nIBM-distributed TSO command. I've seen a few variations of\nit as well. Some variations allow more parameters, such as\nthe scope of the ENQUEUE. Others versions are more rigid,\nallowing only a scope of SYSTEM.  I even ran across a\nvariation of it named WHOGOT. The grammar of this particular\ncommand name always tickled me.\n\nAs I fiddled around with the QUERYENQ service, a thought\ncame to me: Why not write a REXX wrapper around QUERYENQ\nthat pops-up a scrollable window of all held ENQUEUEs on a\ndataset?\n\nAn hour or two later, I had it working quite well. The\nbalance of this month's column will explain the basics of\nthe REXX WHOHAS EXEC.\n\nWHOHAS - REXX and ISPF\n\nI should point out that the REXX WHOHAS is intended only\nfor full-screen, interactive ISPF. The entire dialog has\nonly two components: The REXX EXEC and a single ISPF panel.\nThe source code is in this pds as member WHOHAS so that you\ncan follow along with the narrative and you can execute it.\nThe panel is also here in this pds as member CLCPQENQ.\n\nI will not delve too deeply into the QUERYENQ service\nitself. I'll only discuss it where appropriate. The basic\nformat of the QUERYENQ can be seen in member WHOHAS. For a\nmore detailed explanation of QUERYENQ, you should read the\nz/OS ISPF Services Guide manual.  Note that Qname and Rname\nare parameters to QUERYENQ. They must be REXX variables\nwhose values have been set prior to invoking QUERYENQ.\n\nAnd this brings me to the first bit of REXX explanation.\nSince many ENQUEUEs use the dataset name as the Rname,  I\nimmediately ran into some confusion with regard to whether\nto quote the dataset name or not when preparing the Rname\nQUERYENQ variable.\n\nThe simple answer is: Don't enclose any dataset name in\nquotes for QUERYENQ purposes. At first, this might seem to\nviolate a long-held TSO/ISPF convention. But then, you must\nremember that the Rname value can be anything. It doesn't\nnecessarily have to be a dataset name.\n\nREXX Functions to the Rescue\n\nSince the ARG dataset name might be enclosed in quotes (such\nas when you invoke a REXX EXEC as a line command at ISPF\nOption 3.4) or it might not be, the REXX STRIP function is\nused to remove any quotes, if present. Then, the LISTDSI\nfunction is used to verify that the dataset has a valid,\ncataloged name.\n\nThe LISTDSI function returns a lot of dataset attributes.\nTwo of these attributes are used to determine if an asterisk\nshould be appended to the Minor dataset name variable before\npassing it to QUERYENQ.\n\nFirst the SYSDSORG variable is queried to see if it is PO\n(partitioned organization, or a PDS). If it is PO dataset,\nthen the REXX LEFT function is used to determine if the\nleft-most character of SYSREFCM is an F (or Fixed-length).\n\nThe extra checks are there to expand the Minor name with an\nasterisk in order to pick up more ENQUEUEs, such as any\nSPFEDIT-style ENQUEUE.\n\nIf a member of a fixed-length PDS is being edited, the Minor\nname will include the member name as well as the complete\ndataset name. Normally, SYSDSN-style ENQUEUEs include only\nthe dataset name. The WHOHAS REXX EXEC has already set the\nMajor variable to a single asterisk so that ANY Major name\nwill match.\n\nThis is why I append an asterisk to the passed dataset name\nin the Minor (Rname) variable under the specified\nconditions. Note that this could result in QUERYENQ\nreturning too many ENQUEUEs on other datasets that begin\nwith identical qualifiers. This would be especially true if\nthe dataset name was short.\n\nQUERYENQ Return Codes\n\nThere are only four QUERYENQ return codes that the WHOHAS\nREXX considers: 0, 2, 4 and 8. Here's what they indicate:\n\n       * 0 | Indicates that an ENQUEUE is being held but some\n             might be missing\n       * 2 | Indicates all ENQUEUEs returned, even cross-system\n             ENQUEUEs\n       * 4 | ENQUEUEs held but table truncated due to limit\n       * 8 | No ENQUEUE held\n\nThe REXX code will display the table returned by QUERYENQ in\na small pop-up panel if the return code from QUERYENQ is\n\"less than\" five.\n\nIf the return code is eight, an ISPF message is displayed\nstating | No ENQUEUE held.\n\nOther things to note\n\nWhen you are using QUERYENQ and an ISPF table is returned\n(RC=0, 2 or 4), it is up to the programmer to delete the\ntable when finished with it. This is important because ISPF\ntables are persistent. Simply ending your dialog function\nwill not cause the table to be deleted.\n\nIt will live on and the next time you invoke whatever\ncreated the QUERYENQ table, you will likely get an error\nmessage reading: Table already exists.\n\nWhenever a message needs to be set in a simple dialog such\nas WHOHAS, I prefer to use the IBM-supplied generic message\nnamed ISPZ000. If the ZMSG000S variable is set to spaces and\nthe ZMSG000L contains the actual message text, after issuing\nthe SETMSG, only the long message will display.\n\nIf the user has the Display Long Message in Pop-Up option\nset (at Option 0, Settings) the message will appear in a\nnice little rectangular pop-up window.\n\nNo processing at all is required for the table that\nQUERYENQ returns, other than the TBEND, that is. The\nTBDISPL command uses the panel named CLCPQENQ that contains\na model line naming the columns returned by QUERYENQ.\n\nConclusion\n\nThe entire dialog is simple and easy to use. Place the panel\nin an 80-byte PDS and code the name of the PDS with the\npanel in the LIBDEF statement. Place the WHOHAS in a PDS at\nSYSEXEC (or SYSPROC or even an ALTLIB'd PDS) and invoke it.\n\nJust a reminder: QUERYENQ is the newest of the ISPF services\nand did not appear until z/OS was released. Also, no PDF\nMODEL exists for QUERYENQ as of z/OS V1R4.\n\nThe missing MODEL has been reported to IBM.\n\nTip of the Month: How about wrapping a point-and-shoot\naround the WHOHAS dialog?\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PDSLOAD": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00T\\x01\\x026_\\x01\\x18!/\\x13R\\x00)\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2018-07-31T13:52:54", "lines": 41, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//*      THIS JOB CREATES THE PDS TO INSTALL ENQ\n//*\n//*  Note:  Please substitute appropriate names for:\n//*             name.of.this.pds\n//*             yourqual\n//*\n//PDSLOAD PROC IPDS='name.of.this.pds',         /* THIS PDS */\n//             OPRE=yourqual,\n//             ENQU=ENQ00,\n//             LOWL=PDS,\n//             OUNT=SYSALLDA,\n//             OVL=WORK04,\n//             DSP1=NEW,\n//             DSP2=CATLG,\n//             DSP3='',\n//             P=15,S=30,D=44\n//*\n//LOAD   EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=yourqual.PDSLOAD.TEMPLIB\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=&IPDS(&ENQU)\n//SYSUT2   DD UNIT=&OUNT,VOL=SER=&OVL,\n//             DSN=&OPRE..&ENQU..&LOWL,\n//             DISP=(&DSP1,&DSP2&DSP3),\n//             SPACE=(TRK,(&P,&S,&D),RLSE)\n//  PEND\n//*\n//*  CREATE THE LOADLIB WITH THE PDSLOAD PROGRAM IN IT, FIRST.\n//*\n//TSOBATCH EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n  RECEIVE INDS('name.of.this.pds(PDSLOAD)')\n  DSN('yourqual.PDSLOAD.TEMPLIB') VOL(WORK05) UNIT(SYSALLDA)\n/*\n//*\n//S001 EXEC PDSLOAD,LOWL=PDS\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE716": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00\\x10\\x01\\x18!/\\x01\\x18!/\\x13U\\x00>\\x00>\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-07-31T00:00:00", "modifydate": "2018-07-31T13:55:10", "lines": 62, "newlines": 62, "modlines": 0, "user": "CBT-496"}, "text": "//***FILE 716 is from Jim Moore and contains an ISPF application    *   FILE 716\n//*           to display MVS enqueues using the new ISPF interface  *   FILE 716\n//*           called QUERYENQ.                                      *   FILE 716\n//*                                                                 *   FILE 716\n//*           A detailed article explaining this interface was      *   FILE 716\n//*           published in the March 2005 issue of \"Technical       *   FILE 716\n//*           Support\" magazine from NaSPA.  A version of this      *   FILE 716\n//*           article is in this file, as member $ARTICLE.          *   FILE 716\n//*                                                                 *   FILE 716\n//*           email for Jim Moore:     conlogco@comcast.net         *   FILE 716\n//*                                                                 *   FILE 716\n//*           email for Mike Tomkins:  mjt6@daimlerchrysler.com     *   FILE 716\n//*                                                                 *   FILE 716\n//*           email for Lionel Dyck:   lbdyck@gmail.com             *   FILE 716\n//*                                                                 *   FILE 716\n//*       Newly updated by Lionel Dyck, who incorporated the        *   FILE 716\n//*       panels into the REXX.  Please see his notes at the        *   FILE 716\n//*       beginning of the program.                                 *   FILE 716\n//*                                                                 *   FILE 716\n//*       Notes below pertain to Mike Tomkins' updates, and         *   FILE 716\n//*       are carried over into Lionel's update.                    *   FILE 716\n//*                                                                 *   FILE 716\n//*       Mike Tomkins' version is member ENQ00.  Lionel's is       *   FILE 716\n//*       member ENQ.                                               *   FILE 716\n//*                                                                 *   FILE 716\n//*       Once Jim created this package and wrote his article,      *   FILE 716\n//*       Mike Tomkins has found a few ways to improve it.  Mike's  *   FILE 716\n//*       version may be found in the two members called ENQ00 and  *   FILE 716\n//*       ENQ@.  To make it easier to create the pds that installs  *   FILE 716\n//*       Mike's ENQ package, I've included two members here, the   *   FILE 716\n//*       PDSLOAD program, in TSO XMIT format, and the $PDSLOAD     *   FILE 716\n//*       member, which is one-stop JCL to create the install pds   *   FILE 716\n//*       for ENQ.  (Maybe overkill--it could have been done by     *   FILE 716\n//*       hand.  SBG)  Mike's notes are in member ENQ@.  An         *   FILE 716\n//*       excerpt is copied below:                                  *   FILE 716\n//*                                                                 *   FILE 716\n//*       I thought you might like to get my updates to the ISPF    *   FILE 716\n//*       ENQ facility in file 716 originally provided by Jim       *   FILE 716\n//*       Moore which accompanied his article in Technical          *   FILE 716\n//*       Support.                                                  *   FILE 716\n//*                                                                 *   FILE 716\n//*       I've loosened the restictions, so to speak, to allow      *   FILE 716\n//*       its use as a more general ENQ display facility.  The      *   FILE 716\n//*       following are the changes:                                *   FILE 716\n//*                                                                 *   FILE 716\n//*       1. Removed the restriction that the input must be a       *   FILE 716\n//*          DSN; i.e. any pattern or no input can be supplied as   *   FILE 716\n//*          an \"*\" is automatically appended to the input.  If     *   FILE 716\n//*          there is no RNAME input, ALL ENQ's for ALL QNAMES      *   FILE 716\n//*          are displayed.                                         *   FILE 716\n//*                                                                 *   FILE 716\n//*       2. Updated to allow a larger popup window width of 77     *   FILE 716\n//*          vs. 46.                                                *   FILE 716\n//*                                                                 *   FILE 716\n//*       3. Updated to allow a larger popup window depth of 39     *   FILE 716\n//*          for mod4's and 20 for all other devices vs. the        *   FILE 716\n//*          original 8.                                            *   FILE 716\n//*                                                                 *   FILE 716\n//*       4. Added LIMIT(0) to the QUERYENQ invocation to           *   FILE 716\n//*          override the default limit of 5,000 returned table     *   FILE 716\n//*          rows.                                                  *   FILE 716\n//*                                                                 *   FILE 716\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLCPQENQ": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x05\\x08o\\x01\\x05\\x08o\"1\\x00\\x11\\x00\\x11\\x00\\x00\\xd4\\xd6\\xd6\\xd9\\xc5@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-27T00:00:00", "modifydate": "2005-03-27T22:31:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "MOORE"}, "text": ")ATTR\n? TYPE(OUTPUT) CAPS(ON)  INTENS(LOW)\n_ TYPE(INPUT)  CAPS(ON)  INTENS(HIGH)\n% TYPE(TEXT)             INTENS(HIGH) SKIP(ON)\n+ TYPE(TEXT)             INTENS(LOW)  SKIP(ON)\n)BODY WINDOW(46,8)\n%\n%Command ===>_ZCMD          %Scroll ===>_Z   %\n%\n%--Holder---How--Type--Scope--System--Qname--\n)MODEL\n ?Z       ?Z     ?Z   ?Z      ?Z     ?Z\n)INIT\n.ZVARS = '(ZSCED,ZENJOB,ZENDISP,ZENHOLD,ZENSCOPE,ZENSYST,ZENQNAME)'\n&ZWINTTL = &EQDSN\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENQ": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00#\\x01\\x06\\x02\\x0f\\x01\\x18!/\\t\\t\\x01\\xa5\\x00(\\x00\\x00\\xd3\\xc2\\xc4\\xe8\\xc3\\xd2@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2006-01-20T00:00:00", "modifydate": "2018-07-31T09:09:23", "lines": 421, "newlines": 40, "modlines": 0, "user": "LBDYCK"}, "text": "/* -- REXX --------------------------------------------------------- */\n/* -- Purpose: To test to see if an ENQ is held against a DSN or any */\n/* --          RNAME pattern.  No input defaults to RNAME=*; i.e.    */\n/* --          ALL RNAMEs for ALL QNAMEs are returned.  The ENQ exec */\n/* --          can be invoked via \"TSO %ENQ pattern\", or a 3.4 line  */\n/* --          cmd, where pattern can be null, a partial RNAME/DSN,  */\n/* --          or a fully qualified, quoted DSN.  Don't include \"*\". */\n/* --          The table returned from QUERYENQ is displayed in a    */\n/* --          pop-up Window if anything holds an ENQ on ARG EQDSN   */\n/* -- Related: . Panels Named OSGP2ENQ & OSGP4ENQ                    */\n/* -- By Jim Moore - Concentrated Logic Inc - 1/15/2005              */\n/* ----------------------------------------------------------------- */\n/* Maintenance:                                                      */\n/* -- By Lionel Dyck  - VA                    - 07/31/2018           */\n/* --    Check if under ISPF                                         */\n/* -- By John Kalinich                        - 07/30/2018           */\n/* --    Enhance if minor name is *                                  */\n/* -- By Lionel Dyck  - VA                    - 07/26/2018           */\n/* --    Moved ISPF Panels inline using the LoadISPF subroutine      */\n/* --          and removed the LIBDEF                                */\n/* --    Added ADDRESS ISPEXEC and removed ISPEXEC on individual     */\n/* --          ISPF services                                         */\n/* -- By Mike Tomkins - DaimlerChrysler Corp. - 01/20/2006           */\n/* --    Updated to allow RNAME patterns; i.e. not limited to DSNs   */\n/* --    Updated to allow larger popup window width - 77 vs. 46      */\n/* --    Updated to allow larger popup window depth - old value of 8 */\n/* --               replaced by 39 for mod 4 or 20 for anything else */\n/* --    Updated to allow > 5,000 output table rows via LIMIT(0)     */\n/* ----------------------------------------------------------------- */\nParse Upper Arg EQDSN\nif sysvar('sysenv') /= 'FORE' then do\n   say 'Not running in the Foreground under ISPF - exiting . . .'\n   exit 16\n   end\nif sysvar('sysispf') /= 'ACTIVE' then do\n   say 'Not running under ISPF so exiting. . .'\n   exit 16\n   end\nAddress ISPExec                  /* Set addressing environment       */\n\"CONTROL ERRORS CANCEL\"          /* Ensure that errors cancel REXX   */\nload_info = ''                   /* set load_info to null            */\nEQDSN = Strip(''EQDSN'',,\"'\")    /* Strip off quotes if DSN quoted   */\nMAJOR = '*'                      /* Set Major to any Name            */\nMINOR = EQDSN'*'                 /* Set Minor to Arg DSN w/asterisk  */\nZTDMARK = CENTER('------------ End of ENQ Holder List ------------',77)\n\"QUERYENQ TABLE(DSNENQ) QNAME(MAJOR) RNAME(MINOR) XSYS LIMIT(0)\"\nQRC = RC                         /* Save RC from QUERYENQ            */\nIf QRC < 5 Then Do               /* If 0-2-4, an ENQ is being held   */\n  TRC = 0                        /* Force \"TableRC\" (TRC) = 0        */\n  \"VGET (ZSCRMAXD)\"              /* Get the max scrn depth for popup */\n  If ZSCRMAXD = 43 Then osgpanel = \"OSGP4ENQ\"   /* If Mod4, depth=39 */\n                   Else osgpanel = \"OSGP2ENQ\" /* If \u00ac Mod4, depth=20 */\n  load_info = loadispf()         /* Load ISPF Panels                 */\n  Do Until TRC > 0               /* Display panel until END          */\n    \"ADDPOP\"                     /* Add pop-up window                */\n    \"TBDISPL DSNENQ PANEL(\"osgpanel\")\"             /* TBDISPL panel  */\n    TRC = RC                     /* Save RC as \"TRC\"                 */\n    \"REMPOP\"                     /* Remove pop-up window             */\n  End                            /* Out on TRC Not = 0               */\n  \"TBEND DSNENQ\"                 /* Destroy table from QUERYENQ      */\nEnd                              /* -------------------------------- */\nIf QRC = 8 Then Do               /* If 8, No ENQ held                */\n  ZMSG000S = \" \"                 /* No short message                 */\n  ZMSG000L = \"There are no enqueues on resource\" EQDSN\n  'SETMSG MSG(ISPZ000)'          /* Only a long message              */\nEnd                              /* -------------------------------- */\nif length(load_info) > 0 then    /* if we loaded the ispf panels     */\ndo until length(load_info) = 0   /* loop and free the libdefs        */\n   parse value load_info with dd libd load_info\n   \"libdef\" libd                 /* free the libdef                  */\n   address tso \"free f(\"dd\")\"    /* and free the allocation          */\n   End                           /* -------------------------------- */\nExit 0\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    load_info = loadispf()                          *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          Address ISPEXEC                                   *\n *          do until length(load_info) = 0                    *\n *             parse value load_info with dd libd load_info   *\n *             if left(libd,6) = \"ALTLIB\" then do             *\n *                if libd = \"ALTLIBC\" then lib = \"CLIST\"      *\n *                                    else lib = \"EXEC\"       *\n *                Address TSO,                                *\n *                  \"Altlib Deact Application(\"lib\")\"         *\n *                end                                         *\n *             else \"libdef\" libd                             *\n *             address tso \"free f(\"dd\")\"                     *\n *             end                                            *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            08/29/17 - Fixup static values that were vars   *\n *            05/31/17 - Change default directory count       *\n *            12/09/16 - update for add_it routine            *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\n LoadISPF: Procedure\n\n parse value \"\" with null kmsg kpanel kskel first returns ,\n                     kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n last_line = sourceline()\n do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n    end\n rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n    end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n clistdd = \"lc\"random(999)\n execdd  = \"le\"random(999)\n msgdd   = \"lm\"random(999)\n paneldd = \"lp\"random(999)\n skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n    end\n if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n    end\n if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n    end\n if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n    end\n if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n    end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n       if first = 1 then call add_it\n       type = \"Clist\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">EXEC \" then do\n       if first = 1 then call add_it\n       type = \"Exec\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,5) = \">MSG \" then do\n       if first = 1 then call add_it\n       type = \"Msg\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,7) = \">PANEL \" then do\n       if first = 1 then call add_it\n       type = \"Panel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">SKEL \" then do\n       if first = 1 then call add_it\n       type = \"Skel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n           \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n           \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n           \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n           \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n           \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n      end\n    end\n if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n if kclist <> null then do\n    Address TSO,\n    \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n    end\n if kexec <> null then do\n    Address TSO,\n    \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n    end\n if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n    end\n if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n    end\n if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n    end\n return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\n Add_It:\n Select\n    When type = \"Clist\" then\n         \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n         \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n         \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n         \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n         \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n    end\n type = null\n return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\n Alloc_DD:\n arg dd\n Address TSO\n if pos(left(dd,2),\"lc le\") > 0 then\n \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n else\n \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n return\n>start\n>panel osgp2enq\n)ATTR\n? TYPE(OUTPUT) CAPS(ON)  INTENS(LOW)\n_ TYPE(INPUT)  CAPS(ON)  INTENS(HIGH)\n% TYPE(TEXT)             INTENS(HIGH) SKIP(ON)\n+ TYPE(TEXT)             INTENS(LOW)  SKIP(ON)\n)BODY WINDOW(77,20)\n%\n%Command ===>_ZCMD                                         %Scroll ===>_Z   %\n%\n%--Holder---How--Type--Scope--System--Qname---Rname--------------------------\n)MODEL\n ?Z       ?Z     ?Z   ?Z      ?Z     ?Z      ?Z\n)INIT\n.ZVARS = '(ZSCED,ZENJOB,ZENDISP,ZENHOLD,ZENSCOPE,ZENSYST,+\nZENQNAME,ZENRNAME)'\nIF (&MINOR = '*')\n  &EQDSN = 'QUERYENQ Qname=&MAJOR Rname=&MINOR'\n&ZWINTTL = &EQDSN\n)PROC\n)END\n>panel osgp4enq\n)ATTR\n? TYPE(OUTPUT) CAPS(ON)  INTENS(LOW)\n_ TYPE(INPUT)  CAPS(ON)  INTENS(HIGH)\n% TYPE(TEXT)             INTENS(HIGH) SKIP(ON)\n+ TYPE(TEXT)             INTENS(LOW)  SKIP(ON)\n)BODY WINDOW(77,39)\n%\n%Command ===>_ZCMD                                         %Scroll ===>_Z   %\n%\n%--Holder---How--Type--Scope--System--Qname---Rname--------------------------\n)MODEL\n ?Z       ?Z     ?Z   ?Z      ?Z     ?Z      ?Z\n)INIT\n.ZVARS = '(ZSCED,ZENJOB,ZENDISP,ZENHOLD,ZENSCOPE,ZENSYST,+\nZENQNAME,ZENRNAME)'\nIF (&MINOR = '*')\n  &EQDSN = 'QUERYENQ Qname=&MAJOR Rname=&MINOR'\n&ZWINTTL = &EQDSN\n)PROC\n)END\n>end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ENQ@": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00G\\x01\\x06\\x05\\x8f\\x01\\x06\\x05\\x8f\\x10V\\x00B\\x00B\\x00\\x00\\xe3\\xd6\\xd4\\xd2\\xc9\\xd5\\xe2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-02-27T00:00:00", "modifydate": "2006-02-27T10:56:47", "lines": 66, "newlines": 66, "modlines": 0, "user": "TOMKINS"}, "text": "Subject:     Update to ISPF ENQ Facility in FILE716\nFrom:        mjt6@daimlerchrysler.com\nDate:        Thu, 23 Feb 2006 13:46:43 -0500\nTo:          sbgolob@cbttape.org\n\nHi Sam,\n\nI thought you might like to get my updates to the ISPF ENQ\nfacility in file 716 originally provided by Jim Moore which\naccompanied his article in Technical Support.\n\nI've loosened the restictions, so to speak, to allow its use as a\nmore general ENQ display facility.  The following are the\nchanges:\n\n1. Removed the restriction that the input must be a DSN; i.e. any\n   pattern or no input can be supplied as an \"*\" is automatically\n   appended to the input.  If there is no RNAME input, ALL ENQ's for\n   ALL QNAMES are displayed.\n\n2. Updated to allow a larger popup window width of 77 vs. 46.\n\n3. Updated to allow a larger popup window depth of 39 for mod4's\n   and 20 for all other devices vs. the original 8.\n\n4. Added LIMIT(0) to the QUERYENQ invocation to override the\n   default limit of 5,000 returned table rows.\n\nDue to number 3 above, there are now two panels; one for popup\ndepth 39 and one for popup depth 20.  It sure would be nice if\nthe WINDOW specification in the )BODY section of a panel allowed\nthe use of variables, but that's why the invocation exec I call\nENQ now retrieves variable ZSCRMAXD and sets the appropriate\npanel name in a variable passed to the TBDISP facility.  We\nalready had a facility called WHOHAS; hence the name change to\nENQ.  Assuming the exec name and panel names are OK in a shop,\nall that needs to be done to implement is the following:\n\n1. Replace Your_panel_library in the LIBDEF for ISPPLIB with the\n   dsn of the shop's panel library to contain the panels.\n   (That is: edit the ENQ exec, to put your panel library name in,\n   instead of the string, Your_panel_library.)\n\n2. Copy the panels to the panel library referenced in the last\n   item.\n\n3. Copy the updated rexx exec to the shop's choice of clist or\n   exec library.\n\n4. Enjoy.\n\nOne can then enter TSO %ENQ or TSO %ENQ some-pattern (without the\ntrailing \"*\") on the command input line to get all ENQ's or all\nENQ's for all QNAMES with an RNAME pattern of some-pattern\nrespectively.  One can also enter ENQ or %ENQ as a line command\nbefore a DSN in a 3.4 list.\n\nThe following attachment is the xmit output file of the pds\ncontaining the ENQ rexx exec and the two panels:\n\nSince the three members are named differently, you could add them\nto the existing FILE716 contents adding a note member describing\nthe above enhancements.\n\nWarmest Regards, Mike\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ENQ00": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x06\\x05\\x8f\\x01\\x06\\x05\\x8f\\x10!\\x00Y\\x00Y\\x00\\x00\\xe3\\xd6\\xd4\\xd2\\xc9\\xd5\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-02-27T00:00:00", "modifydate": "2006-02-27T10:21:00", "lines": 89, "newlines": 89, "modlines": 0, "user": "TOMKINS"}, "text": "./ ADD NAME=ENQ      0100-06020-06053-1357-00050-00040-00000-T7796MT\n/* -- REXX --------------------------------------------------------- */\n/* -- Purpose: To test to see if an ENQ is held against a DSN or any */\n/* --          RNAME pattern.  No input defaults to RNAME=*; i.e.    */\n/* --          ALL RNAMEs for ALL QNAMEs are returned.  The ENQ exec */\n/* --          can be invoked via \"TSO %ENQ pattern\", or a 3.4 line  */\n/* --          cmd, where pattern can be null, a partial RNAME/DSN,  */\n/* --          or a fully qualified, quoted DSN.  Don't include \"*\". */\n/* --          The table returned from QUERYENQ is displayed in a    */\n/* --          pop-up Window if anything holds an ENQ on ARG EQDSN   */\n/* -- Related: . Panels Named OSGP2ENQ & OSGP4ENQ                    */\n/* -- By Jim Moore - Concentrated Logic Inc - 1/15/2005              */\n/* ----------------------------------------------------------------- */\n/* Maintenance:                                                      */\n/* -- By Mike Tomkins - DaimlerChrysler Corp. - 01/20/2006           */\n/* --    Updated to allow RNAME patterns; i.e. not limited to DSNs   */\n/* --    Updated to allow larger popup window width - 77 vs. 46      */\n/* --    Updated to allow larger popup window depth - old value of 8 */\n/* --               replaced by 39 for mod 4 or 20 for anything else */\n/* --    Updated to allow > 5,000 output table rows via LIMIT(0)     */\n/* ----------------------------------------------------------------- */\nParse Upper Arg EQDSN\nAddress Ispexec 'LIBDEF ISPPLIB DATASET,\n         ID(''Your_panel_library'') STACK'\nIspexec \"CONTROL ERRORS CANCEL\"  /* Ensure that errors cancel REXX   */\nEQDSN = Strip(''EQDSN'',,\"'\")    /* Strip off quotes if DSN quoted   */\nMAJOR = '*'                      /* Set Major to any Name            */\nMINOR = EQDSN'*'                 /* Set Minor to Arg DSN w/asterisk  */\nZTDMARK = CENTER('------------ End of ENQ Holder List ------------',77)\nIspexec \"QUERYENQ TABLE(DSNENQ) QNAME(MAJOR) RNAME(MINOR) XSYS LIMIT(0)\"\nQRC = RC                         /* Save RC from QUERYENQ            */\nIf QRC < 5 Then Do               /* If 0-2-4, an ENQ is being held   */\n  TRC = 0                        /* Force \"TableRC\" (TRC) = 0        */\n  Ispexec \"VGET (ZSCRMAXD)\"      /* Get the max scrn depth for popup */\n  If ZSCRMAXD = 43 Then osgpanel = \"OSGP4ENQ\"   /* If Mod4, depth=39 */\n                   Else osgpanel = \"OSGP2ENQ\" /* If \u00ac Mod4, depth=20 */\n  Do Until TRC > 0               /* Display panel until END          */\n    Ispexec \"ADDPOP\"             /* Add pop-up window                */\n    Ispexec \"TBDISPL DSNENQ PANEL(\"osgpanel\")\"     /* TBDISPL panel  */\n    TRC = RC                     /* Save RC as \"TRC\"                 */\n    Ispexec \"REMPOP\"             /* Remove pop-up window             */\n  End                            /* Out on TRC Not = 0               */\n  Ispexec \"TBEND DSNENQ\"         /* Destroy table from QUERYENQ      */\nEnd                              /* -------------------------------- */\nIf QRC = 8 Then Do               /* If 8, No ENQ held                */\n  ZMSG000S = \" \"                 /* No short message                 */\n  ZMSG000L = \"There are no enqueues on resource\" EQDSN\n  Ispexec 'SETMSG MSG(ISPZ000)'  /* Only a long message              */\nEnd                              /* -------------------------------- */\nIspexec \"LIBDEF ISPPLIB\"         /* Destroy panel LIBDEF             */\nExit\n./ ADD NAME=OSGP2ENQ 0100-06020-06020-2200-00018-00018-00000-T7796MT\n)ATTR\n? TYPE(OUTPUT) CAPS(ON)  INTENS(LOW)\n_ TYPE(INPUT)  CAPS(ON)  INTENS(HIGH)\n% TYPE(TEXT)             INTENS(HIGH) SKIP(ON)\n+ TYPE(TEXT)             INTENS(LOW)  SKIP(ON)\n)BODY WINDOW(77,20)\n%\n%Command ===>_ZCMD                                         %Scroll ===>_Z   %\n%\n%--Holder---How--Type--Scope--System--Qname---Rname--------------------------\n)MODEL\n ?Z       ?Z     ?Z   ?Z      ?Z     ?Z      ?Z\n)INIT\n.ZVARS = '(ZSCED,ZENJOB,ZENDISP,ZENHOLD,ZENSCOPE,ZENSYST,+\nZENQNAME,ZENRNAME)'\n&ZWINTTL = &EQDSN\n)PROC\n)END\n./ ADD NAME=OSGP4ENQ 0100-06020-06020-2200-00018-00018-00000-T7796MT\n)ATTR\n? TYPE(OUTPUT) CAPS(ON)  INTENS(LOW)\n_ TYPE(INPUT)  CAPS(ON)  INTENS(HIGH)\n% TYPE(TEXT)             INTENS(HIGH) SKIP(ON)\n+ TYPE(TEXT)             INTENS(LOW)  SKIP(ON)\n)BODY WINDOW(77,39)\n%\n%Command ===>_ZCMD                                         %Scroll ===>_Z   %\n%\n%--Holder---How--Type--Scope--System--Qname---Rname--------------------------\n)MODEL\n ?Z       ?Z     ?Z   ?Z      ?Z     ?Z      ?Z\n)INIT\n.ZVARS = '(ZSCED,ZENJOB,ZENDISP,ZENHOLD,ZENSCOPE,ZENSYST,+\nZENQNAME,ZENRNAME)'\n&ZWINTTL = &EQDSN\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSLOAD": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x156\\x00e\\x00e\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T15:36:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "WHOHAS": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x05\\x08o\\x01\\x05\\x08o\"1\\x000\\x000\\x00\\x00\\xd4\\xd6\\xd6\\xd9\\xc5@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-27T00:00:00", "modifydate": "2005-03-27T22:31:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "MOORE"}, "text": "/* -- REXX --------------------------------------------------------- */\n/* -- Purpose: To test to see if an ENQ is held against a DSN        */\n/* --          The table returned from QUERYENQ is displayed in a    */\n/* --          pop-up Window if anything holds an ENQ on ARG DSN     */\n/* -- Related: . Panel Named CLCPQENQ                                */\n/* -- By Jim Moore - Concentrated Logic Inc - 1/15/2005              */\n/* ----------------------------------------------------------------- */\n/* Maintenance:                                                      */\n/* ----------------------------------------------------------------- */\nParse Upper Arg EQDSN\nAddress Ispexec 'LIBDEF ISPPLIB DATASET,\n         ID(''pds.with.CLCPQENQ.panel'') STACK'\nIspexec \"CONTROL ERRORS CANCEL\"  /* Ensure that errors cancel REXX   */\nEQDSN = Strip(''EQDSN'',,\"'\")    /* Strip off quotes if DSN quoted   */\nX = LISTDSI(''''EQDSN'''' DIRECTORY NORECALL)\nIF SYSREASON /= 0 Then Do        /* If DSN not Cataloged             */\n  ZMSG000S = \" \"                 /* No short message                 */\n  ZMSG000L = \"Dataset \"EQDSN\" Not in Catalog\"\n  Ispexec 'SETMSG MSG(ISPZ000)'  /* If DSN NOT Catlg'd, message+exit */\n  Exit                           /* -------------------------------- */\nEnd\nMAJOR = '*'                      /* Set Major to any Name            */\nMINOR = EQDSN                    /* Set Minor to Arg DSN             */\nIf SYSDSORG = \"PO\" Then Do       /* If a PDS                         */\n If Left(SYSRECFM,1) = \"F\" Then Do /* If \"Fixed\"                     */\n    MINOR = EQDSN'*'             /* Append asterisk to Minor         */\n End                             /* (to pick up other ENQUEUEs)      */\nEnd\nZTDMARK = CENTER('---End of ENQ Holder List---',44)\nIspexec \"QUERYENQ TABLE(DSNENQ) QNAME(MAJOR) RNAME(MINOR) XSYS\"\nQRC = RC                         /* Save RC from QUERYENQ            */\nIf QRC < 5 Then Do               /* If 0-2-4, an ENQ is being held   */\n  TRC = 0                        /* Force \"TableRC\" (TRC) = 0        */\n  Do Until TRC > 0               /* Display panel until END          */\n    Ispexec \"ADDPOP\"             /* Add pop-up window                */\n    Ispexec \"TBDISPL DSNENQ PANEL(CLCPQENQ)\"   /* TBDISPL panel      */\n    TRC = RC                     /* Save RC as \"TRC\"                 */\n    Ispexec \"REMPOP\"             /* Remove pop-up window             */\n  End                            /* Out on TRC Not = 0               */\n  Ispexec \"TBEND DSNENQ\"         /* Destroy table from QUERYENQ      */\nEnd                              /* -------------------------------- */\nIf QRC = 8 Then Do               /* If 8, No ENQ held                */\n  ZMSG000S = \" \"                 /* No short message                 */\n  ZMSG000L = \"No Other job holds a SYSDSN Enq on \"EQDSN\n  Ispexec 'SETMSG MSG(ISPZ000)'  /* Only a long message              */\nEnd                              /* -------------------------------- */\nIspexec \"LIBDEF ISPPLIB\"         /* Destroy panel LIBDEF             */\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT716/FILE716.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT716", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}