{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011517000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE215.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE215.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\r'", "DS1TRBAL": "b'>\\xf4'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\x91\\x00\\x0c\\x01\\x92\\x00\\x00\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x94\\x19O\\x01\\x00)\\x9f\\x112\\x000\\x000\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1994-07-13T00:00:00", "modifydate": "2000-10-25T11:32:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "WSBG"}, "text": "SMP/E Helper Tools\n\n   This simple collection consists of 2 CLISTs, and 3 articles from\n\"Technical Support\" magazine, showing how to use them.  The CLISTs\nare:\n\n      PTF       -  A CLIST to browse PTFs using the REVIEW command\n                   from the CBT Tape (File 134).  The \"database\"\n                   containing your PTFs is none other than the\n                   SMPPTS dataset.  Therefore, it is advisable not\n                   to purge PTFs after you ACCEPT them.  In any\n                   case, you can at least look at the ones you have\n                   currently.\n\n      SMPCLIST  -  This invokes SMP/E in the foreground as if it\n                   were running in background.  You enter background\n                   commands on the terminal, and GIMSMP's results\n                   are displayed line-by-line, on the terminal.\n                   Logging can be turned on or off.  Look at the\n                   CLIST to see the options.  I use this CLIST to\n                   make certain kinds of inquiries that are not\n                   easily made with the SMP/E ISPF interface.  Also,\n                   I use this CLIST to do UCLIN interactively, using\n                   LIST commands to check my work.\n\n                   Note - This CLIST was originally in VB-Lrecl 255\n                          format, and was converted to FB-Lrecl 80\n                          format by the clist conversion program on\n                          File 187 of the CBT Tape.  Therefore many\n                          of the long lines have been folded over.\n\n\nI have written several articles for \"Technical Support\" magazine\nregarding these CLISTS.  #ARTPTF is an article about the PTF clist.\n#ARTSMPC is about the SMPCLIST clist.  #ARTEXMP describes cases\nin which both clists were put to practical use.\n\nIf you have any questions or inquiries on this material, please\ncontact:\n\n       Sam Golob\n       P.O. Box 906\n       Tallman, NY 10982-0906\n\n    email:  sbgolob@attglobal.net  and/or  sbgolob@aol.com\n\nGood Luck.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#ARTEXMP": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x18$\\x01\\x13\\x01\\x13\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T18:24:00", "lines": 275, "newlines": 275, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         November 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n                                      (908) 901-0943\n\n Sam Golob is a Senior Systems Programmer living\n in New Jersey.\n\nHOW I FOLLOWED MY OWN ADVICE, AND, HOW NOT TO UPGRADE JES2 EXITS.\n\n      In our last two columns, we discussed two clists that are very\nuseful in SMP/E related areas.  The first clist called PTF, uses the\nTSO command called REVIEW from the CBT Tape to look at all your\nreceived ptfs.  The idea is to use your SMPPTS dataset as a data\nrepository to keep accurate information about recent system fixes.\nThe second clist, called SMPETSO, runs SMP/E in the foreground for the\npurpose of doing quick CSI inquiries and UCLIN adjustments.  These\nclists are illustrated in the two figures.  This month, I'd like to\ntell a true-to-life story about how I used my own tools.\n\n      The installation I'm now at, runs MVS/ESA 4.1 with JES2 4.1.0.\nThey have a JES2 Exit 1 routine which produces customized separator\npages for all non-FSSMODE printouts.  I've been told that this routine\nstopped working properly at the ESA 3.1.1 level.  At the 4.1 level, it\nstarted getting 0C4 abends at random intervals.  Clearly, something had\nto be done about the coding of this exit.\n\n\nTHE PROBLEM WITH JES EXIT UPGRADES.\n\n      I have to preface this discussion with the usual \"method\" of\nquickly upgrading JES2 exits from one JES2 release to another.  This\nmethod has been used since JES2 exits have been available, and we're\nprobably all \"guilty\" of exploiting it most of the time.  The idea is\nto obtain IBM's \"conversion notebook\" or whatever documentation they've\ndistributed to outline the changes (and pitfalls) of the new JES2\nrelease.  Then you assemble your old JES2 exit using the new JES2\nmacros you've just installed.  Finally, you fix any assembly errors\nthat happen, following the hints and instructions in the conversion\ndocument.  Then you \"run the sucker\" and if it doesn't bomb, you put it\ninto production.\n\n      I'm exaggerating just a wee bit, but you can probably see what\nis wrong with this picture.  In this process, there's no study as to\njust how the exit works.  It's all \"external\" and mechanical, and it\nassumes that IBM hasn't changed any of the logic interfacing with what\nthe exit does.  That's a very false assumption, since an installation's\ncustomized exit can do almost anything, and ultimately, it seems prudent\nfor the systems programmers to understand what mechanisms and processes\ntheir JES exits are actually using.\n\n      Our case seemed typical of the above mismanagement.  Tracing the\nimmediate cause of the 0C4 abends was the first problem.  I got help\nfrom several sources worth mentioning, one of whom was our esteemed\nfellow NaSPA member Tom Bryant, but I'll leave that discussion for\nanother time.  For now, I'll tell you what caused the abends, and how I\nfollowed my own advice to go about fixing them.  My particular case was\nrather specific, but my methods are so general, that you'll undoubtedly\nderive considerable benefit by looking over my shoulder.\n\n\nRDT ENTRIES, AND HOW THEY'RE SEARCHED.\n\n      Our abends were caused by a change in the construction of JES2's\nRDT or Remote Destination Table entries.  The RDT defines remote\nprinter addresses to JES2.  Our exit needed to read the RDT so the\nseparator page could display the remote node and destid of the printer\nbeing used to print the job.\n\n      Our exit was trying to read the RDT the \"old way\", across a\ncontiguous block of storage.  But IBM had actually changed the RDT's\nconstruction so it needed to be read another way, through entry\nchaining across non-contiguous pages.  IBM made that change, to allow\nfor dynamic adding of new remote destids through $ADD operator\ncommands.  Our installation services 2200 remote printers, with the RDT\ntable covering 14 scattered pages in storage.  The disparity between\ncontiguous reading, and non-contiguous construction of the RDT table\ncaused our exit to occasionally cross the page boundaries and try to\nlook at storage that JES2 hadn't GETMAIN'ed, resulting in the abend\n0C4's.\n\n      What does this have to do with our two clists?  Once the problem\nwas diagnosed, I had to determine the correct method of actually\nreading the RDT so I could fix our exit.  From looking at the dump, the\nRDT was a hodgepodge.  Whole pages were being GETMAIN'ed for RDT use.\nEach page had a heading marker.  It was not clear if the heading marker\nwas used to read the RDT entries, or just to tag pages earmarked for\nRDT use.  Entries were scattered across pages, usually crowded toward\nthe end of the page, and often an entry would point to the next entry\nseveral pages away.  I had to discover what IBM really wanted here.  To\nsolve my own problem with the user code, I wanted to imitate IBM's code\nexactly, or else we'd continue to get errors.\n\n      So in order to discover IBM's ways, I had to look at IBM's code.\nBut how do I find examples of IBM's code, at the correct maintenence\nlevel?  Each RDT entry is described by the JES2 macro called $RDT.  I\nused the SMPETSO clist to quickly find the UMID (update level) of this\nmacro.  It was at PTF level UY76237.  The $RDT macro in our exit's\nassembly listing had been marked at OY47804.  A LIST SYSMOD inquiry to\nSMPETSO revealed that apar BY47804 was indeed superseded by ptf\nUY76237, so we were looking at the current level of the $RDT macro.\n\n      My next deduction was that if IBM was indeed introducing a new\nconstruction of an RDT entry with ptf UY76237, they also would have to\nchange their own code to read the RDT the new way.  I'd bet that good\nold ptf UY76237 probably ALSO changed any JES2 code which had to read\nthe RDT.  That would be a good place for me to learn how to do the same\nthing for my exit's code.\n\n      I don't have to mention that my next step was to use the PTF\nclist to look at the actual text of ptf UY76237.  To find IBM code that\nhad been changed, I scanned the ptf for ++SRCUPD (source update) SMP\nstatements to look for likely examples.  A promising update was to\nthe module HASPIRRE that is a component of HASPINIT.  Another quick\nuse of the SMPETSO clist showed me that the HASPIRRE module was at\nRMID (replacement level) UY76237, and that the HASPIRRE source had\nUY76237 as its highest numbered UMID.  This indicated that an assembly\nlisting of HASPIRRE would probably produce a coding example that I\ncould copy for our exit's use.\n\n      Since UY76237 hadn't been ACCEPTed yet, I went to the SMPSTS\nto get the source code.  I assembled the code, using the SMPMTS as\nthe highest concatenated macro library, and was soon in possession\nof an assembly listing.  This listing quickly revealed that the RDT\nwas correctly searched by a 3-instruction loop, which ended in a\nzero pointer to the next RDT entry.  Case closed and problem solved.\nWe have another happy ending to a perplexing system problem.\n\n\nSO WHAT DO WE LEARN?\n\n      IBM introduces a lot of code rewrites and SPE's (Small\nProgramming Enhancements) in ptfs.  If you'll look at the actual text\nof a such a ptf, you'll have the basis of learning everything that IBM\nneeded to do with its own code, to make any necessary changes.  There\ncouldn't be a better learning example than that.  Of course, we were\nhelped immensely by the fact that JES2 is (still) distributed in\nsource code.  We can fully exploit these techniques while looking at\nJES2 or JES3 problems.  What could we gain from this method if the\nchanges were in object module form only and the ptf contains only\nobject modules?\n\n      In this forum, I can't recommend disassembling IBM's object\ndecks.  But I can recommend learning how to READ object decks, or I\ncan recommend linkediting them and use zapping tools to discover their\ncontents.  That is the subject of another session.  See Fred Schuff's\narticle in the May 1992 issue of \"Technical Support\" on the linkage\neditor.  Fred also talks there about some of the structure of object\ndecks.\n\n      More practically, we can point out that a ptf can always be\nexamined for the EXACT NAMES of all the components it affects.  If you\nexamine the actual ptf closely, you can learn a lot about what really\nwas changed, and how it was changed.  You are in possession of the\nactual changes, the \"genuine article\".  This is much better than only\nlooking at the cover letter.  Any changes to macros, which are in\nsource update form, or to source, if present, can shed additional\nlight on a problem resulting from IBM maintenance.\n\n      So to summarize:  Examining a ptf directly (through the PTF\nclist) and examining SMP/E entries directly (through the SMPETSO\nclist) are essential techniques for good system detective work.  I am\na great believer in not getting my information secondhand (from ISPF\nSMP/E inquiries) if it is available firsthand, from the ptfs and SMP/E\nentries themselves.  Learn ABOUT your system FROM your system!\n\n      Good luck in these and all future endeavors.  I'll see you next\nmonth.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   THE \"PTF\" INQUIRY CLIST.\n\n            This clist, which takes advantage of the capabilities of\n            the \"REVIEW\" TSO command on the CBT MVS Tape (File 134\n            for source and File 135 for load), is extremely simple,\n            but extremely useful.  Assemble REVIEW from File 134 or\n            copy the load module from File 135 and have fun.\n\n\n\n PROC 1 SYSM\n REVIEW 'SMPE.SMPPTS(&SYSM)'\n /*\n /*  This assumes that your PTS dataset is called SMPE.SMPPTS.\n /*\n /*  Assuming the member name of this clist is PTF, and it resides\n /*   in a library in the SYSPROC ddname concatenation of your TSO\n /*   session, you merely execute  %PTF UY78914 to look at ptf UY78914.\n /*   It's that simple.  PF3 to end.  You're back where you were.\n /*\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE 2.   THE SMP/E INQUIRY CLIST.  WE'LL CALL THIS CLIST \"SMPETSO\".\n\n       This CLIST invokes SMP/E in the foreground under TSO exactly\n       the same way as it would run in the background in batch.  Input\n       of commands and output of results go to the terminal.  Since\n       there might be quite a few lines of output, it is preferred\n       to run this CLIST in TSO \"Session Manager mode\", which can\n       preserve and print up to several thousand lines of TSO output.\n       See your TSO/E Customization Guide or this column in last\n       month's issue on how to set up your TSO session to run in\n       Session Manager mode.\n\n\n PROC  0  VOLID  CSI('SMPE.GLOBAL.CSI')  UNIT(DISK)  TYPE(SYS1)  NOLOG -\n          SYSOUT  LOGDISP(MOD)  NOPTS  LIST()  /**  YES OR NO  **/\n\n   SET VOLID = XRS003       /*  SMP-CONTROLLED PACK  */\n   IF LIST = YES  THEN  CONTROL LIST\n   ELSE  IF LIST = NO  THEN  CONTROL NOLIST\n\n   CONTROL PROMPT\n\n   WRITE ***********************************************************\n   WRITE *                                                         *\n   WRITE *     WELCOME TO THE SMP INQUIRY SYSTEM.  THIS MEANS      *\n   WRITE *          MAKE INQUIRIES ONLY  ........                  *\n   WRITE *                                                         *\n   WRITE ***********************************************************\n   WRITE\n   WRITE                  T Y P E  =   &TYPE\n   WRITE\n   WRITE             FOREGROUND EXECUTION OF SMP/E\n   WRITE\n   WRITE              SYSTEM DEFAULT  ====>  &TYPE\n   WRITE\n   WRITE            TYPE  =  &TYPE  MVS SP 4.1.0  DFP/ESA\n   WRITENR              ENTER DESIRED TYPE ====>\n   READ ANS\n\n   IF &LENGTH(&STR(&ANS)) \u00ac= 0  THEN SET TYPE=&STR(&ANS)\n   IF &TYPE = SYS1    THEN SET VOLID = XRS003   /*  TARGET PACK  */\n   IF &TYPE = SYS1    THEN SET DIST  = SMPDL1   /*   DLIB  PACK  */\n\n   WRITE\n   WRITE   YOU HAVE SPECIFIED  &TYPE AS THE SYSTEM.\n   WRITE   TARGET = &VOLID   ----  DISTRIBUTION = &DIST\n   WRITE\n\n   ERROR GO TO ENDALL\n   ATTN  GO TO ENDALL\n\n   ALLOC FI(SMPLIST) DA(*)\n   ALLOC FI(SMPCNTL) DA(*)\n   ALLOC FI(SMPRPT)  DUMMY\n\n   IF &NOLOG = NOLOG THEN ALLOC FILE(SMPLOG) DUMMY   /* NO SMP LOG */\n     ELSE ALLOC FI(SMPLOG) &LOGDISP KEEP DA('SMPE.GLOBAL.SMPLOG')\n\n   IF &NOPTS \u00ac= NOPTS  AND  TYPE = SYS1    +\n     THEN ALLOC FI(SMPPTS) SH REUSE DA('SMPE.GLOBAL.SMPPTS')\n\n   IF &SYSOUT = SYSOUT THEN ALLOC FI(SMPOUT) SYS(T)  /* HELD CLASS */\n     ELSE ALLOC FI(SMPOUT)  DA(*)\n\n   CALL  'SYS1.LINKLIB(GIMSMP)' 'CSI=&CSI'\n\n  ENDALL:  ERROR OFF\n           ATTN  OFF\n           FREE FI(SMPLIST SMPRPT SMPCNTL SMPLOG SMPOUT SMPPTS)\n\n  END\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#ARTPTF": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x18$\\x01(\\x01(\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T18:24:00", "lines": 296, "newlines": 296, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         September 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n                                      (908) 901-0943\n\nSOME SMP TOOLS YOU SHOULD HAVE.\n\n      I'm surprised at how a few incredibly simple tools can go a\nlong way.  Today, I'd like to talk about two very basic tricks in the\nSMP/E area and their simple implementations.  These will make life\nmuch easier for you when you do system maintenance or investigate\nproblems.\n\n      Idea number one:  Wouldn't it be nice to always have any PTF\nor usermod instantly available for inquiry?  This is not far from\nyour reach.  It's as close as one dataset, your SMPPTS.\n\n      If you have the disk space, it may not be a bad idea to let\nyour PTS dataset grow to 4000 or 5000 tracks or more.  (The only\ndisadvantage is that APPLY GROUP or GROUPEXTEND runs take considerably\nmore time.)  The PTS, in SMP/E, contains the actual text of received\nsysmods as members of a partitioned dataset.  This includes the text\nof all cover letters, as well as all modification control statements.\nThe PTS dataset is a gold mine to you, as a database for inquiry.  If\nyou have some simple way of browsing a member of this pds, you can\ninstantly investigate the mechanism of how any sysmod works, as well\nas all of the extra documentation that IBM wants you to know about.\nYou will be looking at the actual sysmod itself.\n\n      There's a simple-to-use and powerful browsing tool called REVIEW\non the CBT MVS Utilities Tape.  REVIEW is a TSO command that doesn't\ndepend on ISPF.  REVIEW can be called from a clist or a REXX exec.\nREVIEW, which is found in source code on File 134, and in load module\nform on File 135 of the CBT Tape, gives you instant ability to look at\nPTFs, and has multiple advantages over \"ISPF BROWSE\".  See Figure 1\nfor a simple clist called \"PTF\".  This clist can do wonders for you if\nyou'll try it and use it.\n\n      Why is REVIEW better than ISPF browse?  First, it's much faster.\nFor fixed blocked data, if you have a large dataset, it's possible to\ngo down to the bottom or \"DOWN 100000\" lines by figuring out the\ndestination TTR instead of by feeling your way down record by record.\nREVIEW is smart enough to do the math.  ISPF browse isn't.  If you say\n\"BOTTOM\" or \"DOWN M\" when REVIEWing a 400000 line fixed blocked\ndataset, you're there almost instantly.  Try doing that with BROWSE,\nthe first time you're looking at the dataset, and see how long you\nhave to wait.\n\n      Even in cases when it's impossible to do the math, and REVIEW\n\"knows\" it, REVIEW is better than BROWSE.  This can happen when you're\nREVIEWing a variable blocked dataset or doing a FIND command for a\nstring of data.  REVIEW can't get there instantly by doing calculations,\nbecause it has no way of knowing how big the blocks are, or in a string\nFIND, it can't skip over any of the data.  In that case, REVIEW will\ntell you how far it's gotten if you're tired of waiting.  BROWSE won't.\nHow?  When REVIEW is searching through many blocks of data and hasn't\nupdated the screen for you yet, all you have to do is press ATTENTION\n(or PA1) once.  REVIEW will stop in its tracks, displaying exactly how\nfar it has gotten.  Re-issue the same \"find\" command (there's a\nRETRIEVE pfkey) and REVIEW will continue looking from there.  There's\nno hint of such a facility in ISPF BROWSE.\n\n      So I recommend a CLIST with two lines:  \"PROC 1 SYSM\" is the\nfirst line, and \"REVIEW 'SMPE.SMPPTS(&SYSM)'\" is the second line.\n(Make sure you're pointing to your active PTS where the sysmods are.)\nIf you name the clist \"PTF\" and put it in a clist library that's part\nof your TSO SYSPROC ddname concatenation, all you have to do to\ninquire on PTF UY78912 is to type:  \"TSO %PTF UY78912\" under ISPF and\nyou've got it.  When you finish looking at the PTF and press PF3,\nyou're back in ISPF where you were before.  This will also work in\nnative TSO, because REVIEW doesn't need ISPF.  I recommend creating a\npfkey in ISPF called \"TSO\".  Then, to inquire on the PTF, you just\ntype:  \"%PTF UY78912\" and press the \"TSO\" pfkey.  There isn't anything\nmuch more simple or easy to set up, and this is very handy.\n\n      One more thing.  Please make sure you've installed the newer\nversion of REVIEW from Greg Price that's on File 134 of the CBT tape,\nrather than an older version.  The older version will suffice for\nthe PTF inquiry purpose, but it doesn't have the \"speed functions\"\nwe mentioned above.  Also, suppose you missed on the PTF number and\ntyped one that you don't have.  REVIEW will display it's \"null member\"\nscreen.  With Greg's version of REVIEW, you needn't worry.  Just type\nthe command:  \"DIR\" on the command line, and you get a full directory\nlist of the PTFs in your SMPPTS dataset.  There's an 8-byte command\nfield at the top of this member list which serves a \"locate\" function\nfor the member list.  Just type \"approximately\" the PTF number in\nthis field, and the list will be positioned close to where you want\nto go.  Type an \"S\" next to any member name, and you REVIEW it.\nIf you're running REVIEW under ISPF and the ISPF environment is there,\na \"B\" (instead of an \"S\") next to the member name will ISPF BROWSE the\nmember.  An \"E\" will ISPF EDIT it.  Of course, you don't want to\nedit IBM's PTFs, but you can use \"CREATE\" under EDIT to extract parts\nof the PTF or to copy its cover letter to another dataset.\n\n\nA SECOND TOOL - A CLIST TO RUN SMP/E IN THE FOREGROUND.\n\n      See Figure 2 for a clist that runs SMP/E in the foreground\nat your TSO terminal under native TSO.  This is \"idea number two\".\nWhich this clist, you can make many \"little inquiries\" and SMP\nadjustments with much more ease than with SMP/E's ISPF inquiry\nsystem.  You can carefully do small UCLIN adjustments (if you know\nwhat you're doing), and you can immediately look at the results by\ndoing the corresponding \"LIST\" commands, before and after the UCLIN.\nThis clist allocates the SMP/E log, so that your activities are\nchronicled there.\n\n      When you use this clist, which we can call \"SMPETSO\" for this\ndiscussion, you are actually running the SMP/E program GIMSMP as\nthough it were a batch job.  The difference is that you have to enter\nall of the commands (normally in SMPCNTL) at your terminal.  For\nexample, after the clist starts running, you must type in a \"SET BDY\"\ncommand in order to start your work.  The clist display's GIMSMP's\nnormal response.  Then you type your commands.  For example, you\nmight type:  \"LIST MOD (IFG0194K) .\"  You have to use strict SMP\nsyntax, with periods and all.  The result is displayed on your terminal.\nWhen you've finished, you type \"/*\" in column 1, and the GIMSMP program\nends.\n\n      Once you've used the SMPETSO clist for a while, you'll be\namazed at how handy it is to have.  I'd recommend using it for very\nsimple things most of the time.  It is intended for inquiries primarily,\nnot for MASS APPLY!  The capabilities of this CLIST are very much\nenhanced if you use the TSO session manager which comes with TSO/E.\nThe TSO session manager gives you up-down-right-left scrollability\nunder native TSO, and it preserves several thousand lines of TSO\noutput in your running session.  You aren't limited to just a screen\nfull of data that you can't recover.  In my travels, I've been extremely\nsurprised about people's ignorance of the session manager, even among\nIBM'ers.  See Figure 3 for simple information on invoking the TSO/E\nsession manager in your logon procedure.\n\n      The TSO session manager is extremely easy to set up.  You just\nhave to change the EXEC card in your TSO logon proc.  Figure 3 is\nprovided as a helpful hint.  You can make the whole change in two or\nthree minutes.\n\n      If you are in TSO in session manager mode, and you want to\nchange to the other mode, there is an authorized command called \"SM\"\non the CBT Tape (File 119) that can be used to toggle back and forth\nbetween modes.  If you have the SM command set up, you can instantly\nhave TSO the way you like it.  You can change modes with the flick\nof a finger.\n\n      I am sure these tools will help you in your work, especially\nthe simple PTF inquiry clist.  It's great for looking at APAR letters\nwhile you're doing PE research, or when you're on the phone with IBM.\nThe SMP/E execution clist allows you to do much more than the SMP ISPF\ninquiry, such as looking at the state of three or four entries at\nonce.  The SMP ISPF inquiry only allows you to see one entry at a\ntime, and it's a lot of trouble to switch and look at 3 or 4 other\nones.  Not so with the SMPETSO clist.  You can list as many entries\nin one inquiry as you feel like, just as in a batch job.  But you\ndon't have to wait as long for the answer.\n\n      These two tools have stood me in good stead over many years.\nIf you take an hour to set them up, they can do the same for you.\nGood luck.  I'll see you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   THE \"PTF\" INQUIRY CLIST.\n\n            This clist, which takes advantage of the capabilities of\n            the \"REVIEW\" TSO command on the CMT MVS Tape (File 134\n            for source and File 135 for load), is extremely simple,\n            but extremely useful.  Assemble REVIEW from File 134 or\n            copy the load module from File 135 and have fun.\n\n\n\n PROC 1 SYSM\n REVIEW 'SMPE.SMPPTS(&SYSM)'\n /*\n /*  This assumes that your PTS dataset is called SMPE.SMPPTS.\n /*\n /*  Assuming the member name of this clist is PTF, and it resides\n /*   in a library in the SYSPROC ddname concatenation of your TSO\n /*   session, you merely execute  %PTF UY78912 to look at ptf UY78912.\n /*   It's that simple.  PF3 to end.  You're back where you were.\n /*\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 2.   THE SMP/E INQUIRY CLIST.  WE'LL CALL THIS CLIST \"SMPETSO\".\n\n       This clist invokes SMP/E in the foreground under TSO in exactly\n       the same way as it would run in the background in batch.  Input\n       of commands and output of results go to the terminal.  Since\n       there might be quite a few lines of output, it is preferred\n       to run this clist in TSO \"session manager mode\", which can\n       preserve and print up to several thousand lines of TSO output.\n       See Figure 3 on how to set up session manager mode for your\n       TSO session.\n\n\n PROC  0  VOLID  CSI('SMPE.GLOBAL.CSI')  UNIT(DISK)  TYPE(SYS1)  NOLOG -\n          SYSOUT  LOGDISP(MOD)  NOPTS  LIST()  /**  YES OR NO  **/\n\n   SET VOLID = XRS003       /*  SMP-CONTROLLED PACK  */\n   IF LIST = YES  THEN  CONTROL LIST\n   ELSE  IF LIST = NO  THEN  CONTROL NOLIST\n\n   CONTROL PROMPT\n\n   WRITE ***********************************************************\n   WRITE *                                                         *\n   WRITE *     WELCOME TO THE SMP INQUIRY SYSTEM.  THIS MEANS      *\n   WRITE *          MAKE INQUIRIES ONLY  ........                  *\n   WRITE *                                                         *\n   WRITE ***********************************************************\n   WRITE\n   WRITE                  T Y P E  =   &TYPE\n   WRITE\n   WRITE             FOREGROUND EXECUTION OF SMP/E\n   WRITE\n   WRITE              SYSTEM DEFAULT  ====>  &TYPE\n   WRITE\n   WRITE            TYPE  =  &TYPE  MVS SP 4.1.0  DFP/ESA\n   WRITENR              ENTER DESIRED TYPE ====>\n   READ ANS\n\n   IF &LENGTH(&STR(&ANS)) \u00ac= 0  THEN SET TYPE=&STR(&ANS)\n   IF &TYPE = SYS1    THEN SET VOLID = XRS003   /*  TARGET PACK  */\n   IF &TYPE = SYS1    THEN SET DIST  = SMPDL1   /*   DLIB  PACK  */\n\n   WRITE\n   WRITE   YOU HAVE SPECIFIED  &TYPE AS THE SYSTEM.\n   WRITE   TARGET = &VOLID   ----  DISTRIBUTION = &DIST\n   WRITE\n\n   ERROR GO TO ENDALL\n   ATTN  GO TO ENDALL\n\n   ALLOC FI(SMPLIST) DA(*)\n   ALLOC FI(SMPCNTL) DA(*)\n   ALLOC FI(SMPRPT)  DUMMY\n\n   IF &NOLOG = NOLOG THEN ALLOC FILE(SMPLOG) DUMMY   /* NO SMP LOG */\n     ELSE ALLOC FI(SMPLOG) &LOGDISP KEEP DA('SMPE.GLOBAL.SMPLOG')\n\n   IF &NOPTS \u00ac= NOPTS  AND  TYPE = SYS1    +\n     THEN ALLOC FI(SMPPTS) SH REUSE DA('SMPE.GLOBAL.SMPPTS')\n\n   IF &SYSOUT = SYSOUT THEN ALLOC FI(SMPOUT) SYS(T)  /* HELD CLASS */\n     ELSE ALLOC FI(SMPOUT)  DA(*)\n\n   CALL  'SYS1.LINKLIB(GIMSMP)' 'CSI=&CSI'\n\n  ENDALL:  ERROR OFF\n           ATTN  OFF\n           FREE FI(SMPLIST SMPRPT SMPCNTL SMPLOG SMPOUT SMPPTS)\n\n  END\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFigure 3.   SETTING UP TSO SESSION MANAGER IN YOUR TSO LOGON PROC.\n\n            By changing the coding of the EXEC card slightly in\n            your TSO logon procedure, you can invoke TSO in session\n            manager mode.  Session manager mode preserves several\n            thousand lines of TSO output, which is scrollable.\n            The output is also 255 characters wide, and may be\n            printed using the \"SMCOPY\" TSO command.  Every TSO/E\n            system is equipped for session manager mode, and help\n            for SMCOPY is shipped by TSO/E in SYS1.HELP.\n\n\n To use the TSO session manager, code the EXEC card of your TSO logon\n procedure as follows:    (Refer to the \"TSO/E Customization\" manual.)\n\n\n //PROCNAME  EXEC  PGM=ADFMDF03,PARM='SM(IKJEFT01,Y),%LOGCLST',\n //          DYNAMNBR=100\n\n\n instead of:\n\n\n //PROCNAME  EXEC  PGM=IKJEFT01,PARM='%LOGCLST',DYNAMNBR=100\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#ARTSMPC": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x18$\\x00\\xf3\\x00\\xf3\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T18:24:00", "lines": 243, "newlines": 243, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         October 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n                                      (908) 901-0943\n\nSMP TOOLS YOU SHOULD HAVE:  PART II - A CLIST to run SMP/E in the\n      Foreground.\n\n      Sometimes you can get a lot of work done by taking advantage of\na few simple ideas.  It is possible to save yourself a lot of time\nwith some very simple mechanisms that take just a few minutes to\ninstall.  Last month, we talked about one such idea--a simple CLIST\nthat is very helpful for SMP/E PTF inquiry.  This month, we'll\nintroduce another CLIST.\n\n      This second CLIST invokes SMP/E in the foreground and is useful\nfor CSI inquiries and quick changes.  We shall call this CLIST,\nSMPETSO.  Since SMPETSO works better when your TSO session is running\nin \"session manager mode\" under TSO/E, we'll show you how to set up\nthe TSO session manager, with about three minutes of work.\n\n      See Figure 1 for an coded example of the SMPETSO CLIST.  Using\nSMPETSO, you can make \"little inquiries\" and SMP adjustments with much\nmore ease than with SMP/E's ISPF inquiry system.  You can also do\nsmall UCLIN changes (if you know what you're doing).  You can\nimmediately see the results by doing the corresponding \"LIST\"\ncommands before and after each UCLIN.  SMPETSO allocates the SMP/E\nlog, so that all activities are chronicled there.\n\n      SMPETSO actually runs the SMP/E program GIMSMP as though it were\na batch job.  The difference is that you have to enter all of the SMP/E\ncommands (normally in SMPCNTL) at your terminal.  For example, after\nthe CLIST starts running, you must type in a \"SET BDY\" command in\norder to start your work.  SMPETSO displays GIMSMP's normal response.\nThen you type other commands.  For example, you might type:  \"LIST MOD\n(IFG0194K) .\"  You have to use strict SMP syntax, with periods and\nall.  The result is displayed at the terminal.  When you've finished,\ntype \"/*\" in column 1, and the GIMSMP program ends.\n\n      Once you've used the SMPETSO CLIST for a while, you'll be amazed\nat how handy it is to have.  I'd recommend using it for very simple\nthings most of the time.  It is intended for inquiries primarily, not\nfor MASS APPLY!  The capabilities of this CLIST are very much enhanced\nif you use the TSO session manager which comes with TSO/E.  The TSO\nsession manager gives you up-down-right-left scrollability under native\nTSO, and it preserves several thousand lines of TSO output in your\nrunning session.  You aren't limited to just a screen full of data that\nyou can't recover.  From my travels, I've been extremely surprised\nabout people's ignorance of the session manager, even among IBM'ers.\nSee Figure 2 for simple information on invoking the TSO/E session\nmanager in your logon procedure.  You can make the whole change in two\nor three minutes.\n\n      If you are in TSO in session manager mode and you want to change\nto the \"ordinary\" mode, there is an authorized command called \"SM\" on\nthe CBT Tape (File 119) that can be used to toggle back and forth\nbetween modes.  If you have the SM command set up, you can instantly\nhave TSO the way you like it.  You can change modes with the flick of a\nfinger.\n\n      Our SMPETSO CLIST frequently allows you to do much more than the\nIBM-supplied SMP/E ISPF inquiry.  For example, we can look at three or\nfour SMP entries at once, such as MOD, MAC or SYSMOD entries.  The\nSMP/E ISPF cross-zone query only allows you to see one entry at a\ntime, and it's a lot of trouble to switch and look at 3 or 4 other\nentries.  Using the SMPETSO CLIST, you can list as many entries with\none inquiry as you feel like, just as in a batch job.\n\n      For example, try doing the equivalent of the command:\n        \"LIST MOD(IFG0194A IFG0194F).\"\nusing the SMP/E ISPF cross zone inquiry.  If you're only looking in\none zone, you'll have to admit that the SMPETSO CLIST is better.\nSee Figure 3 for sample output of this command.\n\n      This SMPETSO CLIST has been very helpful to me over the years.\nTake a few minutes to set it up and use it, and it can be just as\nuseful to you.  Good luck.  I'll see you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 1.   THE SMP/E INQUIRY CLIST.  WE'LL CALL THIS CLIST \"SMPETSO\".\n\n       This CLIST invokes SMP/E in the foreground under TSO exactly\n       the same way as it would run in the background in batch.  Input\n       of commands and output of results go to the terminal.  Since\n       there might be quite a few lines of output, it is preferred\n       to run this CLIST in TSO \"Session Manager mode\", which can\n       preserve and print up to several thousand lines of TSO output.\n       See Figure 2 on how to set up Session Manager mode for your\n       TSO session.\n\n\n PROC  0  VOLID  CSI('SMPE.GLOBAL.CSI')  UNIT(DISK)  TYPE(SYS1)  NOLOG -\n          SYSOUT  LOGDISP(MOD)  NOPTS  LIST()  /**  YES OR NO  **/\n\n   SET VOLID = XRS003       /*  SMP-CONTROLLED PACK  */\n   IF LIST = YES  THEN  CONTROL LIST\n   ELSE  IF LIST = NO  THEN  CONTROL NOLIST\n\n   CONTROL PROMPT\n\n   WRITE ***********************************************************\n   WRITE *                                                         *\n   WRITE *     WELCOME TO THE SMP INQUIRY SYSTEM.  THIS MEANS      *\n   WRITE *          MAKE INQUIRIES ONLY  ........                  *\n   WRITE *                                                         *\n   WRITE ***********************************************************\n   WRITE\n   WRITE                  T Y P E  =   &TYPE\n   WRITE\n   WRITE             FOREGROUND EXECUTION OF SMP/E\n   WRITE\n   WRITE              SYSTEM DEFAULT  ====>  &TYPE\n   WRITE\n   WRITE            TYPE  =  &TYPE  MVS SP 4.1.0  DFP/ESA\n   WRITENR              ENTER DESIRED TYPE ====>\n   READ ANS\n\n   IF &LENGTH(&STR(&ANS)) \u00ac= 0  THEN SET TYPE=&STR(&ANS)\n   IF &TYPE = SYS1    THEN SET VOLID = XRS003   /*  TARGET PACK  */\n   IF &TYPE = SYS1    THEN SET DIST  = SMPDL1   /*   DLIB  PACK  */\n\n   WRITE\n   WRITE   YOU HAVE SPECIFIED  &TYPE AS THE SYSTEM.\n   WRITE   TARGET = &VOLID   ----  DISTRIBUTION = &DIST\n   WRITE\n\n   ERROR GO TO ENDALL\n   ATTN  GO TO ENDALL\n\n   ALLOC FI(SMPLIST) DA(*)\n   ALLOC FI(SMPCNTL) DA(*)\n   ALLOC FI(SMPRPT)  DUMMY\n\n   IF &NOLOG = NOLOG THEN ALLOC FILE(SMPLOG) DUMMY   /* NO SMP LOG */\n     ELSE ALLOC FI(SMPLOG) &LOGDISP KEEP DA('SMPE.GLOBAL.SMPLOG')\n\n   IF &NOPTS \u00ac= NOPTS  AND  TYPE = SYS1    +\n     THEN ALLOC FI(SMPPTS) SH REUSE DA('SMPE.GLOBAL.SMPPTS')\n\n   IF &SYSOUT = SYSOUT THEN ALLOC FI(SMPOUT) SYS(T)  /* HELD CLASS */\n     ELSE ALLOC FI(SMPOUT)  DA(*)\n\n   CALL  'SYS1.LINKLIB(GIMSMP)' 'CSI=&CSI'\n\n  ENDALL:  ERROR OFF\n           ATTN  OFF\n           FREE FI(SMPLIST SMPRPT SMPCNTL SMPLOG SMPOUT SMPPTS)\n\n  END\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFigure 2.   SETTING UP TSO SESSION MANAGER IN YOUR TSO LOGON PROC.\n\n            By changing the coding of the EXEC card slightly in\n            your TSO logon procedure, you can invoke TSO in session\n            manager mode.  Session manager mode preserves several\n            thousand lines of TSO output, which can be viewed by\n            either scrolling, or printing with the SMCOPY TSO command.\n            TSO Session Manager output is 255 characters wide.\n            Every TSO/E release includes software for session manager\n            mode, and help to use SMCOPY is shipped by TSO/E in\n            SYS1.HELP.\n\n\n To use the TSO session manager, code the EXEC card of your TSO logon\n procedure as follows:    (Refer to the \"TSO/E Customization\" manual\n for further details.)\n\n\n //PROCNAME  EXEC  PGM=ADFMDF03,PARM='SM(IKJEFT01,Y),%LOGCLST',\n //          DYNAMNBR=100\n\n\n instead of:\n\n\n //PROCNAME  EXEC  PGM=IKJEFT01,PARM='%LOGCLST',DYNAMNBR=100\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   SAMPLE OUTPUT OF AN SMP/E COMMAND USING SMPETSO.\n            The \"SET BDY(XRS003).\" command to look at target zone XRS003\n            has been omitted for the sake of brevity.\n\n (Editor:   The period in the above description is technical and is\n       necessary to show, as it is written.  Thanks. )\n\nlist mod(ifg0194a ifg0194f).\nLIST MOD(IFG0194A IFG0194F).\n\nDATE 92.236  TIME 15:21:09  GIMSMP LVL 15.1.19 SMPLIST OUTPUT - NOW SET\n  TO TARGET ZONE XRS003                      PAGE 0001\n\nLIST MOD(IFG0194A IFG0194F).\n\nDATE 92.236  TIME 15:21:09  GIMSMP LVL 15.1.19 SMPLIST OUTPUT - NOW SET\n  TO TARGET ZONE XRS003                      PAGE 0002\n\nXRS003  MODULE  ENTRIES\n\n  NAME\n\nIFG0194A  LASTUPD           = HDP3320  TYPE=ADD\n          LIBRARIES         = DISTLIB=AOSD0\n          FMID              = HDP3320\n          RMID              = UY69467\n          TALIAS            = IFG0204A  IFG0554A\n          LMOD              = IFG0194A\n\nIFG0194F  LASTUPD           = HDP3320  TYPE=ADD\n          LIBRARIES         = DISTLIB=AOSD0\n          FMID              = HDP3320\n          RMID              = UY79106\n          TALIAS            = IFG0554F\n          LMOD              = IFG0194A\n\nDATE 92.236  TIME 15:21:09  GIMSMP LVL 15.1.19 SMPLIST OUTPUT - NOW SET\n  TO TARGET ZONE XRS003                      PAGE 0003\n\nLIST     SUMMARY REPORT FOR XRS003\n\nENTRY-TYPE   ENTRY-NAME   STATUS\n\nMODULE       IFG0194A     STARTS ON PAGE 0002\nMODULE       IFG0194F     STARTS ON PAGE 0002\nGIM20501I    LIST PROCESSING IS COMPLETE. THE HIGHEST RETURN CODE WAS 00.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PTF": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x92\\x18O\\x00\\x94\\x19O\\x16\\x06\\x00\\x0b\\x00\\x04\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1992-07-02T00:00:00", "modifydate": "1994-07-13T16:06:00", "lines": 11, "newlines": 4, "modlines": 0, "user": "SBGCSC"}, "text": "/*   THIS CLIST USES THE \"REVIEW\" PROGRAM FROM FILE 134 OF THE CBT   */\n/*   TAPE.  A LOAD MODULE FOR THE \"REVIEW\" PROGRAM MAY BE FOUND ON   */\n/*   FILE 135 OF THE CBT TAPE.  \"REVIEW\" IS A SOPHISTICATED TSO      */\n/*   FULLSCREEN FILE BROWSER, WHICH DOES NOT NEED ISPF TO FUNCTION.  */\n/*   IF YOUR SMPPTS FILE IS CATALOGED, YOU SHOULD REMOVE THE \"VOL\"   */\n/*   PARAMETER.                                                      */\n/*                                                                   */\n PROC 1 PTF CSI('SMPEZ.GLOBAL.SMPPTS') VL(ZGLB01)\n CONTROL NOLIST\n REVIEW '&CSI(&PTF)' VOL(&VL)\n EXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMPCLIST": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x00\\x92\\x18\\x8f\\x00\\x94\\x19O\\x15X\\x00I\\x00=\\x00\\x17\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1992-07-06T00:00:00", "modifydate": "1994-07-13T15:58:00", "lines": 73, "newlines": 61, "modlines": 23, "user": "SBGCSC"}, "text": "/* THIS CLIST INVOKES SMP/E INTERACTIVELY, SENDING OUTPUT TO THE   */\n/*  TSO USER'S TERMINAL.  POINT THE CSI DEFAULT TO THE GLOBAL ZONE */\n/*  THAT YOU ARE USING.  THE REST OF THIS STUFF SHOULD BE SELF-    */\n/*  EVIDENT.  I.E. YOU SHOULD BE EASILY ABLE TO FIGURE IT OUT.     */\n/*                                                                 */\n/* NOTE:  THIS CLIST USED TO BE VB-LRECL 255, AND WAS CONVERTED    */\n/*  TO FB-LRECL 80 BY THE CVTCLIST PROGRAM ON FILE 187 OF THE CBT  */\n/*  TAPE.  THE LONG LINES HAVE BEEN FOLDED OVER.  ACTUALLY, THIS   */\n/*  CLIST \"LOOKS\" A LOT BETTER WHEN IT IS IN VB-255 FORMAT, WITH   */\n/*  THE LONG LINES.                                                */\n/*                                                                 */\nPROC 0  VOLID  CSI('SMPEZ.GLOBAL.CSI')     UNIT(DISK) -\n  TYPE(SYS1) NOLOG SYSOUT LOGDISP(MOD) NOPTS -\n         LIST()  /*** YES OR NO ****/\n   SET VOLID= ZRS001\n IF &LIST = YES THEN -\n     CONTROL LIST\n ELSE -\n IF &LIST = NO THEN -\n     CONTROL NOLIST\nPASSTYPE: -\nCLEAR\nCONTROL PROMPT\nWRITE *****************************************************************-\n*************\nWRITE *                                                                -\n            *\nWRITE *    WELCOME TO THE SMP INQUIRY SYSTEM.  THIS MEANS MAKE INQUIRIE-\nS ONLY.     *\nWRITE *                                                                -\n            *\nWRITE *****************************************************************-\n*************\nWRITE                               T Y P E = &TYPE\nWRITE\nWRITE                   ====> FOREGROUND EXECUTION OF SMP/E <====\nWRITE\nWRITE                       ***  SYSTEM DEFAULT ==> &TYPE  ***\nWRITE\nWRITE                        TYPE = &TYPE MVS SP 4.3.0 DFSMS\nWRITENR                         ENTER DESIRED TYPE ===>\nREAD ANS\nIF &LENGTH(&STR(&ANS))\u00ac=0 THEN SET TYPE=&STR(&ANS)\nIF &TYPE = SYS1      THEN SET VOLID = ZRS001\nIF &TYPE = SYS1      THEN SET DIST  = ZGLB01\nWRITE\nWRITE              ===> YOU HAVE SPECIFIED  &TYPE AS THE SYSTEM. <===\nWRITE              ===> TARGET = &VOLID --- DISTRIBUTION = &DIST <===\nERROR -\n   GOTO ENDALL\nATTN -\n   GOTO ENDALL\nALLOC FI(SMPOUT)   DA(*)\nALLOC FI(SMPLIST)  DA(*)\nALLOC FI(SMPCNTL)  DA(*)\nALLOC FI(SMPRPT)   DUMMY\nIF &NOLOG = NOLOG THEN ALLOC FILE(SMPLOG) DUMMY\n ELSE ALLOC FI(SMPLOG) &LOGDISP KEEP DA('SMPEZ.GLOBAL.SMPLOG') SH\nIF &NOLOG = NOLOG THEN ALLOC FILE(SMPLOGA) DUMMY\n ELSE ALLOC FI(SMPLOGA) &LOGDISP KEEP DA('SMPEZ.GLOBAL.SMPLOGA') SH\nIF &NOPTS \u00ac= NOPTS AND     +\n &TYPE = SYS1 THEN ALLOC FILE(SMPPTS) DA('SMPEZ.GLOBAL.SMPPTS') SH\nALLOC FI(SMPCNTL)      DA(*)\nIF &SYSOUT = SYSOUT THEN ALLOC F(SMPOUT) SYS(T)\n    ELSE ALLOC FI(SMPOUT)       DA(*)\nCALL '&TYPE..LINKLIB(GIMSMP)' 'CSI=&CSI'\nENDALL: -\nERROR OFF\nATTN OFF\nFREE FI(SMPLIST  SMPRPT        SMPCNTL     -\n      SMPLOGA  SMPLOG SMPOUT SMPPTS        )\n/*  FREE DA('&TYPE..LINKLIB')\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT215/FILE215.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT215", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}