{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013455000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE925.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE925.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\x07'", "DS1TRBAL": "b'[\\x1c'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\tY\\x00\\x01\\tY\\x00\\x05\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04Z\\x00)\\x01\\x15\\x01/\\x01\\x15\\x01/\\x01\\x01\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf0@@@'", "ispf": {"version": "04.90", "flags": 0, "createdate": "2015-01-12T00:00:00", "modifydate": "2015-01-12T01:01:29", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-490"}, "text": "REGULAR CBT TAPE - VERSION 490    FILE:  925\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT490.FILE925\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 6 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,431 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   01/12/15    01:01:29    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE925": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04Z\\x00\\x18\\x01\\x15\\x01/\\x01\\x15\\x01/\\x01\\x01\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf0@@@'", "ispf": {"version": "04.90", "flags": 0, "createdate": "2015-01-12T00:00:00", "modifydate": "2015-01-12T01:01:18", "lines": 7, "newlines": 7, "modlines": 0, "user": "CBT-490"}, "text": "//***FILE 925 is from Robert Glover and contains a method of        *   FILE 925\n//*           conveniently enlarging dataset, both non-VSAM and     *   FILE 925\n//*           VSAM.  Basically these are two REXX execs with two    *   FILE 925\n//*           panels that help to automate the process.             *   FILE 925\n//*                                                                 *   FILE 925\n//*           email:  im4fsu@comcast.net                            *   FILE 925\n//*                                                                 *   FILE 925\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENL": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00V\\x01\\x10 \\x7f\\x01\\x144O\\x14I\\x02\\xfc\\x01\\xea\\x00\\x00\\xe3\\xe2\\xf0\\xf7\\xf1\\xf0@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2010-07-26T00:00:00", "modifydate": "2014-12-10T14:49:56", "lines": 764, "newlines": 490, "modlines": 0, "user": "TS0710"}, "text": "/* REXX */\n/*----------------------------------------------------------------------------*/\n/* Enlarge a dataset -                                                        */\n/* DSORGs supported are : PS, PDS, PDSE                                       */\n/*                        VS(KSDS, ESDS, RRDS, LINEAR)                        */\n/*----------------------------------------------------------------------------*/\n/* How-To call                                                                */\n/* 1. \"ENL  MYDSNAME.XYZ\"     (A la 3.4)                                      */\n/* 2. \"TSO ENL MYDSNAME.XYZ\"  (TSO CMD)                                       */\n/*                                                                            */\n/* It does the following to the dataset being enlarged:                       */\n/*     (NON-VSAM)                                                             */\n/*  1) Create \"*.NEW\" version                                                 */\n/*  2) Copy   the DS to \"*.NEW\"                                               */\n/*  3) Rename the DS to \".OLD\"                                                */\n/*  4) Rename the \".NEW\" to DS                                                */\n/*  5) Delete the \".OLD\" (if no errors)                                       */\n/*                                                                            */\n/*     (VSAM)                                                                 */\n/*  1) Create \"*.NEW\" version                                                 */\n/*  2) REPRO  the DS to \"*.NEW\"                                               */\n/*  3) Rename the DS to \".OLD\"                                                */\n/*  4) Rename the \".NEW\" to DS                                                */\n/*  5) Delete the \".OLD\" (if no errors)                                       */\n/*                                                                            */\n/* Dataset ALIASES:                                                           */\n/*  If any are detected, the user is alerted and must                         */\n/*  decide whether to continue or not. Continuing always                      */\n/*  DELETES the affected aliases (ALL of them!). If done,                     */\n/*  the user MUST redefine them.                                              */\n/*                                                                            */\n/* NOTES:                                                                     */\n/* =====                                                                      */\n/* > Routine \"CHECK_SECURITY\" calls a RACF facility to determine              */\n/*   ALTER authority. This may need changing to fit your                      */\n/*   environment.                                                             */\n/*                                                                            */\n/* > Any significant error causes the rest of the rtns to be                  */\n/*   bypassed, along with an error message.                                   */\n/*============================================================================*/\n/*                     WHEN MYRC/MYRCV <> 0                                   */\n/*                                                                            */\n/* If RC <> 0 we cannot count on the final product being correct              */\n/*  and so the following grid recommends what to do if these cases arise      */\n/* All recovery actions should be thoroughly investigated before actions      */\n/*                                                                            */\n/*                    RECOVERY DECISION MATRIX                                */\n/*                                                                            */\n/* YES(exists); NO(no exists)                                                 */\n/* DSN (Original ds); .NEW (Enlarged version); .OLD (Original renamed)        */\n/* ------------------------------ C A S E 1 ----------------------------------*/\n/* |  DSN YES | Delete *.NEW to keep original                                 */\n/* | .NEW YES |                                                               */\n/* | .OLD NO  |                                                               */\n/* ---------------------------------------------------------------------------*/\n/* ------------------------------ C A S E 2 ----------------------------------*/\n/* |  DSN YES | Delete DSN, rename *.OLD to get back to original              */\n/* | .NEW NO  |                                                               */\n/* | .OLD YES |                                                               */\n/* ---------------------------------------------------------------------------*/\n/* ------------------------------ C A S E 3 ----------------------------------*/\n/* |  DSN YES | No action, original is unchanged                              */\n/* | .NEW NO  |                                                               */\n/* | .OLD NO  |                                                               */\n/* ---------------------------------------------------------------------------*/\n/* ------------------------------ C A S E 4 ----------------------------------*/\n/* |  DSN No  | Delete *.NEW & rename *.OLD to get back to original           */\n/* | .NEW YES |                                                               */\n/* | .OLD YES |                                                               */\n/* ---------------------------------------------------------------------------*/\n/*----------------------------------------------------------------------------*/\n\nparse arg dsn\n\nMAINLINE:\n  Call HOUSEKEEP                    /* The usual                   */\n/*-------------------------*/\n/* You can un-comment the  */\n/* \"CHECK_SECURITY\" call if*/\n/* you want RACF checking  */\n/* ahead of time.          */\n/*                         */\n/*Call CHECK_SECURITY      */       /* Check for ALTER authority   */\n/*-------------------------*/\n  Call CLEAN_UP                     /* Clean up residual stuff     */\n  Call ALLOC_LISTCAT                /* Free/ALLOC LISTCAT FILES    */\n  Call CREATE_SYSIN                 /* Create LISTCAT Input STMNTS */\n  Call LISTCAT                      /* Run LISTCAT on dataset      */\n  Call PROCESS_LISTCAT              /* Analyze LISTCAT output      */\n  Call ALERT_USER                   /* Inform User of DS ALIASes   */\n  Call GET_DSINFO                   /* Find out about the dataset  */\n  Call CLEAN_UP                     /* Clean up residual stuff     */\n  Call ALLOC_GENERAL                /* Alloc general wrk Datasets  */\n  Call USER_CHANGES                 /* Request changes from user   */\n  Call ALLOC_SPECIFIC               /* Alloc specific wrk datasets */\n  Call USER_APPROVAL                /* Give user \"GO-NOGO\"         */\n  Call COPY_IT                      /* Run the copy                */\n  Call RENAME_IT                    /* Run the renames             */\n  Call CLEAN_UP                     /* Clean one last time         */\n  Call ADIOS                        /* Parting msgs                */\n  address ispexec\n   ZISPFRC = MYRC\n   \" VPUT (ZISPFRC) SHARED \"\nreturn MYRC\n\nHOUSEKEEP:\n  if dsn='' then\n    do forever\n      say 'Enter DSname to be enlarged or \"EXIT\"'\n      parse upper pull dsn\n      if dsn = 'EXIT' then exit\n      if dsn <> '' then leave\n    end\n  dsn=strip(dsn,b,\"'\")\n  valid='YES'\n  mydsn=translate(dsn,' ','.')\n  #levels=words(mydsn)\n  if length(mydsn) > 44 | #levels < 1 then\n    valid='NO'\n  if valid='YES' then\n    do x1=1 to #levels\n      hotlev=word(mydsn,x1)\n      if length(hotlev) > 8 then\n        do\n          valid='NO'\n          leave\n        end\n      sc=substr(hotlev,1,1)\n      if sc > 'Z' then\n        do\n          valid='NO'\n          leave\n        end\n      if sc < 'A' then\n        if sc <> '@' then\n          if sc <> '#' then\n            if sc <> '$' then\n              do\n                valid='NO'\n                leave\n              end\n    end\n  if valid='NO' then\n    do\n      say 'DSNAME of '''dsn''' is invalid'\n      say 'REXX ends'\n      myrc=20\n      exit\n    end\n  eldsn=dsn\n  myid=SYSVAR(SYSUID)\n  dashes=right('-',80,'-')\n  myrc=0\n  myrcv=0\nreturn\n\nCHECK_SECURITY:\n  if myrc <> 0 then return\n  stuff = msg(on)\n  TSOCMD='LD DA('||dsn||') GEN ALL'\n  address tso\n  stuff=outtrap(line.)                  /* set the trap          */\n  TSOCMD\n  stuff=outtrap('off')                  /* close trap            */\n  checkon = 0\n\n  READLU:\n    do i = 1 to line.0\n        IF SUBSTR(LINE.I,1,19) = \"NO RACF DESCRIPTION\" THEN\n          do\n            access = 'NONE'\n            leave\n          end\n        if substr(line.i,1,14) = \"NOT AUTHORIZED\" then\n          do\n            access = 'NONE'\n            leave\n          end\n        if substr(line.i,1,15) = \"INFORMATION FOR\" then\n          do\n          end\n        if substr(line.i,1,13) = \"YOUR ACCESS  \" then\n          do\n            checkon = 1\n          end\n        if checkon = 1 & substr(line.i,1,11) = \"-----------\" then\n          do\n            checkon = 2\n          end\n        if checkon = 2 & substr(line.i,1,5) = \"     \" then\n          do\n            checkon = 0\n          end\n        IF CHECKON = 2 & SUBSTR(LINE.I,1,11) \u00ac= \"-----------\" THEN\n          do\n            access = substr(line.i,1,10)\n            access = strip(access,'B')\n          end\n    end\n    stuff = msg(off)\n    if access <> 'ALTER' then\n      do\n        say 'You do not have RACF \"ALTER\" authority to 'dsn\n        say 'REXX ends'\n        myrc=16\n        return\n      end\nreturn\n\nALLOC_LISTCAT:\n  if myrc <> 0 then return\n  address tso\n    \"FREE FI(SYSIN,SYSPRINT)\"\n    \"DELETE ('\"myid\".ENL.SYSIN')\"\n    \"DELETE ('\"myid\".ENL.SYSPRINT')\"\n    \"ALLOCATE FI(SYSIN) DA('\"myid\".ENL.SYSIN') NEW CATALOG\n                 SPACE(1,1) TRACKS RECFM(F B) LRECL(80) BLKSIZE(27920)\"\n    if rc /= 0 then\n      do\n        say myid'.ENL.SYSIN allocation error'\n        say ' Reason follows:'\n        say ' '\n        x=MSG(ON)\n        xx=OUTTRAP(BADALLOC.)\n        \"ALLOCATE FI(SYSIN) DA('\"myid\".ENL.SYSIN') NEW CATALOG\n                     SPACE(1,1) TRACKS RECFM(F B) LRECL(80) BLKSIZE(27920)\"\n        xx=OUTTRAP(OFF)\n        do x2=1 to badalloc.0\n          say badalloc.x2\n        end\n        say 'Rexx ends'\n        myrc=16\n        return\n      end\n    \"ALLOCATE FI(SYSPRINT) DA('\"myid\".ENL.SYSPRINT') NEW CATALOG REUSE\n                 SPACE(2,2) TRACKS RECFM(F B) LRECL(133) BLKSIZE(27930  )\"\n    IF RC /= 0 THEN\n      do\n        say myid'.ENL.SYSPRINT allocation error'\n        say ' Reason follows:'\n        say ' '\n        x=MSG(ON)\n        xx=OUTTRAP(BADALLOC.)\n        \"ALLOCATE FI(SYSPRINT) DA('\"myid\".ENL.SYSPRINT') NEW CATALOG REUSE\n                     SPACE(2,2) TRACKS RECFM(F B) LRECL(133) BLKSIZE(27930)\"\n        xx=OUTTRAP(OFF)\n        do x2=1 to badalloc.0\n          say badalloc.x2\n        end\n        say 'Rexx ends'\n        myrc=16\n        return\n      end\nreturn\n\nCREATE_SYSIN:\n  if myrc <> 0 then return\n  sysin.1 = '  LISTC ENT('ELDSN') ALL'\n  address tso\n  \"execio * diskw sysin (stem sysin. finis)\"\nreturn\n\nLISTCAT:\n  if myrc <> 0 then return\n  address tso \"call 'sys1.linklib(idcams)'\"\n  if rc > 4 then\n    do\n      say sysin.1 ' LISTCAT error,RC='rc\n      say ' Reason follows:'\n      \"ISPEXEC BROWSE DATASET('\"myid\".ENL.SYSPRINT')\"\n      myrc=16\n      return\n    end\nreturn\n\nPROCESS_LISTCAT:\n  if myrc <> 0 then return\n  alias_sw=0\n  alias_delete_sw=0\n  alias_cnt=0\n  \"execio * diskr SYSPRINT (stem lc. FINIS\"\n  do X=1 to lc.0                         /* loop until eof          */\n    if pos('ASSOCIATIONS',lc.x) > 0 then\n      do\n        x=x+1\n        if pos('NONVSAM--',lc.x) > 0 then\n          do y=x to lc.0\n            if pos('NONVSAM--',lc.y) > 0 then\n              do\n                alias_sw=1\n                startpos=pos('NONVSAM--',lc.y) + 9\n                alias_cnt=alias_cnt + 1\n                alias_table.alias_cnt=strip(substr(lc.y,startpos,44))\n              end\n            leave\n          end\n        if pos('ALIAS----',lc.x) > 0 then\n          do y=x to lc.0\n            if pos('ALIAS----',lc.y) > 0 then\n              do\n                alias_delete_sw=1\n                startpos=pos('ALIAS----',lc.y) + 9\n                alias_cnt=alias_cnt + 1\n                alias_table.alias_cnt=strip(substr(lc.y,startpos,44))\n              end\n          end\n      end\n  end\nreturn\n\nALERT_USER:\n  if myrc <> 0 then return\n  if alias_sw=1 then\n    do\n      say ' '\n      say '*********************************************'\n      say '* 'eldsn 'is an ALIAS of Dataset 'alias_table.1\n      say '*'\n      say '* You CANNOT enlarge an ALIAS!'\n      say '*'\n      say '* Re-launch against a legitimate dataset'\n      say '*********************************************'\n      say ' '\n      myrc=16\n      return\n    end\n  if alias_cnt > 0 then\n  do\n    say ' '\n    say ' '\n    say ' '\n    say ' '\n    say ' '\n    leneldsn=length(eldsn)\n    mydashes=substr(dashes,1,leneldsn)\n    say ' Dataset ' eldsn 'has 'alias_cnt' ALIASES:'\n    say '*---------------------------------------------------*'\n    say '*  (D) 'eldsn\n    say '*  --- 'mydashes\n    do x=1 to alias_cnt\n      say '*  (A) 'alias_table.x\n    end\n    say '*---------------------------------------------------*'\n    say '                                               '\n    say '**************************************************'\n    say 'Proceeding will cause all ALIASes to be DELETED  *'\n    say '                                        =======  *'\n    say 'If deleted you must redefine them!!!             *'\n    say '**************************************************'\n    do forever\n      say 'ARE YOU SURE (Y/N) ?'\n      parse upper pull YN\n      if YN = 'N' then\n        do\n          say 'Enlarge Cancelled'\n          myrc=8\n          return\n        end\n      if YN = 'Y' then\n        do\n          say 'Proceeding with Operation...'\n          say ' '\n          return\n        end\n    end\n  end\nreturn\n\nGET_DSINFO:\n  if myrc <> 0 then return\n  dir='directory'\n  x=listdsi(''''ELDSN'''' dir)\n    if x = 4 then\n    do\n      if sysdsorg = 'VS' then\n        do\n          call ENLVSAM eldsn  /* -> VSAM */\n          myrcv=result        /* <- VSAM */\n          myrc=myrcv\n          call clean_up\n          call adios\n          exit\n        end\n    end\n  if x > 4 then\n    do\n      say 'LISTDSI err, RC='RC',REASON='sysreason\n      say 'for dataset 'ELDSN\n      myrc=16\n      return\n    end\n  ELVOL=sysvolume\n  ELDSO=sysdsorg\n  ELRCF=sysrecfm\n  ELRCL=syslrecl\n  ELBLK=sysblksize\n  ELUNI=sysunits\n  ELPRI=sysprimary\n  ELSEC=sysseconds\n  ELDIR=sysadirblk\n  ELXTN=sysextents\n  address ispexec\n  \"VPUT (ELDSN) PROFILE\"\n  \"VPUT (ELVOL) PROFILE\"\n  \"VPUT (ELDSO) PROFILE\"\n  \"VPUT (ELRCF) PROFILE\"\n  \"VPUT (ELRCl) PROFILE\"\n  \"VPUT (ELBLK) PROFILE\"\n  \"VPUT (ELUNI) PROFILE\"\n  \"VPUT (ELPRI) PROFILE\"\n  \"VPUT (ELSEC) PROFILE\"\n  \"VPUT (ELDIR) PROFILE\"\n  \"VPUT (ELXTN) PROFILE\"\nreturn\n\nALLOC_GENERAL:\n  if myrc <> 0 then return\n  address TSO\n  \"ALLOC DA('\"ELDSN\"') DDN(SYSUT1) OLD\"\n  if rc \u00ac= 0 then\n    do\n      say ELDSN' Allocation error:'\n      say ' Reason follows:'\n      say ' '\n      x=MSG(ON)\n      xx=OUTTRAP(BADALLOC.)\n      \"ALLOC DA('\"ELDSN\"') DDN(SYSUT1) OLD\"\n      xx=OUTTRAP(OFF)\n      do x2=1 to badalloc.0\n        say badalloc.x2\n      end\n      say 'Rexx ends'\n      myrc=16\n      return\n    end\n  \"ALLOC F(SYSPRINT) DA('\"myid\".ENL.SYSPRINT') SPACE(5,5) TRACKS NEW\n         CATALOG REUSE RECFM(F) BLKSIZE(121)\"\n  if RC \u00ac= 0 then\n    do\n      say myid'.ENL.SYSPRINT Allocation error:'\n      say ' Reason follows:'\n      say ' '\n      x=MSG(ON)\n      xx=OUTTRAP(BADALLOC.)\n      \"ALLOC F(SYSPRINT) DA('\"MYID\".ENL.SYSPRINT') SPACE(5,5) TRACKS NEW\n             CATALOG REUSE RECFM(F) BLKSIZE(121)\"\n      xx=OUTTRAP(OFF)\n      do x2=1 to badalloc.0\n        say badalloc.x2\n      end\n      say 'Rexx ends'\n      myrc=16\n      return\n    end\n  \"ALLOC F(SYSIN) DA('\"myid\".ENL.SYSIN') SPACE(1,1) TRACKS NEW CATALOG\n         RECFM(F) BLKSIZE(80) REUSE\"\n  if RC \u00ac= 0 then\n    do\n      say myid'.ENL.SYSIN Allocation error:'\n      say ' Reason follows:'\n      say ' '\n      x=MSG(ON)\n      xx=OUTTRAP(BADALLOC.)\n      \"ALLOCATE F(SYSIN) DA('\"myid\".ENL.SYSIN') SPACE(1,1) TRACKS NEW CATALOG\n                RECFM(F) BLKSZIE(80) REUSE\"\n      xx=OUTTRAP(OFF)\n      do x2=1 to badalloc.0\n        say badalloc.x2\n      end\n      say 'Rexx ends'\n      myrc=16\n      return\n    end\nreturn\n\nUSER_CHANGES:\n  if myrc <> 0 then return\n  address ispexec\n  \"DISPLAY PANEL(ENLPANNV)\"\n  \"VGET (ELVOL2) PROFILE\"\n  \"VGET (ELPRI2) PROFILE\"\n  \"VGET (ELUNI2) PROFILE\"\n  \"VGET (ELSEC2) PROFILE\"\n  \"VGET (ELDIR2) PROFILE\"\n  if ELVOL2='' then ELVOL2=ELVOL1\n  x1=wordlength(ELRCF,1)\n  select\n    when x1=1 then call RCF1\n    when x1=2 then call RCF2\n    when x1=3 then call RCF3\n    otherwise\n      do\n        say ' '\n        say ELDSN' has invalid RECFM of 'ELRCF\n        myrc=16\n        return\n      end\n  end\n  /* =============  allocate target dataset ============ */\n  if pos('BL',ELUNI2) <> '0' then\n    final_unit='BLOCK('ELPRI2')'\n  else\n    final_unit=ELUNI2\n/*-----------------------------------------------*/\n/*   V A L I D A T E   U S E R   R E Q U E S T   */\n/*-----------------------------------------------*/\n  if substr(ELDSO,1,2) = 'PS' then\n    do\n      DSNTYPE='PS'\n      utility='IEBGENER'\n    end\n  else\n  if ELDIR2='NO_LIM' then\n    do\n      DSNTYPE='LIBRARY'\n      utility='IEBCOPY'\n    end\n  else\n    do\n      DSNTYPE='PDS'\n      utility='IEBCOPY'\n    end\n    type_is='# Dataset type is 'dsntype' #'\n    len=length(type_is)\n    pounds=right('#',len,'#')\n    say pounds\n    say type_is\n    say pounds\n  if ELPRI2=0 then\n    do\n      say 'ZERO value for a new primary is invalid'\n      say' REXX ends'\n      myrc=16\n      return\n    end\n  if DSNTYPE='PS' & datatype(ELDIR2,'N') = 1 then\n    do\n      say 'Cannot assign a Directory value to a DSORG=PS dataset'\n      say' REXX ends'\n      myrc=16\n      return\n    end\n\n  if DSNTYPE='LIBRARY' & ELDIR2 <> 'NO_LIM' then\n    do\n      say ' '\n      say 'PDSE ignores user DIR value of 'ELDIR2', \"NO_LIM\" is assumed'\n      say ' '\n    end\n\n  if DSNTYPE='LIBRARY' & ELDIR2 = 'NO_LIM' then\n     ELDIR2=99999   /* Needed for next rtn */\nreturn\n\nALLOC_SPECIFIC:\n  if myrc <> 0 then return\n  if substr(ELDSO,1,2) = 'PO' then\n    \"ALLOC DA('\"ELDSN\".NEW') VOL(\"ELVOL2\") BLKSIZE(\"ELBLK\") LRECL(\"ELRCL\")\n     RECFM(\"ELRCF\") SPACE(\"ELPRI2\",\"ELSEC2\") \"FINAL_UNIT\" DIR(\"ELDIR2\")\n     DSNTYPE(\"DSNTYPE\") DDN(SYSUT2) NEW CATALOG\"\n  else\n    \"ALLOC DA('\"ELDSN\".NEW') VOL(\"ELVOL2\") BLKSIZE(\"ELBLK\") LRECL(\"ELRCL\")\n           RECFM(\"ELRCF\") SPACE(\"ELPRI2\",\"ELSEC2\") \"FINAL_UNIT\" DDN(SYSUT2)\n           NEW CATALOG\"\n  if RC \u00ac= 0 then\n    do\n      myrc=rc\n      x=MSG(ON)\n      say ELDSN'.NEW allocation error'\n      say ' Reason follows:'\n      say ' '\n      x=MSG(ON)\n      xx=OUTTRAP(BADALLOC.)\n      if substr(ELDSO,1,2) = 'PO' then\n        \"ALLOC DA('\"ELDSN\".NEW') VOL(\"ELVOL2\") BLKSIZE(\"ELBLK\") LRECL(\"ELRCL\")\n         RECFM(\"ELRCF\") SPACE(\"ELPRI2\",\"ELSEC2\") \"FINAL_UNIT\" DIR(\"ELDIR2\")\n         DSNTYPE(\"DSNTYPE\") DDN(SYSUT2) NEW CATALOG\"\n      else\n        \"ALLOC DA('\"ELDSN\".NEW') VOL(\"ELVOL2\") BLKSIZE(\"ELBLK\") LRECL(\"ELRCL\")\n               RECFM(\"ELRCF\") SPACE(\"ELPRI2\",\"ELSEC2\") \"FINAL_UNIT\" DDN(SYSUT2)\n               NEW CATALOG\"\n      do x2=1 to badalloc.0\n        say badalloc.x2\n      end\n      say 'REXX ends'\n      myrc=16\n      return\n    end\n  x=listdsi(''''ELDSN'.NEW''' dir)\n  if x \u00ac= 0 then\n    do\n      myrc=rc\n      say 'LISTDSI err for 'ELDSN'.NEW,RC='myrc',reason='sysreason\n      myrc=16\n      return\n    end\nreturn\n\nUSER_APPROVAL:\n  if myrc <> 0 then return\n  do forever\n    say ' '\n    say '*** 'eldsn' ***'\n    say ' '\n    say 'Target volume  for enlarged dataset is ' sysvolume\n    say 'Number extents for enlarged dataset is ' sysextents\n    say '----------------------------------------------'\n    say 'Input UNIT='right(ELUNI1,8)', Output UNIT='right(ELUNI2,8)\n    say 'Input PRI ='right(ELPRI1,8)', Output PRI ='right(ELPRI2,8)\n    say 'Input SEC ='right(ELSEC1,8)', Output SEC ='right(ELSEC2,8)\n    if DSNTYPE = 'LIBRARY' then\n      say 'Input DIR ='right(ELDIR1,8)', Output DIR =  NO_LIM'\n    else\n    if DSNTYPE='PDS' then\n      say 'Input DIR ='right(ELDIR1,8)', Output DIR ='right(ELDIR2,8)\n    if alias_delete_sw=1 then\n      do\n        say '-------------------------------------------'\n        say right(alias_cnt,10)' DATASET ALIASES will be deleted '\n        say '-------------------------------------------'\n      end\n    say ' '\n    say 'OK to proceed (Y/N) ?'\n    parse upper pull YN\n    if YN = 'N' then\n      do\n        say 'REXX ends'\n        myrc=8\n        return\n      end\n    if YN = 'Y' then\n      leave\n  end\nreturn\n\nCOPY_IT:\n  if myrc <> 0 then return\n  address tso\n  jcl.1 = '     COPY INDD=SYSUT1,OUTDD=SYSUT2'\n  'EXECIO  *  DISKW SYSIN (STEM jcl. FINIS)'\n  say 'ENLARGING 'ELDSN' ... PLEASE WAIT'\n  if substr(ELDSO,1,2) = 'PO' then\n    ADDRESS TSO \"CALL 'SYS1.LINKLIB(IEBCOPY)'\"\n  else\n    do\n      \"FREE FI(SYSIN)\"\n      \"ALLOC DDN(SYSIN) DUMMY\"\n       ADDRESS TSO \"CALL 'SYS1.LINKLIB(IEBGENER)'\"\n    end\n  if rc \u00ac= 0 then\n    do\n      say 'ERROR WHILE RUNNING 'utility\n      say ' Reason follows:'\n      \"ISPEXEC BROWSE DATASET('\"myid\".ENL.SYSPRINT')\"\n      say ' '\n      say ' If no error msg appears, check your alloc values'\n      say 'Rexx ends'\n      myrc=16\n      return\n    end\n  \"FREE F(SYSIN,SYSPRINT)\"\n  \"DELETE ('\"myid\".ENL.SYSIN')\"\n  \"DELETE ('\"myid\".ENL.SYSPRINT')\"\n  \"ALLOC F(SYSPRINT) DA('\"myid\".ENL.SYSPRINT') SPACE(2,1) TRACKS NEW CATALOG\n         REUSE RECF(F) BLKSIZE(133)\"\n   IF RC /= 0 THEN\n     do\n       say MYID'.ENL.SYSPRINT allocation error'\n       say ' Reason follows:'\n       say ' '\n       x=MSG(ON)\n       xx=OUTTRAP(BADALLOC.)\n       \"ALLOCATE FI(SYSPRINT) DA('\"myid\".ENL.SYSPRINT') SPACE(2,1) TRACKS NEW\n                    CATALOG REUSE RECFM(F) BLKSUZE(133)\"\n       xx=OUTTRAP(OFF)\n       do x2=1 to badalloc.0\n         say badalloc.x2\n       end\n       say 'Rexx ends'\n       myrc=16\n       return\n     end\n  \"ALLOC F(SYSIN) DA('\"myid\".ENL.SYSIN') SPACE(1,1) TRACKS NEW CATALOG\n           RECFM(F) BLKSIZE(80) REUSE\"\n  if RC <> 0 then\n    do\n       say MYID'.ENL.SYSIN allocation error'\n       say ' Reason follows:'\n       say ' '\n       x=MSG(ON)\n       xx=OUTTRAP(BADALLOC.)\n       \"ALLOCATE FI(SYSIN) DA('\"myid\".ENL.SYSIN') TRACKS NEW CATALOG\n                    RECFM(F) BLKSIZE(80) REUSE\"\n       xx=OUTTRAP(OFF)\n       do x2=1 to badalloc.0\n         say badalloc.x2\n       end\n       say 'Rexx ends'\n       myrc=16\n       return\n     end\nreturn\n\nRENAME_IT:\n  if myrc <> 0 then return\n  newstack\n  jcl.1=' ALTER -'\n  jcl.2='       'ELDSN' -'\n  jcl.3='        NEWNAME('ELDSN'.OLD)'\n  jcl.4=' ALTER -'\n  jcl.5='       'ELDSN'.NEW -'\n  jcl.6='        NEWNAME('ELDSN')'\n  jcl.7=' DELETE -'\n  jcl.8='       'ELDSN'.OLD -'\n  jcl.9='        NONVSAM'\n  'EXECIO  *  DISKW SYSIN (STEM jcl. FINIS)'\n   ADDRESS TSO \"CALL 'SYS1.LINKLIB(IDCAMS)'\"\n  if rc <> 0 then\n    do\n      say 'IDCAMS dataset RENAME -or- DELETE error'\n      say '  check 'ELDSN', 'ELDSN'.NEW, and 'ELDSN'.OLD '\n      say ' Reason follows:'\n      \"ISPEXEC BROWSE DATASET('\"myid\".ENL.SYSPRINT')\"\n      myrc=16\n      call clean_up\n      return\n    end\nreturn\n\nCLEAN_UP:\n  X=MSG('OFF')\n  address TSO\n  \"FREE FI(SYSIN,SYSPRINT,SYSUT1,SYSUT2)\"\n  \"DELETE ('\"myid\".ENL.SYSIN')\"\n  \"DELETE ('\"myid\".ENL.SYSPRINT')\"\n  \"DELETE ('\"ELDSN\".NEW')\"\n  if myrc < 16 then\n    \"DELETE ('\"ELDSN\".OLD')\"\nreturn\n\nADIOS:\n  if myrc=0 then\n    say 'Dataset 'dsn' was enlarged, RC='myrc\n  else\n    say 'Dataset 'dsn' enlarge process ABNORMAL end; INVESTIGATE'\nreturn\n\nRCF1:\n  x2=substr(ELRCF,1,1)\n  ELRCF=x2\nreturn\n\nRCF2:\n  x2=substr(ELRCF,1,1)\n  x3=substr(ELRCF,2,1)\n  ELRCF=x2||','||x3\nreturn\n\nRCF3:\n  x2=substr(ELRCF,1,1)\n  x3=substr(ELRCF,2,1)\n  x4=substr(ELRCF,3,1)\n  ELRCF=x2||','||x3||','||x4\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ENLPANNV": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x08\\x01\\x142?\\x01\\x143\\x7f\\x14 \\x00Q\\x00M\\x00\\x00\\xe3\\xe2\\xf0\\xf7\\xf1\\xf0@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2014-11-19T00:00:00", "modifydate": "2014-12-03T14:20:08", "lines": 81, "newlines": 77, "modlines": 0, "user": "TS0710"}, "text": ")ATTR\n$ TYPE(OUTPUT) INTENS(LOW)  COLOR(RED)\n\u00ac TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n# TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n\u00a2 TYPE(TEXT)   INTENS(LOW)  COLOR(WHITE)\n~ TYPE(INPUT)  INTENS(HIGH) COLOR(GREEN)\n)BODY\n\u00ac                               N O N  -  V S A M\n%\n#                        ---  #CURRENT DATASET INFO  ---\n% DSN      ==>$ELDSN1                                     +\n% DSORG    ==>$ELDSO1+\n% RECFM    ==>$ELRCF1+\n% BLKSIZE  ==>$ELBLK1+\n% LRECL    ==>$ELRCL1+\n% EXTNTS   ==>$ELXTN1+\n%\n% ALLOCATION :\n%    VOL    ==>$ELVOL1+\n%    UNIT   ==>$ELUNI1  +\n%    PRI    ==>$ELPRI1  +\n%    SEC    ==>$ELSEC1  +\n%    DIR    ==>$ELDIR1  +\n#                        ---  #ENTER CHANGES HERE  ---\n% ALLOCATION :\n%    VOL   ==>~ELVOL2+\n%    UNIT  ==>~ELUNI2  +\n%    PRI   ==>~ELPRI2  +\n%    SEC   ==>~ELSEC2  +\n%    DIR   ==>~ELDIR2  +\n)INIT\nVGET (ELDSN) PROFILE\nVGET (ELVOL) PROFILE\nVGET (ELDSO) PROFILE\nVGET (ELRCF) PROFILE\nVGET (ELRCL) PROFILE\nVGET (ELBLK) PROFILE\nVGET (ELUNI) PROFILE\nVGET (ELPRI) PROFILE\nVGET (ELSEC) PROFILE\nVGET (ELDIR) PROFILE\nVGET (ELXTN) PROFILE\n&ELDSN1  = &ELDSN\n&ELVOL1  = &ELVOL\n&ELDSO1  = &ELDSO\n&ELRCF1  = &ELRCF\n&ELRCL1  = &ELRCL\n&ELBLK1  = &ELBLK\n&ELUNI1  = &ELUNI\n&ELPRI1  = &ELPRI\n&ELSEC1  = &ELSEC\n&ELDIR1  = &ELDIR\n&ELXTN1  = &ELXTN\n&ELVOL2  = &ELVOL\n&ELUNI2  = &ELUNI\n&ELPRI2  = &ELPRI\n&ELSEC2  = &ELSEC\n&ELDIR2  = &ELDIR\nVPUT (ELUNI2) PROFILE\nVPUT (ELVOL2) PROFILE\nVPUT (ELPRI2) PROFILE\nVPUT (ELSEC2) PROFILE\nVPUT (ELDIR2) PROFILE\n.CURSOR = ELVOL2\n)PROC\nIF (&ELVOL2 = '')\n    &ELVOL2=&ELVOL1\nIF (&ELVOL2 NE '')\n    VER(&ELVOL2,NONBLANK)\n    VER(&ELVOL2,LEN,'=',6)\nVER(&ELUNI2,LIST,CYLINDERS,CYLINDER,CYLS,CYL,TRACKS,TRACK,TRKS,TRK,BLOCK,BLK)\nVER(&ELPRI2,NUM)\nVER(&ELSEC2,NUM)\nIF (&ELDIR2 NE 'NO_LIM')\n    VER(&ELDIR2,NUM)\nVPUT (ELUNI2) PROFILE\nVPUT (ELVOL2) PROFILE\nVPUT (ELPRI2) PROFILE\nVPUT (ELSEC2) PROFILE\nVPUT (ELDIR2) PROFILE\n)END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENLPANV": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x12\\x001\\x01\\x142?\\x01\\x144?\\tC\\x005\\x00'\\x00\\x00\\xe3\\xe2\\xf0\\xf7\\xf1\\xf0@@@@\"", "ispf": {"version": "01.18", "flags": 0, "createdate": "2014-11-19T00:00:00", "modifydate": "2014-12-09T09:43:31", "lines": 53, "newlines": 39, "modlines": 0, "user": "TS0710"}, "text": ")ATTR\n$ TYPE(OUTPUT) INTENS(LOW)  COLOR(RED)\n\u00ac TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n# TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n\u00a2 TYPE(TEXT)   INTENS(LOW)  COLOR(WHITE)\n~ TYPE(INPUT)  INTENS(HIGH) COLOR(GREEN)\n)BODY\n\u00ac                                     V S A M\n%\n#                        ---  #CURRENT DATASET INFO   ---\n%    DSN    ==>$ELCLUS                                    +\n%\n% ALLOCATION :\n%    VOL    ==>$ELDVOL+\n%    TYPE   ==>$ELDUNI  +\n%    PRI    ==>$ELDPRI  +\n%    SEC    ==>$ELDSEC  +\n%\n#                        ---  #ENTER CHANGES HERE  ---\n%\n% ALLOCATION :\n%    VOL   ==>~ELDVL4+\n%    TYPE  ==>~ELDUNI4  +\n%    PRI   ==>~ELDPRI4  +\n%    SEC   ==>~ELDSEC4  +\n%\n)INIT\n&ELDVL4=&ELDVOL\nVGET (ELCLUS)  PROFILE\nVGET (ELDVOL)  PROFILE\nVGET (ELDUNI)  PROFILE\nVGET (ELDPRI)  PROFILE\nVGET (ELDSEC)  PROFILE\nVPUT (ELDVL4)  PROFILE\nVPUT (ELDUNI4) PROFILE\nVPUT (ELDPRI4) PROFILE\nVPUT (ELDSEC4) PROFILE\n.CURSOR = ELDVL4\n)PROC\nIF (&ELDVL4 = '')\n   &ELDVL4=&ELDVOL\nIF (&ELDVL4 NE '')\n   VER(&ELDVL4,NONBLANK)\n   VER(&ELDVL4,LEN,'=',6)\nVER(&ELDUNI4,LIST,CYLINDERS,CYLINDER,CYL,TRACKS,TRACK,TRK,RECORDS,REC,\nKILOBYTES,KB,MEGABYTES,MB)\nVER(&ELDPRI4,NUM)\nVER(&ELDSEC4,NUM)\nVPUT (ELDVL4)  PROFILE\nVPUT (ELDUNI4) PROFILE\nVPUT (ELDPRI4) PROFILE\nVPUT (ELDSEC4) PROFILE\n)END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENLVSAM": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x16\\x01\\x143_\\x01\\x144O\\x14B\\x02\\x02\\x02%\\x00\\x00\\xe3\\xe2\\xf0\\xf7\\xf1\\xf0@@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2014-12-01T00:00:00", "modifydate": "2014-12-10T14:42:16", "lines": 514, "newlines": 549, "modlines": 0, "user": "TS0710"}, "text": "/* REXX */\n/*------------------------------------------------------------------*/\n/* Enlarge a VSAM dataset                                           */\n/* Called by REXX ENL when a VSAM dataset is detected               */\n/*                                                                  */\n/* VSAM formats upported:                                           */\n/*   1. KSDS                                                        */\n/*   2. ESDS                                                        */\n/*   3. RRDS                                                        */\n/*   4. LINEAR                                                      */\n/*------------------------------------------------------------------*/\n\nparse arg dsn\n\nMAINLINE:\n  Call Housekeep        /* The usual                                */\n  Call Clean_up         /* Clean up residual stuff                  */\n  Call Alloc_work_new   /* Create IDCAMS work datasets              */\n  Call Bldlcat          /* Build LISTCAT stream                     */\n  Call Listcat          /* LISTCAT                                  */\n  Call Allocbrow        /* Allocate browse datasets                 */\n  Call Scanlcat         /* Browse LISTCAT output                    */\n  Call Showpanel        /* Get user changes                         */\n  Call Alloc_work_shr   /* Reallocate IDCAMS datasets               */\n  Call Builddef         /* Build DEFINE CLUSTER stream              */\n  Call Define           /* DEFINE CLUSTER.NEW                       */\n  Call Alloc_work_shr   /* Reallocate IDCAMS datasets               */\n  Call Alloc_repro      /* Alloc REPRO datasets                     */\n  Call Build_repro      /* Construct REPRO stream                   */\n  Call Repro            /* REPRO ORIG -> *.NEW                      */\n  Call Alloc_work_shr   /* Reallocate IDCAMS datasets               */\n  Call Buildalter       /* Build ALTER stream                       */\n  Call Alter            /* ALTER                                    */\n  Call Alloc_work_shr   /* Reallocate IDCAMS datasets               */\n  Call Builddel         /* Build DELETE stream                      */\n  Call Delete           /* DELETE                                   */\n  Call clean_up         /* Clean up residual stuff                  */\n  address ISPEXEC\n  ZISPFRC = MYRCV\n  \" VPUT (ZISPFRC) SHARED \"\nreturn myrcv\n\nHOUSEKEEP:\n  ELDSN=dsn\n  msg_status = MSG('OFF')\n  hotdata=''\n  hotindx=''\n  rtn=p\n  myid=sysvar(sysuid)\n  myrcv=0\nRETURN\n\nALLOC_WORK_NEW:\n  if myrcv <> 0 then return\n  address TSO\n  \"ALLOC F(SYSPRINT) DA('\"myid\".ENLV.SYSPRINT') SPACE(5,5) TRACKS NEW CATALOG\n         LRECL(133) BLKSIZE(27930) REUSE\"\n    if rc /= 0 then\n      do\n        say myid'.ENLV.SYSIN allocation error'\n        say ' Reason follows:'\n        say ' '\n        x=MSG(ON)\n        xx=OUTTRAP(BADALLOC.)\n        \"ALLOCATE F(SYSPRINT) DA('\"myid\".ENLV.SYSPRINT') SPACE(5 5) TRACKS NEW\n                  CATALOG LRECL(133) BLKSIZE(27930) REUSE\"\n        xx=OUTTRAP(OFF)\n        do x2=1 to badalloc.0\n          say badalloc.x2\n        end\n        say 'Rexx ends'\n        myrcv=16\n        return\n      end\n  \"ALLOC F(SYSIN) DA('\"myid\".ENLV.SYSIN') SPACE(1,1) TRACKS NEW CATALOG\n         RECFM(F) BLKSIZE(80) REUSE\"\n    if rc /= 0 then\n      do\n        say myid'.ENLV.SYSIN allocation error'\n        say ' Reason follows:'\n        say ' '\n        x=MSG(ON)\n        xx=OUTTRAP(BADALLOC.)\n        \"ALLOCATE FI(SYSIN) DA('\"myid\".ELV.SYSIN') SPACE(1,1) TRACKS NEW CATALOG\n                  RECFM(F) BLKSIZE(80) REUSE\"\n        xx=OUTTRAP(OFF)\n        do x2=1 to badalloc.0\n          say badalloc.x2\n        end\n        say 'Rexx ends'\n        myrcv=16\n        return\n      end\nreturn\n\nBLDLCAT:\n  if myrcv <> 0 then return\n  address tso\n  lca.1='     LISTCAT -'\n  lca.2='             ENT('eldsn') -'\n  lca.3='             ALL'\n  'EXECIO  *  DISKW SYSIN (STEM lca. FINIS)'\nreturn\n\nLISTCAT:\n  if myrcv <> 0 then return\n  ADDRESS TSO \"CALL 'SYS1.LINKLIB(IDCAMS)'\"\n  if RC \u00ac= 0 then\n    do\n      say 'IDCAMS LISTCAT error'\n      say ' Reason follows:'\n      \"ISPEXEC BROWSE DATASET('\"myid\".ENLV.SYSPRINT')\"\n      myrcv=16\n      call clean_up\n      return\n    end\nreturn\n\nALLOCBROW:\n  if myrcv <> 0 then return\n  address TSO\n  \"FREE FI(SYSIN,SYSPRINT)\"\n  \"ALLOC F(SYSPRINT) DA('\"myid\".ENLV.SYSPRINT') SHR\"\n   if rc /= 0 then\n     do\n       say myid'.ENLV.SYSPRINT allocation error'\n       say ' Reason follows:'\n       say ' '\n       x=MSG(ON)\n       xx=OUTTRAP(BADALLOC.)\n       \"ALLOCATE FI(SYSIN) DA('\"myid\".ENLV.SYSPRINT') SHR\"\n       xx=OUTTRAP(OFF)\n       do x2=1 to badalloc.0\n         say badalloc.x2\n       end\n       say 'Rexx ends'\n       myrcv=16\n       return\n     end\nreturn\n\nSCANLCAT:\n  if myrcv <> 0 then return\n  \"EXECIO * DISKR SYSPRINT (STEM lca. FINIS)\"\n  \"FREE FI(SYSPRINT)\"\n  do x=1 to lca.0\n    if pos('PROCESSED WAS:',lca.x) <> 0 then return\n    select\n      when rtn=p then call prertn\n      when rtn=c then call clusrtn\n      when rtn=d then call datartn\n      when rtn=i then return\n        otherwise\n          do\n            say 'rtn ='rtn '... error'\n            exit\n          end\n    end /* select */\n  end /* do */\n return\n\nPRERTN:\n  if myrcv <> 0 then return\n  if pos('CLUSTER ------- ',lca.x) /= 0 then\n    do\n      hotclus=word(lca.x,3)\n      hotclus=strip(hotclus,B)\n      rtn=c\n    end\nreturn\n\nCLUSRTN:\n  if myrcv <> 0 then return\n  if pos('DATA -------',lca.x) /= 0 then\n    do\n      hotdata=word(lca.x,4)\n      hotdata=strip(hotdata,B)\n      rtn=d\n      return\n    end\n  if pos('INDEX ------',lca.x) /= 0 then\n    do\n      hotindx=word(lca.x,4)\n      hotindx=strip(hotindx,B)\n      rtn=I\n      return\n    end\nreturn\n\nDATARTN:\n  if myrcv <> 0 then return\n  if pos('INDEX ------',lca.x) /= 0 then\n    do\n      hotindx=word(lca.x,4)\n      hotindx=strip(hotindx,B)\n      rtn=I\n      return\n    end\n  if pos('SPACE-TYPE',lca.x) /= 0 then\n    do\n      mystmt=translate(lca.x,' ','-')\n      if words(mystmt) = 8 then\n        dalloc=word(mystmt,4)\n      else\n      if words(mystmt) = 7 then\n        dalloc=word(mystmt,3)\n      return\n    end\n  if pos('SPACE-PRI',lca.x) /= 0 then\n    do\n      mystmt=translate(lca.x,' ','-')\n      if words(mystmt) = 8 then\n        dpri=word(mystmt,4)\n      else\n      if words(mystmt) = 7 then\n        dpri=word(mystmt,3)\n      return\n    end\n  if pos('SPACE-SEC',lca.x) /= 0 then\n    do\n      mystmt=translate(lca.x,' ','-')\n      if words(mystmt) = 4 then\n        dsec=word(mystmt,4)\n      else\n      if words(mystmt) = 3 then\n        dsec=word(mystmt,3)\n      return\n    end\n  if pos('VOLSER---',lca.x) /= 0 then\n    do\n      mystmt=translate(lca.x,' ','-')\n      volser=word(mystmt,2)\n    end\nreturn\n\nSHOWPANEL:\n  if myrcv <> 0 then return\n  ELCLUS=hotclus\n  ELDVOL=volser\n  ELDUNI=dalloc\n  ELDPRI=dpri\n  ELDSEC=dsec\n  ELDUNI4=ELDUNI\n  ELDPRI4=ELDPRI\n  ELDSEC4=ELDSEC\n  address ispexec\n  \"VPUT (ELCLUS)  PROFILE\"\n  \"VPUT (ELDUNI)  PROFILE\"\n  \"VPUT (ELDVOL)  PROFILE\"\n  \"VPUT (ELDPRI)  PROFILE\"\n  \"VPUT (ELDSEC)  PROFILE\"\n  \"VPUT (ELDUNI4) PROFILE\"\n  \"VPUT (ELDPRI4) PROFILE\"\n  \"VPUT (ELDSEC4) PROFILE\"\n  \"DISPLAY PANEL(ENLPANV)\"\n  \"VGET (ELDUNI4) PROFILE\"\n  \"VGET (ELDVL4)  PROFILE\"\n  \"VGET (ELDPRI4) PROFILE\"\n  \"VGET (ELDSEC4) PROFILE\"\n  say '########################'\n  say '# Dataset type is VSAM #'\n  say '########################'\n  say ' '\n  do forever\n    say '*** 'hotclus' ***'\n    say ' '\n    say ' Input VOL ='right(ELDVOL,8)', Output VOL ='right(ELDVL4,8)\n    say ' Input UNIT='right(ELDUNI,8)', Output UNIT='right(ELDUNI4,8)\n    say ' Input PRI ='right(ELDPRI,8)', Output PRI ='right(ELDPRI4,8)\n    say ' Input SEC ='right(ELDSEC,8)', Output SEC ='right(ELDSEC4,8)\n    say ' '\n    say 'OK to change (Y/N) ?'\n    parse upper pull YN\n    if YN = 'N' then\n      do\n        say 'Enlarging operation cancelled'\n        myrcv=8\n        return\n      end\n    if YN = 'Y' then\n      leave\n  end\nreturn\n\nBUILDDEF:\n  if myrcv <> 0 then return\n  address tso\n  def.1='     DEFINE CLUSTER ( - '\n  def.2='                    NAME('hotclus'.NEW) -'\n  def.3='                    'ELDUNI4'('ELDPRI4' 'ELDSEC4') -'\n  def.4='                    VOLUME('ELDVL4') -'\n  def.5='                    MODEL('hotclus')) -'\n  def.6='            DATA( -'\n  df=6\n  if hotindx <> '' then\n    do\n      df=df+1\n      def.df='                    NAME('hotdata'.NEW)) -'\n      df=df+1\n      def.df='            INDEX( -'\n      df=df+1\n      def.df='                    NAME('hotindx'.NEW))'\n    end\n  else\n    do\n      df=df+1\n      def.df='                      NAME('hotdata'.NEW))  '\n    end\n  'EXECIO  *  DISKW SYSIN (STEM def. FINIS)'\nreturn\n\nDEFINE:\n  if myrcv <> 0 then return\n  ADDRESS TSO \"CALL 'SYS1.LINKLIB(IDCAMS)'\"\n  if rc /= 0 then\n    do\n      say 'IDCAMS DEFINE 'hotclus'.NEW error'\n      say ' Reason follows:'\n      \"ISPEXEC BROWSE DATASET('\"myid\".ENLV.SYSPRINT')\"\n      myrcv=16\n      call clean_up\n      return\n    end\nreturn\n\nALLOC_REPRO:\n  if myrcv <> 0 then return\n  address TSO\n  \"ALLOC F(REPROIN) DA('\"hotclus\"') SHR\"\n   if rc /= 0 then\n     do\n       say 'REPRO (REPRO-IN) \"hotclus\" allocation error'\n       say ' Reason follows:'\n       say ' '\n       x=MSG(ON)\n       xx=OUTTRAP(BADALLOC.)\n       \"ALLOC F(REPROIN) DA('\"hotclus\"') SHR\"\n       xx=OUTTRAP(OFF)\n       do x2=1 to badalloc.0\n         say badalloc.x2\n       end\n       say 'Rexx ends'\n       myrcv=16\n       return\n     end\n  \"ALLOC F(REPROUT) DA('\"hotclus\".NEW') SHR\"\n   if rc /= 0 then\n     do\n       say 'REPRO (REPRO-OUT) 'hotclus'*.NEW allocation error'\n       say ' Reason follows:'\n       say ' '\n       x=MSG(ON)\n       xx=OUTTRAP(BADALLOC.)\n       \"ALLOC F(REPROUT) DA('\"hotclus\".NEW') SHR\"\n       xx=OUTTRAP(OFF)\n       do x2=1 to badalloc.0\n         say badalloc.x2\n       end\n       say 'Rexx ends'\n       myrcv=16\n       return\n     end\nreturn\n\nBUILD_REPRO:   /* Original to Original.NEW */\n  if myrcv <> 0 then return\n  address tso\n  rep.1='     REPRO -'\n  rep.2='           INFILE(REPROIN) -'\n  rep.3='           OUTFILE(REPROUT) '\n  'EXECIO  *  DISKW SYSIN (STEM rep. FINIS)'\nreturn\n\nREPRO:\n  if myrcv <> 0 then return\n  ADDRESS TSO \"CALL 'SYS1.LINKLIB(IDCAMS)'\"\n  if rc /= 0 then\n    do\n      say ' REPRO ('hotclus'.NEW) ERROR'\n      say ' Reason follows:'\n      say ' '\n      \"ISPEXEC BROWSE DATASET('\"myid\".ENLV.SYSPRINT')\"\n      myrcv=16\n      call clean_up\n      return\n    end\nreturn\n\nBUILDALTER:\n  if myrcv <> 0 then return\n  address tso\n  ida.1='     ALTER -'\n  ida.2='         ' hotclus' -'\n  ida.3='         NEWNAME('hotclus'.OLD) '\n  ida.4='     ALTER -'\n  ida.5='         ' hotdata' -'\n  ida.6='         NEWNAME('hotdata'.OLD)'\n  idx=6\n  if hotindx <> '' then\n    do\n      idx=idx+1\n      ida.idx='     ALTER -'\n      idx=idx+1\n      ida.idx='         ' hotindx' -'\n      idx=idx+1\n      ida.idx='         NEWNAME('hotindx'.OLD)'\n    end\n  idx=idx+1\n  ida.idx='     ALTER -'\n  idx=idx+1\n  ida.idx='         ' hotclus'.NEW -'\n  idx=idx+1\n  ida.idx='         NEWNAME('hotclus') '\n  idx=idx+1\n  ida.idx='     ALTER -'\n  idx=idx+1\n  ida.idx='         ' hotdata'.NEW -'\n  idx=idx+1\n  ida.idx='         NEWNAME('hotdata')'\n  if hotindx <> '' then\n    do\n      idx=idx+1\n      ida.idx='     ALTER -'\n      idx=idx+1\n      ida.idx='         'hotindx'.NEW -'\n      idx=idx+1\n      ida.idx='         NEWNAME('hotindx')'\n    end\n  'EXECIO  *  DISKW SYSIN (STEM ida. FINIS)'\nreturn\n\nALTER:\n  if myrcv <> 0 then return\n  ADDRESS TSO \"CALL 'SYS1.LINKLIB(IDCAMS)'\"\n  if rc <> 0 then\n    do\n      say 'IDCAMS ALTER ERROR'\n      say ' Reason follows:'\n      \"ISPEXEC BROWSE DATASET('\"myid\".ENLV.SYSPRINT')\"\n      myrcv=16\n      call clean_up\n      return\n    end\nreturn\n\nBUILDDEL:\n  if myrcv <> 0 then return\n  address tso\n  idc.1='     DELETE -'\n  idc.2='          'hotclus'.OLD  - '\n  idc.3='           CLUSTER '\n  'EXECIO  *  DISKW SYSIN (STEM idc. FINIS)'\nreturn\n\nDELETE:\n  if myrcv <> 0 then return\n  ADDRESS TSO \"CALL 'SYS1.LINKLIB(IDCAMS)'\"\n  if RC \u00ac= 0 then\n    do\n      say 'IDCAMS DELETE error for 'hotclus'.OLD'\n      say ' Reason follows:'\n      \"ISPEXEC BROWSE DATASET('\"myid\".ENLV.SYSPRINT')\"\n      call clean_up\n      myrcv=16\n      return\n    end\nreturn\n\nALLOC_WORK_SHR:\n  if myrcv <> 0 then return\n  address TSO\n  \"FREE FI(SYSIN,SYSPRINT,REPROIN,REPROUT)\"\n  \"ALLOC F(SYSPRINT) DA('\"myid\".ENLV.SYSPRINT') SHR\"\n   if rc /= 0 then\n     do\n       say myid'.ENLV.SYSPRINT allocation error'\n       say ' Reason follows:'\n       say ' '\n       x=MSG(ON)\n       xx=OUTTRAP(BADALLOC.)\n       \"ALLOCATE FI(SYSPRINT) DA('\"myid\".ENLV.SYSPRINT') SHR\"\n       xx=OUTTRAP(OFF)\n       do x2=1 to badalloc.0\n         say badalloc.x2\n       end\n       say 'Rexx ends'\n       myrcv=16\n       return\n     end\n  \"ALLOC F(SYSIN) DA('\"myid\".ENLV.SYSIN') SHR\"\n    if rc /= 0 then\n     do\n       say myid'.ENLV.SYSIN allocation error'\n       say ' Reason follows:'\n       say ' '\n       x=MSG(ON)\n       xx=OUTTRAP(BADALLOC.)\n       \"ALLOCATE FI(SYSIN) DA('\"myid\".ENLV.SYSIN') SHR\"\n       xx=OUTTRAP(OFF)\n       do x2=1 to badalloc.0\n         say badalloc.x2\n       end\n       say 'Rexx ends'\n       myrcv=16\n       return\n     end\nreturn\n\nCLEAN_UP:\n  address TSO\n  \"FREE FI(SYSIN,SYSPRINT,REPROIN,REPROUT)\"\n  \"DELETE ('\"myid\".ENLV.SYSIN')\"\n  \"DELETE ('\"myid\".ENLV.SYSPRINT')\"\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT925/FILE925.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT925", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}