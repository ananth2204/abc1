{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012546000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1352078, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE663.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1352078, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1352078, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE663.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x16\\x07'", "DS1TRBAL": "b'WB'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xb6\\x00\\n\\x04\\xb8\\x00\\x02\\x00\\x17'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04A\\x00\\x00\\x01\\x04\\x04/\\x01\\x04\\x04/\\x11\\x19\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf5@@@'", "ispf": {"version": "04.65", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T11:19:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-465"}, "text": "REGULAR CBT TAPE - VERSION 465    FILE:  663\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT465.FILE663\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 20 MEMBERS COUNTED; CUMULATIVE SIZE IS 12,561 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   02/11/04    11:18:59    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NAMES": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00U\\x01\\x04\\x04/\\x01\\x04\\x04/\\x11\\x11\\x00\"\\x00\\x1a\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T11:11:55", "lines": 34, "newlines": 26, "modlines": 0, "user": "SBGOLOB"}, "text": "Naming conventions for File 663 members:\n\n    Because C naming conventions on the pc were used in the\n    distribution of this file, and they had to be moved to an\n    MVS format, several things were done:\n\n 1.  ASCII was translated into EBCDIC throughout.\n\n 2.  Members of this pds, were created with the suffix name,\n     and the individual sources were IEBUPDTE (or PDSLOAD)\n     combined into each pds member.  For example, ASSERT.C\n     as distributed in the original distribution, can be found\n     in the pds member called C, as submember ASSERT.  The only\n     exception to this convention is the MAKEFILE member, where\n     the submembers are the SUFFIX.  For example, MAKEFILE.BCC\n     is submember BCC in member MAKEFILE.\n\n 3.  Two sources in the distribution which didn't have suffixes\n     are included as members of the base pds.  These are:\n     MVSOPTS and MVSZIP.\n\nTo re-create all the pds'es necessary, from this pds, please\ncustomize and run the job called $PDSLOAD.  The load library\ncontaining the PDSLOAD load module is in XMIT format in this\npds, as member PDSLOAD.  To retrieve the load module, do:\n\n  TSO RECEIVE INDS(this.pds(PDSLOAD))\n\nIf you have any questions or comments, please write:\n     Sam Golob  -  sbgolob@attglobal.net   or  sbgolob@cbttape.org\n\n     I am solely responsible for the CBT Tape packaging of this\n     product.  Please do not blame the author, Paul Edwards.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PDPCLIB": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10G\\x012\\x012\\x00\\x00\\xc5\\xc4\\xe6\\xc1\\xd9\\xc4\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:47:30", "lines": 306, "newlines": 306, "modlines": 0, "user": "EDWARDS"}, "text": "            Public Domain C runtime library\n            -------------------------------\n\nVersion : 0.73\nReleased: 1998-04-07\n\nWritten by Paul Edwards.\nReleased to the public domain.\nYou may use this entire package for any purpose whatsoever without\nrestriction.\n\n\n\nINTRODUCTION\n------------\n\nThis project is to create a public domain runtime library which\nconforms to ISO/IEC 9899:1990.  It is expected to be highly OS-specific,\nbut hopefully not too compiler-specific.  It is the job of C library\ndevelopers to make unportable but fast code, not that of the application\ndevelopers.  Anyone wishing to contribute to this project, please contact\nPaul Edwards at avon@matra.com.au.\n\n\nMAIN DESIGN GOALS\n-----------------\n\n1. Application developers should not have to resort to DosOpen, open et al\n   in order to get better performance for binary files.\n\n2. Application developers should not have to resort to using binary mode to\n   get better performance for fgets in text mode.\n\n\nCURRENT STATUS\n--------------\n\nA substantial, but still incomplete version under\n\nOS/2 for:\nEMX 0.9b\nWatcom C++ 10.0b\nIBM CSET++ 2.0\nBorland C++ 1.5\n\nDOS for:\nBorland C++ 3.1\nWatcom C++ 10.0b\n\nMVS for:\nIBM C/370 v2r1m0\n\nPDOS for:\nEMX 0.9b\n\n\nWHO WANTS IT?\n-------------\n\nIt is expected that this archive will interest the following groups of\npeople:\n\n1. People who have a commercial compiler, such as CSET, but would like\nto have the source code to the C runtime library, so that they can\nhave control over it.\n\n2. People who have a commercial compiler, such as Borland, where\nalthough they have the runtime source, Borland have some restrictions\non the use of their object code, saying that the resultant executable\nmust have either their copyright notice on it, or yours, or some such\nrubbish.\n\n3. People who have EMX 0.9b, but would like to be able to modify the\nruntime library code without being bound by any of EMX's licensing\nrestrictions on doing that.\n\n4. People who are interested in the internal workings of a runtime\nlibrary, and would like unrestricted use of any useful code they\nmay find whilst investigating that.\n\n5. Someone who wants to write their own commercial C compiler and\nlibrary, and wants something to use as a base.  This at least gives\nyou the library, there are no public domain C compilers available\nto the best of my knowledge, on any platform.\n\n6. People who have ISO text-processing programs that want a significant\nspeed improvement.\n\n\nUSAGE\n-----\n\nThere are makefiles for all the different compilers supported.  Choose\nthe one you want, and compile it, creating a library if you want, and\nthen compiling your programs in the same way that the \"pdptest\" program\nis compiled.\n\n\n\nPERFORMANCE\n-----------\n\nI have done performance testing (of version 0.07 of PDPCLIB) of the\nstated objectives, using perf*.c as the testing tool, and got the\nfollowing results (on OS/2):\n\n                fgets on text files\n                -------------------\n\nbcc - 12.98 12.98 13.10\ngcc - 12.59 12.51 12.45\nicc - 7.84 7.72 7.76\nwcc - 23.38 23.36 23.34\npbcc - 4.87 4.84 4.85\npgcc - 4.42 4.52 4.50\npicc - 4.87 4.96 4.85\npwcc - 4.87 4.85 4.87\n\nsummary - cset has the best library, watcom the worst.  pdpclib\ncreams the lot.  gcc is the best compiler.\n\n\n                large freads on binary files\n                ----------------------------\n\nbcc - 2.10 2.01 1.98\ngcc - 2.71 2.70 2.64\nicc - 3.87 3.88 3.93\nwcc - 2.18 2.18 2.18\npbcc - 1.83 1.85 1.87\npgcc - 1.89 1.83 1.87\npicc - 1.87 1.84 1.85\npwcc - 1.85 1.83 1.86\n\nsummary - Borland has the best library, cset has the worst.\npdpclib creams the lot.  The compilers are equal.\n\n\n                small freads on binary files\n                ----------------------------\n\nbcc - 8.13 8.27 8.42\ngcc - 3.98 3.92 3.91\nicc - 4.54 4.64 4.68\nwcc - 3.89 3.95 3.93\npbcc - 3.24 3.22 3.19\npgcc - 3.41 3.43 3.41\npicc - 3.24 3.24 3.21\npwcc - 3.21 3.20 3.21\n\nsummary - Borland has the worst library, gcc has the best. pdpclib,\nas usual, beats the lot.  The compilers are basically equal,\nexcept that gcc is slightly worse, as it doesn't generate an\ninline memcpy() for the situation I am using it in.  The main\nreason for gcc having the best library is that it has a default\nbuffer size of 5120 compared to the others at 4096.  Note - in\nother tests I did, gcc was coming out ahead of wcc, by about 5%,\nso I don't know why this particular set of tests had them level.\n\n\nInformation:\nI used a 486DX33 with a RAM disk in order to perform these tests,\nin an effort to concentrate the stats on the library itself rather\nthan the physical hard disk.\nbcc = Borland C++ 1.5\ngcc = EMX 0.9a\nicc = CSET++/2 2.0\nwcc = Watcom 10.0b\np* = PDPCLIB compiled with one of the above compilers.\n\n\nKNOWN LIMITATIONS\n-----------------\n\nNot all printf and scanf formats are supported.\nNo maths library.\nNo floating point support.\nMinimal testing.\nDOS version doesn't do full long arithmetic.\n\n\nHISTORY\n-------\n\n0.01  A lot of stuff has been implemented, and a lot of stuff has\n      not.  However, there has been sufficient amount of work done\n      to make it at least interesting reading.\n\n0.02  Further down the track, but not enough to go bananas about.\n      Main work was done in fopen(), which is far more robust now.\n\n0.03  Got it working on Watcom, CSET + GNU.\n\n0.04  Miscellaneous additions\n\n0.05  There is a function for every single function except those in\n      the math library, but there are still holes in the system,\n      especially with the File I/O.  But now I have all of the\n      fundamental design in place.\n\n0.06  Much more robust file i/o.\n\n0.07  Many bug fixes and enhancements.\n\n0.50  DOS support, and various bug fixes.\n\n0.51  General tidy up.\n\n0.52  Bug fixes for problems found whilst doing PDOS work.\n\n0.60  Added MVS support, since I suddenly had an MVS machine available\n      and had always wondered how on earth C was able to be implemented\n      on that environment.  Now I know some of the answers.\n\n0.61  Implemented a stub function required for some situations under\n      MSDOS.\n\n0.70  Added PDOS support.\n\n0.71  Completed PDOS and fixed DOS bug.\n\n0.73  Revamped interface to PDOS.\n\n\nCREDITS\n-------\n\nXiayi Edwards, my wife, for putting up with me in the many many\n  man-days it took me to write this, when I should have been doing\n  family-related things.\nRay Gardner for making his date routines public domain, plus\n  the qsort routine.\nJim Nutt and Rob Duff for releasing strftime to the public domain.\nRowan Crowe for some mods to memcpy.\nMatthew Parker for getting the program name under MSDOS.\n./ ADD NAME=PDPGOAL  0100-04042-04042-1043-00070-00070-00000-PDPCLIB\n          GOALS OF THE PUBLIC DOMAIN PROJECT\n          ----------------------------------\n\nVersion:  1.3\nDate:     2003-10-29\nAuthor:   Paul Edwards\nInternet: kerravon@w3.to\nStatus:   This document is released to the public domain\n\n\nThe Public Domain Project's philosophy is basically to put as much\nbase material into the public domain so that commercial developers,\nor other PD developers, can build upon it, rather than having to\nreinvent the wheel.  Unless something is public domain, it essentially\nhasn't been invented yet, as far as not needing to reinvent it is\nconcerned.  It's like inventing the cure for cancer and keeping it a\nsecret.  You may as well not have bothered.\n\nThe commercial software which you end up using (which most people use,\nif only for the support) will always be sold at a price designed to\nrecoup costs.  The only way you can reduce the price of commercial\nsoftware is to reduce the costs they have.  One way to do this is to\ngive them quality public domain code on which to use as a basis for\nfurther development.  Normal market forces will guarantee that the\ncost saving goes through to the customer.  It's the basis of\ncapitalism.  Feel free to start your own business and make enormous\nprofits if you disagree.\n\nWhy not use GPL (aka the Gnu Virus License)?  Well, there are three\nbig problems with it.  The first is that if you are a commercial\ndeveloper, and have some spare time to contribute to a freeware\nproduct, after spending 10 hours wading through someone else's code,\ngetting familiar with it, and improving it or bug fixing it, all the\ntime you spent is wasted, as far as being able to reuse any routines\nyou found in a commercial product is concerned.\n\nThe second is that encourages others to join the dog-in-the-manger\nbrigade.  Someone who ordinarily would be happy to contribute something\nto the public domain, once and for all, now instead goes and spends their\neffort on a GPL product, meaning the world still doesn't get the code\nfreely available for ALL use (ie in public domain projects AND commercial\nprojects, not JUST other GPL projects).\n\nThe third is that it is actually technology-inhibitive.  E.g. let's\nsay there's a GPL wordprocessor, but it doesn't support italics.\nQuite a lot of people want italics, but no-one to date has been\nwilling to do that work for free.  Let's say a portion of the market\nwants italics.  But no one individual can afford to pay the cost of\ndevelopment by themselves.  Normally this is where a company would\njump in, do the work, and then sell the new version to the market,\nmeaning that each individual only has to pay a fraction of the\ndevelopment cost.  But the problem is that the company CAN'T just\nmake those changes and sell them, because it can't make those\nchanges proprietary, as it needs to do in order to sell them.  So\ninstead, the commercial operation needs to develop the entire\nequivalent of the GPL wordprocessor, and THEN add italics.  But it\nis too expensive for the company to do that, so the technology is\nsimply never developed!\n\nGPL code will eventually become as useful as public domain code - 50\nyears after the death of the original author, when it becomes public\ndomain!  That's a long time to have to wait.  Until then, unless your\nlawyer informs you that the 2756 license agreement conditions don't\naffect you, the GPL work is only useful as reference material.\n\nThe default for any software written is for it to be copyright by the\nauthor.  Please include an explicit \"Released to the public domain\" if\nyou wish to make your code public domain.  If you wish to contribute\nsome public domain code, please contact Paul Edwards at the address\nabove.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PDPGOAL": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10H\\x00F\\x00F\\x00\\x00\\xc5\\xc4\\xe6\\xc1\\xd9\\xc4\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:48:33", "lines": 70, "newlines": 70, "modlines": 0, "user": "EDWARDS"}, "text": "          GOALS OF THE PUBLIC DOMAIN PROJECT\n          ----------------------------------\n\nVersion:  1.3\nDate:     2003-10-29\nAuthor:   Paul Edwards\nInternet: kerravon@w3.to\nStatus:   This document is released to the public domain\n\n\nThe Public Domain Project's philosophy is basically to put as much\nbase material into the public domain so that commercial developers,\nor other PD developers, can build upon it, rather than having to\nreinvent the wheel.  Unless something is public domain, it essentially\nhasn't been invented yet, as far as not needing to reinvent it is\nconcerned.  It's like inventing the cure for cancer and keeping it a\nsecret.  You may as well not have bothered.\n\nThe commercial software which you end up using (which most people use,\nif only for the support) will always be sold at a price designed to\nrecoup costs.  The only way you can reduce the price of commercial\nsoftware is to reduce the costs they have.  One way to do this is to\ngive them quality public domain code on which to use as a basis for\nfurther development.  Normal market forces will guarantee that the\ncost saving goes through to the customer.  It's the basis of\ncapitalism.  Feel free to start your own business and make enormous\nprofits if you disagree.\n\nWhy not use GPL (aka the Gnu Virus License)?  Well, there are three\nbig problems with it.  The first is that if you are a commercial\ndeveloper, and have some spare time to contribute to a freeware\nproduct, after spending 10 hours wading through someone else's code,\ngetting familiar with it, and improving it or bug fixing it, all the\ntime you spent is wasted, as far as being able to reuse any routines\nyou found in a commercial product is concerned.\n\nThe second is that encourages others to join the dog-in-the-manger\nbrigade.  Someone who ordinarily would be happy to contribute something\nto the public domain, once and for all, now instead goes and spends their\neffort on a GPL product, meaning the world still doesn't get the code\nfreely available for ALL use (ie in public domain projects AND commercial\nprojects, not JUST other GPL projects).\n\nThe third is that it is actually technology-inhibitive.  E.g. let's\nsay there's a GPL wordprocessor, but it doesn't support italics.\nQuite a lot of people want italics, but no-one to date has been\nwilling to do that work for free.  Let's say a portion of the market\nwants italics.  But no one individual can afford to pay the cost of\ndevelopment by themselves.  Normally this is where a company would\njump in, do the work, and then sell the new version to the market,\nmeaning that each individual only has to pay a fraction of the\ndevelopment cost.  But the problem is that the company CAN'T just\nmake those changes and sell them, because it can't make those\nchanges proprietary, as it needs to do in order to sell them.  So\ninstead, the commercial operation needs to develop the entire\nequivalent of the GPL wordprocessor, and THEN add italics.  But it\nis too expensive for the company to do that, so the technology is\nsimply never developed!\n\nGPL code will eventually become as useful as public domain code - 50\nyears after the death of the original author, when it becomes public\ndomain!  That's a long time to have to wait.  Until then, unless your\nlawyer informs you that the 2756 license agreement conditions don't\naffect you, the GPL work is only useful as reference material.\n\nThe default for any software written is for it to be copyright by the\nauthor.  Please include an explicit \"Released to the public domain\" if\nyou wish to make your code public domain.  If you wish to contribute\nsome public domain code, please contact Paul Edwards at the address\nabove.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PDSLOAD": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x10\\x00\\x98\\x01/\\x01\\x04\\x04/\\x11\\t\\x00\\x1d\\x00\\x0c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "2004-02-11T11:09:10", "lines": 29, "newlines": 12, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBP JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//* -------------------------------------------------------------- *//\n//* -- SAMPLE JOB TO CREATE ALL THE PDS'ES NECESSARY            -- *//\n//* --                                                          -- *//\n//* --    Load Module PDSLOAD is member PDSLOAD in XMIT format  -- *//\n//* --    in this pds.                                          -- *//\n//* --                                                          -- *//\n//* --  TSO RECEIVE INDS(this.pds(PDSLOAD))                     -- *//\n//* -------------------------------------------------------------- *//\n//PDSLOAD PROC OPRE=SBGOLOB,MEMBER=XXX,\n//             OUNT=SYSALLDA,OVL=WORK03,DSP2=CATLG,\n//             DSP1=NEW,DSP3='',P=30,S=60,D=137,QUAL=PDPCLIB\n//LOAD EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=userid.CBT464.FILE035.PDS\n//SYSUT1 DD DISP=SHR,DSN=SBGOLOB.CBT465.FILE663(&MEMBER)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2 DD UNIT=&OUNT,VOL=SER=&OVL,DSN=&OPRE..&QUAL..&MEMBER,\n//       DISP=(&DSP1,&DSP2&DSP3),SPACE=(TRK,(&P,&S,&D),RLSE)\n//  PEND\n//ASM      EXEC PDSLOAD,MEMBER=ASM\n//BAT      EXEC PDSLOAD,MEMBER=BAT\n//C        EXEC PDSLOAD,MEMBER=C\n//CMD      EXEC PDSLOAD,MEMBER=CMD\n//H        EXEC PDSLOAD,MEMBER=H\n//IN       EXEC PDSLOAD,MEMBER=IN\n//MAKEFILE EXEC PDSLOAD,MEMBER=MAKEFILE\n//MVS      EXEC PDSLOAD,MEMBER=MVS\n//TXT      EXEC PDSLOAD,MEMBER=TXT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PROGRES": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10I\\x004\\x004\\x00\\x00\\xc5\\xc4\\xe6\\xc1\\xd9\\xc4\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:49:19", "lines": 52, "newlines": 52, "modlines": 0, "user": "EDWARDS"}, "text": "This file describes the progress of the project in terms of\nnumber of functions implemented/roughly implemented.  Where\nthere are no functions, a dummy one is created!  This\narchive may be FREQed from 3:711/934@fidonet with name\nPDPCLIB.*.\n\n\nassert *\n       *\n\nctype  *************\n       *************\n\nerrno  *\n       *\n\nfloat  *\n       *\n\nlimits *\n       *\n\nlocale **\n       **\n\nmath   **********************\n       ****\n\nsetjmp *\n       *\n\nsignal **\n       **\n\nstdarg *\n       *\n\nstddef *\n       *\n\nstdio  *****************************************\n       *****************************************\n\nstdlib ****************************\n       ****************************\n\nstring **********************\n       **********************\n\ntime   *********\n       *********\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$README": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10I\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc5\\xc4\\xe6\\xc1\\xd9\\xc4\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:49:33", "lines": 15, "newlines": 15, "modlines": 0, "user": "EDWARDS"}, "text": "Public Domain C Library\n-----------------------\n\nFiles included:\n\npdpclib.txt  - documentation for this archive\npdpgoal.txt  - philosophy of the Public Domain Project\nprogress.txt - a rough idea of progress to date\n*.c          - source code\n*.asm        - source code\n*.h          - header files\nmakefile.*   - various makefiles\ncompile.cmd  - command to execute makefiles\npdptest.*    - demo program\n*.lib        - lib files for various compilers\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE663": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04A\\x00\\x00\\x01\\x04\\x04/\\x01\\x04\\x04/\\x11\\x18\\x00i\\x00i\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf5@@@'", "ispf": {"version": "04.65", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T11:18:00", "lines": 105, "newlines": 105, "modlines": 0, "user": "CBT-465"}, "text": "//***FILE 663 is from Paul Edwards, and contains a public domain    *   FILE 663\n//*           runtime C Library.                                    *   FILE 663\n//*                                                                 *   FILE 663\n//*                  Public Domain C runtime library                *   FILE 663\n//*                  -------------------------------                *   FILE 663\n//*                                                                 *   FILE 663\n//*      Version : 0.73                                             *   FILE 663\n//*      Released: 1998-04-07                                       *   FILE 663\n//*                                                                 *   FILE 663\n//*      Written by Paul Edwards.                                   *   FILE 663\n//*      Released to the public domain.                             *   FILE 663\n//*      You may use this entire package for any purpose            *   FILE 663\n//*      whatsoever without restriction.                            *   FILE 663\n//*                                                                 *   FILE 663\n//*                                                                 *   FILE 663\n//*                                                                 *   FILE 663\n//*      INTRODUCTION                                               *   FILE 663\n//*      ------------                                               *   FILE 663\n//*                                                                 *   FILE 663\n//*      This project is to create a public domain runtime          *   FILE 663\n//*      library which conforms to ISO/IEC 9899:1990.  It is        *   FILE 663\n//*      expected to be highly OS-specific, but hopefully not too   *   FILE 663\n//*      compiler-specific.  It is the job of C library             *   FILE 663\n//*      developers to make unportable but fast code, not that of   *   FILE 663\n//*      the application developers.  Anyone wishing to             *   FILE 663\n//*      contribute to this project, please contact Paul Edwards    *   FILE 663\n//*      at avon@matra.com.au.                                      *   FILE 663\n//*                                                                 *   FILE 663\n//*                                                                 *   FILE 663\n//*      MAIN DESIGN GOALS                                          *   FILE 663\n//*      -----------------                                          *   FILE 663\n//*                                                                 *   FILE 663\n//*      1. Application developers should not have to resort to     *   FILE 663\n//*         DosOpen, open et al in order to get better              *   FILE 663\n//*         performance for binary files.                           *   FILE 663\n//*                                                                 *   FILE 663\n//*      2. Application developers should not have to resort to     *   FILE 663\n//*         using binary mode to get better performance for fgets   *   FILE 663\n//*         in text mode.                                           *   FILE 663\n//*                                                                 *   FILE 663\n//*      CURRENT STATUS                                             *   FILE 663\n//*      --------------                                             *   FILE 663\n//*                                                                 *   FILE 663\n//*      A substantial, but still incomplete version under          *   FILE 663\n//*                                                                 *   FILE 663\n//*      OS/2 for:                                                  *   FILE 663\n//*      EMX 0.9b                                                   *   FILE 663\n//*      Watcom C++ 10.0b                                           *   FILE 663\n//*      IBM CSET++ 2.0                                             *   FILE 663\n//*      Borland C++ 1.5                                            *   FILE 663\n//*                                                                 *   FILE 663\n//*      DOS for:                                                   *   FILE 663\n//*      Borland C++ 3.1                                            *   FILE 663\n//*      Watcom C++ 10.0b                                           *   FILE 663\n//*                                                                 *   FILE 663\n//*      MVS for:                                                   *   FILE 663\n//*      IBM C/370 v2r1m0                                           *   FILE 663\n//*                                                                 *   FILE 663\n//*      PDOS for:                                                  *   FILE 663\n//*      EMX 0.9b                                                   *   FILE 663\n//*                                                                 *   FILE 663\n//*                                                                 *   FILE 663\n//*      WHO WANTS IT?                                              *   FILE 663\n//*      -------------                                              *   FILE 663\n//*                                                                 *   FILE 663\n//*      It is expected that this archive will interest the         *   FILE 663\n//*      following groups of people:                                *   FILE 663\n//*                                                                 *   FILE 663\n//*      1. People who have a commercial compiler, such as CSET,    *   FILE 663\n//*      but would like to have the source code to the C runtime    *   FILE 663\n//*      library, so that they can have control over it.            *   FILE 663\n//*                                                                 *   FILE 663\n//*      2. People who have a commercial compiler, such as          *   FILE 663\n//*      Borland, where although they have the runtime source,      *   FILE 663\n//*      Borland have some restrictions on the use of their         *   FILE 663\n//*      object code, saying that the resultant executable must     *   FILE 663\n//*      have either their copyright notice on it, or yours, or     *   FILE 663\n//*      some such rubbish.                                         *   FILE 663\n//*                                                                 *   FILE 663\n//*      3. People who have EMX 0.9b, but would like to be able     *   FILE 663\n//*      to modify the runtime library code without being bound     *   FILE 663\n//*      by any of EMX's licensing restrictions on doing that.      *   FILE 663\n//*                                                                 *   FILE 663\n//*      4. People who are interested in the internal workings of   *   FILE 663\n//*      a runtime library, and would like unrestricted use of      *   FILE 663\n//*      any useful code they may find whilst investigating that.   *   FILE 663\n//*                                                                 *   FILE 663\n//*      5. Someone who wants to write their own commercial C       *   FILE 663\n//*      compiler and library, and wants something to use as a      *   FILE 663\n//*      base.  This at least gives you the library, there are no   *   FILE 663\n//*      public domain C compilers available to the best of my      *   FILE 663\n//*      knowledge, on any platform.                                *   FILE 663\n//*                                                                 *   FILE 663\n//*      6. People who have ISO text-processing programs that       *   FILE 663\n//*      want a significant speed improvement.                      *   FILE 663\n//*                                                                 *   FILE 663\n//*      USAGE                                                      *   FILE 663\n//*      -----                                                      *   FILE 663\n//*                                                                 *   FILE 663\n//*      There are makefiles for all the different compilers        *   FILE 663\n//*      supported.  Choose the one you want, and compile it,       *   FILE 663\n//*      creating a library if you want, and then compiling your    *   FILE 663\n//*      programs in the same way that the \"pdptest\" program is     *   FILE 663\n//*      compiled.                                                  *   FILE 663\n//*                                                                 *   FILE 663\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASM": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10F\\x05\\xcf\\x05\\xcf\\x00\\x00\\xd7\\xc4\\xd7\\xc3\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:46:00", "lines": 1487, "newlines": 1487, "modlines": 0, "user": "PDPCLIB"}, "text": "./ ADD NAME=DOSSTART 0100-04042-04042-1042-00104-00104-00000-PDPCLIB\n; dosstart.asm - startup code for C programs for DOS\n;\n; This program written by Paul Edwards\n; Released to the public domain\n\n.model large\n\nextrn ___start:proc\n\npublic ___psp\npublic ___envptr\npublic ___osver\n\n_DATA   segment word public 'DATA'\nbanner  db  \"PDPCLIB\"\n___psp   dd  ?\n___envptr dd ?\n___osver dw ?\n_DATA   ends\n_BSS    segment word public 'BSS'\n_BSS    ends\n_STACK  segment word stack 'STACK'\n        db 1000h dup(?)\n_STACK  ends\n\nDGROUP  group   _DATA,_BSS\n        assume cs:_TEXT,ds:DGROUP\n\n_TEXT segment word public 'CODE'\n\ntop:\n\n___intstart proc\n\n; add some nops to create a cs-addressable save area, and also create a\n; bit of an eyecatcher\n\nnop\nnop\nnop\nnop\n\n; push the psp now, ready for calling start\npush ds\nmov ax, 0\npush ax\n\n; free initially allocated memory\n\nmov bx, 01111h\nmov ah, 4ah\nint 21h\n\nmov dx,DGROUP\nmov ds,dx\n\nmov ah,30h\nint 21h\nxchg al,ah\nmov [___osver],ax\n\nmov word ptr ___psp, 0\nmov word ptr [___psp + 2], es\nmov word ptr ___envptr, 0\nmov dx, es:[02ch]\nmov word ptr [___envptr + 2], dx\nmov dx, ds\nmov es, dx\n\n; we have already pushed the pointer to psp\ncall far ptr ___start\nadd sp, 4  ; delete psp from stack\n\npush ax\n\n; how do I get rid of the warning about \"instruction can be compacted\n; with override\"?  The answer is certainly NOT to change the \"far\" to\n; \"near\".\ncall far ptr ___exita\nadd sp, 2\nret\n___intstart endp\n\npublic ___exita\n___exita proc\npush bp\nmov bp, sp\nmov ax, [bp + 6]\nmov ah,4ch\nint 21h ; terminate\npop bp\nret\n___exita endp\n\n\npublic ___main\n___main proc\nret\n___main endp\n\n\n_TEXT ends\n\nend top\n./ ADD NAME=DOSSUPA  0100-04042-04042-1042-00736-00736-00000-PDPCLIB\n; dossupa.asm - assembler support functions for DOS\n;\n; This program written by Paul Edwards\n; Released to the public domain\n\n.model large\n\nextrn ___divide:proc\nextrn ___modulo:proc\n\npublic fidrqq\npublic fiwrqq\n\n_DATA   segment word public 'DATA'\nfidrqq  dw  ?\nfiwrqq  dw  ?\n_DATA   ends\n_BSS    segment word public 'BSS'\n_BSS    ends\n\nDGROUP  group   _DATA,_BSS\n        assume cs:_TEXT,ds:DGROUP\n\n_TEXT segment word public 'CODE'\n\npublic ___open\n___open proc\npush bp\nmov bp, sp\n\npush bx\npush dx\npush ds\n\nmov dx,[bp+8]\nmov ds,dx\nmov dx,[bp+6]\nmov al,[bp+11]\n\nmov ah, 3dh\nint 21h\n\njc ___open1\nmov dx,[bp+14]\nmov ds,dx\nmov bx,[bp+12]\nmov word ptr [bx], 0\njmp short ___open2\n___open1:\nmov dx,[bp+14]\nmov ds,dx\nmov bx,[bp+12]\nmov word ptr [bx], 1\n___open2:\npop ds\npop dx\npop bx\n\npop bp\nret\n___open endp\n\n\npublic ___read\n___read proc\npush bp\nmov bp,sp\n\npush bx\npush cx\npush dx\npush ds\n\nmov bx,[bp+6]\nmov dx,[bp+10]\nmov ds,dx\nmov dx,[bp+8]\nmov cx,[bp+12]\n\nmov ah, 3fh\nint 21h\n\njc ___read1\nmov dx,[bp+16]\nmov ds,dx\nmov bx,[bp+14]\nmov word ptr [bx], 0\njmp short ___read2\n___read1:\nmov dx,[bp+16]\nmov ds,dx\nmov bx,[bp+14]\nmov word ptr [bx], 1\n___read2:\n\npop ds\npop dx\npop cx\npop bx\n\npop bp\nret\n___read endp\n\n\npublic ___write\n___write proc\npush bp\nmov bp,sp\n\npush bx\npush cx\npush dx\npush ds\n\nmov bx,[bp+6]\nmov dx,[bp+10]\nmov ds,dx\nmov dx,[bp+8]\nmov cx,[bp+12]\n\nmov ah, 40h\nint 21h\n\njc ___write1\nmov dx,[bp+16]\nmov ds,dx\nmov bx,[bp+14]\nmov word ptr [bx], 0\njmp short ___write2\n___write1:\nmov dx,[bp+16]\nmov ds,dx\nmov bx,[bp+14]\nmov word ptr [bx], 1\n___write2:\n\npop ds\npop dx\npop cx\npop bx\n\npop bp\nret\n___write endp\n\n\n; seek - handle, offset, type\n\npublic ___seek\n___seek proc\npush bp\nmov bp, sp\npush bx\npush dx\npush cx\n\nmov bx, [bp + 8]\nmov dx, [bp + 10]\nmov cx, [bp + 12]\nmov al, [bp + 13]\n\nmov ah, 042h\nint 021h\n\npop cx\npop dx\npop bx\npop bp\nret\n___seek endp\n\n\npublic ___close\n___close proc\npush bp\nmov bp, sp\npush bx\n\nmov bx,[bp+8]\n\nmov ah, 03eh\nint 021h\n\npop bx\npop bp\nret\n___close endp\n\n\npublic ___remove\n___remove proc\npush bp\nmov bp, sp\npush ds\npush dx\n\nmov dx, [bp + 8]\nmov ds, [bp + 10]\n\nmov ah, 041h\nint 021h\n\npop dx\npop ds\npop bp\nret\n___remove endp\n\n\npublic ___rename\n___rename proc\npush bp\nmov bp, sp\npush ds\npush dx\npush es\npush di\n\nmov dx, [bp + 8]\nmov ds, [bp + 10]\nmov di, [bp + 12]\nmov es, [bp + 14]\n\nmov ah, 056h\nint 021h\n\npop di\npop es\npop dx\npop ds\npop bp\nret\n___rename endp\n\n\n\npublic ___allocmem\n___allocmem proc\npush bp\nmov bp,sp\n\npush bx\npush dx\npush ds\n\nmov bx,[bp+6]\n\nshr bx,1\nshr bx,1\nshr bx,1\nshr bx,1\n\nadd bx,1\nmov ah, 48h\nint 21h\n\njnc allocok\nmov ax, 0\nallocok:\nmov dx,[bp+10]\nmov ds,dx\nmov bx,[bp+8]\n\nmov word ptr [bx], 0\nmov word ptr [bx+2], ax\n\npop ds\npop dx\npop bx\npop bp\nret\n___allocmem endp\n\n\npublic ___freemem\n___freemem proc\npush bp\nmov bp,sp\npush es\npush dx\npush cx\n\nmov dx,[bp+6]\nmov cx,[bp+8]\n\nshr dx, 1\nshr dx, 1\nshr dx, 1\nshr dx, 1\n\nadd cx, dx\nmov es, cx\nmov ah, 049h\nint 21h\n\npop cx\npop dx\npop es\npop bp\nret\n___freemem endp\n\n\n; full path, parm block\npublic ___exec\n___exec proc\npush bp\nmov bp, sp\npush ds\npush dx\npush es\npush bx\npush cx\npush si\npush di\n\nmov dx, [bp + 6]\nmov ds, [bp + 8]\nmov bx, [bp + 10]\nmov es, [bp + 12]\n\njmp short bypass\ndummy1 dw ?\ndummy2 dw ?\nbypass:\n\nmov dummy1, sp\nmov dummy2, ss\n\nmov al, 0\nmov ah, 04bh\ncld              ; dos 2 \"bug\"\nint 21h\n\ncli\nmov ss, dummy2\nmov sp, dummy1\nsti\n\npop di\npop si\npop cx\npop bx\npop es\npop dx\npop ds\npop bp\nret\n___exec endp\n\n\npublic ___datetime\n___datetime proc\npush bp\nmov bp, sp\npush ds\npush dx\npush cx\npush bx\n\nmov bx, [bp + 6]\nmov ds, [bp + 8]\n\nmov ah, 02ah\nint 021h\n\nmov [bx + 0], cx\nmov ch, 0\nmov cl, dh\nmov [bx + 2], cx\nmov dh, 0\nmov [bx + 4], dx\n\nmov ah, 02ch\nint 021h\n\nmov ah, 0\nmov al, ch\nmov [bx + 6], ax\nmov ch, 0\nmov [bx + 8], cx\nmov ah, 0\nmov al, dh\nmov [bx + 10], ax\nmov dh, 0\nmov [bx + 12], dx\n\npop bx\npop cx\npop dx\npop ds\npop bp\nret\n___datetime endp\n\n\nifdef WATCOM\n; divide dx:ax by cx:bx, result in dx:ax\npublic __U4D\n__U4D proc\npush cx\npush bx\npush dx\npush ax\npush cx\npush bx\npush dx\npush ax\ncall far ptr f_lumod@\nmov cx, dx\nmov bx, ax\ncall far ptr f_ludiv@\nret\n__U4D endp\nendif\n\n\npublic f_ludiv@\nf_ludiv@ proc far\npush bp\nmov bp,sp\npush bx\n\ncmp word ptr [bp + 12], 0\njne ludiv_full\n\nmov ax, [bp + 8]\nmov dx, 0\ndiv word ptr [bp + 10]\nmov bx, ax\nmov ax, [bp + 6]\ndiv word ptr [bp + 10]\n\nmov dx, bx\njmp short ludiv_fin\n\nludiv_full:\npush word ptr [bp + 12]\npush word ptr [bp + 10]\npush word ptr [bp + 8]\npush word ptr [bp + 6]\ncall far ptr ___divide\nadd sp, 8\n\nludiv_fin:\n\npop bx\npop bp\nret 8\nf_ludiv@ endp\n\n\n; dx:ax divided by cx:bx, result in dx:ax, module on cx:bx\n\nifdef WATCOM\npublic __I4D\n__I4D proc\npush cx\npush bx\npush dx\npush ax\npush cx\npush bx\npush dx\npush ax\ncall far ptr f_lmod@\nmov cx, dx\nmov bx, ax\ncall far ptr f_ldiv@\nret\n__I4D endp\nendif\n\n\n; must release stack space in this procedure\npublic f_ldiv@\nf_ldiv@ proc\npush bp\nmov bp,sp\npush dx\n\ncmp word ptr [bp + 12], 0\njne ldiv_full\n\nmov ax,[bp+6]\nmov dx,[bp+8]\nidiv word ptr [bp+10]\njmp short ldiv_fin\n\nldiv_full:\npush word ptr [bp + 12]\npush word ptr [bp + 10]\npush word ptr [bp + 8]\npush word ptr [bp + 6]\ncall far ptr ___divide\nadd sp, 8\n\nldiv_fin:\n\npop dx\npop bp\nret 8\nf_ldiv@ endp\n\n\npublic f_lmod@\nf_lmod@ proc\npush bp\nmov bp,sp\n\ncmp word ptr [bp + 12], 0\njne lmod_full\n\nmov ax,[bp+6]\nmov dx,[bp+8]\nidiv word ptr [bp+10]\nmov ax,dx\nmov dx,0\njmp short lmod_fin\n\nlmod_full:\npush word ptr [bp + 12]\npush word ptr [bp + 10]\npush word ptr [bp + 8]\npush word ptr [bp + 6]\ncall far ptr ___modulo\nadd sp, 8\n\nlmod_fin:\n\npop bp\nret 8\nf_lmod@ endp\n\n\n; procedure needs to fix up stack\npublic f_lumod@\nf_lumod@ proc\npush bp\nmov bp,sp\n\ncmp word ptr [bp + 12], 0\njne lumod_full\n\nmov ax, [bp + 8]\nmov dx, 0\ndiv word ptr [bp + 10]\nmov ax, [bp + 6]\ndiv word ptr [bp + 10]\nmov ax,dx\nmov dx, 0\njmp short lumod_fin\n\nlumod_full:\npush word ptr [bp + 12]\npush word ptr [bp + 10]\npush word ptr [bp + 8]\npush word ptr [bp + 6]\ncall far ptr ___modulo\nadd sp, 8\n\nlumod_fin:\n\npop bp\nret 8\nf_lumod@ endp\n\n\n; multiply cx:bx by dx:ax, result in dx:ax\n\npublic f_lxmul@\npublic __I4M\npublic __U4M\nf_lxmul@ proc\n__I4M:\n__U4M:\npush bp\nmov bp,sp\npush cx\n\npush ax\nmul cx\nmov cx, ax\npop ax\nmul bx\nadd dx, cx\n\npop cx\npop bp\nret\nf_lxmul@ endp\n\n\n; shift dx:ax left by cl\n\npublic f_lxlsh@\nf_lxlsh@ proc\npush bx\n\ncmp cl, 24\njl lxlsh_16\nmov dh, al\nmov dl, 0\nmov ax, 0\nsub cl, 24\njmp short lxlsh_last\n\nlxlsh_16:\ncmp cl, 16\njl lxlsh_8\nmov dx, ax\nmov ax, 0\nsub cl, 16\njmp short lxlsh_last\n\nlxlsh_8:\ncmp cl, 8\njl lxlsh_last\nmov dh, dl\nmov dl, ah\nmov ah, al\nmov al, 0\nsub cl, 8\n;jmp short lxlsh_last\n\nlxlsh_last:\n\nmov ch, 8\nsub ch, cl\nxchg ch, cl\nmov bx, ax\nshr bx, cl\nxchg ch, cl\nshl dx, cl\nor dl, bh\nshl ax, cl\n\npop bx\nret\nf_lxlsh@ endp\n\n\n; shift dx:ax right by cl\n\npublic f_lxursh@\nf_lxursh@ proc\npush bx\n\ncmp cl, 24\njl lxursh_16\nmov al, dh\nmov ah, 0\nmov dx, 0\nsub cl, 24\njmp short lxursh_last\n\nlxursh_16:\ncmp cl, 16\njl lxursh_8\nmov ax, dx\nmov dx, 0\nsub cl, 16\njmp short lxursh_last\n\nlxursh_8:\ncmp cl, 8\njl lxursh_last\nmov al, ah\nmov ah, dl\nmov dl, dh\nmov dh, 0\nsub cl, 8\n;jmp short lxursh_last\n\nlxursh_last:\n\nmov ch, 8\nsub ch, cl\nxchg ch, cl\nmov bx, dx\nshl bx, cl\nxchg ch, cl\nshr ax, cl\nor ah, bl\nshr dx, cl\n\npop bx\nret\nf_lxursh@ endp\n\n\n; this procedure needs to fix up the stack\npublic f_scopy@\nf_scopy@ proc\n\npush bp\nmov bp, sp\npush cx\npush ds\npush es\npush si\npush di\nlds si, [bp + 6]\nles di, [bp + 10]\ncld\nrep movsb\n\npop di\npop si\npop es\npop ds\npop cx\npop bp\nret 8\nf_scopy@ endp\n\n\npublic f_ftol@\nf_ftol@ proc\nret\nf_ftol@ endp\n\npublic ___SIN__\n___SIN__ proc\nret\n___SIN__ endp\n\npublic ___COS__\n___COS__ proc\nret\n___COS__ endp\n\n_TEXT ends\n\nend\n./ ADD NAME=MVSSTART 0100-04042-04042-1042-00153-00153-00000-PDPCLIB\n**********************************************************************\n*                                                                    *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                             *\n*  RELEASED TO THE PUBLIC DOMAIN                                     *\n*                                                                    *\n**********************************************************************\n**********************************************************************\n*                                                                    *\n*  MVSSTART - STARTUP ROUTINES FOR MVS FOR USE WITH C/370.           *\n*                                                                    *\n*  NOTE THAT THE AMODE/RMODE AND CSVQUERY HAVE BEEN COMMENTED        *\n*  OUT IN ORDER TO BE COMPATIBLE WITH IFOX (OS/360).  ON OS/370      *\n*  AND ABOVE THE AMODE/RMODE CAN BE GIVEN AT ASSEMBLY AND LINK       *\n*  TIME INSTEAD.  WITHOUT CSVQUERY, WHEN RUN UNDER TSO, THE          *\n*  PROGRAM NAME WILL BE IKJEFT01 INSTEAD OF THE NORMAL NAME, BUT     *\n*  THAT WILL NOT AFFECT PROGRAM FUNCTIONALITY.                       *\n*                                                                    *\n**********************************************************************\n         PRINT NOGEN\n* YREGS IS NOT AVAILABLE WITH IFOX\n*         YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSUBPOOL  EQU   0\n         CSECT\n*@@MVSTRT AMODE 31\n*@@MVSTRT RMODE ANY\n         ENTRY @@MVSTRT\n@@MVSTRT EQU   *\n         SAVE  (14,12),,@@MVSTRT\n         LR    R10,R15\n         USING @@MVSTRT,R10\n         LR    R11,R1\n         GETMAIN RU,LV=STACKLEN,SP=SUBPOOL\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING STACK,R13\n*\n         LA    R2,0\n         ST    R2,DUMMYPTR       WHO KNOWS WHAT THIS IS USED FOR\n         LA    R2,MAINSTK\n         ST    R2,THEIRSTK       NEXT AVAILABLE SPOT IN STACK\n         LA    R12,ANCHOR\n         ST    R14,EXITADDR\n         L     R3,=A(MAINLEN)\n         AR    R2,R3\n         ST    R2,12(R12)        TOP OF STACK POINTER\n         LA    R2,0\n         ST    R2,116(R12)       ADDR OF MEMORY ALLOCATION ROUTINE\n         ST    R2,ARGPTR\n*\n         L     R2,CVTPTR\n         USING CVT,R2\n         L     R2,CVTTCBP\n         L     R2,4(R2)\n         USING TCB,R2\n         L     R2,TCBJSCB\n         USING IEZJSCB,R2\n         MVC   PGMNAME,JSCBPGMN\n*\n         LH    R2,JSCBTJID\n         ST    R2,TYPE\n         L     R2,0(R1)\n         LA    R2,0(R2)\n         ST    R2,ARGPTR\n         LA    R2,PGMNAME\n         ST    R2,PGMNPTR\n*\n* FOR GCC WE NEED TO BE ABLE TO RESTORE R13\n         L     R5,SAVEAREA+4\n         ST    R5,SAVER13\n*\n*         LA    R2,=V(@@MVSTRT)\n*         CSVQUERY INADDR=(R2),OUTMJNM=PGMNAME,MF=(E,CSVQC)\n*\n         LA    R1,PARMLIST\n         CALL  @@START\n         B     RETURN\n*\nRETURN   DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R15\n         FREEMAIN RU,LV=STACKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\nSAVER13  DS    F\n         LTORG\n*CEESTART AMODE 31\n*CEESTART RMODE ANY\n*         ENTRY CEESTART\n*CEESTART EQU   *\n*CEESG003 AMODE 31\n*CEESG003 RMODE ANY\n*         ENTRY CEESG003\n*CEESG003 EQU   *\n*@@CRT0    AMODE 31\n*@@CRT0    RMODE ANY\n         ENTRY @@CRT0\n@@CRT0   EQU   *\n*@@EXITA  AMODE 31\n*@@EXITA  RMODE ANY\n         ENTRY @@EXITA\n@@EXITA  EQU   *\n*         L     R14,0(R12)\n*         L     R15,0(R1)\n* FOR GCC, WE HAVE TO USE OUR SAVED R13\n         DROP  R10\n         USING @@EXITA,R15\n         L     R13,=A(SAVER13)\n         L     R13,0(R13)\n         L     R15,0(R1)\n         RETURN (14,12),RC=(15)\n*         BR    R14\n         LTORG\n*\n         CVT   DSECT=YES\n         IKJTCB\n         IEZJSCB\nSTACK    DSECT\nSAVEAREA DS    18F\nDUMMYPTR DS    F\nTHEIRSTK DS    F\nPARMLIST DS    0F\nARGPTR   DS    F\nPGMNPTR  DS    F\nTYPE     DS    F\nPGMNAME  DS    CL8\nPGMNAMEN DS    C                 NUL BYTE FOR C\nANCHOR   DS    0F\nEXITADDR DS    F\n         DS    49F\n*         CSVQUERY MF=(L,CSVQC)\nMAINSTK  DS    8000F\nMAINLEN  EQU   *-MAINSTK\nSTACKLEN EQU   *-STACK\n         END\n./ ADD NAME=MVSSUPA  0100-04042-04042-1042-00375-00375-00000-PDPCLIB\n**********************************************************************\n*                                                                    *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                             *\n*  RELEASED TO THE PUBLIC DOMAIN                                     *\n*                                                                    *\n**********************************************************************\n**********************************************************************\n*                                                                    *\n*  MVSSUPA - SUPPORT ROUTINES FOR PDPCLIB UNDER MVS                  *\n*                                                                    *\n*  NOTE - IF USING 31-BIT ADDRESSING, YOU NEED TO REINSTATE          *\n*  THE ONE LINE THAT HAS \"LOC=BELOW\" IN IT.                          *\n*                                                                    *\n**********************************************************************\n         PRINT NOGEN\n* YREGS IS NOT AVAILABLE WITH IFOX\n*         YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSUBPOOL  EQU   0\n         CSECT\n*@@AOPEN  AMODE 31\n*@@AOPEN  RMODE ANY\n         ENTRY @@AOPEN\n@@AOPEN  EQU   *\n         SAVE  (14,12),,@@AOPEN\n         LR    R12,R15\n         USING @@AOPEN,R12\n         LR    R11,R1\n         GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R3,0(R1)         R3 POINTS TO DDNAME\n         L     R4,4(R1)         R4 POINTS TO MODE\n         L     R5,8(R1)         R5 POINTS TO RECFM\n         L     R8,12(R1)        R8 POINTS TO LRECL\n         L     R9,16(R1)        R9 POINTS TO MEMBER NAME (OF PDS)\n*         GETMAIN RU,LV=ZDCBLEN,SP=SUBPOOL,LOC=BELOW\n* CAN'T USE \"BELOW\" ON MVS 3.8\n         GETMAIN RU,LV=ZDCBLEN,SP=SUBPOOL\n         LR    R2,R1\n* THIS LINE IS FOR GCC\n         LR    R6,R4\n* THIS LINE IS FOR C/370\n*         L     R6,0(R4)\n         LTR   R6,R6\n         BNZ   WRITING\n* READING\n         USING ZDCBAREA,R2\n         MVC   ZDCBAREA(INDCBLN),INDCB\n         MVC   EOFR24(EOFRLEN),ENDFILE\n         LA    R10,JFCB\n* EXIT TYPE 07 + 80 (END OF LIST INDICATOR)\n         ICM   R10,B'1000',=X'87'\n         ST    R10,JFCBPTR\n         LA    R10,JFCBPTR\n         LA    R4,EOFR24\n         USING IHADCB,R2\n         STCM  R4,B'0111',DCBEODA\n         STCM  R10,B'0111',DCBEXLSA\n         MVC   DCBDDNAM,0(R3)\n         MVC   OPENMB,OPENMAC\n* NOTE THAT THIS IS CURRENTLY NOT REENTRANT AND SHOULD BE MADE SO\n         RDJFCB ((R2),INPUT)\n         LTR   R9,R9\n         BZ    NOMEM\n         USING ZDCBAREA,R2\n         MVC   JFCBELNM,0(R9)\n         OI    JFCBIND1,JFCPDS\nNOMEM    DS    0H\n*         OPEN  ((R2),INPUT),MF=(E,OPENMB),MODE=31,TYPE=J\n* CAN'T USE MODE=31 ON MVS 3.8, OR WITH TYPE=J\n         OPEN  ((R2),INPUT),MF=(E,OPENMB),TYPE=J\n         B     DONEOPEN\nWRITING  DS    0H\n         USING ZDCBAREA,R2\n         MVC   ZDCBAREA(OUTDCBLN),OUTDCB\n         LA    R10,JFCB\n* EXIT TYPE 07 + 80 (END OF LIST INDICATOR)\n         ICM   R10,B'1000',=X'87'\n         ST    R10,JFCBPTR\n         LA    R10,JFCBPTR\n         USING IHADCB,R2\n         STCM  R10,B'0111',DCBEXLSA\n         MVC   DCBDDNAM,0(R3)\n         MVC   WOPENMB,WOPENMAC\n* NOTE THAT THIS IS CURRENTLY NOT REENTRANT AND SHOULD BE MADE SO\n         RDJFCB ((R2),OUTPUT)\n         LTR   R9,R9\n         BZ    WNOMEM\n         USING ZDCBAREA,R2\n         MVC   JFCBELNM,0(R9)\n         OI    JFCBIND1,JFCPDS\nWNOMEM   DS    0H\n*         OPEN  ((R2),OUTPUT),MF=(E,WOPENMB),MODE=31,TYPE=J\n* CAN'T USE MODE=31 ON MVS 3.8, OR WITH TYPE=J\n         OPEN  ((R2),OUTPUT),MF=(E,WOPENMB),TYPE=J\nDONEOPEN DS    0H\n         USING IHADCB,R2\n         SR    R6,R6\n         LH    R6,DCBLRECL\n         ST    R6,0(R8)\n         SR    R6,R6\n         IC    R6,DCBRECFM\n         LA    R7,DCBRECF\n         NR    R6,R7\n         BZ    VARIABLE\n         L     R6,=F'0'\n         B     DONESET\nVARIABLE DS    0H\n         L     R6,=F'1'\nDONESET  DS    0H\n         ST    R6,0(R5)\n         LR    R15,R2\n         B     RETURN\n*\n* THIS IS NOT EXECUTED DIRECTLY, BUT COPIED INTO 24-BIT STORAGE\nENDFILE  LA    R6,1\n         BR    R14\nEOFRLEN  EQU   *-ENDFILE\n*\nRETURN   DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R15\n         FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\n         LTORG\n* OPENMAC  OPEN  (,INPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\nOPENMAC  OPEN  (,INPUT),MF=L,TYPE=J\nOPENMLN  EQU   *-OPENMAC\n* WOPENMAC OPEN  (,OUTPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\nWOPENMAC OPEN  (,OUTPUT),MF=L\nWOPENMLN EQU   *-WOPENMAC\nINDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\nINDCBLN  EQU   *-INDCB\nJPTR     DS    F\nOUTDCB   DCB   MACRF=PL,DSORG=PS\nOUTDCBLN EQU   *-OUTDCB\n*\n*\n*\n*@@AREAD  AMODE 31\n*@@AREAD  RMODE ANY\n         ENTRY @@AREAD\n@@AREAD  EQU   *\n         SAVE  (14,12),,@@AREAD\n         LR    R12,R15\n         USING @@AREAD,R12\n         LR    R11,R1\n         GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         L     R3,4(R1)         R3 POINTS TO BUF POINTER\n         LA    R6,0\n         GET   (R2)\n         ST    R1,0(R3)\n         LR    R15,R6\n         B     RETURN2\n*\nRETURN2  DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R15\n         FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\n*\n*\n*\n*@@AWRITE AMODE 31\n*@@AWRITE RMODE ANY\n         ENTRY @@AWRITE\n@@AWRITE EQU   *\n         SAVE  (14,12),,@@AWRITE\n         LR    R12,R15\n         USING @@AWRITE,R12\n         LR    R11,R1\n         GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         L     R3,4(R1)         R3 POINTS TO BUF POINTER\n         PUT   (R2)\n         ST    R1,0(R3)\n         LA    R15,0\n         B     RETURNWR\n*\nRETURNWR DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R15\n         FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\n*\n*\n*\n*@@ACLOSE AMODE 31\n*@@ACLOSE RMODE ANY\n         ENTRY @@ACLOSE\n@@ACLOSE EQU   *\n         SAVE  (14,12),,@@ACLOSE\n         LR    R12,R15\n         USING @@ACLOSE,R12\n         LR    R11,R1\n         GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         N     R2,=X'7FFFFFFF'\n         MVC   CLOSEMB,CLOSEMAC\n*         CLOSE ((R2)),MF=(E,CLOSEMB),MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\n         CLOSE ((R2)),MF=(E,CLOSEMB)\n         FREEMAIN RU,LV=ZDCBLEN,A=(R2),SP=SUBPOOL\n         LA    R15,0\n         B     RETURN3\n*\nRETURN3  DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R15\n         FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\n         LTORG\n* CLOSEMAC CLOSE (),MF=L,MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\nCLOSEMAC CLOSE (),MF=L\nCLOSEMLN EQU   *-CLOSEMAC\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  GETM - GET MEMORY                                                 *\n*                                                                    *\n**********************************************************************\n*@@GETM   AMODE 31\n*@@GETM   RMODE ANY\n         ENTRY @@GETM\n@@GETM   EQU   *\n         SAVE  (14,12),,@@GETM\n         LR    R12,R15\n         USING @@GETM,R12\n*\n         L     R2,0(R1)\n* THIS LINE IS FOR GCC\n         LR    R3,R2\n* THIS LINE IS FOR C/370\n*         L     R3,0(R2)\n         A     R3,=F'16'\n         GETMAIN RU,LV=(R3),SP=SUBPOOL\n         ST    R3,0(R1)\n         A     R1,=F'16'\n         LR    R15,R1\n*\nRETURNGM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  FREEM - FREE MEMORY                                               *\n*                                                                    *\n**********************************************************************\n*@@FREEM  AMODE 31\n*@@FREEM  RMODE ANY\n         ENTRY @@FREEM\n@@FREEM  EQU   *\n         SAVE  (14,12),,@@FREEM\n         LR    R12,R15\n         USING @@FREEM,R12\n*\n         L     R2,0(R1)\n         S     R2,=F'16'\n         L     R3,0(R2)\n         FREEMAIN RU,LV=(R3),A=(R2),SP=SUBPOOL\n*\nRETURNFM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  GETCLCK - GET THE VALUE OF THE MVS CLOCK TIMER AND MOVE IT TO AN  *\n*  8-BYTE FIELD.  THIS 8-BYTE FIELD DOES NOT NEED TO BE ALIGNED IN   *\n*  ANY PARTICULAR WAY.                                               *\n*                                                                    *\n*  E.G. CALL 'GETCLCK' USING WS-CLOCK1                               *\n*                                                                    *\n*  THIS FUNCTION ALSO RETURNS THE NUMBER OF SECONDS SINCE 1970-01-01 *\n*  BY USING SOME EMPERICALLY-DERIVED MAGIC NUMBERS                   *\n*                                                                    *\n**********************************************************************\n*@@GETCLK AMODE 31\n*@@GETCLK RMODE ANY\n         ENTRY @@GETCLK\n@@GETCLK EQU   *\n         SAVE  (14,12),,@@GETCLK\n         LR    R12,R15\n         USING @@GETCLK,R12\n*\n         L     R2,0(R1)\n         STCK  0(R2)\n         L     R4,0(R2)\n         L     R5,4(R2)\n         SRDL  R4,12\n         SL    R4,=X'0007D910'\n         D     R4,=F'1000000'\n         SL    R5,=F'1220'\n         LR    R15,R5\n*\nRETURNGC DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\nWORKAREA DSECT\nSAVEAREA DS    18F\n         DS    0F\nCLOSEMB  DS    CL(CLOSEMLN)\n         DS    0F\nOPENMB   DS    CL(OPENMLN)\n         DS    0F\nWOPENMB  DS    CL(WOPENMLN)\nWORKLEN  EQU   *-WORKAREA\nZDCBAREA DSECT\n         DS    CL(INDCBLN)\n         DS    CL(OUTDCBLN)\n         DS    0H\nEOFR24   DS    CL(EOFRLEN)\nJFCBPTR  DS    F\nJFCB     DS    0F\n         IEFJFCBN\nZDCBLEN  EQU   *-ZDCBAREA\n         DCBD  DSORG=PS\n         END\n./ ADD NAME=OSSTART  0100-04042-04042-1042-00063-00063-00000-PDPCLIB\n; osstart.asm - startup code for C programs\n;\n; This program written by Paul Edwards, Fidonet 3:711/934\n; Released to the public domain\n; w/mods by Matthew Parker\n\n; This program is meant to be used as a stub for your C programs\n; It is designed for OS/2\n\n.386p\n\n.model flat\n\n;.stack 4000h\n\nextrn __start:near, DosExit:near\n\n_DATA   segment dword public use32 'DATA'\nifdef LINK386_FIX\n        org 20000h\nendif\nbanner  db  \"PDPCLIB\"\n_DATA   ends\n_BSS    segment dword public use32 'BSS'\n_BSS    ends\n_STACK  segment dword stack use32 'STACK'\n        db 4000h dup(?)\n_STACK  ends\n\nDGROUP  group   _DATA,_BSS\n        assume cs:_TEXT,ds:DGROUP\n\n_TEXT segment 'CODE'\n\ntop:\n\npublic __main\n__intstart proc\nmov eax, [esp+16]\npush eax\ncall __start\nsub sp,4\npush eax\ncall __exita\n__intstart endp\n\npublic __exita\n__exita proc\npop eax\npop eax\npush eax\npush 1\ncall DosExit\nsub sp,8\n__exita endp\n\n__main proc\nret\n__main endp\n\n_TEXT ends\n\nend top\n./ ADD NAME=STRINGA  0100-04042-04042-1042-00050-00050-00000-PDPCLIB\n; stringa.asm - string assembler functions\n;\n; This program written by Paul Edwards, Fidonet 3:711/934\n; Released to the public domain\n;\n; Mods by Rowan Crowe\n\n.386p\n\n.model flat\n\n_DATA   segment dword public use32 'DATA'\n_DATA   ends\n_BSS    segment dword public use32 'BSS'\n_BSS    ends\n\nDGROUP  group   _DATA,_BSS\n    assume cs:_TEXT,ds:DGROUP\n\n_TEXT segment 'CODE'\n\npublic memcpy\nmemcpy proc\npush ebp\nmov ebp, esp\npushf\npush edi\npush esi\npush ecx\nmov edi, [ebp+8]\nmov eax, edi    ; used for return value\nmov esi, [ebp+12]\nmov ecx, [ebp+16]\ncld\nshr ecx, 2\nrep movsd\nmov cl, byte ptr [ebp+16] ; ECX = 0 so we can safely manipulate\nand cl, 3                 ; the bottom byte only\nrep movsb\npop ecx\npop esi\npop edi\npopf\npop ebp\nret\nmemcpy endp\n\n_TEXT ends\n\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BAT": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10F\\x00\\x07\\x00\\x07\\x00\\x00\\xd7\\xc4\\xd7\\xc3\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:46:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "PDPCLIB"}, "text": "./ ADD NAME=COMPILE  0100-04042-04042-1042-00004-00004-00000-PDPCLIB\nrem make -fmakefile.pcm\nmake -fmakefile.dos\nrem wmake -u -f makefile.wcd\nrem make -fmakefile.pwc\n./ ADD NAME=COMPP    0100-04042-04042-1042-00001-00001-00000-PDPCLIB\nmake -fmakefile.pds\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "C": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10F \\x99 \\x99\\x00\\x00\\xd7\\xc4\\xd7\\xc3\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:46:00", "lines": 8345, "newlines": 8345, "modlines": 0, "user": "PDPCLIB"}, "text": "./ ADD NAME=ASSERT   0100-04042-04042-0944-00023-00023-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  assert.c - implementation of stuff in assert.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"assert.h\"\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\nint __assert(char *x, char *y, char *z)\n{\n    fprintf(stderr, \"assertion failed for statement %s in\"\n            \"file %s on line %d\\n\", x, y, z);\n    abort();\n    return (0);\n}\n./ ADD NAME=CTYPE    0100-04042-04042-0944-01639-01639-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  ctype.c - implementation of stuff in ctype.h                     */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __MVS__\nstatic unsigned short __isbufR[257] = {\n    0x0000U, /* EOF */\n    0x0004U, /* NUL */\n    0x0004U, /* 01  */\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0104U,\n    0x0104U,\n    0x0104U,\n    0x0104U,\n    0x0104U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0140U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0004U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U };\n\nstatic short __tolowR[257] = {\n    -1,\n    0x00,\n    0x01,\n    0x02,\n    0x03,\n    0x04,\n    0x05,\n    0x06,\n    0x07,\n    0x08,\n    0x09,\n    0x0A,\n    0x0B,\n    0x0C,\n    0x0D,\n    0x0E,\n    0x0F,\n    0x10,\n    0x11,\n    0x12,\n    0x13,\n    0x14,\n    0x15,\n    0x16,\n    0x17,\n    0x18,\n    0x19,\n    0x1A,\n    0x1B,\n    0x1C,\n    0x1D,\n    0x1E,\n    0x1F,\n    0x20,\n    0x21,\n    0x22,\n    0x23,\n    0x24,\n    0x25,\n    0x26,\n    0x27,\n    0x28,\n    0x29,\n    0x2A,\n    0x2B,\n    0x2C,\n    0x2D,\n    0x2E,\n    0x2F,\n    0x30,\n    0x31,\n    0x32,\n    0x33,\n    0x34,\n    0x35,\n    0x36,\n    0x37,\n    0x38,\n    0x39,\n    0x3A,\n    0x3B,\n    0x3C,\n    0x3D,\n    0x3E,\n    0x3F,\n    0x40,\n    0x61,\n    0x62,\n    0x63,\n    0x64,\n    0x65,\n    0x66,\n    0x67,\n    0x68,\n    0x69,\n    0x6A,\n    0x6B,\n    0x6C,\n    0x6D,\n    0x6E,\n    0x6F,\n    0x70,\n    0x71,\n    0x72,\n    0x73,\n    0x74,\n    0x75,\n    0x76,\n    0x77,\n    0x78,\n    0x79,\n    0x7A,\n    0x5B,\n    0x5C,\n    0x5D,\n    0x5E,\n    0x5F,\n    0x60,\n    0x61,\n    0x62,\n    0x63,\n    0x64,\n    0x65,\n    0x66,\n    0x67,\n    0x68,\n    0x69,\n    0x6A,\n    0x6B,\n    0x6C,\n    0x6D,\n    0x6E,\n    0x6F,\n    0x70,\n    0x71,\n    0x72,\n    0x73,\n    0x74,\n    0x75,\n    0x76,\n    0x77,\n    0x78,\n    0x79,\n    0x7A,\n    0x7B,\n    0x7C,\n    0x7D,\n    0x7E,\n    0x7F,\n    0x80,\n    0x81,\n    0x82,\n    0x83,\n    0x84,\n    0x85,\n    0x86,\n    0x87,\n    0x88,\n    0x89,\n    0x8A,\n    0x8B,\n    0x8C,\n    0x8D,\n    0x8E,\n    0x8F,\n    0x90,\n    0x91,\n    0x92,\n    0x93,\n    0x94,\n    0x95,\n    0x96,\n    0x97,\n    0x98,\n    0x99,\n    0x9A,\n    0x9B,\n    0x9C,\n    0x9D,\n    0x9E,\n    0x9F,\n    0xA0,\n    0xA1,\n    0xA2,\n    0xA3,\n    0xA4,\n    0xA5,\n    0xA6,\n    0xA7,\n    0xA8,\n    0xA9,\n    0xAA,\n    0xAB,\n    0xAC,\n    0xAD,\n    0xAE,\n    0xAF,\n    0xB0,\n    0xB1,\n    0xB2,\n    0xB3,\n    0xB4,\n    0xB5,\n    0xB6,\n    0xB7,\n    0xB8,\n    0xB9,\n    0xBA,\n    0xBB,\n    0xBC,\n    0xBD,\n    0xBE,\n    0xBF,\n    0xC0,\n    0xC1,\n    0xC2,\n    0xC3,\n    0xC4,\n    0xC5,\n    0xC6,\n    0xC7,\n    0xC8,\n    0xC9,\n    0xCA,\n    0xCB,\n    0xCC,\n    0xCD,\n    0xCE,\n    0xCF,\n    0xD0,\n    0xD1,\n    0xD2,\n    0xD3,\n    0xD4,\n    0xD5,\n    0xD6,\n    0xD7,\n    0xD8,\n    0xD9,\n    0xDA,\n    0xDB,\n    0xDC,\n    0xDD,\n    0xDE,\n    0xDF,\n    0xE0,\n    0xE1,\n    0xE2,\n    0xE3,\n    0xE4,\n    0xE5,\n    0xE6,\n    0xE7,\n    0xE8,\n    0xE9,\n    0xEA,\n    0xEB,\n    0xEC,\n    0xED,\n    0xEE,\n    0xEF,\n    0xF0,\n    0xF1,\n    0xF2,\n    0xF3,\n    0xF4,\n    0xF5,\n    0xF6,\n    0xF7,\n    0xF8,\n    0xF9,\n    0xFA,\n    0xFB,\n    0xFC,\n    0xFD,\n    0xFE,\n    0xFF };\n\nstatic short __toupR[257] = {\n    -1,\n    0x00,\n    0x01,\n    0x02,\n    0x03,\n    0x04,\n    0x05,\n    0x06,\n    0x07,\n    0x08,\n    0x09,\n    0x0A,\n    0x0B,\n    0x0C,\n    0x0D,\n    0x0E,\n    0x0F,\n    0x10,\n    0x11,\n    0x12,\n    0x13,\n    0x14,\n    0x15,\n    0x16,\n    0x17,\n    0x18,\n    0x19,\n    0x1A,\n    0x1B,\n    0x1C,\n    0x1D,\n    0x1E,\n    0x1F,\n    0x20,\n    0x21,\n    0x22,\n    0x23,\n    0x24,\n    0x25,\n    0x26,\n    0x27,\n    0x28,\n    0x29,\n    0x2A,\n    0x2B,\n    0x2C,\n    0x2D,\n    0x2E,\n    0x2F,\n    0x30,\n    0x31,\n    0x32,\n    0x33,\n    0x34,\n    0x35,\n    0x36,\n    0x37,\n    0x38,\n    0x39,\n    0x3A,\n    0x3B,\n    0x3C,\n    0x3D,\n    0x3E,\n    0x3F,\n    0x40,\n    0x41,\n    0x42,\n    0x43,\n    0x44,\n    0x45,\n    0x46,\n    0x47,\n    0x48,\n    0x49,\n    0x4A,\n    0x4B,\n    0x4C,\n    0x4D,\n    0x4E,\n    0x4F,\n    0x50,\n    0x51,\n    0x52,\n    0x53,\n    0x54,\n    0x55,\n    0x56,\n    0x57,\n    0x58,\n    0x59,\n    0x5A,\n    0x5B,\n    0x5C,\n    0x5D,\n    0x5E,\n    0x5F,\n    0x60,\n    0x41,\n    0x42,\n    0x43,\n    0x44,\n    0x45,\n    0x46,\n    0x47,\n    0x48,\n    0x49,\n    0x4A,\n    0x4B,\n    0x4C,\n    0x4D,\n    0x4E,\n    0x4F,\n    0x50,\n    0x51,\n    0x52,\n    0x53,\n    0x54,\n    0x55,\n    0x56,\n    0x57,\n    0x58,\n    0x59,\n    0x5A,\n    0x7B,\n    0x7C,\n    0x7D,\n    0x7E,\n    0x7F,\n    0x80,\n    0x81,\n    0x82,\n    0x83,\n    0x84,\n    0x85,\n    0x86,\n    0x87,\n    0x88,\n    0x89,\n    0x8A,\n    0x8B,\n    0x8C,\n    0x8D,\n    0x8E,\n    0x8F,\n    0x90,\n    0x91,\n    0x92,\n    0x93,\n    0x94,\n    0x95,\n    0x96,\n    0x97,\n    0x98,\n    0x99,\n    0x9A,\n    0x9B,\n    0x9C,\n    0x9D,\n    0x9E,\n    0x9F,\n    0xA0,\n    0xA1,\n    0xA2,\n    0xA3,\n    0xA4,\n    0xA5,\n    0xA6,\n    0xA7,\n    0xA8,\n    0xA9,\n    0xAA,\n    0xAB,\n    0xAC,\n    0xAD,\n    0xAE,\n    0xAF,\n    0xB0,\n    0xB1,\n    0xB2,\n    0xB3,\n    0xB4,\n    0xB5,\n    0xB6,\n    0xB7,\n    0xB8,\n    0xB9,\n    0xBA,\n    0xBB,\n    0xBC,\n    0xBD,\n    0xBE,\n    0xBF,\n    0xC0,\n    0xC1,\n    0xC2,\n    0xC3,\n    0xC4,\n    0xC5,\n    0xC6,\n    0xC7,\n    0xC8,\n    0xC9,\n    0xCA,\n    0xCB,\n    0xCC,\n    0xCD,\n    0xCE,\n    0xCF,\n    0xD0,\n    0xD1,\n    0xD2,\n    0xD3,\n    0xD4,\n    0xD5,\n    0xD6,\n    0xD7,\n    0xD8,\n    0xD9,\n    0xDA,\n    0xDB,\n    0xDC,\n    0xDD,\n    0xDE,\n    0xDF,\n    0xE0,\n    0xE1,\n    0xE2,\n    0xE3,\n    0xE4,\n    0xE5,\n    0xE6,\n    0xE7,\n    0xE8,\n    0xE9,\n    0xEA,\n    0xEB,\n    0xEC,\n    0xED,\n    0xEE,\n    0xEF,\n    0xF0,\n    0xF1,\n    0xF2,\n    0xF3,\n    0xF4,\n    0xF5,\n    0xF6,\n    0xF7,\n    0xF8,\n    0xF9,\n    0xFA,\n    0xFB,\n    0xFC,\n    0xFD,\n    0xFE,\n    0xFF };\n\n#else\n\nstatic unsigned short __isbufR[257] = {\n    0x0000U, /* EOF */\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0104U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0104U,\n    0x0104U,\n    0x0104U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0104U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0000U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0000U,\n    0x0000U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0000U,\n    0x0004U,\n    0x0140U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0000U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0000U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U };\n\nstatic short __tolowR[257] = {\n    -1,\n    0x00,\n    0x01,\n    0x02,\n    0x03,\n    0x04,\n    0x05,\n    0x06,\n    0x07,\n    0x08,\n    0x09,\n    0x0A,\n    0x0B,\n    0x0C,\n    0x0D,\n    0x0E,\n    0x0F,\n    0x10,\n    0x11,\n    0x12,\n    0x13,\n    0x14,\n    0x15,\n    0x16,\n    0x17,\n    0x18,\n    0x19,\n    0x1A,\n    0x1B,\n    0x1C,\n    0x1D,\n    0x1E,\n    0x1F,\n    0x20,\n    0x21,\n    0x22,\n    0x23,\n    0x24,\n    0x25,\n    0x26,\n    0x27,\n    0x28,\n    0x29,\n    0x2A,\n    0x2B,\n    0x2C,\n    0x2D,\n    0x2E,\n    0x2F,\n    0x30,\n    0x31,\n    0x32,\n    0x33,\n    0x34,\n    0x35,\n    0x36,\n    0x37,\n    0x38,\n    0x39,\n    0x3A,\n    0x3B,\n    0x3C,\n    0x3D,\n    0x3E,\n    0x3F,\n    0x40,\n    0x41,\n    0x42,\n    0x43,\n    0x44,\n    0x45,\n    0x46,\n    0x47,\n    0x48,\n    0x49,\n    0x4A,\n    0x4B,\n    0x4C,\n    0x4D,\n    0x4E,\n    0x4F,\n    0x50,\n    0x51,\n    0x52,\n    0x53,\n    0x54,\n    0x55,\n    0x56,\n    0x57,\n    0x58,\n    0x59,\n    0x5A,\n    0x5B,\n    0x5C,\n    0x5D,\n    0x5E,\n    0x5F,\n    0x60,\n    0x61,\n    0x62,\n    0x63,\n    0x64,\n    0x65,\n    0x66,\n    0x67,\n    0x68,\n    0x69,\n    0x6A,\n    0x6B,\n    0x6C,\n    0x6D,\n    0x6E,\n    0x6F,\n    0x70,\n    0x71,\n    0x72,\n    0x73,\n    0x74,\n    0x75,\n    0x76,\n    0x77,\n    0x78,\n    0x79,\n    0x7A,\n    0x7B,\n    0x7C,\n    0x7D,\n    0x7E,\n    0x7F,\n    0x80,\n    0x81,\n    0x82,\n    0x83,\n    0x84,\n    0x85,\n    0x86,\n    0x87,\n    0x88,\n    0x89,\n    0x8A,\n    0x8B,\n    0x8C,\n    0x8D,\n    0x8E,\n    0x8F,\n    0x90,\n    0x91,\n    0x92,\n    0x93,\n    0x94,\n    0x95,\n    0x96,\n    0x97,\n    0x98,\n    0x99,\n    0x9A,\n    0x9B,\n    0x9C,\n    0x9D,\n    0x9E,\n    0x9F,\n    0xA0,\n    0xA1,\n    0xA2,\n    0xA3,\n    0xA4,\n    0xA5,\n    0xA6,\n    0xA7,\n    0xA8,\n    0xA9,\n    0xAA,\n    0xAB,\n    0xAC,\n    0xAD,\n    0xAE,\n    0xAF,\n    0xB0,\n    0xB1,\n    0xB2,\n    0xB3,\n    0xB4,\n    0xB5,\n    0xB6,\n    0xB7,\n    0xB8,\n    0xB9,\n    0xBA,\n    0xBB,\n    0xBC,\n    0xBD,\n    0xBE,\n    0xBF,\n    0xC0,\n    0x81,\n    0x82,\n    0x83,\n    0x84,\n    0x85,\n    0x86,\n    0x87,\n    0x88,\n    0x89,\n    0xCA,\n    0xCB,\n    0xCC,\n    0xCD,\n    0xCE,\n    0xCF,\n    0xD0,\n    0x91,\n    0x92,\n    0x93,\n    0x94,\n    0x95,\n    0x96,\n    0x97,\n    0x98,\n    0x99,\n    0xDA,\n    0xDB,\n    0xDC,\n    0xDD,\n    0xDE,\n    0xDF,\n    0xE0,\n    0xE1,\n    0xA2,\n    0xA3,\n    0xA4,\n    0xA5,\n    0xA6,\n    0xA7,\n    0xA8,\n    0xA9,\n    0xEA,\n    0xEB,\n    0xEC,\n    0xED,\n    0xEE,\n    0xEF,\n    0xF0,\n    0xF1,\n    0xF2,\n    0xF3,\n    0xF4,\n    0xF5,\n    0xF6,\n    0xF7,\n    0xF8,\n    0xF9,\n    0xFA,\n    0xFB,\n    0xFC,\n    0xFD,\n    0xFE,\n    0xFF };\n\nstatic short __toupR[257] = {\n    -1,\n    0x00,\n    0x01,\n    0x02,\n    0x03,\n    0x04,\n    0x05,\n    0x06,\n    0x07,\n    0x08,\n    0x09,\n    0x0A,\n    0x0B,\n    0x0C,\n    0x0D,\n    0x0E,\n    0x0F,\n    0x10,\n    0x11,\n    0x12,\n    0x13,\n    0x14,\n    0x15,\n    0x16,\n    0x17,\n    0x18,\n    0x19,\n    0x1A,\n    0x1B,\n    0x1C,\n    0x1D,\n    0x1E,\n    0x1F,\n    0x20,\n    0x21,\n    0x22,\n    0x23,\n    0x24,\n    0x25,\n    0x26,\n    0x27,\n    0x28,\n    0x29,\n    0x2A,\n    0x2B,\n    0x2C,\n    0x2D,\n    0x2E,\n    0x2F,\n    0x30,\n    0x31,\n    0x32,\n    0x33,\n    0x34,\n    0x35,\n    0x36,\n    0x37,\n    0x38,\n    0x39,\n    0x3A,\n    0x3B,\n    0x3C,\n    0x3D,\n    0x3E,\n    0x3F,\n    0x40,\n    0x41,\n    0x42,\n    0x43,\n    0x44,\n    0x45,\n    0x46,\n    0x47,\n    0x48,\n    0x49,\n    0x4A,\n    0x4B,\n    0x4C,\n    0x4D,\n    0x4E,\n    0x4F,\n    0x50,\n    0x51,\n    0x52,\n    0x53,\n    0x54,\n    0x55,\n    0x56,\n    0x57,\n    0x58,\n    0x59,\n    0x5A,\n    0x5B,\n    0x5C,\n    0x5D,\n    0x5E,\n    0x5F,\n    0x60,\n    0x61,\n    0x62,\n    0x63,\n    0x64,\n    0x65,\n    0x66,\n    0x67,\n    0x68,\n    0x69,\n    0x6A,\n    0x6B,\n    0x6C,\n    0x6D,\n    0x6E,\n    0x6F,\n    0x70,\n    0x71,\n    0x72,\n    0x73,\n    0x74,\n    0x75,\n    0x76,\n    0x77,\n    0x78,\n    0x79,\n    0x7A,\n    0x7B,\n    0x7C,\n    0x7D,\n    0x7E,\n    0x7F,\n    0x80,\n    0xC1,\n    0xC2,\n    0xC3,\n    0xC4,\n    0xC5,\n    0xC6,\n    0xC7,\n    0xC8,\n    0xC9,\n    0x8A,\n    0x8B,\n    0x8C,\n    0x8D,\n    0x8E,\n    0x8F,\n    0x90,\n    0xD1,\n    0xD2,\n    0xD3,\n    0xD4,\n    0xD5,\n    0xD6,\n    0xD7,\n    0xD8,\n    0xD9,\n    0x9A,\n    0x9B,\n    0x9C,\n    0x9D,\n    0x9E,\n    0x9F,\n    0xA0,\n    0xA1,\n    0xE2,\n    0xE3,\n    0xE4,\n    0xE5,\n    0xE6,\n    0xE7,\n    0xE8,\n    0xE9,\n    0xAA,\n    0xAB,\n    0xAC,\n    0xAD,\n    0xAE,\n    0xAF,\n    0xB0,\n    0xB1,\n    0xB2,\n    0xB3,\n    0xB4,\n    0xB5,\n    0xB6,\n    0xB7,\n    0xB8,\n    0xB9,\n    0xBA,\n    0xBB,\n    0xBC,\n    0xBD,\n    0xBE,\n    0xBF,\n    0xC0,\n    0xC1,\n    0xC2,\n    0xC3,\n    0xC4,\n    0xC5,\n    0xC6,\n    0xC7,\n    0xC8,\n    0xC9,\n    0xCA,\n    0xCB,\n    0xCC,\n    0xCD,\n    0xCE,\n    0xCF,\n    0xD0,\n    0xD1,\n    0xD2,\n    0xD3,\n    0xD4,\n    0xD5,\n    0xD6,\n    0xD7,\n    0xD8,\n    0xD9,\n    0xDA,\n    0xDB,\n    0xDC,\n    0xDD,\n    0xDE,\n    0xDF,\n    0xE0,\n    0xE1,\n    0xE2,\n    0xE3,\n    0xE4,\n    0xE5,\n    0xE6,\n    0xE7,\n    0xE8,\n    0xE9,\n    0xEA,\n    0xEB,\n    0xEC,\n    0xED,\n    0xEE,\n    0xEF,\n    0xF0,\n    0xF1,\n    0xF2,\n    0xF3,\n    0xF4,\n    0xF5,\n    0xF6,\n    0xF7,\n    0xF8,\n    0xF9,\n    0xFA,\n    0xFB,\n    0xFC,\n    0xFD,\n    0xFE,\n    0xFF };\n\n#endif\n\nunsigned short *__isbuf = &__isbufR[1];\nshort *__tolow = &__tolowR[1];\nshort *__toup = &__toupR[1];\n\nint isalnum(int c)\n{\n    return (__isbuf[(c)] & 0x0001U);\n}\n\nint isalpha(int c)\n{\n    return (__isbuf[(c)] & 0x0002U);\n}\n\nint iscntrl(int c)\n{\n    return (__isbuf[(c)] & 0x0004U);\n}\n\nint isdigit(int c)\n{\n    return (__isbuf[(c)] & 0x0008U);\n}\n\nint isgraph(int c)\n{\n    return (__isbuf[(c)] & 0x0010U);\n}\n\nint islower(int c)\n{\n    return (__isbuf[(c)] & 0x0020U);\n}\n\nint isprint(int c)\n{\n    return (__isbuf[(c)] & 0x0040U);\n}\n\nint ispunct(int c)\n{\n    return (__isbuf[(c)] & 0x0080U);\n}\n\nint isspace(int c)\n{\n    return (__isbuf[(c)] & 0x0100U);\n}\n\nint isupper(int c)\n{\n    return (__isbuf[(c)] & 0x0200U);\n}\n\nint isxdigit(int c)\n{\n    return (__isbuf[(c)] & 0x0400U);\n}\n\nint tolower(int c)\n{\n    return (__tolow[(c)]);\n}\n\nint toupper(int c)\n{\n    return (__toup[(c)]);\n}\n./ ADD NAME=DOSSUPC  0100-04042-04042-0944-00115-00115-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  fpfuncsb.c - some support routines for floating point work       */\n/*  for Borland C++ for OS/2                                         */\n/*                                                                   */\n/*********************************************************************/\n\n#ifdef __OS2__\nint __turboFloat;\n\nlong _ftol(double x)\n{\n    (void)x;\n    return (0);\n}\n#endif\n\n#ifdef __MSDOS__\n\n#ifdef __WATCOMC__\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\n\nunsigned long CTYP __divide(unsigned long x, unsigned long y)\n{\n    unsigned int a;\n    unsigned int b;\n    unsigned int c;\n    unsigned int d;\n    unsigned int e;\n    unsigned int f;\n    unsigned int g = 0;\n    unsigned int h;\n\n    b = (unsigned int)(y & 0xffffU);\n    a = (unsigned int)(y >> 16);\n    c = -b;\n    d = a;\n    if (b > 0)\n    {\n        d++;\n    }\n    f = 1;\n    while (f != 0)\n    {\n        e = (unsigned int)(x >> 16);\n        h = (unsigned int)(x & 0xffffU);\n        f = e / d;\n        g += f;\n        e = e % d;\n        x = ((unsigned long)e << 16) + (unsigned long)c * f + h;\n    }\n    if (x >= y)\n    {\n        g++;\n    }\n    return ((unsigned long)g);\n}\n\nunsigned long CTYP __modulo(unsigned long x, unsigned long y)\n{\n    unsigned int a;\n    unsigned int b;\n    unsigned int c;\n    unsigned int d;\n    unsigned int e;\n    unsigned int f;\n    unsigned int g = 0;\n    unsigned int h;\n\n    b = (unsigned int)(y & 0xffffU);\n    a = (unsigned int)(y >> 16);\n    c = -b;\n    d = a;\n    if (b > 0)\n    {\n        d++;\n    }\n    f = 1;\n    while (f != 0)\n    {\n        e = (unsigned int)(x >> 16);\n        h = (unsigned int)(x & 0xffffU);\n        f = e / d;\n        g += f;\n        e = e % d;\n        x = ((unsigned long)e << 16) + (unsigned long)c * f + h;\n    }\n    if (x >= y)\n    {\n        x -= y;\n    }\n    return (x);\n}\n\n#ifdef __WATCOMC__\nvoid _cstart(void)\n{\n    return;\n}\n\nint _argc, _8087;\n\n#endif\n\n#endif\n\n./ ADD NAME=ERRNO    0100-04042-04042-0944-00014-00014-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  errno.c - implementation of stuff in errno.h                     */\n/*                                                                   */\n/*********************************************************************/\n\nint errno = 0;\n\n./ ADD NAME=FPFUNCSB 0100-04042-04042-0944-00115-00115-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  fpfuncsb.c - some support routines for floating point work       */\n/*  for Borland C++ for OS/2                                         */\n/*                                                                   */\n/*********************************************************************/\n\n#ifdef __OS2__\nint __turboFloat;\n\nlong _ftol(double x)\n{\n    (void)x;\n    return (0);\n}\n#endif\n\n#ifdef __MSDOS__\n\n#ifdef __WATCOMC__\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\n\nunsigned long CTYP __divide(unsigned long x, unsigned long y)\n{\n    unsigned int a;\n    unsigned int b;\n    unsigned int c;\n    unsigned int d;\n    unsigned int e;\n    unsigned int f;\n    unsigned int g = 0;\n    unsigned int h;\n\n    b = (unsigned int)(y & 0xffffU);\n    a = (unsigned int)(y >> 16);\n    c = -b;\n    d = a;\n    if (b > 0)\n    {\n        d++;\n    }\n    f = 1;\n    while (f != 0)\n    {\n        e = (unsigned int)(x >> 16);\n        h = (unsigned int)(x & 0xffffU);\n        f = e / d;\n        g += f;\n        e = e % d;\n        x = ((unsigned long)e << 16) + (unsigned long)c * f + h;\n    }\n    if (x >= y)\n    {\n        g++;\n    }\n    return ((unsigned long)g);\n}\n\nunsigned long CTYP __modulo(unsigned long x, unsigned long y)\n{\n    unsigned int a;\n    unsigned int b;\n    unsigned int c;\n    unsigned int d;\n    unsigned int e;\n    unsigned int f;\n    unsigned int g = 0;\n    unsigned int h;\n\n    b = (unsigned int)(y & 0xffffU);\n    a = (unsigned int)(y >> 16);\n    c = -b;\n    d = a;\n    if (b > 0)\n    {\n        d++;\n    }\n    f = 1;\n    while (f != 0)\n    {\n        e = (unsigned int)(x >> 16);\n        h = (unsigned int)(x & 0xffffU);\n        f = e / d;\n        g += f;\n        e = e % d;\n        x = ((unsigned long)e << 16) + (unsigned long)c * f + h;\n    }\n    if (x >= y)\n    {\n        x -= y;\n    }\n    return (x);\n}\n\n#ifdef __WATCOMC__\nvoid _cstart(void)\n{\n    return;\n}\n\nint _argc, _8087;\n\n#endif\n\n#endif\n\n./ ADD NAME=FPFUNCSC 0100-04042-04042-0944-00020-00020-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  fpfuncsc.c - some support routines for floating point work       */\n/*  for IBM CSET compiler for OS/2                                   */\n/*                                                                   */\n/*********************************************************************/\n\nint _fltused;\n\n_exeentry(void)\n{\n    __main();\n    return;\n}\n./ ADD NAME=FPFUNCSG 0100-04042-04042-0944-00018-00018-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  fpfuncsg.c - some support routines for floating point work       */\n/*  for GNU C compiler for OS/2                                      */\n/*                                                                   */\n/*********************************************************************/\n\n__main(void)\n{\n    return;\n}\n\n./ ADD NAME=FPFUNCSW 0100-04042-04042-0944-00044-00044-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  fpfuncsw.c - some support routines for floating point work       */\n/*  for Watcom C compiler for OS/2                                   */\n/*                                                                   */\n/*********************************************************************/\n\nint _fltused_ = 0;\nint __real87 = 0;\nint _argc;\n\n__init_387_emulator(void)\n{\n    return;\n}\n\n__8087(void)\n{\n    return;\n}\n\n__STOSD(void)\n{\n    return;\n}\n\n__CHP(void)\n{\n    return;\n}\n\nvoid __main(void);\n\n_cstart_(void)\n{\n    __main();\n    return;\n}\n./ ADD NAME=LOCALE   0100-04042-04042-0944-00059-00059-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  locale.c - implementation of stuff in locale.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"locale.h\"\n#include \"limits.h\"\n#include \"string.h\"\n\nstatic struct lconv thislocale = {\n    \".\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX\n};\n\nchar *setlocale(int category, const char *locale)\n{\n    (void)category;\n    if (locale == NULL)\n    {\n        return (\"C\");\n    }\n    else if ((strcmp(locale, \"C\") == 0)\n             || (strcmp(locale, \"\") == 0))\n    {\n        return (\"C\");\n    }\n    else\n    {\n        return (NULL);\n    }\n}\n\nstruct lconv *localeconv(void)\n{\n    return (&thislocale);\n}\n./ ADD NAME=MATH     0100-04042-04042-0944-00232-00232-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  math.c - implementation of stuff in math.h                       */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"math.h\"\n\ndouble ceil(double x)\n{\n    int y;\n\n    y = (int)x;\n    if ((double)y < x)\n    {\n        y++;\n    }\n    return ((double)y);\n}\n\n#ifdef fabs\n#undef fabs\n#endif\ndouble fabs(double x)\n{\n    if (x < 0.0)\n    {\n        x = -x;\n    }\n    return (x);\n}\n\ndouble floor(double x)\n{\n    int y;\n\n    if (x < 0.0)\n    {\n        y = (int)fabs(x);\n        if ((double)y != x)\n        {\n            y--;\n        }\n    }\n    else\n    {\n        y = (int)x;\n    }\n    return ((double)x);\n}\n\ndouble fmod(double x, double y)\n{\n    return (x / y);\n}\n\nstatic double i_acos(double x)\n{\n    return (acos(x));\n}\n\nstatic double i_asin(double x)\n{\n    return (asin(x));\n}\n\nstatic double i_atan(double x)\n{\n    return (atan(x));\n}\n\nstatic double i_atan2(double y, double x)\n{\n    return (atan2(y,x));\n}\n\nstatic double i_cos(double x)\n{\n    return (cos(x));\n}\n\nstatic double i_sin(double x)\n{\n    return (sin(x));\n}\n\nstatic double i_tan(double x)\n{\n    return (tan(x));\n}\n\nstatic double i_cosh(double x)\n{\n    return (cosh(x));\n}\n\nstatic double i_sinh(double x)\n{\n    return (sinh(x));\n}\n\nstatic double i_tanh(double x)\n{\n    return (tanh(x));\n}\n\nstatic double i_exp(double x)\n{\n    return (exp(x));\n}\n\nstatic double i_log(double x)\n{\n    return (log(x));\n}\n\nstatic double i_log10(double x)\n{\n    return (log10(x));\n}\n\nstatic double i_pow(double x, double y)\n{\n    return (pow(x, y));\n}\n\nstatic double i_sqrt(double x)\n{\n    return (sqrt(x));\n}\n\n#ifdef acos\n#undef acos\n#endif\ndouble acos(double x)\n{\n    return (i_acos(x));\n}\n\n#ifdef asin\n#undef asin\n#endif\ndouble asin(double x)\n{\n    return (i_asin(x));\n}\n\n#ifdef atan\n#undef atan\n#endif\ndouble atan(double x)\n{\n    return (i_atan(x));\n}\n\ndouble atan2(double y, double x)\n{\n    return (i_atan2(y, x));\n}\n\n#ifdef cos\n#undef cos\n#endif\ndouble cos(double x)\n{\n    return (i_cos(x));\n}\n\n#ifdef sin\n#undef sin\n#endif\ndouble sin(double x)\n{\n    return (i_sin(x));\n}\n\n#ifdef tan\n#undef tan\n#endif\ndouble tan(double x)\n{\n    return (i_tan(x));\n}\n\ndouble cosh(double x)\n{\n    return (i_cosh(x));\n}\n\ndouble sinh(double x)\n{\n    return (i_sinh(x));\n}\n\ndouble tanh(double x)\n{\n    return (i_tanh(x));\n}\n\ndouble exp(double x)\n{\n    return (i_exp(x));\n}\n\ndouble log(double x)\n{\n    return (i_log(x));\n}\n\ndouble log10(double x)\n{\n    return (i_log10(x));\n}\n\ndouble pow(double x, double y)\n{\n    return (i_pow(x, y));\n}\n\n#ifdef sqrt\n#undef sqrt\n#endif\ndouble sqrt(double x)\n{\n    return (i_sqrt(x));\n}\n./ ADD NAME=MVSUNZIP 0100-04042-04042-0944-00226-00226-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards                             */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  mvsunzip - unzip files for use by pdpclib                        */\n/*  e.g. mvsunzip pdpclib.czip pdpclib.c                             */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXBUF 500000\n\nstatic int fasc(int asc);\nstatic int onefile(FILE *infile);\nstatic char *ascii2l(char *buf);\nstatic char *outn;\n\nint main(int argc, char **argv)\n{\n    FILE *infile;\n    int c;\n\n    if (argc <= 2)\n    {\n        printf(\"usage: mvsunzip <infile> <outfile>\\n\");\n        printf(\"where infile is a sequential file\\n\");\n        printf(\"and outfile is a PDS\\n\");\n        printf(\"e.g. mvsunzip dd:input dd:output\\n\");\n        return (0);\n    }\n    outn = *(argv+2);\n    infile = fopen(*(argv+1), \"rb\");\n    while (onefile(infile)) ;\n    return (0);\n}\n\nstatic int onefile(FILE *infile)\n{\n    int c;\n    int x;\n    long size;\n    int fnmlen;\n    char fnm[FILENAME_MAX];\n    static char *buf = NULL;\n    char newfnm[FILENAME_MAX];\n    FILE *newf;\n\n    if (buf == NULL)\n    {\n        buf = malloc(MAXBUF);\n    }\n    if (fgetc(infile) != 0x50)\n    {\n        return (0);\n    }\n    if (fgetc(infile) != 0x4b)\n    {\n        return (0);\n    }\n    for (x = 0; x < 16; x++)\n    {\n        fgetc(infile);\n    }\n    c = fgetc(infile);\n    size = c;\n    c = fgetc(infile);\n    size = (c << 8) | size;\n    c = fgetc(infile);\n    size = (c << 16) | size;\n    c = fgetc(infile);\n    size = (c << 24) | size;\n    if (size > MAXBUF)\n    {\n        return (0);\n    }\n    for (x = 0; x < 4; x++)\n    {\n        fgetc(infile);\n    }\n    c = fgetc(infile);\n    fnmlen = c;\n    c = fgetc(infile);\n    fnmlen = (c << 8) | fnmlen;\n    fgetc(infile);\n    fgetc(infile);\n    fread(fnm, fnmlen, 1, infile);\n    fnm[fnmlen] = '\\0';\n    ascii2l(fnm);\n    printf(\"fnm is %s\\n\", fnm);\n    fread(buf, size, 1, infile);\n    buf[size] = '\\0';\n    ascii2l(buf);\n    if (strchr(fnm, '.') != NULL) *strchr(fnm, '.') = '\\0';\n    while (strchr(fnm, '-') != NULL) *strchr(fnm, '-') = '@';\n    while (strchr(fnm, '_') != NULL) *strchr(fnm, '_') = '@';\n    sprintf(newfnm, \"%s(%s)\", outn, fnm);\n    newf = fopen(newfnm, \"w\");\n    fwrite(buf, size, 1, newf);\n    fclose(newf);\n    return (1);\n}\n\nstatic char *ascii2l(char *buf)\n{\n    char *p;\n\n    p = buf;\n    while (*p != '\\0')\n    {\n        *p = fasc(*p);\n        p++;\n    }\n    return (buf);\n}\n\nstatic int fasc(int asc)\n{\n  switch (asc)\n  {\n    case 0x0a : return('\\n');\n    case 0x0d : return('\\r');\n    case 0x20 : return(' ');\n    case 0x21 : return('!');\n    case 0x22 : return('\\\"');\n    case 0x23 : return('#');\n    case 0x24 : return('$');\n    case 0x25 : return('%');\n    case 0x26 : return('&');\n    case 0x27 : return('\\'');\n    case 0x28 : return('(');\n    case 0x29 : return(')');\n    case 0x2a : return('*');\n    case 0x2b : return('+');\n    case 0x2c : return(',');\n    case 0x2d : return('-');\n    case 0x2e : return('.');\n    case 0x2f : return('/');\n    case 0x30 : return('0');\n    case 0x31 : return('1');\n    case 0x32 : return('2');\n    case 0x33 : return('3');\n    case 0x34 : return('4');\n    case 0x35 : return('5');\n    case 0x36 : return('6');\n    case 0x37 : return('7');\n    case 0x38 : return('8');\n    case 0x39 : return('9');\n    case 0x3a : return(':');\n    case 0x3b : return(';');\n    case 0x3c : return('<');\n    case 0x3d : return('=');\n    case 0x3e : return('>');\n    case 0x3f : return('?');\n    case 0x40 : return('@');\n    case 0x41 : return('A');\n    case 0x42 : return('B');\n    case 0x43 : return('C');\n    case 0x44 : return('D');\n    case 0x45 : return('E');\n    case 0x46 : return('F');\n    case 0x47 : return('G');\n    case 0x48 : return('H');\n    case 0x49 : return('I');\n    case 0x4a : return('J');\n    case 0x4b : return('K');\n    case 0x4c : return('L');\n    case 0x4d : return('M');\n    case 0x4e : return('N');\n    case 0x4f : return('O');\n    case 0x50 : return('P');\n    case 0x51 : return('Q');\n    case 0x52 : return('R');\n    case 0x53 : return('S');\n    case 0x54 : return('T');\n    case 0x55 : return('U');\n    case 0x56 : return('V');\n    case 0x57 : return('W');\n    case 0x58 : return('X');\n    case 0x59 : return('Y');\n    case 0x5a : return('Z');\n    case 0x5b : return('[');\n    case 0x5c : return('\\\\');\n    case 0x5d : return(']');\n    case 0x5e : return('^');\n    case 0x5f : return('_');\n    case 0x60 : return('`');\n    case 0x61 : return('a');\n    case 0x62 : return('b');\n    case 0x63 : return('c');\n    case 0x64 : return('d');\n    case 0x65 : return('e');\n    case 0x66 : return('f');\n    case 0x67 : return('g');\n    case 0x68 : return('h');\n    case 0x69 : return('i');\n    case 0x6a : return('j');\n    case 0x6b : return('k');\n    case 0x6c : return('l');\n    case 0x6d : return('m');\n    case 0x6e : return('n');\n    case 0x6f : return('o');\n    case 0x70 : return('p');\n    case 0x71 : return('q');\n    case 0x72 : return('r');\n    case 0x73 : return('s');\n    case 0x74 : return('t');\n    case 0x75 : return('u');\n    case 0x76 : return('v');\n    case 0x77 : return('w');\n    case 0x78 : return('x');\n    case 0x79 : return('y');\n    case 0x7a : return('z');\n    case 0x7b : return('{');\n    case 0x7c : return('|');\n    case 0x7d : return('}');\n    case 0x7e : return('~');\n    default   : return(0);\n  }\n}\n./ ADD NAME=PDOSST32 0100-04042-04042-0944-00015-00015-00000-PDPCLIB\n/* Startup code for PDOS */\n/* written by Paul Edwards */\n/* released to the public domain */\n\n/* We can get away with a minimal startup code, plus make it\n   a C program.  Do not put any string literals in here though,\n   as the code needs to start immediately.  This is IT!  */\n\nint __pdosst32(int i1, int i2, int i3, void *exep)\n{\n    int rc;\n\n    rc = __pstart(&i1, &i2, &i3, exep);\n    return (rc);\n}\n./ ADD NAME=PDOSSUPC 0100-04042-04042-0944-00138-00138-00000-PDPCLIB\n/* written by Paul Edwards */\n/* released to the public domain */\n/* pdossupc - support routines for pdos */\n\n#include \"stddef.h\"\n\n#include <pos.h>\n#include <support.h>\n\nint __open(const char *filename, int mode, int *errind)\n{\n    int handle;\n    int ret;\n\n    ret = PosOpenFile(filename, mode, &handle);\n    *errind = ret;\n    return (handle);\n}\n\nint __read(int handle, void *buf, size_t len, int *errind)\n{\n    long readBytes;\n\n    PosReadFile(handle, buf, len, &readBytes);\n    *errind = 0;\n    return (readBytes);\n}\n\nint __write(int handle, const void *buf, size_t len, int *errind)\n{\n    int ret;\n\n    ret = PosWriteFile(handle, buf, len);\n    *errind = 0;\n    return (ret);\n}\n\nvoid __seek(int handle, long offset, int whence)\n{\n    PosMoveFilePointer(handle, offset, whence);\n    return;\n}\n\nvoid __close(int handle)\n{\n    PosCloseFile(handle);\n    return;\n}\n\nvoid __remove(const char *filename)\n{\n    PosDeleteFile(filename);\n    return;\n}\n\nvoid __rename(const char *old, const char *new)\n{\n    PosRenameFile(old, new);\n    return;\n}\n\nvoid __allocmem(size_t size, void **ptr)\n{\n    *ptr = PosAllocMem(size);\n    return;\n}\n\nvoid __freemem(void *ptr)\n{\n    PosFreeMem(ptr);\n    return;\n}\n\nvoid __exec(char *cmd, void *env)\n{\n    PosExec(cmd, env);\n    return;\n}\n\nvoid __datetime(void *ptr)\n{\n    int year, month, day, dow;\n    int hour, minute, second, hundredths;\n    int *iptr = ptr;\n\n    PosGetSystemDate(&year, &month, &day, &dow);\n    iptr[0] = year;\n    iptr[1] = month;\n    iptr[2] = day;\n    iptr[3] = dow;\n    PosGetSystemTime(&hour, &minute, &second, &hundredths);\n    iptr[4] = hour;\n    iptr[5] = minute;\n    iptr[6] = second;\n    iptr[7] = hundredths;\n    return;\n}\n\nint __pstart(int *i1, int *i2, int *i3, POS_EPARMS *exep)\n{\n    return (__start(i1, i2, i3, exep));\n}\n\n#ifdef PDOS_MAIN_ENTRY\nvoid __callback(void)\n{\n    __exit(0);\n    return;\n}\n#endif\n\n#ifdef PDOS_MAIN_ENTRY\nvoid __main(int ebp, int retaddr, int i1, int i2, int i3, POS_EPARMS *exep)\n{\n    __start(&i1, &i2, &i3, exep);\n    exep->callback = __callback;\n    return;\n}\n#else\nvoid __main(void)\n{\n    return;\n}\n#endif\n\nvoid __exita(int retcode)\n{\n#ifndef PDOS_RET_EXIT\n     PosTerminate(retcode);\n#endif\n    return;\n}\n\nvoid __displayc(void)\n{\n    *__vidptr = 'C';\n    return;\n}\n./ ADD NAME=PDPTEST  0100-04042-04042-0944-00108-00108-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  pdptest.c - Test of PDPCLIB                                      */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <time.h>\n#include <assert.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char **argv)\n{\n    FILE *fp;\n    FILE *fq;\n    char buf[5000];\n    size_t x;\n    int c;\n    time_t tt;\n\n#if 0\n    fq = fopen(\"dd:outfile\", \"w\");\n    fgets(buf, sizeof buf, stdin);\n    fputs(buf, fq);\n    fgets(buf, sizeof buf, stdin);\n    fputs(buf, fq);\n    fgets(buf, sizeof buf, stdin);\n    fputs(buf, fq);\n    fclose(fq);\n#endif\n    printf(\"hello there\\n\");\n    for (x = 0; x < argc; x++)\n    {\n        printf(\"arg %d is %s\\n\", x, argv[x]);\n    }\n    return (6);\n#if 0\n    fp = fopen(\"pdptest.in\", \"r+b\");\n    if (fp == NULL)\n    {\n        printf(\"couldn't open input file\\n\");\n        return (0);\n    }\n    x = fread(buf, 1, 5, fp);\n    buf[x] = '\\0';\n    printf(\"x is %d\\n\", x);\n    printf(\"buf is %s\\n\", buf);\n    fwrite(\"test\\ntest2\\n\", 1, 11, stdout);\n    printf(\"data is:\\n\");\n    printf(\"%s\\n\", buf);\n    printf(\"position is %ld\\n\", ftell(fp));\n    x = fseek(fp, 15, SEEK_SET);\n    fputc('Z', fp);\n    printf(\"x is %d\\n\", x);\n    x = fread(buf, 1, 5, fp);\n    printf(\"x is %d\\n\", x);\n    printf(\"%s\\n\", buf);\n    fclose(fp);\n    printf(\"This is a test of 342 %d!\\n\", 342);\n    printf(\"Please enter your name\\n\");\n/*    fgets(buf, sizeof buf, stdin);\n    printf(\"hello, %s\", buf); */\n    printf(\"is 'C' uppercase? %d\\n\", isupper('C'));\n    printf(\"is 'C' lowercase? %d\\n\", islower('C'));\n    printf(\"what is lowercase 'C'? %d\\n\", tolower('C'));\n    tt = time(NULL);\n    printf(\"time is %lu\\n\", tt);\n    fp = fopen(\"pdptest.in\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"failed to open file\\n\");\n        return (0);\n    }\n    c = getc(fp);\n    printf(\"c is %d\\n\", c);\n    while (fgets(buf, sizeof buf, fp) != NULL)\n    {\n        if (*buf != ',')\n        {\n            printf(buf);\n        }\n    }\n    fclose(fp);\n    printf(\"argc is %d\\n\", argc);\n    for (x = 0; x < argc; x++)\n    {\n        printf(\"argv[%d] is %s\\n\", x, argv[x]);\n    }\n    sprintf(buf, \"%.4d-%.2d-%.2d\", 51, 41, 31);\n    printf(\"%s\\n\", buf);\n    printf(\"%-15s%s\\n\", \"hello\", \"there\");\n    printf(\"%-06dJJ\\n\", 37);\n    printf(\"%2d\\n\", 57);\n    printf(\"%2d\\n\", 7);\n    printf(\"%2d\\n\", -3);\n    printf(\"%d\\n\", -457);\n    printf(\"should be there %s\\n\", strstr(\"hello there\", \"there\"));\n#endif\n    return (0);\n}\n./ ADD NAME=PERF1    0100-04042-04042-0944-00014-00014-00000-PDPCLIB\n/* Run this to create a test file called \"temp.in\" */\n\n#include <stdio.h>\n\nint main(void)\n{\n    long x;\n\n    for (x = 0; x < 200000L; x++)\n    {\n        printf(\"123456789012345678901234567890\\n\");\n    }\n    return (0);\n}\n./ ADD NAME=PERF2    0100-04042-04042-0944-00026-00026-00000-PDPCLIB\n/* Run this to test out \"fgets\" */\n\n#include <stdio.h>\n\nint main(void)\n{\n    char buf[100];\n    FILE *fp;\n    long x;\n\n    fp = fopen(\"temp.in\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"can't open temp.in\\n\");\n        return (0);\n    }\n\n    x = 0;\n    while (fgets(buf, sizeof buf, fp) != NULL)\n    {\n        x++;\n    }\n    fclose(fp);\n    printf(\"x is %ld\\n\", x);\n    return (0);\n}\n./ ADD NAME=PERF3    0100-04042-04042-0944-00027-00027-00000-PDPCLIB\n/* Run this to test out \"fread\" on binary files */\n\n#include <stdio.h>\n\nstatic char buf[20000];\n\nint main(void)\n{\n    FILE *fp;\n    long x;\n\n    fp = fopen(\"temp.in\", \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"can't open temp.in\\n\");\n        return (0);\n    }\n\n    x = 0;\n    while (fread(buf, sizeof buf, 1, fp) == 1)\n    {\n        x++;\n    }\n    fclose(fp);\n    printf(\"x is %ld\\n\", x);\n    return (0);\n}\n./ ADD NAME=PERF4    0100-04042-04042-0944-00028-00028-00000-PDPCLIB\n/* Run this to test out \"fread\" on binary files,\n   for small reads */\n\n#include <stdio.h>\n\nstatic char buf[80];\n\nint main(void)\n{\n    FILE *fp;\n    long x;\n\n    fp = fopen(\"temp.in\", \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"can't open temp.in\\n\");\n        return (0);\n    }\n\n    x = 0;\n    while (fread(buf, sizeof buf, 1, fp) == 1)\n    {\n        x++;\n    }\n    fclose(fp);\n    printf(\"x is %ld\\n\", x);\n    return (0);\n}\n./ ADD NAME=SETJMP   0100-04042-04042-0944-00042-00042-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  setjmp.c - implementation of stuff in setjmp.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"setjmp.h\"\n\nint setjmp(jmp_buf env)\n{\n    env[0].eax = 0;\n    env[0].ebx = 0;\n    env[0].ecx = 0;\n    env[0].longj = 0;\n    /* env[0].sp = sp */\n    if (env[0].longj == 1)\n    {\n        if (env[0].eax == 0)\n        {\n            env[0].eax = 1;\n        }\n        return (env[0].eax);\n    }\n    else\n    {\n        return (0);\n    }\n}\n\nvoid longjmp(jmp_buf env, int val)\n{\n    env[0].longj = 1;\n    env[0].eax = val;\n    /* load regs */\n    return;\n}\n./ ADD NAME=SIGNAL   0100-04042-04042-0944-00073-00073-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  signal.c - implementation of stuff in signal.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"signal.h\"\n#include \"stdlib.h\"\n\nstatic void (*handlers[6])(int) = {\n    __sigdfl,\n    __sigdfl,\n    __sigdfl,\n    __sigdfl,\n    __sigdfl,\n    __sigdfl };\n\nvoid __sigdfl(int sig);\nvoid __sigerr(int sig);\nvoid __sigign(int sig);\n\n#define SIG_DFL __sigdfl\n#define SIG_ERR __sigerr\n#define SIG_IGN __sigign\n\n#define SIGABRT 1\n#define SIGFPE 2\n#define SIGILL 3\n#define SIGINT 4\n#define SIGSEGV 5\n#define SIGTERM 6\n\nvoid (*signal(int sig, void (*func)(int)))(int)\n{\n    handlers[sig] = func;\n    return (func);\n}\n\n\nint raise(int sig)\n{\n    (handlers[sig])(sig);\n    return (0);\n}\n\nvoid __sigdfl(int sig)\n{\n    handlers[sig] = SIG_DFL;\n    if (sig == SIGABRT)\n    {\n        exit(EXIT_FAILURE);\n    }\n    return;\n}\n\nvoid __sigerr(int sig)\n{\n    (void)sig;\n    return;\n}\n\nvoid __sigign(int sig)\n{\n    (void)sig;\n    return;\n}\n\n./ ADD NAME=START    0100-04042-04042-0944-00309-00309-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  start.c - startup/termination code                               */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n\n#ifdef __OS2__\n#define INCL_DOS\n#include <os2.h>\n#endif\n\n#if (defined(__MSDOS__) && defined(__WATCOMC__))\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\n\n#ifdef __MSDOS__\n/* Must be unsigned as it is used for array index */\nextern unsigned char *__envptr;\nextern unsigned short __osver;\n#endif\n\nint main(int argc, char **argv);\n\nvoid __exit(int status);\nvoid CTYP __exita(int status);\n\n#ifndef __MVS__\nstatic char buffer1[BUFSIZ + 8];\nstatic char buffer2[BUFSIZ + 8];\nstatic char buffer3[BUFSIZ + 8];\n#endif\n\n#ifdef __PDOS__\n#include <support.h>\n#include <pos.h>\nint __abscor;\nunsigned char *__envptr;\nchar *__vidptr;\n#endif\n\n#if defined(__MVS__)\nint __start(char *p, char *pgmname, int tso)\n#elif defined(__PDOS__)\nint __start(int *i1, int *i2, int *i3, POS_EPARMS *exep)\n#else\nint CTYP __start(char *p)\n#endif\n{\n#ifdef __PDOS__\n    char *p;\n#endif\n    int x;\n    int argc;\n    static char *argv[20];\n    int rc;\n#ifdef __OS2__\n    ULONG maxFH;\n    LONG reqFH;\n#endif\n#ifdef __MSDOS__\n    unsigned char *env;\n#endif\n#ifdef __MVS__\n    int parmLen;\n    int progLen;\n    char parmbuf[300];\n#endif\n\n#ifdef __PDOS__\n    p = exep->psp;\n    __abscor = exep->abscor;\n    __vidptr = ABSADDR(0xb8000);\n#endif\n#ifndef __MVS__\n    stdin->hfile = 0;\n    stdout->hfile = 1;\n    stderr->hfile = 2;\n\n    stdin->quickBin = 0;\n    stdin->quickText = 0;\n    stdin->textMode = 1;\n    stdin->intFno = 0;\n    stdin->bufStartR = 0;\n    stdin->bufTech = _IOLBF;\n    stdin->intBuffer = buffer1;\n    stdin->fbuf = stdin->intBuffer + 2;\n    *stdin->fbuf++ = '\\0';\n    *stdin->fbuf++ = '\\0';\n    stdin->szfbuf = BUFSIZ;\n    stdin->endbuf = stdin->fbuf + stdin->szfbuf;\n    *stdin->endbuf = '\\n';\n    stdin->noNl = 0;\n    stdin->upto = stdin->endbuf;\n    stdin->bufStartR = -stdin->szfbuf;\n    stdin->mode = __READ_MODE;\n    stdin->ungetCh = -1;\n    stdin->update = 0;\n    stdin->theirBuffer = 0;\n\n    stdout->quickBin = 0;\n    stdout->quickText = 0;\n    stdout->textMode = 1;\n    stdout->bufTech = _IOLBF;\n    stdout->intBuffer = buffer2;\n    stdout->fbuf = stdout->intBuffer;\n    *stdout->fbuf++ = '\\0';\n    *stdout->fbuf++ = '\\0';\n    stdout->szfbuf = BUFSIZ;\n    stdout->endbuf = stdout->fbuf + stdout->szfbuf;\n    *stdout->endbuf = '\\n';\n    stdout->noNl = 0;\n    stdout->upto = stdout->fbuf;\n    stdout->bufStartR = 0;\n    stdout->mode = __WRITE_MODE;\n    stdout->update = 0;\n    stdout->theirBuffer = 0;\n\n    stderr->quickBin = 0;\n    stderr->quickText = 0;\n    stderr->textMode = 1;\n    stderr->bufTech = _IOLBF;\n    stderr->intBuffer = buffer3;\n    stderr->fbuf = stderr->intBuffer;\n    *stderr->fbuf++ = '\\0';\n    *stderr->fbuf++ = '\\0';\n    stderr->szfbuf = BUFSIZ;\n    stderr->endbuf = stderr->fbuf + stderr->szfbuf;\n    *stderr->endbuf = '\\n';\n    stderr->noNl = 0;\n    stderr->upto = stderr->fbuf;\n    stderr->bufStartR = 0;\n    stderr->mode = __WRITE_MODE;\n    stderr->update = 0;\n    stderr->theirBuffer = 0;\n#else\n    stdin = fopen(\"dd:SYSIN\", \"r\");\n    stdout = fopen(\"dd:SYSPRINT\", \"w\");\n    stderr = stdout;\n    parmLen = ((unsigned int)p[0] << 8) | (unsigned int)p[1];\n    if (parmLen >= sizeof parmbuf - 2)\n    {\n        parmLen = sizeof parmbuf - 1 - 2;\n    }\n    /* We copy the parameter into our own area because\n       the caller hasn't necessarily allocated room for\n       a terminating NUL, nor is it necessarily correct\n       to clobber the caller's are with NULs. */\n    memcpy(parmbuf, p, parmLen + 2);\n    p = parmbuf;\n    if ((parmLen > 0) && (p[2] == 0))     /* assume TSO */\n    {\n        progLen = ((unsigned int)p[2] << 8) | (unsigned int)p[3];\n        parmLen -= (progLen + 4);\n        argv[0] = p + 4;\n        p += (progLen + 4);\n        if (parmLen > 0)\n        {\n            *(p - 1) = '\\0';\n        }\n        else\n        {\n            *p = '\\0';\n        }\n        p[parmLen] = '\\0';\n    }\n    else         /* batch or tso \"call\" */\n    {\n        progLen = 0;\n        p += 2;\n        argv[0] = pgmname;\n        pgmname[8] = '\\0';\n        pgmname = strchr(pgmname, ' ');\n        if (pgmname != NULL)\n        {\n            *pgmname = '\\0';\n        }\n        if (parmLen > 0)\n        {\n            p[parmLen] = '\\0';\n        }\n        else\n        {\n            p = \"\";\n        }\n    }\n#endif\n\n#ifdef __OS2__\n    reqFH = 0;\n    DosSetRelMaxFH(&reqFH, &maxFH);\n    if (maxFH < (FOPEN_MAX + 10))\n    {\n        reqFH = FOPEN_MAX - maxFH + 10;\n        DosSetRelMaxFH(&reqFH, &maxFH);\n    }\n#endif\n    for (x=0; x < __NFILE; x++)\n    {\n        __userFiles[x] = NULL;\n    }\n#ifdef __OS2__\n    argv[0] = p;\n    p += strlen(p) + 1;\n#endif\n#if defined(__MSDOS__) || defined(__PDOS__)\n    argv[0] = \"\";\n\n#ifdef __MSDOS__\n    if(__osver > 0x300)\n    {\n        env=__envptr;\n        while (1)\n        {\n            if (*env++ == '\\0' && *env++ == '\\0')\n            {\n                if (*(unsigned short *)env != 0)\n                {\n                    argv[0] = (char *)env + 2;\n                }\n                break;\n            }\n        }\n    }\n#endif\n    p = p + 0x80;\n    p[*p + 1] = '\\0';\n    p++;\n#endif\n    if (*p == ' ')\n    {\n        p++;\n    }\n    if (*p == '\\0')\n    {\n        argv[1] = NULL;\n        argc = 1;\n    }\n    else\n    {\n        for (x = 1; x < 19; )\n        {\n            argv[x] = p;\n            x++;\n            p = strchr(p, ' ');\n            if (p == NULL)\n            {\n                break;\n            }\n            else\n            {\n                *p = '\\0';\n                p++;\n            }\n        }\n        argv[x] = NULL;\n        argc = x;\n    }\n#ifdef PDOS_MAIN_ENTRY\n    *i1 = argc;\n    *i2 = (int)argv;\n    return (0);\n#else\n    rc = main(argc, argv);\n    __exit(rc);\n    return (rc);\n#endif\n}\n\nvoid __exit(int status)\n{\n    int x;\n\n#if 0\n    for (x = __NATEXIT - 1; x >= 0; x--)\n    {\n        if (__userExit[x] != 0)\n        {\n            (__userExit[x])();\n        }\n    }\n#endif\n    for (x = 0; x < __NFILE; x++)\n    {\n        if (__userFiles[x] != NULL)\n        {\n            fclose(__userFiles[x]);\n        }\n    }\n    fflush(stdout);\n    fflush(stderr);\n#ifdef __MVS__\n    fclose(stdin);\n    fclose(stdout);\n#endif\n    __exita(status);\n    return;\n}\n./ ADD NAME=STDIO    0100-04042-04042-0944-03346-03346-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  stdio.c - implementation of stuff in stdio.h                     */\n/*                                                                   */\n/*  The philosophy of this module is explained here.                 */\n/*  There is a static array containing pointers to file objects.     */\n/*  This is required in order to close all the files on program      */\n/*  termination.                                                     */\n/*                                                                   */\n/*  In order to give speed absolute priority, so that people don't   */\n/*  resort to calling DosRead themselves, there is a special flag    */\n/*  in the FILE object called \"quickbin\".  If this flag is set to 1  */\n/*  it means that it is a binary file and there is nothing in the    */\n/*  buffer and there are no errors, so don't stuff around, just call */\n/*  DosRead.                                                         */\n/*                                                                   */\n/*  When a buffer exists, which is most of the time, fbuf will point */\n/*  to it.  The size of the buffer is given by szfbuf.  upto will    */\n/*  point to the next character to be read.  endbuf will point PAST  */\n/*  the last valid character in the buffer.  bufStartR represents    */\n/*  the position in the file that the first character in the buffer  */\n/*  is at.  This is only updated when a new buffer is read in.       */\n/*                                                                   */\n/*  After file open, for a file being read, bufstartR will actually  */\n/*  be a negative number, which if added to the position of upto     */\n/*  will get to 0.  On a file being written, bufstartR will be set   */\n/*  to 0, and upto will point to the start of the buffer.  The       */\n/*  reason for the difference on the read is in order to tell the    */\n/*  difference between an empty buffer and a buffer with data in it, */\n/*  but which hasn't been used yet.  The alternative would be to     */\n/*  either keep track of a flag, or make fopen read in an initial    */\n/*  buffer.  But we want to avoid reading in data that no-one has    */\n/*  yet requested.                                                   */\n/*                                                                   */\n/*  The buffer is organized as follows...                            */\n/*  What we have is an internal buffer, which is 8 characters        */\n/*  longer than the actually used buffer.  E.g. say BUFSIZ is        */\n/*  512 bytes, then we actually allocate 520 bytes.  The first       */\n/*  2 characters will be junk, the next 2 characters set to NUL,     */\n/*  for protection against some backward-compares.  The fourth-last  */\n/*  character is set to '\\n', to protect against overscan.  The      */\n/*  last 3 characters will be junk, to protect against memory        */\n/*  violation.  intBuffer is the internal buffer, but everyone       */\n/*  refers to fbuf, which is actually set to the &intBuffer[4].      */\n/*  Also, szfbuf is the size of the \"visible\" buffer, not the        */\n/*  internal buffer.  The reason for the 2 junk characters at the    */\n/*  beginning is to align the buffer on a 4-byte boundary.           */\n/*                                                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stdio.h\"\n#include \"string.h\"\n#include \"stdlib.h\"\n#include \"stdarg.h\"\n#include \"ctype.h\"\n#include \"errno.h\"\n#include \"limits.h\"\n\n/* PDOS and MSDOS use the same interface most of the time */\n#ifdef __PDOS__\n#define __MSDOS__\n#endif\n\n#ifdef __MSDOS__\n#ifdef __WATCOMC__\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\nextern int CTYP __open(const char *filename, int mode, int *errind);\nextern int CTYP __read(int handle, void *buf, size_t len, int *errind);\nextern int CTYP __write(int handle, const void *buf, size_t len, int *errind);\nextern void CTYP __seek(int handle, long offset, int whence);\nextern void CTYP __close(int handle);\nextern void CTYP __remove(const char *filename);\nextern void CTYP __rename(const char *old, const char *new);\n#endif\n\n#ifdef __OS2__\n#include <os2.h>\n#endif\n\n#ifdef __MVS__\n#include \"mvssupa.h\"\n#define FIXED_BINARY 0\n#define VARIABLE_BINARY 1\n#define FIXED_TEXT 2\n#define VARIABLE_TEXT 3\n#endif\n\nstatic FILE permFiles[3];\n\n#define unused(x) ((void)(x))\n#define outch(ch) ((fq == NULL) ? *s++ = (char)ch : putc(ch, fq))\n#define inch() ((fp == NULL) ? \\\n    (ch = (unsigned char)*s++) : (ch = getc(fp)))\n\nFILE *stdin = &permFiles[0];\nFILE *stdout = &permFiles[1];\nFILE *stderr = &permFiles[2];\n\nFILE *__userFiles[__NFILE];\nstatic FILE  *myfile;\nstatic int    spareSpot;\nstatic int    err;\n\nstatic const char *fnm;\nstatic const char *modus;\nstatic int modeType;\n\nstatic int vvprintf(const char *format, va_list arg, FILE *fq, char *s);\nstatic int vvscanf(const char *format, va_list arg, FILE *fp, const char *s);\nstatic void fopen2(void);\nstatic void fopen3(void);\nstatic void findSpareSpot(void);\nstatic void checkMode(void);\nstatic void osfopen(void);\nstatic void fwriteSlow(const void *ptr,\n                       size_t size,\n                       size_t nmemb,\n                       FILE *stream,\n                       size_t towrite,\n                       size_t *elemWritten);\nstatic void fwriteSlowT(const void *ptr,\n                        FILE *stream,\n                        size_t towrite,\n                        size_t *actualWritten);\nstatic void fwriteSlowB(const void *ptr,\n                        FILE *stream,\n                        size_t towrite,\n                        size_t *actualWritten);\nstatic void freadSlowT(void *ptr,\n                       FILE *stream,\n                       size_t toread,\n                       size_t *actualRead);\nstatic void freadSlowB(void *ptr,\n                       FILE *stream,\n                       size_t toread,\n                       size_t *actualRead);\nstatic int examine(const char **formt, FILE *fq, char *s, va_list *arg,\n                   int chcount);\n\nint printf(const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vfprintf(stdout, format, arg);\n    va_end(arg);\n    return (ret);\n}\n\nint fprintf(FILE *stream, const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vfprintf(stream, format, arg);\n    va_end(arg);\n    return (ret);\n}\n\nint vfprintf(FILE *stream, const char *format, va_list arg)\n{\n    int ret;\n\n    ret = vvprintf(format, arg, stream, NULL);\n    return (ret);\n}\n\nFILE *fopen(const char *filename, const char *mode)\n{\n    fnm = filename;\n    modus = mode;\n    err = 0;\n    findSpareSpot();\n    if (!err)\n    {\n        myfile = malloc(sizeof(FILE));\n        if (myfile == NULL)\n        {\n            err = 1;\n        }\n        else\n        {\n            fopen2();\n            if (err)\n            {\n                free(myfile);\n            }\n        }\n    }\n    if (err)\n    {\n        myfile = NULL;\n    }\n    return (myfile);\n}\n\nstatic void fopen2(void)\n{\n    checkMode();\n    if (!err)\n    {\n        osfopen();\n        if (!err)\n        {\n            __userFiles[spareSpot] = myfile;\n            myfile->intFno = spareSpot;\n            fopen3();\n        }\n    }\n    return;\n}\n\nstatic void fopen3(void)\n{\n    myfile->intBuffer = malloc(BUFSIZ + 8);\n    if (myfile->intBuffer == NULL)\n    {\n        err = 1;\n    }\n    else\n    {\n        myfile->theirBuffer = 0;\n        myfile->fbuf = myfile->intBuffer + 2;\n        *myfile->fbuf++ = '\\0';\n        *myfile->fbuf++ = '\\0';\n        myfile->szfbuf = BUFSIZ;\n#ifndef __MVS__\n        myfile->quickText = 0;\n#endif\n        myfile->noNl = 0;\n        myfile->endbuf = myfile->fbuf + myfile->szfbuf;\n        *myfile->endbuf = '\\n';\n#ifdef __MVS__\n        myfile->upto = myfile->fbuf;\n        myfile->szfbuf = myfile->lrecl;\n        myfile->endbuf = myfile->fbuf; /* for read only */\n#else\n        myfile->upto = myfile->endbuf;\n#endif\n        myfile->bufStartR = -(long)myfile->szfbuf;\n        myfile->errorInd = 0;\n        myfile->eofInd = 0;\n        myfile->ungetCh = -1;\n        myfile->update = 0;\n#ifndef __MVS__\n        if (!myfile->textMode)\n        {\n            myfile->quickBin = 1;\n        }\n        else\n        {\n            myfile->quickBin = 0;\n        }\n#endif\n        myfile->mode = __READ_MODE;\n        switch (modeType)\n        {\n            case 2:\n            case 3:\n            case 5:\n            case 6:\n            case 8:\n            case 9:\n            case 11:\n            case 12:\n                myfile->bufStartR = 0;\n                myfile->upto = myfile->fbuf;\n                myfile->mode = __WRITE_MODE;\n#ifdef __MVS__\n                myfile->endbuf = myfile->fbuf + myfile->szfbuf;\n#endif\n                break;\n        }\n        switch (modeType)\n        {\n            case 7:\n            case 8:\n            case 10:\n            case 11:\n            case 12:\n                myfile->update = 1;\n                break;\n        }\n    }\n    return;\n}\n\nstatic void findSpareSpot(void)\n{\n    int x;\n\n    for (x = 0; x < __NFILE; x++)\n    {\n        if (__userFiles[x] == NULL)\n        {\n            break;\n        }\n    }\n    if (x == __NFILE)\n    {\n        err = 1;\n    }\n    else\n    {\n        spareSpot = x;\n    }\n    return;\n}\n\n/* checkMode - interpret mode string */\n/* r = 1 */\n/* w = 2 */\n/* a = 3 */\n/* rb = 4 */\n/* wb = 5 */\n/* ab = 6 */\n/* r+ = 7 */\n/* w+ = 8 */\n/* a+ = 9 */\n/* r+b or rb+ = 10 */\n/* w+b or wb+ = 11 */\n/* a+b or ab+ = 12 */\n\nstatic void checkMode(void)\n{\n    if (strncmp(modus, \"r+b\", 3) == 0)\n    {\n        modeType = 10;\n    }\n    else if (strncmp(modus, \"rb+\", 3) == 0)\n    {\n        modeType = 10;\n    }\n    else if (strncmp(modus, \"w+b\", 3) == 0)\n    {\n        modeType = 11;\n    }\n    else if (strncmp(modus, \"wb+\", 3) == 0)\n    {\n        modeType = 11;\n    }\n    else if (strncmp(modus, \"a+b\", 3) == 0)\n    {\n        modeType = 12;\n    }\n    else if (strncmp(modus, \"ab+\", 3) == 0)\n    {\n        modeType = 12;\n    }\n    else if (strncmp(modus, \"r+\", 2) == 0)\n    {\n        modeType = 7;\n    }\n    else if (strncmp(modus, \"w+\", 2) == 0)\n    {\n        modeType = 8;\n    }\n    else if (strncmp(modus, \"a+\", 2) == 0)\n    {\n        modeType = 9;\n    }\n    else if (strncmp(modus, \"rb\", 2) == 0)\n    {\n        modeType = 4;\n    }\n    else if (strncmp(modus, \"wb\", 2) == 0)\n    {\n        modeType = 5;\n    }\n    else if (strncmp(modus, \"ab\", 2) == 0)\n    {\n        modeType = 6;\n    }\n    else if (strncmp(modus, \"r\", 1) == 0)\n    {\n        modeType = 1;\n    }\n    else if (strncmp(modus, \"w\", 1) == 0)\n    {\n        modeType = 2;\n    }\n    else if (strncmp(modus, \"a\", 1) == 0)\n    {\n        modeType = 3;\n    }\n    else\n    {\n        err = 1;\n        return;\n    }\n    if ((modeType == 4)\n        || (modeType == 5)\n        || (modeType == 6)\n        || (modeType == 10)\n        || (modeType == 11)\n        || (modeType == 12))\n    {\n        myfile->textMode = 0;\n    }\n    else\n    {\n        myfile->textMode = 1;\n    }\n    return;\n}\n\nstatic void osfopen(void)\n{\n#ifdef __OS2__\n    APIRET rc;\n    ULONG  action;\n    ULONG  newsize = 0;\n    ULONG  fileAttr = 0;\n    ULONG  openAction = 0;\n    ULONG  openMode = 0;\n\n    if ((modeType == 1) || (modeType == 4) || (modeType == 7)\n        || (modeType == 10))\n    {\n        openAction |= OPEN_ACTION_FAIL_IF_NEW;\n        openAction |= OPEN_ACTION_OPEN_IF_EXISTS;\n    }\n    else if ((modeType == 2) || (modeType == 5) || (modeType == 8)\n             || (modeType == 11))\n    {\n        openAction |= OPEN_ACTION_CREATE_IF_NEW;\n        openAction |= OPEN_ACTION_REPLACE_IF_EXISTS;\n    }\n    else if ((modeType == 3) || (modeType == 6) || (modeType == 9)\n             || (modeType == 12))\n    {\n        openAction |= OPEN_ACTION_CREATE_IF_NEW;\n        openAction |= OPEN_ACTION_OPEN_IF_EXISTS;\n    }\n    openMode |= OPEN_SHARE_DENYWRITE;\n    if ((modeType == 1) || (modeType == 4))\n    {\n        openMode |= OPEN_ACCESS_READONLY;\n    }\n    else if ((modeType == 2) || (modeType == 3) || (modeType == 5)\n             || (modeType == 6))\n    {\n        openMode |= OPEN_ACCESS_WRITEONLY;\n    }\n    else\n    {\n        openMode |= OPEN_ACCESS_READWRITE;\n    }\n    if ((strlen(fnm) == 2)\n        && (fnm[1] == ':')\n        && (openMode == OPEN_ACCESS_READONLY))\n    {\n        openMode |= OPEN_FLAGS_DASD;\n    }\n    rc = DosOpen((PSZ)fnm,\n                 &myfile->hfile,\n                 &action,\n                 newsize,\n                 fileAttr,\n                 openAction,\n                 openMode,\n                 NULL);\n    if (rc != 0)\n    {\n        err = 1;\n        errno = rc;\n    }\n#endif\n#ifdef __MSDOS__\n    int mode;\n    int errind;\n\n    if ((modeType == 1) || (modeType == 4))\n    {\n        mode = 0;\n    }\n    else if ((modeType == 2) || (modeType == 5))\n    {\n        mode = 1;\n    }\n    else\n    {\n        mode = 2;\n    }\n    myfile->hfile = __open(fnm, mode, &errind);\n    if (errind)\n    {\n        err = 1;\n        errno = myfile->hfile;\n    }\n#endif\n#ifdef __MVS__\n    int mode;\n    char *p;\n    int len;\n\n    if ((modeType == 1) || (modeType == 4))\n    {\n        mode = 0;\n    }\n    else if ((modeType == 2) || (modeType == 5))\n    {\n        mode = 1;\n    }\n    else\n    {\n        mode = 2;\n    }\n    p = strchr(fnm, ':');\n    if ((p != NULL)\n        && ((strncmp(fnm, \"dd\", 2) == 0)\n            || (strncmp(fnm, \"DD\", 2) == 0)))\n    {\n        p++;\n    }\n    else\n    {\n        p = (char *)fnm;\n    }\n    strcpy(myfile->ddname, \"        \");\n    len = strcspn(p, \"(\");\n    if (len > 8)\n    {\n        len = 8;\n    }\n    memcpy(myfile->ddname, p, len);\n    p = myfile->ddname;\n    while (*p != '\\0')\n    {\n        *p = toupper(*p);\n        p++;\n    }\n    p = strchr(fnm, '(');\n    if (p != NULL)\n    {\n        p++;\n        strcpy(myfile->pdsmem, \"        \");\n        len = strcspn(p, \")\");\n        if (len > 8)\n        {\n            len = 8;\n        }\n        memcpy(myfile->pdsmem, p, len);\n        p = myfile->pdsmem;\n        while (*p != '\\0')\n        {\n            *p = toupper(*p);\n            p++;\n        }\n        p = myfile->pdsmem;\n    }\n    myfile->hfile =\n        __aopen(myfile->ddname, mode, &myfile->recfm, &myfile->lrecl, p);\n    if ((modeType == 4) || (modeType == 5))\n    {\n        myfile->style = 0; /* binary */\n    }\n    else\n    {\n        myfile->style = 2; /* text */\n    }\n    myfile->style += myfile->recfm;\n    if (myfile->style == VARIABLE_TEXT)\n    {\n        myfile->quickText = 1;\n    }\n    else\n    {\n        myfile->quickText = 0;\n    }\n    if (myfile->style == FIXED_BINARY)\n    {\n        myfile->quickBin = 1;\n    }\n    else\n    {\n        myfile->quickBin = 0;\n    }\n#endif\n    return;\n}\n\nint fclose(FILE *stream)\n{\n#ifdef __OS2__\n    APIRET rc;\n#endif\n\n    fflush(stream);\n#ifdef __OS2__\n    rc = DosClose(stream->hfile);\n#endif\n#ifdef __MSDOS__\n    __close(stream->hfile);\n#endif\n#ifdef __MVS__\n    __aclose(stream->hfile);\n#endif\n    __userFiles[stream->intFno] = NULL;\n    if (!stream->theirBuffer)\n    {\n        free(stream->intBuffer);\n    }\n    free(stream);\n#ifdef __OS2__\n    if (rc != 0)\n    {\n        errno = rc;\n        return (EOF);\n    }\n#endif\n    return (0);\n}\n\n#ifndef __MVS__\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)\n{\n    size_t toread;\n    size_t elemRead;\n    size_t actualRead;\n#ifdef __OS2__\n    APIRET rc;\n    ULONG tempRead;\n#endif\n#ifdef __MSDOS__\n    int errind;\n    size_t tempRead;\n#endif\n\n    if (nmemb == 1)\n    {\n        toread = size;\n    }\n    else if (size == 1)\n    {\n        toread = nmemb;\n    }\n    else\n    {\n        toread = size * nmemb;\n    }\n    if (toread < stream->szfbuf)\n    {\n        stream->quickBin = 0;\n    }\n    if (!stream->quickBin)\n    {\n        if (stream->textMode)\n        {\n            freadSlowT(ptr, stream, toread, &actualRead);\n        }\n        else\n        {\n            if (toread <= (stream->endbuf - stream->upto))\n            {\n                memcpy(ptr, stream->upto, toread);\n                actualRead = toread;\n                stream->upto += toread;\n            }\n            else\n            {\n                freadSlowB(ptr, stream, toread, &actualRead);\n            }\n        }\n        if (nmemb == 1)\n        {\n            if (actualRead == size)\n            {\n                elemRead = 1;\n            }\n            else\n            {\n                elemRead = 0;\n            }\n        }\n        else if (size == 1)\n        {\n            elemRead = actualRead;\n        }\n        else\n        {\n            elemRead = actualRead / size;\n        }\n        return (elemRead);\n    }\n    else\n    {\n#ifdef __OS2__\n        rc = DosRead(stream->hfile, ptr, toread, &tempRead);\n        if (rc != 0)\n        {\n            actualRead = 0;\n            stream->errorInd = 1;\n            errno = rc;\n        }\n        else\n        {\n            actualRead = tempRead;\n        }\n#endif\n#ifdef __MSDOS__\n        tempRead = __read(stream->hfile, ptr, toread, &errind);\n        if (errind)\n        {\n            errno = tempRead;\n            actualRead = 0;\n            stream->errorInd = 1;\n        }\n        else\n        {\n            actualRead = tempRead;\n        }\n#endif\n        if (nmemb == 1)\n        {\n            if (actualRead == size)\n            {\n                elemRead = 1;\n            }\n            else\n            {\n                elemRead = 0;\n                stream->eofInd = 1;\n            }\n        }\n        else if (size == 1)\n        {\n            elemRead = actualRead;\n            if (nmemb != actualRead)\n            {\n                stream->eofInd = 1;\n            }\n        }\n        else\n        {\n            elemRead = actualRead / size;\n            if (toread != actualRead)\n            {\n                stream->eofInd = 1;\n            }\n        }\n        stream->bufStartR += actualRead;\n        return (elemRead);\n    }\n}\n\n\n/*\nwhile toread has not been satisfied\n{\n    scan stuff out of buffer, replenishing buffer as required\n}\n*/\n\nstatic void freadSlowT(void *ptr,\n                       FILE *stream,\n                       size_t toread,\n                       size_t *actualRead)\n{\n    int finReading = 0;\n    size_t avail;\n    size_t need;\n    char *p;\n    size_t got;\n#ifdef __OS2__\n    ULONG tempRead;\n    APIRET rc;\n#endif\n#ifdef __MSDOS__\n    size_t tempRead;\n    int errind;\n#endif\n\n    *actualRead = 0;\n    while (!finReading)\n    {\n        if (stream->upto == stream->endbuf)\n        {\n            stream->bufStartR += (stream->upto - stream->fbuf);\n#ifdef __OS2__\n            rc = DosRead(stream->hfile,\n                         stream->fbuf,\n                         stream->szfbuf,\n                         &tempRead);\n            if (rc != 0)\n            {\n                tempRead = 0;\n                stream->errorInd = 1;\n                errno = rc;\n            }\n#endif\n#ifdef __MSDOS__\n            tempRead = __read(stream->hfile,\n                              stream->fbuf,\n                              stream->szfbuf,\n                              &errind);\n            if (errind)\n            {\n                errno = tempRead;\n                tempRead = 0;\n                stream->errorInd = 1;\n            }\n#endif\n            if (tempRead == 0)\n            {\n                stream->eofInd = 1;\n                break;\n            }\n            stream->endbuf = stream->fbuf + tempRead;\n            *stream->endbuf = '\\n';\n            stream->upto = stream->fbuf;\n        }\n        avail = (size_t)(stream->endbuf - stream->upto) + 1;\n        need = toread - *actualRead;\n        p = memchr(stream->upto, '\\n', avail);\n        got = (size_t)(p - stream->upto);\n        if (need < got)\n        {\n            memcpy((char *)ptr + *actualRead, stream->upto, need);\n            stream->upto += need;\n            *actualRead += need;\n        }\n        else\n        {\n            memcpy((char *)ptr + *actualRead, stream->upto, got);\n            stream->upto += got;\n            *actualRead += got;\n            if (p != stream->endbuf)\n            {\n                if (*(stream->upto - 1) == '\\r')\n                {\n                    *((char *)ptr + *actualRead - 1) = '\\n';\n                }\n                else\n                {\n                    *((char *)ptr + *actualRead) = '\\n';\n                    *actualRead += 1;\n                }\n                stream->upto++;\n            }\n            else\n            {\n                if (*(stream->upto - 1) == '\\r')\n                {\n                    *actualRead -= 1;\n                }\n            }\n        }\n        if (*actualRead == toread)\n        {\n            finReading = 1;\n        }\n    }\n    return;\n}\n\nstatic void freadSlowB(void *ptr,\n                       FILE *stream,\n                       size_t toread,\n                       size_t *actualRead)\n{\n    size_t avail;\n#ifdef __OS2__\n    ULONG tempRead;\n    APIRET rc;\n#endif\n#ifdef __MSDOS__\n    size_t tempRead;\n    int errind;\n#endif\n\n    avail = (size_t)(stream->endbuf - stream->upto);\n    memcpy(ptr, stream->upto, avail);\n    *actualRead = avail;\n    stream->bufStartR += (stream->endbuf - stream->fbuf);\n    if (toread >= stream->szfbuf)\n    {\n        stream->upto = stream->endbuf;\n        stream->quickBin = 1;\n#ifdef __OS2__\n        rc = DosRead(stream->hfile,\n                     (char *)ptr + *actualRead,\n                     toread - *actualRead,\n                     &tempRead);\n        if (rc != 0)\n        {\n            tempRead = 0;\n            stream->errorInd = 1;\n            errno = rc;\n        }\n#endif\n#ifdef __MSDOS__\n        tempRead = __read(stream->hfile,\n                          (char *)ptr + *actualRead,\n                          toread - *actualRead,\n                          &errind);\n        if (errind)\n        {\n            errno = tempRead;\n            tempRead = 0;\n            stream->errorInd = 1;\n        }\n#endif\n        else if (tempRead != (toread - *actualRead))\n        {\n            stream->eofInd = 1;\n        }\n        *actualRead += tempRead;\n        stream->bufStartR += tempRead;\n    }\n    else\n    {\n        size_t left;\n\n        stream->upto = stream->fbuf;\n#ifdef __OS2__\n        rc = DosRead(stream->hfile,\n                     stream->fbuf,\n                     stream->szfbuf,\n                     &tempRead);\n        left = toread - *actualRead;\n        if (rc != 0)\n        {\n            tempRead = 0;\n            stream->errorInd = 1;\n            errno = rc;\n        }\n#endif\n#ifdef __MSDOS__\n        tempRead = __read(stream->hfile,\n                          stream->fbuf,\n                          stream->szfbuf,\n                          &errind);\n        left = toread - *actualRead;\n        if (errind)\n        {\n            errno = tempRead;\n            tempRead = 0;\n            stream->errorInd = 1;\n        }\n#endif\n        else if (tempRead < left)\n        {\n            stream->eofInd = 1;\n        }\n        stream->endbuf = stream->fbuf + tempRead;\n        *stream->endbuf = '\\n';\n        avail = (size_t)(stream->endbuf - stream->upto);\n        if (avail > left)\n        {\n            avail = left;\n        }\n        memcpy((char *)ptr + *actualRead,\n               stream->upto,\n               avail);\n        stream->upto += avail;\n        *actualRead += avail;\n    }\n    return;\n}\n#endif\n\n#ifndef __MVS__\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)\n{\n    size_t towrite;\n    size_t elemWritten;\n#ifdef __OS2__\n    ULONG actualWritten;\n    APIRET rc;\n#endif\n#ifdef __MSDOS__\n    size_t actualWritten;\n    int errind;\n#endif\n\n    if (nmemb == 1)\n    {\n        towrite = size;\n    }\n    else if (size == 1)\n    {\n        towrite = nmemb;\n    }\n    else\n    {\n        towrite = size * nmemb;\n    }\n    if (towrite < stream->szfbuf)\n    {\n        stream->quickBin = 0;\n        if ((stream->bufTech == _IONBF) && !stream->textMode)\n        {\n            stream->quickBin = 1;\n        }\n    }\n    if (!stream->quickBin)\n    {\n        fwriteSlow(ptr, size, nmemb, stream, towrite, &elemWritten);\n        return (elemWritten);\n    }\n    else\n    {\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile, (VOID *)ptr, towrite, &actualWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            actualWritten = 0;\n            errno = rc;\n        }\n#endif\n#ifdef __MSDOS__\n        actualWritten = __write(stream->hfile,\n                                ptr,\n                                towrite,\n                                &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            actualWritten = 0;\n            errno = actualWritten;\n        }\n#endif\n        if (nmemb == 1)\n        {\n            if (actualWritten == size)\n            {\n                elemWritten = 1;\n            }\n            else\n            {\n                elemWritten = 0;\n            }\n        }\n        else if (size == 1)\n        {\n            elemWritten = actualWritten;\n        }\n        else\n        {\n            elemWritten = actualWritten / size;\n        }\n        stream->bufStartR += actualWritten;\n        return (elemWritten);\n    }\n}\n\nstatic void fwriteSlow(const void *ptr,\n                       size_t size,\n                       size_t nmemb,\n                       FILE *stream,\n                       size_t towrite,\n                       size_t *elemWritten)\n{\n    size_t actualWritten;\n\n    /* Normally, on output, there will never be a situation where\n       the write buffer is full, but it hasn't been written out.\n       If we find this to be the case, then it is because we have\n       done an fseek, and didn't know whether we were going to do\n       a read or a write after it, so now that we know, we switch\n       the buffer to being set up for write.  We could use a flag,\n       but I thought it would be better to just put some magic\n       code in with a comment */\n    if (stream->upto == stream->endbuf)\n    {\n        stream->bufStartR += (stream->endbuf - stream->fbuf);\n        stream->upto = stream->fbuf;\n        stream->mode = __WRITE_MODE;\n    }\n    if ((stream->textMode) || (stream->bufTech == _IOLBF))\n    {\n        fwriteSlowT(ptr, stream, towrite, &actualWritten);\n    }\n    else\n    {\n        fwriteSlowB(ptr, stream, towrite, &actualWritten);\n    }\n    if (nmemb == 1)\n    {\n        if (actualWritten == size)\n        {\n            *elemWritten = 1;\n        }\n        else\n        {\n            *elemWritten = 0;\n        }\n    }\n    else if (size == 1)\n    {\n        *elemWritten = actualWritten;\n    }\n    else\n    {\n        *elemWritten = actualWritten / size;\n    }\n    return;\n}\n\n\n/* can still be called on binary files, if the binary file is\n   line buffered  */\n\nstatic void fwriteSlowT(const void *ptr,\n                        FILE *stream,\n                        size_t towrite,\n                        size_t *actualWritten)\n{\n    char *p;\n    char *tptr;\n    char *oldp;\n    size_t diffp;\n    size_t rem;\n    int fin;\n#ifdef __OS2__\n    ULONG tempWritten;\n    APIRET rc;\n#endif\n#ifdef __MSDOS__\n    size_t tempWritten;\n    int errind;\n#endif\n\n    *actualWritten = 0;\n    tptr = (char *)ptr;\n    p = tptr;\n    oldp = p;\n    p = (char *)memchr(oldp, '\\n', towrite - (size_t)(oldp - tptr));\n    while (p != NULL)\n    {\n        diffp = (size_t)(p - oldp);\n        fin = 0;\n        while (!fin)\n        {\n            rem = (size_t)(stream->endbuf - stream->upto);\n            if (diffp < rem)\n            {\n                memcpy(stream->upto, oldp, diffp);\n                stream->upto += diffp;\n                *actualWritten += diffp;\n                fin = 1;\n            }\n            else\n            {\n                memcpy(stream->upto, oldp, rem);\n                oldp += rem;\n                diffp -= rem;\n#ifdef __OS2__\n                rc = DosWrite(stream->hfile,\n                              stream->fbuf,\n                              stream->szfbuf,\n                              &tempWritten);\n                if (rc != 0)\n                {\n                    stream->errorInd = 1;\n                    return;\n                }\n#endif\n#ifdef __MSDOS__\n                tempWritten = __write(stream->hfile,\n                                      stream->fbuf,\n                                      stream->szfbuf,\n                                      &errind);\n                if (errind)\n                {\n                    stream->errorInd = 1;\n                    return;\n                }\n#endif\n                else\n                {\n                    *actualWritten += rem;\n                    stream->upto = stream->fbuf;\n                    stream->bufStartR += tempWritten;\n                }\n            }\n        }\n        rem = (size_t)(stream->endbuf - stream->upto);\n        if (rem < 2)\n        {\n#ifdef __OS2__\n            rc = DosWrite(stream->hfile,\n                          stream->fbuf,\n                          (size_t)(stream->upto - stream->fbuf),\n                          &tempWritten);\n            if (rc != 0)\n            {\n                stream->errorInd = 1;\n                errno = rc;\n                return;\n            }\n#endif\n#ifdef __MSDOS__\n            tempWritten = __write(stream->hfile,\n                                  stream->fbuf,\n                                  (size_t)(stream->upto - stream->fbuf),\n                                  &errind);\n            if (errind)\n            {\n                stream->errorInd = 1;\n                errno = tempWritten;\n                return;\n            }\n#endif\n            stream->upto = stream->fbuf;\n            stream->bufStartR += tempWritten;\n        }\n        if (stream->textMode)\n        {\n            memcpy(stream->upto, \"\\r\\n\", 2);\n            stream->upto += 2;\n        }\n        else\n        {\n            memcpy(stream->upto, \"\\n\", 1);\n            stream->upto += 1;\n        }\n        *actualWritten += 1;\n        oldp = p + 1;\n        p = (char *)memchr(oldp, '\\n', towrite - (size_t)(oldp - tptr));\n    }\n\n    if ((stream->bufTech == _IOLBF)\n        && (stream->upto != stream->fbuf)\n        && (oldp != tptr))\n    {\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile,\n                      stream->fbuf,\n                      (size_t)(stream->upto - stream->fbuf),\n                      &tempWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            errno = rc;\n            return;\n        }\n#endif\n#ifdef __MSDOS__\n        tempWritten = __write(stream->hfile,\n                              stream->fbuf,\n                              (size_t)(stream->upto - stream->fbuf),\n                              &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            errno = tempWritten;\n            return;\n        }\n#endif\n        stream->upto = stream->fbuf;\n        stream->bufStartR += tempWritten;\n    }\n\n    diffp = towrite - *actualWritten;\n    while (diffp != 0)\n    {\n        rem = (size_t)(stream->endbuf - stream->upto);\n        if (diffp < rem)\n        {\n            memcpy(stream->upto, oldp, diffp);\n            stream->upto += diffp;\n            *actualWritten += diffp;\n        }\n        else\n        {\n            memcpy(stream->upto, oldp, rem);\n#ifdef __OS2__\n            rc = DosWrite(stream->hfile,\n                          stream->fbuf,\n                          stream->szfbuf,\n                          &tempWritten);\n            if (rc != 0)\n            {\n                stream->errorInd = 1;\n                errno = rc;\n                return;\n            }\n#endif\n#ifdef __MSDOS__\n            tempWritten = __write(stream->hfile,\n                                  stream->fbuf,\n                                  stream->szfbuf,\n                                  &errind);\n            if (errind)\n            {\n                stream->errorInd = 1;\n                errno = tempWritten;\n                return;\n            }\n#endif\n            else\n            {\n                *actualWritten += rem;\n                stream->upto = stream->fbuf;\n            }\n            stream->bufStartR += tempWritten;\n            oldp += rem;\n        }\n        diffp = towrite - *actualWritten;\n    }\n    if ((stream->bufTech == _IONBF)\n        && (stream->upto != stream->fbuf))\n    {\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile,\n                      stream->fbuf,\n                      (size_t)(stream->upto - stream->fbuf),\n                      &tempWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            errno = rc;\n            return;\n        }\n#endif\n#ifdef __MSDOS__\n        tempWritten = __write(stream->hfile,\n                              stream->fbuf,\n                              (size_t)(stream->upto - stream->fbuf),\n                              &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            errno = tempWritten;\n            return;\n        }\n#endif\n        stream->upto = stream->fbuf;\n        stream->bufStartR += tempWritten;\n    }\n    return;\n}\n\n/* whilst write requests are smaller than a buffer, we do not turn\n   on quickbin */\n\nstatic void fwriteSlowB(const void *ptr,\n                        FILE *stream,\n                        size_t towrite,\n                        size_t *actualWritten)\n{\n    size_t spare;\n#ifdef __OS2__\n    ULONG tempWritten;\n    APIRET rc;\n#endif\n#ifdef __MSDOS__\n    size_t tempWritten;\n    int errind;\n#endif\n\n    spare = (size_t)(stream->endbuf - stream->upto);\n    if (towrite < spare)\n    {\n        memcpy(stream->upto, ptr, towrite);\n        *actualWritten = towrite;\n        stream->upto += towrite;\n        return;\n    }\n    memcpy(stream->upto, ptr, spare);\n#ifdef __OS2__\n    rc = DosWrite(stream->hfile,\n                  stream->fbuf,\n                  stream->szfbuf,\n                  &tempWritten);\n    if (rc != 0)\n    {\n        stream->errorInd = 1;\n        errno = rc;\n        return;\n    }\n#endif\n#ifdef __MSDOS__\n    tempWritten = __write(stream->hfile,\n                          stream->fbuf,\n                          stream->szfbuf,\n                          &errind);\n    if (errind)\n    {\n        stream->errorInd = 1;\n        errno = tempWritten;\n        return;\n    }\n#endif\n    *actualWritten = spare;\n    stream->upto = stream->fbuf;\n    stream->bufStartR += tempWritten;\n    if (towrite > stream->szfbuf)\n    {\n        stream->quickBin = 1;\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile,\n                      (char *)ptr + *actualWritten,\n                      towrite - *actualWritten,\n                      &tempWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            errno = rc;\n            return;\n        }\n#endif\n#ifdef __MSDOS__\n        tempWritten = __write(stream->hfile,\n                              (char *)ptr + *actualWritten,\n                              towrite - *actualWritten,\n                              &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            errno = tempWritten;\n            return;\n        }\n#endif\n        *actualWritten += tempWritten;\n        stream->bufStartR += tempWritten;\n    }\n    else\n    {\n        memcpy(stream->fbuf,\n               (char *)ptr + *actualWritten,\n               towrite - *actualWritten);\n        stream->upto += (towrite - *actualWritten);\n        *actualWritten = towrite;\n    }\n    stream->bufStartR += *actualWritten;\n    return;\n}\n#endif\n\nstatic int vvprintf(const char *format, va_list arg, FILE *fq, char *s)\n{\n    int fin = 0;\n    int vint;\n    unsigned int uvint;\n    char *vcptr;\n    int chcount = 0;\n    size_t len;\n    char numbuf[50];\n    char *nptr;\n\n    while (!fin)\n    {\n        if (*format == '\\0')\n        {\n            fin = 1;\n        }\n        else if (*format == '%')\n        {\n            format++;\n            if (*format == 'd')\n            {\n                vint = va_arg(arg, int);\n                if (vint < 0)\n                {\n                    uvint = -vint;\n                }\n                else\n                {\n                    uvint = vint;\n                }\n                nptr = numbuf;\n                do\n                {\n                    *nptr++ = (char)('0' + uvint % 10);\n                    uvint /= 10;\n                } while (uvint > 0);\n                if (vint < 0)\n                {\n                    *nptr++ = '-';\n                }\n                do\n                {\n                    nptr--;\n                    outch(*nptr);\n                    chcount++;\n                } while (nptr != numbuf);\n            }\n            else if (*format == 's')\n            {\n                vcptr = va_arg(arg, char *);\n                if (vcptr == NULL)\n                {\n                    vcptr = \"(null)\";\n                }\n                if (fq == NULL)\n                {\n                    len = strlen(vcptr);\n                    memcpy(s, vcptr, len);\n                    s += len;\n                    chcount += len;\n                }\n                else\n                {\n                    fputs(vcptr, fq);\n                    chcount += strlen(vcptr);\n                }\n            }\n            else if (*format == 'c')\n            {\n                vint = va_arg(arg, int);\n                outch(vint);\n                chcount++;\n            }\n            else if (*format == '%')\n            {\n                outch('%');\n                chcount++;\n            }\n            else\n            {\n                int extraCh;\n\n                extraCh = examine(&format, fq, s, &arg, chcount);\n                chcount += extraCh;\n                if (s != NULL)\n                {\n                    s += extraCh;\n                }\n            }\n        }\n        else\n        {\n            outch(*format);\n            chcount++;\n        }\n        format++;\n    }\n    return (chcount);\n}\n\nstatic int examine(const char **formt, FILE *fq, char *s, va_list *arg,\n                   int chcount)\n{\n    int extraCh = 0;\n    int flagMinus = 0;\n    int flagPlus = 0;\n    int flagSpace = 0;\n    int flagHash = 0;\n    int flagZero = 0;\n    int width = 0;\n    int precision = -1;\n    int half = 0;\n    int lng = 0;\n    int specifier = 0;\n    int fin;\n    long lvalue;\n    unsigned long ulvalue;\n    char *svalue;\n    char work[50];\n    int x;\n    int y;\n    int rem;\n    const char *format;\n    int base;\n    int fillCh;\n    int neg;\n    int length;\n\n    unused(chcount);\n    format = *formt;\n    /* processing flags */\n    fin = 0;\n    while (!fin)\n    {\n        switch (*format)\n        {\n            case '-': flagMinus = 1;\n                      break;\n            case '+': flagPlus = 1;\n                      break;\n            case ' ': flagSpace = 1;\n                      break;\n            case '#': flagHash = 1;\n                      break;\n            case '0': flagZero = 1;\n                      break;\n            default:  fin = 1;\n                      break;\n        }\n        if (!fin)\n        {\n            format++;\n        }\n        else\n        {\n            if (flagSpace && flagPlus)\n            {\n                flagSpace = 0;\n            }\n            if (flagMinus)\n            {\n                flagZero = 0;\n            }\n        }\n    }\n\n    /* processing width */\n    if (isdigit((unsigned char)*format))\n    {\n        while (isdigit((unsigned char)*format))\n        {\n            width = width * 10 + (*format - '0');\n            format++;\n        }\n    }\n\n    /* processing precision */\n    if (*format == '.')\n    {\n        format++;\n        precision = 0;\n        while (isdigit((unsigned char)*format))\n        {\n            precision = precision * 10 + (*format - '0');\n            format++;\n        }\n    }\n\n    /* processing h/l/L */\n    if (*format == 'h')\n    {\n        half = 1;\n    }\n    else if (*format == 'l')\n    {\n        lng = 1;\n    }\n    else if (*format == 'L')\n    {\n        lng = 1;\n    }\n    else\n    {\n        format--;\n    }\n    format++;\n\n    if (precision < 0)\n    {\n        precision = 1;\n    }\n    /* processing specifier */\n    specifier = *format;\n\n    if (strchr(\"dxXuiop\", specifier) != NULL)\n    {\n#if defined(__MSDOS__) && !defined(__PDOS__)\n        if (specifier == 'p')\n        {\n            lng = 1;\n        }\n#endif\n        if (lng)\n        {\n            lvalue = va_arg(*arg, long);\n        }\n        else if (half)\n        {\n            lvalue = va_arg(*arg, short);\n        }\n        else\n        {\n            lvalue = va_arg(*arg, int);\n        }\n        ulvalue = (unsigned long)lvalue;\n        if ((lvalue < 0) && ((specifier == 'd') || (specifier == 'i')))\n        {\n            neg = 1;\n            ulvalue = -lvalue;\n        }\n        else\n        {\n            neg = 0;\n        }\n        if ((specifier == 'X') || (specifier == 'x') || (specifier == 'p'))\n        {\n            base = 16;\n        }\n        else if (specifier == 'o')\n        {\n            base = 8;\n        }\n        else\n        {\n            base = 10;\n        }\n        if (specifier == 'p')\n        {\n#if defined(__OS2__) || defined(__PDOS__)\n            precision = 8;\n#endif\n#if defined(__MSDOS__) && !defined(__PDOS__)\n            precision = 9;\n#endif\n        }\n        x = 0;\n        while (ulvalue > 0)\n        {\n            rem = (int)(ulvalue % base);\n            if (rem < 10)\n            {\n                work[x] = (char)('0' + rem);\n            }\n            else\n            {\n                if ((specifier == 'X') || (specifier == 'p'))\n                {\n                    work[x] = (char)('A' + (rem - 10));\n                }\n                else\n                {\n                    work[x] = (char)('a' + (rem - 10));\n                }\n            }\n            x++;\n#if defined(__MSDOS__) && !defined(__PDOS__)\n            if ((x == 4) && (specifier == 'p'))\n            {\n                work[x] = ':';\n                x++;\n            }\n#endif\n            ulvalue = ulvalue / base;\n        }\n#if defined(__MSDOS__) && !defined(__PDOS__)\n        if (specifier == 'p')\n        {\n            while (x < 5)\n            {\n                work[x] = (x == 4) ? ':' : '0';\n                x++;\n            }\n        }\n#endif\n        while (x < precision)\n        {\n            work[x] = '0';\n            x++;\n        }\n        if (neg)\n        {\n            work[x++] = '-';\n        }\n        if (flagZero)\n        {\n            fillCh = '0';\n        }\n        else\n        {\n            fillCh = ' ';\n        }\n        y = x;\n        if (!flagMinus)\n        {\n            while (y < width)\n            {\n                outch(fillCh);\n                extraCh++;\n                y++;\n            }\n        }\n        if (flagHash && (toupper(specifier) == 'X'))\n        {\n            outch('0');\n            outch('x');\n            extraCh += 2;\n        }\n        x--;\n        while (x >= 0)\n        {\n            outch(work[x]);\n            extraCh++;\n            x--;\n        }\n        if (flagMinus)\n        {\n            while (y < width)\n            {\n                outch(fillCh);\n                extraCh++;\n                y++;\n            }\n        }\n    }\n    else if (specifier == 's')\n    {\n        svalue = va_arg(*arg, char *);\n        fillCh = ' ';\n        if (precision > 1)\n        {\n            char *p;\n\n            p = memchr(svalue, '\\0', precision);\n            if (p != NULL)\n            {\n                length = (int)(p - svalue);\n            }\n            else\n            {\n                length = precision;\n            }\n        }\n        else\n        {\n            length = strlen(svalue);\n        }\n        if (!flagMinus)\n        {\n            if (length < width)\n            {\n                extraCh += (width - length);\n                for (x = 0; x < (width - length); x++)\n                {\n                    outch(fillCh);\n                }\n            }\n        }\n        for (x = 0; x < length; x++)\n        {\n            outch(svalue[x]);\n        }\n        extraCh += length;\n        if (flagMinus)\n        {\n            if (length < width)\n            {\n                extraCh += (width - length);\n                for (x = 0; x < (width - length); x++)\n                {\n                    outch(fillCh);\n                }\n            }\n        }\n    }\n    *formt = format;\n    return (extraCh);\n}\n\nint fputc(int c, FILE *stream)\n{\n    char buf[1];\n\n#ifndef __MVS__\n    stream->quickBin = 0;\n    if ((stream->upto < (stream->endbuf - 2))\n        && (stream->bufTech != _IONBF))\n    {\n        if (stream->textMode)\n        {\n            if (c == '\\n')\n            {\n                if (stream->bufTech == _IOFBF)\n                {\n                    *stream->upto++ = '\\r';\n                    *stream->upto++ = '\\n';\n                }\n                else\n                {\n                    buf[0] = (char)c;\n                    if (fwrite(buf, 1, 1, stream) != 1)\n                    {\n                        return (EOF);\n                    }\n                }\n            }\n            else\n            {\n                *stream->upto++ = (char)c;\n            }\n        }\n        else\n        {\n            *stream->upto++ = (char)c;\n        }\n    }\n    else\n#endif\n    {\n        buf[0] = (char)c;\n        if (fwrite(buf, 1, 1, stream) != 1)\n        {\n            return (EOF);\n        }\n    }\n    return (c);\n}\n\n#ifndef __MVS__\nint fputs(const char *s, FILE *stream)\n{\n    size_t len;\n\n    len = strlen(s);\n    fwrite(s, len, 1, stream);\n    return (0);\n}\n#endif\n\nint remove(const char *filename)\n{\n    int ret;\n#ifdef __OS2__\n    APIRET rc;\n#endif\n\n#ifdef __OS2__\n    rc = DosDelete((PSZ)filename);\n    if (rc != 0)\n    {\n        ret = 1;\n        errno = rc;\n    }\n    else\n    {\n        ret = 0;\n    }\n#endif\n#ifdef __MSDOS__\n    __remove(filename);\n    ret = 0;\n#endif\n    return (ret);\n}\n\nint rename(const char *old, const char *new)\n{\n    int ret;\n#ifdef __OS2__\n    APIRET rc;\n#endif\n\n#ifdef __OS2__\n    rc = DosMove((PSZ)old, (PSZ)new);\n    if (rc != 0)\n    {\n        ret = 1;\n        errno = rc;\n    }\n    else\n    {\n        ret = 0;\n    }\n#endif\n#ifdef __MSDOS__\n    __rename(old, new);\n    ret = 0;\n#endif\n    return (ret);\n}\n\nint sprintf(char *s, const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vsprintf(s, format, arg);\n    va_end(arg);\n    return (ret);\n}\n\nint vsprintf(char *s, const char *format, va_list arg)\n{\n    int ret;\n\n    ret = vvprintf(format, arg, NULL, s);\n    if (ret >= 0)\n    {\n        *(s + ret) = '\\0';\n    }\n    return (ret);\n}\n\n/*\n\nIn fgets, we have the following possibilites...\n\n1. we found a genuine '\\n' that terminated the search.\n2. we hit the '\\n' at the endbuf.\n3. we hit the '\\n' sentinel.\n\n*/\n#ifndef __MVS__\nchar *fgets(char *s, int n, FILE *stream)\n{\n    char *p;\n    register char *t;\n    register char *u = s;\n    int c;\n    int processed;\n#ifdef __OS2__\n    ULONG actualRead;\n    APIRET rc;\n#endif\n#ifdef __MSDOS__\n    size_t actualRead;\n    int errind;\n#endif\n\n    if (stream->quickText)\n    {\n        p = stream->upto + n - 1;\n        t = stream->upto;\n        if (p < stream->endbuf)\n        {\n            c = *p;\n            *p = '\\n';\n#ifdef __OS2__\n            if (n < 8)\n            {\n#endif\n                while ((*u++ = *t++) != '\\n') ; /* tight inner loop */\n#ifdef __OS2__\n            }\n            else\n            {\n                register unsigned int *i1;\n                register unsigned int *i2;\n                register unsigned int z;\n\n                i1 = (unsigned int *)t;\n                i2 = (unsigned int *)u;\n                while (1)\n                {\n                    z = *i1;\n                    if ((z & 0xffU) == '\\n') break;\n                    z >>= 8;\n                    if ((z & 0xffU) == '\\n') break;\n                    z >>= 8;\n                    if ((z & 0xffU) == '\\n') break;\n                    z >>= 8;\n                    if ((z & 0xffU) == '\\n') break;\n                    *i2++ = *i1++;\n                }\n                t = (char *)i1;\n                u = (char *)i2;\n                while ((*u++ = *t++) != '\\n') ;\n            }\n#endif\n            *p = (char)c;\n            if (t <= p)\n            {\n                if (*(t - 2) == '\\r') /* t is protected, u isn't */\n                {\n                    *(u - 2) = '\\n';\n                    *(u - 1) = '\\0';\n                }\n                else\n                {\n                    *u = '\\0';\n                }\n                stream->upto = t;\n                return (s);\n            }\n            else\n            {\n                processed = (int)(t - stream->upto) - 1;\n                stream->upto = t - 1;\n                u--;\n            }\n        }\n        else\n        {\n            while ((*u++ = *t++) != '\\n') ; /* tight inner loop */\n            if (t <= stream->endbuf)\n            {\n                if (*(t - 2) == '\\r') /* t is protected, u isn't */\n                {\n                    *(u - 2) = '\\n';\n                    *(u - 1) = '\\0';\n                }\n                else\n                {\n                    *u = '\\0';\n                }\n                stream->upto = t;\n                return (s);\n            }\n            else\n            {\n                processed = (int)(t - stream->upto) - 1;\n                stream->upto = t - 1;\n                u--;\n            }\n        }\n    }\n    else\n    {\n        processed = 0;\n    }\n\n    if (n < 1)\n    {\n        return (NULL);\n    }\n    if (n < 2)\n    {\n        *u = '\\0';\n        return (s);\n    }\n    if (stream->ungetCh != -1)\n    {\n        processed++;\n        *u++ = (char)stream->ungetCh;\n        stream->ungetCh = -1;\n    }\n    while (1)\n    {\n        t = stream->upto;\n        p = stream->upto + (n - processed) - 1;\n        if (p < stream->endbuf)\n        {\n            c = *p;\n            *p = '\\n';\n        }\n        if (stream->noNl)\n        {\n            while (((*u++ = *t) != '\\n') && (*t++ != '\\r')) ;\n            if (*(u - 1) == '\\n')\n            {\n                t++;\n            }\n            else\n            {\n                u--;\n                while ((*u++ = *t++) != '\\n') ;\n            }\n        }\n        else\n        {\n            while ((*u++ = *t++) != '\\n') ; /* tight inner loop */\n        }\n        if (p < stream->endbuf)\n        {\n            *p = (char)c;\n        }\n        if (((t <= p) && (p < stream->endbuf))\n           || ((t <= stream->endbuf) && (p >= stream->endbuf)))\n        {\n            if (stream->textMode)\n            {\n                if (stream->noNl)\n                {\n                    if ((*(t - 1) == '\\r') || (*(t - 1) == '\\n'))\n                    {\n                        *(u - 1) = '\\0';\n                    }\n                    else\n                    {\n                        *u = '\\0';\n                    }\n                }\n                else if (*(t - 2) == '\\r') /* t is protected, u isn't */\n                {\n                    *(u - 2) = '\\n';\n                    *(u - 1) = '\\0';\n                }\n                else\n                {\n                    *u = '\\0';\n                }\n            }\n            stream->upto = t;\n            if (stream->textMode)\n            {\n                stream->quickText = 1;\n            }\n            return (s);\n        }\n        else if (((t > p) && (p < stream->endbuf))\n                 || ((t > stream->endbuf) && (p >= stream->endbuf)))\n        {\n            int leave = 1;\n\n            if (stream->textMode)\n            {\n                if (t > stream->endbuf)\n                {\n                    if ((t - stream->upto) > 1)\n                    {\n                        if (*(t - 2) == '\\r') /* t is protected, u isn't */\n                        {\n                            processed -= 1; /* preparation for add */\n                        }\n                    }\n                    leave = 0;\n                }\n                else\n                {\n                    if ((*(t - 2) == '\\r') && (*(t - 1) == '\\n'))\n                    {\n                        *(u - 2) = '\\n';\n                        *(u - 1) = '\\0';\n                    }\n                    else\n                    {\n                        t--;\n                        *(u - 1) = '\\0';\n                    }\n                }\n            }\n            else if (t > stream->endbuf)\n            {\n                leave = 0;\n            }\n            else\n            {\n                *u = '\\0';\n            }\n            if (leave)\n            {\n                stream->upto = t;\n                if (stream->textMode)\n                {\n                    stream->quickText = 1;\n                }\n                return (s);\n            }\n        }\n        processed += (int)(t - stream->upto) - 1;\n        u--;\n        stream->bufStartR += (stream->endbuf - stream->fbuf);\n#ifdef __OS2__\n        rc = DosRead(stream->hfile, stream->fbuf, stream->szfbuf, &actualRead);\n        if (rc != 0)\n        {\n            actualRead = 0;\n            stream->errorInd = 1;\n            errno = rc;\n        }\n#endif\n#ifdef __MSDOS__\n        actualRead = __read(stream->hfile,\n                            stream->fbuf,\n                            stream->szfbuf,\n                            &errind);\n        if (errind)\n        {\n            errno = actualRead;\n            actualRead = 0;\n            stream->errorInd = 1;\n        }\n#endif\n        stream->endbuf = stream->fbuf + actualRead;\n        *stream->endbuf = '\\n';\n        if (actualRead == 0)\n        {\n            *u = '\\0';\n            if ((u - s) <= 1)\n            {\n                stream->eofInd = 1;\n                return (NULL);\n            }\n            else\n            {\n                return (s);\n            }\n        }\n        stream->upto = stream->fbuf;\n    }\n}\n#endif\n\nint ungetc(int c, FILE *stream)\n{\n    if ((stream->ungetCh != -1) || (c == EOF))\n    {\n        return (EOF);\n    }\n    stream->ungetCh = (unsigned char)c;\n    stream->quickText = 0;\n    return ((unsigned char)c);\n}\n\nint fgetc(FILE *stream)\n{\n    unsigned char x[1];\n    size_t ret;\n\n    ret = fread(x, 1, 1, stream);\n    if (ret == 0)\n    {\n        return (EOF);\n    }\n    return ((int)x[0]);\n}\n\nint fseek(FILE *stream, long int offset, int whence)\n{\n    long newpos;\n#ifdef __OS2__\n    ULONG retpos;\n    APIRET rc;\n#endif\n\n    if (stream->mode == __WRITE_MODE)\n    {\n        fflush(stream);\n    }\n    if (whence == SEEK_SET)\n    {\n        newpos = offset;\n    }\n    else if (whence == SEEK_CUR)\n    {\n        newpos = offset + stream->bufStartR + (stream->upto - stream->fbuf);\n    }\n    if ((newpos > stream->bufStartR)\n        && (newpos < (stream->bufStartR + (stream->endbuf - stream->fbuf)))\n        && stream->update)\n    {\n        stream->upto = stream->fbuf + (size_t)(newpos - stream->bufStartR);\n    }\n    else\n    {\n#ifdef __OS2__\n        rc = DosSetFilePtr(stream->hfile, newpos, FILE_BEGIN, &retpos);\n        if ((rc != 0) || (retpos != newpos))\n        {\n            errno = rc;\n            return (-1);\n        }\n        else\n        {\n            stream->endbuf = stream->fbuf + stream->szfbuf;\n            stream->upto = stream->endbuf;\n            stream->bufStartR = newpos - stream->szfbuf;\n        }\n#endif\n#ifdef __MSDOS\n        __seek(stream->hfile, newpos, whence);\n        stream->endbuf = stream->fbuf + stream->szfbuf;\n        stream->upto = stream->endbuf;\n        stream->bufStartR = newpos - stream->szfbuf;\n#endif\n    }\n    stream->quickBin = 0;\n    stream->quickText = 0;\n    stream->ungetCh = -1;\n    return (0);\n}\n\nlong int ftell(FILE *stream)\n{\n    return (stream->bufStartR + (stream->upto - stream->fbuf));\n}\n\nint fsetpos(FILE *stream, const fpos_t *pos)\n{\n    fseek(stream, *pos, SEEK_SET);\n    return (0);\n}\n\nint fgetpos(FILE *stream, fpos_t *pos)\n{\n    *pos = ftell(stream);\n    return (0);\n}\n\nvoid rewind(FILE *stream)\n{\n    fseek(stream, 0L, SEEK_SET);\n    return;\n}\n\nvoid clearerr(FILE *stream)\n{\n    stream->errorInd = 0;\n    stream->eofInd = 0;\n    return;\n}\n\nvoid perror(const char *s)\n{\n    if ((s != NULL) && (*s != '\\0'))\n    {\n        printf(\"%s: \");\n    }\n    if (errno == 0)\n    {\n        printf(\"No error has occurred\\n\");\n    }\n    else\n    {\n        printf(\"An error has occurred\\n\");\n    }\n    return;\n}\n\n/*\nNULL + F = allocate, setup\nNULL + L = allocate, setup\nNULL + N = ignore, return success\nbuf  + F = setup\nbuf  + L = setup\nbuf  + N = ignore, return success\n*/\n\nint setvbuf(FILE *stream, char *buf, int mode, size_t size)\n{\n    char *mybuf;\n\n#ifdef __MVS__\n    /* don't allow mucking around with buffers on MVS */\n    return (0);\n#endif\n\n    if (mode == _IONBF)\n    {\n        stream->bufTech = mode;\n        return (0);\n    }\n    if (buf == NULL)\n    {\n        if (size < 2)\n        {\n            return (-1);\n        }\n        mybuf = malloc(size + 8);\n        if (mybuf == NULL)\n        {\n            return (-1);\n        }\n    }\n    else\n    {\n        if (size < 10)\n        {\n            return (-1);\n        }\n        mybuf = buf;\n        stream->theirBuffer = 1;\n        size -= 8;\n    }\n    free(stream->intBuffer);\n    stream->intBuffer = mybuf;\n    stream->fbuf = stream->intBuffer + 2;\n    *stream->fbuf++ = '\\0';\n    *stream->fbuf++ = '\\0';\n    stream->szfbuf = size;\n    stream->endbuf = stream->fbuf + stream->szfbuf;\n    *stream->endbuf = '\\n';\n    stream->upto = stream->endbuf;\n    stream->bufTech = mode;\n    if (!stream->textMode && (stream->bufTech == _IOLBF))\n    {\n        stream->quickBin = 0;\n    }\n    return (0);\n}\n\nint setbuf(FILE *stream, char *buf)\n{\n    int ret;\n\n    if (buf == NULL)\n    {\n        ret = setvbuf(stream, NULL, _IONBF, 0);\n    }\n    else\n    {\n        ret = setvbuf(stream, buf, _IOFBF, BUFSIZ);\n    }\n    return (ret);\n}\n\nFILE *freopen(const char *filename, const char *mode, FILE *stream)\n{\n    fclose(stream);\n    return (fopen(filename, mode));\n}\n\nint fflush(FILE *stream)\n{\n#ifndef __MVS__\n#ifdef __OS2__\n    APIRET rc;\n    ULONG actualWritten;\n#endif\n#ifdef __MSDOS__\n    int errind;\n    size_t actualWritten;\n#endif\n\n    if ((stream->upto != stream->fbuf) && (stream->mode == __WRITE_MODE))\n    {\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile,\n                     (VOID *)stream->fbuf,\n                     (size_t)(stream->upto - stream->fbuf),\n                     &actualWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            errno = rc;\n            return (EOF);\n        }\n#endif\n#ifdef __MSDOS__\n        actualWritten = __write(stream->hfile,\n                                stream->fbuf,\n                                (size_t)(stream->upto - stream->fbuf),\n                                &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            errno = actualWritten;\n            return (EOF);\n        }\n#endif\n        stream->bufStartR += actualWritten;\n        stream->upto = stream->fbuf;\n    }\n#endif\n    return (0);\n}\n\nchar *tmpnam(char *s)\n{\n    static char buf[] = \"ZZZZZZZA.$$$\";\n\n    buf[7]++;\n    if (s == NULL)\n    {\n        return (buf);\n    }\n    strcpy(s, buf);\n    return (s);\n}\n\nFILE *tmpfile(void)\n{\n    return (fopen(\"ZZZZZZZA.$$$\", \"wb+\"));\n}\n\nint fscanf(FILE *stream, const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vvscanf(format, arg, stream, NULL);\n    va_end(arg);\n    return (ret);\n}\n\nint scanf(const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vvscanf(format, arg, stdin, NULL);\n    va_end(arg);\n    return (ret);\n}\n\nint sscanf(const char *s, const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vvscanf(format, arg, NULL, s);\n    va_end(arg);\n    return (ret);\n}\n\nstatic int vvscanf(const char *format, va_list arg, FILE *fp, const char *s)\n{\n    int ch;\n    int fin = 0;\n    int cnt = 0;\n    char *cptr;\n    int *iptr;\n\n    inch();\n    while (!fin)\n    {\n        if (*format == '\\0')\n        {\n            fin = 1;\n        }\n        else if (*format == '%')\n        {\n            format++;\n            if (*format == '%')\n            {\n                if (ch != '%') return (cnt);\n                inch();\n            }\n            else if (*format == 's')\n            {\n                cptr = va_arg(arg, char *);\n                *cptr++ = (char)ch;\n                inch();\n                while ((ch >= 0) && (!isspace(ch)))\n                {\n                    *cptr++ = (char)ch;\n                    inch();\n                }\n                *cptr = '\\0';\n                if (ch < 0)\n                {\n                    fin = 1;\n                }\n            }\n            else if (*format == 'd')\n            {\n                iptr = va_arg(arg, int *);\n                if (!isdigit(ch)) return (cnt);\n                *iptr = ch - '0';\n                inch();\n                while ((ch >= 0) && (isdigit(ch)))\n                {\n                    *iptr = *iptr * 10 + (ch - '0');\n                    inch();\n                }\n                if (ch < 0)\n                {\n                    fin = 1;\n                }\n            }\n        }\n        else\n        {\n            if (ch != *format) return (cnt);\n            inch();\n        }\n    }\n    return (cnt);\n}\n\nchar *gets(char *s)\n{\n    char *ret;\n\n    stdin->quickText = 0;\n    stdin->noNl = 1;\n    ret = fgets(s, INT_MAX, stdin);\n    stdin->noNl = 0;\n    stdin->quickText = 1;\n    return (ret);\n}\n\nint puts(const char *s)\n{\n    int ret;\n\n    ret = fputs(s, stdout);\n    if (ret == EOF)\n    {\n        return (ret);\n    }\n    return (putc('\\n', stdout));\n}\n\n/* The following functions are implemented as macros */\n\n#undef getchar\n#undef putchar\n#undef getc\n#undef putc\n#undef feof\n#undef ferror\n\nint getc(FILE *stream)\n{\n    return (fgetc(stream));\n}\n\nint putc(int c, FILE *stream)\n{\n    return (fputc(c, stream));\n}\n\nint getchar(void)\n{\n    return (getc(stdin));\n}\n\nint putchar(int c)\n{\n    return (putc(c, stdout));\n}\n\nint feof(FILE *stream)\n{\n    return (stream->eofInd);\n}\n\nint ferror(FILE *stream)\n{\n    return (stream->errorInd);\n}\n\n#if 0\nDesign of MVS i/o routines\n\nin/out function rec-type mode   method\nin     fread    fixed    bin    loop reading, remember remainder\nin     fread    fixed    text   loop reading + truncing, remember rem\nin     fread    var      bin    loop reading (+ len), remember remainder\nin     fread    var      text   loop reading (+ len), remember remainder\nin     fgets    fixed    bin    read, scan, remember remainder\nin     fgets    fixed    text   read, trunc, remember remainder\nin     fgets    var      bin    read, scan, rr\nin     fgets    var      text   read, rr\nin     fgetc    fixed    bin    read, rr\nin     fgetc    fixed    text   read, trunc, rr\nin     fgetc    var      bin    read, rr\nin     fgetc    var      text   read, rr\n\nout    fwrite   fixed    bin    loop doing put, rr\nout    fwrite   fixed    text   search newline, copy + pad, put, rr\nout    fwrite   var      bin    if nelem != 1 copy to max lrecl\nout    fwrite   var      text   loop search nl, put, rr\nout    fputs    fixed    bin    loop doing put, rr\nout    fputs    fixed    text   search newline, copy + pad, put, rr\nout    fputs    var      bin    put\nout    fputs    var      text   search newline, put, copy rem\nout    fputc    fixed    bin    copy to rr until rr == lrecl\nout    fputc    fixed    text   copy to rr until newline, then pad\nout    fputc    var      bin    copy to rr until rr == lrecl\nout    fputc    var      text   copy to rr until newline\n\noptimize for fread on binary files (read matching record length),\nespecially fixed block files, and fgets on text files, especially\nvariable blocked files.\n\nbinary, variable block files are not a file type supported by this\nlibrary as part of the conforming implementation.  Instead, they\nare considered to be record-oriented processing, similar to unix\nsystems reading data from a pipe, where you can read less bytes\nthan requested, without reaching EOF.  ISO 7.9.8.1 does not give you\nthe flexibility of calling either of these things conforming.\nBasically, the C standard does not have a concept of operating\nsystem maintained length binary records, you have to do that\nyourself, e.g. by writing out the lengths yourself.  You can do\nthis in a fixed block dataset on MVS, and if you are concerned\nabout null-padding at the end of your data, use a lrecl of 1\n(and suffer the consequences!).  You could argue that this\nnon-conformance should only be initiated if fopen has a parameter\nincluding \",type=record\" or whatever.  Another option would\nbe to make VB binary records include the record size as part of\nthe stream.  Hmmm, sounds like that is the go actually.\n\nfread: if quickbin, if read elem size == lrecl, doit\nfgets: if variable record + no remainder\n       if buffer > record size, copy + add newline\n#endif\n\n#ifdef __MVS__\nchar *fgets(char *s, int n, FILE *stream)\n{\n    unsigned char *dptr;\n    unsigned char *eptr;\n    size_t len;\n    int cnt;\n    int c;\n\n    if (stream->quickText)\n    {\n        if (__aread(stream->hfile, &dptr) != 0)\n        {\n            stream->eofInd = 1;\n            stream->quickText = 0;\n            return (NULL);\n        }\n        len = ((dptr[0] << 8) | dptr[1]) - 4;\n        if (n > (len + 1))\n        {\n            memcpy(s, dptr + 4, len);\n            memcpy(s + len, \"\\n\", 2);\n            return (s);\n        }\n        else\n        {\n            memcpy(stream->fbuf, dptr + 4, len);\n            stream->upto = stream->fbuf;\n            stream->endbuf = stream->fbuf + len;\n            *(stream->endbuf++) = '\\n';\n            stream->quickText = 0;\n        }\n    }\n\n    if (stream->eofInd)\n    {\n        return (NULL);\n    }\n\n    switch (stream->style)\n    {\n        case FIXED_TEXT:\n            if ((stream->endbuf == stream->fbuf)\n                && (n > (stream->lrecl + 2)))\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    return (NULL);\n                }\n                eptr = dptr + stream->lrecl - 1;\n                while ((*eptr == ' ') && (eptr >= dptr))\n                {\n                    eptr--;\n                }\n                memcpy(s, dptr, eptr + 1 - dptr);\n                memcpy(s + (eptr + 1 - dptr), \"\\n\", 2);\n                return (s);\n            }\n            break;\n\n        default:\n            break;\n\n    }\n\n    /* Ok, the obvious optimizations have been done,\n       so now we switch to the slow generic version */\n\n    n--;\n    cnt = 0;\n    while (cnt < n)\n    {\n        c = getc(stream);\n        if (c == EOF) break;\n        s[cnt] = c;\n        if (c == '\\n') break;\n        cnt++;\n    }\n    if (cnt < n) s[cnt++] = '\\n';\n    s[cnt] = '\\0';\n    return (s);\n}\n\nint fputs(const char *s, FILE *stream)\n{\n    const char *p;\n    size_t len;\n    char *dptr;\n\n    if (stream->quickText)\n    {\n        p = strchr(s, '\\n');\n        if (p != NULL)\n        {\n            len = p - s;\n            if (len > stream->lrecl)\n            {\n                len = stream->lrecl;\n            }\n            __awrite(stream->hfile, &dptr);\n            memcpy(dptr + 4, s, len);\n            dptr[0] = (len + 4) >> 8;\n            dptr[1] = (len + 4) & 0xff;\n            dptr[2] = 0;\n            dptr[3] = 0;\n            if (*(p + 1) == '\\0')\n            {\n                return (len + 1);\n            }\n            s = p + 1;\n        }\n    }\n    switch (stream->style)\n    {\n        case FIXED_TEXT:\n            len = strlen(s);\n            if (len > 0)\n            {\n                len--;\n                if (((strchr(s, '\\n') - s) == len)\n                    && (stream->upto == stream->fbuf)\n                    && (len <= stream->lrecl))\n                {\n                    __awrite(stream->hfile, &dptr);\n                    memcpy(dptr, s, len);\n                    memset(dptr + len, ' ', stream->szfbuf - len);\n                }\n                else\n                {\n                    fwrite(s, len + 1, 1, stream);\n                }\n            }\n            break;\n\n        default:\n            len = strlen(s);\n            fwrite(s, len, 1, stream);\n    }\n    return (0);\n}\n\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)\n{\n    size_t bytes;\n    size_t sz;\n    char *p;\n    int x;\n    char *dptr;\n\n    if (stream->quickBin)\n    {\n        if ((nmemb == 1) && (size == stream->lrecl))\n        {\n            __awrite(stream->hfile, &dptr);\n            memcpy(dptr, ptr, size);\n            return (1);\n        }\n        else\n        {\n            stream->quickBin = 0;\n        }\n    }\n    switch (stream->style)\n    {\n        case FIXED_BINARY:\n            bytes = nmemb * size;\n            if ((stream->endbuf - stream->upto) > bytes)\n            {\n                memcpy(stream->upto, ptr, bytes);\n            }\n            else\n            {\n                if (stream->upto != stream->fbuf)\n                {\n                    sz = stream->endbuf - stream->upto;\n                    memcpy(stream->upto, ptr, sz);\n                    ptr = (char *)ptr + sz;\n                    bytes -= sz;\n                    __awrite(stream->hfile, stream->fbuf);\n                    stream->upto = stream->fbuf;\n                }\n            }\n            while (bytes > stream->szfbuf)\n            {\n                __awrite(stream->hfile, ptr);\n                ptr = (char *)ptr + stream->szfbuf;\n                bytes -= stream->szfbuf;\n            }\n            memcpy(stream->upto, ptr, bytes);\n            stream->upto += bytes;\n            break;\n\n        case VARIABLE_BINARY:\n            for (x = 0; x < nmemb; x++)\n            {\n                memcpy(stream->fbuf + 4, ptr, size);\n                stream->fbuf[0] = (size + 4) >> 8;\n                stream->fbuf[1] = (size + 4) & 0xff;\n                stream->fbuf[2] = 0;\n                stream->fbuf[3] = 0;\n                __awrite(stream->hfile, ptr);\n                ptr = (char *)ptr + size;\n            }\n            break;\n\n        case FIXED_TEXT:\n            bytes = nmemb * size;\n            p = memchr(ptr, '\\n', bytes);\n            if (p != NULL)\n            {\n                sz = p - (char *)ptr;\n                bytes -= sz + 1;\n                if (stream->upto == stream->fbuf)\n                {\n                    if (sz > stream->lrecl)\n                    {\n                        sz = stream->lrecl;\n                    }\n                    __awrite(stream->hfile, &dptr);\n                    memcpy(dptr, ptr, sz);\n                    memset(dptr + sz, ' ', stream->szfbuf - sz);\n                }\n                else\n                {\n                    if (((stream->upto - stream->fbuf) + sz) > stream->lrecl)\n                    {\n                        sz = stream->lrecl - (stream->upto - stream->fbuf);\n                    }\n                    memcpy(stream->upto, ptr, sz);\n                    sz += (stream->upto - stream->fbuf);\n                    __awrite(stream->hfile, &dptr);\n                    memcpy(dptr, stream->fbuf, sz);\n                    memset(dptr + sz, ' ', stream->lrecl - sz);\n                    stream->upto = stream->fbuf;\n                }\n                ptr = (char *)p + 1;\n                if (bytes > 0)\n                {\n                    p = memchr(ptr, '\\n', bytes);\n                    while (p != NULL)\n                    {\n                        sz = p - (char *)ptr;\n                        bytes -= sz + 1;\n                        if (sz > stream->lrecl)\n                        {\n                            sz = stream->lrecl;\n                        }\n                        __awrite(stream->hfile, &dptr);\n                        memcpy(dptr, ptr, sz);\n                        memset(dptr + sz, ' ', stream->szfbuf - sz);\n                        ptr = p + 1;\n                        p = memchr(ptr, '\\n', bytes);\n                    }\n                    if (bytes > 0)\n                    {\n                        sz = bytes;\n                        if (sz > stream->lrecl)\n                        {\n                            sz = stream->lrecl;\n                        }\n                        memcpy(stream->upto, ptr, sz);\n                        stream->upto += sz;\n                        bytes = 0;\n                    }\n                }\n            }\n            else /* p == NULL */\n            {\n                if (((stream->upto - stream->fbuf) + bytes) > stream->lrecl)\n                {\n                    bytes = stream->lrecl - (stream->upto - stream->fbuf);\n                }\n                memcpy(stream->upto, ptr, bytes);\n                stream->upto += bytes;\n            }\n            break;\n\n        case VARIABLE_TEXT:\n            bytes = nmemb * size;\n            p = memchr(ptr, '\\n', bytes);\n            if (p != NULL)\n            {\n                sz = p - (char *)ptr;\n                bytes -= sz + 1;\n                if (stream->upto == stream->fbuf)\n                {\n                    if (sz > stream->lrecl)\n                    {\n                        sz = stream->lrecl;\n                    }\n                    __awrite(stream->hfile, &dptr);\n                    dptr[0] = sz >> 8;\n                    dptr[1] = sz & 0xff;\n                    dptr[2] = 0;\n                    dptr[3] = 0;\n                    memcpy(dptr + 4, ptr, sz);\n                }\n                else\n                {\n                    if (((stream->upto - stream->fbuf) + sz) > stream->lrecl)\n                    {\n                        sz = stream->lrecl - (stream->upto - stream->fbuf);\n                    }\n                    memcpy(stream->upto, p, sz);\n                    sz += (stream->upto - stream->fbuf);\n                    __awrite(stream->hfile, &dptr);\n                    dptr[0] = sz >> 8;\n                    dptr[1] = sz & 0xff;\n                    dptr[2] = 0;\n                    dptr[3] = 0;\n                    memcpy(dptr + 4, stream->fbuf, sz);\n                    stream->upto = stream->fbuf;\n                }\n                ptr = (char *)p + 1;\n                if (bytes > 0)\n                {\n                    p = memchr(ptr, '\\n', bytes);\n                    while (p != NULL)\n                    {\n                        sz = p - (char *)ptr;\n                        bytes -= sz + 1;\n                        if (sz > stream->lrecl)\n                        {\n                            sz = stream->lrecl;\n                        }\n                        __awrite(stream->hfile, &dptr);\n                        dptr[0] = sz >> 8;\n                        dptr[1] = sz & 0xff;\n                        dptr[2] = 0;\n                        dptr[3] = 0;\n                        memcpy(dptr + 4, ptr, sz);\n                        ptr = p + 1;\n                        p = memchr(ptr, '\\n', bytes);\n                    }\n                    if (bytes > 0)\n                    {\n                        sz = bytes;\n                        if (sz > stream->lrecl)\n                        {\n                            sz = stream->lrecl;\n                        }\n                        memcpy(stream->upto, ptr, sz);\n                        stream->upto += sz;\n                        bytes = 0;\n                    }\n                }\n            }\n            else /* p == NULL */\n            {\n                if (((stream->upto - stream->fbuf) + bytes) > stream->lrecl)\n                {\n                    bytes = stream->lrecl - (stream->upto - stream->fbuf);\n                }\n                memcpy(stream->upto, ptr, bytes);\n                stream->upto += bytes;\n            }\n            break;\n    }\n    return (nmemb);\n}\n\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)\n{\n    size_t bytes;\n    size_t read;\n    size_t totalread;\n    size_t extra;\n    unsigned char *dptr;\n    unsigned char *eptr;\n\n    if (stream->quickBin)\n    {\n        if ((nmemb == 1) && (size == stream->lrecl))\n        {\n            if (__aread(stream->hfile, &dptr) != 0)\n            {\n                stream->eofInd = 1;\n                stream->quickBin = 0;\n                return (0);\n            }\n            memcpy(ptr, dptr, read);\n            return (1);\n        }\n    }\n    if (stream->eofInd)\n    {\n        return (0);\n    }\n    switch (stream->style)\n    {\n        case FIXED_TEXT:\n            bytes = nmemb * size;\n            read = stream->endbuf - stream->upto;\n            if (read > bytes)\n            {\n                memcpy(ptr, stream->upto, bytes);\n                stream->upto += bytes;\n                totalread = bytes;\n            }\n            else\n            {\n                memcpy(ptr, stream->upto, read);\n                stream->upto = stream->endbuf = stream->fbuf;\n                totalread = read;\n            }\n\n            while (totalread < bytes)\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    break;\n                }\n\n                eptr = dptr + stream->lrecl - 1;\n                while ((*eptr == ' ') && (eptr >= dptr))\n                {\n                    eptr--;\n                }\n\n                read = eptr + 1 - dptr;\n\n                if ((totalread + read) >= bytes)\n                {\n                    extra = (totalread + read) - bytes;\n                    read -= extra;\n                    memcpy(stream->fbuf, dptr + read, extra);\n                    stream->endbuf = stream->fbuf + extra;\n                    *stream->endbuf++ = '\\n';\n                }\n\n                memcpy((char *)ptr + totalread, dptr, read);\n                totalread += read;\n                if (totalread < bytes)\n                {\n                    *((char *)ptr + totalread) = '\\n';\n                    totalread++;\n                }\n            }\n            return (totalread / size);\n            break;\n\n        case FIXED_BINARY:\n            bytes = nmemb * size;\n            read = stream->endbuf - stream->upto;\n            if (read > bytes)\n            {\n                memcpy(ptr, stream->upto, bytes);\n                stream->upto += bytes;\n                totalread = bytes;\n            }\n            else\n            {\n                memcpy(ptr, stream->upto, read);\n                stream->upto = stream->endbuf = stream->fbuf;\n                totalread = read;\n            }\n\n            while (totalread < bytes)\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    break;\n                }\n\n                read = stream->lrecl;\n\n                if ((totalread + read) > bytes)\n                {\n                    extra = (totalread + read) - bytes;\n                    read -= extra;\n                    memcpy(stream->fbuf, dptr + read, extra);\n                    stream->endbuf = stream->fbuf + extra;\n                }\n\n                memcpy((char *)ptr + totalread, dptr, read);\n                totalread += read;\n            }\n            return (totalread / size);\n            break;\n\n        case VARIABLE_TEXT:\n            bytes = nmemb * size;\n            read = stream->endbuf - stream->upto;\n            if (read > bytes)\n            {\n                memcpy(ptr, stream->upto, bytes);\n                stream->upto += bytes;\n                totalread = bytes;\n            }\n            else\n            {\n                memcpy(ptr, stream->upto, read);\n                stream->upto = stream->endbuf = stream->fbuf;\n                totalread = read;\n            }\n\n            while (totalread < bytes)\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    break;\n                }\n\n                read = (dptr[0] << 8) | dptr[1];\n                read -= 4;\n                dptr += 4;\n\n                if ((totalread + read) >= bytes)\n                {\n                    extra = (totalread + read) - bytes;\n                    read -= extra;\n                    memcpy(stream->fbuf, dptr + read, extra);\n                    stream->endbuf = stream->fbuf + extra;\n                    *stream->endbuf++ = '\\n';\n                }\n\n                memcpy((char *)ptr + totalread, dptr, read);\n                totalread += read;\n                if (totalread < bytes)\n                {\n                    *((char *)ptr + totalread) = '\\n';\n                    totalread++;\n                }\n            }\n            return (totalread / size);\n            break;\n\n        case VARIABLE_BINARY:\n            bytes = nmemb * size;\n            read = stream->endbuf - stream->upto;\n            if (read > bytes)\n            {\n                memcpy(ptr, stream->upto, bytes);\n                stream->upto += bytes;\n                totalread = bytes;\n            }\n            else\n            {\n                memcpy(ptr, stream->upto, read);\n                stream->upto = stream->endbuf = stream->fbuf;\n                totalread = read;\n            }\n\n            while (totalread < bytes)\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    break;\n                }\n\n                read = (dptr[0] << 8) | dptr[1];\n\n                if ((totalread + read) > bytes)\n                {\n                    extra = (totalread + read) - bytes;\n                    read -= extra;\n                    memcpy(stream->fbuf, dptr + read, extra);\n                    stream->endbuf = stream->fbuf + extra;\n                }\n\n                memcpy((char *)ptr + totalread, dptr, read);\n                totalread += read;\n            }\n            return (totalread / size);\n            break;\n\n        default:\n            break;\n    }\n    return (0);\n}\n\n#endif\n./ ADD NAME=STDLIB   0100-04042-04042-0944-00699-00699-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  stdlib.c - implementation of stuff in stdlib.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stdlib.h\"\n#include \"signal.h\"\n#include \"string.h\"\n#include \"ctype.h\"\n\n/* PDOS and MSDOS use the same interface most of the time */\n#ifdef __PDOS__\n#define __MSDOS__\n#endif\n\n#ifdef __OS2__\n#define INCL_DOSMISC\n#define INCL_DOSPROCESS\n#include <os2.h>\n#endif\n\n#ifdef __MVS__\n#include \"mvssupa.h\"\n#endif\n\n#ifdef __MSDOS__\n#ifdef __WATCOMC__\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\nvoid CTYP __allocmem(size_t size, void **ptr);\nvoid CTYP __freemem(void *ptr);\nextern unsigned char *__envptr;\nvoid CTYP __exec(char *cmd, void *env);\n#endif\n\nvoid (*__userExit[__NATEXIT])(void);\n\nvoid *malloc(size_t size)\n{\n#ifdef __OS2__\n    PVOID BaseAddress;\n    ULONG ulObjectSize;\n    ULONG ulAllocationFlags;\n    APIRET rc;\n\n    ulObjectSize = size + sizeof(size_t);\n    ulAllocationFlags = PAG_COMMIT | PAG_WRITE | PAG_READ;\n    rc = DosAllocMem(&BaseAddress, ulObjectSize, ulAllocationFlags);\n    if (rc != 0) return (NULL);\n    *(size_t *)BaseAddress = size;\n    BaseAddress = (char *)BaseAddress + sizeof(size_t);\n    return ((void *)BaseAddress);\n#endif\n#ifdef __MSDOS__\n    void *ptr;\n\n    __allocmem(size, &ptr);\n    return (ptr);\n#endif\n#ifdef __MVS__\n    return (__getm(size));\n#endif\n}\n\nvoid *calloc(size_t nmemb, size_t size)\n{\n    void *ptr;\n    size_t total;\n\n    if (nmemb == 1)\n    {\n        total = size;\n    }\n    else if (size == 1)\n    {\n        total = nmemb;\n    }\n    else\n    {\n        total = nmemb * size;\n    }\n    ptr = malloc(total);\n    if (ptr != NULL)\n    {\n        memset(ptr, '\\0', total);\n    }\n    return (ptr);\n}\n\nvoid *realloc(void *ptr, size_t size)\n{\n    char *newptr;\n    size_t oldsize;\n\n    newptr = malloc(size);\n    if (newptr == NULL)\n    {\n        return (NULL);\n    }\n    if (ptr != NULL)\n    {\n#ifdef __MVS__\n        oldsize = *(size_t *)((char *)ptr - 16);\n        oldsize -= 16;\n#else\n        oldsize = *(size_t *)((char *)ptr - 4);\n#endif\n        if (oldsize < size)\n        {\n            size = oldsize;\n        }\n        memcpy(newptr, ptr, size);\n        free(ptr);\n    }\n    return (newptr);\n}\n\nvoid free(void *ptr)\n{\n#ifdef __OS2__\n    if (ptr != NULL)\n    {\n        ptr = (char *)ptr - sizeof(size_t);\n        DosFreeMem((PVOID)ptr);\n    }\n#endif\n#ifdef __MSDOS__\n    if (ptr != NULL)\n    {\n        __freemem(ptr);\n    }\n#endif\n#ifdef __MVS__\n    if (ptr != NULL)\n    {\n        __freem(ptr);\n    }\n#endif\n    return;\n}\n\nvoid abort(void)\n{\n    raise(SIGABRT);\n    exit(EXIT_FAILURE);\n#ifndef __EMX__\n    return;\n#endif\n}\n\n#ifndef __EMX__\nvoid __exit(int status);\n#else\nvoid __exit(int status) __attribute__((noreturn));\n#endif\n\nvoid exit(int status)\n{\n    __exit(status);\n#ifndef __EMX__\n    return;\n#endif\n}\n\n/******************************************************************/\n/* qsort.c  --  Non-Recursive ISO C qsort() function              */\n/*                                                                */\n/* Public domain by Raymond Gardner, Englewood CO  February 1991  */\n/* Minor mods by Paul Edwards also public domain                  */\n/*                                                                */\n/* Usage:                                                         */\n/*     qsort(base, nbr_elements, width_bytes, compare_function);  */\n/*        void *base;                                             */\n/*        size_t nbr_elements, width_bytes;                       */\n/*        int (*compare_function)(const void *, const void *);    */\n/*                                                                */\n/* Sorts an array starting at base, of length nbr_elements, each  */\n/* element of size width_bytes, ordered via compare_function,     */\n/* which is called as  (*compare_function)(ptr_to_element1,       */\n/* ptr_to_element2) and returns < 0 if element1 < element2,       */\n/* 0 if element1 = element2, > 0 if element1 > element2.          */\n/* Most refinements are due to R. Sedgewick. See \"Implementing    */\n/* Quicksort Programs\", Comm. ACM, Oct. 1978, and Corrigendum,    */\n/* Comm. ACM, June 1979.                                          */\n/******************************************************************/\n\n/* prototypes */\nstatic void swap_chars(char *, char *, size_t);\n\n/*\n** Compile with -DSWAP_INTS if your machine can access an int at an\n** arbitrary location with reasonable efficiency.  (Some machines\n** cannot access an int at an odd address at all, so be careful.)\n*/\n\n#ifdef   SWAP_INTS\n void swap_ints(char *, char *, size_t);\n #define  SWAP(a, b)  (swap_func((char *)(a), (char *)(b), width))\n#else\n #define  SWAP(a, b)  (swap_chars((char *)(a), (char *)(b), size))\n#endif\n\n#define  COMP(a, b)  ((*comp)((void *)(a), (void *)(b)))\n\n#define  T           7    /* subfiles of T or fewer elements will */\n                          /* be sorted by a simple insertion sort */\n                          /* Note!  T must be at least 3          */\n\nvoid qsort(void *basep, size_t nelems, size_t size,\n                            int (*comp)(const void *, const void *))\n{\n   char *stack[40], **sp;       /* stack and stack pointer        */\n   char *i, *j, *limit;         /* scan and limit pointers        */\n   size_t thresh;               /* size of T elements in bytes    */\n   char *base;                  /* base pointer as char *         */\n\n#ifdef   SWAP_INTS\n   size_t width;                /* width of array element         */\n   void (*swap_func)(char *, char *, size_t); /* swap func pointer*/\n\n   width = size;                /* save size for swap routine     */\n   swap_func = swap_chars;      /* choose swap function           */\n   if ( size % sizeof(int) == 0 ) {   /* size is multiple of ints */\n      width /= sizeof(int);           /* set width in ints        */\n      swap_func = swap_ints;          /* use int swap function    */\n   }\n#endif\n\n   base = (char *)basep;        /* set up char * base pointer     */\n   thresh = T * size;           /* init threshold                 */\n   sp = stack;                  /* init stack pointer             */\n   limit = base + nelems * size;/* pointer past end of array      */\n   for ( ;; ) {                 /* repeat until break...          */\n      if ( limit - base > thresh ) {  /* if more than T elements  */\n                                      /*   swap base with middle  */\n         SWAP(((((size_t)(limit-base))/size)/2)*size+base, base);\n         i = base + size;             /* i scans left to right    */\n         j = limit - size;            /* j scans right to left    */\n         if ( COMP(i, j) > 0 )        /* Sedgewick's              */\n            SWAP(i, j);               /*    three-element sort    */\n         if ( COMP(base, j) > 0 )     /*        sets things up    */\n            SWAP(base, j);            /*            so that       */\n         if ( COMP(i, base) > 0 )     /*      *i <= *base <= *j   */\n            SWAP(i, base);            /* *base is pivot element   */\n         for ( ;; ) {                 /* loop until break         */\n            do                        /* move i right             */\n               i += size;             /*        until *i >= pivot */\n            while ( COMP(i, base) < 0 );\n            do                        /* move j left              */\n               j -= size;             /*        until *j <= pivot */\n            while ( COMP(j, base) > 0 );\n            if ( i > j )              /* if pointers crossed      */\n               break;                 /*     break loop           */\n            SWAP(i, j);       /* else swap elements, keep scanning*/\n         }\n         SWAP(base, j);         /* move pivot into correct place  */\n         if ( j - base > limit - i ) {  /* if left subfile larger */\n            sp[0] = base;             /* stack left subfile base  */\n            sp[1] = j;                /*    and limit             */\n            base = i;                 /* sort the right subfile   */\n         } else {                     /* else right subfile larger*/\n            sp[0] = i;                /* stack right subfile base */\n            sp[1] = limit;            /*    and limit             */\n            limit = j;                /* sort the left subfile    */\n         }\n         sp += 2;                     /* increment stack pointer  */\n      } else {      /* else subfile is small, use insertion sort  */\n         for ( j = base, i = j+size; i < limit; j = i, i += size )\n            for ( ; COMP(j, j+size) > 0; j -= size ) {\n               SWAP(j, j+size);\n               if ( j == base )\n                  break;\n            }\n         if ( sp != stack ) {         /* if any entries on stack  */\n            sp -= 2;                  /* pop the base and limit   */\n            base = sp[0];\n            limit = sp[1];\n         } else                       /* else stack empty, done   */\n            break;\n      }\n   }\n}\n\n/*\n**  swap nbytes between a and b\n*/\n\nstatic void swap_chars(char *a, char *b, size_t nbytes)\n{\n   char tmp;\n   do {\n      tmp = *a; *a++ = *b; *b++ = tmp;\n   } while ( --nbytes );\n}\n\n#ifdef   SWAP_INTS\n\n/*\n**  swap nints between a and b\n*/\n\nstatic void swap_ints(char *ap, char *bp, size_t nints)\n{\n   int *a = (int *)ap, *b = (int *)bp;\n   int tmp;\n   do {\n      tmp = *a; *a++ = *b; *b++ = tmp;\n   } while ( --nints );\n}\n\n#endif\n\nstatic unsigned long myseed = 1;\n\nvoid srand(unsigned int seed)\n{\n    myseed = seed;\n    return;\n}\n\nint rand(void)\n{\n    int ret;\n\n    myseed = myseed * 1103515245UL + 12345;\n    ret = (int)((myseed >> 16) & 0x8fff);\n    return (ret);\n}\n\ndouble atof(const char *nptr)\n{\n    return (strtod(nptr, (char **)NULL));\n}\n\ndouble strtod(const char *nptr, char **endptr)\n{\n    double x = 0.0;\n\n    while (1)\n    {\n        if (isdigit(*nptr))\n        {\n            x = x * 10 + (*nptr - '0');\n        }\n        else\n        {\n            if (endptr != NULL)\n            {\n                *endptr = (char *)nptr;\n            }\n            break;\n        }\n        nptr++;\n    }\n    return (x);\n}\n\nint atoi(const char *nptr)\n{\n    return ((int)strtol(nptr, (char **)NULL, 10));\n}\n\nlong int atol(const char *nptr)\n{\n    return (strtol(nptr, (char **)NULL, 10));\n}\n\nlong int strtol(const char *nptr, char **endptr, int base)\n{\n    long x = 0;\n    int undecided = 0;\n\n    if (base == 0)\n    {\n        undecided = 1;\n    }\n    while (1)\n    {\n        if (isdigit(*nptr))\n        {\n            if (base == 0)\n            {\n                if (*nptr == '0')\n                {\n                    base = 8;\n                }\n                else\n                {\n                    base = 10;\n                    undecided = 0;\n                }\n            }\n            x = x * base + (*nptr - '0');\n            nptr++;\n        }\n        else if (isalpha(*nptr))\n        {\n            if ((*nptr == 'X') || (*nptr == 'x'))\n            {\n                if ((base == 0) || ((base == 8) && undecided))\n                {\n                    base = 16;\n                    undecided = 0;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            else\n            {\n                x = x * base + (toupper((unsigned char)*nptr) - 'A') + 10;\n                nptr++;\n            }\n        }\n        else\n        {\n            break;\n        }\n    }\n    if (endptr != NULL)\n    {\n        *endptr = (char *)nptr;\n    }\n    return (x);\n}\n\nunsigned long int strtoul(const char *nptr, char **endptr, int base)\n{\n    unsigned long x = 0;\n\n    while (1)\n    {\n        if (isdigit(*nptr))\n        {\n            x = x * base + (*nptr - '0');\n            nptr++;\n        }\n        else if (isalpha(*nptr) && (base > 10))\n        {\n            x = x * base + (toupper((unsigned char)*nptr) - 'A') + 10;\n            nptr++;\n        }\n        else\n        {\n            break;\n        }\n    }\n    if (endptr != NULL)\n    {\n        *endptr = (char *)nptr;\n    }\n    return (x);\n}\n\nint mblen(const char *s, size_t n)\n{\n    if (s == NULL)\n    {\n        return (0);\n    }\n    if (n == 1)\n    {\n        return (1);\n    }\n    else\n    {\n        return (-1);\n    }\n}\n\nint mbtowc(wchar_t *pwc, const char *s, size_t n)\n{\n    if (s == NULL)\n    {\n        return (0);\n    }\n    if (n == 1)\n    {\n        if (pwc != NULL)\n        {\n            *pwc = *s;\n        }\n        return (1);\n    }\n    else\n    {\n        return (-1);\n    }\n}\n\nint wctomb(char *s, wchar_t wchar)\n{\n    if (s != NULL)\n    {\n        *s = wchar;\n        return (1);\n    }\n    else\n    {\n        return (0);\n    }\n}\n\nsize_t mbstowcs(wchar_t *pwcs, const char *s, size_t n)\n{\n    strncpy((char *)pwcs, s, n);\n    if (strlen(s) >= n)\n    {\n        return (n);\n    }\n    return (strlen((char *)pwcs));\n}\n\nsize_t wcstombs(char *s, const wchar_t *pwcs, size_t n)\n{\n    strncpy(s, (const char *)pwcs, n);\n    if (strlen((const char *)pwcs) >= n)\n    {\n        return (n);\n    }\n    return (strlen(s));\n}\n\n#ifdef abs\n#undef abs\n#endif\nint abs(int j)\n{\n    if (j < 0)\n    {\n        j = -j;\n    }\n    return (j);\n}\n\ndiv_t div(int numer, int denom)\n{\n    div_t x;\n\n    x.quot = numer / denom;\n    x.rem = numer % denom;\n    return (x);\n}\n\n#ifdef labs\n#undef labs\n#endif\nlong int labs(long int j)\n{\n    if (j < 0)\n    {\n        j = -j;\n    }\n    return (j);\n}\n\nldiv_t ldiv(long int numer, long int denom)\n{\n    ldiv_t x;\n\n    x.quot = numer / denom;\n    x.rem = numer % denom;\n    return (x);\n}\n\nint atexit(void (*func)(void))\n{\n    int x;\n\n    for (x = 0; x < __NATEXIT; x++)\n    {\n        if (__userExit[x] == 0)\n        {\n            __userExit[x] = func;\n            return (0);\n        }\n    }\n    return (-1);\n}\n\nchar *getenv(const char *name)\n{\n#ifdef __OS2__\n    PSZ result;\n\n    if (DosScanEnv((void *)name, (void *)&result) == 0)\n    {\n        return ((char *)result);\n    }\n#endif\n#ifdef __MSDOS__\n    char *env;\n    size_t lenn;\n\n    env = (char *)__envptr;\n    lenn = strlen(name);\n    while (*env != '\\0')\n    {\n        if (strncmp(env, name, lenn) == 0)\n        {\n            if (env[lenn] == '=')\n            {\n                return (&env[lenn + 1]);\n            }\n        }\n        env = env + strlen(env) + 1;\n    }\n#endif\n    return (NULL);\n}\n\n/* The following code was taken from Paul Markham's \"EXEC\" program,\n   and adapted to create a system() function.  The code is all\n   public domain */\n\nint system(const char *string)\n{\n#ifdef __OS2__\n    char err_obj[100];\n        APIRET rc;\n        RESULTCODES results;\n\n    if (string == NULL)\n    {\n        return (1);\n    }\n    rc = DosExecPgm(err_obj, sizeof err_obj, EXEC_SYNC,\n                    (PSZ)string, NULL, &results, (PSZ)string);\n    if (rc != 0)\n    {\n        return (rc);\n    }\n    return ((int)results.codeResult);\n#endif\n#ifdef __MSDOS__\n    static unsigned char cmdt[140];\n    static struct {\n        int env;\n        unsigned char *cmdtail;\n        char *fcb1;\n        char *fcb2;\n    } parmblock = { 0, cmdt, NULL, NULL };\n    size_t len;\n    char *cmd;\n\n    len = strlen(string);\n    cmdt[0] = (unsigned char)(len + 3);\n    memcpy(&cmdt[1], \"/c \", 3);\n    memcpy(&cmdt[4], string, len);\n    memcpy(&cmdt[len + 4], \"\\r\", 2);\n    cmd = getenv(\"COMSPEC\");\n    if (cmd == NULL)\n    {\n        cmd = \"\\\\command.com\";\n    }\n    __exec(cmd, &parmblock);\n    return (0);\n#endif\n}\n\nvoid *bsearch(const void *key, const void *base,\n              size_t nmemb, size_t size,\n              int (*compar)(const void *, const void *))\n{\n    size_t try;\n    int res;\n    const void *ptr;\n\n    while (nmemb > 0)\n    {\n        try = nmemb / 2;\n        ptr = (void *)((char *)base + try * size);\n        res = compar(ptr, key);\n        if (res == 0)\n        {\n            return ((void *)ptr);\n        }\n        else if (res < 0)\n        {\n            nmemb = nmemb - try - 1;\n            base = (const void *)((const char *)ptr + size);\n        }\n        else\n        {\n            nmemb = try;\n        }\n    }\n    return (NULL);\n}\n./ ADD NAME=STRING   0100-04042-04042-0944-00439-00439-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  string.c - implementation of routines in string.h                */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"string.h\"\n\n#ifdef memmove\n#undef memmove\n#endif\nvoid *memmove(void *s1, const void *s2, size_t n)\n{\n    char *p = s1;\n    const char *cs2 = s2;\n    size_t x;\n\n    if (p <= cs2)\n    {\n        for (x=0; x < n; x++)\n        {\n            *p = *cs2;\n            p++;\n            cs2++;\n        }\n    }\n    else\n    {\n        if (n != 0)\n        {\n            for (x=n-1; x > 0; x--)\n            {\n                *(p+x) = *(cs2+x);\n            }\n        }\n        *(p+x) = *(cs2+x);\n    }\n    return (s1);\n}\n\n#ifdef strcpy\n#undef strcpy\n#endif\nchar *strcpy(char *s1, const char *s2)\n{\n    char *p = s1;\n\n    while ((*p++ = *s2++) != '\\0') ;\n    return (s1);\n}\n\n#ifdef strncpy\n#undef strncpy\n#endif\nchar *strncpy(char *s1, const char *s2, size_t n)\n{\n    char *p = s1;\n    size_t x;\n\n    for (x=0; x < n; x++)\n    {\n        *p = *s2;\n        if (*s2 == '\\0') break;\n        p++;\n        s2++;\n    }\n    for (; x < n; x++)\n    {\n        *p++ = '\\0';\n    }\n    return (s1);\n}\n\n#ifdef strcat\n#undef strcat\n#endif\nchar *strcat(char *s1, const char *s2)\n{\n    char *p = s1;\n\n    while (*p != '\\0') p++;\n    while ((*p = *s2) != '\\0')\n    {\n        p++;\n        s2++;\n    }\n    return (s1);\n}\n\n#ifdef strncat\n#undef strncat\n#endif\nchar *strncat(char *s1, const char *s2, size_t n)\n{\n    char *p = s1;\n    size_t x = 0;\n\n    while (*p != '\\0') p++;\n    while ((*s2 != '\\0') && (x < n))\n    {\n        *p = *s2;\n        p++;\n        s2++;\n        x++;\n    }\n    *p = '\\0';\n    return (s1);\n}\n\n#ifdef memcmp\n#undef memcmp\n#endif\nint memcmp(const void *s1, const void *s2, size_t n)\n{\n    const unsigned char *p1;\n    const unsigned char *p2;\n    size_t x = 0;\n\n    p1 = (const unsigned char *)s1;\n    p2 = (const unsigned char *)s2;\n    while (x < n)\n    {\n        if (p1[x] < p2[x]) return (-1);\n        else if (p1[x] > p2[x]) return (1);\n        x++;\n    }\n    return (0);\n}\n\n#ifdef strcmp\n#undef strcmp\n#endif\nint strcmp(const char *s1, const char *s2)\n{\n    const unsigned char *p1;\n    const unsigned char *p2;\n\n    p1 = (const unsigned char *)s1;\n    p2 = (const unsigned char *)s2;\n    while (*p1 != '\\0')\n    {\n        if (*p1 < *p2) return (-1);\n        else if (*p1 > *p2) return (1);\n        p1++;\n        p2++;\n    }\n    if (*p2 == '\\0') return (0);\n    else return (-1);\n}\n\nint strcoll(const char *s1, const char *s2)\n{\n    return (strcmp(s1, s2));\n}\n\n#ifdef strncmp\n#undef strncmp\n#endif\nint strncmp(const char *s1, const char *s2, size_t n)\n{\n    const unsigned char *p1;\n    const unsigned char *p2;\n    size_t x = 0;\n\n    p1 = (const unsigned char *)s1;\n    p2 = (const unsigned char *)s2;\n    while (x < n)\n    {\n        if (p1[x] < p2[x]) return (-1);\n        else if (p1[x] > p2[x]) return (1);\n        else if (p1[x] == '\\0') return (0);\n        x++;\n    }\n    return (0);\n}\n\nsize_t strxfrm(char *s1, const char *s2, size_t n)\n{\n    size_t oldlen;\n\n    oldlen = strlen(s2);\n    if (oldlen < n)\n    {\n        memcpy(s1, s2, oldlen);\n        s1[oldlen] = '\\0';\n    }\n    return (oldlen);\n}\n\n#ifdef memchr\n#undef memchr\n#endif\nvoid *memchr(const void *s, int c, size_t n)\n{\n    const unsigned char *p;\n    size_t x = 0;\n\n    p = (const unsigned char *)s;\n    while (x < n)\n    {\n        if (*p == (unsigned char)c) return ((void *)p);\n        p++;\n        x++;\n    }\n    return (NULL);\n}\n\n#ifdef strchr\n#undef strchr\n#endif\nchar *strchr(const char *s, int c)\n{\n    while (*s != '\\0')\n    {\n        if (*s == (char)c) return ((char *)s);\n        s++;\n    }\n    if (c == '\\0') return ((char *)s);\n    return (NULL);\n}\n\nsize_t strcspn(const char *s1, const char *s2)\n{\n    const char *p1;\n    const char *p2;\n\n    p1 = s1;\n    while (*p1 != '\\0')\n    {\n        p2 = s2;\n        while (*p2 != '\\0')\n        {\n            if (*p1 == *p2) return ((size_t)(p1 - s1));\n            p2++;\n        }\n        p1++;\n    }\n    return ((size_t)(p1 - s1));\n}\n\nchar *strpbrk(const char *s1, const char *s2)\n{\n    const char *p1;\n    const char *p2;\n\n    p1 = s1;\n    while (*p1 != '\\0')\n    {\n        p2 = s2;\n        while (*p2 != '\\0')\n        {\n            if (*p1 == *p2) return ((char *)p1);\n            p2++;\n        }\n        p1++;\n    }\n    return (NULL);\n}\n\n#ifdef strrchr\n#undef strrchr\n#endif\nchar *strrchr(const char *s, int c)\n{\n    const char *p;\n\n    p = s + strlen(s);\n    while (p >= s)\n    {\n        if (*p == (char)c) return ((char *)p);\n        p--;\n    }\n    return (NULL);\n}\n\nsize_t strspn(const char *s1, const char *s2)\n{\n    const char *p1;\n    const char *p2;\n\n    p1 = s1;\n    while (*p1 != '\\0')\n    {\n        p2 = s2;\n        while (*p2 != '\\0')\n        {\n            if (*p1 == *p2) break;\n            p2++;\n        }\n        if (*p2 == '\\0') return ((size_t)(p1 - s1));\n        p1++;\n    }\n    return ((size_t)(p1 - s1));\n}\n\n\n/* strstr by Frank Adam */\n/* modified by Paul Edwards */\n\nchar *strstr(const char *s1, const char *s2)\n{\n    const char *p = s1, *p1, *p2 = s2;\n\n    while (*p)\n    {\n        if (*p == *s2)\n        {\n            p1 = p;\n            p2 = s2;\n            while ((*p2 != '\\0') && (*p1++ == *p2++)) ;\n            if (*p2 == '\\0')\n            {\n                return (char *)p;\n            }\n        }\n        p++;\n    }\n    return NULL;\n}\n\nchar *strtok(char *s1, const char *s2)\n{\n    static char *old = NULL;\n    char *p;\n    size_t len;\n    size_t remain;\n\n    if (s1 != NULL) old = s1;\n    if (old == NULL) return (NULL);\n    p = old;\n    len = strspn(p, s2);\n    remain = strlen(p);\n    if (remain <= len) { old = NULL; return (NULL); }\n    p += len;\n    len = strcspn(p, s2);\n    remain = strlen(p);\n    if (remain <= len) { old = NULL; return (p); }\n    *(p + len) = '\\0';\n    old = p + len + 1;\n    return (p);\n}\n\n#ifdef memset\n#undef memset\n#endif\nvoid *memset(void *s, int c, size_t n)\n{\n    size_t x = 0;\n\n    for (x = 0; x < n; x++)\n    {\n        *((char *)s + x) = (unsigned char)c;\n    }\n    return (s);\n}\n\nchar *strerror(int errnum)\n{\n    if (errnum == 0) return (\"No error has occurred\\n\");\n    else return (\"An error has occurred\\n\");\n}\n\n#ifdef strlen\n#undef strlen\n#endif\nsize_t strlen(const char *s)\n{\n    const char *p;\n\n    p = s;\n    while (*p != '\\0') p++;\n    return ((size_t)(p - s));\n}\n\n#ifndef USE_ASSEMBLER\n#ifdef memcpy\n#undef memcpy\n#endif\n#ifndef __32BIT__\nvoid *memcpy(void *s1, const void *s2, size_t n)\n{\n    register const unsigned char *f = s2;\n    register const unsigned char *fe;\n    register unsigned char *t = s1;\n\n    fe = f + n;\n    while (f != fe)\n    {\n        *t++ = *f++;\n    }\n    return (s1);\n}\n#else\nvoid *memcpy(void *s1, const void *s2, size_t n)\n{\n    register unsigned int *p = (unsigned int *)s1;\n    register unsigned int *cs2 = (unsigned int *)s2;\n    register unsigned int *endi;\n\n    endi = (unsigned int *)((char *)p + (n & ~0x03));\n    while (p != endi)\n    {\n        *p++ = *cs2++;\n    }\n    switch (n & 0x03)\n    {\n        case 0:\n            break;\n        case 1:\n            *(char *)p = *(char *)cs2;\n            break;\n        case 2:\n            *(char *)p = *(char *)cs2;\n            p = (unsigned int *)((char *)p + 1);\n            cs2 = (unsigned int *)((char *)cs2 + 1);\n            *(char *)p = *(char *)cs2;\n            break;\n        case 3:\n            *(char *)p = *(char *)cs2;\n            p = (unsigned int *)((char *)p + 1);\n            cs2 = (unsigned int *)((char *)cs2 + 1);\n            *(char *)p = *(char *)cs2;\n            p = (unsigned int *)((char *)p + 1);\n            cs2 = (unsigned int *)((char *)cs2 + 1);\n            *(char *)p = *(char *)cs2;\n            break;\n    }\n    return (s1);\n}\n#endif\n#endif\n\n\n./ ADD NAME=TIME     0100-04042-04042-0944-00551-00551-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  time.c - implementation of stuff in time.h                       */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"time.h\"\n#include \"stdarg.h\"\n#include \"stdio.h\"\n\n/* pdos and msdos use the same interface most of the time) */\n#ifdef __PDOS__\n#define __MSDOS__\n#endif\n\n#ifdef __MVS__\n#include \"mvssupa.h\"\n#endif\n#ifdef __OS2__\n#include <os2.h>\n#endif\n#ifdef __MSDOS__\n#ifdef __WATCOMC__\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\nvoid CTYP __datetime(void *ptr);\n#endif\n\n/* scalar date routines    --    public domain by Ray Gardner\n** These will work over the range 1-01-01 thru 14699-12-31\n** The functions written by Ray are isleap, months_to_days,\n** years_to_days, ymd_to_scalar, scalar_to_ymd.\n** modified slightly by Paul Edwards\n*/\n\nstatic int isleap(unsigned yr)\n{\n   return yr % 400 == 0 || (yr % 4 == 0 && yr % 100 != 0);\n}\n\nstatic unsigned months_to_days(unsigned month)\n{\n   return (month * 3057 - 3007) / 100;\n}\n\nstatic long years_to_days (unsigned yr)\n{\n   return yr * 365L + yr / 4 - yr / 100 + yr / 400;\n}\n\nstatic long ymd_to_scalar(unsigned yr, unsigned mo, unsigned day)\n{\n   long scalar;\n\n   scalar = day + months_to_days(mo);\n   if ( mo > 2 )                         /* adjust if past February */\n      scalar -= isleap(yr) ? 1 : 2;\n   yr--;\n   scalar += years_to_days(yr);\n   return (scalar);\n}\n\nstatic void scalar_to_ymd(long scalar,\n                          unsigned *pyr,\n                          unsigned *pmo,\n                          unsigned *pday)\n{\n   unsigned n;                /* compute inverse of years_to_days() */\n\n   n = (unsigned)((scalar * 400L) / 146097L);\n   while (years_to_days(n) < scalar)\n   {\n      n++;\n   }\n   for ( n = (unsigned)((scalar * 400L) / 146097L); years_to_days(n) < scalar; )\n      n++;                          /* 146097 == years_to_days(400) */\n   *pyr = n;\n   n = (unsigned)(scalar - years_to_days(n-1));\n   if ( n > 59 ) {                       /* adjust if past February */\n      n += 2;\n      if ( isleap(*pyr) )\n         n -= n > 62 ? 1 : 2;\n   }\n   *pmo = (n * 100 + 3007) / 3057;  /* inverse of months_to_days() */\n   *pday = n - months_to_days(*pmo);\n   return;\n}\n\ntime_t time(time_t *timer)\n{\n    time_t tt;\n#ifdef __OS2__\n    DATETIME dt;\n    APIRET rc;\n#endif\n#if (defined(__MSDOS__) || defined(__MVS__))\n    struct {\n        int year;\n        int month;\n        int day;\n        int hours;\n        int minutes;\n        int seconds;\n        int hundredths;\n    } dt;\n#endif\n#ifdef __MVS__\n    unsigned int clk[2];\n#endif\n\n#ifdef __OS2__\n    rc = DosGetDateTime(&dt);\n    if (rc != 0)\n    {\n        tt = (time_t)-1;\n    }\n    else\n#endif\n#ifdef __MSDOS__\n    __datetime(&dt);\n#endif\n#ifdef __MVS__\n    tt = __getclk(clk);\n#else\n\n    {\n        tt = ymd_to_scalar(dt.year, dt.month, dt.day)\n             - ymd_to_scalar(1970, 1, 1);\n        tt = tt * 24 + dt.hours;\n        tt = tt * 60 + dt.minutes;\n        tt = tt * 60 + dt.seconds;\n    }\n#endif\n    if (timer != NULL)\n    {\n        *timer = tt;\n    }\n    return (tt);\n}\n\nclock_t clock(void)\n{\n    return ((clock_t)-1);\n}\n\ndouble difftime(time_t time1, time_t time0)\n{\n    return ((double)(time1 - time0));\n}\n\ntime_t mktime(struct tm *timeptr)\n{\n    time_t tt;\n\n    if ((timeptr->tm_year < 70) || (timeptr->tm_year > 120))\n    {\n        tt = (time_t)-1;\n    }\n    else\n    {\n        tt = ymd_to_scalar(timeptr->tm_year + 1900,\n                           timeptr->tm_mon + 1,\n                           timeptr->tm_mday)\n             - ymd_to_scalar(1970, 1, 1);\n        tt = tt * 24 + timeptr->tm_hour;\n        tt = tt * 60 + timeptr->tm_min;\n        tt = tt * 60 + timeptr->tm_sec;\n    }\n    return (tt);\n}\n\nchar *asctime(const struct tm *timeptr)\n{\n    static const char wday_name[7][3] = {\n          \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n    };\n    static const char mon_name[12][3] = {\n          \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n          \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n    };\n    static char result[26];\n\n    sprintf(result, \"%.3s %.3s%3d %.2d:%.2d:%.2d %d\\n\",\n          wday_name[timeptr->tm_wday],\n          mon_name[timeptr->tm_mon],\n          timeptr->tm_mday, timeptr->tm_hour,\n          timeptr->tm_min, timeptr->tm_sec,\n          1900 + timeptr->tm_year);\n    return result;\n}\n\nchar *ctime(const time_t *timer)\n{\n    return (asctime(localtime(timer)));\n}\n\nstruct tm *gmtime(const time_t *timer)\n{\n    return (localtime(timer));\n}\n\n/* dow - written by Paul Edwards, 1993-01-31 */\n/* Released to the Public Domain */\n/* This routine will work over the range 1-01-01 to 32767-12-31.\n   It assumes the current calendar system has always been in\n   place in that time.  If you pass 0 or negative years, then\n   it produces results on the assumption that there is a year\n   0.  It should always produce a value in the range of 0..6\n   if a valid month and day have been passed, no matter what\n   the year is.  However, it has not been tested for negative\n   years, because the results are meaningless anyway.  It is\n   mainly to stop people playing silly buggers and causing\n   the macro to crash on negative years. */\n\n#define dow(y,m,d) \\\n  ((((((m)+9)%12+1)<<4)%27 + (d) + 1 + \\\n  ((y)%400+400) + ((y)%400+400)/4 - ((y)%400+400)/100 + \\\n  (((m)<=2) ? ( \\\n  (((((y)%4)==0) && (((y)%100)!=0)) || (((y)%400)==0)) \\\n  ? 5 : 6) : 0)) % 7)\n\nstatic struct tm tms;\n\nstruct tm *localtime(const time_t *timer)\n{\n    unsigned yr, mo, da;\n    unsigned long secs;\n    unsigned long days;\n\n    days = *timer / (60L*60*24);\n    secs = *timer % (60L*60*24);\n    scalar_to_ymd(days + ymd_to_scalar(1970, 1, 1), &yr, &mo, &da);\n    tms.tm_year = yr - 1900;\n    tms.tm_mon = mo - 1;\n    tms.tm_mday = da;\n    tms.tm_yday = (int)(ymd_to_scalar(tms.tm_year + 1900, 1, 1)\n                  - ymd_to_scalar(tms.tm_year + 1900, mo, da));\n    tms.tm_wday = dow(tms.tm_year + 1900, mo, da);\n    tms.tm_isdst = -1;\n    tms.tm_sec = (int)(secs % 60);\n    secs /= 60;\n    tms.tm_min = (int)(secs % 60);\n    secs /= 60;\n    tms.tm_hour = (int)secs;\n    return (&tms);\n}\n\n/*\n * strftime.c\n *\n * implements the iso c function strftime()\n *\n * written 1989-09-06 by jim nutt\n * released into the public domain by jim nutt\n *\n * modified 1989-10-21 by Rob Duff\n *\n * modified 1994-08-26 by Paul Edwards\n */\n\nstatic char *aday[] = {\n    \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n};\n\nstatic char *day[] = {\n    \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n    \"Thursday\", \"Friday\", \"Saturday\"\n};\n\nstatic char *amonth[] = {\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n};\n\nstatic char *month[] = {\n    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n};\n\nstatic char *__tzname[2] = { \"\" \"\" };\nstatic char buf[26];\n\nstatic void strfmt(char *str, const char *fmt, ...);\n\n/**\n *\n * size_t strftime(char *str,\n *                 size_t maxs,\n *                 const char *fmt,\n *                 const struct tm *t)\n *\n *      this functions acts much like a sprintf for time/date output.\n *      given a pointer to an output buffer, a format string and a\n *      time, it copies the time to the output buffer formatted in\n *      accordance with the format string.  the parameters are used\n *      as follows:\n *\n *          str is a pointer to the output buffer, there should\n *          be at least maxs characters available at the address\n *          pointed to by str.\n *\n *          maxs is the maximum number of characters to be copied\n *          into the output buffer, included the '\\0' terminator\n *\n *          fmt is the format string.  a percent sign (%) is used\n *          to indicate that the following character is a special\n *          format character.  the following are valid format\n *          characters:\n *\n *              %A      full weekday name (Monday)\n *              %a      abbreviated weekday name (Mon)\n *              %B      full month name (January)\n *              %b      abbreviated month name (Jan)\n *              %c      standard date and time representation\n *              %d      day-of-month (01-31)\n *              %H      hour (24 hour clock) (00-23)\n *              %I      hour (12 hour clock) (01-12)\n *              %j      day-of-year (001-366)\n *              %M      minute (00-59)\n *              %m      month (01-12)\n *              %p      local equivalent of AM or PM\n *              %S      second (00-59)\n *              %U      week-of-year, first day sunday (00-53)\n *              %W      week-of-year, first day monday (00-53)\n *              %w      weekday (0-6, sunday is 0)\n *              %X      standard time representation\n *              %x      standard date representation\n *              %Y      year with century\n *              %y      year without century (00-99)\n *              %Z      timezone name\n *              %%      percent sign\n *\n *      the standard date string is equivalent to:\n *\n *          %a %b %d %Y\n *\n *      the standard time string is equivalent to:\n *\n *          %H:%M:%S\n *\n *      the standard date and time string is equivalent to:\n *\n *          %a %b %d %H:%M:%S %Y\n *\n *      strftime returns the number of characters placed in the\n *      buffer, not including the terminating \\0, or zero if more\n *      than maxs characters were produced.\n *\n**/\n\nsize_t strftime(char *s, size_t maxs, const char *f, const struct tm *t)\n{\n      int w;\n      char *p, *q, *r;\n\n      p = s;\n      q = s + maxs - 1;\n      while ((*f != '\\0'))\n      {\n            if (*f++ == '%')\n            {\n                  r = buf;\n                  switch (*f++)\n                  {\n                  case '%' :\n                        r = \"%\";\n                        break;\n\n                  case 'a' :\n                        r = aday[t->tm_wday];\n                        break;\n\n                  case 'A' :\n                        r = day[t->tm_wday];\n                        break;\n\n                  case 'b' :\n                        r = amonth[t->tm_mon];\n                        break;\n\n                  case 'B' :\n                        r = month[t->tm_mon];\n                        break;\n\n                  case 'c' :\n                        strfmt(r, \"%0 %0 %2 %2:%2:%2 %4\",\n                              aday[t->tm_wday], amonth[t->tm_mon],\n                              t->tm_mday,t->tm_hour, t->tm_min,\n                              t->tm_sec, t->tm_year+1900);\n                        break;\n\n                  case 'd' :\n                        strfmt(r,\"%2\",t->tm_mday);\n                        break;\n\n                  case 'H' :\n                        strfmt(r,\"%2\",t->tm_hour);\n                        break;\n\n                  case 'I' :\n                        strfmt(r,\"%2\",(t->tm_hour%12)?t->tm_hour%12:12);\n                        break;\n\n                  case 'j' :\n                        strfmt(r,\"%3\",t->tm_yday+1);\n                        break;\n\n                  case 'm' :\n                        strfmt(r,\"%2\",t->tm_mon+1);\n                        break;\n\n                  case 'M' :\n                        strfmt(r,\"%2\",t->tm_min);\n                        break;\n\n                  case 'p' :\n                        r = (t->tm_hour>11)?\"PM\":\"AM\";\n                        break;\n\n                  case 'S' :\n                        strfmt(r,\"%2\",t->tm_sec);\n                        break;\n\n                  case 'U' :\n                        w = t->tm_yday/7;\n                        if (t->tm_yday%7 > t->tm_wday)\n                              w++;\n                        strfmt(r, \"%2\", w);\n                        break;\n\n                  case 'W' :\n                        w = t->tm_yday/7;\n                        if (t->tm_yday%7 > (t->tm_wday+6)%7)\n                              w++;\n                        strfmt(r, \"%2\", w);\n                        break;\n\n                  case 'w' :\n                        strfmt(r,\"%1\",t->tm_wday);\n                        break;\n\n                  case 'x' :\n                        strfmt(r, \"%3s %3s %2 %4\", aday[t->tm_wday],\n                              amonth[t->tm_mon], t->tm_mday, t->tm_year+1900);\n                        break;\n\n                  case 'X' :\n                        strfmt(r, \"%2:%2:%2\", t->tm_hour,\n                              t->tm_min, t->tm_sec);\n                        break;\n\n                  case 'y' :\n                        strfmt(r,\"%2\",t->tm_year%100);\n                        break;\n\n                  case 'Y' :\n                        strfmt(r,\"%4\",t->tm_year+1900);\n                        break;\n\n                  case 'Z' :\n                        r = (t->tm_isdst) ? __tzname[1] : __tzname[0];\n                        break;\n\n                  default:\n                        buf[0] = '%';     /* reconstruct the format */\n                        buf[1] = f[-1];\n                        buf[2] = '\\0';\n                        if (buf[1] == 0)\n                              f--;        /* back up if at end of string */\n                  }\n                  while (*r)\n                  {\n                        if (p == q)\n                        {\n                              *q = '\\0';\n                              return 0;\n                        }\n                        *p++ = *r++;\n                  }\n            }\n            else\n            {\n                  if (p == q)\n                  {\n                        *q = '\\0';\n                        return 0;\n                  }\n                  *p++ = f[-1];\n            }\n      }\n      *p = '\\0';\n      return (size_t)(p - s);\n}\n\nstatic int pow[5] = { 1, 10, 100, 1000, 10000 };\n\n/**\n * static void strfmt(char *str, char *fmt);\n *\n * simple sprintf for strftime\n *\n * each format descriptor is of the form %n\n * where n goes from zero to four\n *\n * 0    -- string %s\n * 1..4 -- int %?.?d\n *\n**/\n\nstatic void strfmt(char *str, const char *fmt, ...)\n{\n      int ival, ilen;\n      char *sval;\n      va_list vp;\n\n      va_start(vp, fmt);\n      while (*fmt)\n      {\n            if (*fmt++ == '%')\n            {\n                  ilen = *fmt++ - '0';\n                  if (ilen == 0)                /* zero means string arg */\n                  {\n                        sval = va_arg(vp, char*);\n                        while (*sval)\n                              *str++ = *sval++;\n                  }\n                  else                          /* always leading zeros */\n                  {\n                        ival = va_arg(vp, int);\n                        while (ilen)\n                        {\n                              ival %= pow[ilen--];\n                              *str++ = (char)('0' + ival / pow[ilen]);\n                        }\n                  }\n            }\n            else  *str++ = fmt[-1];\n      }\n      *str = '\\0';\n      va_end(vp);\n}\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMD": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10F\\x00R\\x00R\\x00\\x00\\xd7\\xc4\\xd7\\xc3\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:46:00", "lines": 82, "newlines": 82, "modlines": 0, "user": "PDPCLIB"}, "text": "./ ADD NAME=COMPALL  0100-04042-04042-1043-00013-00013-00000-PDPCLIB\n@echo off\ndel *.obj pdptest.exe\nmake -f makefile.bcc\npdptest\ndel *.obj pdptest.exe\nnmake -nologo -f makefile.ibm\npdptest\ndel *.obj pdptest.exe\nmake -f makefile.emx\npdptest\ndel *.obj pdptest.exe\nwmake -u -h -f makefile.wat\npdptest\n./ ADD NAME=COMPILE  0100-04042-04042-1043-00005-00005-00000-PDPCLIB\n@echo off\nwmake -u -h -f makefile.wat\nrem nmake -f makefile.ibm\nrem dmake -B -f makefile.emx\nrem make -f makefile.bcc\n./ ADD NAME=COMPPERF 0100-04042-04042-1043-00055-00055-00000-PDPCLIB\nbcc -O2 perf2.c\ncopy perf2.exe e:\\scratch\\test2\\bcc.exe\ngcc -O perf2.c\ncopy perf2.exe e:\\scratch\\test2\\gcc.exe\nicc -O perf2.c\ncopy perf2.exe e:\\scratch\\test2\\icc.exe\nwcl386 -oneatx perf2.c\ncopy perf2.exe e:\\scratch\\test2\\wcc.exe\n\ncall pbcc perf2 -O2\ncopy perf2.exe e:\\scratch\\test2\\pbcc.exe\ncall pgcc perf2 -O\ncopy perf2.exe e:\\scratch\\test2\\pgcc.exe\ncall picc perf2 -O\ncopy perf2.exe e:\\scratch\\test2\\picc.exe\ncall pwcc -oneatx perf2.c\ncopy perf2.exe e:\\scratch\\test2\\pwcc.exe\n\nbcc -O2 perf3.c\ncopy perf3.exe e:\\scratch\\test3\\bcc.exe\ngcc -O perf3.c\ncopy perf3.exe e:\\scratch\\test3\\gcc.exe\nicc -O perf3.c\ncopy perf3.exe e:\\scratch\\test3\\icc.exe\nwcl386 -oneatx perf3.c\ncopy perf3.exe e:\\scratch\\test3\\wcc.exe\n\ncall pbcc perf3 -O2\ncopy perf3.exe e:\\scratch\\test3\\pbcc.exe\ncall pgcc perf3 -O\ncopy perf3.exe e:\\scratch\\test3\\pgcc.exe\ncall picc perf3 -O\ncopy perf3.exe e:\\scratch\\test3\\picc.exe\ncall pwcc -oneatx perf3.c\ncopy perf3.exe e:\\scratch\\test3\\pwcc.exe\n\ncall pbcc perf4 -O2\ncopy perf4.exe e:\\scratch\\test4\\pbcc.exe\ncall pgcc perf4 -O\ncopy perf4.exe e:\\scratch\\test4\\pgcc.exe\ncall picc perf4 -O\ncopy perf4.exe e:\\scratch\\test4\\picc.exe\ncall pwcc -oneatx perf4.c\ncopy perf4.exe e:\\scratch\\test4\\pwcc.exe\n\nbcc -O2 perf4.c\ncopy perf4.exe e:\\scratch\\test4\\bcc.exe\ngcc -O perf4.c\ncopy perf4.exe e:\\scratch\\test4\\gcc.exe\nicc -O perf4.c\ncopy perf4.exe e:\\scratch\\test4\\icc.exe\nwcl386 -oneatx perf4.c\ncopy perf4.exe e:\\scratch\\test4\\wcc.exe\n\n\n./ ADD NAME=MYTEST   0100-04042-04042-1043-00005-00005-00000-PDPCLIB\n/* rexx */\n\n\"pdptest\"\nx = rc\nsay \"x is \" x\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "H": {"ttr": 4868, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10F\\x03l\\x03l\\x00\\x00\\xd7\\xc4\\xd7\\xc3\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:46:00", "lines": 876, "newlines": 876, "modlines": 0, "user": "PDPCLIB"}, "text": "./ ADD NAME=ASSERT   0100-04042-04042-0950-00025-00025-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  assert.h - assert header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __ASSERT_INCLUDED\n#define __ASSERT_INCLUDED\n\nint __assert(char *x, char *y, char *z);\n\n#ifdef NDEBUG\n#define assert(ignore) ((void)0)\n#else\n#define assert(x) (x) ? ((void)0) : \\\n    __assert(#x, __FILE__, __LINE__)\n#endif\n\n#endif\n./ ADD NAME=CTYPE    0100-04042-04042-0950-00034-00034-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  ctype.h - ctype header file.                                     */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __CTYPE_INCLUDED\n#define __CTYPE_INCLUDED\n\nextern unsigned short *__isbuf;\nextern short *__tolow;\nextern short *__toup;\n\n#define isalnum(c) (__isbuf[(c)] & 0x0001U)\n#define isalpha(c) (__isbuf[(c)] & 0x0002U)\n#define iscntrl(c) (__isbuf[(c)] & 0x0004U)\n#define isdigit(c) (__isbuf[(c)] & 0x0008U)\n#define isgraph(c) (__isbuf[(c)] & 0x0010U)\n#define islower(c) (__isbuf[(c)] & 0x0020U)\n#define isprint(c) (__isbuf[(c)] & 0x0040U)\n#define ispunct(c) (__isbuf[(c)] & 0x0080U)\n#define isspace(c) (__isbuf[(c)] & 0x0100U)\n#define isupper(c) (__isbuf[(c)] & 0x0200U)\n#define isxdigit(c) (__isbuf[(c)] & 0x0400U)\n#define tolower(c) (__tolow[(c)])\n#define toupper(c) (__toup[(c)])\n\n#endif\n./ ADD NAME=ERRNO    0100-04042-04042-0950-00020-00020-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  errno.h - errno header file.                                     */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __ERRNO_INCLUDED\n#define __ERRNO_INCLUDED\n\n#define EDOM 1\n#define ERANGE 2\nextern int errno;\n\n#endif\n./ ADD NAME=FLOAT    0100-04042-04042-0950-00046-00046-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  float.h - float header file.                                     */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __FLOAT_INCLUDED\n#define __FLOAT_INCLUDED\n\n#define FLT_ROUNDS 1\n#define FLT_RADIX 2\n#define FLT_MANT_DIG 24\n#define DBL_MANT_DIG 53\n#define LDBL_MANT_DIG 53\n#define FLT_DIG 6\n#define DBL_DIG 10\n#define LDBL_DIG 10\n#define FLT_MIN_EXP -125\n#define DBL_MIN_EXP -1021\n#define LDBL_MIN_EXP -1021\n#define FLT_MIN_10_EXP -37\n#define DBL_MIN_10_EXP -37\n#define LDBL_MIN_10_EXP -37\n#define FLT_MAX_EXP +128\n#define DBL_MAX_EXP +1024\n#define LDBL_MAX_EXP +1024\n#define FLT_MAX_10_EXP +37\n#define DBL_MAX_10_EXP +37\n#define LDBL_MAX_10_EXP +37\n#define FLT_MAX 1E+37\n#define DBL_MAX 1E+37\n#define LDBL_MAX 1E+37\n#define FLT_EPSILON 1E-5\n#define DBL_EPSILON 1E-9\n#define LDBL_EPSILON 1E-9\n#define FLT_MIN 1E-37\n#define DBL_MIN 1E-37\n#define LDBL_MIN 1E-37\n\n#endif\n./ ADD NAME=LIMITS   0100-04042-04042-0950-00048-00048-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  limits.h - limits header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __LIMITS_INCLUDED\n#define __LIMITS_INCLUDED\n\n#define CHAR_BIT 8\n#define SCHAR_MIN -128\n#define SCHAR_MAX 127\n#define UCHAR_MAX 255\n#if ('\\x80' < 0)\n#define CHAR_MIN -128\n#define CHAR_MAX 127\n#else\n#define CHAR_MIN 0\n#define CHAR_MAX 255\n#endif\n#define MB_LEN_MAX 1\n#define SHRT_MIN -32768\n#define SHRT_MAX 32767\n#define USHRT_MAX 65535\n\n#if (defined(__OS2__) || defined(__32BIT__) || defined(__MVS__))\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define UINT_MAX 4294967295U\n#endif\n\n#if (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC))\n#define INT_MIN -32768\n#define INT_MAX 32767\n#define UINT_MAX 65535\n#endif\n\n#define LONG_MIN -2147483648\n#define LONG_MAX 2147483647\n#define ULONG_MAX 4294967295U\n\n#endif\n./ ADD NAME=LOCALE   0100-04042-04042-0950-00048-00048-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  locale.h - locale header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __LOCALE_INCLUDED\n#define __LOCALE_INCLUDED\n\nstruct lconv {\n    char *decimal_point;\n    char *thousands_sep;\n    char *grouping;\n    char *int_curr_symbol;\n    char *currency_symbol;\n    char *mon_decimal_point;\n    char *mon_thousands_sep;\n    char *mon_grouping;\n    char *positive_sign;\n    char *negative_sign;\n    char int_frac_digits;\n    char frac_digits;\n    char p_cs_precedes;\n    char p_sep_by_space;\n    char n_cs_precedes;\n    char n_sep_by_space;\n    char p_sign_posn;\n    char n_sign_posn;\n};\n\n#define NULL ((void *)0)\n#define LC_ALL 1\n#define LC_COLLATE 2\n#define LC_CTYPE 3\n#define LC_MONETARY 4\n#define LC_NUMERIC 5\n#define LC_TIME 6\n\nchar *setlocale(int category, const char *locale);\nstruct lconv *localeconv(void);\n\n#endif\n./ ADD NAME=MATH     0100-04042-04042-0950-00072-00072-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  math.h - math header file.                                       */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __MATH_INCLUDED\n#define __MATH_INCLUDED\n\ndouble ceil(double x);\ndouble fabs(double x);\ndouble floor(double x);\ndouble fmod(double x, double y);\n\n/* unimplemented: */\n\ndouble acos(double x);\ndouble asin(double x);\ndouble atan(double x);\ndouble atan2(double y, double x);\ndouble cos(double x);\ndouble sin(double x);\ndouble tan(double x);\ndouble cosh(double x);\ndouble sinh(double x);\ndouble tanh(double x);\ndouble exp(double x);\ndouble frexp(double value, int *exp);\ndouble ldexp(double x, int exp);\ndouble log(double x);\ndouble log10(double x);\ndouble modf(double value, double *iptr);\ndouble pow(double x, double y);\ndouble sqrt(double x);\n\n#ifdef __WATCOMC__\n#pragma intrinsic(cos, sin, tan, exp, log, log10, sqrt)\n#endif\n\n#ifdef __IBMC__\ndouble _Builtin __fabs(double x);\n#define fabs(x) (__fabs((x)))\ndouble _Builtin __fsin(double x);\n#define sin(x) (__fsin((x)))\ndouble _Builtin __fcos(double x);\n#define cos(x) (__fcos((x)))\ndouble _Builtin __fptan(double x);\n#define tan(x) (__fptan((x)))\ndouble _Builtin __fpatan(double x);\n#define atan(x) (__fpatan((x)))\ndouble _Builtin __facos(double x);\n#define acos(x) (__facos((x)))\ndouble _Builtin __fasin(double x);\n#define asin(x) (__fasin((x)))\ndouble _Builtin __fsqrt(double x);\n#define sqrt(x) (__fsqrt((x)))\n#endif\n\n#ifdef __BORLANDC__\ndouble __sin__(double x);\n#define sin(x) (__sin__((x)))\ndouble __cos__(double x);\n#define cos(x) (__cos__((x)))\n#endif\n\n#endif\n./ ADD NAME=MVSSUPA  0100-04042-04042-0950-00017-00017-00000-PDPCLIB\n#include <stddef.h>\n\n#pragma linkage(__aopen, OS)\nvoid *__aopen(const char *ddname, int mode, int *recfm,\n              int *lrecl, const char *mem);\n#pragma linkage(__aread, OS)\nint __aread(void *handle, void *buf);\n#pragma linkage(__awrite, OS)\nint __awrite(void *handle, const void *buf);\n#pragma linkage(__aclose, OS)\nvoid __aclose(void *handle);\n#pragma linkage(__getclk, OS)\nunsigned int __getclk(void *buf);\n#pragma linkage(__getm, OS)\nvoid *__getm(size_t sz);\n#pragma linkage(__freem, OS)\nvoid __freem(void *ptr);\n./ ADD NAME=SETJMP   0100-04042-04042-0950-00026-00026-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  setjmp.h - setjmp header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __SETJMP_INCLUDED\n#define __SETJMP_INCLUDED\n\ntypedef struct {\n    int eax;\n    int ebx;\n    int ecx;\n    int longj;\n} jmp_buf[1];\n\nint setjmp(jmp_buf env);\nvoid longjmp(jmp_buf env, int val);\n\n#endif\n./ ADD NAME=SIGNAL   0100-04042-04042-0950-00036-00036-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  signal.h - signal header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __SIGNAL_INCLUDED\n#define __SIGNAL_INCLUDED\n\ntypedef int sig_atomic_t;\n\nvoid __sigdfl(int sig);\nvoid __sigerr(int sig);\nvoid __sigign(int sig);\n\n#define SIG_DFL __sigdfl\n#define SIG_ERR __sigerr\n#define SIG_IGN __sigign\n\n#define SIGABRT 1\n#define SIGFPE 2\n#define SIGILL 3\n#define SIGINT 4\n#define SIGSEGV 5\n#define SIGTERM 6\n\nvoid (*signal(int sig, void (*func)(int)))(int);\nint raise(int sig);\n\n#endif\n./ ADD NAME=STDARG   0100-04042-04042-0950-00022-00022-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  stdarg.h - stdarg header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __STDARG_INCLUDED\n#define __STDARG_INCLUDED\n\ntypedef char * va_list;\n\n#define va_start(ap, parmN) ap = (char *)&parmN + 4\n#define va_arg(ap, type) *(type *)(ap += sizeof(type), ap - sizeof(type))\n#define va_end(ap) ap = 0\n\n#endif\n./ ADD NAME=STDDEF   0100-04042-04042-0950-00034-00034-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  stddef.h - assert header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __STDDEF_INCLUDED\n#define __STDDEF_INCLUDED\n\ntypedef int ptrdiff_t;\n#ifndef __SIZE_T_DEFINED\n#define __SIZE_T_DEFINED\n#if (defined(__OS2__) || defined(__32BIT__) || defined(__MVS__))\ntypedef unsigned long size_t;\n#endif\n#if (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC))\ntypedef unsigned int size_t;\n#endif\n#endif\n#ifndef __WCHAR_T_DEFINED\n#define __WCHAR_T_DEFINED\ntypedef char wchar_t;\n#endif\n\n#define NULL ((void *)0)\n#define offsetof(x, y) (size_t)&(((x *)0)->y)\n\n#endif\n./ ADD NAME=STDIO    0100-04042-04042-0950-00173-00173-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  stdio.h - stdio header file                                      */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __STDIO_INCLUDED\n#define __STDIO_INCLUDED\n\n#ifndef __SIZE_T_DEFINED\n#define __SIZE_T_DEFINED\n#if (defined(__OS2__) || defined(__32BIT__) || defined(__MVS__))\ntypedef unsigned long size_t;\n#endif\n#if (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC))\ntypedef unsigned int size_t;\n#endif\n#endif\n\n/*\n    What we have is an internal buffer, which is 8 characters\n    longer than the actually used buffer.  E.g. say BUFSIZ is\n    512 bytes, then we actually allocate 520 bytes.  The first\n    2 characters will be junk, the next 2 characters set to NUL,\n    for protection against some backward-compares.  The fourth-last\n    character is set to '\\n', to protect against overscan.  The\n    last 3 characters will be junk, to protect against memory\n    violation.  intBuffer is the internal buffer, but everyone refers\n    to fbuf, which is actually set to the &intBuffer[4].  Also,\n    szfbuf is the size of the \"visible\" buffer, not the internal\n    buffer.  The reason for the 2 junk characters at the beginning\n    is to align the buffer on a 4-byte boundary.\n*/\n\ntypedef struct\n{\n#if (defined(__OS2__) || defined(__32BIT__))\n    unsigned long hfile;  /* OS/2 file handle */\n#endif\n#if (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC))\n    int hfile; /* dos file handle */\n#endif\n#if (defined(__MVS__))\n    void *hfile;\n    int recfm;\n    int style;\n    int lrecl;\n    char ddname[9];\n    char pdsmem[9];\n#endif\n    int quickBin;  /* 1 = do DosRead NOW!!!! */\n    int quickText; /* 1 = quick text mode */\n    int textMode; /* 1 = text mode, 0 = binary mode */\n    int intFno;   /* internal file number */\n    unsigned long bufStartR; /* buffer start represents, e.g. if we\n        have read in 3 buffers, each of 512 bytes, and we are\n        currently reading from the 3rd buffer, then the first\n        character in the buffer would be 1024, so that is what is\n        put in bufStartR. */\n    char *fbuf;     /* file buffer - this is what all the routines\n                       look at. */\n    size_t szfbuf;  /* size of file buffer (the one that the routines\n                       see, and the user allocates, and what is actually\n                       read in from disk) */\n    char *upto;     /* what character is next to read from buffer */\n    char *endbuf;   /* pointer PAST last character in buffer, ie it\n                       points to the '\\n' in the internal buffer */\n    int errorInd;   /* whether an error has occurred on this file */\n    int eofInd;     /* whether EOF has been reached on this file */\n    int ungetCh;    /* character pushed back, -1 if none */\n    int bufTech;    /* buffering technique, _IOFBF etc */\n    char *intBuffer; /* internal buffer */\n    int noNl;       /* When doing gets, we don't copy NL */\n    int mode;       /* __WRITE_MODE or __READ_MODE */\n    int update;     /* Is file update (read + write)? */\n    int theirBuffer; /* Is the buffer supplied by them? */\n} FILE;\n\ntypedef unsigned long fpos_t;\n\n#define NULL ((void *)0)\n#define FILENAME_MAX 260\n#define FOPEN_MAX 256\n#define _IOFBF 1\n#define _IOLBF 2\n#define _IONBF 3\n/*#define BUFSIZ 409600*/\n/* #define BUFSIZ 8192 */\n/*#define BUFSIZ 5120*/\n#ifdef __MVS__\n/* set it to maximum possible LRECL to simplify processing */\n#define BUFSIZ 32768\n#else\n#define BUFSIZ 6144\n#endif\n/* #define BUFSIZ 10 */\n/* #define BUFSIZ 512 */\n#define EOF -1\n#define L_tmpnam FILENAME_MAX\n#define TMP_MAX 25\n#define SEEK_SET 0\n#define SEEK_CUR 1\n#define SEEK_END 2\n#define __NFILE (FOPEN_MAX - 3)\n#define __WRITE_MODE 1\n#define __READ_MODE 2\n\nextern FILE *stdin;\nextern FILE *stdout;\nextern FILE *stderr;\n\nextern FILE *__userFiles[__NFILE];\n\nint printf(const char *format, ...);\nFILE *fopen(const char *filename, const char *mode);\nint fclose(FILE *stream);\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\nint fputc(int c, FILE *stream);\nint fputs(const char *s, FILE *stream);\nint fprintf(FILE *stream, const char *format, ...);\nint vfprintf(FILE *stream, const char *format, char *arg);\nint remove(const char *filename);\nint rename(const char *old, const char *new);\nint sprintf(char *s, const char *format, ...);\nint vsprintf(char *s, const char *format, char *arg);\nchar *fgets(char *s, int n, FILE *stream);\nint ungetc(int c, FILE *stream);\nint fgetc(FILE *stream);\nint fseek(FILE *stream, long int offset, int whence);\nlong int ftell(FILE *stream);\nint fsetpos(FILE *stream, const fpos_t *pos);\nint fgetpos(FILE *stream, fpos_t *pos);\nvoid rewind(FILE *stream);\nvoid clearerr(FILE *stream);\nvoid perror(const char *s);\nint setvbuf(FILE *stream, char *buf, int mode, size_t size);\nint setbuf(FILE *stream, char *buf);\nFILE *freopen(const char *filename, const char *mode, FILE *stream);\nint fflush(FILE *stream);\nchar *tmpnam(char *s);\nFILE *tmpfile(void);\nint fscanf(FILE *stream, const char *format, ...);\nint scanf(const char *format, ...);\nint sscanf(const char *s, const char *format, ...);\nchar *gets(char *s);\nint puts(const char *s);\n\n#ifndef __POWERC\nint getchar(void);\nint putchar(int c);\nint getc(FILE *stream);\nint putc(int c, FILE *stream);\nint feof(FILE *stream);\nint ferror(FILE *stream);\n#endif\n\n#define getchar() (getc(stdin))\n#define putchar(c) (putc((c), stdout))\n#define getc(stream) (fgetc((stream)))\n#define putc(c, stream) (fputc((c), (stream)))\n#define feof(stream) ((stream)->eofInd)\n#define ferror(stream) ((stream)->errorInd)\n\n#endif\n\n\n./ ADD NAME=STDLIB   0100-04042-04042-0950-00084-00084-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  stdlib.h - stdlib header file                                    */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __STDLIB_INCLUDED\n#define __STDLIB_INCLUDED\n\n#ifndef __SIZE_T_DEFINED\n#define __SIZE_T_DEFINED\n#if (defined(__OS2__) || defined(__32BIT__) || defined(__MVS__))\ntypedef unsigned long size_t;\n#endif\n#if (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC))\ntypedef unsigned int size_t;\n#endif\n#endif\n#ifndef __WCHAR_T_DEFINED\n#define __WCHAR_T_DEFINED\ntypedef char wchar_t;\n#endif\ntypedef struct { int quot; int rem; } div_t;\ntypedef struct { long int quot; long int rem; } ldiv_t;\n\n#define NULL ((void *)0)\n#define EXIT_SUCCESS 0\n#define EXIT_FAILURE 1\n#define RAND_MAX 32767\n#define MB_CUR_MAX 1\n#define __NATEXIT 32\n\nextern void (*__userExit[__NATEXIT])(void);\n\nvoid *malloc(size_t size);\nvoid *calloc(size_t nmemb, size_t size);\nvoid *realloc(void *ptr, size_t size);\nvoid free(void *ptr);\nvoid abort(void);\nvoid exit(int status);\nvoid qsort(void *, size_t, size_t,\n                           int (*)(const void *, const void *));\nvoid srand(unsigned int seed);\nint rand(void);\ndouble atof(const char *nptr);\ndouble strtod(const char *nptr, char **endptr);\nint atoi(const char *nptr);\nlong int atol(const char *nptr);\nlong int strtol(const char *nptr, char **endptr, int base);\nunsigned long int strtoul(const char *nptr, char **endptr, int base);\nint mblen(const char *s, size_t n);\nint mbtowc(wchar_t *pwc, const char *s, size_t n);\nint wctomb(char *s, wchar_t wchar);\nsize_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);\nsize_t wcstombs(char *s, const wchar_t *pwcs, size_t n);\nint abs(int j);\ndiv_t div(int numer, int denom);\nlong int labs(long int j);\nldiv_t ldiv(long int numer, long int denom);\nint atexit(void (*func)(void));\nchar *getenv(const char *name);\nint system(const char *string);\nvoid *bsearch(const void *key, const void *base,\n              size_t nmemb, size_t size,\n              int (*compar)(const void *, const void *));\n\n#ifdef __WATCOMC__\n#pragma intrinsic (abs,labs,div,ldiv)\n#endif\n\n#ifdef __IBMC__\nint _Builtin __abs(int j);\n#define abs(j) (__abs((j)))\nlong int _Builtin __labs(long int j);\n#define labs(j) (__labs((j)))\n#endif\n\n#endif\n./ ADD NAME=STRING   0100-04042-04042-0950-00118-00118-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  string.h - string header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __STRING_INCLUDED\n#define __STRING_INCLUDED\n\n#ifndef __SIZE_T_DEFINED\n#define __SIZE_T_DEFINED\n#if (defined(__OS2__) || defined(__32BIT__) || defined(__MVS__))\ntypedef unsigned long size_t;\n#endif\n#if (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC))\ntypedef unsigned int size_t;\n#endif\n#endif\n\n#define NULL ((void *)0)\nvoid *memcpy(void *s1, const void *s2, size_t n);\nvoid *memmove(void *s1, const void *s2, size_t n);\nchar *strcpy(char *s1, const char *s2);\nchar *strncpy(char *s1, const char *s2, size_t n);\nchar *strcat(char *s1, const char *s2);\nchar *strncat(char *s1, const char *s2, size_t n);\nint memcmp(const void *s1, const void *s2, size_t n);\nint strcmp(const char *s1, const char *s2);\nint strcoll(const char *s1, const char *s2);\nint strncmp(const char *s1, const char *s2, size_t n);\nsize_t strxfrm(char *s1, const char *s2, size_t n);\nvoid *memchr(const void *s, int c, size_t n);\nchar *strchr(const char *s, int c);\nsize_t strcspn(const char *s1, const char *s2);\nchar *strpbrk(const char *s1, const char *s2);\nchar *strrchr(const char *s, int c);\nsize_t strspn(const char *s1, const char *s2);\nchar *strstr(const char *s1, const char *s2);\nchar *strtok(char *s1, const char *s2);\nvoid *memset(void *s, int c, size_t n);\nchar *strerror(int errnum);\nsize_t strlen(const char *s);\n\n#ifdef __WATCOMC__\n#ifdef __INLINE_FUNCTIONS__\n#pragma intrinsic(memchr, memcmp, memcpy, strcat, strcpy, strlen, strchr)\n#endif\n#endif\n\n#ifdef __IBMC__\nchar * _Builtin __strcat(char *s1, const char *s2);\n#define strcat(s1,s2) (__strcat((s1),(s2)))\nchar * _Builtin __strchr(const char *s, int c);\n#define strchr(s,c) (__strchr((s),(c)))\nint _Builtin __strcmp(const char *s1, const char *s2);\n#define strcmp(s1,s2) (__strcmp((s1),(s2)))\nint _Builtin __strcpy(char *s1, const char *s2);\n#define strcpy(s1,s2) (__strcpy((s1),(s2)))\nsize_t _Builtin __strlen(const char *s);\n#define strlen(s) (__strlen((s)))\nchar * _Builtin __strncat(char *s1, const char *s2, size_t n);\n#define strncat(s1,s2,n) (__strncat((s1),(s2),(n)))\nint _Builtin __strncmp(const char *s1, const char *s2, size_t n);\n#define strncmp(s1,s2,n) (__strncmp((s1),(s2),(n)))\nchar * _Builtin __strncpy(char *s1, const char *s2, size_t n);\n#define strncpy(s1,s2,n) (__strncpy((s1),(s2),(n)))\nchar * _Builtin __strrchr(const char *s, int c);\n#define strrchr(s,c) (__strrchr((s),(c)))\nvoid * _Builtin __memcpy(void *s1, const void *s2, size_t n);\n#define memcpy(a,b,c) (__memcpy((a),(b),(c)))\nvoid * _Builtin __memchr(const void *s, int c, size_t n);\n#define memchr(s,c,n) (__memchr((s),(c),(n)))\nint _Builtin __memcmp(const void *s1, const void *s2, size_t n);\n#define memcmp(s1,s2,n) (__memcmp((s1),(s2),(n)))\nvoid * _Builtin __memset(void *s, int c, size_t n);\n#define memset(s,c,n) (__memset((s),(c),(n)))\nvoid * _Builtin __memmove(void *s1, const void *s2, size_t n);\n#define memmove(s1,s2,n) (__memmove((s1),(s2),(n)))\n#endif\n\n#ifdef __BORLANDC__\n#ifdef __INLINE_FUNCTIONS__\nvoid *__memcpy__(void *s1, const void *s2, size_t n);\n#define memcpy(a,b,c) (__memcpy__((a),(b),(c)))\nvoid *__memchr__(const void *s, int c, size_t n);\n#define memchr(s,c,n) (__memchr__((s),(c),(n)))\nint __memcmp__(const void *s1, const void *s2, size_t n);\n#define memcmp(s1,s2,n) (__memcmp__((s1),(s2),(n)))\nvoid *__memset__(void *s, int c, size_t n);\n#define memset(s,c,n) (__memset__((s),(c),(n)))\nchar *__strcat__(char *s1, const char *s2);\n#define strcat(s1,s2) (__strcat__((s1),(s2)))\nchar *__strchr__(const char *s, int c);\n#define strchr(s,c) (__strchr__((s),(c)))\nint __strcmp__(const char *s1, const char *s2);\n#define strcmp(s1,s2) (__strcmp__((s1),(s2)))\nchar *__strcpy__(char *s1, const char *s2);\n#define strcpy(s1,s2) (__strcpy__((s1),(s2)))\nsize_t __strlen__(const char *s);\n#define strlen(s) (__strlen__((s)))\nchar *__strncat__(char *s1, const char *s2, size_t n);\n#define strncat(s1,s2,n) (__strncat__((s1),(s2),(n)))\nint __strncmp__(const char *s1, const char *s2, size_t n);\n#define strncmp(s1,s2,n) (__strncmp__((s1),(s2),(n)))\nchar *__strncpy__(char *s1, const char *s2, size_t n);\n#define strncpy(s1,s2,n) (__strncpy__((s1),(s2),(n)))\nchar *__strrchr__(const char *s, int c);\n#define strrchr(s,c) (__strrchr__((s),(c)))\n#endif\n#endif\n\n#endif\n./ ADD NAME=TIME     0100-04042-04042-0950-00057-00057-00000-PDPCLIB\n/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards, 3:711/934@fidonet.         */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  time.h - time header file.                                       */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __TIME_INCLUDED\n#define __TIME_INCLUDED\n\n#define CLOCKS_PER_SEC 1000\n#define NULL ((void *)0)\n\ntypedef unsigned int clock_t;\n\n#ifndef __SIZE_T_DEFINED\n#define __SIZE_T_DEFINED\n#if (defined(__OS2__) || defined(__32BIT__) || defined(__MVS__))\ntypedef unsigned long size_t;\n#endif\n#if (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC))\ntypedef unsigned int size_t;\n#endif\n#endif\n\ntypedef unsigned long time_t;\n\nstruct tm\n{\n    int tm_sec;\n    int tm_min;\n    int tm_hour;\n    int tm_mday;\n    int tm_mon;\n    int tm_year;\n    int tm_wday;\n    int tm_yday;\n    int tm_isdst;\n};\n\ntime_t time(time_t *timer);\nclock_t clock(void);\ndouble difftime(time_t time1, time_t time0);\ntime_t mktime(struct tm *timeptr);\nchar *asctime(const struct tm *timeptr);\nchar *ctime(const time_t *timer);\nstruct tm *gmtime(const time_t *timer);\nstruct tm *localtime(const time_t *timer);\nsize_t strftime(char *s, size_t maxsize,\n                const char *format, const struct tm *timeptr);\n\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IN": {"ttr": 5128, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10F\\x00\\x04\\x00\\x04\\x00\\x00\\xd7\\xc4\\xd7\\xc3\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:46:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "PDPCLIB"}, "text": "./ ADD NAME=PDPTEST  0100-04042-04042-1043-00003-00003-00000-PDPCLIB\nThis is the firZt line in the file\nThis is the second line in the same file\nThird line\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAKEFILE": {"ttr": 5130, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10F\\x01\\xd6\\x01\\xd6\\x00\\x00\\xd7\\xc4\\xd7\\xc3\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:46:00", "lines": 470, "newlines": 470, "modlines": 0, "user": "PDPCLIB"}, "text": "./ ADD NAME=BCC      0100-04042-04042-1043-00069-00069-00000-PDPCLIB\nCC=bcc\nCOPTS=-w -c -I. -u- -O2\n\npdptest.exe: startup.obj pdptest.obj stdio.obj string.obj stdlib.obj \\\n       start.obj time.obj errno.obj assert.obj signal.obj locale.obj \\\n       ctype.obj setjmp.obj math.obj fpfuncsb.obj\n  if exist borland.lib del borland.lib\n  tlib borland +startup.obj\n  tlib borland +stdio.obj\n  tlib borland +string.obj\n  tlib borland +stdlib.obj\n  tlib borland +start.obj\n  tlib borland +time.obj\n  tlib borland +errno.obj\n  tlib borland +assert.obj\n  tlib borland +signal.obj\n  tlib borland +locale.obj\n  tlib borland +ctype.obj\n  tlib borland +setjmp.obj\n  tlib borland +math.obj\n  tlib borland +fpfuncsb.obj\n  tlink pdptest,pdptest.exe,nul.map,borland.lib+e:\\bcos2\\lib\\os2.lib\n\nstartup.obj: startup.asm\n  tasm -mx -w2 startup.asm\n\nstart.obj: start.c\n  $(CC) $(COPTS) start.c\n\npdptest.obj: pdptest.c\n  $(CC) $(COPTS) pdptest.c\n\nstdio.obj: stdio.c\n  $(CC) $(COPTS) stdio.c\n\nstring.obj: string.c\n  $(CC) $(COPTS) string.c\n\nstdlib.obj: stdlib.c\n  $(CC) $(COPTS) stdlib.c\n\ntime.obj: time.c\n  $(CC) $(COPTS) time.c\n\nerrno.obj: errno.c\n  $(CC) $(COPTS) errno.c\n\nassert.obj: assert.c\n  $(CC) $(COPTS) assert.c\n\nsignal.obj: signal.c\n  $(CC) $(COPTS) signal.c\n\nlocale.obj: locale.c\n  $(CC) $(COPTS) locale.c\n\nctype.obj: ctype.c\n  $(CC) $(COPTS) ctype.c\n\nsetjmp.obj: setjmp.c\n  $(CC) $(COPTS) setjmp.c\n\nmath.obj: math.c\n  $(CC) $(COPTS) math.c\n\nfpfuncsb.obj: fpfuncsb.c\n  $(CC) $(COPTS) fpfuncsb.c\n\n\n./ ADD NAME=BL3      0100-04042-04042-1043-00058-00058-00000-PDPCLIB\nCC=bcc\nCOPTS=-w -c -I. -I\\bcos2\\include -u- -O2\n\npdptest.exe: startup.obj pdptest.obj stdio.obj string.obj stdlib.obj \\\n       start.obj time.obj errno.obj assert.obj signal.obj locale.obj \\\n       ctype.obj setjmp.obj math.obj fpfuncsb.obj\n  link386 /nologo /pm:vio startup+pdptest+stdio+string+stdlib+start\\\n       +time+errno+assert+signal+locale+ctype+setjmp+math+fpfuncsb,\\\n       pdptest.exe,nul.map,os2386.lib,nul.def\n  if exist borland.lib del borland.lib\n  tlib borland +startup.obj +stdio.obj +string.obj +stdlib.obj \\\n       +start.obj +time.obj +errno.obj +assert.obj +signal.obj +locale.obj \\\n       +ctype.obj +setjmp.obj +math.obj +fpfuncsb.obj\n\nstartup.obj: startup.asm\n  tasm -oi -mx -w2 -DLINK386_FIX startup.asm\n\nstart.obj: start.c\n  $(CC) $(COPTS) start.c\n\npdptest.obj: pdptest.c\n  $(CC) $(COPTS) pdptest.c\n\nstdio.obj: stdio.c\n  $(CC) $(COPTS) stdio.c\n\nstring.obj: string.c\n  $(CC) $(COPTS) string.c\n\nstdlib.obj: stdlib.c\n  $(CC) $(COPTS) stdlib.c\n\ntime.obj: time.c\n  $(CC) $(COPTS) time.c\n\nerrno.obj: errno.c\n  $(CC) $(COPTS) errno.c\n\nassert.obj: assert.c\n  $(CC) $(COPTS) assert.c\n\nsignal.obj: signal.c\n  $(CC) $(COPTS) signal.c\n\nlocale.obj: locale.c\n  $(CC) $(COPTS) locale.c\n\nctype.obj: ctype.c\n  $(CC) $(COPTS) ctype.c\n\nsetjmp.obj: setjmp.c\n  $(CC) $(COPTS) setjmp.c\n\nmath.obj: math.c\n  $(CC) $(COPTS) math.c\n\nfpfuncsb.obj: fpfuncsb.c\n  $(CC) $(COPTS) fpfuncsb.c\n./ ADD NAME=DOS      0100-04042-04042-1043-00018-00018-00000-PDPCLIB\nCC=tcc\nCOPTS=-O -w -c -I. -ml\n\npdptest.exe: dosstart.obj pdptest.obj stdio.obj string.obj stdlib.obj \\\n       start.obj time.obj errno.obj assert.obj signal.obj locale.obj \\\n       ctype.obj setjmp.obj math.obj dossupc.obj dossupa.obj\n  if exist borland.lib del borland.lib\n  tlib borland +dosstart.obj +stdio.obj +string.obj +stdlib.obj\n  tlib borland +start.obj +time.obj +errno.obj +assert.obj +signal.obj\n  tlib borland +locale.obj +ctype.obj +setjmp.obj +math.obj\n  tlib borland +dossupc.obj +dossupa.obj\n  tlink dosstart+pdptest,pdptest.exe,nul.map,borland.lib,\n\n.c.obj:\n  $(CC) $(COPTS) $<\n\n.asm.obj:\n  tasm -mx -w2 $<\n./ ADD NAME=EMX      0100-04042-04042-1043-00059-00059-00000-PDPCLIB\nCC=gcc\nCOPTS=-c -Zomf -I. -O -DUSE_ASSEMBLER -D__OS2__\n\npdptest.exe: startup.obj pdptest.obj stdio.obj string.obj stdlib.obj \\\n       start.obj time.obj errno.obj assert.obj signal.obj locale.obj \\\n       ctype.obj setjmp.obj math.obj stringa.obj\n  link386 /nologo /pm:vio startup+pdptest+stdio+string+stdlib+start\\\n       +time+errno+assert+signal+locale+ctype+setjmp+math+stringa,\\\n       pdptest.exe,nul.map,os2386.lib,nul.def\n  rm -f emx.lib\n  lib /nologo emx startup.obj stdio.obj string.obj stdlib.obj \\\n       start.obj time.obj errno.obj assert.obj signal.obj locale.obj \\\n       ctype.obj setjmp.obj math.obj stringa.obj,,\n\nstartup.obj: startup.asm\n  wasm -zq startup.asm\n\nstringa.obj: stringa.asm\n  wasm -zq stringa.asm\n\nstart.obj: start.c\n  $(CC) $(COPTS) start.c\n\npdptest.obj: pdptest.c\n  $(CC) $(COPTS) pdptest.c\n\nstdio.obj: stdio.c\n  $(CC) $(COPTS) stdio.c\n\nstring.obj: string.c\n  $(CC) $(COPTS) string.c\n\nstdlib.obj: stdlib.c\n  $(CC) $(COPTS) stdlib.c\n\ntime.obj: time.c\n  $(CC) $(COPTS) time.c\n\nerrno.obj: errno.c\n  $(CC) $(COPTS) errno.c\n\nassert.obj: assert.c\n  $(CC) $(COPTS) assert.c\n\nsignal.obj: signal.c\n  $(CC) $(COPTS) signal.c\n\nlocale.obj: locale.c\n  $(CC) $(COPTS) locale.c\n\nctype.obj: ctype.c\n  $(CC) $(COPTS) ctype.c\n\nsetjmp.obj: setjmp.c\n  $(CC) $(COPTS) setjmp.c\n\nmath.obj: math.c\n  $(CC) $(COPTS) math.c\n\n./ ADD NAME=IBM      0100-04042-04042-1043-00058-00058-00000-PDPCLIB\nCC=icc\nCOPTS=-c -Xc -I. -Gn -Tl- -Q -Gi -O -Oi500\n\npdptest.exe: startup.obj pdptest.obj stdio.obj string.obj stdlib.obj \\\n       start.obj time.obj errno.obj assert.obj signal.obj locale.obj \\\n       ctype.obj setjmp.obj math.obj fpfuncsc.obj\n  link386 /nologo /pm:vio startup+pdptest+stdio+string+stdlib+start\\\n       +time+errno+assert+signal+locale+ctype+setjmp+math+fpfuncsc,\\\n       pdptest.exe,nul.map,os2386.lib,nul.def\n  if exist cset.lib del cset.lib\n  lib /nologo cset startup.obj stdio.obj string.obj stdlib.obj \\\n       start.obj time.obj errno.obj assert.obj signal.obj locale.obj \\\n       ctype.obj setjmp.obj math.obj fpfuncsc.obj,,\n\nstartup.obj: startup.asm\n  wasm -zq startup.asm\n\nstart.obj: start.c\n  $(CC) $(COPTS) start.c\n\npdptest.obj: pdptest.c\n  $(CC) $(COPTS) pdptest.c\n\nstdio.obj: stdio.c\n  $(CC) $(COPTS) stdio.c\n\nstring.obj: string.c\n  $(CC) $(COPTS) string.c\n\nstdlib.obj: stdlib.c\n  $(CC) $(COPTS) stdlib.c\n\ntime.obj: time.c\n  $(CC) $(COPTS) time.c\n\nerrno.obj: errno.c\n  $(CC) $(COPTS) errno.c\n\nassert.obj: assert.c\n  $(CC) $(COPTS) assert.c\n\nsignal.obj: signal.c\n  $(CC) $(COPTS) signal.c\n\nlocale.obj: locale.c\n  $(CC) $(COPTS) locale.c\n\nctype.obj: ctype.c\n  $(CC) $(COPTS) ctype.c\n\nsetjmp.obj: setjmp.c\n  $(CC) $(COPTS) setjmp.c\n\nmath.obj: math.c\n  $(CC) $(COPTS) math.c\n\nfpfuncsc.obj: fpfuncsc.c\n  $(CC) $(COPTS) fpfuncsc.c\n./ ADD NAME=PDS      0100-04042-04042-1043-00027-00027-00000-PDPCLIB\nCC=gcc\nCOPTS=-c -s -O -I. -I..\\src -D__PDOS__\n\npdptest.exe: pdosst32.o pdptest.o stdio.o string.o stdlib.o \\\n       start.o time.o errno.o assert.o signal.o locale.o \\\n       ctype.o setjmp.o math.o pos.o support.o pdossupc.o\n  if exist pdos.a del pdos.a\n  ar r pdos.a pdosst32.o stdio.o string.o stdlib.o\n  ar r pdos.a start.o time.o errno.o assert.o signal.o\n  ar r pdos.a locale.o ctype.o setjmp.o math.o\n  ar r pdos.a pos.o support.o pdossupc.o\n  ld -o pdptest pdosst32.o pdptest.o pdos.a\n  if exist pdptest.exe del pdptest.exe\n  ren pdptest pdptest.exe\n\npos.o: ..\\src\\pos.c\n  $(CC) $(COPTS) ..\\src\\pos.c\n\nsupport.o: ..\\src\\support.s\n  $(CC) $(COPTS) ..\\src\\support.s\n\n.c.o:\n  $(CC) $(COPTS) $<\n\n.s.o:\n  $(CC) $(COPTS) $<\n\n./ ADD NAME=PWC      0100-04042-04042-1043-00018-00018-00000-PDPCLIB\n# Makefile for Power C (doesn't work though)\n\nCC=pc\nCOPTS=-w -I. -ml -D__MSDOS__\n\npdptest.exe: dosstart.mix stdio.mix string.mix stdlib.mix \\\n       start.mix time.mix errno.mix assert.mix signal.mix locale.mix \\\n       ctype.mix setjmp.mix math.mix fpfuncsb.mix\n  $(CC) $(COPTS) pdptest.c\n  pcl pdptest,powerc\n\ndosstart.mix: dosstart.asm\n  tasm -mx -w2 dosstart.asm\n#  mix dosstart.obj dosstart.mix\n\n.c.mix:\n  $(CC) $(COPTS) $<\n  merge powerc $*\n./ ADD NAME=WAT      0100-04042-04042-1043-00020-00020-00000-PDPCLIB\nCC=wcl386\nCOPTS=-wx -c -I. -y -fpi87 -s -zq -3s -zm -zl -oneatx\n\npdptest.exe: startup.obj pdptest.obj stdio.obj string.obj stdlib.obj \\\n       start.obj time.obj errno.obj assert.obj signal.obj locale.obj \\\n       ctype.obj setjmp.obj math.obj fpfuncsw.obj\n#Debug All\n  if exist watcom.lib del watcom.lib\n  wlib -q watcom startup.obj stdio.obj string.obj stdlib.obj \\\n       start.obj time.obj errno.obj assert.obj signal.obj locale.obj \\\n       ctype.obj setjmp.obj math.obj fpfuncsw.obj\n  wlink File pdptest.obj \\\n        Name pdptest.exe \\\n        Library watcom.lib Library os2386.lib\n\nstartup.obj: startup.asm\n  wasm -zq startup.asm\n\n.c.obj:\n  $(CC) $(COPTS) $<\n./ ADD NAME=WCD      0100-04042-04042-1043-00073-00073-00000-PDPCLIB\nCC=wcl\nCOPTS=-w -c -I. -ml -zl -D__MSDOS__ -fpi87 -s -d2 -zdp -zu\n\npdptest.exe: dosstart.obj pdptest.obj stdio.obj string.obj stdlib.obj \\\n       start.obj time.obj errno.obj assert.obj signal.obj locale.obj \\\n       ctype.obj setjmp.obj math.obj fpfuncsb.obj\n#  wlink dosstart+pdptest+stdio+string+stdlib+start+time+errno\\\n#        +assert+signal+locale+ctype+setjmp+math+fpfuncsb,\\\n#        pdptest.exe,nul.map,,\n  if exist watcom.lib del watcom.lib\n  wlib -b watcom +dosstart.obj\n  wlib -b watcom +stdio.obj\n  wlib -b watcom +string.obj\n  wlib -b watcom +stdlib.obj\n  wlib -b watcom +start.obj\n  wlib -b watcom +time.obj\n  wlib -b watcom +errno.obj\n  wlib -b watcom +assert.obj\n  wlib -b watcom +signal.obj\n  wlib -b watcom +locale.obj\n  wlib -b watcom +ctype.obj\n  wlib -b watcom +setjmp.obj\n  wlib -b watcom +math.obj\n  wlib -b watcom +fpfuncsb.obj\n  wlink File pdptest.obj Name pdptest.exe Library watcom.lib\n\ndosstart.obj: dosstart.asm\n  wasm -DWATCOM dosstart.asm\n\nstart.obj: start.c\n  $(CC) $(COPTS) start.c\n\npdptest.obj: pdptest.c\n  $(CC) $(COPTS) pdptest.c\n\nstdio.obj: stdio.c\n  $(CC) $(COPTS) stdio.c\n\nstring.obj: string.c\n  $(CC) $(COPTS) string.c\n\nstdlib.obj: stdlib.c\n  $(CC) $(COPTS) stdlib.c\n\ntime.obj: time.c\n  $(CC) $(COPTS) time.c\n\nerrno.obj: errno.c\n  $(CC) $(COPTS) errno.c\n\nassert.obj: assert.c\n  $(CC) $(COPTS) assert.c\n\nsignal.obj: signal.c\n  $(CC) $(COPTS) signal.c\n\nlocale.obj: locale.c\n  $(CC) $(COPTS) locale.c\n\nctype.obj: ctype.c\n  $(CC) $(COPTS) ctype.c\n\nsetjmp.obj: setjmp.c\n  $(CC) $(COPTS) setjmp.c\n\nmath.obj: math.c\n  $(CC) $(COPTS) math.c\n\nfpfuncsb.obj: fpfuncsb.c\n  $(CC) $(COPTS) fpfuncsb.c\n\n\n\n./ ADD NAME=WL3      0100-04042-04042-1043-00060-00060-00000-PDPCLIB\nCC=wcl386\nCOPTS=-wx -c -I. -y -fpi87 -s -zq -3s -zm -d2\n\npdptest.exe: startup.obj pdptest.obj stdio.obj string.obj stdlib.obj \\\n       start.obj time.obj errno.obj assert.obj signal.obj locale.obj \\\n       ctype.obj setjmp.obj math.obj fpfuncsw.obj\n  link386 /nologo /pm:vio startup+pdptest+stdio+string+stdlib+start\\\n       +time+errno+assert+signal+locale+ctype+setjmp+math+fpfuncsw,\\\n       pdptest.exe,nul.map,os2386.lib,nul.def\n  if exist watcom.lib del watcom.lib\n  wlib -q watcom startup.obj stdio.obj string.obj stdlib.obj \\\n       start.obj time.obj errno.obj assert.obj signal.obj locale.obj \\\n       ctype.obj setjmp.obj math.obj fpfuncsw.obj\n\nstartup.obj: startup.asm\n  wasm -zq startup.asm\n\nstart.obj: start.c\n  $(CC) $(COPTS) start.c\n\npdptest.obj: pdptest.c\n  $(CC) $(COPTS) pdptest.c\n\nstdio.obj: stdio.c\n  $(CC) $(COPTS) stdio.c\n\nstring.obj: string.c\n  $(CC) $(COPTS) string.c\n\nstdlib.obj: stdlib.c\n  $(CC) $(COPTS) stdlib.c\n\ntime.obj: time.c\n  $(CC) $(COPTS) time.c\n\nerrno.obj: errno.c\n  $(CC) $(COPTS) errno.c\n\nassert.obj: assert.c\n  $(CC) $(COPTS) assert.c\n\nsignal.obj: signal.c\n  $(CC) $(COPTS) signal.c\n\nlocale.obj: locale.c\n  $(CC) $(COPTS) locale.c\n\nctype.obj: ctype.c\n  $(CC) $(COPTS) ctype.c\n\nsetjmp.obj: setjmp.c\n  $(CC) $(COPTS) setjmp.c\n\nmath.obj: math.c\n  $(CC) $(COPTS) math.c\n\nfpfuncsw.obj: fpfuncsw.c\n  $(CC) $(COPTS) fpfuncsw.c\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MVS": {"ttr": 5382, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10F\\x00W\\x00W\\x00\\x00\\xd7\\xc4\\xd7\\xc3\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:46:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "PDPCLIB"}, "text": "./ ADD NAME=COMPILE  0100-04042-04042-1043-00086-00086-00000-PDPCLIB\n/* rexx */\n\ncall init\ncall acomp mvsstart\ncall acomp mvssupa\ncall ccomp start\ncall ccomp stdio\ncall ccomp string\ncall ccomp stdlib\ncall ccomp time\ncall ccomp errno\ncall ccomp assert\ncall ccomp signal\ncall ccomp locale\ncall ccomp ctype\ncall ccomp setjmp\ncall ccomp math\ncall ccomp pdptest\ncall clink mvsstart\ncall term\nexit\n\ninit: procedure\n  \"delete sysprint\"\n  \"delete syscprt\"\n  \"delete syscerr\"\n  \"alloc f(sysprint) da(sysprint) mod reus space(1,1) cyl\",\n      \"dsorg(ps) cat\"\n  \"alloc f(syscprt) da(syscprt) mod reus space(1,1) cyl\",\n      \"dsorg(ps) cat\"\nreturn\n\nacomp: procedure;arg ?file\n  say \"acomp\" ?file\n  \"alloc f(syslib) da('sys1.maclib') shr reuse\"\n  \"alloc f(syslin) new space(1,1) track reuse delete\"\n  \"alloc f(sysin) da(pdpclib.c(\"?file\")) shr reuse\"\n  \"alloc f(sysut1) da(sysut1) new space(1,1) track reuse delete\"\n  \"call 'sys1.linklib(iev90)' 'list,noxref,object,nodeck,batch'\"\n  say \"rc from asm is\" rc\n  if (rc = 0) then do\n      \"alloc f(syslmod) da(pdpclib.ncalib(\"?file\")) shr reuse\"\n      \"alloc f(sysut1) new space(1,1) track reuse delete\"\n      \"call 'sys1.linklib(iewl)' 'ncal,let,rent,reus'\"\n      say \"rc from link is\" rc\n  end\n  \"free f(syslin)\"\nreturn\n\nccomp: procedure;arg ?file\n  say \"ccomp\" ?file\n  \"alloc f(sysmsgs) da('sys1.c.sedcmsgs(edcmsge)') shr reuse\"\n  \"alloc f(syslib) da(pdpclib.h) shr reuse\"\n  \"alloc f(syslin) new space(1,1) track reuse delete\"\n  \"alloc f(sysin) da(pdpclib.c(\"?file\")) shr reuse\"\n  \"alloc f(sysut7) new space(1,1) track reuse delete\"\n  \"alloc f(sysut8) new space(1,1) track reuse delete\"\n  \"call 'sys1.c.sedccomp(edccomp)' \",\n      \"'>>syscerr nomar,noseq,define(__MVS__)' asis\"\n  say \"rc from c is\" rc\n  if (rc = 0) then do\n      \"alloc f(syslmod) da(pdpclib.ncalib(\"?file\")) shr reuse\"\n      \"alloc f(sysut1) new space(1,1) track reuse delete\"\n      \"call 'sys1.linklib(iewl)' 'ncal,let,rent,reus'\"\n      say \"rc from link is\" rc\n  end\n  \"free f(syslin)\"\nreturn\n\nclink: procedure;arg ?file\n  say \"clink\" ?file\n  \"alloc f(syslin) da(pdpclib.ncalib(\"?file\") pdpclib.c(mvsopts)) shr\"\n  \"alloc f(syslmod) da(pdpclib.linklib(\"?file\")) shr reuse\"\n  \"alloc f(sysut1) new space(1,1) track reuse delete\"\n  \"alloc f(syslib) da(pdpclib.ncalib) shr reuse\"\n  \"call 'sys1.linklib(iewl)' 'let,rent,reus'\"\n  \"free f(syslin)\"\n  \"free f(syslmod)\"\n  \"free f(syslib)\"\n  say \"rc from link is\" rc\nreturn\n\nterm: procedure\n  \"alloc f(sysprint) da(*) shr reus\"\n  \"alloc f(sysin) da(*) shr reus\"\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSOPTS": {"ttr": 5385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10F\\x00\\x11\\x00\\x11\\x00\\x00\\xd7\\xc4\\xd7\\xc3\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:46:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "PDPCLIB"}, "text": " INCLUDE SYSLIB(MVSSTART)\n INCLUDE SYSLIB(START)\n INCLUDE SYSLIB(MVSSUPA)\n INCLUDE SYSLIB(PDPTEST)\n INCLUDE SYSLIB(STDIO)\n INCLUDE SYSLIB(STDLIB)\n INCLUDE SYSLIB(CTYPE)\n INCLUDE SYSLIB(STRING)\n INCLUDE SYSLIB(TIME)\n INCLUDE SYSLIB(ERRNO)\n INCLUDE SYSLIB(ASSERT)\n INCLUDE SYSLIB(LOCALE)\n INCLUDE SYSLIB(MATH)\n INCLUDE SYSLIB(SETJMP)\n INCLUDE SYSLIB(SIGNAL)\n ENTRY @@MVSTRT\n NAME PDPTEST(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MVSZIP": {"ttr": 5387, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10F\\x00\\x06\\x00\\x06\\x00\\x00\\xd7\\xc4\\xd7\\xc3\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:46:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "PDPCLIB"}, "text": "rm -f pdpclib.czip\nrm -f pdpclib.hzip\nzip -0 pdpclib.czip *.c compile.mvs *.asm mvsopts\nzip -0 pdpclib.hzip *.h\ncp pdpclib.czip /edrive/scratch\ncp pdpclib.hzip /edrive/scratch\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDSLOAD": {"ttr": 5389, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x04/\\x01\\x04\\x04/\\x11\\x04\\x00e\\x00e\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T11:04:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "TXT": {"ttr": 5392, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x04/\\x01\\x04\\x04/\\x10F\\x01\\xc8\\x01\\xc8\\x00\\x00\\xd7\\xc4\\xd7\\xc3\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-11T00:00:00", "modifydate": "2004-02-11T10:46:00", "lines": 456, "newlines": 456, "modlines": 0, "user": "PDPCLIB"}, "text": "./ ADD NAME=MVS      0100-04042-04042-1043-00079-00079-00000-PDPCLIB\nDesign of MVS i/o routines\n\nin/out function rec-type mode   method\nin     fread    fixed    bin    loop reading, remember remainder\nin     fread    fixed    text   loop reading + truncing, remember rem\nin     fread    var      bin    loop reading (+ len), remember remainder\nin     fread    var      text   loop reading (+ len), remember remainder\nin     fgets    fixed    bin    read, scan, remember remainder\nin     fgets    fixed    text   read, trunc, remember remainder\nin     fgets    var      bin    read, scan, rr\nin     fgets    var      text   read, rr\nin     fgetc    fixed    bin    read, rr\nin     fgetc    fixed    text   read, trunc, rr\nin     fgetc    var      bin    read, rr\nin     fgetc    var      text   read, rr\n\nout    fwrite   fixed    bin    loop doing put, rr\nout    fwrite   fixed    text   search newline, copy + pad, put, rr\nout    fwrite   var      bin    if nelem != 1 copy to max lrecl\nout    fwrite   var      text   loop search nl, put, rr\nout    fputs    fixed    bin    loop doing put, rr\nout    fputs    fixed    text   search newline, copy + pad, put, rr\nout    fputs    var      bin    put\nout    fputs    var      text   search newline, put, copy rem\nout    fputc    fixed    bin    copy to rr until rr == lrecl\nout    fputc    fixed    text   copy to rr until newline, then pad\nout    fputc    var      bin    copy to rr until rr == lrecl\nout    fputc    var      text   copy to rr until newline\n\noptimize for fread on binary files (read matching record length),\nespecially fixed block files, and fgets on text files, especially\nvariable blocked files.\n\nbinary, variable block files are not a file type supported by this\nlibrary as part of the conforming implementation.  Instead, they\nare considered to be record-oriented processing, similar to unix\nsystems reading data from a pipe, where you can read less bytes\nthan requested, without reaching EOF.  ISO 7.9.8.1 doesn't give you\nthe flexibility of calling either of these things conforming.\nBasically, the C standard doesn't have a concept of operating\nsystem maintained length binary records, you have to do that\nyourself, e.g. by writing out the lengths yourself.  You can do\nthis in a fixed block dataset on MVS, and if you're concerned\nabout null-padding at the end of your data, use a lrecl of 1\n(and suffer the consequences!).  You could argue that this\nnon-conformance should only be initiated if fopen has a parameter\nincluding \",type=record\" or whatever.  Another option would\nbe to make VB binary records include the record size as part of\nthe stream.  Hmmm, sounds like that's the go actually.\n\nfread: if quickbin, if read elem size == lrecl, doit\nfgets: if variable record + no remainder\n       if buffer > record size, copy + add newline\n\nchar *fgets(char *buf, size_t szbuf, FILE *stream)\n{\n    char *dptr;\n    size_t len;\n\n    if (stream->quickText)\n    {\n        if (szbuf > (stream->lrecl + 1))\n        {\n            __aread(&dptr, &len, stream->hfile);\n            memcpy(buf, dptr, len);\n            memcpy(buf + len, \"\\n\", 2);\n        }\n    }\n    return (buf);\n}\n\nchar *fputs(char *buf, FILE *stream)\n{\n    char *p;\n\n    p = strchr(buf, '\\n');\n    __awrite(buf, p - buf, stream->hfile);\n    return (buf);\n}\n./ ADD NAME=PDPCLIB  0100-04042-04042-1043-00235-00235-00000-PDPCLIB\n            Public Domain C runtime library\n            -------------------------------\n\nVersion : 0.73\nReleased: 1998-04-07\n\nWritten by Paul Edwards.\nReleased to the public domain.\nYou may use this entire package for any purpose whatsoever without\nrestriction.\n\n\n\nINTRODUCTION\n------------\n\nThis project is to create a public domain runtime library which\nconforms to ISO/IEC 9899:1990.  It is expected to be highly OS-specific,\nbut hopefully not too compiler-specific.  It is the job of C library\ndevelopers to make unportable but fast code, not that of the application\ndevelopers.  Anyone wishing to contribute to this project, please contact\nPaul Edwards at avon@matra.com.au.\n\n\nMAIN DESIGN GOALS\n-----------------\n\n1. Application developers should not have to resort to DosOpen, open et al\n   in order to get better performance for binary files.\n\n2. Application developers should not have to resort to using binary mode to\n   get better performance for fgets in text mode.\n\n\nCURRENT STATUS\n--------------\n\nA substantial, but still incomplete version under\n\nOS/2 for:\nEMX 0.9b\nWatcom C++ 10.0b\nIBM CSET++ 2.0\nBorland C++ 1.5\n\nDOS for:\nBorland C++ 3.1\nWatcom C++ 10.0b\n\nMVS for:\nIBM C/370 v2r1m0\n\nPDOS for:\nEMX 0.9b\n\n\nWHO WANTS IT?\n-------------\n\nIt is expected that this archive will interest the following groups of\npeople:\n\n1. People who have a commercial compiler, such as CSET, but would like\nto have the source code to the C runtime library, so that they can\nhave control over it.\n\n2. People who have a commercial compiler, such as Borland, where\nalthough they have the runtime source, Borland have some restrictions\non the use of their object code, saying that the resultant executable\nmust have either their copyright notice on it, or yours, or some such\nrubbish.\n\n3. People who have EMX 0.9b, but would like to be able to modify the\nruntime library code without being bound by any of EMX's licensing\nrestrictions on doing that.\n\n4. People who are interested in the internal workings of a runtime\nlibrary, and would like unrestricted use of any useful code they\nmay find whilst investigating that.\n\n5. Someone who wants to write their own commercial C compiler and\nlibrary, and wants something to use as a base.  This at least gives\nyou the library, there are no public domain C compilers available\nto the best of my knowledge, on any platform.\n\n6. People who have ISO text-processing programs that want a significant\nspeed improvement.\n\n\nUSAGE\n-----\n\nThere are makefiles for all the different compilers supported.  Choose\nthe one you want, and compile it, creating a library if you want, and\nthen compiling your programs in the same way that the \"pdptest\" program\nis compiled.\n\n\n\nPERFORMANCE\n-----------\n\nI have done performance testing (of version 0.07 of PDPCLIB) of the\nstated objectives, using perf*.c as the testing tool, and got the\nfollowing results (on OS/2):\n\n                fgets on text files\n                -------------------\n\nbcc - 12.98 12.98 13.10\ngcc - 12.59 12.51 12.45\nicc - 7.84 7.72 7.76\nwcc - 23.38 23.36 23.34\npbcc - 4.87 4.84 4.85\npgcc - 4.42 4.52 4.50\npicc - 4.87 4.96 4.85\npwcc - 4.87 4.85 4.87\n\nsummary - cset has the best library, watcom the worst.  pdpclib\ncreams the lot.  gcc is the best compiler.\n\n\n                large freads on binary files\n                ----------------------------\n\nbcc - 2.10 2.01 1.98\ngcc - 2.71 2.70 2.64\nicc - 3.87 3.88 3.93\nwcc - 2.18 2.18 2.18\npbcc - 1.83 1.85 1.87\npgcc - 1.89 1.83 1.87\npicc - 1.87 1.84 1.85\npwcc - 1.85 1.83 1.86\n\nsummary - Borland has the best library, cset has the worst.\npdpclib creams the lot.  The compilers are equal.\n\n\n                small freads on binary files\n                ----------------------------\n\nbcc - 8.13 8.27 8.42\ngcc - 3.98 3.92 3.91\nicc - 4.54 4.64 4.68\nwcc - 3.89 3.95 3.93\npbcc - 3.24 3.22 3.19\npgcc - 3.41 3.43 3.41\npicc - 3.24 3.24 3.21\npwcc - 3.21 3.20 3.21\n\nsummary - Borland has the worst library, gcc has the best. pdpclib,\nas usual, beats the lot.  The compilers are basically equal,\nexcept that gcc is slightly worse, as it doesn't generate an\ninline memcpy() for the situation I am using it in.  The main\nreason for gcc having the best library is that it has a default\nbuffer size of 5120 compared to the others at 4096.  Note - in\nother tests I did, gcc was coming out ahead of wcc, by about 5%,\nso I don't know why this particular set of tests had them level.\n\n\nInformation:\nI used a 486DX33 with a RAM disk in order to perform these tests,\nin an effort to concentrate the stats on the library itself rather\nthan the physical hard disk.\nbcc = Borland C++ 1.5\ngcc = EMX 0.9a\nicc = CSET++/2 2.0\nwcc = Watcom 10.0b\np* = PDPCLIB compiled with one of the above compilers.\n\n\nKNOWN LIMITATIONS\n-----------------\n\nNot all printf and scanf formats are supported.\nNo maths library.\nNo floating point support.\nMinimal testing.\nDOS version doesn't do full long arithmetic.\n\n\nHISTORY\n-------\n\n0.01  A lot of stuff has been implemented, and a lot of stuff has\n      not.  However, there has been sufficient amount of work done\n      to make it at least interesting reading.\n\n0.02  Further down the track, but not enough to go bananas about.\n      Main work was done in fopen(), which is far more robust now.\n\n0.03  Got it working on Watcom, CSET + GNU.\n\n0.04  Miscellaneous additions\n\n0.05  There is a function for every single function except those in\n      the math library, but there are still holes in the system,\n      especially with the File I/O.  But now I have all of the\n      fundamental design in place.\n\n0.06  Much more robust file i/o.\n\n0.07  Many bug fixes and enhancements.\n\n0.50  DOS support, and various bug fixes.\n\n0.51  General tidy up.\n\n0.52  Bug fixes for problems found whilst doing PDOS work.\n\n0.60  Added MVS support, since I suddenly had an MVS machine available\n      and had always wondered how on earth C was able to be implemented\n      on that environment.  Now I know some of the answers.\n\n0.61  Implemented a stub function required for some situations under\n      MSDOS.\n\n0.70  Added PDOS support.\n\n0.71  Completed PDOS and fixed DOS bug.\n\n0.73  Revamped interface to PDOS.\n\n\nCREDITS\n-------\n\nXiayi Edwards, my wife, for putting up with me in the many many\n  man-days it took me to write this, when I should have been doing\n  family-related things.\nRay Gardner for making his date routines public domain, plus\n  the qsort routine.\nJim Nutt and Rob Duff for releasing strftime to the public domain.\nRowan Crowe for some mods to memcpy.\nMatthew Parker for getting the program name under MSDOS.\n./ ADD NAME=PDPGOAL  0100-04042-04042-1043-00070-00070-00000-PDPCLIB\n          GOALS OF THE PUBLIC DOMAIN PROJECT\n          ----------------------------------\n\nVersion:  1.3\nDate:     2003-10-29\nAuthor:   Paul Edwards\nInternet: kerravon@w3.to\nStatus:   This document is released to the public domain\n\n\nThe Public Domain Project's philosophy is basically to put as much\nbase material into the public domain so that commercial developers,\nor other PD developers, can build upon it, rather than having to\nreinvent the wheel.  Unless something is public domain, it essentially\nhasn't been invented yet, as far as not needing to reinvent it is\nconcerned.  It's like inventing the cure for cancer and keeping it a\nsecret.  You may as well not have bothered.\n\nThe commercial software which you end up using (which most people use,\nif only for the support) will always be sold at a price designed to\nrecoup costs.  The only way you can reduce the price of commercial\nsoftware is to reduce the costs they have.  One way to do this is to\ngive them quality public domain code on which to use as a basis for\nfurther development.  Normal market forces will guarantee that the\ncost saving goes through to the customer.  It's the basis of\ncapitalism.  Feel free to start your own business and make enormous\nprofits if you disagree.\n\nWhy not use GPL (aka the Gnu Virus License)?  Well, there are three\nbig problems with it.  The first is that if you are a commercial\ndeveloper, and have some spare time to contribute to a freeware\nproduct, after spending 10 hours wading through someone else's code,\ngetting familiar with it, and improving it or bug fixing it, all the\ntime you spent is wasted, as far as being able to reuse any routines\nyou found in a commercial product is concerned.\n\nThe second is that encourages others to join the dog-in-the-manger\nbrigade.  Someone who ordinarily would be happy to contribute something\nto the public domain, once and for all, now instead goes and spends their\neffort on a GPL product, meaning the world still doesn't get the code\nfreely available for ALL use (ie in public domain projects AND commercial\nprojects, not JUST other GPL projects).\n\nThe third is that it is actually technology-inhibitive.  E.g. let's\nsay there's a GPL wordprocessor, but it doesn't support italics.\nQuite a lot of people want italics, but no-one to date has been\nwilling to do that work for free.  Let's say a portion of the market\nwants italics.  But no one individual can afford to pay the cost of\ndevelopment by themselves.  Normally this is where a company would\njump in, do the work, and then sell the new version to the market,\nmeaning that each individual only has to pay a fraction of the\ndevelopment cost.  But the problem is that the company CAN'T just\nmake those changes and sell them, because it can't make those\nchanges proprietary, as it needs to do in order to sell them.  So\ninstead, the commercial operation needs to develop the entire\nequivalent of the GPL wordprocessor, and THEN add italics.  But it\nis too expensive for the company to do that, so the technology is\nsimply never developed!\n\nGPL code will eventually become as useful as public domain code - 50\nyears after the death of the original author, when it becomes public\ndomain!  That's a long time to have to wait.  Until then, unless your\nlawyer informs you that the 2756 license agreement conditions don't\naffect you, the GPL work is only useful as reference material.\n\nThe default for any software written is for it to be copyright by the\nauthor.  Please include an explicit \"Released to the public domain\" if\nyou wish to make your code public domain.  If you wish to contribute\nsome public domain code, please contact Paul Edwards at the address\nabove.\n./ ADD NAME=PROGRESS 0100-04042-04042-1043-00052-00052-00000-PDPCLIB\nThis file describes the progress of the project in terms of\nnumber of functions implemented/roughly implemented.  Where\nthere are no functions, a dummy one is created!  This\narchive may be FREQed from 3:711/934@fidonet with name\nPDPCLIB.*.\n\n\nassert *\n       *\n\nctype  *************\n       *************\n\nerrno  *\n       *\n\nfloat  *\n       *\n\nlimits *\n       *\n\nlocale **\n       **\n\nmath   **********************\n       ****\n\nsetjmp *\n       *\n\nsignal **\n       **\n\nstdarg *\n       *\n\nstddef *\n       *\n\nstdio  *****************************************\n       *****************************************\n\nstdlib ****************************\n       ****************************\n\nstring **********************\n       **********************\n\ntime   *********\n       *********\n\n./ ADD NAME=README   0100-04042-04042-1043-00015-00015-00000-PDPCLIB\nPublic Domain C Library\n-----------------------\n\nFiles included:\n\npdpclib.txt  - documentation for this archive\npdpgoal.txt  - philosophy of the Public Domain Project\nprogress.txt - a rough idea of progress to date\n*.c          - source code\n*.asm        - source code\n*.h          - header files\nmakefile.*   - various makefiles\ncompile.cmd  - command to execute makefiles\npdptest.*    - demo program\n*.lib        - lib files for various compilers\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT663/FILE663.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT663", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}