{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011349000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 14, "INMDSNAM": "CBT.V500.FILE158.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE158.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x08\\x0e'", "DS1TRBAL": "b'eV'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\x17\\x00\\n\\x01\\x18\\x00\\x03\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x17\\x01\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T17:01:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SBGCSC"}, "text": "   This file was submitted to the SHARE diskettes by Robert Iappini.\n   This file was converted from having some members with sequence\n    numbers in columns 1-8 to those members having sequence numbers\n    in columns 73-80 (by Sam Golob).  That's so the members can be\n    properly interpreted in a FB-80 environment by REXX.\n\n   These EXECs originally ran in a VB-255 environment.\n\n   If you have any questions or problems, please contact:\n\n       Robert Iappini\n       Texaco Inc.\n       6464 Savoy Drive\n       Houston, TX  77036-3318\n       (713) 975-4212   phone\n       (713) 975-4744   fax\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CENTER": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15H\\x006\\x006\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:48:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "RIAP-FB"}, "text": "/* Center **************************************************** Rexx */\n/*   Revised By: IAPPINI,R. (from Share I184)                       */\n/*   When: 07/08/93                                                 */\n/*   What: Center, an Edit macro, CENTERs a specified range of text */\n/*         within a text dataset.                                   */\n/********************************************************************/\nAddress \"TSO\"\nTrace \"OFF\"\nAddress \"ISREDIT\"\n\"MACRO (HELP) NOPROCESS\"\nAddress \"ISPEXEC\"\n\"CONTROL ERRORS RETURN\"\nAddress \"ISREDIT\"\n/* Process line commands, check if C was specfied */\n\"PROCESS RANGE C\"\nlcc = rc\n\"(rch) = Range_cmd\"\nIf lcc > 0 | rch \u00ac= \"C\" Then Do\n   If lcc = 16 Then zedsmsg = \"Conflicting line commands\"\n   Else zedsmsg = \"No range specified\"\n   zedlmsg = \"You must specify a range of lines\",\n             \"to be centered; Use 'Cn' or 'CC'\"\n   Address \"ISPEXEC\"\n   \"SETMSG MSG(ISRZ001)\"\n   Exit 12\n   End;\n/* Centering program logic       */\nAddress \"ISREDIT\"\n\"(fr) = Linenum .zfrange\"\n\"(lr) = linenum .zlrange\"\n\"(lb,rb) = Bounds\"\n/* ***********************************************************\n=  any character                   .  invalid characters\n@  alphabetic characters           -  non-numeric characters\n#  numeric characters              <  lower case alphabetics\n$  special characters              >  upper case alphabetics\n\u00ac  non-blank characters\n   *********************************************************** */\nDo i = fr By 1 To lr\n   \"Label \"i \"= .LJ\"\n   \"SEEK P'\u00ac' .lj .lj\" lb rb \"FIRST\"\n   \"(lline,lcol) = Cursor\"\n   \"SEEK P'\u00ac' .lj .lj\" lb rb \"LAST\"\n   \"(rline,rcol) = Cursor\"\n   midpt = (rb-lb)%2+lb\n   left = midpt-lcol\n   right = rcol - midpt\n   count = (left-right+1)%2\n   If count > 0 Then \"SHIFT ) \"i count\n   Else              \"SHIFT ( \"i Abs(count)\n   If i = fr Then \"Label \"i\" = .LJX\"\n   End i;\n\"SEEK P'=' .ljx .ljx FIRST\"\nExit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMDTBDI": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x16\\x06\\x00B\\x00B\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xd5\\xc3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T16:06:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "RIAP-NC"}, "text": ")ATTR\n\u00ac AREA(DYNAMIC)\n  @ TYPE(INPUT) INTENS(LOW) CAPS(OFF) COLOR(BLUE)\n  # TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) COLOR(RED)\n  ` TYPE(INPUT) INTENS(LOW) CAPS(ON) PAD('''')\n  ~ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) HILITE(REVERSE)\n  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON)\n  \u00a2 TYPE(OUTPUT) INTENS(HIGH) CAPS(ON)\n  + TYPE(TEXT) INTENS(LOW) CAPS(OFF) SKIP(ON)\n  ? TYPE(&IO) INTENS(LOW) CAPS(ON) HILITE(&IOHILITE)\n  ! TYPE(text) INTENS(LOW) CAPS(off) color(yellow)\n)BODY   EXPAND(\\\\)\n!&appldesc\n%Command ===>_ZCMD        \\ \\ %Scroll ===>_AMT %\n+\n\u00acselect,shad1  \\ \\\u00ac\n+\n%&ZSRCWORD    ?WORDX       +\n+O+ZCTVERB   +ZCTTRUNC  +ZCTACT\n  +ZCTDESC   +\n+ ~ZFD1      ~ZFD2      ~ZFD3           +\n)MODEL ROWS(&ZSCAN) CLEAR(ZSZ ZCTVERB ZCTTRUNC ZCTACT ZCTDESC)\n`Z@ZCTVERB   @ZCTTRUNC  @ZCTACT\n    @ZCTDESC\n)INIT\n If (&select = &z)\n     &select = ' Options: Add Change Delete Modify Browse '\n If (&shad1  = &z)\n     &SHAD1  = ' %======% !==%!=====%!=====%!=====%!===== '\n IF (&tableinx = Y) &IO = INPUT\n      &IOHILITE =  REVERSE\n      &ZSRCWORD  = 'Search Word:'\n ELSE &IO = OUTPUT\n      &IOHILITE = ''\n      &ZSRCWORD  = ''\n &ZFD1 = ''\n &ZFD2 = ''\n &ZFD3 = ''\n &ZFD4 = ''\n &ZFD5 = ''\n &ZFD6 = ''\n &ZFDN1 = ''\n &ZFDN2 = ''\n &ZFDN3 = ''\n &ZFDN4 = ''\n &ZFDN5 = ''\n &ZFDN6 = ''\n &ZCMD = ''\n &ZSZ = ''\n &AMT = CSR\n IF (&TBDINIT = INIT)\n      &TBDINIT = ''\n      .RESP = END\n.ZVARS='( ZSZ )'\n)REINIT\n  REFRESH(ZSZ,ZCMD)\n)PROC\n &xxz =  trunc (&zcmd, 2)\n  if (&xxz = L,F)\n    &zfd1 = .trail\n    &fdn1 = ZCTVERB\n IF (&ZFD1 \u00ac= '') &ZFDN1 = ZCTVERB\n IF (&ZFD1 \u00ac= '') &ZFDN1 = ZCTTRUNC\n IF (&ZFD1 \u00ac= '') &ZFDN1 = ZCTACT\n IF (&ZFD1 \u00ac= '') &ZFDN1 = ZCTDESC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CMDTBD1": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x16\\x06\\x009\\x009\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xd5\\xc3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T16:06:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "RIAP-NC"}, "text": ")ATTR\n @ AREA(dynamic) EXTEND(ON)          /* extendable scrollable area   */\n ~ AREA(SCRL)                        /* scrollable area attribute    */\n \u00a2 TYPE(TEXT)    INTENS(LOW)  SKIP(ON)  CAPS(ON)    COLOR(RED)\n % TYPE(TEXT)    INTENS(LOW)  SKIP(ON)  CAPS(ON)    COLOR(WHITE )\n + TYPE(TEXT)    INTENS(HIGH) SKIP(ON)  CAPS(ON)    COLOR(BLUE  )\n } TYPE(INPUT)   INTENS(LOW)  CAPS(ON)  PADC('_')    COLOR(WHITE)\n _ TYPE(INPUT)   INTENS(LOW)  CAPS(ON)  PAD(' ')    COLOR(RED   )\n \u00ac TYPE(Text)   INTENS(LOW)  CAPS(ON)  PAD(' ')    COLOR(yellow)\n | TYPE(INPUT)   INTENS(HIGH) CAPS(ON) JUST(ASIS) COLOR(YELLOW)\n # TYPE(TEXT)    INTENS(LOW)  SKIP(ON)  CAPS(OFF)   COLOR(YELLOW)\n)BODY  expand(\\\\)\n%\\-\\#&appldesc                      %\\-\\\n%Command ===>_ZCMD\n+\n+ This procedure will create a#differences+command table by comparing\n+ a#current+versus a#default+table.  You must specify the#table+\n+ and#library+names for#each+copy.\n+\n#Enter%/#Verify+the following%:\n+   #Current+command library %:_z                             +\n+                      table %:_z      +\n+          Differences table %:_z      +\n+\n+   #Default+command library %:_z                             +\n+                      table %:_z      +\n+\n\n+\n+\n+\n+\n@area1    \\ \\@\n+\\ \\%PF3|END+to\u00acExit+ %ENTER+to\u00acContinue\\ \\\n+\n+\n)INIT\n  .HELP = TUTORPAN                   /* insert name of tutorial panel */\n  &area1 = ''\n .zvars = '(tlib1,tblnam1,tblnamd,tlib2,tblnam2)'\n)PROC\n/********************************************************************/\n/*   Modified By: IAPPINI,R.                                        */\n/*   When: 04/14/92                                                 */\n/*   What: CMDTBLDI - compare to command tables                     */\n/*                                                                  */\n/********************************************************************/\n  &retval = Trans(.resp 'END',1 'ENTER',0 *,1)\n  VER (&tlib1,Dsname)\n  VER (&tblnam1,NAME)\n  VER (&tblnamd,NAME)\n  VER (&tlib2,Dsname)\n  VER (&tblnam2,NAME)\n  VPUT (TLIB1,TBLNAM1,TBLNAMD,TLIB2,TBLNAM2) PROFILE\n)HELP\n  /*FIELD(FLDNAME) PANEL(PLNAME) /* insert field help statements  */\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CMDTBLUP": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x01 \\x01 \\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 288, "newlines": 288, "modlines": 0, "user": "RIAP-FB"}, "text": "/* CMDTBLUP*************************************************** Rexx */\n/*   Created by: IAPPINI,R.                                         */\n/*   When: 12/09/92                                                 */\n/*   What: CMDTBLUP is a Rexx EXEC dialog process ISPF command      */\n/*         tables.                                                  */\n/********************************************************************/\nTrace OFF\nAddress \"TSO\"\nArg p1\nParse Source environment . exec_name .\n\nIf Sysvar(Sysispf) \u00ac= \"ACTIVE\" Then Do\n   \"ISPF CMD(%\"exec_name p1\")\"\n   Exit\n   End\n\nIf Words(p1) = 0 Then Do\n   Say \"You must enter the NAME of the table to be processed.\"\n   Exit\n   End\n\nCall Get_tbl_data\nIf rc = 0 Then Do\n   Call Process_tbl_data\n   Call Rebuild_tbl\n   End;\nExit\n\nProcess_tbl_data:\n   Call Build_temp_tbl\n   spannam = pannam\n   pannam  = \"PSICMDIS\"\n   Address \"ISPEXEC\"\n   zscan = \"ALL\"\n   \"VPUT (ZSCAN)\"\n   \"TBTOP   \" tblnam\n   \"TBDISPL \" tblnam \"PANEL(\"pannam\")\"\n   tbdcc = rc\n   pannamd = \"PSICMIN1\"\n   Call Make_selection\n   pannam = spannam\n   names  = snames\n   tblnam = stblnam\n   keys   = \"\"\n   Return\n\nMake_selection:\n   Do i_tbdisp = 1 By 1 While tbdcc < 8\n      Call Process_options\n      Select;\n         When ztdsels > 1 Then Do\n            \"TBDISPL \" tblnam\n            End\n         Otherwise Do\n            \"TBDISPL \" tblnam \"PANEL(\"pannam\")\"\n            tbdcc = rc\n            End\n         End /* End of Select ... */\n      End i_tbdisp\n   Return\n\nProcess_options:\n   se_cols = Space(zfd1 zfd2 zfd3)\n   If zsz = \"\" Then zsz = Left(zcmd,1)\n   Select;\n      When se_cols \u00ac= \"\" Then Do\n         If zcmd = \"\" Then zcmd = \"SEARCH \"\n         /* ZCTVERB   +ZCTTRUNC  +ZCTACT  */\n         If zfd1 \u00ac= \"\" Then zcmd = Word(zcmd,1) \"ZCTVERB(\"zfd1\")\"\n         If zfd2 \u00ac= \"\" Then zcmd = Word(zcmd,1) \"ZCTTRUNC(\"zfd2\")\"\n         If zfd3 \u00ac= \"\" Then zcmd = Word(zcmd,1) \"ZCTACT(\"zfd3\")\"\n         Call Position_table\n         End\n      When Pos(zsz,\"BIS\") \\= 0 Then Do\n         \"DISPLAY PANEL(\"pannamd\")\"\n         End\n      When Pos(zsz,\"CM\") \\= 0 Then Do\n         \"DISPLAY PANEL(\"pannamd\")\"\n         sortf = Word(zctact,1)\n         \"TBMOD \"tblnam \"ORDER\"\n         zedsmsg = zctverb \"modified\"\n         zedlmsg = \"\"\n         \"SETMSG MSG(ISRZ000)\"\n         End\n      When Pos(zsz,\"D\") \\= 0 Then Do\n         \"TBDELETE \"tblnam\n         zedsmsg = zctverb \"deleted\"\n         zedlmsg = \"\"\n         \"SETMSG MSG(ISRZ000)\"\n         End\n      When Pos(zsz,\"R\") \\= 0 Then Call Position_table\n      When Pos(zsz,\"A\") \\= 0 Then Do\n         \"DISPLAY PANEL(\"pannamd\")\"\n         sortf = Word(zctact,1)\n         \"TBADD \"tblnam \"ORDER\"\n         zedsmsg = zctverb \"added\"\n         zedlmsg = \"\"\n         \"SETMSG MSG(ISRZ000)\"\n         End\n      Otherwise Do\n         zedsmsg = zsz \"invalid\"\n         zedlmsg = \"Valid options are Browse, Inquiry, Select,\",\n                   \"Change, Modify, Delete, Add.\"\n         \"SETMSG MSG(ISRZ000)\"\n         End\n      End; /* End of Select ... */\n   Return\n\nPosition_table:\n   Parse Var zcmd function value\n   Address \"ISPEXEC\"\n   zscan  = \"SCAN\"\n   If Right(value,1) = \")\" Then,\n      Parse Var value column  \"(\" value \")\" .\n   Select\n      When Pos(Left(function,1),\"FL\") > 0 Then Do\n         zctverb = value\"*\"\n         \"TBSCAN \"tblnam \"ARGLIST(\"column\") CONDLIST(GE)\"\n         End\n      When Abbrev(\"SEARCH\",function) Then Do\n         \"TBVCLEAR \"tblnam\n         namecond = \"\"\n         Do i_v = 1 By 1 To Words(value)\n            w_value = Strip(Word(value,i_v),\"B\")\n            If Right(w_value,1) = \")\" Then,\n               Parse Upper Var w_value varname \"(\" varvalue \")\" .\n            Else varvalue = \"\"\n            Select\n               When varvalue \u00ac= \"\" Then Do\n                  namecond = namecond\",\"varname\",EQ\"\n                  xx = varname\" = '\"varvalue\"*'\"\n                  Interpret xx\n                  End\n               Otherwise Do\n                  namecond = \",ZCTVERB,EQ\"\n                  zctverb = value\"*\"\n                  End\n               End /* End of Select ... */\n            End i_v\n         namecond = Right(namecond,Length(namecond)-1)\n         \"TBSARG \"tblnam \"NAMECOND(\"namecond\")\"\n         \"TBTOP \"tblnam\n         End\n      When Abbrev(\"RESET\",function) Then Do\n         \"TBVCLEAR \"tblnam\n         zctverb = value\"*\"\n         \"TBSARG \"tblnam \"NAMECOND(ZCTVERB,EQ)\"\n         \"TBTOP \"tblnam\n         End\n      Otherwise Do\n         zedsmsg = \"Invalid command\"\n         zedlmsg = function \"is invalid; valid commands are:\",\n            valid_primary_commands\".\"\n         \"SETMSG MSG(ISRZ000)\"\n         End\n      End /* End of Select ... */\n   Return;\n\nRebuild_tbl:\n   Call Alloc_isptabl\n   Address \"ISPEXEC\"\n/*\n   \"TBSTATS \"tblnam \"CDATE(CDATNAME)    CTIME(CTIMNAME)    \",\n            \"UDATE(UDATNAME)    UTIME(UTIMNAME)    \",\n            \"USER(USERNAME)     ROWCREAT(RCRTNAME) \",\n            \"ROWCURR(RCURNAME)  ROWUPD(RUPDNAME)   \",\n            \"TABLEUPD(TUPDNAME) SERVICE(SERVNAME)  \",\n            \"RETCODE(RETCNAME)  STATUS1(STA1NAME)  \",\n            \"STATUS2(STA2NAME)  STATUS3(STA3NAME)  \"\n   Say       tblnam \"CDATE(\"CDATNAME\") CTIME(\"CTIMNAME\")  \",\n            \"UDATE(\"UDATNAME\")  UTIME(\"UTIMNAME\")  \",\n            \"USER(\"USERNAME\")   ROWCREAT(\"RCRTNAME\") \",\n            \"ROWCURR(\"RCURNAME\") ROWUPD(\"RUPDNAME\") \",\n            \"TABLEUPD(\"TUPDNAME\") SERVICE(\"SERVNAME\") \",\n            \"RETCODE(\"RETCNAME\") STATUS1(\"STA1NAME\") \",\n            \"STATUS2(\"STA2NAME\") STATUS3(\"STA3NAME\") \"\n  Say \"TBSTATS rc(\"rc\")\"\n*/\n   \"TBERASE \" tblnam           /* Delelet original table */\n   \"TBCREATE\" tblnam \"KEYS(\"keys\") NAMES\"names\n   If rc \\= 0 Then Do\n/*    Say \"TBOPEN rc(\"rc\") *** Error for table(\"tblnam\").\"\n*/    zedsmsg = \"Table error\";\n      zedlmsg = \"Table(\"tblnam\") can not be created.\"\n      \"SETMSG MSG(ISRZ001)\"\n      rc = 4;\n      Return;\n      End\n/* \"TBSORT  \" tblnam \"FIELDS(ZCTACT,C,A ZCTVERB,C,A)\"\n*/\n   \"TBTOP  TEMPTBL\" /* Position CRP to 1st row */\n   \"TBSKIP TEMPTBL\"         /*                         */\n   tbgrc = rc\n\n   Do While tbgrc = 0;\n      \"TBADD \"tblnam \"MULT(\"rownum\") ORDER\"\n      \"TBSKIP TEMPTBL\"\n      tbgrc =rc;\n      End;\n   \"TBCLOSE \"tblnam\n   \"TBCLOSE  TEMPTBL\"\n   Address \"TSO\" \"FREE FI(ISPTABL)\"\n   Return\n\nAlloc_isptabl:\n   /* Determine if the member exists in the ISPTLIB allocation */\n   zz = Outtrap(cmdt.)\n   xx = Membydd(tblnam \"ISPTLIB\")\n   zz = Outtrap(\"OFF\")\n   If xx \u00ac= 0 Then Do\n      Say \"Target table not pre-allocated.\"\n      Say \"Terminating \"exec_name\".\"\n      Exit\n      End\n   Parse Var cmdt.1 \"(\" atblnam \")\" . \"(\" adsnam \")\" .\n   Address \"TSO\" \"ALLOC FI(ISPTABL) DA('\"adsnam\"') SH REUSE\"\n   Return\n\nGet_tbl_data:\n   tblnam = Word(p1,1)  /* First entry is the TABLE name*/\n   pannam = cmdtbldi\n   appldesc = \"Table \"tblnam\n   entries = \"Add Browse Change Delete\"\n   Address \"ISPEXEC\"\n   \"TBOPEN \" tblnam  \"NOWRITE\"\n   If rc \\= 0 Then Do\n/*    Say \"TBOPEN rc(\"rc\") *** Error for table(\"tblnam\").\"\n*/    zedsmsg = \"Table error\";\n      zedlmsg = \"Table(\"tblnam\") can not be opened.\"\n      \"SETMSG MSG(ISRZ001)\"\n      rc = 4;\n      Return\n      End\n   \"TBQUERY\" tblnam \"KEYS(KEYS) NAMES(NAMES) ROWNUM(ROWNUM)\"\n   If rc \\= 0 Then Do\n/*    Say \"TBQUERY rc(\"rc\") **** Error for table(\"tblnam\").\"\n*/    zedsmsg = \"Table error\";\n      zedlmsg = \"TBQUERY rc(\"rc\") table(\"tblnam\").\"\n      \"SETMSG MSG(ISRZ001)\"\n      rc = 4;\n      Return;\n      End\n   xnames = Substr(names,2,Length(names)-1)\n/* Say \"KEYS(\"keys\") NAMES(\"xnames\") ROWNUM(\"rownum\")\"\n*/\n   \"TBTOP \" tblnam\n   \"TBSKIP\" tblnam\n   \"TBGET \" tblnam /*\"SAVENAME(XNAMES)\"*/\n   tbgcc = rc\n   Do i_tbget = 1 By 1 While tbgcc = 0\n      sort_fld = Word(zctact,1)\n      Select\n         When sort_fld = \"ALIAS\" Then sort_fld = \"\"\n         Otherwise Nop\n         End /* End of Select ... */\n      tbget.i_tbget = Left(sort_fld,7)Left(zctverb,9),\n                      Left(zcttrunc,3)Left(zctact,50)Left(zctdesc,60)\n      \"TBSKIP\" tblnam\n      \"TBGET \"tblnam /*\"SAVENAME(XNAMES)\" */\n      tbgcc = rc\n      End i_tbget;\n   tbget.0 = rownum\n   \"TBCLOSE \" tblnam  /* Close input table */\n   Return\n\nBuild_temp_tbl:\n   Address \"ISPEXEC\"\n   stblnam = tblnam  /* Save this table name */\n   tblnam  = \"TEMPTBL\"\n   snames  = names   /* Save Names of variables */\n   keys    = \"(SORTF ZCTVERB)\"\n   names   = \"(ZCTTRUNC ZCTACT ZCTDESC)\"\n   \"TBCREATE \"tblnam \"NOWRITE KEYS\"keys \"NAMES\"names\n   \"TBSORT \"tblnam \"FIELDS(SORTF,C,A ZCTVERB,C,A)\"\n   If rownum = 0 Then rownum = 1\n   mult = \"MULT(\"rownum\")\"\n   Do i_tbadd = 1 By 1 While i_tbadd <= rownum\n      Parse Var tbget.i_tbadd sortf +7 zctverb +9 zcttrunc +3 zctact,\n                +50 zctdesc +60 .\n     sortf    = Space(sortf)\n     zctverb  = Space(zctverb)\n     zcttrunc = Space(zcttrunc)\n     zctact   = Space(zctact)\n     zctdesc  = Space(zctdesc)\n     \"TBADD \"tblnam mult \"ORDER\"\n     mult = \"\"\n     End i_tbadd\n   Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMDTBME": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x16\\x06\\x009\\x009\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xd5\\xc3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T16:06:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "RIAP-NC"}, "text": ")ATTR\n @ AREA(dynamic) EXTEND(ON)          /* extendable scrollable area   */\n ~ AREA(SCRL)                        /* scrollable area attribute    */\n \u00a2 TYPE(TEXT)    INTENS(LOW)  SKIP(ON)  CAPS(ON)    COLOR(RED)\n % TYPE(TEXT)    INTENS(LOW)  SKIP(ON)  CAPS(ON)    COLOR(WHITE )\n + TYPE(TEXT)    INTENS(HIGH) SKIP(ON)  CAPS(ON)    COLOR(BLUE  )\n } TYPE(INPUT)   INTENS(LOW)  CAPS(ON)  PADC('_')    COLOR(WHITE)\n _ TYPE(INPUT)   INTENS(LOW)  CAPS(ON)  PAD(' ')    COLOR(RED   )\n \u00ac TYPE(Text)   INTENS(LOW)  CAPS(ON)  PAD(' ')    COLOR(yellow)\n | TYPE(INPUT)   INTENS(HIGH) CAPS(ON) JUST(ASIS) COLOR(YELLOW)\n # TYPE(TEXT)    INTENS(LOW)  SKIP(ON)  CAPS(OFF)   COLOR(YELLOW)\n)BODY  expand(\\\\)\n%\\-\\#&appldesc                      %\\-\\\n%Command ===>_ZCMD\n+\n+ This procedure will create a#merged+command table by merging\n+ a#current+versus a#default+table.  You must specify the#table+\n+ and#library+names for#each+copy.\n+\n#Enter%/#Verify+the following%:\n+   #Current+command library %:_z                             +\n+                      table %:_z      +\n+               Merged table %:_z      +\n+\n+   #Default+command library %:_z                             +\n+                      table %:_z      +\n+\n\n+\n+\n+\n+\n@area1    \\ \\@\n+\\ \\%PF3|END+to\u00acExit+ %ENTER+to\u00acContinue\\ \\\n+\n+\n)INIT\n  .HELP = TUTORPAN                   /* insert name of tutorial panel */\n  &area1 = ''\n .zvars = '(tlib1m,tblnam1m,tblnamdm,tlib2m,tblnam2m)'\n)PROC\n/********************************************************************/\n/*   Modified By: IAPPINI,R.                                        */\n/*   When: 04/14/92                                                 */\n/*   What: CMDTBLME - merge command tables                          */\n/*                                                                  */\n/********************************************************************/\n  &retval = Trans(.resp 'END',1 'ENTER',0 *,1)\n  VER (&tlib1m,Dsname)\n  VER (&tblnam1m,NAME)\n  VER (&tblnamdm,NAME)\n  VER (&tlib2m,Dsname)\n  VER (&tblnam2m,NAME)\n  VPUT (Tlib1m,TBLnam1m,TBLnamdm,Tlib2m,TBLnam2m) PROFILE\n)HELP\n  /*FIELD(FLDNAME) PANEL(PLNAME) /* insert field help statements  */\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COPYF": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x16\\x06\\x00C\\x00C\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xd5\\xc3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T16:06:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "RIAP-NC"}, "text": ")ATTR\n  ` TYPE(TEXT) INTENS(HIGH) CAPS(ON) COLOR(RED)\n  ! TYPE(TEXT) INTENS(HIGH) CAPS(OFF) COLOR(TURQ) HILITE(USCORE)\n ~ area(scrl)\n)BODY EXPAND(\\\\) WINDOW(60,15)\n%Select ===> _ZCMD \\ \\ +\n+(Enter a number or DSname ) \\ \\!PF7/8+Scroll!PF3+End+\n%Copy member _MEM     +All dataset name fully qual no quote\n~scrarea  \\ \\~\n~         \\ \\~\n~         \\ \\~\n~         \\ \\~\n~         \\ \\~\n~         \\ \\~\n~         \\ \\~\n~         \\ \\~\n+\n+A Program Products Service\n)area scrarea\n`1)  _DSN01 \\ \\+\n`2)  _DSN02 \\ \\+\n`3)  _DSN03 \\ \\+\n`4)  _DSN04 \\ \\+\n`5)  _DSN05 \\ \\+\n`6)  _DSN06 \\ \\+\n`7)  _DSN07 \\ \\+\n`8)  _DSN08 \\ \\+\n`9)  _DSN09 \\ \\+\n`10) _DSN10 \\ \\+\n`11) _DSN11 \\ \\+\n`12) _DSN12 \\ \\+\n`13) _DSN13 \\ \\+\n`14) _DSN14 \\ \\+\n`15) _DSN15 \\ \\+\n`16) _DSN16 \\ \\+\n`17) _DSN17 \\ \\+\n`18) _DSN18 \\ \\+\n`19) _DSN19 \\ \\+\n`20) _DSN20 \\ \\+\n)INIT\n.cursor = zcmd\n&ZWINTTL= 'Quick Member copy'\n)REINIT\n&ZCMD = ' '\n)PROC\nVER (&MEM   NAME)\nVER (&DSN01 DSNAME)\nVER (&DSN02 DSNAME)\nVER (&DSN03 DSNAME)\nVER (&DSN04 DSNAME)\nVER (&DSN05 DSNAME)\nVER (&DSN06 DSNAME)\nVER (&DSN07 DSNAME)\nVER (&DSN08 DSNAME)\nVER (&DSN09 DSNAME)\nVER (&DSN10 DSNAME)\nVER (&DSN11 DSNAME)\nVER (&DSN12 DSNAME)\nVER (&DSN13 DSNAME)\nVER (&DSN14 DSNAME)\nVER (&DSN15 DSNAME)\nVER (&DSN16 DSNAME)\nVER (&DSN17 DSNAME)\nVER (&DSN18 DSNAME)\nVER (&DSN19 DSNAME)\nVER (&DSN20 DSNAME)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COPYMORE": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00=\\x00=\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "RIAP-FB"}, "text": "/* REXX * REXX * REXX * REXX * REXX * REXX */\nAddress TSO\narg p1\ncmd_area = ,\n\"PROC 2 FROMQUALIFIER TOQUALIFIER DEBUG NUMBEROFDSNS(500) NOCOPY \"\ncall proctso p1,cmd_area\ninterpret result\nif Length(NOCOPY) > 0 then NOCOPY = 1      /* true */\nelse                         NOCOPY = 0    /* false*/\nif debug \u00ac= '' then trace r\n#digits = length(numberofdsns)\n#from = length(fromqualifier)+1\n#to   = length(toqualifier)  +1\nx = outtrap(lv.,numberofdsns)\n\"LV '\"fromqualifier\"'\"\nX=OUTTRAP('OFF')\nloop = lv.0\nlqmx = ''\nDO I = 1 BY 1 WHILE i <= loop\n   lqmx = length(space(lv.i)) lqmx\n   end i\n#from = #from + rexxmax(lqmx)\nDO I = 1 BY 1 WHILE i <= loop\n   lowquals = LV.I\n   select\n      when wordpos(\"LV \"fromqualifier, lowquals) >0 then nop\n      when WORDPOS('LOCATE ERROR CODE =' ,lowquals) > 0 THEN DO\n         SAY 'COPYMORE - Could not LOCATE 'fromqualifier' datasets.'\n         EXIT\n         END\n      otherwise do\n         lowquals = space(lowquals)\n         Y = TOQUALIFIER\".\"lowquals\n         lowquals = FROMQUALIFIER\".\"lowquals\n         SELECT\n            WHEN NOCOPY then DO\n               j = right(i,#digits)\n               say J' 'left(lowquals,#from)' -> 'y\n               END /* End of when ........ */\n            OTHERWISE DO\n               \"COPY '\"lowquals\"' '\"Y\"'\"\n               if rc \u00ac= 0 then,\n                  say \"COPYMORE - failed:\" left(lowquals,#from) y\n               end /* End of otherwise ... */\n            end    /* End of Select ...... */\n         end       /* End of otherwise ... */\n      end          /* End of SELECT ...... */\n   end i           /* End of DO I ........ */\n/**************************************************************/\n/*                                                            */\n/*                                                            */\n/*         This procedure will COPY starting with a Generic   */\n/*         FROMQUALIFIER to a Generic TOQUALIFIER             */\n/*                                                            */\n/*    BY: R. IAPPINI                                          */\n/*  DATE: 08/02/88                                            */\n/*                                                            */\n/*                                                            */\n/*                                                            */\n/*                                                            */\n/**************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COPYNREC": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x004\\x004\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "RIAP-FB"}, "text": "/* COPYNREC*************************************************** Rexx */\n/*   Created By: IAPPINI,R.                                         */\n/*   When: 03/24/93                                                 */\n/*   What: COPYNREC will copy n records from file1 to file2.        */\n/*                                                                  */\n/********************************************************************/\nTrace \"OFF\"\nAddress 'TSO'\nParse Source environment . exec_name .\nArg p1\nproc_stmt = \"PROC 3 FILE1 FILE2 NUMBEROFRECORDS SKIP()\"\nCall Proctso p1,proc_stmt\nInterpret result\nIf rc \u00ac= 0 Then Do\n   Say proctso_msg\n   Say \"Valid options are: \"Subword(proc_stmt,3)\n   Say \"You entered: \"p1\n   Say \"Re-enter \"exec_name \"with the correct options.\"\n   Exit\n   End\nxx = Sysdsnri(file1)\nInterpret xx\nIf rc \u00ac= 0 Then Do\n   Say file1 \"is not Cataloged, terminating \"exec_name\n   Exit\n   End\nxx = Sysdsnri(file2)\nInterpret xx\nIf rc \u00ac= 0 Then,\n   file_options = \"LIKE(\"file1\") REUSE\"\nElse,\n   file_options = \"SH REUSE\"\n\"ALLOC FI(IF) DA(\"file1\") SH REUSE\"\n\"ALLOC FI(OF) DA(\"file2\")\" file_options\nSay \"Copying \"numberofrecords \"records from\" file1 \"to\" file2\".\"\n\"DELSTACK\"\nSelect\n   When skip = \"\"  Then,\n      \"EXECIO \"numberofrecords\" DISKR  IF (FINIS)\"\n   Otherwise Do\n      \"EXECIO \"skip\" DISKR  IF \"\n      \"DELSTACK\"\n      \"EXECIO \"numberofrecords\" DISKR  IF (FINIS)\"\n      End\n   End /* End of Select ... */\nQueue \"\"\n\"EXECIO * DISKW  OF (FINIS)\"\nSay exec_name \"has finished copying \"numberofrecords \"records from\",\n   file1 \"to\" file2\".\"\n\"DELSTACK\"\n\"FREE FI(IF,OF)\"\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DQUAL": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00\\x0b\\x00\\x0b\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "RIAP-FB"}, "text": "/* Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  */\n/********************************************************************/\n/*   Created by: IAPPINI,R.                                         */\n/*   When: 06/03/92                                                 */\n/*   What: Returns a DATE qualifier..........                       */\n/*                                                                  */\n/********************************************************************/\nAddress 'TSO'\nArg p1\nParse Value Date(u) With  mm '/' dd '/' yy .\nReturn (\"D\"yy||mm||dd)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSNBYDD": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00F\\x00F\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 70, "newlines": 70, "modlines": 0, "user": "RIAP-FB"}, "text": "/* DSNBYDD *************************************************** Rexx */\n/*   Created by: IAPPINI,R.                                         */\n/*   When: 11/20/92                                                 */\n/*   What: DSNBYDD is a Rexx EXEC dialog that creates a PS dataset  */\n/*         containing a list of datasets concatenated to a ddname.  */\n/*         The PS dataset is named with the ddname name.            */\n/*                                                                  */\n/********************************************************************/\nAddress 'TSO'\nArg p1\nCall Initialize\nIf debug \u00ac= \"\" Then Trace ?i\nCall Process_dds\nCall Eoj\nExit\n\nProcess_dds:\n   Do i_dd = 1 By 1 To Words(ddnames)\n      v_ddname = Word(ddnames,i_dd)\n      \"DDCURALT \"v_ddname \"DSNLIST\"\n      If rc = 0 Then Call Create_dd_dataset_list\n      Else Call Say_msg v_ddname \"not allocated.\"\n      Call Say_msg \" \"\n      End i_dd;\n   Return;\n\nCreate_dd_dataset_list:\n   dsnlist = Space(Translate(dsnlist,\"\",\"'\"))\n   xx = Listdsi(v_ddname)\n   If xx \u00ac= 0 Then,\n      \"ALLOC DA(\"v_ddname\") LRECL(80) RECFM(F B)\",\n         \"BLKSIZE(6160) DSORG(PS)\"\n   \"ALLOC FI(VDDNAME) DA(\"v_ddname\") OUTPUT REUSE\"\n   dsn. = \"\"\n   Call Say_msg \"Dataset(\"v_ddname\") updated, \"Date()\",\" Time()\".\"\n   Do i_vdd = 1 By 1 To Words(dsnlist)\n      dsn.i_vdd = Strip(Word(dsnlist,i_vdd),\"B\")\n      Call Say_msg \"   \"dsn.i_vdd\n      End i_vdd\n   \"EXECIO * DISKW VDDNAME (STEM DSN. FINIS)\"\n   \"FREE FI(VDDNAME)\"\n   Return;\n\nEoj:\n   If fullscreen Then Call Stemdisp \"BROWSE\",\"say.\",,,\"DD datasets list\"\n   Return;\n\nSay_msg:\n   Parse Arg msg\n   If \u00acfullscreen Then Say msg\n   say_cnt = say_cnt + 1\n   say.say_cnt = msg\n   Return\n\nInitialize:\n   Parse Source environment . exec_name .\n   proc_stmt = \"PROC 1 DDNAMES DEBUG FULLSCREEN\"\n   Call Proctso p1,proc_stmt\n   Interpret result\n   If rc \u00ac= 0 Then Do\n      Say proctso_msg\n      Say \"Valid options are: \"Subword(proc_stmt,3)\n      Say \"Enter the correct options for \"exec_name\".\"\n      Exit\n      End\n   say_cnt = 0\n   If fullscreen = \"\" Then fullscreen = 0\n   Else                    fullscreen = 1\n   ddnames = Strip(Translate(ddnames,\"\",\"()\"),\"B\")\n   Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSNMLIST": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x01\\n\\x01\\n\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 266, "newlines": 266, "modlines": 0, "user": "RIAP-FB"}, "text": "/* DSNMLIST*************************************************** Rexx */\n/*   Modified By: IAPPINI,R.                                        */\n/*   When: 06/08/93                                                 */\n/*   What: Added MEMBERS() option; select member display            */\n/*                                                                  */\n/********************************************************************/\n/* DSNMLIST*************************************************** Rexx */\n/*   Created By: IAPPINI,R.                                         */\n/*   When: 05/14/93                                                 */\n/*   What: DSNMLIST, given a dataset name, complete or generic, will*/\n/*         create an appropriate member statistic display (ala 3.1) */\n/********************************************************************/\nTrace \"OFF\"\nAddress \"TSO\"\nArg p1\nCall Initialize\nCall Process_dsns_list\nCall Eoj\nExit\n\nProcess_dsns_list:\n   Do i_dsnslist = 1 By 1 To Words(dsns)\n      g_dsn = Word(dsns,i_dsnslist)\n      Call Get_dsn_list g_dsn\n      Select\n         When dsn_list.0 = 0 Then Do\n            Call Say_msg \" No datasets found for \"g_dsn\".\"\n            End\n         Otherwise Call Process_dsn_list\n         End /* End of Select */\n      End i_dsnslist;\n   Return;\n\nProcess_dsn_list:\n   #digits = Length(dsn_list.0)\n   Do i_dsnlist = 1 By 1 To dsn_list.0\n      /* Call Say_msg \" \" */\n      ret_dsn = dsn_list.i_dsnlist\n      xx = Listdsi(\"'\"ret_dsn\"' PREALLOC\")\n      /* Say ret_dsn \"DSORG(\"sysdsorg\")\" */\n      If sysdsorg \u00ac= \"PO\" Then Do\n         cc = \"0\"\n         Call Say_msg cc || Right(i_dsnlist,#digits,\" \"),\n            \"Dsn(\"ret_dsn\")\",\n            \"Dsorg(\"sysdsorg\") has no members.\"\n         End\n      Else Do\n         volume  = sysvolume\n         Call Say_msg cc || Right(i_dsnlist,#digits,\" \"),\n            \"Vol(\"volume\") Dsn(\"ret_dsn\")\"\n         If lv Then Do\n            xx = Outtrap(tso.)\n            Address \"TSO\" \"LV '\"ret_dsn\"' A\"\n            xx = Outtrap(\"OFF\")\n            Do i_tso = 1 By 1 To tso.0\n               Call Say_msg \"   \"Left(tso.i_tso,72)\n               End i_tso\n            End\n         Call Get_member_list ret_dsn\n         If #members_found = 0 Then,\n            Call Say_msg \" 0 members found for dataset \"ret_dsn\".\"\n         cc = \"1\"\n         End;\n      If (i_dsnlist // 10) = 0 Then, /* Do every 10 datasets */\n         Call Save_display_partial\n      End i_dsnlist;\n   If (i_dsnlist // 10) \u00ac= 0 Then,   /* Do remaining datasets */\n      Call Save_display_partial\n   Return;\n\nSave_display_partial:\n   If print | disk Then,\n      Call Allocate_write_dsnmlist_disk\n      Address \"ISPEXEC\"\n   If fullscreen Then,\n      Call Stemdisp \"BROWSE\",\"say.\",,,dsnm_msg\n   say. = \"\"\n   say_cnt = 0\n   Return;\n\nGet_member_list:\n   Arg dataset\n   Address \"ISPEXEC\"\n   \"LMINIT DATAID(DAID) DATASET('\"dataset\"')\"\n   If rc \u00ac= 0 Then Do\n      Call Say_msg \" 0Dataset(\"dataset\") Error(\"rc\").\"\n      Return;\n      End;\n   \"LMOPEN DATAID(\"daid\")\"\n   mbrname = \" \"\n   \"LMMLIST DATAID(\"daid\") MEMBER(MBRNAME) STATS(YES) OPTION(LIST)\"\n   r_c = rc\n/* *******************************************************************\n-  MEMBER           TTR   VERS.MOD    CREATION      DATE AND TIME\n    NAME           (HEX)    LEVEL       DATE        LAST MODIFIED\n0 @DIR             003405\n  ABENDAID         002E0C   01.00     93/03/09     93/03/09  06:42\n CURRENT      INITIAL     MODIFIED       USER\nNO. LINES    NO. LINES    NO. LINES       ID\n   20           20            0        BI21RI\n   25           24            1        BI21RI\n******************************************************************** */\n   #members_found = 0 /* Reset for every DSN requested */\n   Do i_memlist = 1 By 1 While r_c = 0\n      Select\n          When members \u00ac= \"\" Then Call Member_select\n          Otherwise Call Member_display\n          End /* End of Select ... */\n      \"LMMLIST DATAID(\"daid\") MEMBER(MBRNAME) STATS(YES)\"\n      r_c = rc\n      End i_memlist\n   \"LMMLIST DATAID(\"daid\") OPTION(FREE)\"\n   \"LMCLOSE DATAID(\"daid\")\"\n   Return;\n\nMember_select:\n   Do i_mem = 1 By 1 To Words(members)\n      sel_mem = Word(members,i_mem)\n      Select\n         When Right(sel_mem,1) = \"*\" Then Do\n            If Strip(Translate(sel_mem,\"\",\"*\"),\"B\") =,\n               Left(mbrname,Length(sel_mem)-1) Then,\n               Call Member_display\n            End;\n         When mbrname = sel_mem Then Call Member_display\n         Otherwise Nop\n         End /* End of Select ... */\n      End i_mem;\n   Return;\n\nMember_display:\n   If #members_found = 0 Then Call Headings\n   If Space(zlvers zlmod,0) = \"\" Then vermod = \"\"\n   Else vermod = zlvers\".\"zlmod\n   Call Say_msg \"    \"Left(mbrname,9)Center(vermod,8),\n      zlcdate zlmdate zlmtime,\n      Right(zlcnorc,7) Right(zlinorc,7) Right(zlmnorc,7),\n      Right(zluser,7)\n   #members_found = #members_found + 1;\n   Return;\n\nHeadings:\n   Call Say_msg \"0   \"Left(\"Member\",9)Center(\"Ver.Mod\",8),\n      Center(\"Created\",8) Center(\"Modified\",14),\n      Center(\"Record Counts\",23) Left(\"Userid\",7)\n   Call Say_msg \"    \"Copies(\" \",17),\n      Center(\"Date\",8) Center(\"Date/Time\",14),\n      Right(\"Cur\",7) Right(\"Init\",7) Right(\"Mod\",7)\n   Call Say_msg \"    \"Copies(\"-\",8) Copies( \"-\",8) Copies(\"-\",8),\n      Copies(\"-\",14),\n      Copies(\"-\",7) Copies(\"-\",7) Copies(\"-\",7),\n      Copies(\"-\",7)\n   Return;\n\nGet_dsn_list:\n   Arg dataset\n   Address \"ISPEXEC\"\n   dataset = Strip(Translate(dataset,\"\",\"'\"),\"B\")\n   \"LMDINIT LISTID(DSVAR) LEVEL(\"dataset\")\"\n   r_c = 0\n   dlist_opt = \"LIST\"\n   ret_dsn =     \"\"\n   dlist_stats = \"YES\"\n   dsn_list. = \"\"\n   \"LMDLIST LISTID(\"dsvar\") OPTION(\"dlist_opt\") DATASET(RET_DSN)\",\n       \"STATS(\"dlist_stats\")\"\n   r_c = rc\n   Do i_dsnlist  = 1 By 1 While r_c = 0\n      dsn_list.i_dsnlist = ret_dsn;\n      Select\n         When r_c > 0 Then Leave i /* End of list */\n         When zdlmigr \u00ac= \"YES\" Then Do\n              volume = zdlvol\n              device = zdldev\n              dsorg  = zdldsorg\n              recfm  = zdlrecfm\n              lrecl  = zdllrecl\n              blksiz = zdlblksz\n              size   = zdlsize\n              extent = zdlext\n              cdate  = zdlcdate\n              edate  = zdledate\n              rdate  = zdlrdate\n              migr   = zdlmigr\n             dsn_typ = zdldsntp\n            End\n         Otherwise  Do\n            volume = \"MIGRAT\"\n            End\n         End /* End of Select .... */\n      \"LMDLIST LISTID(\"dsvar\") OPTION(\"dlist_opt\") DATASET(RET_DSN)\",\n          \"STATS(\"dlist_stats\")\"\n      r_c = rc\n      End i_dsnlist\n   dsn_list.0 = i_dsnlist - 1\n   Return;\n\nSay_msg:\n   Parse Arg msg\n   Select\n      When queue Then Queue msg\n      When (\u00acfullscreen & \u00acQuiet) Then Say msg\n      Otherwise Nop\n      End /* End of Select ... */\n   say_cnt = say_cnt + 1\n   say.say_cnt = msg\n   Return\n\nEoj:\n   Address \"TSO\"\n   If queue Then Queue \"\" /* Data Stack separator */\n   If print Then Do\n      If Sysvar(Sysenv) \u00ac= \"FORE\" Then,\n         \"%PRT \"dsnmlist \"DEST(\"acfdest\")\"\n      Else \"%QPRT\" dsnmlist\n      \"DELETE \"dsnmlist\n      End\n   Return;\n\nAllocate_write_dsnmlist_disk:\n   If Sysdsn(dsnmlist) \u00ac= \"OK\" Then Do;\n      \"ALLOC FI(DSNMLIST) DA(\"dsnmlist\") UNIT(DISK) RECFM(F B A)\",\n          \"SPACE(15 5) BLKSIZE(1330) LRECL(133) TRACK  REUSE\"\n      End;\n   Else,\n      \"ALLOC FI(DSNMLIST) DA(\"dsnmlist\") SH REUSE MOD\"\n   \"EXECIO * DISKW DSNMLIST (STEM SAY. FINIS)\"\n   \"FREE FI(DSNMLIST)\"\n   Return;\n\nInitialize:\n   Parse Source environment . exec_name .\n   If Sysvar(Sysispf) \u00ac= \"ACTIVE\" Then Do\n      \"ISPF CMD(%\"exec_name p1\")\"\n      Exit\n      End\n   \"ACFVPUTT\"\n   proc_stmt = \"PROC 1 DSNS MEMBERS()\"\n   more_options = \"FULLSCREEN QUIET LV  DISK PRINT QUEUE\"\n   Call Proctso p1,proc_stmt more_options\n   Interpret result\n   If proctso_msg \u00ac= \"\" Then Do\n      Say proctso_msg\n      Say \"Valid options are: \"Subword(proc_stmt,3)\n      Exit\n      End\n   say_cnt = 0\n   cc = \"0\"\n   /* Set option flags */\n   Do i_flag = 1 By 1 To Words(more_options)\n      Interpret Word(more_options,i_flag) \"=\",\n                Set_flag(Word(more_options,i_flag) )\n      End i_flag;\n   dsnm_msg = \"1Dsn/Member list(\"Date() Time()\") for\" dsns\n   Call Say_msg dsnm_msg\n   dsns = Strip(Translate(dsns,\"\",\"(),\"),\"B\")\n   members = Space(Translate(members,\"\",\"(,)\"))\n   dsnmlist = \"DSNMLIST.\"Dtqual()\n   If \u00acquiet & disk Then,\n      Say \"DSNMLIST information will be saved in \"dsnmlist\".\"\n   If queue Then \"DELSTACK\" /* Initialize Data Stack */\n   Return;\n\nSet_flag:\n   Arg flag\n   Return (Value(flag) \u00ac= \"\")\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSNTABLE": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x16\\x06\\x00\\x87\\x00\\x87\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xd5\\xc3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T16:06:00", "lines": 135, "newlines": 135, "modlines": 0, "user": "RIAP-NC"}, "text": "/** dsntable level stat save TLIB() ************************* Rexx **/\n/*                                                                  */\n/*  Level:    High level qualifier. Mask (*) allowed                */\n/*  STAT:     Other statistic info created                          */\n/*  SAVE:     Save to table DSNTABLE. TBLIB() required.             */\n/*  TLIB:     Table library. Required with \"SAVE\" (no quote)        */\n/*  OPEN:     Do not display table but leave open for               */\n/*                  further processing.                             */\n/*  Example:  DSNTABLE BI21ctt.C* STAT SAVE TLIB(BI21CTT.TABLES)    */\n/*  By CT Tran 8/91.                                                */\n/********************************************************************/\n/********************************************************************/\n/*   Modified By: IAPPINI,R.                                        */\n/*   When: 08/28/91                                                 */\n/*   What: Added DSN list capablity, ie, (dsn1 dsn2 ... dsnx)       */\n/*                                                                  */\n/********************************************************************/\narg otherparms\nParse Source . . cname .\nIf SysVar('SysISPF') \u00ac= \"ACTIVE\"\n  Then Do\n    Address TSO \"ISPF CMD(%\"cname otherparms \") \",\n    \"NEWAPPL(Q34) PASSLIB\"\n    Exit (0)\n    End\nAddress 'ISPEXEC'\n\"VGET (ZAPPLID)\"\nIf zapplid \u00ac= \"Q34\"  Then Do\n    \"SELECT CMD(%\"cname otherparms \") NEWAPPL(Q34) PASSLIB\"\n    Exit (0)\n    End /* zapplid*/\nUpper  otherparms\nTLIB = keywordv('TLIB(',otherparms)\nIf  wordpos('OPEN',otherparms) >0 Then open = 'OPEN'\nElse open = ''\nIf  wordpos('SAVE',otherparms) >0 Then write = 'WRITE'\nElse write= 'NOWRITE'\nIf  wordpos('STAT',otherparms) >0 Then stats = 'STATS'\nElse stats = ''\nAddress TSO 'ACFVPUTT'\nIf window \u00ac= '' Then center = center'('window')'\n\"VPUT CENTER SHARED\"\nCall remove \"OPEN STAT SAVE \"\nIf Left(otherparms,1) = '(' Then,\n   Parse Upper Var otherparms '(' level ')' .\nElse Parse Upper Var otherparms level .\nIf level      = '' Then Do\n   'DISPLAY PANEL(DSNT1)'\n   If rc > 0 Then Exit\n   End\nIf write = 'WRITE' Then Do\n   If tlib = '' Then  tlib = USERID()'.TABLES'\n   If sysdsn(\"'\"tlib\"'\") \u00ac= 'OK' Then Exit\n   \"LIBDEF ISPTABL DATASET ID('\"tlib\"')\"\n   \"LIBDEF ISPTLIB DATASET ID('\"tlib\"')\"\n   End\nIf substr(stats,1,4,' ') = 'STAT' Then Do;stats = 'YES';tabdis='DSNT3'\nEnd\nElse Do; tabdis = 'DSNT2'; stats = 'NO';End\nIf stats = 'YES' Then\n   'TBCREATE DSNTABLE KEYS(DSNAME) NAMES(PREFIX QUAL2 QUAL3 QUAL4 ',\n   'DSN TRKALLOC VOLUME TRKUSED DEVICE EXTENT DSORG CDATE ',\n   'RECFM EDATE LRECL LRDATE BLKSIZE DSNTP)   REPLACE ' write\nElse 'TBCREATE DSNTABLE KEYS(DSNAME)',\n         ' NAMES(DSN PREFIX QUAL2 QUAL3 QUAL4 ) ',\n         ' REPLACE ' WRITE\nmlevel = Translate(level,' ',',') /* remove potential commas */\nDo idsnl = 1 to words(mlevel)\n   level = word(mlevel,idsnl)\n   Call Build_level /* iterate on adding DSNs to the table */\n   End\nIf open = '' Then Do\n   ufunc1 =    \" B 'BROWSE DATASET('dsn')'\"\n   ufunc2 =    \" E 'EDIT   DATASET('dsn')'\"\n   ufunc3 =    \" D  Address 'TSO' 'DELETE 'dsn ;\",\n               \" If rc = 0 Then 'TBDELETE DSNTABLE'\"\n   ufunc4 =    \" P Do; \",\n               \"'CONTROL DISPLAY SAVE'; \",\n               \"'ADDPOP ROW(3) COLUMN(10)';\",\n               \"'DISPLAY PANEL(POPPRT)';\" ,\n               \"'REMPOP' ;\",\n               \"'CONTROL DISPLAY RESTORE';\",\n                \"  Address 'TSO' \",\n                \"'PRT 'dsn ' DEST('DEST') \",\n                    \"COPIES('copies') ROOM('room') 'parms ztype;End;\"\n   ufunc5 =   \"Address 'TSO' 'RECOVER 'dsn\"\n   'VPUT (UFUNC1 UFUNC2 UFUNC3 UFUNC4 UFUNC5) PROFILE '\n   Call TBD 'table(DSNTABLE) nopcheck tabdis('tabdis,\n   ') OPEN NOUPDATE VGET(UFUNC1 UFUNC2 UFUNC3 UFUNC4 UFUNC5) '\n   End\nIf write = 'WRITE' & open = '' Then\n'TBCLOSE DSNTABLE '\nElse If WRITE = 'WRITE' & OPEN \u00ac= '' Then 'TBSAVE  DSNTABLE '\nExit\nRemove:\n   arg p1\n   Do i = 1  to words(p1)\n      remi = word(p1,i)\n      If remi  = '' Then leave\n      x = wordpos(remi,otherparms)\n      If x> 0 Then  otherparms = Delword(otherparms,x,1)\n      End\n   Return\nBuild_level:\n   'LMDINIT LISTID(Q34) LEVEL('level')'\n   If rc >0 Then Do\n      say 'Invalid qualifier('level') or datasets do not exist'\n      Return /* Exit may not be valid anymore */\n      End\n   cc = 0\n   q34name = ''\n   Do while cc = 0\n      'LMDLIST LISTID('q34') STATS('stats') OPTION(LIST) DATASET(Q34NAME) '\n      cc = rc\n      Trace Off\n      If cc = 0 Then Do\n         dsn =  \"'\"q34name\"'\"\n         dsname = q34name\n         If stats = 'YES' Then Do\n            dsntp =    zdldsntp\n            TRKALLOC = zdlsize\n            If zdlmigr = 'YES' Then volume = 'MIGRAT'\n            Else volume = zdlvol;                   TRKUSED =  zdlused\n            device = zdldev;                        extent =   zdlext\n            dsorg =  zdldsorg;                      cdate  =   zdlcdate\n            recfm =  zdlrecfm;                      exdate =   zdledate\n            lrecl =  zdllrecl;                      lrefdate = zdllrdate\n            blksize = zdlblksz\n            End\n         Parse Upper Var dsname prefix '.' qual2 '.' qual3 '.' qual4 '.' .\n         'TBADD DSNTABLE '\n         End\n      End\n   'LMDFREE LISTID('Q34') '\n   Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDF": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x01p\\x01p\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 368, "newlines": 368, "modlines": 0, "user": "RIAP-FB"}, "text": "/* EDF   (Edit Find) ***************************************** Rexx */\n/*   Created By: TRAN,C.T.                                          */\n/*   When: 02/14/92                                                 */\n/*                                                                  */\n/*   What: EDF   is a Rexx EXEC dialog To browse/edit/LV/Delete     */\n/*   the next occurence of dataset at cursor line                   */\n/*   (or bring up a whole list of dsn for further processing).      */\n/*   Enter EDF   at command line                                    */\n/*   Then move cursor To the string To be found.                    */\n/*   Helpful in browse/edit imbeded dsn without typing name         */\n/*                                                                  */\n/*   Option: B: Browse (default)                                    */\n/*           E: Edit                                                */\n/*           L: LV status of dataset instead of browse/edit         */\n/*           C: Full screen display of dsnames By CATALYST          */\n/*      blank : Full screen display of dsnames By Popup panel       */\n/*     NOCHECK: Datasets will not be checked for existance          */\n/*   By CT Tran program Products        2/92                        */\n/*                                                                  */\n/********************************************************************/\nAddress ISREDIT\n\"MACRO (OPT nocheck) NOPROCESS\"\nTrace \"OFF\"\nCall Initialize\nCall Process_main\n/*Call Endpgm*/\nExit\n\nProcess_main:\n   edfcmd = Left(opt,2)\n   Select\n      When firstlin = 1 & ccrs = 0 Then Do\n         \"(LASTLINE) = LINENUM .ZL\"\n/*       \"(firstlin) = LINENUM .ZF\"*/\n         If \u00acDatatype(firstlin,\"N\") Then firstlin = 1\n         Call Setup_display\n         Select\n            When totaldsn = 0 Then Do\n               zedsmsg = \"No dsname(s) found\"\n               Address \"ISPEXEC\" \"setmsg Msg(ISRZ000)\"\n               End\n            When catalyst Then Do\n               Call Do_catalyst\n               End;\n            Otherwise Call Displ_it\n            End /* End of Select ... */\n         End\n      Otherwise Do\n         If \u00acDatatype(lastline,\"N\") Then lastline = firstlin\n         Call Setup_display\n         Select\n            When catalyst Then Do\n               Call Do_catalyst\n               End;\n            Otherwise Do\n               zcmd = 1\n               If totaldsn = 1 Then Call Browse_them\n               Else Call Displ_it\n               End\n            End /* End of Select ... */\n         End\n      End  /* End of Select ... */\n   Return;\n\nCatalyst_msgs:\n   dsn.0 = 7\n   dsn.1 = \"This list contains all the dataset names pulled from \"\n   dsn.2 = \"dataset('\"Strip(dsname,\"B\")\"')\"\n   dsn.3 = \"You can perform all Catalyst functions\"\n   dsn.4 = \"against these datasets. To Exit press <Enter>\"\n   dsn.5 = \"twice To get back To the editing session.\"\n   dsn.6 = Copies(\" \",20)\"Thanks for using EDF C function\"\n   dsn.7 = Copies(\" \",20)\"A service of Program Products group\"\n   Do i = 1 By 1 To dsn.0\n      dsn.i = \"/*\"Substr(dsn.i,1,60,\" \")\"*/\"\n      End i;\n   Return;\n\nAdd_dsn_to_table:\n   If dsn = \"\" Then Return;\n   Address \"ISPEXEC\" \"TBADD @EDF \"\n   If rc = 0 Then Do\n      i = i + 1\n      If \u00acnocheck Then Do\n         If Sysdsn(\"'\"dsn\"'\") \u00ac= \"OK\"  Then Do\n            x = 41-Length(dsn)\n            If x > 0 Then,\n               dsn = dsn\"<-\"Substr(dash,1,x,\"-\")\"-UNCATALOGED\"\n            End\n         totaldsn = totaldsn+1\n         dsn.i = dsn\n         copyf = copyf dsn.i\n         End\n      End\n   Return;\n\nSetup_display:\n   Address \"ISPEXEC\" \"TBCREATE @EDF   KEYS(DSN) NOWRITE REPLACE\"\n   i = dsn.0\n   copyf = \"\"\n   totaldsn=0\n   Do firstlin = firstlin By 1 To lastline\n      \"(NAME) = LINE\" firstlin\n      If Get_line() \u00ac= 0 Then Iterate\n      Call Add_dsn_to_table\n      End firstlin /* finished parsing the data lines */\n   Return;\n\nGet_line:\n   Select\n      When Left(name,2) = \"/*\" Then Return (4)\n      When Left(name,3) = \"//*\" Then Return (4)\n      When Pos(\"DSN=\",name) > 0 Then Do\n         Parse Var name \"DSN=\" dsn \",\"\n         End\n      When Pos(\"DSNAME=\",name) > 0 Then Do\n         Parse Var name \"DSNAME=\" dsn  \",\"\n         End\n      When clist_rexx Then Do\n         Call Process_clist_rexx\n         Return (4)\n         End\n      Otherwise Return (4)\n      End /* End of Select ... */\n   If Left(dsn,1) = \"'\" & Right(dsn,1) \u00ac= \"'\" Then,\n      dsn = dsn\"'\" /* add ending quote */\n   Return (0);\n\nProcess_clist_rexx:\n   Do i = 1 By 1 To Words(name)\n      dsn = Word(name,i)\n      Select\n         When Pos(\".\",dsn) > 0 Then dsn = Valid_dsname(dsn)\n         When Pos(\"(\",dsn) > 0 Then dsn = Valid_dsname(dsn)\n         When Pos(\"'\",dsn) > 0 Then dsn = Valid_dsname(dsn)\n         Otherwise dsn = \"\"\n         End /* End of Select ... */\n      If dsn \u00ac= \"\" Then Do\n         dsn = Strip(Translate(dsn,\"\",\"'\"),\"B\")\n         Call Add_dsn_to_table\n         End\n      End i;\n   Return (\"\")\n\nValid_dsname:\n   Arg vdsn\n   Upper vdsn\n   Select\n      When Pos(\"'\",vdsn) > 0 Then Do\n         Parse Var vdsn \"'\" vdsn \"'\"\n         vdsn = \"'\"vdsn\"'\"\n         End\n      When Lastpos(\"(\",vdsn) > 0 Then Do\n         Parse Var vdsn \"(\" vdsn \")\"\n         End\n      Otherwise Return (\"\")\n      End /* End of Select ... */\n  vdsn = Space(vdsn,\n     Substr(\" )\",1+(Pos(\"(\",vdsn)>0 &,\n     (Left(vdsn,1)\u00ac=\"'\")),1),0)\n   Address \"TSO\"\n   If Listdsi(vdsn \"RECALL\") \u00ac= 0 Then,\n      If Listdsi(\"'\"vdsn\"'\" \"RECALL\") \u00ac= 0 Then Return (\"\")\n   If Pos(\"(\",vdsn) > 0 Then,\n      Parse Var vdsn \"(\" mem \")\"\n   Else mem = \"\"\n   Return (Space(\"'\"Sysdsname || Substr(\" (\",1+(Length(mem)>0),1) ||,\n      mem || Substr(\" )\",1+(Length(mem)>0),1)\"'\",0))\n/********************************************************************/\n/*  Common routine for display a popup panel with no update.        */\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\n/********************************************************************/\nDispl_it:\n/* totaldsn = Right(totaldsn,2,\"0\")*/\n   Address \"ISPEXEC\"\n   parms = \"\"\n   Call ParseFl;\n   cc = 0\n   Do While cc = 0\n      If parms = \"\" Then Do\n         \"addpop column(20) row(4)\"\n         \"DISPLAY PANEL(EDFind)\"\n         cc = rc\n         \"rempop\"\n         If cc > 4 Then Return\n         End\n      Else Parse Upper var parms zcmd\n      opt = Wordpos(edfcmd,\"BR ED DE LV\")\n      opt = Word(\"BROWSE EDIT DELETE LV\",opt)\n      Select\n         When DATATYPE(ZCMD) = \"NUM\" Then Do\n            Call Browse_them\n            End\n         When zcmd = \"\" Then Nop\n         When  Sysdsn(\"'\"zcmd\"'\")  = \"OK\" Then Do\n            dsname = zcmd\n            Call Search_Browse_them\n            End\n         Otherwise Do  /* string To scan */\n            dsname = zcmd\n/*          Call ParseFl;*/\n            Call Search_Browse_them\n            End\n         End /* End of Select ... */\n      End\n   Return;\n\nParseFl:\n   Parse Upper var CopyF dsn01   dsn02  dsn03  dsn04  ,\n      dsn05  dsn06  dsn07  dsn08  dsn09  dsn10 ,\n      dsn11  dsn12  dsn13  dsn14 dsn15,\n      dsn16  dsn17  dsn18  dsn19  dsn20 ,\n      dsn21  dsn22  dsn23  dsn24 dsn25 ,\n      dsn26  dsn27  dsn28  dsn29  dsn30 ,\n      dsn31  dsn32  dsn33  dsn34 dsn35 ,\n      dsn36  dsn37  dsn38  dsn39  dsn40,\n      dsn41  dsn42  dsn43  dsn44 dsn45 dsn46 dsn47 dsn48 dsn49 dsn50,\n      dsn51  dsn52  dsn53  dsn54 dsn55 dsn56 dsn57 dsn58 dsn59 dsn60,\n      dsn61  dsn62  dsn63  dsn64 dsn65 dsn66 dsn67 dsn68 dsn69 dsn70,\n      dsn71  dsn72  dsn73  dsn74 dsn75 dsn76 dsn77 dsn78 dsn79 dsn80\n   Return\n\nSearch_browse_them:\n   If Search_word() = 0 Then Call Browse_them\n   Else Do\n      zedsmsg = \"Bad dsn selection..\"\n      zedlmsg = dsname \"is NOT in the LIST displayed below\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n      End\n   Return;\n\nEndpgm:\n   If subrou = \"YES\" Then Address ISREDIT \"End \"\n   Return\n\nSEARCH_Word:\n  x = Pos(dsname,CopyF)\n  If x > 0 Then Do\n     x1 = Word(Substr(CopyF,x),1)\n     zcmd = Wordpos(x1,copyf)\n/*   Call browse_them */\n     Return (0)\n     End\n   Return (4);\n\nBrowse_them:\n/*\n   zcmd = Right(zcmd,2,\"0\")\n   Interpret \"dsname = dsn\"zcmd\n*/\n   dsname = Word(copyf,zcmd)\n   zedsmsg = \"Dataset not found\"\n   If \u00acnocheck Then Do\n      If Sysdsn(\"'\"dsname\"'\")  \u00ac= \"OK\" Then Do;\n         \"setmsg Msg(ISRZ000)\";\n         Return ;\n         End\n      End\n   Else If Pos(\"<-\",dsname) > 0 Then Do;\n      \"setmsg Msg(ISRZ000)\";\n      Return ;\n      End\n   zedsmsg = edfcmd \"Done ...\"\n   Select\n      When edfcmd = \"LV\" Then Do\n         Address \"ISPEXEC\" \"CONTROL DISPLAY SAVE\"\n         Address \"TSO\"\n/*       \"CLS\"*/\n         \"LV  '\"dsname\"' ALL \"\n         Address \"ISPEXEC\" \"CONTROL DISPLAY RESTORE\"\n         End\n      When edfcmd = \"DE\" Then Do\n         Address \"ISPEXEC\" \"CONTROL DISPLAY SAVE\"\n         Address \"TSO\"\n         \"DELETE  '\"dsname\"' ALL \"\n         Address \"ISPEXEC\" \"CONTROL DISPLAY RESTORE\"\n         End\n      When edfcmd = \"BR\" | edfcmd = \"ED\" Then Do\n         Address \"ISPEXEC\" opt \"DATASET('\"dsname\"')\"\n         If rc \u00ac= 0 Then Do\n            zedsmsg = opt \"Not done..\"\n            zedlmsg = opt \"for \"dsname \"had a rc(\"rc\")..\"\n            End\n         Else Call QF_it dsname\n         End\n      Otherwise Nop\n      End /* End of Select ... */\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   Return\n\nQF_it:\n   Arg dsname;\n   Address \"ISPEXEC\" \"vget qfedit profile\"\n   x =  \"'\"dsname\"'\"\n   If Wordpos(x,qfedit) = 0 Then Do\n      qfedit = \"'\"dsname\"'\" qfedit\n      Address \"ISPEXEC\" \"vput qfedit profile\"\n      End\n   Return\n\nDo_catalyst:\n   Address \"TSO\"\n   \"ALLOC FI(DD1) DA(CNTL(@DIR)) SHR REUSE \"\n   \"EXECIO * DISKW DD1   (STEM DSN. FINIS  \"\n   \"FREE FI(DD1) \"\n   ppdsn2 = \"Y\";\n   lpt3 = \"Y\";\n   ftm = \"\";\n   pdsn2=\"CNTL(@DIR)\"\n   Address \"ISPEXEC\"\n   \"VPUT (PPDSN2 LPT3 FTM pdsn2) PROFILE \"\n   Call  Catalyst\n   Return\n\nInitialize:\n   \"PROCESS RANGE X\"\n   \"(rcmd) = RANGE_CMD\"\n   Select\n      When rcmd = \"X\" Then Do\n         \"(firstlin) = Linenum .ZFRANGE\"\n         \"(lastline)  = Linenum .ZLRANGE\"\n         End\n      Otherwise Do\n         \"(LCRS CCRS) = CURSOR\"\n         \"(NAME) = LINE .ZCSR\"\n         firstlin = lcrs\n         End\n       End /* End of Select ... */\n   If opt = \"\"  & nocheck = \"\" Then Do\n      subrou  =  \"YES\"\n      Address \"ISPEXEC\" \"VGET (opt nocheck ) SHARED  \"\n      End\n   Address \"ISPEXEC\" \"CONTROL ERRORS Return\"\n   nocheck = 0\n   Upper   opt\n   Upper   nocheck\n   If Abbrev(nocheck,\"NO\",2) > 0 Then nocheck = 1\n   opt = Left(Opt,1)\n   opt# = Wordpos(opt,\"B C E L\") + (Wordpos(opt,\"B C E L\") = 0)\n   opt  = Word(\"BROWSE C EDIT LV\",opt#)\n   \"(DSNAME) = DATASET\"\n   \"(MEM)    = MEMBER \"\n   dsname_w = Translate(dsname,\"\",\".\")\n   crnames = \"CLIST REXX SYSPROC SYSEXEC PDFCLIB ISPCLIB\"\n   clist_rexx = 0+(Wordpos(Word(dsname_w,Words(dsname_w)),crnames)>0)\n   If mem \u00ac= \"\" & mem \u00ac= \"MEMBER\" Then\n      dsname = dsname\"(\"Space(mem,0)\")\"\n   If opt = \"C\" Then Do\n      catalyst = 1\n      Call Catalyst_msgs\n      End\n   Else Do\n      dsn. = \"\"\n      dsn.0 = 0\n      catalyst = 0\n      End\n/*\n   If  opt = \"L\"            Then opt = \"LV \"\n   Else If  opt =  \"C\" Then opt = \"C\"\n   Else If opt = \"E\"  Then opt = \"EDIT \"\n   Else opt = \"BROWSE \"\n*/\n   x = Msg(OFF)\n   dash = \"----\"\n   Return;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDFIND": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x16\\x06\\x00\\xc4\\x00\\xc4\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xd5\\xc3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T16:06:00", "lines": 196, "newlines": 196, "modlines": 0, "user": "RIAP-NC"}, "text": ")ATTR DEFAULT(%+_)\n% TYPE(TEXT) INTENS(HIGH)\n+ TYPE(TEXT) INTENS(LOW)\n_ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n` TYPE(TEXT) INTENS(HIGH) CAPS(ON) COLOR(yellow)\n! TYPE(TEXT) INTENS(HIGH) CAPS(OFF) COLOR(TURQ) HILITE(USCORE)\n\u00a2 TYPE(output) INTENS(HIGH) CAPS(OFF) COLOR(TURQ) HILITE(USCORE)\n~ area(scrl)\n)BODY EXPAND(\\\\) WINDOW(60,18)\n%Select ===>_ZCMD \\ \\ +\n+\n+(Enter a number) \\ \\!PF7/8+Scroll!PF3+End+\n+EDF option:_z +(!BR+browse!ED+Edit!DE+Delete!LV+ListV )\n+All dataset names fully qualifiy, no quote. Count:\u00a2z +\n~scrarea  \\ \\~\n~         \\ \\~\n~         \\ \\~\n~         \\ \\~\n~         \\ \\~\n~         \\ \\~\n~         \\ \\~\n~         \\ \\~\n~         \\ \\~\n~         \\ \\~\n~         \\ \\~\n+Note: Use EDF NOCHECK to bypass dataset checking step.\n+A Program Products Service\n)area scrarea\n` 1_DSN01 \\ \\+\n` 2_DSN02 \\ \\+\n` 3_DSN03 \\ \\+\n` 4_DSN04 \\ \\+\n` 5_DSN05 \\ \\+\n` 6_DSN06 \\ \\+\n` 7_DSN07 \\ \\+\n` 8_DSN08 \\ \\+\n` 9_DSN09 \\ \\+\n`10_DSN10 \\ \\+\n`11_DSN11 \\ \\+\n`12_DSN12 \\ \\+\n`13_DSN13 \\ \\+\n`14_DSN14 \\ \\+\n`15_DSN15 \\ \\+\n`16_DSN16 \\ \\+\n`17_DSN17 \\ \\+\n`18_DSN18 \\ \\+\n`19_DSN19 \\ \\+\n`20_DSN20 \\ \\+\n`21_DSN21 \\ \\+\n`22_DSN22 \\ \\+\n`23_DSN23 \\ \\+\n`24_DSN24 \\ \\+\n`25_DSN25 \\ \\+\n`26_DSN26 \\ \\+\n`27_DSN27 \\ \\+\n`28_DSN28 \\ \\+\n`29_DSN29 \\ \\+\n`30_DSN30 \\ \\+\n`31_DSN31 \\ \\+\n`32_DSN32 \\ \\+\n`33_DSN33 \\ \\+\n`34_DSN34 \\ \\+\n`35_DSN35 \\ \\+\n`36_DSN36 \\ \\+\n`37_DSN37 \\ \\+\n`38_DSN38 \\ \\+\n`39_DSN39 \\ \\+\n`40_DSN40 \\ \\+\n`41_DSN41 \\ \\+\n`42_DSN42 \\ \\+\n`43_DSN43 \\ \\+\n`44_DSN44 \\ \\+\n`45_DSN45 \\ \\+\n`46_DSN46 \\ \\+\n`47_DSN47 \\ \\+\n`48_DSN48 \\ \\+\n`49_DSN49 \\ \\+\n`50_DSN50 \\ \\+\n`51_DSN51 \\ \\+\n`52_DSN52 \\ \\+\n`53_DSN53 \\ \\+\n`54_DSN54 \\ \\+\n`55_DSN55 \\ \\+\n`56_DSN56 \\ \\+\n`57_DSN57 \\ \\+\n`58_DSN58 \\ \\+\n`59_DSN59 \\ \\+\n`60_DSN60 \\ \\+\n`61_DSN61 \\ \\+\n`62_DSN62 \\ \\+\n`63_DSN63 \\ \\+\n`64_DSN64 \\ \\+\n`65_DSN65 \\ \\+\n`66_DSN66 \\ \\+\n`67_DSN67 \\ \\+\n`68_DSN68 \\ \\+\n`69_DSN69 \\ \\+\n`70_DSN70 \\ \\+\n`71_DSN71 \\ \\+\n`72_DSN72 \\ \\+\n`73_DSN73 \\ \\+\n`74_DSN74 \\ \\+\n`75_DSN75 \\ \\+\n`76_DSN76 \\ \\+\n`77_DSN77 \\ \\+\n`78_DSN78 \\ \\+\n`79_DSN79 \\ \\+\n`80_DSN80 \\ \\+\n)INIT\n.cursor = zcmd\n&ZWINTTL= 'Edit Find Selections'\n.zvars = '(edfcmd totaldsn)'\n)REINIT\n&ZCMD = &z\n)PROC\n&zedsmsg = 'Invalid option'\n&zedlmsg = 'Select from the list of values'\n.cursor  = edfcmd\nVer (&edfcmd,LIST,BR,ED,DE,LV,msg=isrz000)\n&zedsmsg = '&zcmd>&totaldsn'\n&zedlmsg = 'Select a file for 1 to &totaldsn'\n.cursor = zcmd\nIf (&zcmd \u00ac= &z)\n   If (&zcmd > &totaldsn)\n      Ver(&zcmd,alpha,msg=isrz000)\nVER (&DSN01 DSNAME)\nVER (&DSN02 DSNAME)\nVER (&DSN03 DSNAME)\nVER (&DSN04 DSNAME)\nVER (&DSN05 DSNAME)\nVER (&DSN06 DSNAME)\nVER (&DSN07 DSNAME)\nVER (&DSN08 DSNAME)\nVER (&DSN09 DSNAME)\nVER (&DSN10 DSNAME)\nVER (&DSN21 DSNAME)\nVER (&DSN22 DSNAME)\nVER (&DSN23 DSNAME)\nVER (&DSN24 DSNAME)\nVER (&DSN25 DSNAME)\nVER (&DSN26 DSNAME)\nVER (&DSN27 DSNAME)\nVER (&DSN28 DSNAME)\nVER (&DSN29 DSNAME)\nVER (&DSN30 DSNAME)\nVER (&DSN31 DSNAME)\nVER (&DSN32 DSNAME)\nVER (&DSN33 DSNAME)\nVER (&DSN34 DSNAME)\nVER (&DSN35 DSNAME)\nVER (&DSN36 DSNAME)\nVER (&DSN37 DSNAME)\nVER (&DSN38 DSNAME)\nVER (&DSN39 DSNAME)\nVER (&DSN40 DSNAME)\nVER (&DSN41 DSNAME)\nVER (&DSN42 DSNAME)\nVER (&DSN43 DSNAME)\nVER (&DSN44 DSNAME)\nVER (&DSN45 DSNAME)\nVER (&DSN46 DSNAME)\nVER (&DSN47 DSNAME)\nVER (&DSN48 DSNAME)\nVER (&DSN49 DSNAME)\nVER (&DSN50 DSNAME)\nVER (&DSN51 DSNAME)\nVER (&DSN52 DSNAME)\nVER (&DSN53 DSNAME)\nVER (&DSN54 DSNAME)\nVER (&DSN55 DSNAME)\nVER (&DSN56 DSNAME)\nVER (&DSN57 DSNAME)\nVER (&DSN58 DSNAME)\nVER (&DSN59 DSNAME)\nVER (&DSN60 DSNAME)\nVER (&DSN61 DSNAME)\nVER (&DSN62 DSNAME)\nVER (&DSN63 DSNAME)\nVER (&DSN64 DSNAME)\nVER (&DSN65 DSNAME)\nVER (&DSN66 DSNAME)\nVER (&DSN67 DSNAME)\nVER (&DSN68 DSNAME)\nVER (&DSN69 DSNAME)\nVER (&DSN70 DSNAME)\nVER (&DSN71 DSNAME)\nVER (&DSN72 DSNAME)\nVER (&DSN73 DSNAME)\nVER (&DSN74 DSNAME)\nVER (&DSN75 DSNAME)\nVER (&DSN76 DSNAME)\nVER (&DSN77 DSNAME)\nVER (&DSN78 DSNAME)\nVER (&DSN79 DSNAME)\nVER (&DSN80 DSNAME)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDLIST": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00?\\x00?\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "RIAP-FB"}, "text": "/* Getdlist ************************************************** Rexx */\n/*   Created By: IAPPINI,R.                                         */\n/*   When: 02/22/93                                                 */\n/*   What: Getdlist, a REXX exec, returns via the RESULT variable   */\n/*         datasets cataloged by a generic qualifier.               */\n/*  Input: stem_name and a dataset qualifier (q1.q2*.g3*)           */\n/*                                                                  */\n/*                                                                  */\n/********************************************************************/\nGetdlist:\nAddress \"TSO\"\nTrace \"OFF\"\nIf Arg() > 1 Then Do\n   p1 = \"\"\n   Do i = 1 By 1 To Arg()\n      p1 = p1 Arg(i)\n      End i\n   End\nElse Arg p1\nproc_stat = \"PROC 2 STEM_NAME QUALIFIER\"\noptions = \"FULLSCREEN\"\nCall Proctso p1,proc_stat options\nInterpret result\nCall Process_main\nIf fullscreen \u00ac= \"\" Then Do\n   Interpret get_list\n   Call Stemdisp \"BROWSE\",stem_name,,,\"Dataset list for\",\n      \"Qualifier(\"qualifier\")\" Date() Time()\n   Exit\n   End\nElse Return (get_list)\n\nProcess_main:\n   Parse Source environment function exec_name whatdd whatdsn exec_cur,\n      env_default env_type supplied_name\n   If Sysvar(Sysispf) \u00ac= \"ACTIVE\" Then Do\n      \"ISPF CMD(%\"exec_name p1\")\"\n      Exit\n      End\n\n   Address ISPEXEC\n   Call Get_member_list\n   Return;\n\nGet_member_list:\n   If Right(qualifier,1) \u00ac= \"*\" Then qualifier = qualifier\"*\"\n   stem_name = Strip(Translate(stem_name,\"\",\"'\"\"\"),\"B\")\n   If Right(stem_name,1) \u00ac= \".\" Then stem_name = stem_name\".\"\n   \"LMDINIT LISTID(DD1ID) LEVEL(\"qualifier\") \"\n   lastcc = rc\n   dsn=\"\"\n   ndsns = 0\n   get_list = \"\"\n   \"LMDLIST LISTID(\"DD1ID\") STATS(NO) OPTION(LIST) DATASET(DSN)\"\n    lastcc = rc\n   Do i = 1 By 1 While lastcc = 0\n       get_list = get_list stem_name || i\" = '\"dsn\"';\"\n      \"LMDLIST LISTID(\"DD1ID\") STATS(NO) OPTION(LIST) DATASET(DSN)\"\n       lastcc = rc\n       End i /* end rc  */\n   get_list = get_list stem_name || \"0 = \"i-1\";\"\n   \"LMDFREE LISTID(\"DD1ID\") \"\n   Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "G2JDATE": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\'\\x1f\\x00\\x93\\'\\x1f\\x16\\x06\\x00\"\\x00\"\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xd5\\xc3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T16:06:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "RIAP-NC"}, "text": "/* G2JDate date ********************************************** REXX */\n/* Convert Gregorian date To Julian date                            */\n/* Program By CT Tran Program Products    X4506          4/91       */\n/* This is a Rexx function executable as                            */\n/*  Jdate = g2jdate(12/12/91)   The julian YYDDD is   in Jdate      */\n/* Similar function: J2Gdate                                        */\n/********************************************************************/\n/*   Modified By: IAPPINI,R.                                        */\n/*   When: 09/23/92                                                 */\n/*   What: Added Return(0) if an invalid date is specified.         */\n/*                                                                  */\nG2JDate:\nParse Arg edate\ndate = Translate(edate,\" \",\"/.-\",\" \")\nParse Var date mo da yr\n\nIf mo = '' | da = '' | yr = '' |,\n   mo = 0  | da = 0            Then Do\n   Say \"date(\"edate\") must be in form MM/DD/YY\",\n       \"and must contain non-zero values for mm and dd.\"\n   Return(0);\n   End\n\nx = \"0 31 59 90 120 151 181 212 243 273 304 334 365\"\nxyr = Right(yr,2)\ndays_in_month = Word(x,mo+1) - Word(x,mo) + (xyr-xyr%4*4 = 0 & mo = 2)\nIf da > days_in_month Then Do\n   Say edate \"Invalid; the day, \"da\", is greater than the month's,\",\n       days_in_month'.'\n   Return (0);\n   End;\nday = da  + Word(x,mo) + (xyr-xyr%4*4 = 0 & mo > 2)\n\nReturn (yr || Right(day,3,'0'))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HELPIDM": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00\\x08\\x00\\x08\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "RIAP-FB"}, "text": "/* HELPID Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx */\nAddress 'TSO'\nArg p1\nAddress \"ISREDIT\"\n\"MACRO \"\nAddress \"TSO\" \"ACFVPUTT\"\nrexxline = \")) Modified by \"acfname \"on \"Date() \"at \"Time()\n' LINE_BEFORE .zlast = \"'rexxline '\"'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HELPIDS": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00&\\x00&\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "RIAP-FB"}, "text": "/* HELPIDS Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx */\nAddress 'TSO'\nArg p1\nAddress \"ISREDIT\"\n\"MACRO \"\nTrace \"OFF\"\n\"NULLS ON\"\n\"CAPS OFF\"\n\"RESET\"\nCall Set_text_lines\nDo j = 1 By 1 To text.0\n   y = j-1\n   ' LINE_after' y' = \"'text.j '\"'\n   End j\n\"HELPID\"\nExit\n/* Subroutines reside at the bottom */\nLine_text:\n   Arg rexxline\n   ' LINE_after j      = \"'rexxline '\"'\n   Return;\nSet_text_lines:\n   Address \"TSO\" \"ACFVPUTT\"\n   \"(mbr) = Member\"\n   text.1  = \")F Description\"\n   text.2  = \"   \"mbr \"is ...\"\n   text.3  = \"  \"\n   text.4  = \")X Function\"\n   text.5  = \"   \"mbr \"options\"\n   text.6  = \" \"\n   text.7  = \"   Required: None\"\n   text.8  = \"   Defaluts: None\"\n   text.9  = \" \"\n   text.10 = \")O Options\"\n   text.11 = \"))option1   - Descriptive text.\"\n   text.9  = \" \"\n   text.0 = 12\n   Return;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IMBED": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00.\\x00.\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "RIAP-FB"}, "text": "/* IMBED ***************************************************** Rexx */\n/*   Modified By: IAPPINI,R.                                        */\n/*   When: 07/08/93                                                 */\n/*   What: IMBED, an Edit Macro (SHARE Ii84), is similar to COPY.   */\n/*         All lines are excluded execept the new lines.            */\n/********************************************************************/\nAddress \"TSO\"                            /*                           */\nTrace \"OFF\"                              /*                           */\nAddress \"ISREDIT\"                        /*                           */\n\"MACRO (member)\"                         /*                           */\nIf member = \"\" Then Do                   /*                           */\n   zedsmsg = \"No member name\"            /*                           */\n   zedlmsg = \"You must supply a member name to IMBED\"\n   Address \"ISPEXEC\" \"SETMSG MSG(ISRZ001)\"\n   Exit 4                                /*                           */\n   End;                                  /*                           */\n                                         /*                           */\n/* IMBED processing logic */             /*                           */\n\"(cl,cc) = CURSOR\"                       /* Get cursor position       */\n                                         /*                           */\nIf cl < 0 Then,                          /*                           */\n   \"(cl) = LINENUM .zl\"                  /* Els Get last line if at 0 */\n\"EXCLUDE ALL\"                            /*                           */\n\"(es,el) = Exclude_counts\"               /* Exclude lines             */\n                                         /* Create member id line     */\n\"LINE_AFTER \"cl\"= 'Member: \"member Date() Time()\"'\"\nfl = cl+1                                /*                           */\n\"Label \"cl+2\" = .imend\"                  /* Set ending label          */\n\"COPY AFTER \"cl+1 member                 /* copy member to end        */\n\"(newll) = Linenum .imend\"               /*                           */\nIf cl      = newll Then Exit 8           /*                           */\n                                         /*                           */\n                                         /*****************************/\n                                         /* Shift IMBEDded .im lines  */\n                                         /* eight bytes right         */\n                                         /*****************************/\n\"LABEL \"cl+1\" = .FIRST\"                  /* Point to first insert     */\n                                         /*                           */\n\"FIND FIRST '.IM' 1 .first .zl\"          /* Any .im lines             */\nIf rc \u00ac= 0 Then Exit                     /*                           */\n                                         /*                           */\nDo i = fl+1 By 1 While i < newll         /* right 8                   */\n   \"SHIFT ) \"i \" 8\"                      /*                           */\n   End i                                 /*                           */\n/* Else \"RESET\" */                       /*                           */\nExit 0                                   /*                           */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JCEX": {"ttr": 1294, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x16\\x06\\x00/\\x00/\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xd5\\xc3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T16:06:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "RIAP-NC"}, "text": ")ATTR\n   \u00a2 TYPE(TEXT)    INTENS(LOW)  SKIP(ON)  CAPS(ON)    COLOR(RED)\n   % TYPE(TEXT)    INTENS(LOW)  SKIP(ON)  CAPS(ON)    COLOR(WHITE )\n   + TYPE(TEXT)    INTENS(HIGH) SKIP(ON)  CAPS(ON)    COLOR(BLUE  )\n   } TYPE(INPUT)   INTENS(LOW)  CAPS(ON)  PADC('_')    COLOR(WHITE)\n   _ TYPE(INPUT)   INTENS(LOW)  CAPS(ON)  PAD(' ')    COLOR(RED)\n   \u00ac TYPE(INPUT)   INTENS(LOW)  CAPS(ON)  PAD(' ')    COLOR(yellow)\n   | TYPE(INPUT)   INTENS(HIGH) CAPS(ON) JUST(ASIS) COLOR(YELLOW)\n   # TYPE(TEXT)    INTENS(LOW)  SKIP(ON)  CAPS(OFF)   COLOR(YELLOW)\n   @ TYPE(OUTPUT)  INTENS(HIGH) SKIP(ON)  CAPS(ON)    COLOR(WHITE )\n)BODY expand(//)\n\u00a2&JCTITLE                        %/-/\n+                                                                      +\n_JCL1                                                                  +\n_JCL2                                                                  +\n_JCL3                                                                  +\n_JCL4                                                                  +\n_JCL5                                                                  +\n_JCL6                                                                  +\n_JCL7                                                                  +\n_JCL8                                                                  +\n%/-/\n)INIT\n .ATTRChar('\u00a2') = 'TYPE(TEXT) COLOR(YELLOW) INTENS(LOW)'\n .ATTRChar('_') = 'TYPE(INPUT) COLOR(RED) INTENS(LOW)'\n IF (&TYPE = 'TEXT')\n    .ATTRChar('_') = 'TYPE(TEXT) COLOR(BLUE) INTENS(LOW)'\n IF (&TYPE = 'INPUT')\n    .ATTRChar('_') = 'TYPE(INPUT) COLOR(RED) INTENS(HIGH)'\n if (&JCL1 = '')\n    &JCL1 = &zllgjob1\n if (&JCL2 = '')\n    &JCL2 = &ZLLGJOB2\n if (&JCL3 = '')\n    &JCL3 = &ZLLGJOB3\n if (&JCL4 = '')\n    &JCL4 = &ZLLGJOB4\n if (&JCL5 = '')\n    &JCL5 = '//*'\n if (&JCL6 = '')\n    &JCL6 = '//*'\n if (&JCL7 = '')\n    &JCL7 = '//*'\n if (&JCL8 = '')\n    &JCL8 = '//*'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "J2GDATE": {"ttr": 1296, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00'\\x00'\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "RIAP-FB"}, "text": "/* J2GDate date ********************************************** REXX */\n/* Convert Julian date  To Gregorian?date yy.ddd -> yy/mm/dd        */\n/* Program By CT Tran PPD group         X4506          4/91         */\n/* This is a Rexx function executable as                            */\n/*  Jdate = J2Gdate 91.118  result in JDATE 04/28/91                */\n/* Companion function: G2Jdate                                      */\n/********************************************************************/\n/*   Modified By: IAPPINI,R.                                        */\n/*   When: 09/23/92                                                 */\n/*   What: Added parameter MMDDYY to return the date in mm/dd/yy    */\n/*         format.                                                  */\n/********************************************************************/\nJ2GDate:\nIf Arg() > 1 Then p1 = Arg(1) Arg(2)\nElse Parse Arg p1\nproc_stmt = 'PROC 1 DATE MMDDYY'\nCall Proctso p1,proc_stmt\nInterpret result\nxdate = Translate(date,\" \",\"./-\")\nIf Words(xdate) > 1 Then Parse Var xdate year dday\nElse Do\n  year = Left(date,Length(date)-3)\n  dday = Right(date,3)\n  End\nIF dday = '' Then Do\n   Say Argument must be in Julian form YY.DDD\n   Exit\n  End\nmo = 1 + (dday%30.416 )  /* ????? */\nIf Length(year) = 4 Then year = Right(year,2)\nx = \"0 31 59 90 120 151 181 212 243 273 304 334 365\"\nday = dday - (Word(x,mo) + (year-year%4*4 = 0 & mo > 2) )\nIf day = 0 Then Do\n   mo = mo -1\n   day = dday - (Word(x,mo) + (year-year%4*4 = 0 & mo > 2) )\n   End\nIf mmddyy \u00ac= \"\" Then,\n   Return (Right(mo,2,'0')'/'Right(day,2,'0')'/'year)\nElse Return (year'/'Right(mo,2,'0')'/'Right(day,2,'0'))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KEYWORDV": {"ttr": 1298, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00g\\x00g\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "RIAP-FB"}, "text": "/* KEYWORDV*************************************************** Rexx */\n/*   Created By: IAPPINI,R.                                         */\n/*   When: 02/02/93                                                 */\n/*   What: KEYWORDV, a REXX exec, that will return a VALUE          */\n/*         associated with a specified KEYWORD.                     */\n/*                                                                  */\n/*         The VALUE will be a null, the keyword name, or the       */\n/*         contents to the Right of an = sign and/or data bounded   */\n/*         by parenthesises.                                        */\n/*                                                                  */\n/*   Options:                                                       */\n/*         1. the KEYWORD                                           */\n/*         2. the WORD string to SEARCH                             */\n/*                                                                  */\n/********************************************************************/\nAddress \"TSO\"\nKeywordv:\nTrace  \"OFF\"\nIf Arg() = 1 Then Parse Arg match against\nElse Parse Arg match, against\nUpper match\nIf Length(against) = 0 Then Return(\"\")\n#keyw = Words(against)\nIf #keyw = 0 Then Return(\"\")\nCall Parsetok against,\"TOK.\",\"(=)',\",\"B\"\nDo i = 1 By 1 To tok.0\n   t_m = Translate(tok.i)  /* Change to UPPER case for keyword match */\n   If Abbrev(match,t_m) Then Do\n      Call Get_keyword_value\n      Return (result)\n      End\n   Else Do\n      Call Get_keyword_value /* Position on Next keyword */\n      j = i + 1\n      If tok.j \u00ac= \",\" Then i = i - 1\n      End\n   End i\n   Return (\"\") /* KEYWORD not found */\n\nGet_keyword_value:\n   value = \"\"\n   i = i + 1\n   Select\n      When tok.i = \"=\" Then Call Value_equal\n      When tok.i = \"(\" Then Call Value_paren\n      When tok.i = \"'\" Then Call Value_quote\n      Otherwise Return (match)\n      End /* End of Select ... */\n   Return (result) /* KEYWORD not found */\n\nValue_equal: /* Syntax: keyword = */\n   Do i = i + 1 By 1 To tok.0\n   Select\n      When tok.i = \"'\" Then Call Value_quote\n      When tok.i = \"(\" Then Call Value_paren\n      Otherwise Return (tok.i)\n      End /* End of Select ... */\n   Return (result)\n\n\nVaLue_paren:  /* Syntax: keyword=() | keyword() */\n   open = 1   /* must have found at least 1 open parenthesis */\n   value = \"\"\n   Do i = i + 1 By 1 To tok.0\n      Select\n         When tok.i = \")\" Then Do\n            open = open - 1\n            If open = 0 Then Return (value)\n            End\n         When tok.i = \"(\" Then open = open + 1\n         Otherwise Nop\n         End /* End of Select ... */\n      value = value || tok.i\n      End i\n   Return (value)\n\nVaLue_quote:  /* Syntax: keyword=' ' | keyword' ' */\n   open = 1   /* must have found at least 1 open quote       */\n   value = \"\"\n   Do i = i + 1 By 1 To tok.0\n      tok_1 = tok.i\n      k = i + 1     /* next token */\n      tok_2 = tok.k\n      Select\n         When tok_1 || tok_2 = \"''\" Then Do\n            value = value\"''\"  /* add in first quote */\n            i = k             /* Set index for the second quote */\n            End\n         When tok_1 = \"'\" Then Do\n            open = open - 1\n            If open = 0 Then Return (value)\n            Else Do\n               If tok_1 = \" \" Then value = value\" \"\n               Else value = value || tok.i\n               End\n            End\n         Otherwise Do\n            If tok_1 = \" \" Then value = value\" \"\n            Else value = value || tok.i\n            End\n         End /* End of Select ... */\n      End i\n   Return (Strip(value,\"B\"))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LCOM": {"ttr": 1301, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00\\x08\\x00\\x08\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "RIAP-FB"}, "text": "/* REXX ** REXX ** REXX ** REXX ** REXX ** REXX ** REXX ** REXX */\nADDRESS 'ISREDIT'\n\" MACRO (DATA) \"\n\" (ROW,COL) = CURSOR\"\nNCSR = Row\n\"LINE \"ROW\" =<40 '/*\"DATA\"'\" 70 \"'*/'>\"\n\" CURSOR = \"ROW  \"42\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTDD": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00<\\x00<\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "RIAP-FB"}, "text": "/* LISTDD **************************************************** Rexx */\n/*   Created by: IAPPINI,R.                                         */\n/*   When: 12/08/92                                                 */\n/*   What: LISTDD is a Rexx EXEC dialog to ...                      */\n/*         emulate WHATLIB# using only TSO/E services.              */\n/********************************************************************/\nListdd:\nAddress 'TSO'\nParse Source environment .  exec_name .\nTrace \"OFF\"\nArg r_ddname r_dsns r_vols  .\nIf r_dsns = \"\" Then Return (\"rc = 24;\")\n/*                                                                    */\n@tcb = Storage(21c,4);                   /*get tcb address from PSAOLD*/\n@tiot = Storage(D2x(C2d(@tcb)+12),4);    /* add 12 to TIOT address */\n@1stdd = D2x(C2d(@tiot)+28);             /* point to 1st DD in TIOT*/\n@1stddlen = Storage(D2x(C2d(@tiot)+24), 1);/* get 1st length */\n@tiot = D2x(C2d(@tiot)+24);              /* point to 1st TIOT DDNAME */\n@jfcb = Storage(D2x(X2d(@tiot)+12),3);   /* get JFCB address from TIOT*/\nfound = 0;\nll_dsns = '';\nll_vols = '';\n/*                                                                    */\nDO while C2d(@1stddlen) \\=0 /* loop through entire TIOT */\n   If Storage(@1stdd,1)/=\"00\"x then Do\n      ddname = Storage(@1stdd,8)\n      If \u00acfound Then,\n      If ddname = r_ddname Then found = 1\n      If found Then Do\n         volser =  Storage(D2x(C2d(@jfcb)+134),6)\n         dsn    =  Storage(D2x(C2d(@jfcb)+16),44)\n         Select\n            When ddname = \" \" Then Do\n               ll_dsns =  ll_dsns dsn\n               ll_vols =  ll_vols volser\n               End\n            When ddname = r_ddname  Then Do\n               ll_dsns = ll_dsns dsn\n               ll_vols =  ll_vols volser\n               End\n            Otherwise Do\n              rc =  Words(ll_dsns)\n              rc = \"rc = 0;\"r_dsns\" = '\"\n              If r_vols \\= \"\" Then,\n                 Return (rc lldsns\"';\"r_vols\" = '\"ll_volser\"';\")\n              Else Return (rc Space(ll_dsns)\"';\")\n              End                       /* End of Otherwise ...  */\n           End                          /* End of Select  ... */\n         End                            /* End of If found ... */\n      End                                  /* End of If Storage ... */\n   @tiot = D2x(X2d(@tiot)+C2d(@1stddlen )) /*point to next TIOT  entry*/\n   @1stddlen = Storage(@tiot,1)            /*get length of TIOT entry */\n   @1stdd = D2x(X2d(@tiot)+4)              /* point at DDname in TIOT */\n   @jfcb = Storage(D2x(X2d(@tiot)+12),3)   /* get next JFCB address */\n   End                                     /* End of Do While ... */\nIf Words(ll_dsns) = 0 Then rc = \"rc = 4;\" /* must not be allocated */\nElse rc = \"rc = 0;\"\nIf r_vols \\= \"\" Then,\n   Return (rc r_dsns\" = '\"lldsns\"';\"r_vols\" = '\"ll_volser\"';\")\nElse Return (rc r_dsns\" = '\"Space(ll_dsns)\"';\")\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTMMI": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00\\x19\\x00\\x19\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "RIAP-FB"}, "text": "/* LISTMMI *************************************************** Rexx */\n/*   Created by: IAPPINI,R.                                         */\n/*   When: 11/23/92                                                 */\n/*   What: LISTMMI is a Rexx EXEC that will list the members of a   */\n/*         PDS (re. GHASPIN Nov 1992, Vol.No.Lvl 3.6.1).            */\n/********************************************************************/\nAddress 'TSO'\nArg p1\nAddress \"ISPEXEC\"\nx = Time(\"E\")\n\"LMINIT DATAID(PDS) DATASET(\"p1\")\"\n\"LMOPEN DATAID(\"pds\") OPTION(INPUT)\"\nmem = \"\"\n\"LMMLIST DATAID(\"pds\") OPTION(LIST) MEMBER(MEM)\"\nDo i = 1 By 1 While rc = 0\n   cmem.i = mem\n   \"LMMLIST DATAID(\"pds\") OPTION(LIST) MEMBER(MEM)\"\n   End i\n\"LMMLIST DATAID(\"pds\") OPTION(FREE) MEMBER(MEM)\"\n\"LMCLOSE DATAID(\"pds\")\"\n\"LMFREE  DATAID(\"pds\")\"\ncemm.0 = i\nsd_msg = \"Dataset(\"p1\") contains \"i \"members.\"\nSay \"Elapsed time \"Time(\"E\")\nCall Stemdisp \"BROWSE\",\"cmem.\",,,sd_msg\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTMMT": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "RIAP-FB"}, "text": "/* LISTMMT *************************************************** Rexx */\n/*   Created by: IAPPINI,R.                                         */\n/*   When: 11/23/92                                                 */\n/*   What: LISTMMT is a Rexx EXEC that will list the members of a   */\n/*         PDS (re. GHASPIN Nov 1992, Vol.No.Lvl 3.6.1).            */\n/********************************************************************/\nAddress 'TSO'\nArg p1\nx = Time(\"E\")\nx = Outtrap(\"TSO.\")\n\"LISTDS (\"p1\") MEMBERS\" /* get member list from LISTD command */\nx = Outtrap(\"OFF\")\nmem# = 0\nmemflag = 0\nDo i = 1 By 1 To tso.0\n   Select\n      When memflag Then Do\n         mem# = mem# + 1\n         tso.mem# = Word(tso.i,1)\n         End\n      When Pos(\"--MEMBERS--\",tso.i) > 0 Then memflag = 1\n      Otherwise Nop\n      End /* End of Select ... */\n   End i\nSay \"Elapsed time \"Time(\"E\")\ntso.0 = mem#\nsd_msg = \"Dataset(\"p1\") contains \"mem# \"members.\"\nmem# = mem# + 1\ntso.mem# = \"\"\nCall Stemdisp \"BROWSE\",\"tso.\",,,sd_msg\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LLDSNS": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00\\x16\\x00\\x16\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "RIAP-FB"}, "text": "/* LLDSNS **************************************************** Rexx */\n/*   Created by: IAPPINI,R.                                         */\n/*   When: 12/08/92                                                 */\n/*   What: LLDSNS is a Rexx EXEC dialog to return a string of       */\n/*         of dataset names for a specified ddname.                 */\n/********************************************************************/\nLldsns:\nAddress 'TSO'\nArg p1\nArg p1\ndebug = Keywordv('DEBUG',p1)\nIF debug \u00ac= '' Then Trace ?I\n@cvt  = Storage(D2X(16),4)             /* CVT pointer */\n@ll   = Storage(D2X(C2D(@cvt)+1244),4)  /* Link List pointer */\n@1stdd = D2X(C2D(@ll)+9)\nll_dsns = ''\nDo count = 0 By 1 While Datatype(Storage(@1stdd),'M')\n   ll_dsns = ll_dsns Storage(@1stdd,44)\n   @1stdd  = D2X(X2D(@1stdd)+45)\n   End count\nrc = count\nReturn (Space(ll_dsns))\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOGMSG": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00*\\x00*\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "RIAP-FB"}, "text": "/* LOGMSG **************************************************** Rexx */\n/*   Created By: IAPPINI,R.                                         */\n/*   When: 04/13/93                                                 */\n/*   What: LOGMSG inserts lines at the bottom after inserting       */\n/*         a time line .  Optional input first(1st) will insert     */\n/*         a dayofweek - Mon day - Name  line                       */\n/********************************************************************/\nAddress \"ISREDIT\"\n\"MACRO (PARMS)\"\nTrace \"OFF\"\n\"(row) = Linenum .zl\"\nIf row = 0 Then parms = \"FIRST\"\ntoday = Date(W)\n\"(PBNDS) = BNDS\"\n\"(lrecl) = LRECL\"\n\"BNDS = 1 \"lrecl\n\"SEEK \"today \"FIRST\"\n\"(s1,s2) = SEEK_COUNTS\"\nIf s1 = 0 Then parms = \"1ST\"\nIf Pos(Translate(parms),\"FIRST 1ST\") > 0 Then Do\n   \"(row) = Linenum .zl\"\n   Address \"TSO\" \"ACFVPUTT\"\n   rexxline = Left(today,10)\"-\",\n              Date(M) Substr(Date(U),4,2) \"-\",\n              Acfname\n   Call Line_after rexxline\n   End;\nCall Line_after Left(Time(),5) \"-\"\n\"BNDS = 9 \"lrecl-8\n\"NUM OFF\"\n\"CAPS OFF\"\n\"RESET\"\n\"TENTER .zl\"\n\"Cursor = \"Row \"09\"\n\"MEND\"\n\nLine_after:\n   Parse Arg xx\n   \" LINE_AFTER \"row\" = (xx)\"\n   If rc = 0 Then,\n       row = row + 1\n   Return;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOGUPDAT": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00 \\x00 \\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "RIAP-FB"}, "text": "/* LOGUPDAT Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx    */\n/*   Created By: IAPPINI,R.                                         */\n/*   When: 04/13/93                                                 */\n/*   What: LOGUPDAT allows easy editing of the Rotating SE          */\n/*      message log.                                                */\n/********************************************************************/\nAddress \"TSO\"\nTrace \"OFF\"\nArg p1\nIf p1 = \"\" Then,\n   dsname = \"CSD.BOBOPER.MESSAGE.LOG\"\nElse dsname = p1\ndaynames = \"TUESDAY WEDNESDAY THURSDAY\",\n           \"FRIDAY  SATURDAY  SUNDAY   MONDAY\"\n/* ***************************************************************** */\n/* Construct the Wyyddd member name                                  */\n/* Construct the dsn name to check                                   */\njul_tues = Calcdays(Date(U) \"12/31/\"Left(Date(O),2)) +,\n   Wordpos(Translate(Date(W)),daynames) - 1\nmember = \"W\"Left(Date(O),2) || jul_tues\ndsn = \"'\"dsname\"(\"member\")'\"\n/* ***************************************************************** */\nParse Source environment . exec_name .\nxx = Sysdsnri(dsn)\nInterpret xx\nIf rc > 3 Then Do\n   Say dsname sysdsn_msg\n   Say \"Terminating \"exec_name\n   Exit\n   End\nAddress \"ISPEXEC\"\n\"EDIT DATASET(\"DSN\") MACRO(LOGMSG)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MASK": {"ttr": 1549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00F\\x00F\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 70, "newlines": 70, "modlines": 0, "user": "RIAP-FB"}, "text": "/* MATCH ***************************************************** Rexx */\n/*   Created By: IAPPINI,R.                                         */\n/*   When: 02/17/93                                                 */\n/*   What: MATCH, a REXX Exec, is an EDIT macro copied from ESJ,    */\n/*         February 1993, that matches braces and parenthesises     */\n/********************************************************************/\nAddress \"TSO\"\nTrace \"OFF\"\nArg p1\nParse Source environment function exec_name whatdd whatdsn exec_cur,\n   env_default env_type supplied_name\n\"SUBCOM ISPEXEC\" /* Is ISPF active? */\nIf rc \u00ac= 0 Then Do\n   Say exec_name \"is an ISPF edit macro --- ISPF is not active\"\n   Exit 1\n   End\nAddress \"ISPEXEC\"\n\"CONTROL ERRORS RETURN\"\nAddress \"ISREDIT\"\n\"MACRO\"\nIf rc \u00ac= 0 Then Do\n   Say exec_name \"is an ISPF edit macro --- edit is not active\"\n   Exit 1\n   End\n\"(crow,ccol) = CURSOR\"      /* Get current cursor position */\nIf ccol = 0 Then Exit       /* in command or prefix area */\n\"CURSOR = \"crow ccol        /* Set default cursor position */\n\"(CLINE) = LINE\" crow       /* Get current line         */\nchar = Substr(cline,ccol,1) /* get character under cursor */\nnest = 0                    /* nesting level               */\ninc  = 0                    /* search direction/increment  */\n/* Set the target character and search direction           */\nsources  = \"{(})\"\ntargets  = \"}){(\"\nchar_ndx = Pos(char,sources)\nIf char_ndx = 0 Then Do\n   Say char \"is not a '\"sources\"'\"\n   Exit\n   End\ntarget   = Substr(targets,char_ndx,1)\nIf char_ndx < 3 Then inc =  1 /* \"NEXT\" */\nElse                 inc = -1 /* \"PREV\" */\n/* Scan until end of file reached            */\nDo i_row = 1 By 1 Until rc \u00ac= 0\n   /* Scan from current column to ending column */\n   If inc = 1 Then ecol = length(cline)\n   Else ecol = 1\n   Do i = ccol + 1 By inc to ecol\n      char2 = Substr(cline,i,1)\n      Select\n         When char2 = char Then nest = nest + 1 /* nested chars */\n         When char2 = target Then Do\n            If nest = 0 Then Do                 /* nested?      */\n               \"CURSOR = \"crow i                /* No!          */\n               \"XSTATUS \"crow \"= NX\"\n               Exit\n               End\n            Else nest = nest - 1         /* Yes, decrement nest */\n            End\n         Otherwise Nop\n         End /* End of Select ... */\n      End i\n   crow = crow + inc                     /* Adjust row number   */\n   \"(CLINE) = LINE\" crow                 /* get next line       */\n   If rc \u00ac= 0 Then Leave\n   /* Set new \"current\" column           */\n   If inc = 1 Then ccol = 1       /* Forward scan */\n   Else ccol = Length(cline)      /* Backward scan*/\n   End i_row\nExit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MASK1": {"ttr": 1551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00\\x17\\x00\\x17\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "RIAP-FB"}, "text": "/* MASKONE *************************************************** Rexx */\n/*   Created By: IAPPINI,R.                                         */\n/*   When: 02/22/93                                                 */\n/*   What: MASKONE, a Rexx Exec, that inserts a comment line        */\n/*         \"/*          ...        */\"                              */\n/********************************************************************/\n/*REXXID Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx */\nAddress \"ISREDIT\"\n\"MACRO NOPROCESS\"\nTrace \"OFF\"\n\"(col1,col2) = DISPLAY_COLS\"\n\"(mbr) = Member\"\n\"(row,col) = CURSOR\"\n \"PROCESS RANGE A B\"\n If rc >=16 Then Exit\n \"(cmd) = range_cmd \"\n \"(first) = linenum .zfrange\"\n \"(last) = linenum .zlrange\"\nxc = (col2-col1)-4\ncopyline = Copies(\" \",col1-1)\"/*\"Copies(\" \",xc)\"*/\"\nIf cmd = \"A\" Then i_cmd = \"LINE_AFTER\"\nElse              i_cmd = \"LINE_BEFORE\"\ni_cmd first\" = '\"copyline\"'\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MASK12": {"ttr": 1553, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "RIAP-FB"}, "text": "/* MASKONE *************************************************** Rexx */\n/*   Created By: IAPPINI,R.                                         */\n/*   When: 02/22/93                                                 */\n/*   What: MASKONE, a Rexx Exec, that inserts a comment line        */\n/*         \"/*          ...        */\"                              */\n/********************************************************************/\n/*REXXID Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx */\nAddress \"ISREDIT\"\n\"MACRO NOPROCESS\"\nTrace \"OFF\"\n\"(col1,col2) = DISPLAY_COLS\"\n\"(mbr) = Member\"\n\"(row,col) = CURSOR\"\n \"PROCESS RANGE A B\"\n If rc >=16 Then Exit\n \"(cmd) = range_cmd \"\n \"(first) = linenum .zfrange\"\n \"(last) = linenum .zlrange\"\nxc = (col2-col1)-4\ncopyline = Copies(\" \",col1-1)\"/*\"Copies(\" \",xc)\"*/\"\nIf cmd = \"A\" Then i_cmd = \"LINE_AFTER\"\nElse              i_cmd = \"LINE_BEFORE\"\ni_cmd first\" = '\"copyline\"'\"\ncopyline = Copies(\" \",col1-1)\"/* \"Copies(\"*\",xc-2)\" */\"\nfirst = first + 1\ni_cmd first\" = '\"copyline\"'\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MASK2": {"ttr": 1555, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00\\x17\\x00\\x17\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "RIAP-FB"}, "text": "/* MASKTWO *************************************************** Rexx */\n/*   Created By: IAPPINI,R.                                         */\n/*   When: 02/22/93                                                 */\n/*   What: MASKONE, a Rexx Exec, that inserts a comment line        */\n/*         \"/* ******************* */\"                              */\n/********************************************************************/\n/*REXXID Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx */\nAddress \"ISREDIT\"\n\"MACRO NOPROCESS\"\nTrace \"OFF\"\n\"(col1,col2) = DISPLAY_COLS\"\n\"(mbr) = Member\"\n\"(row,col) = CURSOR\"\n \"PROCESS RANGE A B\"\n If rc >=16 Then Exit\n \"(cmd) = range_cmd \"\n \"(first) = linenum .zfrange\"\n \"(last) = linenum .zlrange\"\nxc = (col2-col1)-6\ncopyline = Copies(\" \",col1-1)\"/* \"Copies(\"*\",xc)\" */\"\nIf cmd = \"A\" Then i_cmd = \"LINE_AFTER\"\nElse              i_cmd = \"LINE_BEFORE\"\ni_cmd first\" = '\"copyline\"'\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MASK21": {"ttr": 1557, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "RIAP-FB"}, "text": "/* MASKTWO *************************************************** Rexx */\n/*   Created By: IAPPINI,R.                                         */\n/*   When: 02/22/93                                                 */\n/*   What: MASKONE, a Rexx Exec, that inserts a comment line        */\n/*         \"/* ******************* */\"                              */\n/********************************************************************/\n/*REXXID Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx */\nAddress \"ISREDIT\"\n\"MACRO NOPROCESS\"\nTrace \"OFF\"\n\"(col1,col2) = DISPLAY_COLS\"\n\"(mbr) = Member\"\n\"(row,col) = CURSOR\"\n \"PROCESS RANGE A B\"\n If rc >=16 Then Exit\n \"(cmd) = range_cmd \"\n \"(first) = linenum .zfrange\"\n \"(last) = linenum .zlrange\"\nxc = (col2-col1)-6\ncopyline = Copies(\" \",col1-1)\"/* \"Copies(\"*\",xc)\" */\"\nIf cmd = \"A\" Then i_cmd = \"LINE_AFTER\"\nElse              i_cmd = \"LINE_BEFORE\"\ni_cmd first\" = '\"copyline\"'\"\ncopyline = Copies(\" \",col1-1)\"/* \"Copies(\" \",xc)\" */\"\nfirst = first + 1\ni_cmd first\" = '\"copyline\"'\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MEMBYDD": {"ttr": 1559, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00\\x82\\x00\\x82\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 130, "newlines": 130, "modlines": 0, "user": "RIAP-FB"}, "text": "/* MEMBYDD *************************************************** Rexx */\n/*   Modified by: IAPPINI,R.                                        */\n/*   When: 01/28/93                                                 */\n/*   What: Added DATA option to return a string of DSN(member)      */\n/*         Changed list of member ddname processing                 */\n/********************************************************************/\n/* MEMBYDD *************************************************** Rexx */\n/*   Created by: IAPPINI,R.                                         */\n/*   When: 12/09/92                                                 */\n/*   What: MEMBYDD, a REXX exec, will determine if a member is      */\n/*         in a specified ddname.                                   */\n/*                                                                  */\n/* Input is entered in pairs, ie., member ddname |                  */\n/*   (member member ... member) ddname                              */\n/********************************************************************/\nMembydd:\nAddress 'TSO'\nTrace \"OFF\"\nArg p1\nCall Initialize\nCall Process_main\nIf data Then,\n   Return (\"rc=\"result\";ret_data='\"ret_data\"';\")\nElse Return (result)\n\nProcess_main:\n   xx = Get_ddname_list()\n   If xx \u00ac= 0 Then Do\n      If data Then Return(\"rc = 24;\") /* DDname not allocated */\n      Else Return(xx)\n      End\n   Call Process_member_list\n   Return (at_least_one_member_found)\n\nGet_ddname_list:\n   Do i_ddndx = 1 To Words(ddname)\n      ddn = Word(ddname,i_ddndx)\n      Call Listdd ddn \"DSNS\"\n      Interpret result\n      If rc \u00ac= 0 Then Do\n         If \u00acquiet Then Say \"DDname(\"ddn\") is not allocated\"\n         Return (4)\n         End\n      End i_ddndx\n   Return (0);\n\nProcess_member_list:\n   at_least_one_member_found = 4\n   Do i_memndx = 1 To Words(member_list) /* loop thru member_list */\n      found_member = 0\n      Call Process_sysdsn_output Word(member_list,i_memndx)\n      If \u00acfound_member Then,\n         If \u00acquiet Then,\n            Say \"Member(\"member\") not in DDname(\"ddn\").\"\n      End i_memndx\n   Return;\n\nProcess_sysdsn_output:\n   Arg pso_member\n   Do i_dsndx = 1 To Words(dsns)\n      dsn = Word(dsns,i_dsndx)\n      zz = Sysdsn(\"'\"dsn\"(\"pso_member\")'\")\n      If zz = \"OK\" Then Call Display_member_msg\n      End i_dsndx\n   Return;\n\nDisplay_member_msg:\n   If data Then,\n      ret_data = Space(ret_data,\n         Substr(dsn,1,Length(dsn))\"(\"pso_member\")\")\n   If \u00acquiet Then,\n      Say \"Member(\"pso_member\") is in DSname(\"dsn\"),\",\n          \"of DDname(\"ddn\"(\"i_dsndx\")).\"\n   found_member = 1\n   at_least_one_member_found = 0\n   Return;\n\nInitialize:\n   p1 = Space(p1)\n   proc_stmt = \"PROC 2 MEMBER DDNAME QUIET DATA\"\n   Call Proctso p1,proc_stmt\n   Interpret result\n   member_list = Strip(Translate(member,\"\",\"(',)\"),\"B\")\n   If ddname = \"\" Then Do\n      Say \"Invalid input was entered.\"\n      Say \"You entered \"p1\".\"\n      Say \"You must enter a member ddname or member list ddname\",\n          \"combination for this procedure.\"\n      Exit\n      End\n   If quiet = \"\" Then quiet = 0\n   Else quiet = 1\n   If data = \"\" Then data = 0\n   Else data = 1\n   ret_data = \"\"\n   Return;\n\n/*  SYSDSN return values\n OK                            /* data set exists */\n MEMBER NOT FOUND\n MEMBER SPECIFIED, BUT DATA SET IS NOT PARTITIONED\n DATA SET NOT FOUND\n ERROR PROCESSING REQUESTED DATA SET\n PROTECTED DATA SET            /* RACF denied access to data set */\n VOLUME NOT ON SYSTEM\n INVALID DATA SET NAME\n MISSING DATA SET NAME\n UNAVAILABLE DATA SET\n*/\n\n/* messages from WHATLIB used to recreate MEMBYDD */\n Member(CMAPRTRS) is in DSname('BI21RI.TABLES'), of DDname(ISPTLIB(0)).\n Member(CMAPRTRS) is in DSname('BI21RI.TABLES'), of DDname(ISPTLIB(4)).\n *** Member(PSFPRTRS) not found in DDname(ISPTLIB).\n Member(ISPCMDS) is in DSname('BI21RI.TABLES'), of DDname(ISPTLIB(0)).\n Member(ISPCMDS) is in DSname('SPF22.SYS.PDFTLIB'), of DDname(ISPTLIB(2)\n Member(ISPCMDS) is in DSname('BI21RI.TABLES'), of DDname(ISPTLIB(4)).\n Member(ISPCMDS) is in DSname('SPF22.PDFTLIB'), of DDname(ISPTLIB(8)).\n*/\n\n/*  LISTD output\n BI21RI.TABLES\n --RECFM-LRECL-BLKSIZE-DSORG\n   FB    80    6160    PO\n --VOLUMES--\n   780018\n --MEMBER---TTR----ALIAS-TTRN-CNT-DATA\n   CMAPRTRS 009405 NO    0    00\n*/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MEMLIST": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00\\xb8\\x00\\xb8\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 184, "newlines": 184, "modlines": 0, "user": "RIAP-FB"}, "text": "/* MEMLIST   ************************************************* Rexx */\n/*   Created by: IAPPINI,R.                                         */\n/*   When: 12/15/92                                                 */\n/*   What: MEMLIST, a Rexx EXEC,                                    */\n/*                                                                  */\n/* MEMLIST   ************************************************* Rexx */\nAddress 'TSO'\nArg p1\nCall Initialize\nCall Process_main\nCall Eoj\nExit\n\nProcess_main:\n   Do i_dsn = 1 To Words(dataset)\n      Call Process_dsn Word(dataset,i_dsn)\n      End i_dsn\n   Return\n/*\n SYSDSNAME              Data set name\n SYSVOLUME              Volume serial number\n SYSUNIT                Device type for volume\n SYSDSORG               Data set's organization\n SYSRECFM               Data set's record format\n SYSLRECL               Data set's logical record length\n SYSBLKSIZE             Data set's block size\n SYSKEYLEN              Data set's key length\n SYSALLOC               Space allocation quantity\n SYSUSED                Space used quantity\n SYSPRIMARY             Primary allocation quantity\n SYSSECONDS             Secondary allocation quantity\n SYSUNITS               Space units (CYLINDER, TRACK, BLOCK)\n SYSEXTENTS             Number of DASD extents used\n SYSCREATE              Data set's creation date yyyy/ddd\n SYSREFDATE             Data set's last ref. date yyyy/ddd\n SYSEXDATE              Data set's expiration date yyyy/ddd\n SYSPASSWORD            Password protection status - NONE,\n                        READ, or WRITE\n SYSRACFA               RACF indication - NONE, GENERIC, or\n                        DISCRETE\n SYSUPDATED             Data set change indicator (YES or NO)\n SYSTRKSCYL             Tracks per cylinder for unit the data\n                        set is allocated on\n SYSBLKSTRK             Directory blocks per track for unit\n                        the data set is allocated on\n SYSADIRBLK             Directory blocks allocated - PDS only\n SYSUDIRBLK             Directory blocks used - PDS only\n SYSMEMBERS             Number of members - PDS only\n SYSMSGLVL1             1st level message if error\n SYSMSGLVL2             2nd level message if error\n*/\nProcess_dsn:\n   Arg dsn\n   say_cnt = 0\n   xx = Listdsi(dsn directory)\n   x_dsn = Sysdsname\n   Call Say_msg dsn\n   Call Say_msg \"directory blocks(\"sysadirblk\",\"sysudirblk\")\",\n                \"members(\"sysmembers\")\"\n   xx = Outtrap(tso.)\n   \"LISTD \"dsn \"M\"\n   xx = Outtrap(\"OFF\")\n   Do i_tso = 1 To tso.0\n      t_msg = tso.i_tso\n      Select\n         When \"--MEMBERS--\" = Left(t_msg,11) Then Call Get_members\n         Otherwise Nop\n         End /* End of Select ... */\n      End i_tso\n   If fullscreen Then,\n      Call Stemdisp \"BROWSE\",\"SAY.\",,,dsn \"member list\"\n   If print | disk Then Do\n      Address \"TSO\"\n      \"DELETE \"x_dsn\".LIST\"\n      \"ALLOC  FI(MEMOUT) DA(\"x_dsn\".LIST) SP(1 1) TRA DSO(PS)\",\n          \"LRECL(80) BLK(6160) RECFM(F B) REUSE\"\n      \"EXECIO * DISKW MEMOUT (STEM SAY. FINIS)\"\n      \"FREE FI(MEMOUT)\"\n      If print Then \"QPRT \"x_dsn\".LIST\"\n      If \u00acdisk Then \"DELETE \"x_dsn\".LIST\"\n      End\n   Return;\n\nGet_members:\n  memlist. = \"\"\n  mem_ndx  = 1\n  membrs   = 0\n  Do i_tso = i_tso + 1 To tso.0\n     t_msg = tso.i_tso\n     Select\n        When Wordpos(\"EXIST WITHOUT TRUE\",t_msg) > 0 Then,\n           Call Hanging_alias\n        Otherwise Do\n           Call Add_mem_tolist \" \"Left(Word(t_msg,1),9)\n           Call Process_alias Word(t_msg,2)\n           End\n        End /* End of Select ... */\n     End i_tso\n  If Words(memlist.mem_ndx) > 0 Then,\n     Call Say_msg memlist.mem_ndx /* get last line of members */\n  If fullscreen Then,\n     Call Stemdisp \"BROWSE\",\"MEMLIST.\",,,dsn \"contains \"membrs\" members\"\n  Return;\n\nHanging_alias:\n  If Words(memlist.mem_ndx) > 0 Then,\n     Call Say_msg memlist.mem_ndx /* get last line of members */\n  mem_ndx = mem_ndx + 1\n  prev_membrs = membrs\n  membrs = 0\n  Call Say_msg t_msg\n  Call Add_mem_tolist \" -------- \"\n  Do i_tso = i_tso+1 To tso.0\n     t_msg = tso.i_tso\n     Call Process_alias Strip(t_msg,\"B\")\n     End i_tso\n  membrs = membrs + prev_membrs\n  Return;\n\nProcess_alias:\n   Arg alias_msg\n   Select\n      When Left(alias_msg,6) = \"ALIAS(\" Then Do\n         Parse Var t_msg \"ALIAS(\" alias \")\" .\n         Do more_alias = i_tso+1 By 1 While Right(alias,1) = \",\"\n            t_msg = tso.more_alias\n            Select\n               When Right(t_msg,1) = \",\" Then,\n                  alias = alias t_msg\n               Otherwise Do /* Gets last of multiline alias */\n                  aliad = alias t_msg\n                  i_tso = more_alias\n                  Leave more_alias\n                  End\n               End /* End of Select ... */\n            End more_alias\n         alias = Space(Translate(alias,\"\",\",)\"))\n         Do i_a = 1 To Words(alias)\n            Call Add_mem_tolist \"*\"Left(Word(alias,i_a),9)\n            End i_a\n         End\n      Otherwise Nop\n      End /* End of Select ... */\n  Return;\n\nAdd_mem_tolist:\n  Arg add_mem\n  membrs = membrs + 1\n  memlist.mem_ndx = memlist.mem_ndx || add_mem\n  If membrs // 7 = 0 Then Do\n     Call Say_msg memlist.mem_ndx\n     mem_ndx = mem_ndx + 1\n     End\n  Return;\n\nSay_msg:\n   Parse Arg msg\n   If \u00acfullscreen & \u00acnodisplay Then Say msg\n   say_cnt = say_cnt + 1\n   say.say_cnt = msg\n   Return\n\nEoj:\n   Return;\n\nInitialize:\n   Parse Source environment . exec_name .\n   If Sysvar(sysispf) \u00ac= \"ACTIVE\" Then Do\n      \"ISPF CMD(%\"exec_name p1\")\"\n      Exit\n      End\n   proc_stmt = \"PROC 1 DATASET FULLSCREEN NODISPLAY PRINT DISK\"\n   Call Proctso p1,proc_stmt\n   Interpret result\n   If fullscreen = \"\" Then fullscreen = 0\n   Else fullscreen = 1\n   If nodisplay = \"\" Then nodisplay = 0\n   Else nodisplay = 1\n   If print = \"\" Then print = 0\n   Else print = 1\n   If disk = \"\" Then disk = 0\n   Else disk = 1\n   dataset = Translate(dataset,\"\",\"()\") /* possible list processing */\n   Return;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POPPRT": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x16\\x06\\x00\\x80\\x00\\x80\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xd5\\xc3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T16:06:00", "lines": 128, "newlines": 128, "modlines": 0, "user": "RIAP-NC"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "PSICMDIS": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x16\\x06\\x00=\\x00=\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xd5\\xc3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T16:06:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "RIAP-NC"}, "text": ")ATTR\n  @ TYPE(INPUT) INTENS(LOW) CAPS(OFF) COLOR(BLUE)\n  # TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) COLOR(RED)\n  ` TYPE(INPUT) INTENS(LOW) CAPS(ON) PAD('''')\n  ~ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) HILITE(REVERSE)\n  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON)\n  \u00a2 TYPE(OUTPUT) INTENS(HIGH) CAPS(ON)\n  + TYPE(TEXT) INTENS(LOW) CAPS(OFF) SKIP(ON)\n  ! TYPE(TEXT) INTENS(LOW) CAPS(OFF) color(yellow)\n  ? TYPE(&IO) INTENS(LOW) CAPS(ON) HILITE(&IOHILITE)\n)BODY   EXPAND(\\\\)\n%\\-\\!&appldesc     %\\-\\\n%Command ===>_ZCMD        \\ \\ %Scroll ===>_AMT %\n+\n% Options:+&entries\n+\n%&ZSRCWORD    ?WORDX       +\n+O+ZCTVERB   +ZCTTRUNC  +ZCTACT\n  +ZCTDESC   +\n+ ~ZFD1      ~ZFD2      ~ZFD3           +\n)MODEL ROWS(&ZSCAN) CLEAR(ZSZ ZCTVERB ZCTTRUNC ZCTACT ZCTDESC)\n`Z@ZCTVERB   @ZCTTRUNC  @ZCTACT\n    @ZCTDESC\n)INIT\n IF (&tableinx = Y) &IO = INPUT\n      &IOHILITE =  REVERSE\n      &ZSRCWORD  = 'Search Word:'\n ELSE &IO = OUTPUT\n      &IOHILITE = ''\n      &ZSRCWORD  = ''\n &ZFD1 = ''\n &ZFD2 = ''\n &ZFD3 = ''\n &ZFD4 = ''\n &ZFD5 = ''\n &ZFD6 = ''\n &ZFDN1 = ''\n &ZFDN2 = ''\n &ZFDN3 = ''\n &ZFDN4 = ''\n &ZFDN5 = ''\n &ZFDN6 = ''\n &ZCMD = ''\n &ZSZ = ''\n &AMT = CSR\n IF (&TBDINIT = INIT)\n      &TBDINIT = ''\n      .RESP = END\n.ZVARS='( ZSZ )'\n)REINIT\n  REFRESH(ZSZ,ZCMD)\n)PROC\n &xxz =  trunc(&zcmd,2)\n if (&xxz = L,F)\n    &zfd1 = .trail\n    &fdn1 = ZCTVERB\n IF (&ZFD1 \u00ac= '') &ZFDN1 = ZCTVERB\n IF (&ZFD1 \u00ac= '') &ZFDN1 = ZCTTRUNC\n IF (&ZFD1 \u00ac= '') &ZFDN1 = ZCTACT\n IF (&ZFD1 \u00ac= '') &ZFDN1 = ZCTDESC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PSICMIN1": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x16\\x06\\x001\\x001\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xd5\\xc3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T16:06:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "RIAP-NC"}, "text": ")ATTR\n  @ TYPE(INPUT) INTENS(LOW) CAPS(OFF) COLOR(&COLOR)\n  \u00ac TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF)\n  \u00a2 TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(RED)\n  $ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF)\n  # TYPE(&ZIOTYPE) INTENS(HIGH) CAPS(ON) COLOR(RED)\n  ` TYPE(TEXT) INTENS(HIGH) CAPS(ON) COLOR(PINK)\n  + TYPE(TEXT) INTENS(LOW) CAPS(OFF) COLOR(BLUE) SKIP(ON)\n* AREA(DYNAMIC) EXTEND(on) SCROLL(ON) DATAMOD(`) USERMOD(`)\n)BODY EXPAND(\\\\)\n$FUNCP%Page 1 %-\\-\\&appldesc    % \\-\\\n%Command ====> _ZCMD \\ \\ +\n\u00a2ZCOMMEN2\\ \\ +\n%Enter/verify values below:\n\n   +ZCTVERB     : @ZCTVERB \\ \\+\n   +ZCTTRUNC    : @ZCTTRUNC \\ \\+\n   +ZCTACT      : @ZCTACT \\ \\+\n   +ZCTDESC     : @ZCTDESC \\ \\+\n*Zfil \\-\\*\n \\ \\%(PF3)+Exit%(Enter)+Process+\\ \\\n)INIT\n&ZCMD = ' '\n&Zfil = ' '\n&ZIOTYPE = OUTPUT\nIF (&FUNCP = ADD) &ZIOTYPE = INPUT\n IF (&SURCNT \u00ac= ' ')\n  IF (&COMMENT2 = ' ')\n   &COMMENT2= 'Entry added. Please enter next entry to be added'\n IF (&SURCNT = ' ')\n   &SURCNT = 0\n   &COMMENT2 = ' '\nIF (&COLOR = TURQ)\n   &COLOR = ' '\nIF (&COLOR = PINK)\n   &COLOR = TURQ\nIF (&COLOR = YELLOW)\n   &COLOR = PINK\nIF (&COLOR = RED)\n   &COLOR = YELLOW\nIF (&COLOR = GREEN)\n   &COLOR = RED\nIF (&COLOR = ' ')\n   &COLOR = GREEN\n)PROC\n  &COMMENT2 = ' '\n  IF (.RESP  = END)\n    &SURCNT = ' '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REMOVEWD": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00\\x1c\\x00\\x1c\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "RIAP-FB"}, "text": "/* REMOVEWD*************************************************** Rexx */\n/*   Created by: IAPPINI,R.                                         */\n/*   When: 11/06/92                                                 */\n/*   What: REMOVEWD is a Rexx function to REMOVE a WORD of data     */\n/*         from a string of words.                                  */\n/*                                                                  */\n/*   Parameters: string_to_find string_to_search                    */\n/*   Returns: v_del = word_removed                                  */\n/*            v_string = remaining_string                           */\n/*            rc = word_number_removed_from_string_to_search        */\n/*                                                                  */\n/********************************************************************/\nRemovewd:\n   Trace \"OFF\"\n   Address 'TSO'\n   Arg p1\n   w_p1 = Arg(1)\n   sts = Arg(2)\n   Parse Var sts (w_p1) w_v \" \" .\n   w_del = Wordpos(w_p1 || w_v,sts)\n   If w_del > 0 Then Do\n      w_p1 = Word(sts,w_del)\n      sts  = Delword(sts,w_del,1)\n      End\n   Else Do\n      w_p1 = \"\"\n      End\n   Return (\"v_del = '\"w_p1\"';v_string = \"\"\"sts\"\"\";rc = \"w_del\";\")\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REPLACWD": {"ttr": 1806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00(\\x00(\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "RIAP-FB"}, "text": "/* REPLACWD*************************************************** Rexx */\n/*   Created by: IAPPINI,R.                                         */\n/*   When: 12/11/92                                                 */\n/*   What: REPLACWD is a Rexx EXEC that replaces a word or words    */\n/*         in a string of words.                                    */\n/********************************************************************/\nAddress 'TSO'\nTrace \"OFF\"\nParse Source environment . exec_name .\nParse Arg p1\nproc_stmt = \"PROC 3 F R S\"\nCall Proctso p1,proc_stmt\nInterpret result\nIf rc \u00ac= 0 Then Do\n   Say \"Error in: \"exec_name\n   Say proctso_msg\n   Say \"Valid options are: \"Subword(proc_stmt,3)\n   Say \"You entered: \"p1\n   Say \"Re-enter the correct options.\"\n   Exit\n   End\nIf Left(f,1) = \"(\" Then f = Substr(f,2,Length(f)-2)\nIf Left(r,1) = \"(\" Then r = Substr(r,2,Length(r)-2)\nIf Left(s,1) = \"(\" Then s = Substr(s,2,Length(s)-2)\nIf Left(f,1) = \"'\" Then f = Substr(f,2,Length(f)-2)\nIf Left(r,1) = \"'\" Then r = Substr(r,2,Length(r)-2)\nIf Left(s,1) = \"'\" Then s = Substr(s,2,Length(s)-2)\nfind_string = f\nreplace_string = r\nstring = s\nxx = Wordpos(Translate(find_string),Translate(string))\nSelect\n   When xx = 1 Then,\n      string = replace_string Subword(string,2)\n   When xx > 1 Then,\n      string = Subword(string,1,xx - 1) replace_string,\n               Subword(string,xx + Words(find_string))\n   Otherwise Nop\n   End  /* End of Select ... */\nReturn (string)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXID": {"ttr": 1808, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00W\\x00W\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "RIAP-FB"}, "text": "/*REXXID Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx */\n\"ISREDIT MACRO (PARMS)\"\nTrace \"OFF\"\nAddress \"ISREDIT\"\n\"(col1,col2) = DISPLAY_COLS\"\nIf rc \u00ac= 0 Then Do\n   col1 = 1\n   col2 = 72\n   End\n\"(mbr) = Member\"\n\"(row,col) = CURSOR\"\nxc = ((col2-5) - Length(mbr)) % 6\n\"CAPS OFF\"\n\"NUM ON\"\n\"(lb,rb) = BOUNDS\"\n\"(recfm) = RECFM\"\n\"BOUNDS = 1 72\"\nrexxline = \"/* \"mbr || COPIES(' Rexx ',xc) || \"*/\"\nIf row \u00ac= 0 Then row = 0\nCall Line_after rexxline\nCall Line_after \"Address \"\"TSO\"\"\"\nCall Line_after \"Trace \"\"OFF\"\"\"\nCall Line_after \"Arg p1\"\nUpper parms\nSelect\n   When parms = \"\" Then Nop\n   When Abbrev(\"ALL\",parms) Then Call Insert_initial_code\n   Otherwise Nop\n   End /* End of Select ... */\nExit\n\nInsert_initial_code:\n   Call Line_after \"Call Initialize\"\n   Call Line_after \"Call Process_main\"\n   Call Line_after \"Call Eoj\"\n   Call Line_after \"Exit;\"\n   Call Line_after \" \"\n   Call Line_after \"Process_main:\"\n   Call Line_after \"   Return;\"\n   Call Line_after \" \"\n   Call Line_after \"Initialize:\"\n   Call Line_after \"   Parse Source environment function exec_name\",\n                   \"whatdd whatdsn exec_cur,\"\n   Call Line_after \"      env_default env_type supplied_name\"\n   Call Line_after \"   If Sysvar(Sysispf) \u00ac= \"\"ACTIVE\"\" Then Do\"\n   Call Line_after \"      \"\"ISPF CMD(%\"\"exec_name p1\"\")\"\"\"\n   Call Line_after \"      Exit \"\n   Call Line_after \"      End\"\n   Call Line_after \"   proc_stmt = \"\"PROC 0 parm1 ... parmn \"\"  \"\n   Call Line_after \"   flags = \"\" FULLSCREEN QUIET\"\"  \"\n   Call Line_after \"   Call Proctso p1,proc_stmt flags          \"\n   Call Line_after \"   Interpret result                         \"\n   Call Line_after \"   say_cnt = 0                              \"\n   Call Line_after \"   /* Set any optional processing flags */         \"\n   Call Line_after \"   Do i_flag = 1 By 1 To Words(flags)              \"\n   Call Line_after \"      xx = Word(flags,i_flag)                      \"\n   Call Line_after \"      Interpret Word(flags,i_flag)\"\"=\"\"Set_flag(xx)\"\n   Call Line_after \"      End i_flag;                                  \"\n   Call Line_after \"      Interpret x \"\"=\"\"Translate(flags,\"\"+\"\",\"\" \"\")\"\n   Call Line_after \"      If x = 0 Then tso = 1                        \"\n   Call Line_after \"   Return;\"\n   Call Line_after \" \"\n   Call Line_after \"Eoj:\"\n   Call Line_after \"   If fullscreen Then,\"\n   Call Line_after \"      Call Stemdisp \"\"BROWSE\"\",\" || ,\n                         \"\"\"SAY.\"\",,,\"\"Application Display Text\"\"\"\n   Call Line_after \"   Return;\"\n   Call Line_after \" \"\n   Call Line_after \"Say_msg:\"\n   Call Line_after \"   Parse Arg msg                        \"\n   Call Line_after \"   If \u00acfullscreen & \u00acQuiet Then Say msg \"\n   Call Line_after \"   say_cnt = say_cnt + 1                \"\n   Call Line_after \"   say.say_cnt = msg                    \"\n   Call Line_after \"   Return                               \"\n   Call Line_after \"                                        \"\n\n   Call Line_after \" Set_flag:                              \"\n   Call Line_after \"    Arg flag                            \"\n   Call Line_after \"    Return (Value(flag) \u00ac= \"\"\"\");       \"\n   Return;\n\nLine_after:\n   Parse Arg xx\n   \" LINE_AFTER \"row\" = (xx)\"\n   If rc = 0 Then,\n       row = row + 1\n   Return;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RFILL": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00s\\x00s\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 115, "newlines": 115, "modlines": 0, "user": "RIAP-FB"}, "text": "/** RFILL boundary ****************************************** REXX **/\n/*   Modified By: IAPPINI,R.                                        */\n/*   When: 01/07/93                                                 */\n/*   What: Added a SQUEEZE option that will \"squeeze\" out embedded  */\n/*         blanks starting from the first non-blank character       */\n/********************************************************************/\n/*   Modified By: IAPPINI,R.                                        */\n/*   When: 01/15/93                                                 */\n/*   What: Replaced extensive code with the REXX functio JUSTIFY.   */\n/*                                                                  */\n/********************************************************************/\n/*  FILL the text To max Right boundary with blank                  */\n/*  Optional parm:Boundary , integer                                */\n/*  Default boundary is the lrecl of dataset.                       */\n/*  Takes block control characters \"CC\" or \"MM\"                     */\n/*                                                                  */\n/*  By CT Tran PD/PSI                 12/92                         */\n/********************************************************************/\nAddress ISREDIT\n\"MACRO (BND parms) NOPROCESS\"\nCall Initialize\nIf \u00acsqueeze Then Call Process_main\nElse Call Squeeze_lines\nExit\n\nProcess_main:\n   Do i = first To last\n      \"(line) = line  \"i\n      Call Space_out_line\n      line = result\n      \"line \"i\"= (line)\"\n      End i\n   If last > first Then Do\n      shortmsg = \"Filled \"Trunc(first)\"-\"Trunc(last)\n      zedlmsg = \"Bound=\"bnd\", \"last-first+1 \"lines processed\"\n      Address Ispexec \"setmsg Msg(isrz001)\"\n      End\n   Return;\n\nSpace_out_line:\n   x_line = Substr(line,1,bnd)\n   If lrecl > bnd Then r_line = Substr(line,bnd+1)\n   Else r_line = \"\"\n   w_line = Words(x_line)\n   If w_line = 0 Then Return (x_line)\n   last_word  = Word(x_line,Words(x_line))\n   last_blank = Lastpos(last_word,x_line) + Length(last_word)\n   x_line = Substr(x_line,1,last_blank-1) /* final string to process */\n   Return (Justify(x_line,bnd) || r_line)\n\nInitialize:\n   bnd = Translate(bnd)\n   If bnd \u00ac= \"\" & datatype(bnd) \u00ac= \"NUM\" Then Do\n      zedsmsg = \"Invalid parameter-boundary\"\n      zedlmsg = \"Use a whole number > 0 for boundary\"\n      Address Ispexec \"SETMSG Msg(isrz001)\"\n      Exit\n      End\n   \"PROCESS RANGE M C\"\n   If rc >=16 Then Exit\n   \"(cmd) = range_cmd \"\n   \"(first) = linenum .zfrange\"\n   \"(last) = linenum .zlrange\"\n   \"(lrecl) = lrecl           \"\n   If bnd = \"\" Then bnd = lrecl\n   \"(lb,rb) = BOUNDS\"\n   If bnd > rb Then Do\n      zedsmsg = bnd \"> rb\"\n      zedlmsg = \"You specified a right boundary > then BNDS(\"rb\")\"\n      Address \"ISPEXEC\" \"SETMSG MSG(ISRZ001)\"\n      Exit\n      End;\n   If cmd = \"\" Then Do\n      Say \"Please verify that you want To fill whole dataset. Y or N\"\n      Parse External ans\n      If Left(Translate(ans),1) \u00ac= \"Y\" Then Do\n         zedsmsg = \"No process\"\n         zedlmsg = \"You elected to NOT fill the whole dataset\"\n         Address Ispexec \"SETMSG Msg(isrz001)\"\n         Exit\n         End\n      End\n   proc_stmt = \"PROC 0 SQUEEZE FORMAT\"\n   Call Proctso Translate(parms),proc_stmt\n   Interpret result\n   If squeeze \u00ac= \"\" Then squeeze = 1\n   Else squeeze = 0\n   Return\n\nSqueeze_lines:\n   Do i = first To last\n      \"(line) = line  \"i\n      Select\n         When Words(line) = 0 Then Nop\n         When Words(line) = 1 Then,\n            If left_blanks > 0 Then,\n               line = Copies(\" \",left_blanks) ||,\n                   Space(Substr(line,left_blanks+1))\n            Else line = Space(line)\n         Otherwise Do\n            left_blanks = Pos(Word(line,1),line)-1\n            If left_blanks = 0 Then,\n               line = Space(line)\n            Else line = Copies(\" \",left_blanks) ||,\n                   Space(Substr(line,left_blanks+1))\n            End\n         End /* End of Select */\n      \"line \"i\"= (line)\"\n      End i\n   If last > first Then Do\n      zedsmsg = \"Squeezed \"Trunc(first)\"-\"Trunc(last)\n      zedlmsg = \"Bound=\"bnd\", \"last-first+1 \"lines processed\"\n      Address Ispexec \"setmsg Msg(isrz001)\"\n      End\n   Return;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWFLOW": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00!\\x00!\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "RIAP-FB"}, "text": "/* SHOWFLOW*************************************************** Rexx */\n/*   Created By: IAPPINI,R.                                         */\n/*   When: 07/08/93                                                 */\n/*   What: SHOWFLOW, an Edit macro, that excludes all lines and     */\n/*         then displays flow control words. (SHARE I184)           */\n/*                                                                  */\n/********************************************************************/\nAddress \"ISREDIT\"\n\"MACRO (HELP)\"                           /*                           */\nTrace \"OFF\"\n\"(ustate) = USER_STATE\"                  /* Save the user stat so     */\n                                         /* that the last find string */\n                                         /* will not be affected      */\n\"EXCLUDE ALL\"                            /* exclude all lines         */\n                                         /*                           */\n                                         /* Find control flow words   */\n\"FIND ALL char ':'\"                      /*                           */\n\"FIND ALL WORD 'PROCEDURE'\"              /*                           */\n\"FIND ALL WORD 'PERFORM'\"                /*                           */\n\"FIND ALL WORD 'EXIT'\"                   /*                           */\n\"FIND ALL WORD 'RETURN'\"                 /*                           */\n\"FIND ALL WORD 'PROC'\"                   /*                           */\n\"FIND ALL WORD 'CALL'\"                   /*                           */\n\"FIND ALL WORD 'DO'\"                     /*                           */\n\"FIND ALL WORD 'END'\"                    /*                           */\n\"FIND ALL WORD 'IF'\"                     /*                           */\n\"FIND ALL WORD 'THEN'\"                   /*                           */\n\"FIND ALL WORD 'ELSE'\"                   /*                           */\n\"FIND ALL WORD 'SELECT'\"                 /*                           */\n\"FIND ALL WORD 'WHEN'\"                   /*                           */\n\"FIND ALL WORD 'OTHERWISE'\"              /*                           */\n                                         /* Reset the user's state    */\n\"USER_STATE = (ustate)\"                  /*                           */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSDSNRI": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\'\\x1f\\x00\\x93\\'\\x1f\\x15I\\x00\"\\x00\"\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "RIAP-FB"}, "text": "/* SYSDSNRI ************************************************** Rexx */\n/*   Created by: IAPPINI,R.                                         */\n/*   When: 01/12/93                                                 */\n/*   What: SYSDSN is a Rexx EXEC dialog to process the result of    */\n/*         the SYSDSN command                                       */\n/********************************************************************/\nAddress 'TSO'\nArg p1\nsysdsn_result = Sysdsn(p1)\nmsg1 = \"OK\"                           /* data set exists */\nmsg2 = \"MEMBER NOT FOUND\"\nmsg3 = \"MEMBER SPECIFIED, BUT DATASET IS NOT PARTITIONED\"\nmsg4 = \"DATASET NOT FOUND\"\nmsg5 = \"ERROR PROCESSING REQUESTED DATASET\"\nmsg6 = \"PROTECTED DATASET\"   /* RACF denied access to data set*/\nmsg7 = \"VOLUME NOT ON SYSTEM\"\nmsg8 = \"INVALID DATASET NAME\"\nmsg9 = \"MISSING DATASET NAME\"\nmsga = \"UNAVAILABLE DATASET\"\nsmsg = \"sysdsn_msg = '\"sysdsn_result\"';rc = \"\nSelect\n   When (sysdsn_result = msg1) Then Return (smsg || \"0;\")\n   When (sysdsn_result = msg2) Then Return (smsg || \"1;\")\n   When (sysdsn_result = msg3) Then Return (smsg || \"1;\")\n   When (sysdsn_result = msg4) Then Return (smsg || \"8;\")\n   When (sysdsn_result = msg5) Then Return (smsg || \"8;\")\n   When (sysdsn_result = msg6) Then Return (smsg || \"4;\")\n   When (sysdsn_result = msg7) Then Return (smsg || \"8;\")\n   When (sysdsn_result = msg8) Then Return (smsg || \"8;\")\n   When (sysdsn_result = msg9) Then Return (smsg || \"8;\")\n   When (sysdsn_result = msga) Then Return (smsg || \"5;\")\n   Otherwise Return (\"sysdsn_msg = 'Severe Error';rc = 20;\")\n   End /* End OF Select .... */\nReturn;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TABEMPTY": {"ttr": 2058, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00K\\x00K\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "RIAP-FB"}, "text": "/* REXX ** REXX ** REXX ** REXX ** REXX ** REXX ** REXX ** REXX */\n/**************************************************************/\n/*                                                            */\n/*   CREATED BY: IAPPINI,R.                                   */\n/*         WHEN: 08/08/90                                     */\n/*         WHAT: UTILITY TO EMPTY AN ISPF TABLE               */\n/*                                                            */\n/*                                                            */\n/**************************************************************/\nADDRESS 'TSO'\nARG PARMS\nXPROC = 'PROC 2 TABLE_DATASET_NAME TABLE_NAME'\nCALL PROCTSO PARMS,XPROC\nINTERPRET RESULT\n/**/\nif rc \u00ac= 0 then do\n   say proctso_msg\n   say cmd_area', terminating SORTD.'\n   exit\n   end\nTDSN = TABLE_DATASET_NAME\nTNAM = TABLE_NAME\nselect\n   when length(tdsn) \u00ac= 0 & length(tnam) \u00ac= 0 then nop\n   otherwise do\n      say 'A table_dataset_name AND table_name must be entered.'\n      say 'Please re-enter:',\n          'TABEMPTY table_dataset_name table_name'\n      exit\n      end\n   end /* End of SELECT ... */\ncall validate_dataset STRIP(TRANSLATE(TDSN,' ',\"'\"))\"(\"TNAM\")\"\nif result = '' then exit\nparse var result tdsn tnam\n\"ALLOC FI(SB1) DA(\"TDSN\") SH REUSE\"\nADDRESS 'ISPEXEC'\n\"LIBDEF SB1 LIBRARY ID(SB1)\"\n\"TBOPEN \"TNAM \"LIBRARY(SB1) WRITE\"\n\"TBSTATS \"TNAM\" ROWCURR(QROWS)\"\n\"TBTOP \"TNAM\nDO I = 1 BY 1 TO QROWS\n   \"TBSKIP \"TNAM\n   \"TBDELETE \"TNAM\n   END I\n\"TBCLOSE \"TNAM \"LIBRARY(SB1)\"\n\"LIBDEF SB1\"\nADDRESS \"TSO\" \"FREE FI(SB1)\"\nEXIT\n/**************************************************************/\n/*       Subroutines                                          */\n/**************************************************************/\nvalidate_dataset:\nARG vdataset\nparse var vdataset dsn '(' member ')'\nSELECT\n   WHEN vdataset = '*' THEN return \"\"\n   WHEN SYSDSN(vdataset) = 'OK' THEN NOP\n   OTHERWISE do\n      vdataset = \"'\"vdataset\"'\"\n      Xs = SYSDSN(vdataset)\n      IF xs \u00ac= 'OK' THEN DO\n         SAY \"Invalid Table specified(\"vdataset\");\"xs,\n             ';terminating TABEMPTY.'\n         EXIT\n         END\n      END\n   END /* END OF SELECT ... */\nif substr(vdataset,1,1) = \"'\" then dsn = \"'\"dsn\"'\"\nx = listdsi(dsn)\nif member = '' & sysdsorg = 'PO' then do\n   say 'The Table dataset('vdataset')',\n       'is a PDS, please specify a member; terminating TABEMPTY.'\n    exit\n   end\nreturn (dsn member)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TQUAL": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'\\x1f\\x00\\x93'\\x1f\\x15I\\x00\\x0b\\x00\\x0b\\x00\\x00\\xd9\\xc9\\xc1\\xd7`\\xc6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-28T00:00:00", "modifydate": "1993-09-28T15:49:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "RIAP-FB"}, "text": "/* Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  Rexx  */\n/********************************************************************/\n/*   Created by: IAPPINI,R.                                         */\n/*   When: 06/03/92                                                 */\n/*   What: Returns a TIME qualifier (Thhmmsst.).                     */\n/*                                                                  */\n/********************************************************************/\nAddress 'TSO'\nArg p1\nParse Value Time(L) With  hh ':' mm ':' ss '.' t\nReturn (\"T\"hh||mm||ss||Left(t,1))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT158/FILE158.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT158", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}