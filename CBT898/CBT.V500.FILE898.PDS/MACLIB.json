{"INMR01": {"INMLRECL": 80, "INMFNODE": "TSTMVS01", "INMFUID": "ALEX", "INMTNODE": "TSTMVS01", "INMTUID": "ALEX", "INMFTIME": "20130904131446000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2821728, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 18, "INMDSNAM": "AKOS.MACLIB", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2821728, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2821728, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"AKOS.MACLIB": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 128, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "130247", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x10'", "DS1LSTAR": "b'\\x00<\\x05'", "DS1TRBAL": "b'\\x1c\\xb0'"}, "COPYR2": {"deb": "b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0c0\\x00\\x04u]`'", "extents": ["b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0c0\\x00\\x04u]`'", "b'X\\xf3cH\\x00\\x00\\x00H\\x00\\t\\x00L\\x00\\x08\\x00<'", "b'X\\xf3cH\\x00\\x00\\x02\\x07\\x00\\x0e\\x02\\x08\\x00\\x0e\\x00\\x10'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$INDEX": {"ttr": 32, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x18\\x00\\x93\\x11\\x7f\\x00\\x94&/\\x14\\x16\\x00=\\x00=\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1993-04-27T00:00:00", "modifydate": "1994-09-19T14:16:18", "lines": 61, "newlines": 61, "modlines": 0, "user": "ZTSALK"}, "text": "\u00a6 Member  \u00a6 Description         (Enter \"INDEX ?\" command for more info.)\n+---------+---------------------------------------------------------------------\n\u00a6$$$INDEX \u00a6Index gen'd 19/09/94.\n\u00a6$$COPY   \u00a6Copyright statement\n\u00a6$HELP    \u00a6Copybook for 'macro help' comments\n\u00a6$MACHELP \u00a6Copybook for 'macro help' comments\n\u00a6$PCRECV  \u00a6PC transfer receive job\n\u00a6$PCSEND  \u00a6PC transfer send job\n\u00a6@ICSXCAR \u00a6?????\n\u00a6@MACROS  \u00a6Common macros used by programs written by A. Kara\n\u00a6ADYN     \u00a6Dynamic allocation\n\u00a6ADYNNOTE \u00a6Dynamic allocation stand alone instructions\n\u00a6AMODECHG \u00a6Addressing MODE CHanGe\n\u00a6CADC     \u00a6Character Attribute Define Constant\n\u00a6CHHEXMAC \u00a6CHARACTER TO HEX CONVERSION\n\u00a6CICSXCAC \u00a6?????\n\u00a6CICSXCAR \u00a6?????\n\u00a6CLEARV   \u00a6Move a pad character to a variable (any length)\n\u00a6CTRACE   \u00a6CICS TRACE\n\u00a6DDSCAN   \u00a6?????\n\u00a6ESTAERCV \u00a6?????\n\u00a6FBA      \u00a6SBA X'11.ROW.COL' => C'ROW.COL'\n\u00a6GBA      \u00a6C'ROW.COL' => SBA X'11.ROW.COL'\n\u00a6HALATTCH \u00a6?????\n\u00a6HEXCHMAC \u00a6HEC TO CHARACTER\n\u00a6ICDC     \u00a6DEFINE CONSTANT 'INSERT CURSOR/ROW.COL'\n\u00a6INCLUDE  \u00a6?????\n\u00a6ISPBRIF  \u00a6?????\n\u00a6ISPEXEC  \u00a6MACRO TO ACCEPT COMMAND FORMAT \"ISPEXEC\" COMMANDS\n\u00a6ISPINIT  \u00a6INIT ENVIRONMENT TO ACCEPT COMMAND FORMAT \"ISPEXEC\" COMMANDS\n\u00a6ISPVDEFX \u00a6ISPEXEC VDEFINE USING COMMON VARIABLE DEFINES\n\u00a6KICKOFF  \u00a6FRONT END TO KICKOFF AN ASSEMBLER PROGRAM\n\u00a6MACT1    \u00a6?????\n\u00a6PDUMP    \u00a6INVOKE ONLINE PROGRAM DUMP/DISPLAY ROUTINE\n\u00a6PDUMP$   \u00a6PDUMP macro used to debug PROGDUMP modules.\n\u00a6PLOAD    \u00a6Program Load/Execute/Delete\n\u00a6PUTL     \u00a6Issue a PUTLINE macro without all the setup to IOPL etc...\n\u00a6RACKOFF  \u00a6BACK END TO EXIT AN ASSEMBLER PROGRAM\n\u00a6RADC     \u00a6REPEAT TO ADDRESS DEFINE CONSTANT\n\u00a6SBA      \u00a6SET BUFFER ADDRESS\n\u00a6SBADC    \u00a6SET BUFFER ADDRESS DEFINE CONSTANT\n\u00a6SCREEND  \u00a6?????\n\u00a6SCREENL  \u00a6?????\n\u00a6SHOWREGS \u00a6?????\n\u00a6SVLNK    \u00a6?????\n\u00a6TESTMAC  \u00a6?????\n\u00a6TODAY    \u00a6RETURNS TODAY'S DATE IN THE FORMAT DD/MM/YY\n\u00a6TRACE#D  \u00a6?????\n\u00a6TRACE#L  \u00a6?????\n\u00a6TRACED   \u00a6TRACE DATA\n\u00a6TRACEDA  \u00a6?????\n\u00a6TRACEIT  \u00a6?????\n\u00a6TRACEL   \u00a6TRACE LITERAL\n\u00a6TRACELA  \u00a6?????\n\u00a6TRACER   \u00a6?????\n\u00a6UNPACK   \u00a6UNPACK INTO 8 BYTE DOUBLEWORD\n\u00a6WCCDC    \u00a6WRITE CONTROL CHARACTER DEFINE CONSTANT\n\u00a6WCCDCCOL \u00a6WRITE CONTROL CHARACTER DEFINE CONSTANT COLOR\n\u00a6WCCDCMON \u00a6WRITE CONTROL CHARACTER DEFINE CONSTANT MONOCHROME\n\u00a6WCCDCV   \u00a6?????\n\u00a6XESTATE# \u00a6?????\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$COPY": {"ttr": 34, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x03\\x00\\x93%\\x7f\\x00\\x93%\\x7f\\x10Q\\x00\\x04\\x00\\x04\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1993-09-14T00:00:00", "modifydate": "1993-09-14T10:51:03", "lines": 4, "newlines": 4, "modlines": 0, "user": "ZTSALK"}, "text": "***********************************************************************\n* (C) COPYRIGHT 1993 - ASYSTS PTY LTD, COMPUTING SERVICES             *\n*     ALL RIGHTS RESERVED                                             *\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$AMGECH": {"ttr": 10244, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x16\\x00\\x93%\\x7f\\x01\\x013/\\x14\\x02\\x00b\\x00\\x04\\x00\\x00\\xc3\\xf8\\xf3\\xf8\\xf7\\xf0\\xf4@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1993-09-14T00:00:00", "modifydate": "2001-11-28T14:02:16", "lines": 98, "newlines": 4, "modlines": 0, "user": "C838704"}, "text": "*---------------------------------------------------------------------*\n         MACRO\n&NAME    $AMGECH &MODE,&REG,&STMODE=\n         AGO .A$HELPE\n*---------------------------------------------------------------------*\n*                                                                     *\n* CHANGE ADDRESSING MODE.                                             *\n* -----------------------                                             *\n* The purpose of this macro is to change addressing modes (AMODE)     *\n* during execution of a program.                                      *\n*                                                                     *\n* PARAMETERS:                                                         *\n*    MODE        - New addressing mode. This is a positional          *\n*                  parameter and must have value of 24, 31 or         *\n*                  O(riginal).                                        *\n*                                                                     *\n*                    eg. LABEL1  AMODECHG 31                          *\n*                        LABEL2  AMODECHG 24                          *\n*                                                                     *\n*    REG         - WORK REGISTER (DEFAULT IS 15).                     *\n*    STMODE=cccc - Address to store current addressing mode for       *\n*                  subsequent reversal.                               *\n*                                                                     *\n* NOTE:                                                               *\n*    1. The same format of this macro can be used in any type of      *\n*       programs, (ie. can be used in re-entrant programs).           *\n*    2. This macro WILL change the contents of register 15 if no      *\n*       register parameter is passed.                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         LCLC  &LABEL11,&LABEL21\n         GBLB  &AMODE31,&AMODE24\n         LCLC  &WREG1,&WREG2,&LABEL1\n         AIF   (T'&NAME EQ 'O').A$YY\n&NAME    DS    0H\n.A$YY    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&MODE EQ 'O').ERR1\n&WREG1   SETC  '15'                 Set work register\n         AIF   (T'&REG EQ 'O').WREGST1 Bypass if register omitted\n&WREG1   SETC  '&REG'               Set work register\n.WREGST1 ANOP\n         AIF   ('&MODE' EQ '24').A$24\n         AIF   ('&MODE' EQ '31').A$31\n.*--------------------------------------------------------------------*\n.A$OR    ANOP\n*---------------------------------------------------------------------*\n*  ===>  CHANGE TO ORIGINAL ADDRESSING MODE IN STREAM                 *\n*---------------------------------------------------------------------*\n&LABEL1  SETC  'AOR'.'&SYSNDX'.'1'\n         LA    &WREG1,&LABEL1      SET BSM ADDRESS\n         AIF   (T'&STMODE EQ 'O').ERR2\n         O     &WREG1,&STMODE      HIT WITH ORIGINAL MODE\n         BSM   &WREG1,&WREG1       CHANGE MODE TO ORIGINAL MODE\n&LABEL1  EQU   *\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.A$24    ANOP\n*---------------------------------------------------------------------*\n*  ===>  CHANGE TO 24 BIT ADDRESSING MODE IN STREAM                   *\n*---------------------------------------------------------------------*\n&LABEL1  SETC  'A24'.'&SYSNDX'.'1'\n         LA    &WREG1,&LABEL1      SET BSM ADDRESS\n         BSM   &WREG1,&WREG1       CHANGE MODE TO 24 BIT\n&LABEL1  EQU   *\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.A$31    ANOP\n*---------------------------------------------------------------------*\n*  ===>  CHANGE TO 31 BIT ADDRESSING MODE IN STREAM                   *\n*---------------------------------------------------------------------*\n&LABEL1  SETC  'A31'.'&SYSNDX'.'1'\n         LA    &WREG1,&LABEL1      SET BSM ADDRESS\n         O     &WREG1,=X'80000000' SET 32ND BIT FOR SWAP TO 31 BIT MODE\n         AIF   (T'&STMODE EQ 'O').A31001\n         BASSM &WREG1,&WREG1           CHANGE TO 31 AND SAVE CURRENT\n         AGO   .A31002\n.A31001  ANOP\n         BSM   &WREG1,&WREG1           CHANGE MODE TO 31 BIT\n.A31002  ANOP\n&LABEL1  EQU   *\n         AIF   (T'&STMODE EQ 'O').MEXIT\n         N     &WREG1,=X'80000000'     ORIGINAL AMODE\n         ST    &WREG1,&STMODE          STORE IT\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.*       ERROR MESSAGES                                               *\n.*--------------------------------------------------------------------*\n.ERR1    MNOTE 8,'MISSING ADDRESSING MODE PARAMETER (24 OR 31).'\n         AGO   .MEXIT\n.ERR2    MNOTE 8,'ORIGINAL RESTORE MODE REQUIRES A \"STMODE=\" PARAM.'\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.MEXIT   ANOP\n         MEXIT\n.*--------------------------------------------------------------------*\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$FHTUREN": {"ttr": 7425, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*                                                                     *\n*  CHANGE ACTIVITY :                                                  *\n*   $SEG(DFHTUREN),COMP(TRACE),PROD(CICS/VS)   :                      *\n*                                                                     *\n*    PN= REASON REL YYMMDD HDXIII : REMARKS                           *\n*   $D1= I01508 161 8211   HDPBGH : PURGE PERM'T MIRROR AT MXT LIMIT  *\n*   $D2= I01507 170 8410   HDIVJH : TCP TRACE ENTRIES (FE TYPE)       *\n*    D3= RESERVED FOR DCR         :                                   *\n*    D4= RESERVED FOR DCR         :                                   *\n*    D5= RESERVED FOR DCR         :                                   *\n*    D6= RESERVED FOR DCR         :                                   *\n*    D7= RESERVED FOR DCR         :                                   *\n*   $H1= 5E2    160 8010   HDCPH  :  CICS/VS 1.6 PARTITION SUPPORT    *\n*   $H2= 5E5    160 8010   HDCPH  :  CICS/VS 1.6 MAGNETICS SUPPORT    *\n*   $H3= 963    160 8010   HDCPH  :  CICS/VS 1.6 DXAM SUPPORT         *\n*    H4= RESERVED FOR HARDWARE SUPPORT  :                             *\n*    H5= RESERVED FOR HARDWARE SUPPORT  :                             *\n*    H6= RESERVED FOR HARDWARE SUPPORT  :                             *\n*   $L1= CB0    160 811013 HDREH  : AB79,ABKS RMI TRACE ENTRIES       *\n*   $L2= U71    160 8103   HDTHSL : TABLE MANAGER TRACE ENTRY         *\n*                                 : PCP - PPT REPLACE TRACE ENTRY     *\n*   $L3= U71    160 8104   HDBKED : CHANGE TO CODES FOR KC ATTACH     *\n*                                 : CONDITIONAL XCTL                  *\n*                                 : PERMANENT STORAGE                 *\n*                                 : BROWSE PROFILES                   *\n*                                 : FC CTYPE=LOCATE,CTYPE=BROWSE      *\n*                                 : TD CTYPE=LOCATE,CTYPE=BROWSE      *\n*   $L4= U71    160 8104   HD0ADB : CHANGE TO CODES FOR AMP AND DMP   *\n*   $L5= G00    160 810519 HDXDRP : AAZT EXTENDED TRACE ENTRIES       *\n*                   820309 HD0LGP : FIX 2000 HRS PUMPKIN PROBLEM      *\n*   $L6= I00    160 8109   HDUGM  : NEW PROGRAMS FOR LU6.2            *\n*   $L7= 211    160 8108   HDQJDH : VOLUME MANAGER                    *\n*   $L8= I22    160 811103 HD6PRM : LUTYPE 6.2 FSMS                   *\n*   $L9= I22    160 820215 HD6PRM : LUTYPE 6.2 - DFHZERH ERROR TRACE  *\n*   $LA= I22    160 820312 HD6PRM : ZCP EXIT TRACE ANALYSIS           *\n*   $LB= J42    161 820908 HD0JADT: CHANGE TRANSFORMER TRACE ENTRY    *\n*   $LC= 131    161 8303   HDUGM  : TRANSIENT DATA MULTIPLE BUFFERS   *\n*   $LD= 121    161 8304   HDUGM  : TEMP STORAGE MULTIPLE BUFFERS     *\n*   $LE= 970    170 8308   HD0TMB : SPECIAL FEATURES DEVELOPMENT      *\n*   $LF= S00    170 830901 HD5LL  : XSP SECURITY TRACE ENTRY ANALYSIS *\n*   $LG= U8B    170 8311   HDFPSC : NEW RECORDS FOR ZLOC USING RDO    *\n*   $LH= U8C    170 8401   HD0HJC : ZCP TRACE ENTRIES FOR TC INSTALL  *\n*   $LI= 140    170 8402   HD0ADB : DFHSKP TRACE ENTRIES              *\n*   $LJ= U8B    170 8404   HD0ADB : DFHTMP TCTE/TCTN/TCTS TYPE CODES  *\n*   $LK= U80    170 8405   HDJIH  : DFHTOR TRACE ENTRIES              *\n*   $LL= U74    170 8405   HDBKED : DFHCCP, DFHRCP, WAITINIT ENTRIES  *\n*   $LM= A00    170 8405   HDIVJH : GENERAL CODE ENHANCEMENTS         *\n*   $LN= IA6    170 8408   HDFPSC : ZCP LU6.2 IMPROVEMENT             *\n*   $LO= 62B    170 8408   HDUGM  : FAST TD RESTART TRACE ENTRIES     *\n*   $LP= 118    170 8409   HDPBGH : KCP ATTACH TRACE ENTRIES          *\n*   $LQ= 119    170 8409   HDPBGH : KCP UPDATE TASKTIME TRACE ENTRY   *\n*   $LR= 6B0    170 8410   HDIVJH : TACP TRACE ENTRIES NOW STANDARD   *\n*   $LS= D33    170 8410   HD1MA  : TRACE ENTRIES FOR BMS QUERY       *\n*   $LT= U8D    170 8410   HD0NKBE: AUTOINSTALL TRACE ENTRIES         *\n*   $LU= FC2    170 8411   HDDRGC : FCP REVISED FILE STATES TRACE     *\n*   $LV= 6B0    170 8412   HDIVJH : FE TRACE ON BEHALF OF GLOBAL TRAP *\n*    LW= RESERVED FOR LINE ITEM   :                                   *\n*    LX= RESERVED FOR LINE ITEM   :                                   *\n*    LY= RESERVED FOR LINE ITEM   :                                   *\n*    LZ= RESERVED FOR LINE ITEM   :                                   *\n*   $M1= 8D0    161 8205   HD8STC : NEW DL/I IWAIT TRACE              *\n*   $P1= M15544 160 820308 HD0LGP : UNPRINTABLE/UNDISPLAYABLE CHARS   *\n*   $P2= M17176 160 821201 HDPBGH : DFHKC FORCE PURGE TRACE ENTRY     *\n*   $P3= M17307 160 821220 HDPBGH : DFHKC ENTRIES                     *\n*   $P4= M27114 170 8408   HDIVJH : CORRECT LARGE TIME INTERVALS      *\n*   $P5= M29271 170 8503   HDQJDH : DECODE JCP EXIT TRACE RESPONSE    *\n*   $P6= M30576 170 8506   HD1YBC : CORRECT ICP '60' ENTRY            *\n*   $P7= M31030 170 850801 HDFPSC : CORRECT WAIT/NOWAIT FOR LOCATE    *\n*    P8= RESERVED FOR PTM         :                                   *\n*    P9= RESERVED FOR PTM         :                                   *\n*    PA= RESERVED FOR PTM         :                                   *\n*   $01= A07929 160 820309 HD0LGP : TYPE EE FORMAT 6 RECORDS WRONG    *\n*   $02= A22830 170 8407   HDIVJH : DECODE ALP ALLOCATE TRACE ENTRY   *\n*   $03= A14048 170 8410   HDIVJH : FE TRACE ENTRIES (SEE DCR 1507)   *\n*   $04= A36667 170 8503   HDIVJH : DECODE ALP RELEASE_ABNORMAL       *\n*    05= RESERVED FOR APAR        :                                   *\n*    06= RESERVED FOR APAR        :                                   *\n*    07= RESERVED FOR APAR        :                                   *\n*    08= RESERVED FOR APAR        :                                   *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  FUNCTION =                                                         *\n*        THIS ROUTINE DECODES ONE TRACE ENTRY                         *\n*        AND PLACES ITS OUTPUT IN PRINT LINE.                         *\n*                                                                     *\n*  INPUT =                                                            *\n*             REGISTER 15 = ENTRY POINT DFHTUREN                      *\n*             REGISTER 14 = RETURN ADDRESS                            *\n*             REGISTER  1 = 4 WORD PLIST                              *\n*             P 1ST WORD  =A(32 BYTE TRACE ENTRY TO DECODE)           *\n*             P 2ND WORD  =A(133 BYTE PRINT LINE FOR OUTPUT)          *\n*                           (ALREADY BLANKED WITH ASA CONTROL CHARS)  *\n*             P 3RD WORD  =LENGTH OF LINE                             *\n*                            LINE MUST BE AT LEAST 80 BYTES LONG      *\n*             P 4TH WORD  = STCK VALUE OF PREVIOUS TRACE ENTRY        *\n*                                                                     *\n*  OUTPUT =                                                           *\n*              PRINT LINE POINTED TO BY PLIST                         *\n*              DECODED TRACE ENTRY IN CHARACTER FORM                  *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nDFHTUREN CSECT                                                 @BD910JY\n         DFHEJECT ,                                            @BD910JY\n***********************************************************************\n* * *          R E G I S T E R   D E F I N I T I O N S            * * *\n***********************************************************************\n         SPACE 1\n         DFHREGS ,                 DEFINE GENERAL REGISTERS\n         SPACE 3\n***********************************************************************\n* * *          P R I V A T E   D A T A   A R E A S                * * *\n***********************************************************************\n*\n*\n*        FIRST LEVEL TABLE (MAJOR CODES)\n*\nTAB1DST  DSECT                                                 @BD910JY\nTAB1TABO DS    AL2                 OFFSET OF SECOND TABLE      @BD910JY\nTAB1TABR DS    AL2                 OFFSET OF RESPONSE TABLE    @BBAI20Y\n*AB1EX2A DS    AL2                 OFFSET OF EXIT IF ANY       @BD910JY\nTAB1LEN  DS    X                   CHARACTER NAME LENGTH       @BD910JY\nTAB1NAM  DS    C                   CHARACTER NAME(1-N)         @BD910JY\n*\n*        MINOR TABLE HEADER\n*\nTAB2IDST DSECT\nTAB2ITYP DS    AL1                 TYPE OF COMPARE\nTAB2IOFF DS    AL1                 OFFSET FIELD\nTAB2IEX1 DS    AL2                 EXIT OFFSET\nTAB2INX1 DS    AL2                 NEXT ADDRESS OFFSET\nTAB2IEND EQU   *-TAB2IDST          LENGTH\n*\n*        MINOR TABLE DSECT\n*\nTAB2DST  DSECT                                                 @BD910JY\nTAB2ID   DS    XL2                 COMPARE CHARACTER           @BD910JY\nTAB2TABO DS    AL2                 EXIT OFFSET                 @BD910JY\nTAB2LEN  DS    X                   LENGTH OF CHARACTER STRING  @BD910JY\nTAB2DATA DS    C                   ACTUAL DATA(1-N)            @BD910JY\n*\n*\n*        TRACE TABLE ENTRY FORMAT\n*\n         DFHTRACE  TYPE=DSECT\n*\n*        OUTPUT DSECT DESCRIPTION\n*        NOTE THAT START MAY NOT CORRESPOND TO BEGINNING\n*        OF PRINT LINE\nPRINTDST DSECT                                                 @BD910JY\nTURPRINT DC    0CL132' '           PRINT WORK AREA MAXIMUM  @EG00X @L5C\nTURPRITM DC    CL15' '             TIME-OF-DAY              @EG00X @L5A\n         DC    CL2' '                                       @EG00X @L5A\nTURPRIHX EQU   *                   HEX  TABLE POSITION      @EG00X @L5C\nTURPRIID DC    CL(2*L'ZTRID)' '    TRACE IDENTIFIER\n         DC    C' '\nTURPRIRE DC    CL(2*L'ZTRRETAD)' ' REGISTER 14\n         DC    C' '\nTURPRITR DC    CL(2*L'ZTRTR)' '    TYPE OF REQUEST\n         DC    C' '                                         @EG00X @L5A\nTURPRITI DC    CL(2*L'ZTRTCAID-1)' '  TASK IDENTIFIER       @EG00X @L5C\n         DC    C' '                                         @EG00X @L5A\nTURPRID1 DC    CL(2*L'ZTRDATA1)' ' DATA FIELD A (HEX)\n         DC    C' '\nTURPRID2 DC    CL(2*L'ZTRDATA2)' ' DATA FIELD B (HEX)\n         DC    C' '\nTURPRICH DC    CL8' '              FIELDS A & B (CHAR)      @EG00X @L5C\n         DC    C' '                                         @EG00X @L5A\nTURPRRSN DC    CL8' '              RESOURCE NAME            @EG00X @L5A\n         DC    CL2' '                                       @EG00X @L5A\nTURPRILT EQU   *                   MAJOR ID POSITION        @EG00X @L5C\n*\n*\n         DFHEJECT                                              @BD910JY\n***********************************************************************\n* * *    TRACE ENTRY PROCESSING                                   * * *\n***********************************************************************\nDFHTUREN CSECT                                                 @BD910JY\n         USING *,R15                                           @BD910JY\nDFHTURST DS    0H                  CONVERT TYPE ENTRY CODES    @BD910JY\n         STM   R14,R11,TUESAVRG+12 SAVE REGISTERS              @BD910JY\n         DROP  R15                                             @BD910JY\n         BALR  R11,0                                           @BD910JY\n         USING *,R11                                           @BD910JY\n         LM    R2,R3,00(R1)        GET POINTER  TO TRACE ENTRY @BD910JY\n         LR    R0,R3               GET START OF LINE           @BD910JY\n         A     R0,08(R1)           GET POINTER TO END LINE     @BD910JY\n         SH    R0,=Y(TURHED2L)     LEAVE SPACE FOR INTERVAL @EG00X @L5A\n*                                  R2 = ADDRESS OF PRINT AREA 133 IN LN\n         USING PRINTDST,R3         ADDRESSABILITY FOR PRINT AR @BD910JY\n         SPACE 2                                            @EG00X @L5A\n         LTR   R2,R2               IS THERE A TRACE ENTRY?  @EG00X @L5A\n         BNZ   TURSTART            ..YES, DECODE IT         @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n***********************************************************************\n* *                                                                 * *\n* *            FORMAT A HEADING FOR THE TRACE TABLE                 * *\n* *                                                                 * *\n***********************************************************************\n         SPACE 1                                            @EG00X @L5A\n         MVC   0(TURHED1L,R3),TURHED1  COPY PART ONE        @EG00X @L5A\n         LR    R3,R0                   ADDRESS INTERVAL     @EG00X @L5A\n         MVC   0(TURHED2L,R3),TURHED2  COPY PART TWO        @EG00X @L5A\n         LM    R14,R11,TUESAVRG+12     RETRIEVE REGISTERS   @EG00X @L5A\n         BR    R14                       AND RETURN         @EG00X @L5A\n         SPACE 2                                            @EG00X @L5A\nTURHED1  DC    CL80' '                                      @EG00X @L5A\n         ORG   TURPRITM-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C'   TIME OF DAY   '                         @EG00X @L5A\n         ORG   TURPRIID-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C'ID'                                        @EG00X @L5A\n         ORG   TURPRIRE-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C' REG 14 '                                  @EG00X @L5A\n         ORG   TURPRITR-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C'REQD'                                      @EG00X @L5A\n         ORG   TURPRITI-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C'TASK '                                     @EG00X @L5A\n         ORG   TURPRID1-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C' FIELD A'                                  @EG00X @L5A\n         ORG   TURPRID2-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C' FIELD B'                                  @EG00X @L5A\n         ORG   TURPRICH-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C' CHARS  '                                  @EG00X @L5A\n         ORG   TURPRRSN-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C'RESOURCE'                                  @EG00X @L5A\n         ORG   TURPRILT-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C'TRACE TYPE'                                @EG00X @L5A\nTURHED1L EQU   *-TURHED1           LENGTH OF FIRST HEADING  @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\nTURHED2  EQU   *                                            @EG00X @L5A\n         DC    C' INTERVAL '                                @EG00X @L5A\nTURHED2L EQU   *-TURHED2           LENGTH OF SECOND HEADING @EG00X @L5A\n         SPACE 5                                            @EG00X @L5A\nTURSTART DS    0H                                           @EG00X @L5A\n         USING ZTRENTRY,R2         ADDRESSABILITY FOR TR ENTRY @BD910JY\n         SPACE 2                                            @EG00X @L5A\n***********************************************************************\n* *                                                                 * *\n* *            FORMAT HEXADECIMAL OUTPUT FIELDS                     * *\n* *                                                                 * *\n***********************************************************************\n         SPACE 2                                            @EG00X @L5A\n*   FORMAT THE TRACE ID.                                              *\n         UNPK  TURPRIID(L'TURPRIID+1),ZTRID(L'ZTRID+1)      @EG00X @L5A\n         TR    TURPRIID(L'TURPRIID),TURTRT-C'0'             @EG00X @L5A\n         MVI   TURPRIID+L'TURPRIID,C' '                     @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n*   FORMAT THE TYPE OF REQUEST BYTES.                                 *\n         UNPK  TURPRITR(L'TURPRITR+1),ZTRTR(L'ZTRTR+1)      @EG00X @L5A\n         TR    TURPRITR(L'TURPRITR),TURTRT-C'0'             @EG00X @L5A\n         MVI   TURPRITR+L'TURPRITR,C' '                     @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n*   FORMAT THE RETURN ADDRESS.                                        *\n         UNPK  TURPRIRE(L'TURPRIRE+1),ZTRRETAD(L'ZTRRETAD+1)           *\n                                                            @EG00X @L5A\n         TR    TURPRIRE(L'TURPRIRE),TURTRT-C'0'             @EG00X @L5A\n         MVI   TURPRIRE+L'TURPRIRE,C' '                     @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n*   FORMAT THE FIRST DATA FIELD.                                      *\n         UNPK  TURPRID1(L'TURPRID1+1),ZTRDATA1(L'ZTRDATA1+1)           *\n                                                            @EG00X @L5A\n         TR    TURPRID1(L'TURPRID1),TURTRT-C'0'             @EG00X @L5A\n         MVI   TURPRID1+L'TURPRID1,C' '                     @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n*   FORMAT THE SECOND DATA FIELD.                                     *\n         UNPK  TURPRID2(L'TURPRID2+1),ZTRDATA2(L'ZTRDATA2+1)           *\n                                                            @EG00X @L5A\n         TR    TURPRID2(L'TURPRID2),TURTRT-C'0'             @EG00X @L5A\n         MVI   TURPRID2+L'TURPRID2,C' '                     @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n*   FORMAT THE TASK IDENTIFIER.                                       *\n         UNPK  TURPRITI(L'TURPRITI),ZTRTCAID(L'ZTRTCAID)    @EG00X @L5A\n         OI    TURPRITI+L'TURPRITI-1,C'0'                   @EG00X @L5A\n         SPACE 2                                            @EG00X @L5A\n***********************************************************************\n* *                                                                 * *\n* *            FORMAT CHARACTER OUTPUT FIELDS                       * *\n* *                                                                 * *\n***********************************************************************\n         SPACE 2\n*   CONVERT THE TASK IDENTIFIER TO CHARACTER IF IT'S ONE OF THE       *\n*   SPECIAL ONES.                                                     *\n         TM    ZTRTCAID,X'C0'        TEST FOR ALPHA\n         BNO   TUPNOSYN\n         MVC   TURPRITI(3),ZTRTCAID   COPY TASK IDENTIFIER  @EG00X @L5C\n         MVC   TURPRITI+3(2),=CL2'  ' SET REST TO BLANKS    @EG00X @L5C\nTUPNOSYN DS    0H\n         SPACE 1                                            @EG00X @L5A\n*   FORMAT THE RESOURCE NAME.                                         *\n         MVC   TURPRRSN,ZTRRESCE   COPY RESOURCE NAME       @EG00X @L5A\n         TR    TURPRRSN,TUETRANS   TRANSLATE TO PRINTABLE   @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n*   FORMAT THE FIRST AND SECOND DATA FIELDS IF THEY ARE PRINTABLE.    *\n         MVC   TURPRICH,ZTRDATA1   MOVE TRACE ENTRY         @EG00X @L5C\n         TR    TURPRICH,TUETRANS   TRANSLATE TO PRINTABLE      @BD910JY\n         SPACE 2                                            @EG00X @L5A\n***********************************************************************\n* *                                                                 * *\n* *            PREPARE TO INTERPRET THE TRACE TYPE AND TYPE         * *\n* *            OF REQUEST.                                          * *\n* *                                                                 * *\n***********************************************************************\n         SPACE 2                                            @EG00X @L5A\n         LA    R7,TURPRILT         SET IN PRINT POSITION       @BBAI20Y\n*                                                                     *\n*        NOW DECODE SUBTYPE OF TRACE ENTRY ..                         *\n*        AND PICK APPROPRIATE TABLE                                   *\n         IC    R4,ZTRTR+1          GET REQUEST TYPE         @EG00X @L5C\n         N     R4,=F'15'           ENSURE 0 -15                @BBAI20Y\n         STH   R4,TURNTYSV         SAVE REQUEST TYPE           @BBAI20Y\n         STC   R4,TURNREQD         SET IN REQUEST FIELD        @BBAI20Y\n*                                                              @BBDIA0Y\n         AR    R4,R4               *2                          @BBDIA0Y\n         LH    R4,TUTENTAB(R4)     GET INDEX FOR MAJOR TYPES   @BBDIA0Y\n         A     R4,=A(TUTI1SRT)     ADD BASE ADDRESS            @BBDIA0Y\n*                                                              @BBDIA0Y\n***********************************************************************\n*    CORRECT TABLE SELECTED                                    @BBDIA0Y\n*        DETERMINE TYPE OF TRACE ENTRY                         @BBDIA0Y\n*   R4 POINTS TO TABLE WITH                                    @BBDIA0Y\n*       OFFSET 00 = MINIMUM NUMBER                             @BBDIA0Y\n*       OFFSET 02 = START OF TABLE FROM MINIMUM ENTRY          @BBDIA0Y\n***********************************************************************\n         SPACE 2                                               @BD910JY\n         SR    R15,R15             CLEAR WORK REGISTER         @BD910JY\n         IC    R15,ZTRID           GET ID                   @EG00X @L5C\n         SH    R15,00(R4)          SUBTRACT STARTING ID        @BD910JY\n         BP    TUENOTUS            ..IF ABOVE BRANCH ROUND     @BD910JY\n*\n         SR    R15,R15             SET ZERO FOR USER ENTRY     @BD910JY\nTUENOTUS DS    0H                                              @BD910JY\n         AR    R15,R15             MULTIPLY BY TWO             @BD910JY\n         LH    R9,02(R4,R15)       GET ENTRY OFFSET            @BD910JY\n         A     R9,TUTB1STA         GET TABLE ENTRY ADDRESS     @BD910JY\n*\n         USING TAB1DST,R9                                      @BD910JY\n         LA    R14,TAB1LEN         SET AT LENGTH\n         SR    R4,R4                                           @BD910JY\n         IC    R4,TAB1LEN          GET LENGTH                  @BD910JY\n         BAL   R6,TURNVMDM         OUTPUT CONSTANT             @BD910JY\n*                                                                     *\n*     R9 = CURRENT ADDRESS IN THE MAJOR TABLE                         *\n*                                                                     *\n         SR    R4,R4               CLEAR R4                    @BBAI20Y\n         LH    R5,TAB1TABO         PICK UP MINOR DISPLACEMENT  @BBAI20Y\n*                                                              @BBAI20Y\n         CLI   TURNTYSV+1,05       RETURN ID ?                 @BM13334\n         BNE   TURREP2                                         @BM13334\n*    OUTPUT RETN CHARACTER STRING SINCE LIFO RETURN TYPE              *\n         LA    R14,RETNCHRL+2      SET AT LENGTH               @BM13334\n         SR    R4,R4                                           @BM13334\n         IC    R4,00(R14)          GET LENGTH                  @BM13334\n         BAL   R6,TURNVMDM         OUTPUT CONSTANT             @BM13334\n*                                                                     *\n         SR    R4,R4               CLEAR WORK REG              @BM13334\n         LH    R5,TAB1TABR         GET A(RETURN TABLE) OFFSET  @BM13334\n*                                                              @BBAI20Y\n*     R5 = CURRENT ADDRESS IN THE MINOR TABLE\n*                                                              @BBAI20Y\nTURREP2  DS    0H\n         A     R5,TUTB2STA         POINT TO ACTUAL TABLE ENTRY\n         USING TAB2IDST,R5\n         MVC   TURN2ISV,TAB2IDST   COPY TABLE ENTRY\n*                                                              @BBAI20Y\n         SR    R15,R15             CLEAR R15\n         IC    R15,TAB2IOFF        GET OFFSET\n         LA    R15,ZTRENTRY(R15)   GET ADDRESS IN TRACE TABLE\n         MVC   TURNREQD(4),00(R15) MOVE MINOR CODE             @BM10519\n*                                                              @BBAI20Y\n         LH    R6,TAB2IEX1         GET EXIT ADDRESS\n         BAL   R6,TUTE1SRT(R6)     GO TO EXIT\n*                                                              @BBAI20Y\n         SR    R15,R15\n         IC    R15,TAB2ITYP        GET COMPARE TYPE\n         LH    R15,TURBRT(R15)     GET POINTER TO SUBROUTINE\n         LA    R5,TAB2IEND(R5)\n         DROP  R5\n         BAL   R6,TURBRT(R15)      GO TO COMPARE SUBROUTINE\n*                                                                     *\n         LH    R5,TURN2ISV+(TAB2INX1-TAB2IDST) GET NEXT ADDR\n         LTR   R5,R5               ANY MORE DECODING\n         BNZ   TURREP2             YES GO AGAIN\n*\nTURETURN DS    0H                                              @BD910JY\n***********************************************************************\n* *      FORMAT THE TIME OF DAY INTO THE OUTPUT.                    * *\n***********************************************************************\n         SPACE 1                                            @EG00X @L5A\n         L     R1,TUESAVRG+24      RETRIEVE PARM ADDRESS    @EG00X @L5A\n         L     R5,ZTRTOD           GET ENTRY TIME           @EG00X @L5A\n*   THE CONSTANT APPEARING IN THE FOLLOWING INSTRUCTIONS IS EQUAL     *\n*   TO                                                                *\n*               24*60*60*(1000000/32) - 2**32 .                       *\n*                                                                     *\n*   IT IS USED IN THIS FORM TO GENERATE A FULLWORD CONTAINING AN      *\n*   UNSIGNED 32-BIT INTEGER REPRESENTING THE NUMBER OF                *\n*   32-MICROSECOND INTERVALS IN 24 HOURS.                             *\n         CL    R5,=F'-1594967296'  PAST NEXT MIDNIGHT?      @EG00X @L5A\n         BL    TURTMOK             ..NO, SKIP               @EG00X @L5A\n         SL    R5,=F'-1594967296'  ADJUST TIME-OF-DAY       @EG00X @L5A\nTURTMOK  EQU   *                                            @EG00X @L5A\n         XR    R4,R4               CONVERT TO MICROSECS    @EG000L @L5A\n         SLDL  R4,5                SHIFT 5 = MULT BY 32    @EG000L @L5A\n         D     R4,=F'1000000'      CONVERT TO SECONDS       @EG00X @L5A\n*   REGISTER 5 NOW CONTAINS THE TIME OF THIS TRACE ENTRY IN           *\n*   SECONDS SINCE MIDNIGHT AND REGISTER 4 CONTAINS THE REMAINDER      *\n*   IN MICROSECONDS.                                                  *\n         CVD   R4,TURNDWRD         CONVERT TO PRINTABLE     @EG00X @L5A\n         UNPK  TURPRITM+9(6),TURNDWRD CHARACTERS            @EG00X @L5A\n         OI    TURPRITM+14,C'0'    MAKE LAST CHAR PRINTABLE @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n         XR    R4,R4               CLEAR FOR DIVIDE         @EG00X @L5A\n         D     R4,=F'60'           SEPARATE THE SECONDS     @EG00X @L5A\n*   REGISTER 5 NOW CONTAINS THE TIME OF THIS TRACE ENTRY IN MINUTES   *\n*   FROM MIDNIGHT AND REGISTER 4 CONTAINS THE REMAINDER IN SECONDS.   *\n         MH    R5,=H'100'          COLLECT THE MINUTES AND  @EG00X @L5A\n         AR    R5,R4                 SECONDS TOGETHER       @EG00X @L5A\n         XR    R4,R4               CLEAR FOR DIVIDE         @EG00X @L5A\n         D     R4,=F'6000'         SEPARATE THE HOURS       @EG00X @L5A\n*   REGISTER 5 NOW CONTAINS THE TIME OF THIS TRACE ENTRY IN HOURS     *\n*   FROM MIDNIGHT AND REGISTER 4 CONTAINS THE REMAINDER IN MINUTES    *\n*   AND SECONDS.                                                      *\n         MH    R5,=H'10000'        COLLECT THE HOURS AND    @EG00X @L5A\n         AR    R5,R4                 MINUTES TOGETHER       @EG00X @L5A\n         CVD   R5,TURNDWRD         CONVERT TO DECIMAL       @EG00X @L5A\n         UNPK  TURPRITM+2(6),TURNDWRD    UNPACK SIX DIGITS  @EG00X @L5A\n         MVC   TURPRITM(2),TURPRITM+2    MOVE THE HOURS     @EG00X @L5A\n         MVI   TURPRITM+2,C':'           ADD SEPARATOR      @EG00X @L5A\n         MVC   TURPRITM+3(2),TURPRITM+4  MOVE THE MINUTES   @EG00X @L5A\n         MVI   TURPRITM+5,C':'           ADD SEPARATOR      @EG00X @L5A\n         OI    TURPRITM+7,C'0'     MAKE LAST CHAR PRINTABLE @EG00X @L5A\n         MVI   TURPRITM+8,C'.'     INSERT DECIMAL POINT     @EG00X @L5A\n         SPACE 2                                            @EG00X @L5A\n***********************************************************************\n* *      FORMAT THE INTERVAL BETWEEN THIS ENTRY AND THE             * *\n* *      PREVIOUS ONE.                                              * *\n***********************************************************************\n         SPACE 1                                            @EG00X @L5A\n         CLC   12(4,R1),=F'-1'     ANY PREVIOUS ENTRY?             @P4M\n         BE    TURCSNPE            ..NO, SKIP INTERVAL CALC        @P4M\n         SPACE 1                                                   @P4A\n*   CALCULATE THE INTERVAL IN UNITS OF 32 MICROSECONDS.               *\n         L     R5,ZTRTOD           GET ENTRY TIME AGAIN     @EG00X @L5A\n         SL    R5,12(,R1)          SUBTRACT PREVIOUS TIME   @EG00X @L5A\n         CLC   ZTRTOD,12(R1)       CURRENT TIME < PREVIOUS TIME??  @P4A\n         BNL   TURCSNOK            ..NO, THAT'S FINE               @P4A\n         AL    R5,=F'-1594967296'  ADJUST INTERVAL BY 24 HOURS     @P4A\nTURCSNOK DS    0H                                                  @P4A\n         SPACE 1                                                   @P4A\n*   DETERMINE IF THE INTERVAL IS SIGNIFICANT.                         *\n         CL    R5,SIGTIME1         IS INTERVAL SIGNIFICANT?        @P4C\n         BL    TURCSNPX            .. NO THEN BRANCH ROUND  @EG00X @L5A\n         SPACE 1                                               @BM09140\n         LR    R7,R0               ADDRESS END OF LINE             @P4M\n         CL    R5,SIGTIME2         IS INTERVAL VERY SIGNIFICANT?   @P4C\n         BNH   TURCSNPT            ..NO, BRANCH ROUND              @P4C\n         SPACE 1                                               @BM09140\n         MVI   0(R7),C'*'          SET A FLAG               @EG00X @L5A\n         CL    R5,SIGTIME3         TOO HIGH TO PRINT?              @P4C\n         BL    TURCSNPT            ..NO, PRINT IT           @EG00X @L5A\n         MVC   1(9,R7),=C'*********'                        @EG00X @L5A\n         B     TURCSNTH                                     @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\nTURCSNPT DS    0H                                           @EG00X @L5A\n*   PRINT THE INTERVAL IN MICROSECONDS.                               *\n         MH    R5,=H'32'           CONVERT TO MICROSECONDS         @P4M\n         CVD   R5,TURNDWRD         CONVERT TO PACKED,       @EG00X @L5A\n         UNPK  2(8,R7),TURNDWRD      UNPACK AND MAKE        @EG00X @L5A\n         OI    9(R7),C'0'              LAST CHAR PRINTABLE  @EG00X @L5A\n         MVC   1(2,R7),2(R7)       SHIFT SECONDS            @EG00X @L5A\n         MVI   3(R7),C'.'          INSERT DECIMAL POINT     @EG00X @L5A\n         SPACE 1                                               @BM09140\nTURCSNTH DS    0H  INTERVAL TOO HIGH TO BE PRINTED          @EG00X @L5A\nTURCSNPX DS    0H                                           @EG00X @L5A\nTURCSNPE DS    0H                                           @EG00X @L5A\n         MVC   12(4,R1),ZTRTOD     SAVE CURRENT TIME        @EG00X @L5A\n         SPACE 2                                            @EG00X @L5A\n***********************************************************************\n* * *          RETURN TO THE CALLER                               * * *\n***********************************************************************\n         SPACE 1                                            @EG00X @L5A\n         LM    R14,R11,TUESAVRG+12 RESTORE REGS                @BD910JY\n         BR    R14                 RETURN                      @BD910JY\n*\nTURN2ISV DS    CL8                 SAVE AREA FOR MINOR HEADING\nTURBRT   DS    0H\n         DC    AL2(TURNVTM-TURBRT)  00\n         DC    AL2(TURNVCLI-TURBRT) 02\n         DC    AL2(TURNVCLC-TURBRT) 04\n         DC    AL2(TURNV2BN-TURBRT) 06                         @BM10519\n         DC    AL2(TURNV1BN-TURBRT) 08                         @BM10519\n         DC    AL2(TURNVRBN-TURBRT) 10                         @BM10519\n         DC    AL2(TURNVLBN-TURBRT) 12                         @BM10519\n         DC    AL2(TURNV3DE-TURBRT) 14                         @BM10519\n         DC    AL2(TURNV2DE-TURBRT) 16                         @BM10519\n         DC    AL2(TURNV1DE-TURBRT) 18                         @BM10519\n         DC    AL2(TURNVCLC-TURBRT) 20                         @BM10519\n         DC    AL2(TURNVCLC-TURBRT) 22                         @BM10519\n*\n         DFHEJECT ,                                            @BD910JY\n***********************************************************************\n*        SUBROUTINE TO FIND MINOR FLAGS\n*        USING COMPARE TYPE CLC\n*        INPUT\n*             R6 = RETURN ADDRESS\n*             R7 = PRINT POSITION\n*             R5 = ADDRESS OF TABLE ENTRY\n*             R0 = END OF PRINT POSITION\n*        WORK\n*             R4 = WORK REGISTER\n*        OUTPUT\n*             R6 = RETURN ADDRESS UNCHANGED\n*             R7 = PRINT POSITION (UPDATED IF MATCH FOUND)\n*             R5 = ADDRESS OF NEXT TABLE ENTRY\n*             R0 = END OF PRINT POSITION UNCHANGED\n***********************************************************************\nTURNVCLC DS    0H                  SEARCH MINOR TABLE          @BD910JY\n         USING TAB2DST,R5\n         CLC   TAB2ID(2),TURNVEND  END OF MINOR TABLE          @BD910JY\n         BER   R6                  ..YES, RETURN\n*\n         IC    R4,TAB2LEN          GET CONSTANTS LENGTH        @BD910JY\n         CLI   TAB2LEN,TUMAXLEN    ENSURE LOOKING AT A REASONABLE      *\n                                    LENGTH OF DUMMY.           @BD910JY\n         BH    TURNVMER            GET OUT NOW IF ERROR        @BD910JY\n*\n         CLC   TAB2ID(2),TURNREQD\n         BNE   TURNCLC1            ..NO, DON'T PRINT\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS\n         LA    R14,TAB2LEN         SET AT LENGTH BYTE\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS\n         LH    R14,TAB2TABO        GET EXIT ADDR\n         LTR   R14,R14             IS THERE ANY..\n         BZR   R6                  NO THEN LEAVE DEFAULT\n*\n         STH   R14,TURN2ISV+(TAB2INX1-TAB2IDST) GET NEXT ADDR\n         BR    R6\n*\nTURNCLC1 DS    0H\n         LA    R5,TAB2DATA+1(R4)   POINT TO NEXT ENTRY         @BD910JY\n         B     TURNVCLC            GO LOOK AT IT               @BD910JY\n          DFHEJECT                                             @BM10519\n***********************************************************************\n*        SUBROUTINE TO FIND MINOR FLAGS\n*        USING COMPARE TYPE CLI\n*        INPUT\n*             R6 = RETURN ADDRESS\n*             R7 = PRINT POSITION\n*             R5 = ADDRESS OF TABLE ENTRY\n*             R0 = END OF PRINT POSITION\n*        WORK\n*             R4 = WORK REGISTER\n*        OUTPUT\n*             R6 = RETURN ADDRESS UNCHANGED\n*             R7 = PRINT POSITION (UPDATED IF MATCH FOUND)\n*             R5 = ADDRESS OF NEXT TABLE ENTRY\n*             R0 = END OF PRINT POSITION UNCHANGED\n***********************************************************************\nTURNVCLI DS    0H                  SEARCH MINOR TABLE          @BD910JY\n         MVI   TURNREQD+1,00       ENSURE ZERO\n         USING TAB2DST,R5\n         CLC   TAB2ID(2),TURNVEND  END OF MINOR TABLE       @E211Q @L7C\n         BER   R6                  ..YES, RETURN\n*\n         IC    R4,TAB2LEN          GET CONSTANTS LENGTH     @E211Q @L7C\n         CLI   TAB2LEN,TUMAXLEN    ENSURE LOOKING AT A REASONABLE LEN  *\n                                   DUMMY\n         BH    TURNVMER            GET OUT NOW IF ERROR\n*\n         IC    R15,TAB2ID          GET COMPARE CHARACTER\n         EX    R15,CLIINSTR        MINOR CODE MATCH\n         BNE   TURNCLI1            ..NO, DON'T PRINT\n*\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS\n         LA    R14,TAB2LEN         SET AT LENGTH BYTE\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE\n*\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS\n         LH    R14,TAB2TABO        GET EXIT ADDR\n         LTR   R14,R14             IS THERE ANY..\n         BZR   R6                  NO THEN LEAVE DEFAULT\n*\n         STH   R14,TURN2ISV+(TAB2INX1-TAB2IDST) SET NEXT ADDR\n         BR    R6\n*\nTURNCLI1 DS    0H\n         LA    R5,TAB2DATA+1(R4)   POINT TO NEXT ENTRY         @BD910JY\n         B     TURNVCLI            GO LOOK AT IT               @BD910JY\n*\nCLIINSTR CLI   TURNREQD,00         MINOR CODE MATCH\n         DFHEJECT                                              @BM10519\n***********************************************************************\n*        SUBROUTINE TO FIND MINOR FLAGS\n*        USING COMPARE TYPE TM\n*        INPUT\n*             R6 = RETURN ADDRESS\n*             R7 = PRINT POSITION\n*             R5 = ADDRESS OF TABLE ENTRY\n*             R0 = END OF PRINT POSITION\n*        WORK\n*             R4 = WORK REGISTER\n*        OUTPUT\n*             R6 = RETURN ADDRESS UNCHANGED\n*             R7 = PRINT POSITION (UPDATED IF MATCH FOUND)\n*             R5 = ADDRESS OF NEXT TABLE ENTRY\n*             R0 = END OF PRINT POSITION UNCHANGED\n***********************************************************************\nTURNVTM  DS    0H                  SEARCH MINOR TABLE\n         USING TAB2DST,R5\n         CLC   TAB2ID(2),TURNVEND  END OF MINOR TABLE\n         BER   R6                  ..YES, RETURN\n*\n         IC    R4,TAB2LEN          GET CONSTANTS LENGTH\n         CLI   TAB2LEN,TUMAXLEN    ENSURE LOOKING AT A REASONABLE LEN  *\n                                   DUMMY\n         BH    TURNVMER            GET OUT NOW IF ERROR\n*\n         IC    R15,TAB2ID          GET COMPARE CHARACTER\n         EX    R15,TMINSTR         MINOR CODE MATCH\n         BNO   TURNTM1             ..NO, DON'T PRINT\n*\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS\n         LA    R14,TAB2LEN         SET AT LENGTH BYTE\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS\n*\nTURNTM1  DS    0H\n         LA    R5,TAB2DATA+1(R4)   POINT TO NEXT ENTRY\n         B     TURNVTM             GO LOOK AT IT\n*\nTMINSTR  TM    TURNREQD,00         MINOR CODE MATCH\n*\nTURNVMER DS    0H\n         LA    R5,TUTERR           SET ERROR ENTRY\n         IC    R4,TAB2LEN          GET CONSTANTS LENGTH\n         LA    R14,TAB2LEN         SET AT LENGTH BYTE\n         B     TURNVMDM            OUTPUT IT\n*                                                              @BM10519\nTURN2ISR DS    F                                               @BM10519\n          DFHEJECT                                             @BM10519\n***********************************************************************\n*        SUBROUTINE TO CONVERT A FIELD                         @BM10519\n*        USING INPUT FIELD OF 1 OR 2 BYTES                     @BM10519\n*        INPUT                                                 @BM10519\n*             R6 = RETURN ADDRESS                              @BM10519\n*             R7 = PRINT POSITION                              @BM10519\n*             R5 = ADDRESS OF TABLE ENTRY                      @BM10519\n*             R0 = END OF PRINT POSITION                       @BM10519\n*        WORK                                                  @BM10519\n*             R4 = WORK REGISTER                               @BM10519\n*        OUTPUT                                                @BM10519\n*             R6 = RETURN ADDRESS UNCHANGED                    @BM10519\n*             R7 = PRINT POSITION (UPDATED IF MATCH FOUND)     @BM10519\n*             R5 = ADDRESS OF NEXT TABLE ENTRY                 @BM10519\n*             R0 = END OF PRINT POSITION UNCHANGED             @BM10519\n***********************************************************************\nTURNV2BN DS    0H                  HALF WORD BINARY            @BM10519\n         LH    R15,TURNREQD                                    @BM10519\n         CVD   R15,TURNDWRD        CONVERT TO DECIMAL          @BM10519\n         UNPK  TURNOUTD(5),TURNDWRD+5(3) CONVERT TO CHAR       @BM10519\n         OI    TURNOUTD+4,C'0'     ENSURE PRINTABLE            @BM10519\n         MVI   TURNOUTL,04         SET UP LENGTH               @BM10519\n         IC    R4,TURNOUTL         GET CONSTANTS LENGTH        @BM10519\n*                                                              @BM10519\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS         @BM10519\n         LA    R14,TURNOUTL        SET AT LENGTH BYTE          @BM10519\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE      @BM10519\n*                                                              @BM10519\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS      @BM10519\n         BR    R6                                              @BM10519\n         DFHEJECT                                              @BM10519\n*                                                              @BM10519\n*       1 BYTE BINARY TO PRINTABLE CONVERSION                  @BM10519\nTURNV1BN DS    0H                  BYTE      BINARY            @BM10519\n         SR    R15,R15                                         @BM10519\n         IC    R15,TURNREQD        GET THE NUMBER              @BM10519\n         CVD   R15,TURNDWRD        CONVERT TO DECIMAL          @BM10519\n         UNPK  TURNOUTD(3),TURNDWRD+6(2) CONVERT TO CHAR       @BM10519\n         OI    TURNOUTD+2,C'0'     ENSURE PRINTABLE            @BM10519\n         MVI   TURNOUTL,02         SET UP LENGTH               @BM10519\n         IC    R4,TURNOUTL         GET CONSTANTS LENGTH        @BM10519\n*                                                              @BM10519\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS         @BM10519\n         LA    R14,TURNOUTL        SET AT LENGTH BYTE          @BM10519\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE      @BM10519\n*                                                              @BM10519\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS      @BM10519\n         BR    R6                                              @BM10519\n*                                                              @BM10519\n         DFHEJECT                                              @BM10519\n*    RIGHT HAND BYTE CONVERSION                                       *\n*                                                                     *\nTURNVRBN DS    0H                  HALF WORD BINARY            @BM10519\n         IC    R15,TURNREQD        GET BYTE                    @BM10519\n         N     R15,=F'15'          GET LOWER PART              @BM10519\n         CVD   R15,TURNDWRD        CONVERT TO DECIMAL          @BM10519\n         UNPK  TURNOUTD(3),TURNDWRD+6(2) CONVERT TO CHAR       @BM10519\n         OI    TURNOUTD+2,C'0'     ENSURE PRINTABLE            @BM10519\n         MVC   TURNOUTD(2),TURNOUTD+1 MOVE DOWN                @BM10519\n         MVI   TURNOUTL,04         SET UP LENGTH               @BM10519\n         IC    R4,TURNOUTL         GET CONSTANTS LENGTH        @BM10519\n*                                                              @BM10519\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS         @BM10519\n         LA    R14,TURNOUTL        SET AT LENGTH BYTE          @BM10519\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE      @BM10519\n*                                                              @BM10519\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS      @BM10519\n         BR    R6                                              @BM10519\n*                                                              @BM10519\n*                                                              @BM10519\n         DFHEJECT                                              @BM10519\n*      LEFT HAND CONVERSION ONE BYTE                                  *\n*                                                                     *\nTURNVLBN DS    0H                  HALF WORD BINARY            @BM10519\n         IC    R15,TURNREQD        GET BYTE                    @BM10519\n         N     R15,=F'15'          GET LOWER PART              @BM10519\n         CVD   R15,TURNDWRD        CONVERT TO DECIMAL          @BM10519\n         UNPK  TURNOUTD(3),TURNDWRD+6(2) CONVERT TO CHAR       @BM10519\n         OI    TURNOUTD+2,C'0'     ENSURE PRINTABLE            @BM10519\n         MVC   TURNOUTD(2),TURNOUTD+1 MOVE DOWN                @BM10519\n         MVI   TURNOUTL,04         SET UP LENGTH               @BM10519\n         IC    R4,TURNOUTL         GET CONSTANTS LENGTH        @BM10519\n*                                                              @BM10519\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS         @BM10519\n         LA    R14,TURNOUTL        SET AT LENGTH BYTE          @BM10519\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE      @BM10519\n*                                                              @BM10519\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS      @BM10519\n         BR    R6                                              @BM10519\n*                                                              @BM10519\n         DFHEJECT                                              @BM10519\n*   PACKED DECIMAL 3 CONVERSION                                @BM10519\n*                                                              @BM10519\nTURNV3DE DS    0H                  PACKED DECIMAL 3            @BM10519\n         UNPK  TURNOUTD(5),TURNREQD(3)                         @BM10519\n         OI    TURNOUTD+4,C'0'     ENSURE PRINTABLE            @BM10519\n         MVI   TURNOUTL,04         SET UP LENGTH               @BM10519\n         IC    R4,TURNOUTL         GET CONSTANTS LENGTH        @BM10519\n*                                                              @BM10519\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS         @BM10519\n         LA    R14,TURNOUTL        SET AT LENGTH BYTE          @BM10519\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE      @BM10519\n*                                                              @BM10519\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS      @BM10519\n         BR    R6                                              @BM10519\n*                                                              @BM10519\n         DFHEJECT                                              @BM10519\n*     PACKED DEC 2 CONVERSION                                  @BM10519\n*                                                              @BM10519\nTURNV2DE DS    0H                  PACKED DECIMAL 3            @BM10519\n         UNPK  TURNOUTD(3),TURNREQD(2)                         @BM10519\n         OI    TURNOUTD+2,C'0'     ENSURE PRINTABLE            @BM10519\n         MVI   TURNOUTL,02         SET UP LENGTH               @BM10519\n         IC    R4,TURNOUTL         GET CONSTANTS LENGTH        @BM10519\n*                                                              @BM10519\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS         @BM10519\n         LA    R14,TURNOUTL        SET AT LENGTH BYTE          @BM10519\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE      @BM10519\n*                                                              @BM10519\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS      @BM10519\n         BR    R6                                              @BM10519\n*                                                              @BM10519\n         DFHEJECT                                              @BM10519\n*   PACKED DEC 1 CONVERSION                                    @BM10519\n*                                                              @BM10519\nTURNV1DE DS    0H                  PACKED DECIMAL 1            @BM10519\n         UNPK  TURNOUTD(1),TURNREQD(1)                         @BM10519\n         OI    TURNOUTD+0,C'0'     ENSURE PRINTABLE            @BM10519\n         MVI   TURNOUTL,00         SET UP LENGTH               @BM10519\n         IC    R4,TURNOUTL         GET CONSTANTS LENGTH        @BM10519\n*                                                              @BM10519\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS         @BM10519\n         LA    R14,TURNOUTL        SET AT LENGTH BYTE          @BM10519\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE      @BM10519\n*                                                              @BM10519\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS      @BM10519\n         BR    R6                                              @BM10519\n*                                                              @BM10519\n         DFHEJECT                                              @BM10519\n***********************************************************************\n*        SUBROUTINE TO OUTPUT LITERAL                          @BM10519\n*        FOR APPROPRIATE MINOR                                 @BM10519\n*        INPUT                                                 @BM10519\n*             R6 = RETURN ADDRESS                              @BM10519\n*             R7 = PRINT POSITION                              @BM10519\n*             R4 = CONSTANTS LENGTH                            @BM10519\n*             R0 = END OF PRINT POSITION\n*             R14= A(ONE BYTE LENGTH),CHAR STRING\n*        OUTPUT\n*             R6 = RETURN ADDRESS UNCHANGED\n*             R7 = UPDATED PRINT POSITION\n*             R4 = CONSTANTS LENGTH\n*             R0 = END OF PRINT POSITION UNCHANGED\n***********************************************************************\nTURNVMDM DS    0H                  FOUND MINOR CODE            @BD910JY\n         LA    R1,02(R4,R7)        BUMP TO NEXT PRINT POSITION @BD910JY\n         CR    R1,R0               HIGHER THAN MAX             @BD910JY\n         BNL   TURNVMRT            NO THEN EXIT NOW            @BD910JY\n         LTR   R4,R4               IS IT LENGTH ONE?           @BBAA12Y\n         BNZ   TURNVM02            .. NO BRANCH                @BBAA12Y\n         CLI   01(R14),C' '        IS IT REALLY NULL ?         @BBAA12Y\n         BE    TURNVMRT            .. YES THEN LEAVE MOVE      @BBAA12Y\nTURNVM02 DS    0H                                              @BBAA12Y\n         EX    R4,EXPRMVC          MOVE MINOR LITERAL TO PRT   @BD910JY\n         LA    R7,02(R4,R7)        BUMP TO NEXT PRINT POSITION @BD910JY\n*                                  (OVER LITERAL + 1 BLANK)\n*\nTURNVMRT DS    0H                                              @BD910JY\n         BR    R6                  RETURN                      @BD910JY\n*\n*\n*\nEXPRMVC  MVC   00(*-*,R7),01(R14)  EXECUTED MOVE LITERAL       @BD910JY\nTUTERR   DS    0H                                              @BD910JY\n         DFHTUTEN C=(00,00),K='*'                              @BD910JY\n*\n         DFHEJECT ,                                            @BD910JY\n***********************************************************************\n*        EXIT ROUTINES HERE\n*        EACH ROUTINE FORMAT THE REQUEST BYTES READY\n*        FOR INTERPRETATION BY THE BYTE COMPARE TABLES.\n*\n***********************************************************************\nTUTE1SRT DS    0H                  DEFAULT EXIT                @BD910JY\nTUTE1DFT DS    0H                                              @BD910JY\n         BR    R6                  JUST RETURN                 @BD910JY\n*\n*\nTUTE1EXC DS    0H                  FE EXIT                     @BD910JY\nTUTE1SYC DS    0H                  SYSTEM EXIT                 @BD910JY\nTUTE1USC DS    0H                  USER EXIT                   @BD910JY\n         SR    R4,R4               CLEAR R4                    @BD910JY\n         IC    R4,ZTRID            GET ID                   @EG00X @L5C\n         CVD   R4,TURNDWRD         CONVERT TO DECIMAL          @BD910JY\n         OI    TURNDWRD+7,X'0F'    ENSURE PRINTABLE            @BD910JY\n         UNPK  00(03,R7),TURNDWRD+6(2) SET INTO PRINT          @BD910JY\n         LA    R7,04(R7)           BUMP PRINT POINTER\n         BR    R6                  RETURN TO CALLER            @BD910JY\n*                                                              @BBAI20Y\n*        IRC TRACE EXIT                                               *\n*                                                              @BBAI20Y\nTUTE1DD2 DS    0H                  IRC TRACE EXIT              @BBAI20Y\n         NI    TURNREQD,X'F0'      CLEAR OUT UNWANTED BITS     @BBAI20Y\n         LA    R14,X'40'           SET RQE1                    @BBDIA0Y\n         TM    TURNREQD,X'90'      RQD1 + EXC = RQE1           @BBDIA0Y\n         BO    TUTDD010                                        @BBDIA0Y\n         LA    R14,X'10'           SET RQE2                    @BBDIA0Y\n         TM    TURNREQD,X'30'      RQD2 + EXC = RQE1           @BBDIA0Y\n         BO    TUTDD010                                        @BBDIA0Y\n         LA    R14,X'80'           SET RQD1 ONLY               @BBDIA0Y\n         TM    TURNREQD,X'80'      RQD1                        @BBDIA0Y\n         BO    TUTDD010                                        @BBDIA0Y\n         LA    R14,X'20'           RQD2                        @BBDIA0Y\n         TM    TURNREQD,X'20'      RQD2 ONLY                   @BBDIA0Y\n         BO    TUTDD010                                        @BBDIA0Y\n         SR    R14,R14             PUT NONE                    @BBDIA0Y\nTUTDD010 DS    0H                                              @BBDIA0Y\n         STC   R14,TURNREQD        SET UP REQUEST              @BM13334\n         BR    R6                  RETURN                      @BM13334\n*                                                              @BM13334\n*        VIO TRACE EXIT                                               *\n*                                                              @BM13334\nTUTE1EEA DS    0H                  VIO TRACE EXIT              @BM13334\n         LA    R14,X'00'           SET NONE                    @BM13334\n         TM    TURNREQD,X'03'      NEITHER DR1 OR DR2 ?        @BM13334\n         BZ    TUTEEA30            .. YES GET OUT              @BM13334\n         BO    TUTEEA10            .. RQ*3 - CONTINUE       @EI226 @L9A\n*                                                              @BM13334\n         TM    TURNREQD,X'04'      RQE OR RQD ?                @BM13334\n         BO    TUTEEA20            .. BRANCH IF RQE            @BM13334\n         LA    R14,X'80'           SET RQD1 ONLY               @BM13334\n         TM    TURNREQD,X'02'      RQD1                        @BM13334\n         BO    TUTEEA30            .. YES EXIT                 @BM13334\n         LA    R14,X'40'           RQD2                        @BM13334\n         B     TUTEEA30            ALL DONE NOW                @BM13334\n*                                                              @BM13334\nTUTEEA10 DS    0H                                           @EI226 @L9C\n         LA    R14,X'08'           SET RQE3 AT FIRST        @EI226 @L9A\n         TM    TURNREQD,X'04'      RQE OR RQD ?             @EI226 @L9P\n         BO    TUTEEA30            .. BRANCH IF RQE         @EI226 @L9A\n         LA    R14,X'04'           SET RQD3 ONLY            @EI226 @L9A\n         B     TUTEEA30            ALL DONE NOW             @EI226 @L9P\n*                                                              @BM13334\nTUTEEA20 DS    0H                                           @EI226 @L9P\n         LA    R14,X'20'           SET RQE1 ONLY               @BM13334\n         TM    TURNREQD,X'02'      RQE1                        @BM13334\n         BO    TUTEEA30            .. YES EXIT                 @BM13334\n         LA    R14,X'10'           RQE2                        @BM13334\n         B     TUTEEA30            ALL DONE NOW                @BM13334\n*    RETURN WITH ANSWER                                        @BM13334\nTUTEEA30 DS    0H                                              @BM13334\n         STC   R14,TURNREQD        SET UP REQUEST              @BM13334\n         BR    R6                  RETURN                      @BM13334\n*                                                              @BM13334\n*        EIP TRACE EXIT                                               *\n*                                                              @BBAI20Y\nTUTE1E1C DS    0H                  EIP TRACE EXIT              @BBAI20Y\n         NI    TURNREQD,X'F4'      CLEAR OUT UNWANTED BITS     @BBAI20Y\n         BR    R6                  RETURN                      @BBAI20Y\n*                                                              @BBAI20Y\n*                                                              @BBDIA0Y\nTUTE1F1C DS    0H                  STORAGE CONTROL EXIT        @BD910JY\n         NI    TURNREQD,X'E0'      CLEAR OUT UNWANTED BITS     @BD910JY\n         BR    R6                  RETURN                      @BD910JY\n*                                                              @BBDIA0Y\nTUTE1F2C DS    0H                  PROGRAM CONTROL EXIT        @BD910JY\n         NI    TURNREQD+1,X'F0'     TURN OFF TYPE BIT          @BBDIA0Y\n         BR    R6                   RETURN                     @BD910JY\n*                                                              @BBDIA0Y\nTUTE1F3C DS    0H                   INTERVAL CONTROL EXIT      @BD910JY\n         NI    TURNREQD,X'F0'       USE ONLY FIRST HALF        @BD910JY\n         BR    R6                   RETURN                     @BD910JY\n*\nTUTE1F4C DS    0H                  DUMP CONTROL\n         MVC   TURNREQD+1(1),ZTRDATA1 COPY TOP BYTE\n         BR    R6                  AND RETURN\n*\nTUTE1F7C DS    0H                  TEMPORARY STORAGE           @BD910JY\n         NI    TURNREQD,X'E7'      GET RID OF UNWANTED BITS    @BD910JY\n         BR    R6                  RETURN                      @BD910JY\n*                                                                     *\n*    REPEAT ENTRY                                                     *\n*                                                                     *\nTUTE1FD1 DS    0H                  REPEAT ENTRY                @BM10700\n         LA    R1,11(R7)           GET SPACE POSITION          @BM10700\n         CR    R1,R0               ENOUGH SPARE?               @BM10700\n         BNLR  R6                  .. NO GET OUT               @BM10700\n*                                                              @BM10700\n         UNPK  00(05,R7),ZTRRETAD  SET IN REPEAT NUMBER     @EG00X @L5C\n         OI    04(R7),C'0'           FIX LAST DIGIT         @EG00X @L5A\n         MVC   06(05,R7),=C'TIMES'  SET NUMBER                 @BM10700\n         LA    R7,12(R7)           BUMP COUNT                  @BM10700\n         BR    R6                  RETURN                      @BM10700\n         SPACE 2\n        DFHEJECT ,                                             @BD910JY\n***********************************************************************\n* * *        C O N S T A N T S                                    * * *\n***********************************************************************\n         DC    C'CONSTANTS'                                    @BD910JY\nSIGTIME1 DC    A(0)                SIGNIFICANT DIFFERENCE WORTH        *\n                                   PRINTING - CHANGE FOR REAL USE  @P4C\nSIGTIME2 DC    A(12800/32)         VERY SIGNIFICANT DIFFERENCE         *\n                                   - ALTER TO MEET CIRCUMSTANCES   @P4C\nSIGTIME3 DC    A(100*1000000/32)   100 SECONDS (UNITS OF 32 MICROSECS) *\n                                   - UPPER LIMIT FOR PRINTING      @P4C\nTUTB1STA DC    A(DFHTUTB1)         ADDRESS OF TABLE 1...       @BD910JY\nTUTB2STA DC    A(DFHTUTB2)         ADDRESS OF TABLE 2...       @BD910JY\nTURNVEND DC    X'FFFF'             END OF MAJOR LITERAL TABLE  @BD910JY\nTURTRT   DC    C'0123456789ABCDEF' TRANSLATE TABLE             @BD910JY\n*\n***********************************************************************\n         LTORG                                                 @BD910JY\n         DS    0D                                              @BD910JY\nTUMAXLEN EQU   32                  MAXIMUM LITERAL LENGTH      @BD910JY\n         DFHEJECT                                              @BBDIA0Y\n*  TRANSLATE TABLE                                                    *\nTUETRANS DS    0CL256                                       @15544 @P1C\n*                             48 CHARACTER SET\n         DC    C'................'           00-0F          @15544 @P1C\n         DC    C'................'           10-1F          @15544 @P1C\n         DC    C'................'           20-2F          @15544 @P1C\n         DC    C'................'           30-3F          @15544 @P1C\n         DC    C' ............(+.'           40-4F          @15544 @P1C\n         DC    C'&&..........$*)..'          50-5F          @15544 @P1C\n         DC    C'-/.........,....'           60-6F          @15544 @P1C\n         DC    C'.............''=.'          70-7F          @15544 @P1C\n         DC    C'................'           80-8F          @15544 @P1C\n         DC    C'................'           90-9F          @15544 @P1C\n         DC    C'................'           A0-AF          @15544 @P1C\n         DC    C'................'           B0-BF          @15544 @P1C\n         DC    C'.ABCDEFGHI......'           C0-CF          @15544 @P1C\n         DC    C'.JKLMNOPQR......'           D0-DF          @15544 @P1C\n         DC    C'..STUVWXYZ......'           E0-EF          @15544 @P1C\n         DC    C'0123456789......'           F0-FF          @15544 @P1C\n*\n         ORG   ,                                               @BD910JY\n         DFHEJECT ,                                            @BD910JY\n*\n*        WORK AREAS\n*\n         DC    C'WORKAREA'                                     @BD910JY\n         DS    0D                                              @BD910JY\nTUESAVRG DC    18F'0'              SYSTEM REGISTER SAVE AREA   @BD910JY\nTURNREQD DC    XL16'00'            WORK AREA REQUEST CODES     @BD910JY\nTURNTYSV DC    H'0'                REQUEST TYPE                @BBAI20Y\n*\n*\nTURNDWRD DC    D'0'                                            @BM10519\nTURNOUTL DC    X'0'                LENGTH BYTE                 @BM10519\nTURNOUTD DC    XL16'00'            DATA AREA                   @BM10519\n***********************************************************************\n         DFHEJECT ,                                            @BM10700\n*                                                                     *\n*       TYPE  OF ENTRY TABLE                                          *\n*                                                                     *\nTUTENTAB DS    0H                                              @BBAI20Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  00 RESERVED             @BBDIA0Y\n         DC    AL2(TUTI11FE-TUTI1SRT)  01 FE                   @BBDIA0Y\n         DC    AL2(TUTI11US-TUTI1SRT)  02 USER                 @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  03 LIFO ENTRY           @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  04 SYSTEM               @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  05 LIFO RETURN          @BBDIA0Y\n         DC    AL2(TUTI11XC-TUTI1SRT)  06 EXCEPTION            @BM13334\n         DC    AL2(TUTI11PF-TUTI1SRT)  07 PERFORMANCE          @BM13334\n         DC    AL2(TUTI11PP-TUTI1SRT)  08 RESERVED             @BM13334\n         DC    AL2(TUTI11SY-TUTI1SRT)  09 RESERVED             @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  0A RESERVED             @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  0B RESERVED             @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  0C RESERVED             @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  0D TRACE ON/OFF         @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  0E AUX TRACING          @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  0F REPEAT ENTRY         @BBDIA0Y\n*                                                              @BBDIA0Y\nRETNCHRL DS    0H                                              @BM13334\n         DFHTUTEN C=(00,00),K='RETN'                           @BM13334\n         DFHEJECT ,                                            @BBAI20Y\n***********************************************************************\n*    INDEX CSECT TO ADDRESS CORRECT MAIN TABLE                        *\n***********************************************************************\nDFHTUTI1 CSECT                                                 @BBDIA0Y\nTUTI1SRT DS    0H                                              @BBDIA0Y\n         SPACE 4                                               @BM13334\n*                                                                     *\n*       OFFSET TABLE FOR 'USER ENTRIES '  TYPE 02                     *\n*                                                                     *\n         DS    0H                                              @BM13334\nTUTI11US DC    AL2(255)            LOWEST ID IN TABLE          @BM13334\n*                                                              @BM13334\n*        OFFSETS TO FIRST LEVEL TABLE                          @BM13334\n*        MUST FOLLOW TUTI11US                                  @BM13334\n         DC    AL2(TUTB1VUS-TUTB1SRT)  X'00'-X'FF' USER        @BM13334\n         DFHEJECT ,                                            @BM13334\n*                                                                     *\n*       OFFSET TABLE FOR 'EXCEPTION ENTRIES  TYPE 06                  *\n*                                                                     *\n         DS    0H                                              @BBAI20Y\nTUTI11XC DC    AL2(255)            LOWEST ID IN TABLE          @BM13334\n*                                                              @BM13334\n*        OFFSETS TO FIRST LEVEL TABLE                          @BM13334\n*        MUST FOLLOW TUTI11US                                  @BM13334\n         DC    AL2(TUTB1VXC-TUTB1SRT)  X'00'-X'FF' EXCEPTION   @BM13334\n         DFHEJECT ,                                            @BM13334\n*                                                                     *\n*       OFFSET TABLE FOR PERFORMANCE ENTRIES TYPE 07                  *\n*                                                                     *\n         DS    0H                                              @BM13334\nTUTI11PF DC    AL2(255)            LOWEST ID IN TABLE          @BM13334\n*                                                              @BM13334\n*        OFFSETS TO FIRST LEVEL TABLE                          @BM13334\n*        MUST FOLLOW TUTI11US                                  @BM13334\n         DC    AL2(TUTB1VPF-TUTB1SRT)  X'00'-X'FF' PERFORMANCE @BM13334\n         DFHEJECT ,                                            @BM13334\n*                                                                     *\n*       OFFSET TABLE FOR 'EXCEPTION ENTRIES  TYPE 08                  *\n*                                                                     *\n         DS    0H                                              @BM13334\nTUTI11PP DC    AL2(255)            LOWEST ID IN TABLE          @BM13334\n*                                                              @BM13334\n*        OFFSETS TO FIRST LEVEL TABLE                          @BM13334\n*        MUST FOLLOW TUTI11US                                  @BM13334\n         DC    AL2(TUTB1VPP-TUTB1SRT)  X'00'-X'FF' PPS         @BM13334\n         DFHEJECT ,                                            @BM13334\n*                                                                     *\n*       OFFSET TABLE FOR 'FE     ENTRIES '  TYPE 01                   *\n*                                                                     *\n         DS    0H                                              @BM13334\nTUTI11FE DC    AL2(16*14)     X'E0'LOWEST ID IN TABLE          @BM13334\n*                                                              @BM13334\n*        OFFSETS TO FIRST LEVEL TABLE                          @BM13334\n*        MUST FOLLOW TUTI11FE                                  @BM13334\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'00'-X'E0' FE          @BM13334\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E1' FE                @BM13334\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E2' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E3' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E4' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E5' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFO-TUTB1SRT)  X'E6' TCP (FE)              @D2C\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E7' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E8' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E9' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'EA' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'EB' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'EC' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'ED' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'EE' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'EF' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F0' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F1' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F2' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F3' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F4' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F5' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F6' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFQ-TUTB1SRT)  X'F7' TSP (FE)          @BA40668\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F8' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F9' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'FA' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'FB' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'FC' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFP-TUTB1SRT)  X'FD' TRP (FE)              @LVC\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'FE' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'FF' FE                @BBDIA0Y\n         DFHEJECT ,                                            @BBAI20Y\n*                                                                     *\n*       OFFSET TABLE FOR 'SYSTEM ENTRIES '                            *\n*                                                                     *\n         DS    0H                                              @BBAI20Y\nTUTI11SY DC    AL2(16*12)    X'C0' LOWEST ID IN TABLE          @BBAI20Y\n*                                                              @BBAI20Y\n*        OFFSETS TO FIRST LEVEL TABLE                          @BBAI20Y\n*        MUST FOLLOW TUTI11SY                                  @BBAI20Y\n         DC    AL2(TUTB1VSY-TUTB1SRT)  X'00'-X'C0' SYSTEM      @BBDIA0Y\n         DC    AL2(TUTB1VSY-TUTB1SRT)  X'C1' = ****            @BBDIA0Y\n         DC    AL2(TUTB1VSY-TUTB1SRT)  X'C2' = ****            @BBDIA0Y\n         DC    AL2(TUTB1VC3-TUTB1SRT)  X'C3' = CCNV            @BA37421\n         DC    AL2(TUTB1VSY-TUTB1SRT)  X'C4' = ****            @BBDIA0Y\n         DC    AL2(TUTB1VSY-TUTB1SRT)  X'C5' = ****            @BBDIA0Y\n         DC    AL2(TUTB1VSY-TUTB1SRT)  X'C6' = ****            @BBDIA0Y\n         DC    AL2(TUTB1VC7-TUTB1SRT)  X'C7' = FE 2ND LEVEL 199@BA54733\n         DC    AL2(TUTB1VC8-TUTB1SRT)  X'C8' = SC      200     @BBDIA0Y\n         DC    AL2(TUTB1VC9-TUTB1SRT)  X'C9' = SC      201     @BD910JY\n         DC    AL2(TUTB1VCA-TUTB1SRT)  X'CA' = SC      202     @BD910JY\n         DC    AL2(TUTB1VCB-TUTB1SRT)  X'CB' = DBP     203         @LMC\n         DC    AL2(TUTB1VCC-TUTB1SRT)  X'CC' = CCP     204         @LLC\n         DC    AL2(TUTB1VCD-TUTB1SRT)  X'CD' = BMS     205         @LMC\n         DC    AL2(TUTB1VCE-TUTB1SRT)  X'CE' = RCP     206         @LLC\n         DC    AL2(TUTB1VCF-TUTB1SRT)  X'CF' = BMS     207     @BD910JY\n         DC    AL2(TUTB1VD0-TUTB1SRT)  X'D0' = KC AUX  208         @LMC\n         DC    AL2(TUTB1VSY-TUTB1SRT)  X'D1' = RESERVED209     @BD910JY\n         DC    AL2(TUTB1VD2-TUTB1SRT)  X'D2' = VOLUME  210  @E211Q @L7C\n         DC    AL2(TUTB1VD3-TUTB1SRT)  X'D3' = LUP     211  @EI00U @L6A\n         DC    AL2(TUTB1VSY-TUTB1SRT)  X'D4' = RESERVED212     @BD910JY\n         DC    AL2(TUTB1VD5-TUTB1SRT)  X'D5' = UE      213     @BD910JY\n         DC    AL2(TUTB1VD6-TUTB1SRT)  X'D6' = AL      214     @BBDI80O\n         DC    AL2(TUTB1VD7-TUTB1SRT)  X'D7' = DI      215     @BD910JY\n         DC    AL2(TUTB1VD8-TUTB1SRT)  X'D8' = SP      216     @BD910JY\n         DC    AL2(TUTB1VD9-TUTB1SRT)  X'D9' = XFP     217     @BD910JY\n         DC    AL2(TUTB1VDA-TUTB1SRT)  X'DA' = STATS   218     @BD910JY\n         DC    AL2(TUTB1VDB-TUTB1SRT)  X'DB' = XTP     219     @BBDJ20B\n         DC    AL2(TUTB1VDC-TUTB1SRT)  X'DC' = ACP **  220     @BD910JY\n         DC    AL2(TUTB1VDD-TUTB1SRT)  X'DD' = IRC     221     @BD910JY\n         DC    AL2(TUTB1VDE-TUTB1SRT)  X'DE' = SKP     222         @LIC\n         DC    AL2(TUTB1VDF-TUTB1SRT)  X'DF' = ISP     223     @BD910JY\n         DC    AL2(TUTB1VE0-TUTB1SRT)  X'E0' = MGP     224     @BD910JY\n         DC    AL2(TUTB1VE1-TUTB1SRT)  X'E1' = HLL     225     @BD910JY\n         DC    AL2(TUTB1VE2-TUTB1SRT)  X'E2' = SNP     226     @BD910JY\n         DC    AL2(TUTB1VE3-TUTB1SRT)  X'E3' = PSP     227         @LEC\n         DC    AL2(TUTB1VE4-TUTB1SRT)  X'E4' = MTP     228     @BD910JY\n         DC    AL2(TUTB1VE5-TUTB1SRT)  X'E5' = XSP     229     @BD910JY\n         DC    AL2(TUTB1VE6-TUTB1SRT)  X'E6' = TACP    230         @LRC\n         DC    AL2(TUTB1VE7-TUTB1SRT)  X'E7' = EDLI    231     @BD910JY\n         DC    AL2(TUTB1VE8-TUTB1SRT)  X'E8' = ****    232     @BD910JY\n         DC    AL2(TUTB1VE9-TUTB1SRT)  X'E9' = ****    233     @BD910JY\n         DC    AL2(TUTB1VEA-TUTB1SRT)  X'EA' = TMP     234  @EU71T @L2C\n         DC    AL2(TUTB1VEB-TUTB1SRT)  X'EB' = AMP     235  @EU71J @L4C\n         DC    AL2(TUTB1VEC-TUTB1SRT)  X'EC' = DMP     236  @EU71J @L4C\n         DC    AL2(TUTB1VED-TUTB1SRT)  X'ED' = LFO     237     @BBDIA0Y\n         DC    AL2(TUTB1VEE-TUTB1SRT)  X'EE' = VIO     238     @BBDIA0Y\n         DC    AL2(TUTB1VEF-TUTB1SRT)  X'EF' = TOR     239         @LKC\n*        SYSTEM MACRO ENTRIES                                  @BBDIA0Y\n         DC    AL2(TUTB1VF0-TUTB1SRT)  X'F0' = KC      240     @BD910JY\n         DC    AL2(TUTB1VF1-TUTB1SRT)  X'F1' = SC      241     @BD910JY\n         DC    AL2(TUTB1VF2-TUTB1SRT)  X'F2' = PC      242     @BD910JY\n         DC    AL2(TUTB1VF3-TUTB1SRT)  X'F3' = IC      243     @BD910JY\n         DC    AL2(TUTB1VF4-TUTB1SRT)  X'F4' = DC      244     @BD910JY\n         DC    AL2(TUTB1VF5-TUTB1SRT)  X'F5' = FC      245     @BD910JY\n         DC    AL2(TUTB1VF6-TUTB1SRT)  X'F6' = TD      246     @BD910JY\n         DC    AL2(TUTB1VF7-TUTB1SRT)  X'F7' = TS      247     @BD910JY\n         DC    AL2(TUTB1VF8-TUTB1SRT)  X'F8' = DL/I    248     @BD910JY\n         DC    AL2(TUTB1VF9-TUTB1SRT)  X'F9' = JC      249     @BD910JY\n         DC    AL2(TUTB1VFA-TUTB1SRT)  X'FA' = BMS     250     @BD910JY\n         DC    AL2(TUTB1VFB-TUTB1SRT)  X'FB' = BIF     251     @BD910JY\n         DC    AL2(TUTB1VFC-TUTB1SRT)  X'FC' = ZCP     252     @BD910JY\n         DC    AL2(TUTB1VFD-TUTB1SRT)  X'FD' = TRACE INT 253   @BM10700\n         DC    AL2(TUTB1VFE-TUTB1SRT)  X'FE' = TRACE ON  254   @BD910JY\n         DC    AL2(TUTB1VFF-TUTB1SRT)  X'FF' = TRACE OFF 255   @BD910JY\n*                                                              @BBDIA0Y\n         DFHEJECT ,                                            @BBDIA0Y\n************************************************************** @BBDIA0Y\n*      THIS IS THE MAJOR TABLE CONSISTING OF :                 @BBDIA0Y\n*        ONE BYTE ID FOR COMPARE                               @BBDIA0Y\n*        3   BYTE CHAR ID NAME                                 @BBDIA0Y\n*        2 BYTE OFFSET TO COMPARE REQD TABLE                   @BBDIA0Y\n*        2 BYTE OFFSET TO EXIT ROUTINE TO FORMAT REQUEST       @BBDIA0Y\n***********************************************************************\nDFHTUTB1 CSECT                                                 @BD910JY\nTUTB1SRT DS    0H                  START OF TABLE ENTRIES      @BD910JY\n*                                                              @BM13334\n*        SPECIAL ENTRIES                                       @BM13334\n*                                                              @BM13334\n*        USER ENTRY                                                   *\nTUTB1VUS DFHTUTEN T=1,TB=USD,             TABLE OFFSET                 *\n               E=DFT,                                                  *\n               K='USER'                                        @BM13334\n         SPACE 4                                               @BM13334\n*                                                              @BM13334\n*        SPECIAL ENTRIES                                       @BM13334\n*                                                              @BM13334\n*        EXCEPTION                                                    *\nTUTB1VXC DFHTUTEN T=1,TB=USD,             TABLE OFFSET                 *\n               E=DFT,                                                  *\n               K='**EX**'                                      @BM13334\n*                                                              @BM13334\n*        SPECIAL ENTRIES                                       @BM13334\n*                                                              @BM13334\n*        PERFORMANCE                                                  *\nTUTB1VPF DFHTUTEN T=1,TB=USD,             TABLE OFFSET                 *\n               E=DFT,                                                  *\n               K='PERFORM'                                     @BM13334\n*                                                              @BM13334\n*        SPECIAL ENTRIES                                       @BM13334\n*                                                              @BM13334\n*        PP   ENTRY                                                   *\nTUTB1VPP DFHTUTEN T=1,TB=USD,             TABLE OFFSET                 *\n               E=DFT,                                                  *\n               K='PP'                                          @BM13334\n*                                                              @BM13334\n*        SPECIAL ENTRIES                                       @BM13334\n*                                                              @BM13334\n*        FE  ENTRY  (GENERAL)                                         *\nTUTB1VFN DFHTUTEN  T=1,TB=EXD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='FE'                                          @BM13334\n*                                                              @BM13334\n*                                                              @BM13334\n*        FE  ENTRY  (TCP  -  NON-VTAM TERMINALS ONLY)                 *\nTUTB1VFO DFHTUTEN  T=1,TB=E6D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='TCP (FE)'      SAME TRACE ID / TABLE AS TACP     @D2C\n*                                                                     *\n*                                                                     *\n*        FE  ENTRY  (TRP  -  TRACE INTERNAL)                          *\nTUTB1VFP DFHTUTEN  T=1,TB=FDD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='TRP (FE)'                                        @LVA\n*                                                              @BA40668\n*                                                              @BA40668\n*        FE  ENTRY  (TSP  -  AUXILIARY STORAGE ONLY)                  *\nTUTB1VFQ DFHTUTEN  T=1,TB=F7H,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='TSP (FE)'                                    @BA40668\n*                                                              @BM13334\n         DFHEJECT ,                                            @BM13334\n*                                                              @BM13334\n*        DEFAULT ENTRY                                                *\n*        SYSTEM ENTRY  DEFAULT                                        *\n*                                                                     *\nTUTB1VSY DFHTUTEN  T=1,TB=SYD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='SYSTEM'                                      @BD910JY\n*                                                              @BBDIA0Y\n*        GENERAL SYSTEM ENTRIES                                       *\nTUTB1VC3 DFHTUTEN  T=1,TB=C3E,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='CCNV'                                        @BA37421\n*        NEXT ENTRY                                            @BA37421\nTUTB1VC7 DFHTUTEN  T=1,TB=C7D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='L2 '                                         @BA54733\n*        NEXT ENTRY                                                   *\nTUTB1VC8 DFHTUTEN  T=1,TB=C8D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='SCP ACQUIRED'                                @BA54733\n*        NEXT ENTRY                                            @BA54733\nTUTB1VC9 DFHTUTEN  T=1,TB=C9D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='SCP RELEASED' IDENT                          @BD910JY\n*        NEXT ENTRY                                                  *\nTUTB1VCA DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='SCP STORAGE VIOLATION '                      @BD910JY\n*        NEXT ENTRY                                                  *\nTUTB1VCB DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='DBP DYN BACKOUT'                             @BM13334\n*        NEXT ENTRY                                                   *\nTUTB1VCC DFHTUTEN  T=1,TB=CCD,             TABLE OFFSET                *\n               TBR=CCR,                                                *\n               E=DFT,                                                  *\n               K='CCP'                                             @LLA\n*        NEXT ENTRY                                                  *\nTUTB1VCD DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='BMS TS IDERROR'                              @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VCE DFHTUTEN  T=1,TB=CED,             TABLE OFFSET                *\n               TBR=CER,                                                *\n               E=DFT,                                                  *\n               K='RCP'                                             @LLA\n*        NEXT ENTRY                                                  *\nTUTB1VCF DFHTUTEN  T=1,TB=CFD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='BMS RESPONSE'                                @BD910JY\n*        NEXT ENTRY                                                  *\nTUTB1VD0 DFHTUTEN  T=1,TB=D0D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='KCP'                                         @BD910JY\n*        NEXT ENTRY                                                  *\nTUTB1VD2 DFHTUTEN  T=1,TB=D2D,             TABLE OFFSET FOR CALLS      *\n               TBR=D2R,            TABLE OFFSET FOR RETURNS            *\n               E=DFT,              NO EXIT                             *\n               K='VCP'                                      @E211Q @L7C\n*        NEXT ENTRY                                                  *\nTUTB1VD3 DFHTUTEN  T=1,TB=D3D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='LUP'                                      @EI00U @L6A\n*        NEXT ENTRY                                                   *\nTUTB1VD5 DFHTUTEN  T=1,TB=D5D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='UEH'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VD6 DFHTUTEN  T=1,TB=D6D,             TABLE OFFSET                *\n               TBR=D6R,                                                *\n               E=DFT,                                                  *\n               K='ALP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VD7 DFHTUTEN  T=1,TB=D7D,             TABLE OFFSET                *\n               TBR=D7R,                                                *\n               E=DFT,                                                  *\n               K='DIP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VD8 DFHTUTEN  T=1,TB=D8D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='SPP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VD9 DFHTUTEN  T=1,TB=E1D,             USE E1 TABLE AS D9D         *\n               E=DFT,                                                  *\n               K='XF '                                     @FJ420J @LBC\n*        NEXT ENTRY                                                   *\nTUTB1VDA DFHTUTEN  T=1,TB=DAD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='STATISTICS'                                  @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VDB DFHTUTEN  T=1,TB=DBD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='XTP'                                         @BBDJ20B\n*        NEXT ENTRY                                                   *\nTUTB1VDC DFHTUTEN  T=1,TB=DCD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='ACP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VDD DFHTUTEN  T=1,TB=DDD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='IRC'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VDE DFHTUTEN  T=1,TB=DED,             TABLE OFFSET                *\n               TBR=DER,                                                *\n               E=DFT,                                                  *\n               K='SKP'                                             @LIC\n*        NEXT ENTRY                                                   *\nTUTB1VDF DFHTUTEN  T=1,TB=DFD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='ISP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VE0 DFHTUTEN  T=1,TB=E0D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='MGP DFH'                                     @BM10519\nTUTB1VE1 DFHTUTEN  T=1,TB=E1D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='EIP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VE2 DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='SNP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VE3 DFHTUTEN  T=1,TB=E3D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='PSP'                                             @LEC\n*        NEXT ENTRY                                                   *\nTUTB1VE4 DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='MTP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\n*     XSP TRACE ENTRY E5                                              *\nTUTB1VE5 DFHTUTEN  T=1,TB=E5D,             TABLE OFFSET                *\n               TBR=NUL,            NULL EXIT TRACE                     *\n               E=DFT,                                                  *\n               K='XSP'                                         @BA81335\n*        NEXT ENTRY                                                   *\n*     TACP TRACE ENTRY E6                                             *\nTUTB1VE6 DFHTUTEN  T=1,TB=E6D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='TACP'                                            @LRC\n*        NEXT ENTRY                                                   *\n*    EDLI TRACE ENTRY E7                                              *\nTUTB1VE7 DFHTUTEN  T=1,TB=E7D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='ERM'                                      @ECB0R @L1C\n*        NEXT ENTRY                                                   *\n*     XXX TRACE ENTRY E8                                              *\nTUTB1VE8 DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='***'                                         @BD910JY\n*        NEXT ENTRY                                                   *\n*     XXX TRACE ENTRY E9                                              *\nTUTB1VE9 DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='***'                                         @BD910JY\n*        NEXT ENTRY                                                   *\n*     XXX TRACE ENTRY EA                                              *\nTUTB1VEA DFHTUTEN  T=1,TB=EAD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               TBR=EAR,                    RESPONSE TABLE              *\n               K='TMP'                                      @EU71T @L2C\n*        NEXT ENTRY                                                   *\n*     XXX TRACE ENTRY EB                                              *\nTUTB1VEB DFHTUTEN  T=1,TB=EBD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='AMP'                                      @EU71J @L4C\n*        NEXT ENTRY                                                   *\n*     XXX TRACE ENTRY EC                                              *\nTUTB1VEC DFHTUTEN  T=1,TB=ECD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='DMP'                                      @EU71J @L4C\n*        NEXT ENTRY                                                   *\n*    LFO  TRACE ENTRY ED                                              *\nTUTB1VED DFHTUTEN  T=1,TB=EDD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='LFO'                                         @BBDIA0Y\n*        NEXT ENTRY                                                   *\n*    VTAM TRACE ENTRY EE                                              *\nTUTB1VEE DFHTUTEN  T=1,TB=EED,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='VIO'                                         @BBDIA0Y\n*        NEXT ENTRY                                                   *\n*    TOR  TRACE ENTRY EF                                              *\nTUTB1VEF DFHTUTEN  T=1,TB=EFD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='TOR'                                             @LKC\n*        NEXT ENTRY                                                   *\n*        SYSTEM MACRO ENTRIES                                         *\nTUTB1VF0 DFHTUTEN  T=1,TB=F0D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='KCP'                                         @BBDIA0Y\n*        NEXT ENTRY                                                   *\nTUTB1VF1 DFHTUTEN  T=1,TB=F1D,             TABLE OFFSET                *\n               E=F1C,                                                  *\n               K='SCP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VF2 DFHTUTEN  T=1,TB=F2D,             TABLE OFFSET                *\n               E=F2C,                                                  *\n               K='PCP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VF3 DFHTUTEN  T=1,TB=F3D,             TABLE OFFSET                *\n               E=F3C,                                                  *\n               TBR=F3E,                    RESPONSE TABLE      @BM11003*\n               K='ICP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VF4 DFHTUTEN  T=1,TB=F4D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='DCP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VF5 DFHTUTEN  T=1,TB=F5D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               TBR=F5E,                                                *\n               K='FCP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VF6 DFHTUTEN  T=1,TB=F6D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               TBR=F6E,                    RESPONSE TABLE      @BM11003*\n               K='TDP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VF7 DFHTUTEN  T=1,TB=F7D,             TABLE OFFSET                *\n               TBR=F7E,                    RESPONSE TABLE      @BM11003*\n               E=F7C,                                                  *\n               K='TSP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VF8 DFHTUTEN  T=1,TB=F8D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='DLI'                                      @E8D08 @M1C\n*        NEXT ENTRY                                                   *\nTUTB1VF9 DFHTUTEN  T=1,TB=F9D,             TABLE OFFSET                *\n               TBR=F9E,                                                *\n               E=DFT,                                                  *\n               K='JCP'                                             @P5C\n*        NEXT ENTRY                                                   *\nTUTB1VFA DFHTUTEN  T=1,TB=FAD,             TABLE OFFSET                *\n               TBR=CFD,                                                *\n               E=DFT,                                                  *\n               K='BMS'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VFB DFHTUTEN  T=1,TB=FBD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='BIF'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VFC DFHTUTEN  T=1,TB=FCD,             TABLE OFFSET                *\n               TBR=FCE,                                                *\n               E=DFT,                                                  *\n               K='ZCP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VFD DFHTUTEN  T=1,TB=FDD,             TABLE OFFSET                *\n               E=DFT,                      SYSTEM ENTRY                *\n               K=' '                                           @BM10416\n*        NEXT ENTRY                                                   *\nTUTB1VFE DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='TRP TRACE ON'                                @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VFF DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='TRP TRACE OFF'                               @BD910JY\n***********************************************************************\n         DFHEJECT ,                                            @BD910JY\n***********************************************************************\n*        THE FOLLOWING ARE TABLES IN THE FORMAT :\n*              1 BYTE COMPARE VALUE\n*              1 BYTE LENGTH OF LITERAL MINUS ONE\n*              N BYTE LITERAL\n*\n*    IF AN EQUAL COMPARE OCCURS THEN LITERAL IS MOVED TO PRINT\n*       FIELD.\n***********************************************************************\nDFHTUTB2 CSECT                                                 @BD910JY\nTUTB2SRT DS    0H                     DUMMY                    @BD910JY\nTUTB2NUL EQU   *                      NULL EXIT                @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT\n  DFHTUTEN     C=(FF,FF),K=' '     END MARKER                  @BD910JY\n*                                                                     *\nTUTB2EXD EQU   *              GENERAL EXIT    FE               @BD910JY\nTUTB2USD EQU   *              GENERAL EXIT    USER             @BD910JY\nTUTB2SYD EQU   *              GENERAL EXIT    SYSTEM           @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=EXC,NX=SRT\n  DFHTUTEN     C=(FF,FF),K=' '     END MARKER                  @BD910JY\n*                                                                     *\nTUTB2GND EQU   *              GENERAL EXIT                     @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT\n  DFHTUTEN     C=(00,00),K='RESPONSE'                          @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n         PRINT NOGEN                                           @BD910JY\n*                                                                     *\nTUTB2C3E EQU   *                                               @BA37421\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BA37421\n  DFHTUTEN     C=(01,00),K='TS'                                @BA37421\n  DFHTUTEN     C=(02,00),K='TS TEMPLATE'                       @BA37421\n  DFHTUTEN     C=(03,00),K='TD'                                @BA37421\n  DFHTUTEN     C=(04,00),K='TD TEMPLATE'                       @BA37421\n  DFHTUTEN     C=(05,00),K='FC DATA'                           @BA37421\n  DFHTUTEN     C=(06,00),K='FC DATA TEMPLATE'                  @BA37421\n  DFHTUTEN     C=(07,00),K='FC KEY'                            @BA37421\n  DFHTUTEN     C=(08,00),K='FC KEY TEMPLATE'                   @BA37421\n  DFHTUTEN     C=(09,00),K='IC'                                @BA37421\n  DFHTUTEN     C=(0A,00),K='IC TEMPLATE'                       @BA37421\n  DFHTUTEN     C=(0B,00),K='EXIT'                              @BA37421\n  DFHTUTEN     C=(0C,00),K='ENTRY'                             @BA37421\n  DFHTUTEN     C=(0D,00),K='PC'                                @BA64560\n  DFHTUTEN     C=(0E,00),K='PC TEMPLATE'                       @BA64560\n  DFHTUTEN     C=(FF,FF),K=                                    @BA37421\n*                                                              @BA37421\nTUTB2C7D EQU   *   SECOND LEVEL TRACE                          @BA54733\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BA54733\n  DFHTUTEN     C=(01),K='EIP FREEMAIN'                         @BA54733\n  DFHTUTEN     C=(02),K='EIP GETMAIN SHARED'                   @BA54733\n  DFHTUTEN     C=(03),K='EIP GETMAIN TERM'                     @BA54733\n  DFHTUTEN     C=(04),K='EIP GETMAIN TD'                       @BA54733\n  DFHTUTEN     C=(05),K='EIP GETMAIN TS'                       @BA54733\n  DFHTUTEN     C=(06),K='EIP GETMAIN USER'                     @BA54733\n  DFHTUTEN     C=(07),K='EIP FREEMAIN TERM'                    @BA54733\n  DFHTUTEN     C=(0F),K='EIP EXIT GET/FREE'                    @BA54733\n*                                                              @BA54733\nTUTB2C8D EQU   *                                               @BA54733\n*                                                              @BA54733\nTUTB2C9D EQU   *                                               @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=B0,E=DFT,NX=C9F\n  DFHTUTEN     C=(80,00),K='1WD'                               @BD910JY\n  DFHTUTEN     C=(81,00),K='DCA'                               @BD910JY\n  DFHTUTEN     C=(82,00),K='QEA'                               @BD910JY\n  DFHTUTEN     C=(83,00),K='TQA'                               @BD910JY\n  DFHTUTEN     C=(84,00),K='LINE'                              @BD910JY\n  DFHTUTEN     C=(85,00),K='TERMINAL'                          @BD910JY\n  DFHTUTEN     C=(86,00),K='ICE'                               @BD910JY\n  DFHTUTEN     C=(87,00),K='AID'                               @BD910JY\n  DFHTUTEN     C=(88,00),K='PGM'                               @BD910JY\n  DFHTUTEN     C=(89,00),K='RSA'                               @BD910JY\n  DFHTUTEN     C=(8A,00),K='TCA'                               @BD910JY\n  DFHTUTEN     C=(8B,00),K='LLA'                               @BD910JY\n  DFHTUTEN     C=(8C,00),K='USER'                              @BD910JY\n  DFHTUTEN     C=(8D,00),K='TRANSDATA'                         @BD910JY\n  DFHTUTEN     C=(8E,00),K='TEMPSTRG'                          @BD910JY\n  DFHTUTEN     C=(8F,00),K='FILE'                              @BD910JY\n  DFHTUTEN     C=(90,00),K='RPL'                               @BD910JY\n  DFHTUTEN     C=(91,00),K='WRE'                               @BD910JY\n  DFHTUTEN     C=(92,00),K='BCA'                               @BD910JY\n  DFHTUTEN     C=(93,00),K='SHARED'                            @BD910JY\n  DFHTUTEN     C=(94,00),K='CONTROL'                           @BD910JY\n  DFHTUTEN     C=(95,00),K='??'                                @BD910JY\n  DFHTUTEN     C=(96,00),K='TACLE'                             @BD910JY\n  DFHTUTEN     C=(97,00),K='TSMAIN'                            @BD910JY\n  DFHTUTEN     C=(98,00),K='TSTABLE'                           @BD910JY\n  DFHTUTEN     C=(99,00),K='MAP'                               @BD910JY\n  DFHTUTEN     C=(9A,00),K='PERMANENT'                      @EU71B @L3C\n  DFHTUTEN     C=(9B,00),K='JCA'                               @BD910JY\n  DFHTUTEN     C=(9C,00),K='EXTENDED'                       @EG01X @L5C\n  DFHTUTEN     C=(9D,00),K='DWE'                               @BD910JY\n  DFHTUTEN     C=(9E,00),K='MAPCOPY'                           @BD910JY\n  DFHTUTEN     C=(9F,00),K='DL/I'                              @BD910JY\n  DFHTUTEN     C=(00,00),K='** REQUEST FAILED **'              @BM10378\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\nTUTB2C9F EQU   *\n  DFHTUTEN     T=(2,I),CP=TM,OFF=B0,E=DFT,NX=SRT\n  DFHTUTEN     C=(80,00),K='STORAGE'\n  DFHTUTEN     C=(FF,FF),K=\n*                                                                     *\nTUTB2CCD EQU   *                   CCP                             @LLA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT                  @LLP\n  DFHTUTEN     C=(01,00),K='OPEN'                                  @LLA\n  DFHTUTEN     C=(02,00),K='CLOSE'                                 @LLA\n  DFHTUTEN     C=(03,00),K='CONNECT'                               @LLA\n  DFHTUTEN     C=(04,00),K='DISCONNECT'                            @LLA\n  DFHTUTEN     C=(05,00),K='STARTBROWSE'                           @LLA\n  DFHTUTEN     C=(06,00),K='ENDBROWSE'                             @LLA\n  DFHTUTEN     C=(07,00),K='GETNEXT'                               @LLA\n  DFHTUTEN     C=(08,00),K='WRITE'                                 @LLA\n  DFHTUTEN     C=(09,00),K='READ'                                  @LLA\n  DFHTUTEN     C=(0A,00),K='DELETE'                                @LLA\n  DFHTUTEN     C=(0B,00),K='PURGE'                                 @LLA\n  DFHTUTEN     C=(FF,FF),K=                                        @LLP\n*                                                                     *\nTUTB2CCR EQU   *                   CCP RETURN                      @LLA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A3,E=DFT,NX=SRT                  @LLP\n  DFHTUTEN     C=(00),K='NORMAL'                                   @LLP\n  DFHTUTEN     C=(04),K='NOT FOUND'                                @LLA\n  DFHTUTEN     C=(06),K='LENGTH ERROR'                             @LLA\n  DFHTUTEN     C=(08),K='DUPLICATE'                                @LLA\n  DFHTUTEN     C=(0C),K='INVALID REQUEST'                          @LLA\n  DFHTUTEN     C=(10),K='DISASTER'                                 @LLA\n  DFHTUTEN     C=(FF,FF),K=                                        @LLP\n*                                                                     *\nTUTB2CED EQU   *                   RCP                             @LLA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT                  @LLP\n  DFHTUTEN     C=(01,00),K='OPEN'                                  @LLA\n  DFHTUTEN     C=(02,00),K='CLOSE'                                 @LLA\n  DFHTUTEN     C=(03,00),K='CONNECT'                               @LLA\n  DFHTUTEN     C=(04,00),K='DISCONNECT'                            @LLA\n  DFHTUTEN     C=(05,00),K='STARTBROWSE'                           @LLA\n  DFHTUTEN     C=(06,00),K='ENDBROWSE'                             @LLA\n  DFHTUTEN     C=(07,00),K='GETNEXT'                               @LLA\n  DFHTUTEN     C=(08,00),K='WRITE'                                 @LLA\n  DFHTUTEN     C=(09,00),K='READ'                                  @LLA\n  DFHTUTEN     C=(0A,00),K='DELETE'                                @LLA\n  DFHTUTEN     C=(0B,00),K='PURGE'                                 @LLA\n  DFHTUTEN     C=(0C,00),K='LOG'                                   @LLA\n  DFHTUTEN     C=(0D,00),K='INITIALIZE'                            @LLA\n  DFHTUTEN     C=(0E,00),K='WAITINIT'                              @LLA\n  DFHTUTEN     C=(0F,00),K='RESTART'                               @LLA\n  DFHTUTEN     C=(FF,FF),K=                                        @LLP\n*                                                                     *\nTUTB2CER EQU   *                   RCP RETURN                      @LLA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A3,E=DFT,NX=SRT                  @LLP\n  DFHTUTEN     C=(00),K='NORMAL'                                   @LLP\n  DFHTUTEN     C=(04),K='NOT FOUND'                                @LLA\n  DFHTUTEN     C=(06),K='LENGTH ERROR'                             @LLA\n  DFHTUTEN     C=(08),K='DUPLICATE'                                @LLA\n  DFHTUTEN     C=(0C),K='INVALID REQUEST'                          @LLA\n  DFHTUTEN     C=(0E),K='WARNING ISSUED'                           @LLA\n  DFHTUTEN     C=(10),K='DISASTER'                                 @LLA\n  DFHTUTEN     C=(FF,FF),K=                                        @LLP\n*                                                                     *\nTUTB2CFD EQU   *                   BMS RESPONSE\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=CFE\n  DFHTUTEN     C=(80,00),K='ROUTE FAILED'\n  DFHTUTEN     C=(40,00),K='ROUTE WORKED FOR SOME'\n  DFHTUTEN     C=(20,00),K='INVALID ERROR TERMINAL'\n* DFHTUTEN     C=(10,00),K='STORAGE'\n  DFHTUTEN     C=(08,00),K='MAP TOO LARGE'\n  DFHTUTEN     C=(04,00),K='CANNOT MAP I/O AREA'\n  DFHTUTEN     C=(02,00),K='PAGE RETURNED'\n  DFHTUTEN     C=(01,00),K='INVALID REQUEST'\n  DFHTUTEN     C=(FF,FF),K=\nTUTB2CFE EQU   *\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=CFF\n  DFHTUTEN     C=(80,00),K='TEMPORARY STORAGE I/O ERROR'\n  DFHTUTEN     C=(20,00),K='UNEXPECTED DIP INPUT RCVD'\n  DFHTUTEN     C=(10,00),K='INVALID LDC MNEMONIC'\n  DFHTUTEN     C=(08,00),K='INVALID PARTITION SET'          @E5E2C @H1C\n  DFHTUTEN     C=(04,00),K='INVALID PARTITION'              @E5E2C @H1C\n  DFHTUTEN     C=(02,00),K='PARTITION FAIL'                 @E5E2C @H1C\n  DFHTUTEN     C=(FF,FF),K=\nTUTB2CFF EQU   *\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT\n  DFHTUTEN     C=(10,00),K='SPECIFIED REQID IGNORED'\n  DFHTUTEN     C=(08,00),K='END OF CHAIN'\n  DFHTUTEN     C=(04,00),K='END OF DATA SET'\n  DFHTUTEN     C=(02,00),K='INBOUND FMH'                       @BM10771\n  DFHTUTEN     C=(01,00),K='PAGEBLD OVERFLOW'\n  DFHTUTEN     C=(FF,FF),K=\n*                                                                     *\nTUTB2D0D EQU   *                   KCP AUX                     @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT\n  DFHTUTEN     C=(05,00),K='DISPATCH '                         @BD910JY\n  DFHTUTEN     C=(06,00),K='CREATE'                            @BD910JY\n  DFHTUTEN     C=(07,00),K='TERMINATE'                         @BD910JY\n  DFHTUTEN     C=(08,00),K='SYSTEM WAIT'                       @BD910JY\n  DFHTUTEN     C=(09,00),K='SYSTEM RESUME'                     @BBDIA0Y\n  DFHTUTEN     C=(0A,00),K='SUSPEND'                           @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2D2D EQU   *                   VCP                      @E211Q @L7A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT           @E211Q @L7P\n  DFHTUTEN     C=(00),K='LOCATE VOLUME'                     @E211Q @L7A\n  DFHTUTEN     C=(01),K='CREATE TABLES'                     @E211Q @L7A\n  DFHTUTEN     C=(02),K='INSERT SERIES'                     @E211Q @L7A\n  DFHTUTEN     C=(03),K='LOCATE SERIES'                     @E211Q @L7A\n  DFHTUTEN     C=(04),K='READ KEYPOINT RECDS'               @E211Q @L7A\n  DFHTUTEN     C=(05),K='BUILD KEYPOINT RECDS'              @E211Q @L7A\n  DFHTUTEN     C=(07),K='READ USERLABEL'                    @E211Q @L7A\n  DFHTUTEN     C=(08),K='BUILD USERLABEL'                   @E211Q @L7A\n  DFHTUTEN     C=(09),K='TALLY'                             @E211Q @L7A\n  DFHTUTEN     C=(0A),K='WARN'                              @E211Q @L7A\n  DFHTUTEN     C=(0B),K='WRITE DESCRIPTOR'                  @E211Q @L7A\n  DFHTUTEN     C=(0C),K='DELETE DESCRIPTOR'                 @E211Q @L7A\n  DFHTUTEN     C=(0D),K='ADD VOLUME'                        @E211Q @L7C\n  DFHTUTEN     C=(0E),K='ADD VOLUME, LIFO'                  @E211Q @L7A\n  DFHTUTEN     C=(11),K='SET CLOSE FAILURE'                 @E211Q @L7A\n  DFHTUTEN     C=(12),K='SET OPEN FAILURE'                  @E211Q @L7A\n  DFHTUTEN     C=(13),K='SET INPUT FAILURE'                 @E211Q @L7A\n  DFHTUTEN     C=(14),K='SET OUTPUT FAILURE'                @E211Q @L7A\n  DFHTUTEN     C=(15),K='SET READ-ONLY'                     @E211Q @L7A\n  DFHTUTEN     C=(17),K='SET GOOD'                          @E211Q @L7A\n  DFHTUTEN     C=(1D),K='SET CLOSED'                        @E211Q @L7A\n  DFHTUTEN     C=(1E),K='SET PENDING'                       @E211Q @L7A\n  DFHTUTEN     C=(1F),K='SET OPEN'                          @E211Q @L7A\n  DFHTUTEN     C=(20),K='PRIME A JFCB'                      @E211Q @L7A\n  DFHTUTEN     C=(21),K='VOLID FROM JFCB'                   @E211Q @L7A\n  DFHTUTEN     C=(22),K='BUILD NOTE'                        @E211Q @L7A\n  DFHTUTEN     C=(3E),K='FILL JFCB && SET PENDING'  OCCURS IN DFHJCO   F\n                                                            @E211Q @L7C\n  DFHTUTEN     C=(40),K='MAKE CURRENT'                      @E211Q @L7A\n  DFHTUTEN     C=(5F),K='SET CURRENT+OPEN' IN DFHJCO ONLY.  @E211Q @L7C\n  DFHTUTEN     C=(FF,FF),K=                                        @LMC\n*                                                                     *\nTUTB2D2R EQU   *                   VCP RETURN               @E211Q @L7A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT           @E211Q @L7A\n  DFHTUTEN     C=(00),K='NORMAL'                            @E211Q @L7A\n  DFHTUTEN     C=(20),K='SERIES IS SHORT'                   @E211Q @L7A\n  DFHTUTEN     C=(21),K='DONE PARTLY'                       @E211Q @L7A\n  DFHTUTEN     C=(22),K='NO OPERATOR REPLY'                 @E211Q @L7A\n  DFHTUTEN     C=(40),K='CONFLICT'                          @E211Q @L7A\n  DFHTUTEN     C=(41),K='SERIES NOT FOUND'                  @E211Q @L7A\n  DFHTUTEN     C=(43),K='VOLUME NOT FOUND'                  @E211Q @L7A\n  DFHTUTEN     C=(45),K='VOLUME IS REUSED'                  @E211Q @L7A\n  DFHTUTEN     C=(46),K='BAD DATA'                          @E211Q @L7A\n  DFHTUTEN     C=(80),K='INVALID REQ'                       @E211Q @L7A\n  DFHTUTEN     C=(FF,FF),K=                                 @E211Q @L7A\n*                                                                     *\nTUTB2D3D EQU   *                   LUP                      @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT           @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2D5D EQU   *                   UEH                         @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBDIA0Y\n  DFHTUTEN     C=(01,FF),K='BEFORE'                            @BBDIA0Y\n  DFHTUTEN     C=(02,FF),K='AFTER'                             @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2D6D EQU   *                   ALP                         @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBDIA0Y\n  DFHTUTEN     C=(01,00),K='UNCHAIN'                           @BBDIA0Y\n  DFHTUTEN     C=(02,00),K='TPQ CALL 2'                        @BBDI80O\n  DFHTUTEN     C=(03,00),K='LOCATE'                                @LMC\n  DFHTUTEN     C=(05,00),K='TPR CALL 2'                        @BBDI80O\n  DFHTUTEN     C=(06,00),K='CRS CALL 1'                        @BBDI80O\n  DFHTUTEN     C=(07,00),K='CRS CALL 2'                        @BBDI80O\n  DFHTUTEN     C=(08,00),K='ICP CALL 1'                        @BBDI80O\n  DFHTUTEN     C=(09,00),K='ICP CALL 2'                        @BBDI80O\n  DFHTUTEN     C=(0A,00),K='TPQ CALL 1'                            @LMC\n  DFHTUTEN     C=(0C,00),K='TPQ CALL 3'                            @LMA\n  DFHTUTEN     C=(0D,00),K='TPR CALL 1'                            @LMA\n  DFHTUTEN     C=(0E,00),K='CRQ CALL 1'                            @LMA\n  DFHTUTEN     C=(12,00),K='SCHEDULE'                          @BBDI80O\n  DFHTUTEN     C=(14,00),K='AVAIL'                             @BBDI80O\n  DFHTUTEN     C=(15,00),K='UNAVAIL'                           @BBDI80O\n  DFHTUTEN     C=(16,00),K='RELEASE'                           @BBDI80O\n  DFHTUTEN     C=(17,00),K='ALLOCATE'                              @02A\n  DFHTUTEN     C=(18,00),K='RELEASE_ABNORMAL'                      @04A\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDI80O\n*                                                                     *\nTUTB2D6R EQU   *                   ALP RETURN                  @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBDIA0Y\n  DFHTUTEN     C=(00,00),K='NORMAL'                            @BM13334\n  DFHTUTEN     C=(04,00),K='ERROR'                             @BM13334\n  DFHTUTEN     C=(0C,00),K='ERROR'                             @BM13334\n  DFHTUTEN     C=(31,00),K='ERROR'                             @BM13334\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2D7D EQU   *                   DIP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BM10857\n  DFHTUTEN     C=(01,00),K='ADD',NX=D7F                        @BM10857\n  DFHTUTEN     C=(02,00),K='ERASE',NX=D7F                      @BM10857\n  DFHTUTEN     C=(03,00),K='REPLACE',NX=D7F                    @BM10857\n  DFHTUTEN     C=(04,00),K='ABORT',NX=D7F                      @BM10857\n  DFHTUTEN     C=(05,00),K='QUERY',NX=D7F                      @BM10857\n  DFHTUTEN     C=(06,00),K='END',NX=D7F                        @BM10857\n  DFHTUTEN     C=(07,00),K='RECEIVE',NX=D7F                    @BM10857\n  DFHTUTEN     C=(08,00),K='NOTE',NX=D7F                       @BM10857\n  DFHTUTEN     C=(09,00),K='DETACH',NX=D7F                     @BM10857\n  DFHTUTEN     C=(0A,00),K='ATTACH',NX=D7F                     @BM10857\n  DFHTUTEN     C=(0B,00),K='SEND',NX=D7F                       @BM10857\n  DFHTUTEN     C=(0C,00),K='WAIT',NX=SRT                       @BM10857\n  DFHTUTEN     C=(FF,00),K='RESPONSE',NX=SRT                   @BM10857\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\nTUTB2D7F EQU   *\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=SRT\n  DFHTUTEN     C=(80),K='DEFRESP'\n  DFHTUTEN     C=(40),K='SAVE'\n  DFHTUTEN     C=(20),K='KEYADDR'\n  DFHTUTEN     C=(10),K='RRNADDR'\n  DFHTUTEN     C=(08),K='KEYNUMB'                           @E963C @H3C\n  DFHTUTEN     C=(01),K='WAIT'\n  DFHTUTEN     C=(FF,FF),K=\n*                                                                     *\nTUTB2D7R EQU   *                   DIP RETURN                  @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=SRT              @BM10857\n  DFHTUTEN     C=(00,00),K='NORMAL'                            @BBCI70Y\n  DFHTUTEN     C=(01,00),K='BEGIN'                             @BBCI70Y\n  DFHTUTEN     C=(02,00),K='RESUME'                            @BBCI70Y\n  DFHTUTEN     C=(11,00),K='END'                               @BBCI70Y\n  DFHTUTEN     C=(12,00),K='SUSPEND'                           @BBCI70Y\n  DFHTUTEN     C=(13,00),K='ABORT'                             @BBCI70Y\n  DFHTUTEN     C=(14,00),K='ABORT'                             @BBCI70Y\n  DFHTUTEN     C=(15,00),K=' '                                 @BBCI70Y\n  DFHTUTEN     C=(21,00),K='INVALID'                           @BBCI70Y\n  DFHTUTEN     C=(22,00),K='RECLEN'                            @BBCI70Y\n  DFHTUTEN     C=(23,00),K='DS FULL'                           @BBCI70Y\n  DFHTUTEN     C=(24,00),K='INVALID KEY/REC'                   @BBCI70Y\n  DFHTUTEN     C=(25,00),K='NOT AVAILABLE'                     @BBCI70Y\n  DFHTUTEN     C=(26,00),K='INVALID NUMREC'                    @BBCI70Y\n  DFHTUTEN     C=(28,00),K='INSUFFICIENT RES'                  @BBCI70Y\n  DFHTUTEN     C=(29,00),K='DS NOT FOUND'                      @BBCI70Y\n  DFHTUTEN     C=(2A,00),K='DS EXISTS'                         @BBCI70Y\n  DFHTUTEN     C=(2B,00),K='IGREQCD ERR'                       @BBC5G0L\n  DFHTUTEN     C=(2C,00),K='LUSTAT NO DATA'                    @BBCI70Y\n  DFHTUTEN     C=(41,00),K='NO DEST'                           @BBCI70Y\n  DFHTUTEN     C=(42,00),K='DEST BUSY'                         @BBCI70Y\n  DFHTUTEN     C=(43,00),K='MEDIA NOT SUPPORTED'               @BBCI70Y\n  DFHTUTEN     C=(44,00),K='INVALID DEST NAME'                 @BBCI70Y\n  DFHTUTEN     C=(45,00),K='INVALID VOLUME'                    @BBCI70Y\n  DFHTUTEN     C=(46,00),K='VOLUME LEN ERR'                    @BBCI70Y\n  DFHTUTEN     C=(47,00),K='TRANSMIT DS ACTIVE'                @BBCI70Y\n  DFHTUTEN     C=(48,00),K='DS ACTIVE'                         @BBCI70Y\n  DFHTUTEN     C=(60,00),K='TD ERROR'                          @BBCI70Y\n  DFHTUTEN     C=(F1,00),K='UNEXP SENSE'                       @BBCI70Y\n  DFHTUTEN     C=(F2,00),K='UNEXP FMH'                         @BBCI70Y\n  DFHTUTEN     C=(F3,00),K='UNSUP INPUT'                       @BBCI70Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2D8D EQU   *                   SPP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BA51625\n  DFHTUTEN     C=(01,00),K='USER'                              @BD910JY\n  DFHTUTEN     C=(02,00),K='SYSTEM'                            @BD910JY\n  DFHTUTEN     C=(09,00),K='ROLLBACK'                          @BBAI20Y\n  DFHTUTEN     C=(10,00),K='RESYNC REQUEST'                    @BA51625\n  DFHTUTEN     C=(20,00),K='LUC',NX=D8Z                        @BA51625\n  DFHTUTEN     C=(60,00),K='LUC SEND-PREPARE'                  @BA51625\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\nTUTB2D8Z EQU   *                                               @BA51625\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=SRT              @BA51625\n  DFHTUTEN     C=(01,00),K='BIS (INBOUND)'                     @BA51625\n  DFHTUTEN     C=(02,00),K='UNBIND'                            @BA51625\n  DFHTUTEN     C=(04,00),K='RESYNC'                            @BA51625\n  DFHTUTEN     C=(08,00),K='EXCHANGE LOG NAMES RECEIVED'       @BA51625\n  DFHTUTEN     C=(10,00),K='CONTACT'                           @BA51625\n  DFHTUTEN     C=(20,00),K='QPEND'                             @BA51625\n  DFHTUTEN     C=(40,00),K='CLPEND'                            @BA51625\n  DFHTUTEN     C=(FF,FF),K=                                    @BA51625\n*                                                                     *\n*TUTB2D9D EQU   TUTB2E1D      XFP SAME AS EIP                  @BD910JY\n*    COPY EIP TRACE                                            @BBAI20Y\n*                                                                     *\nTUTB2DAD EQU   *                   STATS                       @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAA12Y\n* DFHTUTEN     C=(01,00),K='USER'                              @BD910JY\n* DFHTUTEN     C=(02,00),K='SYSTEM'                            @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2DBD EQU   *                   XTP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BBDJ20B\n  DFHTUTEN     C=(00,00),K='XFORM1'                            @BBDJ20B\n  DFHTUTEN     C=(02,00),K='XFORM2'                            @BBDJ20B\n  DFHTUTEN     C=(04,00),K='XFORM3'                            @BBDJ20B\n  DFHTUTEN     C=(06,00),K='XFORM4'                            @BBDJ20B\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDJ20B\n*                                                                     *\nTUTB2DCD EQU   *                   ACP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAA12Y\n* DFHTUTEN     C=(01,00),K='USER'                              @BD910JY\n* DFHTUTEN     C=(02,00),K='SYSTEM'                            @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2DDD EQU   *                   IRC                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBDIA0Y\n  DFHTUTEN     C=(00),K='RESUME'                               @BBDIA0Y\n  DFHTUTEN     C=(01),K='CONNECT'                              @BBDIA0Y\n  DFHTUTEN     C=(02),K='IN',NX=DD0                            @BBCIA0Y\n  DFHTUTEN     C=(03),K='INBOUND DATA'                         @BBDIA0Y\n  DFHTUTEN     C=(04),K='OUTB',NX=DD0                          @BBDIA0Y\n  DFHTUTEN     C=(05),K='OUTBOUND DATA'                        @BBDIA0Y\n  DFHTUTEN     C=(06),K='BATCH NAME'                           @BBDIA0Y\n  DFHTUTEN     C=(07),K='NAME CONTINUED'                       @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*  FIELD A0 - A1 SEQ NUMBER                                           *\nTUTB2DD0 EQU   *                                               @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=DD1               @BBDIA0Y\n  DFHTUTEN     C=(80),K='RESP'                                 @BBDIA0Y\n  DFHTUTEN     C=(40),K=' '                                    @BBDIA0Y\n  DFHTUTEN     C=(20),K=' '                                    @BBDIA0Y\n***   DFHTUTEN     C=(10),K='FMH'              DELETED BY APAR @BA42777\n  DFHTUTEN     C=(08),K='FMH'                                  @BA42777\n  DFHTUTEN     C=(04),K='SENSE'                                @BBDIA0Y\n  DFHTUTEN     C=(02),K='BC'                                   @BBDIA0Y\n  DFHTUTEN     C=(01),K='EC'                                   @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\nTUTB2DD1 EQU   *                                               @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DD2,NX=DD2               @BBDIA0Y\n  DFHTUTEN     C=(80),K='RQD1'                                 @BBDIA0Y\n  DFHTUTEN     C=(40),K='RQE1'                                 @BBDIA0Y\n  DFHTUTEN     C=(20),K='RQD2'                                 @BBDIA0Y\n  DFHTUTEN     C=(10),K='RQE2'                                 @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\nTUTB2DD2 EQU   *                                               @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=B0,E=DFT,NX=SRT               @BBDIA0Y\n  DFHTUTEN     C=(80),K='BB'                                   @BBDIA0Y\n  DFHTUTEN     C=(40),K='EB'                                   @BBDIA0Y\n  DFHTUTEN     C=(20),K='CD'                                   @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2DED EQU   *                   SKP                             @LIA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT                  @LIA\n  DFHTUTEN     C=(01,00),K='PERFORM'                               @LIA\n  DFHTUTEN     C=(02,00),K='WAIT'                                  @LIA\n  DFHTUTEN     C=(03,00),K='RETURN'                                @LIA\n  DFHTUTEN     C=(04,00),K='TERMINATE'                             @LIA\n  DFHTUTEN     C=(05,00),K='DWE PROCESS'                           @LIA\n  DFHTUTEN     C=(FF,FF),K=                                        @LIA\n*                                                                     *\nTUTB2DER EQU   *                   SKP RETURN                      @LIA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A3,E=DFT,NX=SRT                  @LIA\n  DFHTUTEN     C=(00),K='NORMAL'                                   @LIA\n  DFHTUTEN     C=(04),K='USER CODE FAILED'                         @LIA\n  DFHTUTEN     C=(08),K='SUBTASK CODE FAILED'                      @LIA\n  DFHTUTEN     C=(0C),K='UNABLE TO PERFORM REQUEST'                @LIA\n  DFHTUTEN     C=(10),K='REQUEST NEVER COMPLETED'                  @LIA\n  DFHTUTEN     C=(14),K='INVALID REQUEST'                          @LIA\n  DFHTUTEN     C=(18),K='INVALID ECB ADDRESS'                      @LIA\n  DFHTUTEN     C=(1C),K='USER TASK WAS CANCELLED'                  @LIA\n  DFHTUTEN     C=(FF,FF),K=                                        @LIA\n*                                                                     *\nTUTB2DFD EQU   *                   ISP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(01,00),K='RECEIVE'                           @BBAI20Y\n  DFHTUTEN     C=(02,00),K='ATTACH'                            @BBAI20Y\n  DFHTUTEN     C=(03,00),K='SHUTDOWN'                          @BBAI20Y\n  DFHTUTEN     C=(04,00),K='CONVERSE',NX=DFF                   @BBAI20Y\n  DFHTUTEN     C=(05,00),K='I/O REQ',NX=DFF                    @BBAI20Y\n  DFHTUTEN     C=(06,00),K='INITIALIZE'                            @LMC\n  DFHTUTEN     C=(07,00),K='ABEND'                             @BBAI20Y\n  DFHTUTEN     C=(08,00),K='IRC STOP'                          @BBAI20Y\n  DFHTUTEN     C=(09,00),K='IRC STOP IMMED'                    @BBAI20Y\n  DFHTUTEN     C=(0A,00),K='IRC LOGOFF'                        @BBAI20Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\nTUTB2DFF EQU   *                                               @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT               @BBAI20Y\n  DFHTUTEN     C=(80,00),K='WRITE'                             @BBAI20Y\n  DFHTUTEN     C=(40,00),K='WAIT'                              @BBAI20Y\n  DFHTUTEN     C=(20,00),K='READ'                              @BBAI20Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\n*                                                                     *\nTUTB2E0D EQU   *                   MGP                         @BM10519\n  DFHTUTEN     T=(2,I),CP=2BIN,OFF=A2,E=DFT,NX=E0F             @BM10519\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10519\nTUTB2E0F EQU   *                                               @BM10519\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT               @BM10519\n  DFHTUTEN     C=(80),K='CSMT'                                 @BM10519\n  DFHTUTEN     C=(40),K='CSTL'                                 @BBDIA0Y\n  DFHTUTEN     C=(20),K='TERM'                                 @BBDIA0Y\n  DFHTUTEN     C=(10),K='CONSOLE'                              @BBDIA0Y\n  DFHTUTEN     C=(08),K='RETTIOA'                              @BM13334\n  DFHTUTEN     C=(04),K='NONUM'                                @BBDIA0Y\n  DFHTUTEN     C=(02),K='TIOA'                                 @BBDIA0Y\n  DFHTUTEN     C=(01),K='CSCS'                                 @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2E1D EQU   *                   EIP                         @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLC,OFF=B2,E=DFT,NX=E1E              @BBAI20Y\n         COPY  DFHEITUT            COPY HLL TABLE              @BBAI20Y\n  DFHTUTEN     C=(40,02),K='DL/I SCHEDULE'                     @BBAI20Y\n  DFHTUTEN     C=(40,04),K='DL/I SCHEDULE REPLY'               @BBAI20Y\n  DFHTUTEN     C=(40,06),K='DL/I REPLACE'                      @BBAI20Y\n  DFHTUTEN     C=(40,08),K='DL/I INSERT'                       @BBAI20Y\n  DFHTUTEN     C=(40,0A),K='DL/I DELETE'                       @BBAI20Y\n  DFHTUTEN     C=(40,10),K='DL/I GET UNIQUE'                   @BBAI20Y\n  DFHTUTEN     C=(40,12),K='DL/I GET UNIQUE HOLD'              @BBAI20Y\n  DFHTUTEN     C=(40,14),K='DL/I GET NEXT'                     @BBAI20Y\n  DFHTUTEN     C=(40,16),K='DL/I GET NEXT HOLD'                @BBAI20Y\n  DFHTUTEN     C=(40,18),K='DL/I GET NEXT PARENT'              @BBAI20Y\n  DFHTUTEN     C=(40,1A),K='DL/I GET NEXT PARENT HOLD'         @BBAI20Y\n  DFHTUTEN     C=(40,1C),K='DL/I REPLY WITH DATA'              @BM10416\n  DFHTUTEN     C=(40,1E),K='DL/I REPLY NO DATA'                @BM10416\n  DFHTUTEN     C=(40,20),K='DL/I DEQ'                          @BBAI20Y\n  DFHTUTEN     C=(40,22),K='DL/I DEQ REPLY'                    @BM10416\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\nTUTB2E1E EQU   *                                               @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R1,E=E1C,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(04),K='ENTRY'                                @BBDIA0Y\n  DFHTUTEN     C=(F4),K='RESPONSE'                             @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\n*                                                                     *\nTUTB2E3D EQU   *                   PSP                             @LEA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT                  @LEA\n*  STANDARD SYSTEM ENTRIES ********************************************\n  DFHTUTEN     C=(A0),K='ENTRY'                                    @LEA\n  DFHTUTEN     C=(A1),K='RESPONSE'                                 @LEA\n  DFHTUTEN     C=(A2),K='UNSUPPORTED FUNCTION'                     @LEA\n*  SYSTEM ENTRIES PRODUCED ONLY IF SPECIAL FE OPTION ON ***************\n  DFHTUTEN     C=(88),K='DFHEPS SPOOLOPEN STANDARD'                @LEA\n  DFHTUTEN     C=(42),K='DFHEPS SPOOLOPEN INPUT'                   @LEA\n  DFHTUTEN     C=(41),K='DFHEPS SPOOLOPEN OUTPUT'                  @LEA\n  DFHTUTEN     C=(40),K='DFHEPS SPOOLOPEN RESPONSE'                @LEA\n  DFHTUTEN     C=(28),K='DFHEPS SPOOLWRITE STANDARD'               @LEA\n  DFHTUTEN     C=(22),K='DFHEPS SPOOLWRITE RESPONSE'               @LEA\n  DFHTUTEN     C=(21),K='DFHEPS SPOOLREAD STANDARD'                @LEA\n  DFHTUTEN     C=(20),K='DFHEPS SPOOLREAD RESPONSE'                @LEA\n  DFHTUTEN     C=(14),K='DFHEPS SPOOLCLOSE PRINT'                  @LEA\n  DFHTUTEN     C=(11),K='DFHEPS SPOOLCLOSE DELETE'                 @LEA\n  DFHTUTEN     C=(10),K='DFHEPS SPOOLCLOSE RESPONSE'               @LEA\n  DFHTUTEN     C=(B0),K='DFHPSPCK ENTRY'                           @LEA\n  DFHTUTEN     C=(B1),K='DFHPSPCK INVALID REQUEST'                 @LEA\n  DFHTUTEN     C=(B2),K='DFHPSPCK INTERFACE HALTING'               @LEA\n  DFHTUTEN     C=(B3),K='DFHPSPCK INTERFACE DISABLE'               @LEA\n  DFHTUTEN     C=(B4),K='DFHPSPCK INTERFACE TERMINATE'             @LEA\n  DFHTUTEN     C=(E0),K='DFHPSPST ENTRY'                           @LEA\n  DFHTUTEN     C=(E1),K='DFHPSPST OPEN INPUT RESPONSE'             @LEA\n  DFHTUTEN     C=(E2),K='DFHPSPST OPEN OUTPUT RESPONSE'            @LEA\n  DFHTUTEN     C=(E3),K='DFHPSPST READ RESPONSE'                   @LEA\n  DFHTUTEN     C=(E4),K='DFHPSPST WRITE RESPONSE'                  @LEA\n  DFHTUTEN     C=(E5),K='DFHPSPST CLOSE RESPONSE'                  @LEA\n  DFHTUTEN     C=(E6),K='DFHPSPST INTERFACE HALTING'               @LEA\n  DFHTUTEN     C=(E7),K='DFHPSPST INVALID REQUEST'                 @LEA\n  DFHTUTEN     C=(E8),K='DFHPSPST INVALID OPEN REQUEST'            @LEA\n  DFHTUTEN     C=(E9),K='DFHPSPST INVALID READ REQUEST'            @LEA\n  DFHTUTEN     C=(EA),K='DFHPSPST INVALID WRITE REQUEST'           @LEA\n  DFHTUTEN     C=(EB),K='DFHPSPST INVALID CLOSE REQUEST'           @LEA\n***********************************************************************\n  DFHTUTEN     C=(FF,FF),K=                                        @LEA\n*                                                                     *\nTUTB2E5D EQU   *                   XSP                         @BM13334\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BM13334\n  DFHTUTEN     C=(00),K='SECURITY INITIAL'                     @BA81335\n  DFHTUTEN     C=(04),K='SECURITY SIGNON + PASSWORD'           @BA81335\n  DFHTUTEN     C=(08),K='SECURITY SIGNON - PASSWORD'           @BA81335\n  DFHTUTEN     C=(0C),K='SECURITY CHECK'                       @BA81335\n  DFHTUTEN     C=(10),K='SECURITY SIGN-OFF'                    @BA81335\n  DFHTUTEN     C=(14),K='SECURITY TIMEOUT VALUE'               @BA81335\n  DFHTUTEN     C=(18),K='SECURITY USERID'                      @BA81335\n  DFHTUTEN     C=(1C),K='SECURITY WAITINIT'                    @BA81335\n  DFHTUTEN     C=(20),K='SECURITY MIN TIME'                    @BA81335\n  DFHTUTEN     C=(24),K='SECURITY BUILD SNTTE'                 @BA81335\n  DFHTUTEN     C=(28),K='SECURITY DELETE SNTTE'                @BA81335\n  DFHTUTEN     C=(2C),K='SECURITY REBUILD'                     @BA81335\n  DFHTUTEN     C=(30),K='SECURITY RESTART TASK'                @BA81335\n  DFHTUTEN     C=(40),K='SHARED SIGNON -',NX=E5E               @BA81335\n  DFHTUTEN     C=(44),K='SHARED SIGNOFF -',NX=E5E              @BA81335\n  DFHTUTEN     C=(48),K='SECURITY ZUTM SIGNON'                 @BA81335\n  DFHTUTEN     C=(4C),K='SECURITY ZUTM SIGNOFF'                @BA81335\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\n*                                                              @BA81335\nTUTB2E5E EQU   *                   XSP TCTTE FIELD             @BA81335\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=B0,E=DFT,NX=SRT              @BA81335\n  DFHTUTEN     C=(01),K='TCTTESNT'                             @BA81335\n  DFHTUTEN     C=(02),K='TCTEIRSN'                             @BA81335\n  DFHTUTEN     C=(03),K='TCTELSNT'                             @BA81335\n  DFHTUTEN     C=(FF,FF),K=                                    @BA81335\n*                                                                     *\nTUTB2E6D EQU   *                   TCP/TACP (BTAM)                 @LRC\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT                  @D2A\n*  FE TRACE ENTRIES FROM TCP ******************************************\n  DFHTUTEN     C=(01),K='LINE SCAN PART 1'                         @D2A\n  DFHTUTEN     C=(02),K='LINE SCAN PART 2'                         @D2A\n  DFHTUTEN     C=(03),K='I/O INITIATION PART 1'                    @D2A\n  DFHTUTEN     C=(04),K='I/O INITIATION PART 2'                    @D2A\n  DFHTUTEN     C=(05),K='EVENT TERMINATION PART 1'                 @D2A\n  DFHTUTEN     C=(06),K='EVENT TERMINATION PART 2'                 @D2A\n  DFHTUTEN     C=(07),K='AUTOPOLL CHANGE'                          @D2A\n  DFHTUTEN     C=(08),K='LOPEN REQUEST PART 1'                 @BA52698\n  DFHTUTEN     C=(09),K='LOPEN REQUEST PART 2'                 @BA52698\n*  SYSTEM TRACE ENTRIES FROM TACP *************************************\n  DFHTUTEN     C=(10),K='LINK TO TEP'                              @LRA\n  DFHTUTEN     C=(20),K='RETURN FROM TEP'                          @LRA\n*              ********************************************************\n  DFHTUTEN     C=(FF,FF),K=                                        @D2A\n*                                                                     *\nTUTB2E7D EQU   *                   EDLI                     @ECB0R @L1A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=B3,E=DFT,NX=SRT           @ECB0R @L1A\n  DFHTUTEN     C=(00,00),K='ENTRY'                          @ECB0R @L1A\n  DFHTUTEN     C=(09,00),K='(RM UNAVAILABLE)'               @ECB0R @L1A\n  DFHTUTEN     C=(0F,00),K='PASSING CONTROL TO RM'          @ECB0R @L1A\n  DFHTUTEN     C=(F0,00),K='REGAINING CONTROL FROM RM'      @ECB0R @L1A\n  DFHTUTEN     C=(FF,00),K='RESPONSE'                       @ECB0R @L1A\n  DFHTUTEN     C=(FF,FF),K=                                 @ECB0R @L1A\n*                                                                     *\nTUTB2EAD EQU   *                   TMP                      @EU71T @L2C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A2,E=DFT,NX=EAE           @EU71T @L2C\n  DFHTUTEN     C=(01),K='PCT'                               @EU71T @L2C\n  DFHTUTEN     C=(02),K='PCTR'                              @EU71T @L2C\n  DFHTUTEN     C=(03),K='PPT'                               @EU71T @L2C\n  DFHTUTEN     C=(04),K='PFT'                               @EU71T @L2C\n  DFHTUTEN     C=(05),K='FCT'                               @EU71T @L2C\n  DFHTUTEN     C=(06),K='DCT'                               @EU71T @L2C\n  DFHTUTEN     C=(07),K='TCTE'                                     @LJA\n  DFHTUTEN     C=(08),K='TCTN'                                     @LJA\n  DFHTUTEN     C=(09),K='TCTS'                                     @LJA\n  DFHTUTEN     C=(FF,FF),K=                                        @LJA\nTUTB2EAE EQU   *                                            @EU71J @L4C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT           @EU71T @L2C\n  DFHTUTEN     C=(01),K='LOCATE'                            @EU71T @L2C\n  DFHTUTEN     C=(02),K='GETNEXT'                           @EU71T @L2C\n  DFHTUTEN     C=(03),K='GETALIAS'                          @EU71T @L2C\n  DFHTUTEN     C=(04),K='ADD'                               @EU71T @L2C\n  DFHTUTEN     C=(05),K='DELETE'                            @EU71T @L2C\n  DFHTUTEN     C=(06),K='ALIAS'                             @EU71T @L2C\n  DFHTUTEN     C=(07),K='LOCK'                              @EU71T @L2C\n  DFHTUTEN     C=(08),K='UNLOCK'                            @EU71T @L2C\n  DFHTUTEN     C=(09),K='CREATE'                            @EU71T @L2C\n  DFHTUTEN     C=(0A),K='INDEX'                             @EU71T @L2C\n  DFHTUTEN     C=(0B),K='QUIESCE'                           @EU71T @L2C\n  DFHTUTEN     C=(0C),K='TRANSFER'                          @EU71T @L2C\n  DFHTUTEN     C=(0D),K='DWE'                               @EU71T @L2C\n  DFHTUTEN     C=(0E),K='RESET'                             @EU71T @L2C\n  DFHTUTEN     C=(FF,FF),K=                                 @EU71T @L2C\n*                                                                     *\nTUTB2EAR EQU   *                   TMP RETURN               @EU71T @L2C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A3,E=DFT,NX=SRT           @EU71T @L2C\n  DFHTUTEN     C=(00),K='NORMAL'                            @EU71T @L2C\n  DFHTUTEN     C=(04),K='NOT FOUND'                         @EU71T @L2C\n  DFHTUTEN     C=(08),K='DUPLICATE'                         @EU71T @L2C\n  DFHTUTEN     C=(0C),K='INVREQ'                            @EU71T @L2C\n  DFHTUTEN     C=(10),K='ENTRY BUSY'                        @EU71T @L2C\n  DFHTUTEN     C=(14),K='PROTECTED'                         @EU71T @L2C\n  DFHTUTEN     C=(18),K='LOCK HELD'                         @EU71T @L2C\n  DFHTUTEN     C=(1C),K='LOCK NOTED'                        @EU71T @L2C\n  DFHTUTEN     C=(FF,FF),K=                                 @EU71T @L2C\n*                                                                     *\nTUTB2EBD EQU   *                   AMP                      @EU71J @L4C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT           @EU71J @L4C\n  DFHTUTEN     C=(01),K='ROUTER'                           @EU710A @L4C\n  DFHTUTEN     C=(FF,FF),K=                                 @EU71J @L4C\n*                                                                     *\nTUTB2ECD EQU   *                   DMP                      @EU71J @L4C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT           @EU71J @L4C\n  DFHTUTEN     C=(00),K='ROUTER'                            @EU71J @L4C\n  DFHTUTEN     C=(01),K='CONNECT'                           @EU71J @L4C\n  DFHTUTEN     C=(02),K='DISCONNECT'                        @EU71J @L4C\n  DFHTUTEN     C=(03),K='WRITE'                             @EU71J @L4C\n  DFHTUTEN     C=(04),K='READ'                              @EU71J @L4C\n  DFHTUTEN     C=(05),K='DELETE'                            @EU71J @L4C\n  DFHTUTEN     C=(06),K='(UN)LOCK'                          @EU71J @L4C\n  DFHTUTEN     C=(08),K='START BROWSE'                      @EU71J @L4C\n  DFHTUTEN     C=(09),K='GET NEXT'                          @EU71J @L4C\n  DFHTUTEN     C=(0A),K='END BROWSE'                        @EU71J @L4C\n  DFHTUTEN     C=(0B),K='CREATE SET'                        @EU71J @L4C\n  DFHTUTEN     C=(0D),K='QUERY SET'                         @EU71J @L4C\n  DFHTUTEN     C=(0F),K='ACCESS PRIMARY CTRL REC'           @EU71J @L4C\n  DFHTUTEN     C=(10),K='BUILD KWA'                         @EU71J @L4C\n  DFHTUTEN     C=(11),K='RELEASE KWA'                       @EU71J @L4C\n  DFHTUTEN     C=(12),K='TOKENISE KEY'                      @EU71J @L4C\n  DFHTUTEN     C=(13),K='FREE TOKEN(S)'                     @EU71J @L4C\n  DFHTUTEN     C=(15),K='GENERIC QUALIFY'                   @EU71J @L4C\n  DFHTUTEN     C=(16),K='SEQUENCE ORDERED SET'              @EU71J @L4C\n  DFHTUTEN     C=(17),K='VERIFY KWA'                        @EU71J @L4C\n  DFHTUTEN     C=(63),K='ADAPTOR'                           @EU71J @L4A\n  DFHTUTEN     C=(FF,FF),K=                                 @EU71J @L4C\n*                                                                     *\nTUTB2EDD EQU   *                   LFO NULL                    @BM13334\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT               @BM13334\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\n*                                                                     *\nTUTB2EED EQU   *                   VIO                         @BM13793\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R1,E=DFT,NX=SRT              @BM13793\n  DFHTUTEN     C=(14),K=' ',NX=EE0                             @BM13793\n  DFHTUTEN     C=(24),K='DATA',NX=SRT                          @BM13793\n  DFHTUTEN     C=(34),K='NEGATIVE RESP CODE',NX=SRT            @BM13793\n  DFHTUTEN     C=(44),K='LUSTAT CODE',NX=SRT                   @BM13793\n  DFHTUTEN     C=(54),K='SIGNAL CODE',NX=SRT                   @BM13793\n  DFHTUTEN     C=(64),K=' ',NX=EEE                        @EAPAR0L @01C\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\nTUTB2EEE EQU   *                                          @EAPAR0L @01A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT         @EAPAR0L @01C\n  DFHTUTEN     C=(01),K='STSN'                            @EAPAR0L @01A\n  DFHTUTEN     C=(02),K='CLEAR'                           @EAPAR0L @01A\n  DFHTUTEN     C=(03),K='SDT'                             @EAPAR0L @01A\n  DFHTUTEN     C=(04),K='BIND'                            @EAPAR0L @01A\n  DFHTUTEN     C=(FF,FF),K=                               @EAPAR0L @01A\n*  FIELD A0 - A1 SEQ NUMBER                                           *\nTUTB2EE0 EQU   *                                               @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BM13334\n  DFHTUTEN     C=(11),K='WRITE'                                @BBDIA0Y\n  DFHTUTEN     C=(12),K='RESET'                                @BBDIA0Y\n  DFHTUTEN     C=(13),K='DO'                                   @BBDIA0Y\n  DFHTUTEN     C=(16),K='SIMLOGON'                             @BBDIA0Y\n  DFHTUTEN     C=(17),K='OPNDST'                               @BBDIA0Y\n  DFHTUTEN     C=(19),K='CHANGE'                               @BBDIA0Y\n  DFHTUTEN     C=(1A),K='INQUIRE'                              @BBDIA0Y\n  DFHTUTEN     C=(1F),K='CLSDST'                               @BBDIA0Y\n  DFHTUTEN     C=(21),K='CLOSE ACB'                            @BBDIA0Y\n  DFHTUTEN     C=(22),K='SEND',NX=EE1                          @BM13334\n  DFHTUTEN     C=(23),K='RECEIVE',NX=EE1                       @BM13334\n  DFHTUTEN     C=(24),K='RESETSR'                              @BBDIA0Y\n  DFHTUTEN     C=(25),K='SESSIONC'                             @BBDIA0Y\n  DFHTUTEN     C=(27),K='SENDCMD'                              @BBDIA0Y\n  DFHTUTEN     C=(28),K='RCVCMD'                               @BBDIA0Y\n  DFHTUTEN     C=(29),K='REQSESS'                              @BBDIA0Y\n  DFHTUTEN     C=(2A),K='OPNSEC'                               @BBDIA0Y\n  DFHTUTEN     C=(2C),K='TERMSESS'                             @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\nTUTB2EE1 EQU   *                                               @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=EE2               @BBDIA0Y\n  DFHTUTEN     C=(80),K='BB'                                   @BBDIA0Y\n  DFHTUTEN     C=(40),K='EB'                                   @BBDIA0Y\n  DFHTUTEN     C=(20),K='CD'                                   @BBDIA0Y\n  DFHTUTEN     C=(10),K='FMH'                                  @BBDIA0Y\n  DFHTUTEN     C=(08),K='BC'                                   @BM13334\n  DFHTUTEN     C=(04),K='MC'                                   @BM13334\n  DFHTUTEN     C=(02),K='EC'                                   @BM13334\n  DFHTUTEN     C=(01),K='OIC'                                  @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\nTUTB2EE2 EQU   *                                               @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DFT,NX=EE3               @BM13334\n  DFHTUTEN     C=(40),K='RESP'                                 @BM13334\n  DFHTUTEN     C=(20),K='DATA'                                 @BM13334\n  DFHTUTEN     C=(10),K='CMD'                                  @BM13334\n**DFHTUTEN     C=(80),K=           INBOUND                     @BBCIA0Y\n  DFHTUTEN     C=(08),K='-'                                    @BM13334\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\nTUTB2EE3 EQU   *                                               @BM13334\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=EEA,NX=EE4               @BM13334\n  DFHTUTEN     C=(80),K='RQD1'                                 @BM13334\n  DFHTUTEN     C=(40),K='RQD2'                                 @BM13334\n  DFHTUTEN     C=(20),K='RQE1'                                 @BM13334\n  DFHTUTEN     C=(10),K='RQE2'                                 @BM13334\n  DFHTUTEN     C=(08),K='RQE3'                              @EI226 @L9A\n  DFHTUTEN     C=(04),K='RQD3'                              @EI226 @L9A\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\nTUTB2EE4 EQU   *                                               @BM13334\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=B0,E=DFT,NX=SRT              @BBDIA0Y\n**DFHTUTEN     C=(01),K='DATA'                                 @BM13334\n  DFHTUTEN     C=(04),K='LUSTAT'                               @BBDIA0Y\n  DFHTUTEN     C=(05),K='RTR'                                  @BBDIA0Y\n  DFHTUTEN     C=(05),K='LSA'                                  @BBDIA0Y\n  DFHTUTEN     C=(31),K='BIND'                                 @BBDIA0Y\n  DFHTUTEN     C=(32),K='UNBIND'                               @BBDIA0Y\n  DFHTUTEN     C=(70),K='BIS'                                  @BBDIA0Y\n  DFHTUTEN     C=(71),K='SBI'                                  @BBDIA0Y\n  DFHTUTEN     C=(80),K='QEC'                                  @BBDIA0Y\n  DFHTUTEN     C=(81),K='QC'                                   @BBDIA0Y\n  DFHTUTEN     C=(82),K='RELQ'                                 @BBDIA0Y\n  DFHTUTEN     C=(83),K='CANCEL'                               @BBDIA0Y\n  DFHTUTEN     C=(84),K='CHASE'                                @BBDIA0Y\n  DFHTUTEN     C=(A0),K='SDT'                                  @BBDIA0Y\n  DFHTUTEN     C=(A1),K='CLEAR'                                @BBDIA0Y\n  DFHTUTEN     C=(A2),K='STSN'                                 @BBDIA0Y\n  DFHTUTEN     C=(A3),K='RQR'                                  @BBDIA0Y\n  DFHTUTEN     C=(C0),K='SHUTD'                                @BBDIA0Y\n  DFHTUTEN     C=(C1),K='SHUTC'                                @BBDIA0Y\n  DFHTUTEN     C=(C2),K='RSHUTD'                               @BBDIA0Y\n  DFHTUTEN     C=(C8),K='BID'                                  @BBDIA0Y\n  DFHTUTEN     C=(C9),K='SIGNAL'                               @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2EFD EQU   *                   TOR                             @LKA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT                  @LKA\n  DFHTUTEN     C=(01),K='MAIN PROGRAM'                             @LKA\n  DFHTUTEN     C=(02),K='ADD (NON POOLED) TERM - TOATM'            @LKC\n  DFHTUTEN     C=(03),K='ADD (POOLED) TERMINAL - TOAPT'            @LKC\n  DFHTUTEN     C=(04),K='ADD TYPETERM - TOATY'                     @LKC\n  DFHTUTEN     C=(05),K='ADD CONNECTION - TOACN'                   @LKC\n  DFHTUTEN     C=(06),K='ADD SESSIONS - TOASE'                     @LKC\n  DFHTUTEN     C=(07),K='END GROUP - TOLCR'                        @LKC\n  DFHTUTEN     C=(08),K='END GROUP - TOLUI'                        @LKC\n  DFHTUTEN     C=(09),K='DWE COMMIT PROCESS - TOCMT'               @LKC\n  DFHTUTEN     C=(0A),K='DWE CANCEL PROCESS - TOCAN'               @LKC\n  DFHTUTEN     C=(0B),K='UTILITY - TOUT1'                          @LKC\n  DFHTUTEN     C=(0C),K='UTILITY - TOUT2'                          @LKC\n  DFHTUTEN     C=(10),K='MODEL RETRIEVAL'                          @LKA\n  DFHTUTEN     C=(11),K='CREATE TERMINAL BPS - TOBPS'              @LKA\n  DFHTUTEN     C=(12),K='RECOVERY PROGRAM - TORP'                  @LKA\n  DFHTUTEN     C=(FF,FF),K=                                        @LKA\n*                                                                     *\nTUTB2F0D EQU   *                   KCP                         @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAA12Y\n  DFHTUTEN     C=(01,00),K='ENQUEUE'                           @BD910JY\n  DFHTUTEN     C=(02,00),K='DEQUEUE'                           @BD910JY\n  DFHTUTEN     C=(03,00),K='DEQALL'                            @BD910JY\n  DFHTUTEN     C=(04,00),K='SUSPEND',NX=F0E                 @17307 @P3C\n  DFHTUTEN     C=(05,00),K='ENQUEUE-CONDITIONAL'               @BBDIA0Y\n  DFHTUTEN     C=(06,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(07,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(08,00),K='RESUME'                            @BD910JY\n  DFHTUTEN     C=(09,00),K='UPDATE TASKTIME'                       @LQA\n  DFHTUTEN     C=(0A,00),K='CHANGE MXT VALUE'               @01508 @D1A\n  DFHTUTEN     C=(0B,00),K='REDISPATCH'                     @01508 @D1A\n  DFHTUTEN     C=(0C,00),K='ENTER SRB MODE'                    @BD910JY\n  DFHTUTEN     C=(0D,00),K='ATTACH HTA'                        @BD910JY\n  DFHTUTEN     C=(0E,00),K='(NON FORCE) CANCEL TASK'        @17176 @P2C\n  DFHTUTEN     C=(0F,00),K='FORCE CANCEL TASK'              @17176 @P2A\n  DFHTUTEN     C=(10,00),K='ATTACH'                            @BD910JY\n  DFHTUTEN     C=(11,00),K='ATTACH-CONDITIONAL'                @BD910JY\n  DFHTUTEN     C=(12,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(13,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(14,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(15,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(16,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(17,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(18,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(19,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(1A,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(1B,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(1C,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(1D,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(1E,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(1F,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(20,00),K='CHAP'                              @BD910JY\n  DFHTUTEN     C=(28,00),K='LOCATE'                         @EU71T @L2A\n  DFHTUTEN     C=(29,00),K='LOCATE-REGION'                  @EU71T @L2A\n  DFHTUTEN     C=(2A,00),K='BROWSE'                         @EU71T @L2A\n  DFHTUTEN     C=(2B,00),K='BROWSE-UNLOCK'                  @EU71T @L2A\n  DFHTUTEN     C=(2C,00),K='LOCATE-PROFILE'                 @EU71T @L2A\n  DFHTUTEN     C=(2D,00),K='BROWSE-PROFILE'                 @EU71B @L3A\n  DFHTUTEN     C=(2E,00),K='BROWSE-PROFILE-UNLOCK'          @EU71B @L3A\n  DFHTUTEN     C=(2F,00),K='CTYPE',NX=F0C                   @EU71B @LLC\n  DFHTUTEN     C=(32,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(33,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(36,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(37,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(3A,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(3B,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(3E,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(3F,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(40,00),K='WAIT',NX=F0F                       @BM10700\n  DFHTUTEN     C=(80,00),K='DETACH'                            @BD910JY\n  DFHTUTEN     C=(84,00),K='SUSPEND+CANCADDR',NX=F0E        @01508 @D1C\n  DFHTUTEN     C=(92,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(93,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(9A,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(9B,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(B2,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(B3,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(BA,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(BB,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(C0,00),K='WAIT+CANCADDR',NX=F0F           @01508 @D1C\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\nTUTB2F0F EQU   *                                               @BM10700\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BM10700\n  DFHTUTEN     C=(10,00),K='DCI=NON-DISP'                      @BM13311\n  DFHTUTEN     C=(13,00),K='DCI=TERMINAL'                      @BM13311\n  DFHTUTEN     C=(20,00),K='DCI=DISP'                          @BM10700\n  DFHTUTEN     C=(40,00),K='DCI=LIST'                          @BM10700\n  DFHTUTEN     C=(43,00),K='DCI=IOEVENT'                    @17307 @P3A\n  DFHTUTEN     C=(44,00),K='DCI=TCP'                        @17307 @P3A\n  DFHTUTEN     C=(80,00),K='DCI=SINGLE'                        @BM10700\n  DFHTUTEN     C=(88,00),K='DCI=CICS'                          @BM10700\n  DFHTUTEN     C=(89,00),K='DCI=FAM'                           @BM10700\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10700\nTUTB2F0E EQU   *                                            @17307 @P3A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT           @17307 @P3A\n  DFHTUTEN     C=(10,00),K='NON-DISPATCHABLE'               @17307 @P3A\n  DFHTUTEN     C=(13,00),K='TERMINAL WAIT'                  @17307 @P3A\n  DFHTUTEN     C=(16,00),K='ICP RETRIEVE WAIT'              @17307 @P3A\n  DFHTUTEN     C=(18,00),K='STORAGE CONTROL'                @17307 @P3A\n  DFHTUTEN     C=(19,00),K='ICP DELAY'                      @17307 @P3A\n  DFHTUTEN     C=(1C,00),K='TEMPORARY STORAGE'              @17307 @P3A\n  DFHTUTEN     C=(FF,FF),K=                                 @17307 @P3A\nTUTB2F0C EQU   *                                                   @LLA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT                  @LLA\n  DFHTUTEN     C=(01,00),K='REPLACE'                               @LLA\n  DFHTUTEN     C=(02,00),K='INITIALIZE'                            @LLA\n  DFHTUTEN     C=(03,00),K='WAITINIT'                              @LLA\n  DFHTUTEN     C=(04,00),K='RESTART TASK'                          @LLA\n  DFHTUTEN     C=(FF,FF),K=                                        @LLA\n*                                                                     *\nTUTB2F1D EQU   *                   SCP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=F1C,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(00,00),K=' ',NX=F10                       @EG00X @L2A\n  DFHTUTEN     C=(20,00),K='CUSHION CHANGE'                    @BD910JY\n  DFHTUTEN     C=(40,00),K='FREEMAIN'                          @BD910JY\n  DFHTUTEN     C=(60,00),K='FREEMAIN ALL'                      @BD910JY\n  DFHTUTEN     C=(80,00),K='GETMAIN'                           @BD910JY\n  DFHTUTEN     C=(A0,00),K='GETMAIN CONDITIONAL'               @BD910JY\n  DFHTUTEN     C=(C0,00),K='GETMAIN INITIMG'                   @BD910JY\n  DFHTUTEN     C=(E0,00),K='GETMAIN CONDITIONAL INITIMG'       @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\nTUTB2F10 EQU   *                                            @EG00X @L2A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,NX=SRT                 @EG00X @L2A\n  DFHTUTEN     C=(20,00),K='CUSHION CHANGE'                 @EG00X @L2A\n  DFHTUTEN     C=(40,00),K='FREEMAIN'                       @EG00X @L2A\n  DFHTUTEN     C=(60,00),K='FREEMAIN ALL'                   @EG00X @L2A\n  DFHTUTEN     C=(80,00),K='GETMAIN'                        @EG00X @L2A\n  DFHTUTEN     C=(90,00),K='GETMAIN ANY'                    @EG00X @L2A\n  DFHTUTEN     C=(A0,00),K='GETMAIN CONDITIONAL'            @EG00X @L2A\n  DFHTUTEN     C=(B0,00),K='GETMAIN CONDITIONAL ANY'        @EG00X @L2A\n  DFHTUTEN     C=(C0,00),K='GETMAIN INITIMG'                @EG00X @L2A\n  DFHTUTEN     C=(D0,00),K='GETMAIN INITIMG ANY'            @EG00X @L2A\n  DFHTUTEN     C=(E0,00),K='GETMAIN CONDITIONAL INITIMG'    @EG00X @L2A\n  DFHTUTEN     C=(F0,00),K='GETMAIN CONDITIONAL INITIMG ANY'       @L2A\n  DFHTUTEN     C=(FF,FF),K=                                 @EG00X @L2A\n*                                                                     *\nTUTB2F2D EQU   *                   PCP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLC,OFF=R0,E=F2C,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(01,00),K='LINK'                              @BD910JY\n  DFHTUTEN     C=(02,00),K='XCTL'                              @BD910JY\n  DFHTUTEN     C=(03,00),K='CTYPE LOCATE'                   @EU71T @L2A\n  DFHTUTEN     C=(03,10),K='CTYPE BROWSE'                   @EU71T @L2A\n  DFHTUTEN     C=(03,20),K='CTYPE LOCATE NOWAIT'            @EU71T @L2A\n  DFHTUTEN     C=(03,50),K='CTYPE BROWSE UNLOCK'            @EU71T @L2A\n  DFHTUTEN     C=(04,00),K='LOAD'                              @BD910JY\n  DFHTUTEN     C=(05,10),K='CTYPE REPLACE'                  @EU71T @L2A\n  DFHTUTEN     C=(05,20),K='CTYPE INITIALIZE'                      @LLA\n  DFHTUTEN     C=(05,30),K='CTYPE WAITINIT'                        @LLA\n  DFHTUTEN     C=(08,00),K='DELETE'                            @BD910JY\n  DFHTUTEN     C=(10,00),K='RETURN'                            @BD910JY\n  DFHTUTEN     C=(12,00),K='RETRY'                             @BBAI20Y\n  DFHTUTEN     C=(20,00),K='SETXIT,CANCEL'                     @BD910JY\n  DFHTUTEN     C=(20,10),K='SETXIT,PROGRAM'                    @BD910JY\n  DFHTUTEN     C=(20,20),K='SETXIT,ROUTINE'                    @BD910JY\n  DFHTUTEN     C=(20,40),K='BLDL'                              @BD910JY\n  DFHTUTEN     C=(20,80),K='RESETXIT'                          @BD910JY\n  DFHTUTEN     C=(24,00),K='LOAD,LOADLST=NO'                       @LMC\n  DFHTUTEN     C=(40,00),K='ABEND'                             @BD910JY\n  DFHTUTEN     C=(41,00),K='ABEND,CANCEL=YES'                  @BD910JY\n  DFHTUTEN     C=(44,00),K='LOAD RMODE(ANY)'                @EG00X @L2A\n  DFHTUTEN     C=(60,00),K='ABEND'                             @BD910JY\n  DFHTUTEN     C=(61,00),K='ABEND,CANCEL=YES'                  @BD910JY\n  DFHTUTEN     C=(64,00),K='LOAD,LOADLST=NO RMODE(ANY)'            @LMA\n  DFHTUTEN     C=(81,00),K='LINK-CONDITIONAL'                  @BD910JY\n  DFHTUTEN     C=(82,00),K='LOCATE'                            @BD910JY\n  DFHTUTEN     C=(84,00),K='LOAD-CONDITIONAL'                  @BD910JY\n  DFHTUTEN     C=(88,00),K='XCTL-CONDITIONAL'               @EU71B @L3A\n  DFHTUTEN     C=(A4,00),K='LOAD-CONDNL,LOADLST=NO'                @LMC\n  DFHTUTEN     C=(C4,00),K='LOAD-CONDNL RMODE(ANY)'                @LMA\n  DFHTUTEN     C=(E4,00),K='LOAD-CONDNL,LOADLST=NO RMODE(ANY)'     @LMA\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2F3D EQU   *                   ICP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=F3C,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(10,00),K='GETIME'                            @BD910JY\n* DFHTUTEN     C=(10,01),K='GETIME PACKED'                     @BD910JY\n* DFHTUTEN     C=(10,02),K='GETIME USER BINARY'                @BD910JY\n* DFHTUTEN     C=(10,03),K='GETIME USER PACKED'                @BD910JY\n  DFHTUTEN     C=(20,00),K='WAIT'                              @BD910JY\n  DFHTUTEN     C=(30,00),K='POST'                              @BD910JY\n  DFHTUTEN     C=(40,00),K='INITIATE'                          @BD910JY\n  DFHTUTEN     C=(50,00),K='PUT'                               @BD910JY\n  DFHTUTEN     C=(60,00),K='INITIATE'                              @P6C\n  DFHTUTEN     C=(70,00),K='PUT HEADER'                        @BBCI70Y\n  DFHTUTEN     C=(80,00),K='GET'                               @BD910JY\n  DFHTUTEN     C=(90,00),K='RETRY'                             @BD910JY\n  DFHTUTEN     C=(A0,00),K='RESET'                             @BD910JY\n  DFHTUTEN     C=(B0,00),K='SCHEDULE'                          @BM13793\n  DFHTUTEN     C=(C0,00),K='ICE EXPIRY ANALYSIS'                   @LMA\n  DFHTUTEN     C=(D0,00),K='RECOVERY'                          @BM13793\n  DFHTUTEN     C=(F0,00),K='CANCEL'                            @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2F3E EQU   *                   ICP RETURN                  @BBCI70Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBCI70Y\n  DFHTUTEN     C=(00,00),K='NORMAL'                            @BBCI70Y\n  DFHTUTEN     C=(01,00),K='ENDDATA'                           @BBCI70Y\n  DFHTUTEN     C=(04,00),K='IOERROR'                           @BBCI70Y\n  DFHTUTEN     C=(11,00),K='TRNIDER'                           @BBCI70Y\n  DFHTUTEN     C=(12,00),K='TRMIDER'                           @BBCI70Y\n  DFHTUTEN     C=(14,00),K='TSINVLD'                           @BBCI70Y\n  DFHTUTEN     C=(20,00),K='EXPIRD'                            @BBCI70Y\n  DFHTUTEN     C=(81,00),K='NOTFND'                            @BBCI70Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBCI70Y\n*                                                                     *\nTUTB2F4D EQU   *                   DCP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLC,OFF=R0,E=F4C,NX=F4F              @BBAI20Y\n  DFHTUTEN     C=(00,FF),K='CICS'                              @BBAA12Y\n  DFHTUTEN     C=(FE,FF),K='COMPLETE'                          @BM10631\n  DFHTUTEN     C=(FE,00),K='TRANSACTION'                       @BM10631\n* DFHTUTEN     C=(10,00),K='SUPTRACE'                          @BBAA12Y\n* DFHTUTEN     C=(30,00),K='SUPTCA'                            @BBAA12Y\n* DFHTUTEN     C=(40,00),K='SUPCSA'                            @BBAA12Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\nTUTB2F4F EQU   *                                               @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=SRT               @BD910JY\n  DFHTUTEN     C=(01),K='PRTDCT'                               @BD910JY\n  DFHTUTEN     C=(02),K='PRTFCT'                               @BM10989\n  DFHTUTEN     C=(04),K='PRTTCT'                               @BD910JY\n  DFHTUTEN     C=(08),K='PRTPCT'                               @BD910JY\n  DFHTUTEN     C=(20),K='PRTPPT'                               @BD910JY\n  DFHTUTEN     C=(40),K='PRTSIT'                               @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\n*                                                                     *\nTUTB2F5D EQU   *                   FCP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(00,00),K='DWE PROCESSOR'                     @BM10519\n  DFHTUTEN     C=(01,00),K='DELETE'                            @BD910JY\n  DFHTUTEN     C=(02,00),K='CTYPE OPEN'                            @LUA\n  DFHTUTEN     C=(03,00),K='CTYPE IMPLICIT OPEN'                   @LUA\n  DFHTUTEN     C=(04,00),K='CTYPE MAKE USER'                       @LUA\n  DFHTUTEN     C=(05,00),K='CTYPE CLOSE'                           @LUA\n  DFHTUTEN     C=(06,00),K='CTYPE CLOSE'                           @LUA\n  DFHTUTEN     C=(07,00),K='CTYPE CLOSE'                           @LUA\n  DFHTUTEN     C=(08,00),K='CTYPE CLOSE'                           @LUA\n  DFHTUTEN     C=(09,00),K='CTYPE ENABLE'                          @LUA\n  DFHTUTEN     C=(0A,00),K='CTYPE DISABLE'                         @LUA\n  DFHTUTEN     C=(0B,00),K='CTYPE TEST USER'                       @LUA\n  DFHTUTEN     C=(0C,00),K='DFHFCM OPEN'                           @LUA\n  DFHTUTEN     C=(0D,00),K='DFHFCM CLOSE'                          @LUA\n  DFHTUTEN     C=(0E,00),K='DFHFCN OPEN'                           @LUA\n  DFHTUTEN     C=(0F,00),K='DFHFCN CLOSE'                          @LUA\n  DFHTUTEN     C=(10,00),K='RELEASE'                           @BD910JY\n  DFHTUTEN     C=(11,00),K='ESETL'                             @BD910JY\n  DFHTUTEN     C=(20,00),K='GETAREA'                               @LUA\n  DFHTUTEN     C=(24,00),K='GETAREA MASS INSERT'                   @LUA\n  DFHTUTEN     C=(28,00),K='GETAREA INIT'                          @LUC\n  DFHTUTEN     C=(2C,00),K='GETAREA MASS INSERT INIT'              @LUC\n  DFHTUTEN     C=(40,00),K='PUT'                               @BD910JY\n  DFHTUTEN     C=(41,00),K='PUT-DELETE'                        @BD910JY\n  DFHTUTEN     C=(44,00),K='PUT-NEW'                           @BD910JY\n  DFHTUTEN     C=(80,00),K='GET'                               @BD910JY\n  DFHTUTEN     C=(81,00),K='GET'                               @BD910JY\n  DFHTUTEN     C=(84,00),K='GET-UPDATE'                        @BD910JY\n  DFHTUTEN     C=(85,00),K='GET-UPDATE'                            @LMC\n  DFHTUTEN     C=(A0,00),K='SETL'                              @BD910JY\n  DFHTUTEN     C=(A1,00),K='SETL'                                  @LUA\n  DFHTUTEN     C=(A4,00),K='RESETL'                            @BD910JY\n  DFHTUTEN     C=(B0,00),K='GETNEXT'                           @BM10771\n  DFHTUTEN     C=(B4,00),K='GETPREV'                           @BM10771\n  DFHTUTEN     C=(F0,00),K='CTYPE SET'                             @LUC\n  DFHTUTEN     C=(F1,00),K='CTYPE LOCATE'                   @EU71B @L3A\n  DFHTUTEN     C=(F4,00),K='CTYPE BROWSE'                          @LMC\n  DFHTUTEN     C=(F5,00),K='CTYPE INITIALIZE'                      @LUA\n  DFHTUTEN     C=(F6,00),K='CTYPE WAITINIT'                        @LUA\n  DFHTUTEN     C=(F7,00),K='CTYPE RESTART'                         @LUA\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2F5E EQU   *                   FCP RETURN                  @BBCI70Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBCI70Y\n  DFHTUTEN     C=(00,00),K='NORMAL'                            @BBCI70Y\n  DFHTUTEN     C=(01,00),K='DSIDER'                            @BBCI70Y\n  DFHTUTEN     C=(02,00),K='ILLOGIC'                           @BBCI70Y\n  DFHTUTEN     C=(08,00),K='INVREQ'                            @BBCI70Y\n  DFHTUTEN     C=(0C,00),K='NOTOPEN'                           @BBCI70Y\n  DFHTUTEN     C=(0F,00),K='ENDFILE'                           @BBCI70Y\n  DFHTUTEN     C=(20,00),K='ERROR'                                 @LUA\n  DFHTUTEN     C=(40,00),K='DFHFCN/M NORMAL'                       @LUC\n  DFHTUTEN     C=(41,00),K='DFHFCN/M WARNING'                      @LUC\n  DFHTUTEN     C=(42,00),K='DFHFCN/M ERROR'                        @LUC\n  DFHTUTEN     C=(80,00),K='IOERROR'                           @BBCI70Y\n  DFHTUTEN     C=(81,00),K='NOTFND'                            @BBCI70Y\n  DFHTUTEN     C=(82,00),K='DUPREC'                            @BBCI70Y\n  DFHTUTEN     C=(83,00),K='NOSPACE'                           @BBCI70Y\n  DFHTUTEN     C=(84,00),K='DUPKEY'                            @BBCI70Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBCI70Y\n*                                                                     *\nTUTB2F6D EQU   *                   TDP                         @BBCI70Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R1,E=DFT,NX=SRT           @E131U @LCA\n  DFHTUTEN     C=(03,00),K='APPL REQ',NX=F6B                @E131U @LCA\n  DFHTUTEN     C=(13,00),K='START CANCEL LOGIC'             @E131U @LCA\n  DFHTUTEN     C=(23,00),K='START I/O ERROR LOGIC'          @E131U @LCA\n  DFHTUTEN     C=(33,00),K='START INIT PHASE 2 LOGIC'              @LOC\n  DFHTUTEN     C=(43,00),K='START INIT PHASE 1 LOGIC'              @LOA\n  DFHTUTEN     C=(FF,FF),K=                                 @E131U @LCA\nTUTB2F6B EQU   *                                            @E131U @LCA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(04,00),K='PURGE'                          @E131U @LCA\n  DFHTUTEN     C=(0C,00),K='PURGE ADDR=YES'                 @E131U @LCA\n  DFHTUTEN     C=(10,00),K='LOCATE'                         @E131U @LCA\n  DFHTUTEN     C=(20,00),K='FEOV'                           @E131U @LCA\n  DFHTUTEN     C=(28,00),K='FEOV ADDR=YES'                  @E131U @LCA\n  DFHTUTEN     C=(40,00),K='PUT'                            @E131U @LCA\n  DFHTUTEN     C=(48,00),K='PUT ADDR=YES'                   @E131U @LCA\n  DFHTUTEN     C=(80,00),K='GET'                            @E131U @LCA\n  DFHTUTEN     C=(88,00),K='GET ADDR=YES'                   @E131U @LCA\n  DFHTUTEN     C=(C0,00),K='GET CONDITIONAL'                @E131U @LCA\n  DFHTUTEN     C=(C8,00),K='GET CONDITIONAL ADDR=YES'       @E131U @LCA\n  DFHTUTEN     C=(E1,00),K='CTYPE LOCATE'                   @EU71B @L3A\n  DFHTUTEN     C=(E4,00),K='CTYPE BROWSE'                   @EU71B @L3A\n  DFHTUTEN     C=(F0,00),K='CTYPE INITIALIZE'                      @LOA\n  DFHTUTEN     C=(F1,00),K='CTYPE WAITINIT'                        @LOA\n  DFHTUTEN     C=(F2,00),K='CTYPE FLUSH'                           @LOA\n  DFHTUTEN     C=(F3,00),K='CTYPE PROCESS-DWE'                     @LOC\n  DFHTUTEN     C=(F4,00),K='CTYPE RECOVER'                         @LOA\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2F6E EQU   *                   TDP RETURN                  @BBCI70Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R1,E=DFT,NX=SRT           @E131U @LCA\n  DFHTUTEN     C=(05,00),K='APPL RESP',NX=F6C               @E131U @LCA\n  DFHTUTEN     C=(15,00),K='END CANCEL LOGIC'               @E131U @LCA\n  DFHTUTEN     C=(25,00),K='END I/O ERROR LOGIC'            @E131U @LCA\n  DFHTUTEN     C=(35,00),K='END INIT PHASE 2 LOGIC'                @LOC\n  DFHTUTEN     C=(45,00),K='END INIT PHASE 1 LOGIC'                @LOA\n  DFHTUTEN     C=(FF,FF),K=                                 @E131U @LCA\nTUTB2F6C EQU   *                                            @E131U @LCA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBCI70Y\n  DFHTUTEN     C=(00,00),K='NORMAL'                            @BBCI70Y\n  DFHTUTEN     C=(01,00),K='QUEZERO'                           @BBCI70Y\n  DFHTUTEN     C=(02,00),K='IDERROR'                           @BBCI70Y\n  DFHTUTEN     C=(04,00),K='IOERROR'                           @BBCI70Y\n  DFHTUTEN     C=(08,00),K='NOTOPEN'                           @BBCI70Y\n  DFHTUTEN     C=(10,00),K='NOSPACE'                           @BBCI70Y\n  DFHTUTEN     C=(40,00),K='INVALID CHAIN'                  @E131U @LCA\n  DFHTUTEN     C=(C0,00),K='QUEBUSY'                        @E131U @LCA\n  DFHTUTEN     C=(FF,FF),K=                                    @BBCI70Y\n*                                                                     *\nTUTB2F7D EQU   *                   TSP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R1,E=F7C,NX=SRT           @E121U @LDA\n  DFHTUTEN     C=(03,00),K='APPL REQ',NX=F7F                @E121U @LDA\n  DFHTUTEN     C=(13,00),K='START DWE LOGIC'                @E121U @LDA\n  DFHTUTEN     C=(23,00),K='START CANCEL LOGIC'             @E121U @LDA\n  DFHTUTEN     C=(FF,FF),K=                                 @E121U @LDA\nTUTB2F7F EQU   *                                            @E121U @LDA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=F7C,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(02,00),K='FLUSH'                             @BD910JY\n  DFHTUTEN     C=(20,00),K='RELEASE'                           @BD910JY\n  DFHTUTEN     C=(21,00),K='PURGEQ'                            @BD910JY\n  DFHTUTEN     C=(22,00),K='RELEASE-FLUSH'                     @BD910JY\n  DFHTUTEN     C=(23,00),K='PURGE-FLUSH'                       @BD910JY\n  DFHTUTEN     C=(40,00),K='PUT'                               @BD910JY\n  DFHTUTEN     C=(41,00),K='PUTQ'                              @BD910JY\n  DFHTUTEN     C=(42,00),K='PUT SYSTEM'                        @BM10857\n  DFHTUTEN     C=(43,00),K='PUTQ SYSTEM'                       @BBAI20Y\n  DFHTUTEN     C=(44,00),K='PUT-REPLACE'                       @BD910JY\n  DFHTUTEN     C=(45,00),K='PUTQ-REPLACE'                      @BD910JY\n  DFHTUTEN     C=(46,00),K='PUT-REPLACE SYS'                   @BD910JY\n  DFHTUTEN     C=(47,00),K='PUTQ-REPLACE-SYS'                  @BD910JY\n  DFHTUTEN     C=(80,00),K='GET'                               @BD910JY\n  DFHTUTEN     C=(81,00),K='GETQ'                              @BBAI20Y\n  DFHTUTEN     C=(82,00),K='GET STORCLS=TERM'                  @BBAI20Y\n  DFHTUTEN     C=(83,00),K='GETQ STORCLS=TERM'                 @BBAI20Y\n  DFHTUTEN     C=(84,00),K='GET EXCLUSIVE'                     @BBAI20Y\n  DFHTUTEN     C=(85,00),K='GETQ EXCLUSIVE'                    @BBAI20Y\n  DFHTUTEN     C=(86,00),K='GETQ EXCLUSIVE'                    @BBAI20Y\n  DFHTUTEN     C=(87,00),K='GETQ EXCLUSIVE STORCLS=TERM'       @BBAI20Y\n  DFHTUTEN     C=(A0,00),K='GET-RELEASE'                       @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2F7E EQU   *                   TSP RETURN                  @BBCI70Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R1,E=DFT,NX=SRT           @E121U @LDA\n  DFHTUTEN     C=(05,00),K='APPL RESP',NX=F7G               @E121U @LDA\n  DFHTUTEN     C=(15,00),K='END DWE LOGIC'                  @E131U @LCA\n  DFHTUTEN     C=(25,00),K='END CANCEL LOGIC'               @E131U @LCA\n  DFHTUTEN     C=(FF,FF),K=                                 @E121U @LDA\nTUTB2F7G EQU   *                                            @E121U @LDA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBCI70Y\n  DFHTUTEN     C=(00,00),K='NORMAL'                            @BBCI70Y\n  DFHTUTEN     C=(02,00),K='IDERROR'                           @BBCI70Y\n  DFHTUTEN     C=(04,00),K='IOERROR'                           @BBCI70Y\n  DFHTUTEN     C=(20,00),K='INVREQ'                            @BBCI70Y\n  DFHTUTEN     C=(01,00),K='ENTRY ERROR'                       @BM12042\n  DFHTUTEN     C=(08,00),K='NOSPACE'                           @BBCI70Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBCI70Y\n*                                                              @BA40668\nTUTB2F7H EQU   *                   TSP FE                      @BA40668\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BA40668\n  DFHTUTEN     C=(01),K='COMPRESS CI'                          @BA40668\n  DFHTUTEN     C=(02),K='READ CI'                              @BA40668\n  DFHTUTEN     C=(03),K='WRITE CI'                             @BA40668\n  DFHTUTEN     C=(04),K='BUFFER INFORMATION'                   @BA40668\n  DFHTUTEN     C=(FF,FF),K=                                    @BA40668\n*                                                                     *\nTUTB2F8D EQU   *                   DL/I                     @E8D08 @M1A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT           @E8D08 @M1A\n  DFHTUTEN     C=(01),K='IWAIT'                             @E8D08 @M1A\n  DFHTUTEN     C=(FF,FF),K=                                 @E8D08 @M1A\n*                                                                     *\nTUTB2F8E EQU   *                   DL/I RETURN                 @BBCI70Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBCI70Y\n  DFHTUTEN     C=(01,00),K='PSB NOTFND'                        @BBCI70Y\n  DFHTUTEN     C=(02,00),K='TASKNA'                            @BBCI70Y\n  DFHTUTEN     C=(03,00),K='PSBSCH'                            @BBCI70Y\n  DFHTUTEN     C=(04,00),K='LANGCON'                           @BBCI70Y\n  DFHTUTEN     C=(05,00),K='PSBFAIL'                           @BBCI70Y\n  DFHTUTEN     C=(06,00),K='PSBNA'                             @BBCI70Y\n  DFHTUTEN     C=(07,00),K='TERMNS'                            @BBCI70Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBCI70Y\n*                                                                     *\nTUTB2F9D EQU   *                   JCP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(01,00),K='WRITE'                             @BD910JY\n  DFHTUTEN     C=(02,00),K='WAIT'                              @BD910JY\n  DFHTUTEN     C=(03,00),K='PUT'                               @BD910JY\n  DFHTUTEN     C=(04,00),K='OPEN'                              @BD910JY\n  DFHTUTEN     C=(08,00),K='CLOSE'                             @BD910JY\n  DFHTUTEN     C=(10,00),K='NOTE'                              @BD910JY\n  DFHTUTEN     C=(20,00),K='POINT'                             @BD910JY\n  DFHTUTEN     C=(40,00),K='GETF'                              @BD910JY\n  DFHTUTEN     C=(80,00),K='GETB'                              @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2F9E EQU   *                   JCP RETURN                      @P5A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT                  @P5C\n  DFHTUTEN     C=(00,00),K='NORMAL'                                @P5A\n  DFHTUTEN     C=(01,00),K='IDERROR'                               @P5A\n  DFHTUTEN     C=(02,00),K='INVREQ'                                @P5A\n  DFHTUTEN     C=(03,00),K='STATERR'                               @P5A\n  DFHTUTEN     C=(04,00),K='VOLERR'   IN CG, NOT APRM              @P5A\n  DFHTUTEN     C=(05,00),K='NOTOPEN'                               @P5A\n  DFHTUTEN     C=(06,00),K='LERROR'                                @P5A\n  DFHTUTEN     C=(07,00),K='IOERROR'                               @P5A\n  DFHTUTEN     C=(08,00),K='END OF DATA SET'                       @P5A\n  DFHTUTEN     C=(09,00),K='INSUFFICIENT BUFFER SPACE'  NOJBUFSP   @P5A\n  DFHTUTEN     C=(0A,00),K='DYNAMIC LOG ERROR'                     @P5A\n  DFHTUTEN     C=(FF,FF),K=                                        @P5A\n*                                                                     *\nTUTB2FAD EQU   *                   BMS                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BA54059\n  DFHTUTEN     C=(00),K=' ',NX=FAX                                 @LSA\n*  BMS SECONDARY MODULE ENTRIES                                       *\n  DFHTUTEN     C=(01),K='RLR ENTRY'                            @BA54059\n  DFHTUTEN     C=(02),K='PBP ENTRY'                            @BA54059\n  DFHTUTEN     C=(03),K='M32 ENTRY'                            @BA54059\n  DFHTUTEN     C=(04),K='ML1 ENTRY'                            @BA54059\n  DFHTUTEN     C=(05),K='DSB ENTRY'                            @BA54059\n  DFHTUTEN     C=(06),K='TPP ENTRY'                            @BA54059\n  DFHTUTEN     C=(07),K='IIP ENTRY'                            @BA54059\n  DFHTUTEN     C=(41),K='RLR EXIT'                             @BA54059\n  DFHTUTEN     C=(42),K='PBP EXIT'                             @BA54059\n  DFHTUTEN     C=(43),K='M32 EXIT'                             @BA54059\n  DFHTUTEN     C=(44),K='ML1 EXIT'                             @BA54059\n  DFHTUTEN     C=(45),K='DSB EXIT'                             @BA54059\n  DFHTUTEN     C=(46),K='TPP EXIT'                             @BA54059\n  DFHTUTEN     C=(47),K='IIP EXIT'                             @BA54059\n*  SPECIAL CASE FOR QUERY ENTRIES                                     *\n  DFHTUTEN     C=(81),K='QUERY'                                @BA54059\n  DFHTUTEN     C=(82),K='QUERY CONTINUED'                      @BA54059\n  DFHTUTEN     C=(FF,FF),K=                                        @LSA\nTUTB2FAX EQU  *    NORMAL BMS ENTRIES                              @LSA\n  DFHTUTEN     T=(2,I),CP=TM,OFF=B0,E=DFT,NX=FAZ               @BM10519\n  DFHTUTEN     C=(80),K='PAGEBLD'                              @BM10519\n  DFHTUTEN     C=(40),K='OFLOW'                                @BM10519\n  DFHTUTEN     C=(20),K='ERASEAUP'                             @BM10519\n  DFHTUTEN     C=(04),K='SEND-OUT'                             @BM10519\n  DFHTUTEN     C=(02),K='STORE'                                @BM10519\n  DFHTUTEN     C=(01),K='RETURN'                               @BM10519\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10519\nTUTB2FAZ EQU   *                                               @BM10519\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=FAY               @BM10519\n  DFHTUTEN     C=(80),K='ROUTE'                                @BBAI20Y\n  DFHTUTEN     C=(10),K='INTERVAL'                             @BBAI20Y\n  DFHTUTEN     C=(08),K='TIME'                                 @BBAI20Y\n  DFHTUTEN     C=(04),K='LIST=ALL'                             @BM10519\n  DFHTUTEN     C=(02),K='LIST'                                 @BBAI20Y\n  DFHTUTEN     C=(01),K='OPCLASS'                              @BBAI20Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\nTUTB2FAY EQU   *                                               @BM10519\n  DFHTUTEN     T=(2,I),CP=TM,OFF=B1,E=DFT,NX=FAG               @BM10519\n  DFHTUTEN     C=(80),K='PAGEOUT'                              @BM10519\n  DFHTUTEN     C=(40),K='AUTOPAGE'                             @BM10519\n  DFHTUTEN     C=(20),K='PAGE'                                 @BM10519\n  DFHTUTEN     C=(10),K='RETAIN'                               @BM10519\n  DFHTUTEN     C=(08),K='RELEASE'                              @BM10519\n  DFHTUTEN     C=(01),K='EODPURG'                              @BM10519\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10519\nTUTB2FAG EQU   *                                               @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FAH               @BBAI20Y\n  DFHTUTEN     C=(80),K='TITLE'                                @BM10519\n  DFHTUTEN     C=(20),K='REQID'                                @BM10519\n  DFHTUTEN     C=(01),K='PURGE'                                @BM10519\n  DFHTUTEN     C=(40),K='PROPT'                                @BM10771\n  DFHTUTEN     C=(10),K='LDC'                                  @BM10771\n  DFHTUTEN     C=(04),K='SEND-PARTNSET'                     @E5E2C @H1C\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\nTUTB2FAH EQU   *                                               @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=FAI               @BBAI20Y\n  DFHTUTEN     C=(80),K='LAST'                                 @BM10519\n  DFHTUTEN     C=(40),K='RECEIVE-PARTN'                     @E5E2C @H1C\n  DFHTUTEN     C=(20),K='TEXT'                                 @BM10519\n  DFHTUTEN     C=(10),K='CURSOR'                               @BM10519\n  DFHTUTEN     C=(08),K='CTRL'                                 @BBAI20Y\n  DFHTUTEN     C=(04),K='MAP'                                  @BBAI20Y\n  DFHTUTEN     C=(02),K='MSETADR'                              @BBAI20Y\n  DFHTUTEN     C=(01),K='MAPSET'                               @BBAI20Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\nTUTB2FAI EQU   *                                               @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DFT,NX=FAL               @BM10519\n  DFHTUTEN     C=(20),K='SAVE'                                 @BBAI20Y\n  DFHTUTEN     C=(10),K='MAPADDR'                              @BM10519\n  DFHTUTEN     C=(08),K='WAIT'                                 @BBAI20Y\n  DFHTUTEN     C=(04),K='MAP-FROM'                             @BBAI20Y\n  DFHTUTEN     C=(02),K='ERASE'                                @BBAI20Y\n  DFHTUTEN     C=(01),K='IN'                                   @BBAI20Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\nTUTB2FAL EQU   *                                               @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=B2,E=DFT,NX=FAM                   @LMC\n  DFHTUTEN     C=(80),K='TXTBLD'                               @BBAI20Y\n  DFHTUTEN     C=(40),K='HEADER'                               @BBAI20Y\n  DFHTUTEN     C=(20),K='TRAILER'                              @BBAI20Y\n  DFHTUTEN     C=(10),K='JUSTIFY'                              @BBAI20Y\n  DFHTUTEN     C=(08),K='OUTPARTN'                          @E5E2C @H1C\n  DFHTUTEN     C=(04),K='ACTPARTN'                          @E5E2C @H1C\n  DFHTUTEN     C=(01),K='NOEDIT'                               @BBAI20Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10519\nTUTB2FAM EQU   *                                                   @LMC\n  DFHTUTEN     T=(2,I),CP=TM,OFF=B3,E=DFT,NX=SRT            @E5E2C @H1C\n  DFHTUTEN     C=(80),K='INPARTN'                           @E5E2C @H1C\n  DFHTUTEN     C=(40),K='MSR'                               @E5E5C @H2C\n  DFHTUTEN     C=(01),K='CONTROL'                           @E5E5C @H2C\n  DFHTUTEN     C=(FF,FF),K=                                 @E5E2C @H1C\n*                                                                     *\nTUTB2FBD EQU   *                   BIF                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(01,00),K='BITEST'                            @BD910JY\n  DFHTUTEN     C=(02,00),K='DEEDIT'                            @BD910JY\n  DFHTUTEN     C=(03,00),K='INFORMAT'                          @BD910JY\n  DFHTUTEN     C=(04,00),K='PHONETIC'                          @BD910JY\n  DFHTUTEN     C=(05,00),K='CHECK'                             @BD910JY\n  DFHTUTEN     C=(06,00),K='TSEARCH'                           @BM10771\n  DFHTUTEN     C=(07,00),K='WTRETST'                           @BD910JY\n  DFHTUTEN     C=(08,00),K='WTRTPARM'                          @BD910JY\n  DFHTUTEN     C=(09,00),K='WTRETGET'                          @BD910JY\n  DFHTUTEN     C=(0A,00),K='WTRETREL'                          @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\n*        ZCP ENTRY TABLE                                              *\nTUTB2FCD EQU   *                   ZCP                         @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(EE,00),K='EXIT TRACE',NX=FZA              @EI226 @LAC\n  DFHTUTEN     C=(01,00),K='ZARQ APPL REQ',NX=FCB              @BBAI20Y\n  DFHTUTEN     C=(02,00),K='ZLOC',NX=FCR                       @BBAI20Y\n  DFHTUTEN     C=(03,00),K='ZDET DETACH'                       @BBAI20Y\n  DFHTUTEN     C=(05,00),K='ZSUP START UP TASK'                @BBAI20Y\n  DFHTUTEN     C=(06,00),K='ZCRQ COMMAND REQS'                 @BBAI20Y\n**DFHTUTEN     C=(07,00),K='LENGTH NOT USED'                   @BBDIA0Y\n  DFHTUTEN     C=(08,00),K='ZSTU STATUS',NX=FCI                @BBDIA0Y\n  DFHTUTEN     C=(09,00),K='ZTSP TERMINAL SHARING',NX=FCT      @BBDJ20B\n  DFHTUTEN     C=(0A,00),K='RPL EXECUTOR'                      @BBAI20Y\n  DFHTUTEN     C=(0B,00),K='ZISP ISC',NX=FCL                   @BBAI20Y\n  DFHTUTEN     C=(0C,00),K='ZIS1 ISC',NX=FCM                   @BBAI20Y\n  DFHTUTEN     C=(0D,00),K='ZIS2 IRC',NX=FCN                   @BBAI20Y\n  DFHTUTEN     C=(0E,00),K='ZABD ABEND '                       @BBAI20Y\n* DFHTUTEN     C=(0F,00),K='Z*** RESERVED'                     @BBDIA0Y\n  DFHTUTEN     C=(10,00),K='ZATI A.T.I'                        @BBAI20Y\n  DFHTUTEN     C=(11,00),K='ZATT ATTACH'                       @BBAI20Y\n  DFHTUTEN     C=(12,00),K='ZFRE FREEMAIN'                     @BBAI20Y\n  DFHTUTEN     C=(13,00),K='ZGET GETMAIN'                      @BBAI20Y\n  DFHTUTEN     C=(14,00),K='ZRAC RECEIVE ANY '                 @BM10218\n  DFHTUTEN     C=(15,00),K='ZRST RESETSR'                      @BBAI20Y\n  DFHTUTEN     C=(16,00),K='ZRVS RECEIVE SPECIFIC'             @BBAI20Y\n  DFHTUTEN     C=(17,00),K='ZRVX RECEIVE EXIT'                 @BBAI20Y\n  DFHTUTEN     C=(18,00),K='ZSDS SEND'                         @BBAI20Y\n  DFHTUTEN     C=(19,00),K='ZSDX SEND DATA EXIT'               @BBAI20Y\n  DFHTUTEN     C=(1A,00),K='ZUCT TRANSLATE'                    @BBAI20Y\n  DFHTUTEN     C=(1B,00),K='ZUIX USER EXIT'                    @BBAI20Y\n  DFHTUTEN     C=(1C,00),K='ZACT ACTIVATE SCAN',NX=FZV         @BM13334\n  DFHTUTEN     C=(1D,00),K='ZSDR SEND RESPONSE'                @BBAI20Y\n  DFHTUTEN     C=(20,00),K='ZAIT ATTACH INIT'                  @BBAI20Y\n  DFHTUTEN     C=(21,00),K='ZASX ASYNC COM EXIT'               @BBAI20Y\n  DFHTUTEN     C=(22,00),K='ZCLS CLSDST'                       @BBAI20Y\n  DFHTUTEN     C=(23,00),K='ZCLX CLSDST EXIT'                  @BBAI20Y\n  DFHTUTEN     C=(24,00),K='ZDWE DWE PROCESS'                  @BBAI20Y\n  DFHTUTEN     C=(25,00),K='ZLEX LERAD EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(26,00),K='ZLGX LOGON EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(27,00),K='ZLRP LOGICAL REC PRES'             @BM10218\n  DFHTUTEN     C=(28,00),K='ZLTX LOSTERM EXIT'                 @BBAI20Y\n  DFHTUTEN     C=(29,00),K='ZOPN OPNDST'                       @BBAI20Y\n  DFHTUTEN     C=(2A,00),K='ZOPX OPNDST EXIT'                  @BBAI20Y\n  DFHTUTEN     C=(2B,00),K='ZRAQ READAHEAD QUEUING'            @BBAI20Y\n  DFHTUTEN     C=(2C,00),K='ZRAR READAHEAD RETRIEVAL'          @BM10378\n  DFHTUTEN     C=(2D,00),K='ZRPX RESPONSE EXIT *** DELETED' @EI226 @LAA\n  DFHTUTEN     C=(2E,00),K='ZRRX RELEASE REQ EXIT'             @BBAI20Y\n  DFHTUTEN     C=(2F,00),K='ZNSP NETWORK SERVICE EXIT'         @BBAI20Y\n  DFHTUTEN     C=(30,00),K='ZRSY RESYNC'                       @BBAI20Y\n  DFHTUTEN     C=(31,00),K='ZSAX SEND ASYNC EXIT'              @BBAI20Y\n  DFHTUTEN     C=(32,00),K='ZSCX SCIP EXIT'                    @BBAI20Y\n  DFHTUTEN     C=(33,00),K='ZSDA SEND ASYNC COMMAND'           @BBAI20Y\n  DFHTUTEN     C=(34,00),K='ZSKR SEND COMMAND RESPONSE'        @BBAI20Y\n  DFHTUTEN     C=(35,00),K='ZSES SESSIONC'                     @BBAI20Y\n  DFHTUTEN     C=(36,00),K='ZSEX SESSIONC EXIT'                @BBAI20Y\n  DFHTUTEN     C=(37,00),K='ZSIM SIMLOGON'                     @BBAI20Y\n  DFHTUTEN     C=(38,00),K='ZSIX SIMLOGON EXIT'                @BBAI20Y\n  DFHTUTEN     C=(39,00),K='ZSLS SETLOGON START'               @BBAI20Y\n  DFHTUTEN     C=(3A,00),K='ZSSX SEND COMMAND EXIT'            @BBAI20Y\n  DFHTUTEN     C=(3B,00),K='ZSYX SYNAD EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(3C,00),K='ZTAX TURNAROUND EXIT'              @BBAI20Y\n  DFHTUTEN     C=(3D,00),K='ZTPX TPEND EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(3E,00),K='ZOPA VTAM OPEN ACB'                @BBAI20Y\n  DFHTUTEN     C=(3F,00),K='ZSHU SHUTDOWN',NX=FCS              @BBDIA0Y\n  DFHTUTEN     C=(40,00),K='ZQUE QUEUEING'                     @BBDIA0Y\n  DFHTUTEN     C=(41,00),K='ZEMW ERROR MSG WRITER',NX=FZE      @BM13334\n  DFHTUTEN     C=(42,00),K='ZSYN SYNCPOINT',NX=FC1             @BM13334\n**DFHTUTEN     C=(43,00),K='ZTRA RPL TRACE'                    @BBDIA0Y\n  DFHTUTEN     C=(44,00),K='ZAND PC ABEND'                     @BBDIA0Y\n  DFHTUTEN     C=(45,00),K='ZCNA CONSOLE'                      @BBCIA0Y\n  DFHTUTEN     C=(46,00),K='ZCNR CONSOLE REQ'                  @BBCIA0Y\n  DFHTUTEN     C=(47,00),K='ZCNC CONSOLE ERR'                  @BBCIA0Y\n  DFHTUTEN     C=(48,00),K=' '                                 @BBDIA0Y\n  DFHTUTEN     C=(49,00),K=' '\n  DFHTUTEN     C=(4A,00),K='ZARL APPL REQ',NX=FCW           @EI00U @L6A\n  DFHTUTEN     C=(4B,00),K='ZARM MIGR REQ',NX=FCY           @EI00U @L6A\n  DFHTUTEN     C=(4C,00),K='ZRVL RECEIVE SPECIFIC'          @EI226 @LAA\n  DFHTUTEN     C=(4D,00),K='ZRLX RECEIVE EXIT'              @EI226 @LAA\n  DFHTUTEN     C=(4E,00),K='ZSDL SEND',NX=FSM               @EI00U @L6A\n  DFHTUTEN     C=(4F,00),K='ZSLX SEND EXIT'                 @EI00U @L6A\n  DFHTUTEN     C=(50,00),K='ZERH APPL ERP'                  @EI00U @L6A\n  DFHTUTEN     C=(51,00),K='ZLUS LU SERVICES',NX=FCZ        @EI00U @L6A\n  DFHTUTEN     C=(52,00),K='ZBKT',NX=FSG                    @EI226 @L8C\n  DFHTUTEN     C=(53,00),K='ZCNT',NX=FSD                    @EI226 @L8A\n  DFHTUTEN     C=(54,00),K='ZCHS',NX=FSJ                    @EI226 @L8C\n* DFHTUTEN     C=(55,00),K='Z*** RESERVED'\n  DFHTUTEN     C=(56,00),K='ZUSR',NX=FSA                    @EI226 @L8C\n* DFHTUTEN     C=(57,00),K='Z*** RESERVED'\n  DFHTUTEN     C=(58,00),K='ZEV1 ENCRYPTION VALIDATION 1'          @LNC\n  DFHTUTEN     C=(59,00),K='ZEV2 ENCRYPTION VALIDATION 2'          @LNC\n  DFHTUTEN     C=(5A,00),K='ZATD INSTALL ENTRY'                    @LTC\n  DFHTUTEN     C=(5B,00),K='ZATD INSTALL EXIT'                     @LTC\n  DFHTUTEN     C=(5C,00),K='ZATD DELETE ENTRY'                     @LTA\n  DFHTUTEN     C=(5D,00),K='ZATD DELETE EXIT'                      @LTA\n  DFHTUTEN     C=(5E,00),K='ZATD USER EXIT INSTALL'            @BA17243\n  DFHTUTEN     C=(5F,00),K='ZATD USER EXIT INSTALL RETN'       @BA17243\n  DFHTUTEN     C=(60,00),K='ZATD USER EXIT DELETE'             @BA17243\n  DFHTUTEN     C=(61,00),K='ZATD USER EXIT DELETE RETN'        @BA17243\n*              ********************************************************\n  DFHTUTEN     C=(81,00),K='ZNAC 1ST'                          @BM10771\n  DFHTUTEN     C=(82,00),K='ZNEP NEP'                          @BBAI20Y\n  DFHTUTEN     C=(83,00),K='ZNAC 2ND',NX=FC2                   @BM10771\n  DFHTUTEN     C=(84,00),K='ZRLG RESYNC SYSTEM TASK'           @BBAI20Y\n  DFHTUTEN     C=(85,00),K=' '                                 @BBAI20Y\n  DFHTUTEN     C=(86,00),K='ZGMM GOOD MORNING MSG'             @BM10771\n*              ********************************************************\n* DFHZCQ                                                              *\n  DFHTUTEN     C=(C0,00),K='DFHZCQ REQUEST ROUTER'                 @LHA\n  DFHTUTEN     C=(C1,00),K='ZCQIN INITIALIZE'                      @LHA\n  DFHTUTEN     C=(C2,00),K='ZBAN BIND ANALYSIS'                    @LHA\n  DFHTUTEN     C=(C3,00),K='ZCQCH CATALOG'                         @LHC\n  DFHTUTEN     C=(C4,00),K='ZCQDL DELETE'                          @LHA\n  DFHTUTEN     C=(C5,00),K='ZCQIT INSTALL TCTTE'                   @LHA\n  DFHTUTEN     C=(C6,00),K='ZCQRC RECOVER'                         @LHA\n  DFHTUTEN     C=(C7,00),K='ZCQRS RESTORE'                         @LHA\n  DFHTUTEN     C=(C8,00),K='ZCQIQ INQUIRE'                         @LHA\n  DFHTUTEN     C=(C9,00),K='ZCQIS INSTALL'                         @LHA\n* DFHTRZXP                                                            *\n  DFHTUTEN     C=(CA,00),K='TRZCP BUILD TERMINAL BPS'              @LHA\n  DFHTUTEN     C=(CB,00),K='TRZXP BUILD CONNECTION BPS'            @LHA\n  DFHTUTEN     C=(CC,00),K='TRZIP BUILD SESSIONS BPS'              @LHA\n  DFHTUTEN     C=(CD,00),K='TRZYP BUILD TYPE BPS'                  @LHA\n  DFHTUTEN     C=(CE,00),K='TRZPP BUILD POOL BPS'                  @LHA\n  DFHTUTEN     C=(CF,00),K='TRZZP MERGE TERMINAL AND TYPE BPS'     @LHA\n*              ********************************************************\n* DFHTBS                                                              *\n  DFHTUTEN     C=(E1,00),K='TBSB(P) BUILD'                         @LHA\n  DFHTUTEN     C=(E2,00),K='TBSSP SYNCPOINT PROCESSOR'             @LHA\n  DFHTUTEN     C=(E3,00),K='TBSD(P) DESTROY'                       @LHA\n  DFHTUTEN     C=(E4,00),K='TBSR(P) RECOVER'                       @LHA\n  DFHTUTEN     C=(E5,00),K='TBSC(P) CHANGE'                        @LHA\n  DFHTUTEN     C=(E6,00),K='TBSM MESSAGE'                          @LHC\n  DFHTUTEN     C=(E7,00),K='TBSQ(P) INQUIRE'                       @LHA\n  DFHTUTEN     C=(E8,00),K='TBSL(P) CATALOG'                       @LHA\n*              ********************************************************\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\n*                                                                     *\n*        ZCP EXIT TABLE                                               *\nTUTB2FCE EQU   *                   ZCP RETURN                  @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(EE,00),K='EXIT TRACE',NX=FZA              @EI226 @LAA\n  DFHTUTEN     C=(01,00),K='ZARQ APPL REQ',NX=FCB              @BBAI20Y\n  DFHTUTEN     C=(02,00),K='ZLOC',NX=FZK                           @LGC\n  DFHTUTEN     C=(03,00),K='ZDET DETACH'                       @BBAI20Y\n  DFHTUTEN     C=(05,00),K='ZSUP START UP TASK'                @BBAI20Y\n  DFHTUTEN     C=(06,00),K='ZCRQ COMMAND REQS'                 @BBAI20Y\n**DFHTUTEN     C=(07,00),K='LENGTH NOT USED'                   @BBDIA0Y\n  DFHTUTEN     C=(08,00),K='ZSTU STATUS',NX=FCI                @BBDIA0Y\n  DFHTUTEN     C=(09,00),K='ZTSP TERMINAL SHARING',NX=FCT      @BBDJ20B\n  DFHTUTEN     C=(0A,00),K='RPL EXECUTOR'                      @BBAI20Y\n  DFHTUTEN     C=(0B,00),K='ZISP ISC',NX=FCL                   @BBAI20Y\n  DFHTUTEN     C=(0C,00),K='ZIS1 ISC',NX=FCM                   @BBAI20Y\n  DFHTUTEN     C=(0D,00),K='ZIS2 IRC',NX=FCN                   @BBAI20Y\n  DFHTUTEN     C=(0E,00),K='ZABD ABEND '                       @BBAI20Y\n* DFHTUTEN     C=(0F,00),K='Z*** RESERVED'                     @BBDIA0Y\n  DFHTUTEN     C=(10,00),K='ZATI A.T.I'                        @BBAI20Y\n  DFHTUTEN     C=(11,00),K='ZATT ATTACH'                       @BBAI20Y\n  DFHTUTEN     C=(12,00),K='ZFRE FREEMAIN'                     @BBAI20Y\n  DFHTUTEN     C=(13,00),K='ZGET GETMAIN'                      @BBAI20Y\n  DFHTUTEN     C=(14,00),K='ZRAC RECEIVE ANY '                 @BM10218\n  DFHTUTEN     C=(15,00),K='ZRST RESETSR'                      @BBAI20Y\n  DFHTUTEN     C=(16,00),K='ZRVS RECEIVE SPECIFIC'             @BBAI20Y\n  DFHTUTEN     C=(17,00),K='ZRVX RECEIVE EXIT'                 @BBAI20Y\n  DFHTUTEN     C=(18,00),K='ZSDS SEND'                         @BBAI20Y\n  DFHTUTEN     C=(19,00),K='ZSDX SEND DATA EXIT'               @BBAI20Y\n  DFHTUTEN     C=(1A,00),K='ZUCT TRANSLATE'                    @BBAI20Y\n  DFHTUTEN     C=(1B,00),K='ZUIX USER EXIT'                    @BBAI20Y\n  DFHTUTEN     C=(1C,00),K='ZACT ACTIVATE SCAN',NX=FZV         @BM13334\n  DFHTUTEN     C=(1D,00),K='ZSDR SEND RESPONSE'                @BBAI20Y\n  DFHTUTEN     C=(20,00),K='ZAIT ATTACH INIT'                  @BBAI20Y\n  DFHTUTEN     C=(21,00),K='ZASX ASYNC COM EXIT'               @BBAI20Y\n  DFHTUTEN     C=(22,00),K='ZCLS CLSDST'                       @BBAI20Y\n  DFHTUTEN     C=(23,00),K='ZCLX CLSDST EXIT'                  @BBAI20Y\n  DFHTUTEN     C=(24,00),K='ZDWE DWE PROCESS'                  @BBAI20Y\n  DFHTUTEN     C=(25,00),K='ZLEX LERAD EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(26,00),K='ZLGX LOGON EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(27,00),K='ZLRP LOGICAL REC PRES'             @BM10218\n  DFHTUTEN     C=(28,00),K='ZLTX LOSTERM EXIT'                 @BBAI20Y\n  DFHTUTEN     C=(29,00),K='ZOPN OPNDST'                       @BBAI20Y\n  DFHTUTEN     C=(2A,00),K='ZOPX OPNDST EXIT'                  @BBAI20Y\n  DFHTUTEN     C=(2B,00),K='ZRAQ READAHEAD QUEUING'            @BBAI20Y\n  DFHTUTEN     C=(2C,00),K='ZRAR READAHEAD RETRIEVAL'          @BM10378\n  DFHTUTEN     C=(2D,00),K='ZRPX RESPONSE EXIT *** DELETED' @EI226 @LAC\n  DFHTUTEN     C=(2E,00),K='ZRRX RELEASE REQ EXIT'             @BBAI20Y\n  DFHTUTEN     C=(2F,00),K='ZNSP NETWORK SERVICE EXIT'         @BBAI20Y\n  DFHTUTEN     C=(30,00),K='ZRSY RESYNC'                       @BBAI20Y\n  DFHTUTEN     C=(31,00),K='ZSAX SEND ASYNC EXIT'              @BBAI20Y\n  DFHTUTEN     C=(32,00),K='ZSCX SCIP EXIT'                    @BBAI20Y\n  DFHTUTEN     C=(33,00),K='ZSDA SEND ASYNC COMMAND'           @BBAI20Y\n  DFHTUTEN     C=(34,00),K='ZSKR SEND COMMAND RESPONSE'        @BBAI20Y\n  DFHTUTEN     C=(35,00),K='ZSES SESSIONC'                     @BBAI20Y\n  DFHTUTEN     C=(36,00),K='ZSEX SESSIONC EXIT'                @BBAI20Y\n  DFHTUTEN     C=(37,00),K='ZSIM SIMLOGON'                     @BBAI20Y\n  DFHTUTEN     C=(38,00),K='ZSIX SIMLOGON EXIT'                @BBAI20Y\n  DFHTUTEN     C=(39,00),K='ZSLS SETLOGON START'               @BBAI20Y\n  DFHTUTEN     C=(3A,00),K='ZSSX SEND COMMAND EXIT'            @BBAI20Y\n  DFHTUTEN     C=(3B,00),K='ZSYX SYNAD EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(3C,00),K='ZTAX TURNAROUND EXIT'              @BBAI20Y\n  DFHTUTEN     C=(3D,00),K='ZTPX TPEND EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(3E,00),K='ZOPA VTAM OPEN ACB'                @BBAI20Y\n  DFHTUTEN     C=(3F,00),K='ZSHU SHUTDOWN',NX=FCS              @BBDIA0Y\n  DFHTUTEN     C=(40,00),K='ZQUE QUEUEING'                     @BBDIA0Y\n  DFHTUTEN     C=(41,00),K='ZEMW ERROR MSG WRITER',NX=FZE      @BM13334\n  DFHTUTEN     C=(42,00),K='ZSYN SYNCPOINT',NX=FC1             @BM13334\n**DFHTUTEN     C=(43,00),K='ZTRA RPL TRACE'                    @BBDIA0Y\n  DFHTUTEN     C=(44,00),K='ZAND PC ABEND'                     @BBDIA0Y\n  DFHTUTEN     C=(45,00),K='ZCNA CONSOLE'                      @BBCIA0Y\n  DFHTUTEN     C=(46,00),K='ZCNR CONSOLE REQ'                  @BBCIA0Y\n  DFHTUTEN     C=(47,00),K='ZCNC CONSOLE ERR'                  @BBCIA0Y\n  DFHTUTEN     C=(48,00),K=' '                                 @BBDIA0Y\n  DFHTUTEN     C=(49,00),K=' '\n  DFHTUTEN     C=(4A,00),K='ZARL APPL REQ',NX=FCX           @EI00U @L6A\n  DFHTUTEN     C=(4B,00),K='ZARM MIGR REQ',NX=FCY           @EI00U @L6A\n  DFHTUTEN     C=(4C,00),K='ZRVL RECEIVE SPECIFIC',NX=FSS   @EI226 @LAC\n  DFHTUTEN     C=(4D,00),K='ZRLX RECEIVE EXIT'              @EI226 @LAC\n  DFHTUTEN     C=(4E,00),K='ZSDL SEND'                      @EI00U @L6A\n  DFHTUTEN     C=(4F,00),K='ZSLX SEND EXIT'                 @EI00U @L6A\n  DFHTUTEN     C=(50,00),K='ZERH APPL ERP'                  @EI00U @L6A\n  DFHTUTEN     C=(51,00),K='ZLUS LU SERVICES',NX=FCZ        @EI00U @L6A\n  DFHTUTEN     C=(52,00),K='ZBKT',NX=FSG                    @EI226 @L8C\n  DFHTUTEN     C=(53,00),K='ZCNT',NX=FSD                    @EI226 @L8A\n  DFHTUTEN     C=(54,00),K='ZCHS',NX=FSJ                    @EI226 @L8C\n* DFHTUTEN     C=(55,00),K='Z*** RESERVED'\n  DFHTUTEN     C=(56,00),K='ZUSR',NX=FSA                    @EI226 @L8C\n* DFHTUTEN     C=(57,00),K='Z*** RESERVED'\n* DFHTUTEN     C=(58,00),K='ZEV1 ENCRYPTION VALIDATION 1'          @LNC\n* DFHTUTEN     C=(59,00),K='ZEV2 ENCRYPTION VALIDATION 2'          @LNC\n* DFHTUTEN     C=(5A,00),K='ZATD INSTALL ENTRY'                    @LTC\n* DFHTUTEN     C=(5B,00),K='ZATD INSTALL EXIT'                     @LTC\n* DFHTUTEN     C=(5C,00),K='ZATD DELETE ENTRY'                     @LTA\n* DFHTUTEN     C=(5D,00),K='ZATD DELETE EXIT'                      @LTA\n*              ********************************************************\n  DFHTUTEN     C=(81,00),K='ZNAC 1ST'                          @BM10771\n  DFHTUTEN     C=(82,00),K='ZNEP NEP'                          @BBAI20Y\n  DFHTUTEN     C=(83,00),K='ZNAC 2ND',NX=FC2                   @BM10771\n  DFHTUTEN     C=(84,00),K='ZRLG RESYNC SYSTEM TASK'           @BBAI20Y\n  DFHTUTEN     C=(85,00),K=' '                                 @BBAI20Y\n  DFHTUTEN     C=(86,00),K='ZGMM GOOD MORNING MSG'             @BM10771\n*              ********************************************************\n* DFHZCQ                                                              *\n  DFHTUTEN     C=(C0,00),K='DFHZCQ REQUEST ROUTER'                 @LHA\n  DFHTUTEN     C=(C1,00),K='ZCQIN INITIALIZE'                      @LHA\n  DFHTUTEN     C=(C2,00),K='ZBAN BIND ANALYSIS'                    @LHA\n  DFHTUTEN     C=(C3,00),K='ZCQCH CATALOG'                         @LHC\n  DFHTUTEN     C=(C4,00),K='ZCQDL DELETE'                          @LHA\n  DFHTUTEN     C=(C5,00),K='ZCQIT INSTALL TCTTE'                   @LHA\n  DFHTUTEN     C=(C6,00),K='ZCQRC RECOVER'                         @LHA\n  DFHTUTEN     C=(C7,00),K='ZCQRS RESTORE'                         @LHA\n  DFHTUTEN     C=(C8,00),K='ZCQIQ INQUIRE'                         @LHA\n  DFHTUTEN     C=(C9,00),K='ZCQIS INSTALL'                         @LHA\n* DFHTRZXP                                                            *\n  DFHTUTEN     C=(CA,00),K='TRZCP BUILD TERMINAL BPS'              @LHA\n  DFHTUTEN     C=(CB,00),K='TRZXP BUILD CONNECTION BPS'            @LHA\n  DFHTUTEN     C=(CC,00),K='TRZIP BUILD SESSIONS BPS'              @LHA\n  DFHTUTEN     C=(CD,00),K='TRZYP BUILD TYPE BPS'                  @LHA\n  DFHTUTEN     C=(CE,00),K='TRZPP BUILD POOL BPS'                  @LHA\n  DFHTUTEN     C=(CF,00),K='TRZZP MERGE TERMINAL AND TYPE BPS'     @LHA\n*              ********************************************************\n* DFHTBS                                                              *\n  DFHTUTEN     C=(E1,00),K='TBSB(P) BUILD'                         @LHA\n  DFHTUTEN     C=(E2,00),K='TBSSP SYNCPOINT PROCESSOR'             @LHA\n  DFHTUTEN     C=(E3,00),K='TBSD(P) DESTROY'                       @LHA\n  DFHTUTEN     C=(E4,00),K='TBSR(P) RECOVER'                       @LHA\n  DFHTUTEN     C=(E5,00),K='TBSC(P) CHANGE'                        @LHA\n  DFHTUTEN     C=(E6,00),K='TBSM MESSAGE'                          @LHC\n  DFHTUTEN     C=(E7,00),K='TBSQ(P) INQUIRE'                       @LHA\n  DFHTUTEN     C=(E8,00),K='TBSL(P) CATALOG'                       @LHA\n*              ********************************************************\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\n*                                                                     *\nTUTB2FZA EQU   *              ZCP EXIT TRACE ENTRY          @EI226 @LAA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FZB           @EI226 @LAA\n  DFHTUTEN     C=(17),K='ZRVX'                              @EI226 @LAA\n  DFHTUTEN     C=(19),K='ZSDX'                              @EI226 @LAA\n  DFHTUTEN     C=(21),K='ZASX'                              @EI226 @LAA\n  DFHTUTEN     C=(23),K='ZCLX'                              @EI226 @LAA\n  DFHTUTEN     C=(25),K='ZLEX'                              @EI226 @LAA\n  DFHTUTEN     C=(26),K='ZLGX'                              @EI226 @LAA\n  DFHTUTEN     C=(28),K='ZLTX'                              @EI226 @LAA\n  DFHTUTEN     C=(2A),K='ZOPX'                              @EI226 @LAA\n  DFHTUTEN     C=(2E),K='ZRRX'                              @EI226 @LAA\n  DFHTUTEN     C=(2F),K='ZNSP'                              @EI226 @LAA\n  DFHTUTEN     C=(31),K='ZSAX'                              @EI226 @LAA\n  DFHTUTEN     C=(32),K='ZSCX'                              @EI226 @LAA\n  DFHTUTEN     C=(36),K='ZSEX'                              @EI226 @LAA\n  DFHTUTEN     C=(38),K='ZSIX'                              @EI226 @LAA\n  DFHTUTEN     C=(3A),K='ZSSX'                              @EI226 @LAA\n  DFHTUTEN     C=(3B),K='ZSYX'                              @EI226 @LAA\n  DFHTUTEN     C=(3C),K='ZTAX'                              @EI226 @LAA\n  DFHTUTEN     C=(3D),K='ZTPX'                              @EI226 @LAA\n  DFHTUTEN     C=(4D),K='ZRLX'                              @EI226 @LAA\n  DFHTUTEN     C=(4F),K='ZSLX'                              @EI226 @LAA\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @LAP\n*                                                                     *\nTUTB2FZB EQU   *              ZCP EXIT TRACE ENTRY          @EI226 @LAA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=FZC           @EI226 @LAA\n  DFHTUTEN     C=(17),K='ZRVX'                              @EI226 @LAA\n  DFHTUTEN     C=(19),K='ZSDX'                              @EI226 @LAA\n  DFHTUTEN     C=(21),K='ZASX'                              @EI226 @LAA\n  DFHTUTEN     C=(23),K='ZCLX'                              @EI226 @LAA\n  DFHTUTEN     C=(25),K='ZLEX'                              @EI226 @LAA\n  DFHTUTEN     C=(26),K='ZLGX'                              @EI226 @LAA\n  DFHTUTEN     C=(28),K='ZLTX'                              @EI226 @LAA\n  DFHTUTEN     C=(2A),K='ZOPX'                              @EI226 @LAA\n  DFHTUTEN     C=(2E),K='ZRRX'                              @EI226 @LAA\n  DFHTUTEN     C=(2F),K='ZNSP'                              @EI226 @LAA\n  DFHTUTEN     C=(31),K='ZSAX'                              @EI226 @LAA\n  DFHTUTEN     C=(32),K='ZSCX'                              @EI226 @LAA\n  DFHTUTEN     C=(36),K='ZSEX'                              @EI226 @LAA\n  DFHTUTEN     C=(38),K='ZSIX'                              @EI226 @LAA\n  DFHTUTEN     C=(3A),K='ZSSX'                              @EI226 @LAA\n  DFHTUTEN     C=(3B),K='ZSYX'                              @EI226 @LAA\n  DFHTUTEN     C=(3C),K='ZTAX'                              @EI226 @LAA\n  DFHTUTEN     C=(3D),K='ZTPX'                              @EI226 @LAA\n  DFHTUTEN     C=(4D),K='ZRLX'                              @EI226 @LAA\n  DFHTUTEN     C=(4F),K='ZSLX'                              @EI226 @LAA\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @LAP\n*                                                                     *\nTUTB2FZC EQU   *              ZCP EXIT TRACE ENTRY          @EI226 @LAA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A2,E=DFT,NX=FZD           @EI226 @LAA\n  DFHTUTEN     C=(17),K='ZRVX'                              @EI226 @LAA\n  DFHTUTEN     C=(19),K='ZSDX'                              @EI226 @LAA\n  DFHTUTEN     C=(21),K='ZASX'                              @EI226 @LAA\n  DFHTUTEN     C=(23),K='ZCLX'                              @EI226 @LAA\n  DFHTUTEN     C=(25),K='ZLEX'                              @EI226 @LAA\n  DFHTUTEN     C=(26),K='ZLGX'                              @EI226 @LAA\n  DFHTUTEN     C=(28),K='ZLTX'                              @EI226 @LAA\n  DFHTUTEN     C=(2A),K='ZOPX'                              @EI226 @LAA\n  DFHTUTEN     C=(2E),K='ZRRX'                              @EI226 @LAA\n  DFHTUTEN     C=(2F),K='ZNSP'                              @EI226 @LAA\n  DFHTUTEN     C=(31),K='ZSAX'                              @EI226 @LAA\n  DFHTUTEN     C=(32),K='ZSCX'                              @EI226 @LAA\n  DFHTUTEN     C=(36),K='ZSEX'                              @EI226 @LAA\n  DFHTUTEN     C=(38),K='ZSIX'                              @EI226 @LAA\n  DFHTUTEN     C=(3A),K='ZSSX'                              @EI226 @LAA\n  DFHTUTEN     C=(3B),K='ZSYX'                              @EI226 @LAA\n  DFHTUTEN     C=(3C),K='ZTAX'                              @EI226 @LAA\n  DFHTUTEN     C=(3D),K='ZTPX'                              @EI226 @LAA\n  DFHTUTEN     C=(4D),K='ZRLX'                              @EI226 @LAA\n  DFHTUTEN     C=(4F),K='ZSLX'                              @EI226 @LAA\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @LAP\n*                                                                     *\nTUTB2FZD EQU   *              ZCP EXIT TRACE ENTRY          @EI226 @LAA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A3,E=DFT,NX=SRT           @EI226 @LAA\n  DFHTUTEN     C=(17),K='ZRVX'                              @EI226 @LAA\n  DFHTUTEN     C=(19),K='ZSDX'                              @EI226 @LAA\n  DFHTUTEN     C=(21),K='ZASX'                              @EI226 @LAA\n  DFHTUTEN     C=(23),K='ZCLX'                              @EI226 @LAA\n  DFHTUTEN     C=(25),K='ZLEX'                              @EI226 @LAA\n  DFHTUTEN     C=(26),K='ZLGX'                              @EI226 @LAA\n  DFHTUTEN     C=(28),K='ZLTX'                              @EI226 @LAA\n  DFHTUTEN     C=(2A),K='ZOPX'                              @EI226 @LAA\n  DFHTUTEN     C=(2E),K='ZRRX'                              @EI226 @LAA\n  DFHTUTEN     C=(2F),K='ZNSP'                              @EI226 @LAA\n  DFHTUTEN     C=(31),K='ZSAX'                              @EI226 @LAA\n  DFHTUTEN     C=(32),K='ZSCX'                              @EI226 @LAA\n  DFHTUTEN     C=(36),K='ZSEX'                              @EI226 @LAA\n  DFHTUTEN     C=(38),K='ZSIX'                              @EI226 @LAA\n  DFHTUTEN     C=(3A),K='ZSSX'                              @EI226 @LAA\n  DFHTUTEN     C=(3B),K='ZSYX'                              @EI226 @LAA\n  DFHTUTEN     C=(3C),K='ZTAX'                              @EI226 @LAA\n  DFHTUTEN     C=(3D),K='ZTPX'                              @EI226 @LAA\n  DFHTUTEN     C=(4D),K='ZRLX'                              @EI226 @LAA\n  DFHTUTEN     C=(4F),K='ZSLX'                              @EI226 @LAA\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @LAP\n*                                                                     *\nTUTB2FZK EQU   *              ZLOC EXIT TRACE                      @LGA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A3,E=DFT,NX=SRT                  @LGA\n  DFHTUTEN     C=(00),K='NORMAL'                                   @LGA\n  DFHTUTEN     C=(F0),K='LAST ENTRY'                               @LGA\n  DFHTUTEN     C=(F1),K='INVALID REQUEST'                          @LGA\n  DFHTUTEN     C=(F2),K='INVALID ID'                               @LGA\n  DFHTUTEN     C=(F3),K='INVALID ADDRESS'                          @LGA\n  DFHTUTEN     C=(F9),K='NOT LU6.2'                                @LGA\n  DFHTUTEN     C=(FA),K='BUSY'                                     @LGA\n  DFHTUTEN     C=(FF,FF),K=                                        @LGA\n*                                                                     *\nTUTB2FCB EQU   *              ZARQ PLIST                       @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(00,00),K=' ',NX=FCF                          @BBAI20Y\n  DFHTUTEN     C=(01,00),K='SIGNAL'                            @BM13399\n  DFHTUTEN     C=(02,00),K='WRITE',NX=FCF                      @BM13399\n  DFHTUTEN     C=(03,00),K='CONVERSE',NX=FCF                   @BM13399\n  DFHTUTEN     C=(04,00),K='READ',NX=FCF                       @BM13399\n  DFHTUTEN     C=(05,00),K='FLUSH',NX=FCF                      @BM13399\n  DFHTUTEN     C=(06,00),K='CANCEL',NX=FCF                     @BM13399\n  DFHTUTEN     C=(20,00),K='CLSDST PASS'                           @LNA\n  DFHTUTEN     C=(40,00),K='PROGRAM REQ'                       @BM13399\n  DFHTUTEN     C=(80,00),K='EOD REQ'                           @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\nTUTB2FCF EQU   *                                               @BM13399\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FCG               @BBAI20Y\n  DFHTUTEN     C=(02),K='CONVERSE'                             @BBDIA0Y\n  DFHTUTEN     C=(80),K='ERASE'                                @BBDIA0Y\n  DFHTUTEN     C=(01),K='WRITE'                                @BBAI20Y\n  DFHTUTEN     C=(10),K='READ'                                 @BM10519\n  DFHTUTEN     C=(04),K='WAIT'                                 @BM10519\n  DFHTUTEN     C=(40),K='SAVE'                                 @BM10519\n  DFHTUTEN     C=(20),K='LINEADDR'                             @BBAI20Y\n  DFHTUTEN     C=(08),K='DISC'                                 @BM10519\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\nTUTB2FCG EQU   *                                               @BM13334\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=FZG               @BM13334\n**DFHTUTEN     C=(80),K='CCOMPL=NO'                            @BM13334\n**DFHTUTEN     C=(40),K='TCTTEADDR'                            @BM13334\n  DFHTUTEN     C=(04),K='DEFER'                                @BM13334\n  DFHTUTEN     C=(20),K='COND'                                 @BM13334\n  DFHTUTEN     C=(02),K='INVITE'                               @BM13334\n  DFHTUTEN     C=(10),K='STRFIELD'                             @BM13334\n**DFHTUTEN     C=(08),K='TRANSPARENT TIOA'                     @BM13334\n**DFHTUTEN     C=(01),K=' '        RESERVED                    @BM13334\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\nTUTB2FZG EQU   *                                               @BM13334\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DFT,NX=FCQ               @BM10519\n  DFHTUTEN     C=(08),K='COPY'                                 @BM10519\n  DFHTUTEN     C=(04),K='PRINT'                                @BM10519\n  DFHTUTEN     C=(80),K='READBUF'                              @BM10519\n  DFHTUTEN     C=(40),K='ERASEUNPRO'                           @BM10519\n  DFHTUTEN     C=(01),K='PSEUDO'                               @BM10519\n  DFHTUTEN     C=(02),K='TRANSPARENT'                          @BM10519\n  DFHTUTEN     C=(10),K='READLOCK'                             @BM10519\n  DFHTUTEN     C=(20),K='WRITELOCK'                            @BM10519\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10218\n*  ALSO BRANCHED TO FROM ZIS1 DECODING                                *\nTUTB2FCQ EQU   *                                               @BM10218\n  DFHTUTEN     T=(2,I),CP=TM,OFF=B0,E=DFT,NX=SRT               @BM10218\n  DFHTUTEN     C=(08),K='LAST'                                 @BM10218\n  DFHTUTEN     C=(10),K='FMH'                                  @BM10218\n  DFHTUTEN     C=(20),K='LDC'                                  @BM10218\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10218\n*                                                                     *\nTUTB2FCR EQU   *              ZLOC PLIST                       @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FCH              @BM13334\n  DFHTUTEN     C=(01,00),K='LOC REQ',NX=FZH                    @BM13311\n  DFHTUTEN     C=(02,00),K='ATI REQ',NX=FCH                    @BM13311\n  DFHTUTEN     C=(04,00),K='STATUS REQ',NX=FCH                 @BM13311\n  DFHTUTEN     C=(08,00),K='LDC REQ',NX=FCH                    @BM13311\n  DFHTUTEN     C=(09,00),K='LDC REQ',NX=FCH                    @BM13311\n  DFHTUTEN     C=(10,00),K='LOCNETN',NX=FCH                    @BM13311\n  DFHTUTEN     C=(20,00),K='SYNC POINT REQ',NX=SRT             @BM13311\n  DFHTUTEN     C=(21,00),K='RECOVER REQ',NX=SRT                @BM13311\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13311\nTUTB2FZH EQU   *                   LOCATE REQUESTS                 @LGC\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=FCK                  @LGC\n  DFHTUTEN     C=(00),K='ADDR LOCAL'                           @BM13311\n  DFHTUTEN     C=(01),K='ID LOCAL'                             @BM13311\n  DFHTUTEN     C=(02),K='NEXT LOCAL'                           @BM13311\n  DFHTUTEN     C=(04),K='FIRST LOCAL'                          @BM13311\n  DFHTUTEN     C=(05),K='NETNAME LOCAL'                        @BM13311\n  DFHTUTEN     C=(08),K='ADDR SYSTEM'                              @LGC\n  DFHTUTEN     C=(09),K='ID SYSTEM'                                @LGC\n  DFHTUTEN     C=(0A),K='NEXT SYSTEM'                              @LGC\n  DFHTUTEN     C=(0C),K='FIRST SYSTEM'                             @LGC\n  DFHTUTEN     C=(10),K='ADDR REMOTE'                          @BM13311\n  DFHTUTEN     C=(11),K='ID REMOTE'                            @BM13311\n  DFHTUTEN     C=(12),K='NEXT REMOTE'                          @BM13311\n  DFHTUTEN     C=(13),K='UNIQUE REMOTE'                        @BM13311\n  DFHTUTEN     C=(14),K='FIRST REMOTE'                         @BM13311\n  DFHTUTEN     C=(18),K='ADDR GLOBAL'                          @BM13311\n  DFHTUTEN     C=(19),K='ID GLOBAL'                            @BM13311\n  DFHTUTEN     C=(1A),K='NEXT GLOBAL'                          @BM13311\n  DFHTUTEN     C=(1B),K='UNIQUE GLOBAL'                        @BM13311\n  DFHTUTEN     C=(1C),K='FIRST GLOBAL'                         @BM13311\n  DFHTUTEN     C=(22),K='NEXT NETNAME'                         @BM13311\n  DFHTUTEN     C=(24),K='FIRST NETNAME'                        @BM13311\n  DFHTUTEN     C=(25),K='NETNAME'                              @BM13311\n  DFHTUTEN     C=(2A),K='NEXT SESSION'                         @BM13311\n  DFHTUTEN     C=(2C),K='FIRST SESSION'                        @BM13311\n  DFHTUTEN     C=(32),K='NEXT LUCSESS'                             @LGA\n  DFHTUTEN     C=(34),K='FIRST LUCSESS'                            @LGA\n  DFHTUTEN     C=(3A),K='NEXT LUCMODE'                             @LGA\n  DFHTUTEN     C=(3C),K='FIRST LUCMODE'                            @LGA\n  DFHTUTEN     C=(41),K='ID LUC'                                   @LGA\n  DFHTUTEN     C=(46),K='SID'                                      @LGA\n  DFHTUTEN     C=(4A),K='NEXT POOL'                                @LGA\n  DFHTUTEN     C=(4C),K='FIRST POOL'                               @LGA\n  DFHTUTEN     C=(52),K='NEXT IRC'                                 @LGA\n  DFHTUTEN     C=(54),K='FIRST IRC'                                @LGA\n  DFHTUTEN     C=(5A),K='NEXT SURRG'                               @LGA\n  DFHTUTEN     C=(5C),K='FIRST SURRG'                              @LGA\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13311\nTUTB2FCK EQU   *                                                   @LGA\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT                   @LGA\n  DFHTUTEN     C=(08),K='NOWAIT'                                   @P7C\n  DFHTUTEN     C=(FF,FF),K=                                        @LGA\n*                                                                     *\nTUTB2FCH EQU   *                   ATI REQUESTS                    @LGC\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT               @BM13311\n**DFHTUTEN     C=(00),K='ADDR'                                 @BM13311\n  DFHTUTEN     C=(01),K='IDREQ'                                @BM13311\n  DFHTUTEN     C=(02),K='NEXT'                                 @BM13311\n  DFHTUTEN     C=(C0),K='GLOBAL'                               @BM13311\n  DFHTUTEN     C=(80),K='REMOTE'                               @BM13311\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13311\nTUTB2FCI EQU   *                   STATUS REQUESTS             @BM13311\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DFT,NX=FCJ               @BM13311\n  DFHTUTEN     C=(01),K='ACQUIRE'                              @BM13311\n  DFHTUTEN     C=(02),K='COLD'                                 @BM13311\n  DFHTUTEN     C=(04),K='RELEASE'                              @BM13311\n  DFHTUTEN     C=(08),K='PURGE'                                @BA25245\n  DFHTUTEN     C=(10),K='FORCE-PURGE'                          @BA25245\n  DFHTUTEN     C=(20),K='NOINTLOG'                             @BA25245\n  DFHTUTEN     C=(40),K='INTLOG'                               @BA25245\n  DFHTUTEN     C=(80),K='LUCOUT'                               @BA25245\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13311\nTUTB2FCJ EQU   *                                               @BM13311\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT               @BM13311\n  DFHTUTEN     C=(01),K='OUTSRV'                               @BM13311\n  DFHTUTEN     C=(02),K='INSRV'                                @BM13311\n  DFHTUTEN     C=(04),K='TRANS'                                @BM13311\n  DFHTUTEN     C=(08),K='TRANSCEIVE'                           @BM13311\n  DFHTUTEN     C=(10),K='RCV NOPOLL'                           @BM13311\n  DFHTUTEN     C=(20),K='INPUT AUTOPAGE'                       @BM13311\n  DFHTUTEN     C=(40),K='AUTOPAGE'                             @BM13311\n  DFHTUTEN     C=(80),K='PAGE'                                 @BM13311\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13311\nTUTB2FCL EQU   *                   ISP ENTRY                   @BM13311\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BM13311\n  DFHTUTEN     C=(01),K='ALLOCATE',NX=FZL                      @BM13311\n  DFHTUTEN     C=(02),K='POINT'                                @BM13311\n  DFHTUTEN     C=(03),K='FREE'                                 @BM13311\n  DFHTUTEN     C=(04),K='FREE DETACH'                          @BM13399\n  DFHTUTEN     C=(05),K='FREE ALL'                             @BM13399\n  DFHTUTEN     C=(06),K='LU6.2 ALLOCATE'                    @EI00U @L6A\n  DFHTUTEN     C=(07),K='LU6.2 FREE'                        @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\n*                                                                     *\nTUTB2FZL EQU   *                   ISP ENTRY                   @BM13334\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT               @BM13334\n  DFHTUTEN     C=(80),K='FREESYNC'                             @BM13334\n  DFHTUTEN     C=(40),K='FREEDET'                              @BM13334\n  DFHTUTEN     C=(20),K='FREEREST'                             @BM13334\n  DFHTUTEN     C=(10),K='UNPROT'                               @BM13334\n  DFHTUTEN     C=(08),K='Q'                                    @BM13334\n  DFHTUTEN     C=(01),K='ID'                                   @BM13334\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\n*                                                                     *\nTUTB2FCM EQU   *                   IS1 ENTRY                   @BM13334\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FCQ              @BM13334\n  DFHTUTEN     C=(01),K='PREPARE'                              @BM10700\n  DFHTUTEN     C=(02),K='SPR REQUEST'                          @BM10700\n  DFHTUTEN     C=(03),K='COMMIT'                               @BM10700\n  DFHTUTEN     C=(04),K='ABORT'                                @BM10700\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10700\n*                                                                     *\nTUTB2FC1 EQU   *                   ZSYN EXIT                   @BM13334\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BM13334\n**DFHTUTEN     C=(20),K='SYNCPOINT'                            @BM13334\n  DFHTUTEN     C=(21),K='RECOVER'                              @BM13334\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\n*                                                                     *\nTUTB2FC2 EQU   *                   ZNAC SECOND                 @BM10700\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=FC3               @BM13334\n  DFHTUTEN     C=(80),K='INTLOG'                               @BM13334\n  DFHTUTEN     C=(40),K='NOINTLOG'                             @BM13334\n  DFHTUTEN     C=(10),K='CLSDST NORM'                          @BBDIA0Y\n  DFHTUTEN     C=(08),K='CLSDST SOFT'                          @BBDIA0Y\n  DFHTUTEN     C=(04),K='NEG RESP'                             @BBDIA0Y\n  DFHTUTEN     C=(02),K='OUTSERV'   OUT OF SERVICE             @BBDIA0Y\n  DFHTUTEN     C=(01),K='CLSDST ABNORM'                        @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2FC3 EQU   *                   ZNAC SECOND CONTINUED       @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FC4               @BBDIA0Y\n  DFHTUTEN     C=(20),K='ABTASK'                               @BM13334\n  DFHTUTEN     C=(80),K='ABSEND'                               @BM13334\n  DFHTUTEN     C=(40),K='ABRECV'                               @BM13334\n  DFHTUTEN     C=(08),K='GMM'                                  @BBDIA0Y\n  DFHTUTEN     C=(02),K='SIMLOG'                               @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2FC4 EQU   *                   ZNAC SECOND CONTINUED       @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=SRT               @BBDIA0Y\n  DFHTUTEN     C=(80),K='PRTACT'                               @BBDIA0Y\n  DFHTUTEN     C=(40),K='PRTRPL'                               @BBDIA0Y\n  DFHTUTEN     C=(20),K='PRTTCT'                               @BBDIA0Y\n  DFHTUTEN     C=(10),K='PRTTIOA'                              @BBDIA0Y\n  DFHTUTEN     C=(08),K='PRTBIND'                              @BBDIA0Y\n  DFHTUTEN     C=(04),K=' '                                    @BBDIA0Y\n  DFHTUTEN     C=(02),K=' '                                    @BBDIA0Y\n  DFHTUTEN     C=(01),K=' '                                    @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2FCN EQU   *                   IS2 ENTRY                   @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R1,E=DFT,NX=SRT              @BBDIA0Y\n  DFHTUTEN     C=(03),K=' ',NX=FCO  TYPE =LIFO ENTRY           @BBDIA0Y\n  DFHTUTEN     C=(05),K=' ',NX=FCP  TYPE =LIFO ENTRY           @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\nTUTB2FCO EQU   *                   IS2 ENTRY                   @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BBDIA0Y\n  DFHTUTEN     C=(01),K='RECEIVE'                              @BBDIA0Y\n  DFHTUTEN     C=(02),K='DISC'                                 @BBDIA0Y\n  DFHTUTEN     C=(05),K='IOR',NX=FI2                           @BBDIA0Y\n  DFHTUTEN     C=(08),K='NORMAL STOP'                          @BBDIA0Y\n  DFHTUTEN     C=(09),K='IMMED STOP'                           @BBDIA0Y\n  DFHTUTEN     C=(0A),K='LOGOFF'                               @BBDIA0Y\n  DFHTUTEN     C=(10),K='GETDATA'                              @BBDIA0Y\n  DFHTUTEN     C=(11),K='ENABLE'                               @BBDIA0Y\n  DFHTUTEN     C=(12),K='RECV ABORT'                           @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10700\n*                                                                     *\nTUTB2FCP EQU   *                   IS2 EXIT                    @BM13538\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=B0,E=DFT,NX=SRT              @BM13538\n  DFHTUTEN     C=(00),K='NORMAL'                               @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2FCS EQU   *                   SHUTDOWN DECODE             @BBCI70Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=SRT               @BM12069\n  DFHTUTEN     C=(01),K='ORDERLY'                              @BBCI70Y\n  DFHTUTEN     C=(02),K='IMMED'                                @BBCI70Y\n  DFHTUTEN     C=(04),K='ABEND'                                @BBCI70Y\n  DFHTUTEN     C=(08),K='VTAM QUIESCE'                         @BM13399\n  DFHTUTEN     C=(80),K='TPEND'                                @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*                                                                     *\nTUTB2FI2 EQU   *         CONTINUE  IS2 ENTRY                   @BM13399\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT               @BM10700\n  DFHTUTEN     C=(80),K='WRITE'                                @BM13399\n  DFHTUTEN     C=(40),K='WAIT'                                 @BM13399\n  DFHTUTEN     C=(20),K='READ'                                 @BM13399\n  DFHTUTEN     C=(10),K='LAST'                                 @BM13399\n  DFHTUTEN     C=(08),K='RESET'                                @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*                                                                     *\nTUTB2FCT EQU   *                   TERMINAL SHARING            @BM13399\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BM13399\n  DFHTUTEN     C=(0B),K='ATTACH'                               @BM13399\n  DFHTUTEN     C=(0C),K='APPL REQ'                             @BM13399\n  DFHTUTEN     C=(0D),K='DETACH'                               @BM13399\n  DFHTUTEN     C=(0E),K='FLUSH'                                @BM13399\n  DFHTUTEN     C=(0F),K='ROUTE'                                @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*                                                                     *\nTUTB2FZE EQU   *                   ZEMW TRACE ENTRY            @BM13399\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=SRT              @BM13399\n  DFHTUTEN     C=(40),K='MSG'                                  @BM13399\n  DFHTUTEN     C=(20),K='NEG RESP'                             @BM13399\n  DFHTUTEN     C=(02),K='EMW ACTIVE'                           @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*   ACTIVATE SCAN REQUEST                                             *\nTUTB2FZV EQU   *                   ZACT TRACE ENTRY            @BM13399\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=FZX               @BM13334\n  DFHTUTEN     C=(80),K='ZGET'                                 @BM13399\n  DFHTUTEN     C=(40),K='ZFRE'                                 @BM13399\n  DFHTUTEN     C=(20),K='ZATT'                                 @BM13399\n  DFHTUTEN     C=(10),K='ASYN'                                 @BM13399\n  DFHTUTEN     C=(08),K='RESUME'                               @BM13399\n  DFHTUTEN     C=(04),K='ZRVS'                                 @BM13399\n  DFHTUTEN     C=(02),K='COMQ'                                 @BM13399\n  DFHTUTEN     C=(01),K='LOGRESP'                              @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*   ACTIVATE SCAN REQUEST                                             *\nTUTB2FZX EQU   *                   ZACT TRACE ENTRY            @BM13399\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FZY               @BM13399\n  DFHTUTEN     C=(80),K='ZSDS'                                 @BM13399\n  DFHTUTEN     C=(40),K='ZSDA'                                 @BM13399\n  DFHTUTEN     C=(20),K='ZSES'                                 @BM13399\n  DFHTUTEN     C=(10),K='ZSKR'                                 @BM13399\n  DFHTUTEN     C=(08),K='ZRST'                                 @BM13399\n  DFHTUTEN     C=(04),K='DELAY'                                @BM13399\n  DFHTUTEN     C=(02),K='EXIT ADDED'                           @BM13399\n  DFHTUTEN     C=(01),K='ZDET'                                 @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*   ACTIVATE SCAN REQUEST                                             *\nTUTB2FZY EQU   *                   ZACT TRACE ENTRY            @BM13399\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=FZZ               @BA58102\n  DFHTUTEN     C=(80),K='ZOPN'                                 @BM13399\n  DFHTUTEN     C=(40),K='ZCLS'                                 @BM13399\n  DFHTUTEN     C=(20),K='ZATI'                                 @BM13399\n  DFHTUTEN     C=(10),K='ZSIM'                                 @BM13399\n  DFHTUTEN     C=(08),K='ZRSY'                                 @BM13399\n  DFHTUTEN     C=(04),K='ZNAC'                                 @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*   ACTIVATE SCAN REQUEST                                             *\nTUTB2FZZ EQU   *                   ZACT TRACE ENTRY            @BM13399\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DFT,NX=SRT               @BA58102\n  DFHTUTEN     C=(80),K='ZTRA'                                 @BM13399\n  DFHTUTEN     C=(40),K='ZSDL'                                 @BA51625\n  DFHTUTEN     C=(20),K='ZRVL'                                 @BA51625\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*                                                                     *\nTUTB2FCW EQU   *                   ZARL ENTRY TRACE ENTRY   @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT           @EI00U @L6A\n  DFHTUTEN     C=(01),K='ALLOCATE',NX=FCV                   @EI00U @L6A\n* DFHTUTEN     C=(02),K='RESERVED'\n  DFHTUTEN     C=(03),K='EXTRACT PROCESS'                   @EI00U @L6A\n* DFHTUTEN     C=(04),K='RESERVED'\n  DFHTUTEN     C=(05),K='FREE'                              @EI00U @L6A\n  DFHTUTEN     C=(06),K='ISSUE ABEND'                       @EI00U @L6A\n  DFHTUTEN     C=(07),K='ISSUE ATTACH'                      @EI00U @L6A\n  DFHTUTEN     C=(08),K='ISSUE CONFIRMATION'                @EI00U @L6A\n  DFHTUTEN     C=(09),K='ISSUE ERROR'                       @EI00U @L6A\n  DFHTUTEN     C=(0A),K='ISSUE SIGNAL'                      @EI00U @L6A\n  DFHTUTEN     C=(0B),K='RECEIVE',NX=FC7                    @EI00U @L6A\n  DFHTUTEN     C=(0C),K='SEND',NX=FC5                       @EI00U @L6A\n  DFHTUTEN     C=(0D),K='WAIT'                              @EI00U @L6A\n* DFHTUTEN     C=(0E),K='RESERVED'\n* DFHTUTEN     C=(0F),K='RESERVED'\n  DFHTUTEN     C=(10),K='FREE STORAGE'                      @EI00U @L6A\n  DFHTUTEN     C=(11),K='INITIAL CALL'                      @EI00U @L6A\n  DFHTUTEN     C=(12),K='ALLOCATE PRIV',NX=FCV              @EI00U @L6A\n  DFHTUTEN     C=(13),K='SYNC PREPARE'                      @EI00U @L6A\n  DFHTUTEN     C=(14),K='SYNC REQ COMMIT'                   @EI00U @L6A\n  DFHTUTEN     C=(15),K='SYNC COMMITED'                     @EI00U @L6A\n  DFHTUTEN     C=(16),K='SYNC FORGET'                       @EI00U @L6A\n  DFHTUTEN     C=(17),K='ABORT'                             @EI00U @L6A\n  DFHTUTEN     C=(18),K='GET MY LUNAME'                     @EI00U @L6A\n  DFHTUTEN     C=(19),K='SYNC ROLLBACK'                     @EI00U @L6A\n  DFHTUTEN     C=(1A),K='SEND FMH'                          @EI00U @L6A\n  DFHTUTEN     C=(1B),K='RECEIVE FMH'                       @EI00U @L6A\n* DFHTUTEN     C=(1C),K='RESERVED'\n* DFHTUTEN     C=(1D),K='RESERVED'\n* DFHTUTEN     C=(1E),K='RESERVED'\n* DFHTUTEN     C=(1F),K='RESERVED'\n  DFHTUTEN     C=(20),K='ERP FMH RECEIVED'                  @EI00U @L6A\n  DFHTUTEN     C=(21),K='NEG RESP RECEIVED'                 @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FCV EQU   *                   ZARL ALLOC TRACE ENTRY   @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FCC            @EI00U @L6A\n  DFHTUTEN     C=(80),K='NOQUEUE'                           @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FCC EQU   *                   ZARL ALLOC TRACE ENTRY   @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(80),K='MODENAME'                          @EI00U @L6A\n  DFHTUTEN     C=(40),K='ATI'                               @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FC5 EQU   *                   ZARL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FC6            @EI00U @L6A\n  DFHTUTEN     C=(80),K='FROM'                              @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FC6 EQU   *                   ZARL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(80),K='INVITE'                            @EI00U @L6A\n  DFHTUTEN     C=(40),K='LAST'                              @EI00U @L6A\n  DFHTUTEN     C=(20),K='CONFIRM'                           @EI00U @L6A\n  DFHTUTEN     C=(10),K='WAIT'                              @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FC7 EQU   *                   ZARL RECEIVE TRACE ENTRY @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FC8            @EI00U @L6A\n  DFHTUTEN     C=(80),K='SET'                               @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FC8 EQU   *                   ZARL RECEIVE TRACE ENTRY @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(80),K='LLID'                              @EI00U @L6A\n  DFHTUTEN     C=(40),K='BUFFER'                            @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FCX EQU   *                   ZARL EXIT TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT           @EI00U @L6A\n  DFHTUTEN     C=(00),K='NORMAL'                            @EI00U @L6A\n  DFHTUTEN     C=(01),K='SYSIDERR'                          @EI00U @L6A\n  DFHTUTEN     C=(02),K='SYSBUSY'                           @EI00U @L6A\n  DFHTUTEN     C=(03),K='INVREQ',NX=FCU                     @EI00U @L6A\n  DFHTUTEN     C=(04),K='NOTALLOC'                          @EI00U @L6A\n  DFHTUTEN     C=(05),K='LENGERR'                           @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FCU EQU   *                   ZARL INVREQ TRACE ENTRY  @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=SRT           @EI00U @L6A\n  DFHTUTEN     C=(08),K='STATE'                             @EI00U @L6A\n  DFHTUTEN     C=(0C),K='SYNCLEVEL'                         @EI00U @L6A\n  DFHTUTEN     C=(10),K='LLCOUNT'                           @EI00U @L6A\n  DFHTUTEN     C=(18),K='TPNCHECK'                          @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSM EQU   *                   ZSDL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DFT,NX=FSQ            @EI00U @L6A\n  DFHTUTEN     C=(40),K='DATA',NX=FSN                       @EI00U @L6A\n  DFHTUTEN     C=(20),K='COMMAND',NX=SRT                    @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSN EQU   *                   ZSDL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FSO            @EI00U @L6A\n  DFHTUTEN     C=(01),K='IMPLICIT'                          @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSO EQU   *                   ZSDL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FSP            @EI00U @L6A\n  DFHTUTEN     C=(80),K='FMH'                               @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSP EQU   *                   ZSDL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(10),K='CD'                                @EI00U @L6A\n  DFHTUTEN     C=(40),K='CEB'                               @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSQ EQU   *                   ZSDL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=FSR            @EI00U @L6A\n  DFHTUTEN     C=(04),K='DR2 RESPONSE'                      @EI00U @L6A\n  DFHTUTEN     C=(02),K='DR1 RESPONSE'                      @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSR EQU   *                   ZSDL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(01),K='ER1 RESPONSE'                      @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSS EQU   *                   ZRVL RECEIVE TRACE ENTRY @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(40),K='DATA',NX=FST                       @EI00U @L6A\n  DFHTUTEN     C=(80),K='RESPONSE'                          @EI00U @L6A\n  DFHTUTEN     C=(10),K='SINGLE_RU'                         @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FST EQU   *                   ZRVL RECEIVE TRACE ENTRY @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(08),K='BUFFER'                            @EI00U @L6A\n  DFHTUTEN     C=(04),K='RECALL'                            @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FCY EQU   *                   ZARM TRACE ENTRY         @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT           @EI00U @L6A\n  DFHTUTEN     C=(01),K='SEND'                              @EI00U @L6A\n  DFHTUTEN     C=(02),K='WAIT'                              @EI00U @L6A\n  DFHTUTEN     C=(03),K='RECEIVE'                           @EI00U @L6A\n  DFHTUTEN     C=(04),K='SIGNAL'                            @EI00U @L6A\n  DFHTUTEN     C=(05),K='FLUSH',NX=FC0                      @EI00U @L6A\n  DFHTUTEN     C=(06),K='FREE'                              @EI00U @L6A\n  DFHTUTEN     C=(07),K='INVALID GDS ID'                    @EI00U @L6A\n  DFHTUTEN     C=(08),K='RESET'                             @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FC0 EQU   *                   ZARM FLUSH TRACE ENTRY   @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(80),K='AT SYNCPT'                         @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FCZ EQU   *                   ZLUS TRACE ENTRY         @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FC9           @EI00U @L6A\n  DFHTUTEN     C=(01),K='INIT CHANGE SESS'                  @EI00U @L6A\n  DFHTUTEN     C=(02),K='CHANGE SESS'                       @EI00U @L6A\n  DFHTUTEN     C=(03),K='RECV CHANGE SESS'                  @EI00U @L6A\n  DFHTUTEN     C=(04),K='SHUT DOWN'                         @EI00U @L6A\n  DFHTUTEN     C=(05),K='RESYNC'                            @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FC9 EQU   *                   ZLUS TRACE ENTRY         @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(80),K='ACQUIRED'                          @EI00U @L6A\n  DFHTUTEN     C=(40),K='RELEASED'                          @EI00U @L6A\n  DFHTUTEN     C=(20),K='IMMEDIATE'                         @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSA EQU   *                   ZUSRM TRACE ENTRY TYPE   @EI226 @L8A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FSB           @EI226 @L8C\n  DFHTUTEN     C=(80),K='CHECK'                             @EI226 @L8A\n  DFHTUTEN     C=(00),K='SET'                               @EI226 @L8A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8A\n*                                                                     *\nTUTB2FSB EQU   *                   ZUSRM TRACE ENTRY RQUEST @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=FSC           @EI226 @L8C\n  DFHTUTEN     C=(01),K='ALLOCATE'                          @EI226 @L8C\n  DFHTUTEN     C=(02),K='CONNECT'                           @EI226 @L8C\n  DFHTUTEN     C=(03),K='SEND_DATA'                         @EI226 @L8C\n  DFHTUTEN     C=(04),K='SEND_INV'                          @EI226 @L8C\n  DFHTUTEN     C=(05),K='SEND_LAST'                         @EI226 @L8C\n  DFHTUTEN     C=(06),K='WAIT'                              @EI226 @L8C\n  DFHTUTEN     C=(07),K='ATTCH_INB'                         @EI226 @L8C\n  DFHTUTEN     C=(08),K='RCV_DATA'                          @EI226 @L8C\n  DFHTUTEN     C=(09),K='INV_RCVD'                          @EI226 @L8C\n  DFHTUTEN     C=(0A),K='FREE_RCVD'                         @EI226 @L8C\n  DFHTUTEN     C=(0B),K='FREE'                              @EI226 @L8C\n  DFHTUTEN     C=(0C),K='SYST_FREE'                         @EI226 @L8C\n  DFHTUTEN     C=(0D),K='SEND_SIG'                          @EI226 @L8C\n  DFHTUTEN     C=(0E),K='ISSUE_ERR'                         @EI226 @L8C\n  DFHTUTEN     C=(0F),K='ISSUE_ABD'                         @EI226 @L8C\n  DFHTUTEN     C=(10),K='ERR_RCVD'                          @EI226 @L8C\n  DFHTUTEN     C=(11),K='ABD_RCVD'                          @EI226 @L8C\n  DFHTUTEN     C=(12),K='SEND_CONF'                         @EI226 @L8C\n  DFHTUTEN     C=(13),K='SEND_CNFM'                         @EI226 @L8C\n  DFHTUTEN     C=(14),K='REC_CONF'                          @EI226 @L8C\n  DFHTUTEN     C=(15),K='REC_CNFM'                          @EI226 @L8C\n  DFHTUTEN     C=(16),K='SEND_PREP'                         @EI226 @L8C\n  DFHTUTEN     C=(17),K='SEND_SPR'                          @EI226 @L8C\n  DFHTUTEN     C=(18),K='SEND_CMIT'                         @EI226 @L8C\n  DFHTUTEN     C=(19),K='SEND_FRGT'                         @EI226 @L8C\n  DFHTUTEN     C=(1A),K='REC_PREP'                          @EI226 @L8C\n  DFHTUTEN     C=(1B),K='REC_SPR'                           @EI226 @L8C\n  DFHTUTEN     C=(1C),K='REC_CMIT'                          @EI226 @L8C\n  DFHTUTEN     C=(1D),K='REC_FRGT'                          @EI226 @L8C\n  DFHTUTEN     C=(1E),K='SEND_BCKT'                         @EI226 @L8C\n  DFHTUTEN     C=(1F),K='REC_BCKT'                          @EI226 @L8C\n  DFHTUTEN     C=(20),K='CONV_FAIL'                         @EI226 @L8C\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSC EQU   *                   ZUSRM TRACE ENTRY STATE  @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A2,E=DFT,NX=SRT           @EI226 @L8C\n  DFHTUTEN     C=(01),K='NOT_ALLOC'                         @EI226 @L8C\n  DFHTUTEN     C=(02),K='ALLOC_IN_PROG'                     @EI226 @L8C\n  DFHTUTEN     C=(03),K='ALLOC_SEND'                        @EI226 @L8C\n  DFHTUTEN     C=(04),K='ALLOC_RCV_PND'                     @EI226 @L8C\n  DFHTUTEN     C=(05),K='ALLOC_RCV'                         @EI226 @L8C\n  DFHTUTEN     C=(06),K='FREE_PND_SEND'                     @EI226 @L8C\n  DFHTUTEN     C=(07),K='FREE_RQD'                          @EI226 @L8C\n  DFHTUTEN     C=(08),K='IN_SP_SEND_1PH'                    @EI226 @L8C\n  DFHTUTEN     C=(09),K='IN_SP_RECV_1PH'                    @EI226 @L8C\n  DFHTUTEN     C=(0A),K='IN_SP_SEND_2PH'                    @EI226 @L8A\n  DFHTUTEN     C=(0B),K='IN_SP_RECV_2PH'                    @EI226 @L8A\n  DFHTUTEN     C=(0C),K='IN_SP_BCKT_SEND'                   @EI226 @L8A\n  DFHTUTEN     C=(0D),K='IN_SP_BCKT_REC'                    @EI226 @L8A\n  DFHTUTEN     C=(0E),K='ALLOC_CONF_SEND'                   @EI226 @L8A\n  DFHTUTEN     C=(0F),K='ALLOC_CONF_REC'                    @EI226 @L8A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSD EQU   *                   ZCNT TRACE ENTRY TYPE    @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FSE           @EI226 @L8C\n  DFHTUTEN     C=(80),K='CHECK'                             @EI226 @L8C\n  DFHTUTEN     C=(00),K='SET'                               @EI226 @L8C\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSE EQU   *                   ZCNT TRACE ENTRY REQUEST @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=FSF           @EI226 @L8C\n  DFHTUTEN     C=(01),K='LUS_CONWIN'                        @EI226 @L8C\n  DFHTUTEN     C=(02),K='LUS_CONLOSE'                       @EI226 @L8C\n  DFHTUTEN     C=(03),K='LUS_CON_RESET'                     @EI226 @L8C\n  DFHTUTEN     C=(04),K='BIND_CONWIN'                       @EI226 @L8C\n  DFHTUTEN     C=(05),K='BIND_CONLOSE'                      @EI226 @L8C\n  DFHTUTEN     C=(06),K='UNBIND'                            @EI226 @L8C\n  DFHTUTEN     C=(07),K='LOCAL_ALLOC'                       @EI226 @L8C\n  DFHTUTEN     C=(08),K='DETACH'                            @EI226 @L8C\n  DFHTUTEN     C=(09),K='BB_RCV_+RSP'                       @EI226 @L8C\n  DFHTUTEN     C=(0A),K='BB_RCV_-R(0814)'                   @EI226 @L8C\n  DFHTUTEN     C=(0B),K='BB_RCV_-R(0813)'                   @EI226 @L8C\n  DFHTUTEN     C=(0C),K='-R(0819,RTR)_RCV'                  @EI226 @L8C\n  DFHTUTEN     C=(0D),K='-R(0882,RTR)_RCV'                  @EI226 @L8C\n  DFHTUTEN     C=(0E),K='+RSP(RTR)_RCV'                     @EI226 @L8C\n  DFHTUTEN     C=(0F),K='+RSP(BB)_RCV'                      @EI226 @L8C\n  DFHTUTEN     C=(10),K='RTR_RCV'                           @EI226 @L8C\n  DFHTUTEN     C=(11),K='-R(BB,0814)_RCV'                   @EI226 @L8C\n  DFHTUTEN     C=(12),K='-R(BB,0813)_RCV'                   @EI226 @L8C\n  DFHTUTEN     C=(13),K='RTR_RCV_-R(0819)'                  @EI226 @L8C\n  DFHTUTEN     C=(14),K='-R(BB,088B)_RCV'                   @EI226 @L8A\n  DFHTUTEN     C=(15),K='DATA_INBND'                        @EI226 @L8A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSF EQU   *                   ZCNT TRACE ENTRY STATE   @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A2,E=DFT,NX=SRT           @EI226 @L8C\n  DFHTUTEN     C=(01),K='NOT_BND'                           @EI226 @L8C\n  DFHTUTEN     C=(02),K='NOT_BND_CONWIN'                    @EI226 @L8C\n  DFHTUTEN     C=(03),K='NOT_BND_CONLOSE'                   @EI226 @L8C\n  DFHTUTEN     C=(04),K='BND_CONWIN'                        @EI226 @L8C\n  DFHTUTEN     C=(05),K='CONWIN_ALLOC'                      @EI226 @L8C\n  DFHTUTEN     C=(06),K='CONWIN_RTR_SENT'                   @EI226 @L8C\n  DFHTUTEN     C=(07),K='CONWIN_RTR_PND'                    @EI226 @L8C\n  DFHTUTEN     C=(08),K='BND_CONLOSE'                       @EI226 @L8C\n  DFHTUTEN     C=(09),K='CONLOSE_ALLOC'                     @EI226 @L8C\n  DFHTUTEN     C=(0A),K='CONLOSE_BIDDING'                   @EI226 @L8C\n  DFHTUTEN     C=(0B),K='CONLOSE_BB_CROSS'                  @EI226 @L8C\n  DFHTUTEN     C=(0C),K='CONLOSE_RTR_PND'                   @EI226 @L8C\n  DFHTUTEN     C=(0D),K='CONLOSE_REBID_PND'                 @EI226 @L8C\n  DFHTUTEN     C=(0E),K='CONLOSE_AWAIT_BKT'                 @EI226 @L8C\n  DFHTUTEN     C=(0F),K='BID_ACCEPTED'                      @EI226 @L8A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSG EQU   *                   ZBKT TRACE ENTRY TYPE    @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FSH           @EI226 @L8C\n  DFHTUTEN     C=(80),K='CHECK'                             @EI226 @L8C\n  DFHTUTEN     C=(00),K='SET'                               @EI226 @L8C\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSH EQU   *                   ZBKT TRACE ENTRY REQUEST @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=FSI           @EI226 @L8C\n  DFHTUTEN     C=(01),K='BB_SEND'                           @EI226 @L8C\n  DFHTUTEN     C=(02),K='CEB,RQ*1_SEND'                     @EI226 @L8C\n  DFHTUTEN     C=(03),K='CEB,RQD2_SEND'                     @EI226 @L8C\n  DFHTUTEN     C=(04),K='DR2_RCV'                           @EI226 @L8C\n  DFHTUTEN     C=(05),K='-RSP_RCV'                          @EI226 @L8C\n  DFHTUTEN     C=(06),K='BB_RCV'                            @EI226 @L8C\n  DFHTUTEN     C=(07),K='CEB,RQ*1_RCV'                      @EI226 @L8C\n  DFHTUTEN     C=(08),K='CEB,RQD2_RCV'                      @EI226 @L8C\n  DFHTUTEN     C=(09),K='DR2_SEND'                          @EI226 @L8C\n  DFHTUTEN     C=(0A),K='-RSP_SEND'                         @EI226 @L8C\n  DFHTUTEN     C=(0B),K='SESS_CLOSE'                        @EI226 @L8A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSI EQU   *                   ZBKT TRACE ENTRY STATE   @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A2,E=DFT,NX=SRT           @EI226 @L8C\n  DFHTUTEN     C=(01),K='BET_BRKTS'                         @EI226 @L8C\n  DFHTUTEN     C=(02),K='IN_BKT'                            @EI226 @L8C\n  DFHTUTEN     C=(03),K='IN_BKT_TERM_SEND'                  @EI226 @L8C\n  DFHTUTEN     C=(04),K='IN_BKT_TERM_RCV'                   @EI226 @L8C\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSJ EQU   *                   ZCHS TRACE ENTRY TYPE    @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FSK           @EI226 @L8C\n  DFHTUTEN     C=(80),K='CHECK'                             @EI226 @L8C\n  DFHTUTEN     C=(00),K='SET'                               @EI226 @L8C\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSK EQU   *                   ZCHS TRACE ENTRY REQUEST @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=FSL           @EI226 @L8C\n  DFHTUTEN     C=(01),K='BC_SEND'                           @EI226 @L8C\n  DFHTUTEN     C=(02),K='EC_SEND_RQD'                       @EI226 @L8C\n  DFHTUTEN     C=(03),K='EC_SEND_RQE,CD'                    @EI226 @L8C\n  DFHTUTEN     C=(04),K='EC_SEND_RQD,CD'                    @EI226 @L8C\n  DFHTUTEN     C=(05),K='EC_SEND_RQE,CEB'                   @EI226 @L8C\n  DFHTUTEN     C=(06),K='+R(FMD|LUS)_RCV'                   @EI226 @L8C\n  DFHTUTEN     C=(07),K='-R(FMD|LUS)_RCV'                   @EI226 @L8C\n  DFHTUTEN     C=(08),K='BC_RCV'                            @EI226 @L8C\n  DFHTUTEN     C=(09),K='EC_RCV_RQD'                        @EI226 @L8C\n  DFHTUTEN     C=(0A),K='EC_RCV_RQE,CD'                     @EI226 @L8C\n  DFHTUTEN     C=(0B),K='EC_RCV_RQD,CD'                     @EI226 @L8C\n  DFHTUTEN     C=(0C),K='EC_RCV_RQE,CEB'                    @EI226 @L8C\n  DFHTUTEN     C=(0D),K='+R(FMD|LUS)_SND'                   @EI226 @L8C\n  DFHTUTEN     C=(0E),K='-R(FMD|LUS)_SND'                   @EI226 @L8C\n  DFHTUTEN     C=(0F),K='BB_SND_COMPLETE'                   @EI226 @L8C\n  DFHTUTEN     C=(10),K='BB_ACCEPTED'                       @EI226 @L8C\n  DFHTUTEN     C=(11),K='BKT_ENDED'                         @EI226 @L8C\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSL EQU   *                   ZCHS TRACE ENTRY STATE   @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A2,E=DFT,NX=SRT           @EI226 @L8C\n  DFHTUTEN     C=(01),K='BET_CHNS_SEND'                     @EI226 @L8C\n  DFHTUTEN     C=(02),K='IN_CHN_SEND'                       @EI226 @L8C\n  DFHTUTEN     C=(03),K='AWAIT_RSP_SEND'                    @EI226 @L8C\n  DFHTUTEN     C=(04),K='PND_RSP_SEND'                      @EI226 @L8C\n  DFHTUTEN     C=(05),K='NEG_RSP_RCVD'                      @EI226 @L8C\n  DFHTUTEN     C=(06),K='BET_CHNS_RCV'                      @EI226 @L8C\n  DFHTUTEN     C=(07),K='IN_CHAIN_RCV'                      @EI226 @L8C\n  DFHTUTEN     C=(08),K='PND_RSP_RCV'                       @EI226 @L8C\n  DFHTUTEN     C=(09),K='AWAIT_RSP_RCV'                     @EI226 @L8C\n  DFHTUTEN     C=(0A),K='NEG_RSP_SENT'                      @EI226 @L8C\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\n*   TRACE INTERNAL                                                    *\nTUTB2FDD EQU   *                   TRP - TRACE INTERNAL            @LVC\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BM13399\n*  SYSTEM REPEAT TRACE ENTRY ******************************************\n  DFHTUTEN     C=(01),K='... REPEAT',NX=FDE                    @BM13399\n*  FE TRACE ENTRY *****************************************************\n  DFHTUTEN     C=(99),K='GLOBAL TRAP EXIT'                         @LVA\n*              ********************************************************\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\nTUTB2FDE EQU   *                   REPEAT ENTRY                @BM13399\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=ADDR,E=FD1,NX=SRT            @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FHTUTEN": {"ttr": 7173, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO                                                 @BD910JY\n&NAME    DFHTUTEN &C=,             COMPARE CODE      FOR T=2           *\n               &T=(2,E),           TYPE OF OPERATION FOR T=1           *\n               &CP=CLC,                                                *\n               &OFF=,                                                  *\n               &TB=,               TABLE TYPE        FOR T=2           *\n               &TBR=,              TABLE RETURN TYPE FOR T=1           *\n               &K=,                OUTPUT KEYWORD    FOR BOTH          *\n               &E=,                EXIT              FOR BOTH          *\n               &NX=SRT,                                                *\n               &DUMMY=\n.*  $MAC(DFHTUTEN),COMP(TRACE),PROD(CICS/VS) :                        *\n.*  $L1=G00    160 810918 HDXDRP : ABGV CHANGE FIELD OFFSETS          *\n         GBLB  &GENEXIT            GLOBAL FOR EXITS\n.*                                                                    *\n.*       BUILD TRACE ENTRY IN TABLE                                   *\n.*                                                                    *\n         LCLA  &A1                                          @EG00X @L1A\n         LCLC  &C1,&C2,&C4,&C5                                 @BD910JY\n         LCLC  &E1,&E2             EXIT ADDRESSES              @BD910JY\n         LCLC  &TBD                TABLE RETURN ID             @BBAI20Y\n.*\n&C1      SETC  '&C(1)'            SET IST ENTRY                @BD910JY\n&C2      SETC  '00'                                            @BD910JY\n         AIF   (N'&C LT 2).TUEN010                             @BD910JY\n         AIF   ('&C(2)' EQ '').TUEN010                         @BD910JY\n&C2      SETC  '&C(2)'                                         @BD910JY\n.TUEN010 ANOP                                                  @BD910JY\n.*\n&E1      SETC  'SRT' SET DEFAULTS                              @BD910JY\n&E2      SETC  'SRT' SET DEFAULTS                              @BD910JY\n         AIF   ('&E' EQ '').TUEN020                            @BD910JY\n&E1      SETC  '&E(1)'             SET EXIT 1 OFFSET           @BD910JY\n         AIF   (N'&E LT 2).TUEN020                             @BD910JY\n&E2      SETC  '&E(2)'             SET EXIT 2 OFFSET           @BD910JY\n.TUEN020 ANOP                                                  @BD910JY\n.*\n.*       LEVEL TWO TABLE TO PRODUCE NOW\n.*\n         AIF   ('&T' EQ '1').TUEN200 IF TABLE 1 BRANCH         @BD910JY\n         AIF   ('&T(2)' EQ 'I').TUENI10\n&NAME    DC    X'&C1'              CODE BYTE ONE               @BD910JY\n         DC    X'&C2'              CODE BYTE TWO               @BD910JY\n         AIF   (NOT &GENEXIT).TUENG10 IF NO GEN\n         DC    AL2(TUTB2&NX-TUTB2SRT) GEN NEXT ENTRY\n.TUENG10 ANOP\n.*\n         AGO   .TUEN500            GO OUTPUT KEYWORD           @BD910JY\n.TUENI10 ANOP\n&GENEXIT SETB  1                   SET NO EXIT REQ\n&C4      SETC  '00'\n         AIF   ('&CP' EQ 'TM').TUENI25\n&C4      SETC  '02'\n         AIF   ('&CP' EQ 'CLI').TUENI20\n&C4      SETC  '04'                                            @BM10519\n         AIF   ('&CP' EQ 'CLC').TUENI20                        @BM10519\n.*                                                             @BM10519\n&C4      SETC  '06'                                            @BM10519\n         AIF   ('&CP' EQ '2BIN').TUENI20                       @BM10519\n&C4      SETC  '08'                                            @BM10519\n         AIF   ('&CP' EQ '1BIN').TUENI20                       @BM10519\n&C4      SETC  '10'                                            @BM10519\n         AIF   ('&CP' EQ 'RBIN').TUENI20                       @BM10519\n&C4      SETC  '12'                                            @BM10519\n         AIF   ('&CP' EQ 'LBIN').TUENI20                       @BM10519\n&C4      SETC  '14'                                            @BM10519\n         AIF   ('&CP' EQ '1DEC').TUENI20                       @BM10519\n&C4      SETC  '16'                                            @BM10519\n         AIF   ('&CP' EQ '2DEC').TUENI20                       @BM10519\n&C4      SETC  '18'                                            @BM10519\n         AIF   ('&CP' EQ '3DEC').TUENI20                       @BM10519\n.*                                                             @BM10519\n         MNOTE 12,'WRONG CP OPERAND'\n.TUENI20 ANOP\n&GENEXIT SETB  1                   SET EXIT REQUIRED\n.TUENI25 ANOP\n&C5      SETC  'ID'                                         @EG00X @L1C\n         AIF   ('&OFF' EQ 'ID').TUENI30                        @BM10519\n&C5      SETC  'RETAD'                                      @EG00X @L1C\n         AIF   ('&OFF' EQ 'ADDR').TUENI30                      @BM10519\n&C5      SETC  'TR'                                         @EG00X @L1C\n         AIF   ('&OFF' EQ 'R0').TUENI30\n&C5      SETC  'TR+1'                                       @EG00X @L1C\n         AIF   ('&OFF' EQ 'R1').TUENI30\n&C5      SETC  'TCAID'                                      @EG00X @L1C\n         AIF   ('&OFF' EQ 'TASKNO').TUENI30                    @BM10519\n&C5      SETC  'DATA1'                                      @EG00X @L1C\n         AIF   ('&OFF' EQ 'A0').TUENI30\n&C5      SETC  'DATA1+1'                                    @EG00X @L1C\n         AIF   ('&OFF' EQ 'A1').TUENI30\n&C5      SETC  'DATA1+2'                                    @EG00X @L1C\n         AIF   ('&OFF' EQ 'A2').TUENI30\n&C5      SETC  'DATA1+3'                                    @EG00X @L1C\n         AIF   ('&OFF' EQ 'A3').TUENI30\n&C5      SETC  'DATA2'                                      @EG00X @L1C\n         AIF   ('&OFF' EQ 'B0').TUENI30\n&C5      SETC  'DATA2+1'                                    @EG00X @L1C\n         AIF   ('&OFF' EQ 'B1').TUENI30\n&C5      SETC  'DATA2+2'                                    @EG00X @L1C\n         AIF   ('&OFF' EQ 'B2').TUENI30\n&C5      SETC  'DATA2+3'                                    @EG00X @L1C\n         AIF   ('&OFF' EQ 'B3').TUENI30\n         MNOTE 12,'WRONG OFF COMAND'\n.TUENI30 ANOP\n         DC    AL1(&C4)            OPERATION TYPE              @BM10519\n.*\n         DC    AL1(ZTR&C5-ZTRENTRY)   FIELD OFFSET          @EG00X @L1C\n         DC    AL2(TUTE1&E1-TUTE1SRT) EXIT OFFSET\n         DC    AL2(TUTB2&NX-TUTB2SRT) NEXT OFFSET\n         AGO   .TUEN550\n.*        LEVEL ONE TABLE TO PRODUCE NOW\n.*\n.TUEN200 ANOP                                                  @BD910JY\n&TBD     SETC  '&TB'               SET TO DEFAULT              @BBAI20Y\n         AIF   ('&TBR' EQ '').TUEN210                          @BBAI20Y\n&TBD     SETC  '&TBR'              SET TO REAL                 @BBAI20Y\n.TUEN210 ANOP                                                  @BBAI20Y\n.* GENERATE TABLE ENTRY                                        @BBAI20Y\n&NAME    DC  AL2(TUTB2&TB-TUTB2SRT) TABLE OFFSET               @BD910JY\n         DC  AL2(TUTB2&TBD-TUTB2SRT) TABLE OFFSET FOR RETURN   @BBAI20Y\n.*       DC  AL2(TUTE1&E2-TUTE1SRT) EXIT 2 OFFSET\n.TUEN500 ANOP                                                  @BD910JY\n         AIF   ('&K' NE '').TUEN520 IF NOT NULL BRANCH         @BD910JY\n         DC    AL1(0),C' '         NULL STRING                 @BD910JY\n         AGO   .TUEN550                                        @BD910JY\n.TUEN520 ANOP                                                  @BD910JY\n&A1      SETA  K'&K                                         @EG00X @L1C\n         AIF   ('&K'(1,1) EQ '''').TUEN540                     @BD910JY\n         DC    AL1(&A1-1),CL&A1'&K'                         @EG00X @L1C\n         AGO   .TUEN550                                        @BD910JY\n.TUEN540 ANOP                                                  @BD910JY\n&A1      SETA  &A1-2                                        @EG00X @L1A\n         DC    AL1(&A1-1),CL&A1&K                           @EG00X @L1C\n.TUEN550 ANOP                                                  @BD910JY\n         MEXIT                                                 @BD910JY\n.*       TRACE TABLE SETUP MACRO.\n.*\n.*       STATUS CHANGE LEVEL 00.\n.*\n.*       FUNCTION.\n.*           TO PROVIDE TABLES FOR DECODING THE TRACE TABLE.\n.*           TWO TYPES OF TABLE ARE SETUP.\n.*           TYPE 1 (T=1) LEVEL ONE TABLE CONTAINING\n.*           OFFSET OF EXIT\n.*           OFFSET OF LEVEL TWO TABLE\n.*           CHARACTER STRING TO OUTPUT\n.*\n.*           TYPE 2 (T=2) LEVEL TWO TABLE CONTAINING\n.*           CHAR TO COMPARE 1\n.*           CHAR TO COMPARE 2\n.*           CHAR STRING TO OUTPUT IF COMPARES ARE TRUE.\n.*       OUTPUT.\n.*           FOR EACH INVOCATION OF THE MACRO ONE ENTRY IS OUTPUT.\n.*           T=1\n.*             E=EXIT REQUIRED\n.*             TB=TABLE TWO REQUIRED\n.*             K=CHAR STING TO OUTPUT\n.*           T=(2,E)\n.*             C=HEX (2,2) DIGITS TO COMPARE\n.*             K=CHAR STRING TO OUTPUT\n.*                INTERNAL USE BY TRACE ROUTINES ONLY\n.*           T=(2,I)\n.*             CP=COMPARE TYPE\n.*             OFF=OFFSET IN MINOR TABLE\n.*             K=CHAR STRING TO OUTPUT\n.*             E=EXIT REQUIRED\n.*\n.*       METHOD\n.*          THIS MACRO FIRST SETS LOCAL VALUES FOR THE OPTIONS\n.*          AND THEN OUTPUTS THE ENTRY.\n.*       EXTERNAL FIELDS\n.*          NONE\n.*\n.*       ERROR MSGS\n.*           NONE\n.*\n.*       NOTES\n.*          NONE.\n.*\n.*\n         MEND                                                  @BD910JY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$HELP": {"ttr": 36, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00B\\x00\\x91\\x11o\\x00\\x92!\\x9f\\x13Y\\x00\\t\\x00\\t\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-04-26T00:00:00", "modifydate": "1992-08-06T13:59:42", "lines": 9, "newlines": 9, "modlines": 0, "user": "ZTSALK"}, "text": "         AIF   ('&HELP' EQ 'YES').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the '@@@@' parameter        *\n* and it's use, pass parameter 'HELP=Yes'.\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n.*--------------------------------------------------------------------*\n.A$HELPE ANOP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$MACHELP": {"ttr": 38, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00V\\x00\\x91\\x10\\x8f\\x00\\x92!\\x9f\\x13Y\\x00\\t\\x00\\x07\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1991-04-18T00:00:00", "modifydate": "1992-08-06T13:59:56", "lines": 9, "newlines": 7, "modlines": 0, "user": "ZTSALK"}, "text": "         AIF   ('&HELP' EQ 'YES').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the '@@@@' parameter        *\n* and it's use, pass parameter 'HELP=Yes'.\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n.*--------------------------------------------------------------------*\n.A$HELPE ANOP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$MACROS": {"ttr": 15363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\t\\x07_\\x01\\t\\x07_\\x13 \\x01\\xae\\x01\\xae\\x00\\x00\\xc1\\xd3\\xc5\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-03-16T00:00:00", "modifydate": "2009-03-16T13:20:29", "lines": 430, "newlines": 430, "modlines": 0, "user": "ALEX"}, "text": "*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*\n*                                                                     *\n*  General macros used in programs written by ASYSTS Pty. Ltd.        *\n*                                                                     *\n*  SUMMARY:                                                           *\n*  ~~~~~~~~                                                           *\n*    1. KICKOFF  - Initial program entry housekeeping.                *\n*    2. RACKOFF  - Final program exit housekeeping.                   *\n*    3. UNPACK   o Convert HEX numerics to display format             *\n*    4. CLEARV   o Move blanks to variable field (> 255 bytes).       *\n*    5  AMODECHG o Addressing MODE CHanGe                             *\n*    6. HEXCHMAC o Convert HEX to character.                          *\n*    7. CHHEXMAC o Convert character to HEX.                          *\n*    8. ISPVDEFX o Define ISPF variables (ISPVDEF) to program.        *\n*    9. ISPEXEC  o Invoke ISPLINK using 'ISPEXEC' format commands.    *\n*   10. PUTL     o Issue a PUTLINE command within a command processor *\n*   11. ADYN     o DYNAMIC allocation/deallocation etc...             *\n*   12. PDUMPR   o Program dump with REXX/ISPF presentation.          *\n*   13. PDUMP    o Program dump with 3270 datastream presentation.    *\n*                                                                     *\n*   3270 Data Stream macros:                                          *\n*   14. CADC     o Character Attribute Define Constant                *\n*   15. ICDC     o Insert Character Define Constant                   *\n*   16. RADC     o Repeat to Address Define Constant                  *\n*   17. SBA      o Set Buffer Address                                 *\n*   18. SBADC    o Set Buffer Address Define Constant                 *\n*   19. WCCDC    o Write Control Character Define Constant            *\n*       --------\n*                                                                     *\n*  This member can be rebuilt using the MACBUILD edit macro. To make  *\n*  a sub-set, change the '-' after the macro name to the optional     *\n*  indicator 'o'.  This will leave the entry without including the    *\n*  member. Alternatively pass parameter of ALL to MACBUILD to include *\n*  all assembler macros.                                              *\n*                                                                     *\n*  To find the start of the appropriate macro, enter \"F 'MACRO n'\".   *\n*                                                                     *\n*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*\n*------- Macro  1. KICKOFF -------------------------------------------*\n         MACRO\n&NAME    KICKOFF &BASE,&GETMAINS,&GETMAINL,&LIST=NO,&HELP=NO,&DREG=,   X\n               &AMODE=31,&RMODE=ANY,&SAVE=,&LOC=\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'KICKOFF' parameters    *\n* and it's use, pass parameter of 'HELP=Yes'.                         *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n* Macro to generate all the house keeping etc.. at start of a program,*\n* either re-entrant or not.                                           *\n* This macro works in conjunction with the 'RACKOFF' macro.           *\n*                                                                     *\n* PARAMETERS:\n* 1. Base register(s) - Format \"(Rx,Ry,Rz)\" or \"Rx\". May have up to   *\n*                       3 base registers specified. R13 may not be    *\n*                       used for re-entrant programs (refer 2 below). *\n*                       For non re-entrant programs, if R13 is used   *\n*                       as one of the base registers, it will be used *\n*                       as the first base regardless of it's position *\n*                       in the parameter string, and the initial base *\n*                       will be the conventional register save area   *\n*                       NOT the start of the program.                 *\n*                       Default is \"(R11,R12)\".                       *\n* 2. First variable,s name in the DSECT of a GETMAINEd area.  This    *\n*    parameter is optional, however, if it used (eg. re-entrant       *\n*    programs), R13 may not be used as a base register and the first  *\n*    18 full words must be used for register save and linkage         *\n*    conventions.                                                     *\n* 3. Length of the GETMAINEd area (must be an \"EQU\" variable) and must*\n*    be supplied if variable name parameter is supplied.              *\n* 4. AMODE=..  - Addressing mode '24/31' (default = 31)               *\n* 5. DREG=Rn   - Additional DSECT register on GETMAINEd area. (Use    *\n*                only if you have addressability problems on the      *\n*                GETMAINE'd DSECT. Do not enclose in brackets.)       *\n* 6. HELP=...  - Display help comments. 'YES/NO' (default = NO).      *\n* 7. LIST=...  - Display code generated. 'YES/NO' (default = YES).    *\n* 8. LOC=....  - Optional loaction for the GETMAINed area if that     *\n*                option is used. It must be a valid parameter as      *\n*                defined by the IBM GETMAIN macro.                    *\n* 9. RMODE=..  - Load  mode '24/ANY' (default = ANY)                  *\n*10. SAVE=...  - Variable name of register save area if you wish to   *\n*                control it's name. (useful if specialised exit       *\n*                in-lieu of 'RACKOFF'.                                *\n*                                                                     *\n* GENERATES:                                                          *\n* 1. Inserts a \"program_date_time\" stamp at start of module.          *\n* 2. Sets up all the register equates.                                *\n* 3. Saves callers registers R14 thru R12.                            *\n* 4. Points R13 to the programs savearea.                             *\n* 5. Establishes addresability thru supplied register(s) or default   *\n*     base registers R11 + R12.                                       *\n* 6. Workarea is GETMAINEd and the conventional linkage pointers,     *\n*     registers saved and R13 pointed to the start of the work area.  *\n* 7. As R0 + R1 are used as work registers at start, they are restored*\n*     from callers savearea.                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PUSH  PRINT\n         PRINT NOGEN\n.A$XX    ANOP\n         GBLB  &KO1STR1\n         GBLC  &R,&GETMADR,&GETMADL,&SAVREGS\n         LCLC  &E,&BASE1,&BASE2,&BASE3,&BASE#,&#DREG,&#GMM\n         LCLA  &A,&#BASES,&GETMLEN\n         AIF   (T'&GETMAINS EQ 'O').NRENT\n         AIF   (T'&GETMAINL EQ 'O').ERR2\n.NRENT   ANOP\n&GETMADR SETC  '&GETMAINS'\n&GETMADL SETC  '&GETMAINL'\n.*--------------------------------------------------------------------*\n         AIF   (T'&SAVE EQ 'O').DEFSRG      BYPASS IF DEFAULT SAVE NAME\n&SAVREGS SETC  '&SAVE'\n         AGO   .A$$XX                       BYPASS DEFAULT NAME\n.DEFSRG  ANOP\n&SAVREGS SETC  '$SAV'.'&SYSNDX'\n.A$$XX   ANOP\n.*--------------------------------------------------------------------*\n         LCLC  &TNAME\n         AIF   (T'&BASE EQ 'O').DEFAULT\n&BASE1   SETC  '&SYSLIST(1,1)'\n&BASE2   SETC  '&SYSLIST(1,2)'\n&BASE3   SETC  '&SYSLIST(1,3)'\n&#BASES  SETA  N'&SYSLIST(1)\n         AIF   (T'&GETMAINS EQ 'O').A$00    NON-R BYPASS\n         AIF   ('&BASE1' EQ 'R13').ERRR13\n         AIF   ('&BASE2' EQ 'R13').ERRR13\n         AIF   ('&BASE3' EQ 'R13').ERRR13\n         AIF   ('&BASE1' EQ '13').ERRR13\n         AIF   ('&BASE2' EQ '13').ERRR13\n         AIF   ('&BASE3' EQ '13').ERRR13\n.A$00    ANOP\n         AIF   ('&BASE2' EQ 'R13').BASE213\n         AIF   ('&BASE2' EQ '13').BASE213\n         AIF   ('&BASE3' EQ 'R13').BASE313\n         AIF   ('&BASE3' EQ '13').BASE313\n         AGO   .CONT1\n.BASE213 ANOP\n&BASE#   SETC  '&BASE1'\n&BASE1   SETC  '&BASE2'\n&BASE2   SETC  '&BASE#'\n         AGO   .CONT1\n.BASE313 ANOP\n&BASE#   SETC  '&BASE1'\n&BASE1   SETC  '&BASE3'\n&BASE3   SETC  '&BASE#'\n         AGO   .CONT1\n.DEFAULT ANOP\n&#BASES  SETA  2\n&BASE1   SETC  'R11'\n&BASE2   SETC  'R12'\n.CONT1   ANOP\n         AIF   (T'&GETMAINS EQ 'O').NONR0   NON-R BYPASS\n         AIF   (T'&DREG EQ 'O').NONR0       NO 2ND.DSECT REG, BYPASS\n         AIF   ('&DREG' EQ '&BASE1').ERDREG IF SAME AS BASE 1, ERROR\n         AIF   ('&DREG' EQ '&BASE2').ERDREG IF SAME AS BASE 2, ERROR\n         AIF   ('&DREG' EQ '&BASE3').ERDREG IF SAME AS BASE 3, ERROR\n         AIF   ('&DREG' EQ 'R13').ERDREG    IF R13, ERROR\n         AIF   ('&DREG' EQ '13').ERDREG     IF R13, ERROR\n         AIF   ('&DREG' EQ 'RD').ERDREG     IF R13, ERROR\n&#DREG   SETC  ',&DREG'                     SET SECONDARY DSECT REG\n.NONR0   ANOP\n.*--------------------------------------------------------------------*\n         AIF      ('&NAME' EQ '').NONAME\n&E       SETC     '&NAME'\n         AGO      .A\n.NONAME  ANOP\n&E       SETC    'NULL&SYSNDX'\n.A       ANOP\n&E       CSECT\n.TAMODE  ANOP\n         AIF ('&AMODE' NE '31').AM24$\n&E       AMODE  31                          AMODE OF 31\n         AGO    .TRMODE                     Continue\n.AM24$   ANOP\n&E       AMODE  24                          AMODE OF 24 REQUESTED\n&E       RMODE  24                          RMODE OF 24 FORCED\n         AGO    .BYP#10                     Continue\n.TRMODE  ANOP\n         AIF ('&RMODE' NE 'ANY').RM24$$\n&E       RMODE  ANY                         RMODE OF ANY\n         AGO    .BYP#10                     Continue\n.RM24$$  ANOP\n&E       RMODE  24                          RMODE OF 24 REQUESTED\n.BYP#10  ANOP\n&R       SETC     'R'\n         AIF ('&BASE1' EQ 'R13').SAVANCH\n         AIF ('&BASE1' NE '13').TEST1ST\n.SAVANCH ANOP\n&E       SETC     '&SAVREGS'                SET REGISTER SAVE AREA BASE\n.*--------------------------------------------------------------------*\n.TEST1ST ANOP\n         AIF   (&KO1STR1).C                 FIRST TIME THRU\n&KO1STR1 SETB 1\nR0       EQU    0\nR1       EQU    1\nR2       EQU    2\nR3       EQU    3\nR4       EQU    4\nR5       EQU    5\nR6       EQU    6\nR7       EQU    7\nR8       EQU    8\nR9       EQU    9\nR10      EQU   10\nRA       EQU   10\nR11      EQU   11\nRB       EQU   11\nR12      EQU   12\nRC       EQU   12\nR13      EQU   13\nRD       EQU   13\nR14      EQU   14\nRE       EQU   14\nR15      EQU   15\nRF       EQU   15\n*---------------------------------------------------------------------*\n.C       ANOP\n         B     30(&R.15)                    BRANCH AROUND P/D/T STAMP\n         DC    CL8'&NAME'                   PROGRAM STAMP\n         DC    C'_'                         DELIMITER\n         DC    CL8'&SYSDATE'                DATE STAMP\n         DC    C'_'                         DELIMITER\n         DC    CL8'&SYSTIME'                TIME STAMP\n         STM   &R.14,&R.12,12(&R.13)        SAVE REGISTERS\n         AIF   (T'&GETMAINS EQ 'O').NONR1   NON-R BYPASS\n.*--------------------------------------------------------------------*\n.*      RE-ENTRANT PROG                                               *\n.*--------------------------------------------------------------------*\n         LR    2,15                         LOAD R2 WITH START OF PR\n         USING &NAME,2                      USE R2 AS TEMPORARY BASE\n.*--------------------------------------------------------------------*\n         AIF (T'&LOC EQ 'O').NOGMLOC\n*        GETMAIN R,LV=&GETMAINL,&LOC        GETMAIN AREA\n         GETMAIN R,LV=&GETMAINL,&LOC        GETMAIN AREA\n         AGO   .A$$000\n.NOGMLOC ANOP\n*        GETMAIN R,LV=&GETMAINL             GETMAIN AREA\n         GETMAIN R,LV=&GETMAINL             GETMAIN AREA\n.A$$000  ANOP\n.*--------------------------------------------------------------------*\n         ST    &R.13,4(&R.1)                BACKWARD CHAIN\n         ST    &R.1,8(&R.13)                FORWARD CHAIN\n.*--------------------------------------------------------------------*\n.* The next line does horrible things with 31 bit addressing.         *\n.*       NI    12(&R.13),X'00'              CLEAR TRACE BITS\n.*--------------------------------------------------------------------*\n         LR    &R.13,&R.1                   SAVE AREA @\n         AIF   (T'&DREG EQ 'O').NDREG1      NO 2ND.DSECT REG, BYPASS\n         LA    &DREG,4095(&R.13)            POINT 2ND. REG 1K PAST\n         LA    &DREG,1(&DREG)                 1ST. DSECT BASE\n.NDREG1  ANOP\n         USING &GETMADR,&R.13&#DREG         ADDRESABILITY TO GETMAIN\n         LR    &BASE1,&R.2                  &BASE1 IS 1ST. BASE REG\n         DROP  &R.2                         DROP REGISTER 15 AS BASE\n         AIF      (&#BASES GT 1).TWOBASE\n         USING &E,&BASE1                    USING ONE BASE REGISTER\n         AGO      .RESTR0R2\n.NONR1   ANOP\n.*--------------------------------------------------------------------*\n.*      NON RE-ENTRANT PROG                                           *\n.*--------------------------------------------------------------------*\n         USING &NAME,15                     USE R15 AS TEMPORARY BASE\n         ST    &R.13,&SAVREGS.+4            BACKWARD CHAIN\n         LA    &R.0,&SAVREGS                OUR SAVEAREA ADDRESS\n         ST    &R.0,8(&R.13)                FORWARD CHAIN\n.*--------------------------------------------------------------------*\n.* The next line does horrible things with 31 bit addressing.         *\n.*       NI    12(&R.13),X'00'              CLEAR TRACE BITS\n.*--------------------------------------------------------------------*\n         LR    13,0                         R13 POINT TO OUR SAVEAREA\n         AIF ('&E' EQ '&SAVREGS').NOLOAD1   BUPASS BASE LOAD\n         LR    &BASE1,15                    &BASE1 IS 1ST. BASE REG\n.NOLOAD1 ANOP\n         AIF      (&#BASES GT 1).TWOBASE\n         DROP  15                           RELINQUISH ADDRESSABILITY\n         USING &E,&BASE1                    USING ONE BASE REGISTER\n         AGO      .ADROK\n.TWOBASE ANOP\n         LA    &BASE2,4095(&BASE1)          POINT 2ND. REG 1K PAST\n         LA    &BASE2,1(&BASE2)               1ST. BASE\n         AIF      (&#BASES GT 2).THRBASE\n         DROP  15                           RELINQUISH ADDRESSABILITY\n         USING &E,&BASE1,&BASE2             USING TWO BASE REGISTERS\n         AGO      .ADROK\n.THRBASE ANOP\n         LA    &BASE3,4095(&BASE2)          POINT 3RD. REG 1K PAST\n         LA    &BASE3,1(&BASE3)               2ND. BASE\n         DROP  15                           RELINQUISH ADDRESSABILITY\n         USING &E,&BASE1,&BASE2,&BASE3      USING THREE BASE REGISTERS\n.*       AGO      .ADROK\n.ADROK   ANOP\n         AIF   (T'&GETMAINS NE 'O').RESTR0R2 RE-ENT PROCESSING\n         LA    1,&E                         ADDRESS OF CSECT\n         LA    0,&SAVREGS                   NEW BASE ADDRESS\n         SR    1,0                          SUBTRACT THE DIFFERENCE\n         STH   1,KOFFCOMP                   STORE UNDER @ COMPENSATOR\n         B     &SAVREGS.+74                 BRANCH AROUND SAVE AREA\n&SAVREGS DS    18F\nKOFFCOMP DS    H                            KICKOFF BASE @ COMPENSATOR\n         XR    &R.0,&R.0                    ZERO REGISTER 0\n         ST    &R.0,&SAVREGS.+8             CLEAR FORWARD CHAIN\n         L     &R.1,4(&R.13)                LOAD CALLERS SAVEAREA @\n         LM    &R.0,&R.1,20(&R.1)           RESTORE PARM REGISTERS\n         AGO   .MEXIT1\n.*--------------------------------------------------------------------*\n.RESTR0R2 ANOP\n.*--------------------------------------------------------------------*\n.*      RE-ENTRANT PROG                                               *\n.*--------------------------------------------------------------------*\n         XR    &R.0,&R.0                    ZERO REGISTER 0\n         ST    &R.0,8(&R.13)                CLEAR FORWARD CHAIN\n         L     &R.1,4(&R.13)                LOAD CALLERS SAVEAREA @\n         LM    &R.0,&R.2,20(&R.1)           RESTORE PARM REGISTERS\n         AGO   .MEXIT1\n.*--------------------------------------------------------------------*\n.ERR     MNOTE 8,'MUST SUPPLY WORK-AREA DSECT FOR GETMAIN.'\n         AGO   .MEXIT1\n.ERR2    MNOTE 8,'MUST SUPPLY WORK-AREA DSECT LENGTH FOR GETMAIN.'\n         AGO   .MEXIT1\n.ERR3    MNOTE 8,'NO MATCHING RACKOFF FOR PREVIOUS KICKOFF.'\n         AGO   .MEXIT1\n.ERRR13  MNOTE 8,'R13 CANNOT BE USED AS BASE FOR RE-ENTRANT MACRO.'\n         AGO   .MEXIT1\n.ERDREG  MNOTE 8,'XTRA DSECT REGISTER MUST NOT BE A BASE OR R13.'\n         AGO   .MEXIT1\n.MEXIT1  ANOP\n         AIF   ('&LIST'(1,1) NE 'N').MEXIT9\n         POP PRINT\n.MEXIT9  ANOP\n*---------------------------------------------------------------------*\n         MEXIT\n.*--------------------------------------------------------------------*\n         MEND\n*---------------------------------------------------------------------*\n*------- Macro  2. RACKOFF -------------------------------------------*\n         MACRO                                                          RAC00010\n&NAME    RACKOFF &RC=0,&LIST=NO,&R1=,&HELP=NO                           RAC00020\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'RACKOFF' parameter     *\n* and it's use, pass parameter 'HELP=Yes'.                            *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n* Parameters:                                                         *\n*                                                                     *\n*        RC=n       - Numeric return code (default = 0)               *\n*                             - or -                                  *\n*                     RC=(R15) if R15 contains the return code        *\n*        LIST=Y/N   - Generate code from macro expansion (def = NO)   *\n*        HELP=Y/N   - Display this help box (def = Yes)               *\n*        R1=PASS    - 'PASS' infers that R1 contains return parameter *\n*                     value to the caller and is to remain as is. Any *\n*                     other value will include R1 in the register     *\n*                     restoration command 'LM  R14,R12,....'          *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   (T'&NAME EQ 'O').NONAME\n&NAME    DS    0H                                                       RAC00020\n.NONAME  ANOP\n         GBLC  &R,&GETMADR,&GETMADL,&SAVREGS\n&KO1STR  SETB 0                             TURN 1ST TIME THRU OFF\n         AIF   (T'&GETMADL EQ 'O').A$10     NON-R BYPASS\n         AIF   (T'&R1 EQ 'O').A$00          DO NOT PASS R1\n         AIF   ('&R1' NE 'PASS').A$00       IF R1\u00ac=PASS DO NOT PASS R1\n         LR    &R.3,&R.1                    SAVE REGISTER 1 IN CASE\n.A$00    ANOP\n         LR    &R.1,&R.13                   LOAD GETMAINED AREA ADDRESS\n         LR    &R.2,&R.15                   SAVE REGISTER 15 IN CASE\n.A$10    ANOP\n         L     &R.13,4(&R.13)               LOAD CALLERS SAVEAREA @     RAC00040\n         AIF   (T'&GETMADL EQ 'O').A$20     NON-R BYPASS\n*        FREEMAIN R,LV=&GETMADL,A=(1)\n         FREEMAIN R,LV=&GETMADL,A=(1)\n.A$20    ANOP\n         AIF   (T'&R1 EQ 'O').A$21          DO NOT PASS R1\n         AIF   ('&R1' NE 'PASS').A$21       IF R1\u00ac=PASS DO NOT PASS R1\n         LR    &R.1,&R.3                    RESTORE R1\n.A$21    ANOP\n         AIF   ('&RC' EQ '(R15)').SPEC      R15 CONTAINS RC             RAC00050\n         AIF   ('&RC' EQ '(15)').SPEC R15 CONTAINS RC                   RAC00060\n         AIF   (T'&R1 EQ 'O').A$22          DO NOT PASS R1\n         AIF   ('&R1' NE 'PASS').A$22       IF R1\u00ac=PASS DO NOT PASS R1\n         LM    &R.14,&R.0,12(&R.13)         RESTORE REGISTERS 14-0      RAC00070\n*                                           LEAVE R1 AS IS\n         LM    &R.2,&R.12,28(&R.13)         RESTORE REGISTERS 2-12      RAC00070\n         AGO   .A$23                                                    RAC00090\n.A$22    ANOP\n         LM    &R.14,&R.12,12(&R.13)        RESTORE REGISTERS 14-12     RAC00070\n.A$23    ANOP\n         LA    &R.15,&RC                    SET RETURN CODE             RAC00080\n         AGO   .RET1                                                    RAC00090\n.SPEC    ANOP                                                           RAC00100\n         AIF   (T'&GETMADL EQ 'O').A$30     NON-R BYPASS\n         LR    &R.15,&R.2                   RESTORE R15 FROM ABOVE SAVE RAC00100\n.A$30    ANOP\n         L     &R.14,12(&R.13)              RESTORE R14                 RAC00100\n         AIF   (T'&R1 EQ 'O').A$32          DO NOT PASS R1\n         AIF   ('&R1' NE 'PASS').A$32       IF R1\u00ac=PASS DO NOT PASS R1\n         L     &R.0,20(&R.13)               RESTORE REGISTER 0          RAC00110\n*                                           LEAVE R1 AS IS\n         LM    &R.2,&R.12,28(&R.13)         RESTORE REGISTERS 2-12      RAC00110\n         AGO   .RET1                                                    RAC00090\n.A$32    ANOP\n         LM    &R.0,&R.12,20(&R.13)         RESTORE REGISTERS 0-12      RAC00110\n.RET1    ANOP                                                           RAC00120\n.*--------------------------------------------------------------------*\n.* The next line does horrible things with 31 bit addressing.         *\n.*       MVI   12(&R.13),X'FF'              SET TRACE BITS ON           RAC00120\n.*--------------------------------------------------------------------*\n         BR    &R.14                        RETURN                      RAC00130\n         POP   PRINT\n*---------------------------------------------------------------------*\n         MEXIT\n.*--------------------------------------------------------------------*\n.E1      POP   PRINT\n         MNOTE 8,'MACRO KICKOFF MUST BE USED WITH THIS MACRO.'\n         MEXIT\n.*--------------------------------------------------------------------*\n         MEND                                                           KIC00710\n*---------------------------------------------------------------------*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PCRECV": {"ttr": 257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x05\\x1f\\x00\\x96\\x05\\x1f\\x18%\\x00^\\x00^\\x00\\x00\\xe4\\xe3\\xd4\\xd7\\xf5\\xf4\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-02-20T00:00:00", "modifydate": "1996-02-20T18:25:00", "lines": 94, "newlines": 94, "modlines": 0, "user": "UTMP543"}, "text": "@echo off\nrem *        Created 96/02/20\nrem *******************************************************************\nrem * File to be executed on the PC to send all the bookmanager files *\nrem * to MVS into the datasets specified, that have already been      *\nrem * created by the same job that created this file.                 *\nrem *******************************************************************\n\nrem *******************************************************************\nrem * Ensure all the directories exist                                *\nrem *******************************************************************\nPush\nC:\nPush\ncd\\\nmd ASYSTS\ncd ASYSTS\nmd MACLIB\nPull\nPull\nrem *******************************************************************\n\nset outdir=C:\\ASYSTS\\MACLIB\nset dsname=UTMP543.MACLIB\nPush\nC:\nPush\nRECEIVE %outdir%\\$$$INDEX '%dsname%($$$INDEX)' CR AS\nRECEIVE %outdir%\\$$COPY '%dsname%($$COPY)' CR AS\nRECEIVE %outdir%\\$HELP '%dsname%($HELP)' CR AS\nRECEIVE %outdir%\\$MACHELP '%dsname%($MACHELP)' CR AS\nRECEIVE %outdir%\\$PCRECV '%dsname%($PCRECV)' CR AS\nRECEIVE %outdir%\\$PCSEND '%dsname%($PCSEND)' CR AS\nRECEIVE %outdir%\\@ICSXCAR '%dsname%(@ICSXCAR)' CR AS\nRECEIVE %outdir%\\@MACROS '%dsname%(@MACROS)' CR AS\nRECEIVE %outdir%\\ADYN '%dsname%(ADYN)' CR AS\nRECEIVE %outdir%\\ADYNNOTE '%dsname%(ADYNNOTE)' CR AS\nRECEIVE %outdir%\\AMODECHG '%dsname%(AMODECHG)' CR AS\nRECEIVE %outdir%\\CADC '%dsname%(CADC)' CR AS\nRECEIVE %outdir%\\CHHEXMAC '%dsname%(CHHEXMAC)' CR AS\nRECEIVE %outdir%\\CICSXCAC '%dsname%(CICSXCAC)' CR AS\nRECEIVE %outdir%\\CICSXCAR '%dsname%(CICSXCAR)' CR AS\nRECEIVE %outdir%\\CLEARV '%dsname%(CLEARV)' CR AS\nRECEIVE %outdir%\\CTRACE '%dsname%(CTRACE)' CR AS\nRECEIVE %outdir%\\DDSCAN '%dsname%(DDSCAN)' CR AS\nRECEIVE %outdir%\\ESTAERCV '%dsname%(ESTAERCV)' CR AS\nRECEIVE %outdir%\\FBA '%dsname%(FBA)' CR AS\nRECEIVE %outdir%\\GBA '%dsname%(GBA)' CR AS\nRECEIVE %outdir%\\HALATTCH '%dsname%(HALATTCH)' CR AS\nRECEIVE %outdir%\\HEXCHMAC '%dsname%(HEXCHMAC)' CR AS\nRECEIVE %outdir%\\ICDC '%dsname%(ICDC)' CR AS\nRECEIVE %outdir%\\INCLUDE '%dsname%(INCLUDE)' CR AS\nRECEIVE %outdir%\\ISPBRIF '%dsname%(ISPBRIF)' CR AS\nRECEIVE %outdir%\\ISPEXEC '%dsname%(ISPEXEC)' CR AS\nRECEIVE %outdir%\\ISPINIT '%dsname%(ISPINIT)' CR AS\nRECEIVE %outdir%\\ISPVDEFX '%dsname%(ISPVDEFX)' CR AS\nRECEIVE %outdir%\\KICKOFF '%dsname%(KICKOFF)' CR AS\nRECEIVE %outdir%\\MACT1 '%dsname%(MACT1)' CR AS\nRECEIVE %outdir%\\PDUMP '%dsname%(PDUMP)' CR AS\nRECEIVE %outdir%\\PDUMP$ '%dsname%(PDUMP$)' CR AS\nRECEIVE %outdir%\\PLOAD '%dsname%(PLOAD)' CR AS\nRECEIVE %outdir%\\PUTL '%dsname%(PUTL)' CR AS\nRECEIVE %outdir%\\PUTLNOTE '%dsname%(PUTLNOTE)' CR AS\nRECEIVE %outdir%\\RACKOFF '%dsname%(RACKOFF)' CR AS\nRECEIVE %outdir%\\RADC '%dsname%(RADC)' CR AS\nRECEIVE %outdir%\\SBA '%dsname%(SBA)' CR AS\nRECEIVE %outdir%\\SBADC '%dsname%(SBADC)' CR AS\nRECEIVE %outdir%\\SCREEND '%dsname%(SCREEND)' CR AS\nRECEIVE %outdir%\\SCREENL '%dsname%(SCREENL)' CR AS\nRECEIVE %outdir%\\SHOWREGS '%dsname%(SHOWREGS)' CR AS\nRECEIVE %outdir%\\SVC235 '%dsname%(SVC235)' CR AS\nRECEIVE %outdir%\\SVLNK '%dsname%(SVLNK)' CR AS\nRECEIVE %outdir%\\TESTMAC '%dsname%(TESTMAC)' CR AS\nRECEIVE %outdir%\\TODAY '%dsname%(TODAY)' CR AS\nRECEIVE %outdir%\\TRACE#D '%dsname%(TRACE#D)' CR AS\nRECEIVE %outdir%\\TRACE#L '%dsname%(TRACE#L)' CR AS\nRECEIVE %outdir%\\TRACED '%dsname%(TRACED)' CR AS\nRECEIVE %outdir%\\TRACEDA '%dsname%(TRACEDA)' CR AS\nRECEIVE %outdir%\\TRACEIT '%dsname%(TRACEIT)' CR AS\nRECEIVE %outdir%\\TRACEL '%dsname%(TRACEL)' CR AS\nRECEIVE %outdir%\\TRACELA '%dsname%(TRACELA)' CR AS\nRECEIVE %outdir%\\TRACER '%dsname%(TRACER)' CR AS\nRECEIVE %outdir%\\UNPACK '%dsname%(UNPACK)' CR AS\nRECEIVE %outdir%\\WCCDC '%dsname%(WCCDC)' CR AS\nRECEIVE %outdir%\\WCCDCCOL '%dsname%(WCCDCCOL)' CR AS\nRECEIVE %outdir%\\WCCDCMON '%dsname%(WCCDCMON)' CR AS\nRECEIVE %outdir%\\WCCDCV '%dsname%(WCCDCV)' CR AS\nRECEIVE %outdir%\\XESTATE# '%dsname%(XESTATE#)' CR AS\n:exit\n@echo off\nset outdir=\nset dsname=\nPull\nPull\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PCSEND": {"ttr": 259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x05\\x1f\\x00\\x96\\x05\\x1f\\x18%\\x00S\\x00S\\x00\\x00\\xe4\\xe3\\xd4\\xd7\\xf5\\xf4\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-02-20T00:00:00", "modifydate": "1996-02-20T18:25:00", "lines": 83, "newlines": 83, "modlines": 0, "user": "UTMP543"}, "text": "@echo off\nrem *        Created 96/02/20\nrem *******************************************************************\nrem * File to be executed on the PC to send all the bookmanager files *\nrem * to MVS into the datasets specified, that have already been      *\nrem * created by the same job that created this file.                 *\nrem *******************************************************************\n\nset outdir=C:\\ASYSTS\\MACLIB\nset dsname=UTMP543.MACLIB\nPush\nC:\nPush\nSEND %outdir%\\$$$INDEX '%dsname%($$$INDEX)' CR AS\nSEND %outdir%\\$$COPY '%dsname%($$COPY)' CR AS\nSEND %outdir%\\$HELP '%dsname%($HELP)' CR AS\nSEND %outdir%\\$MACHELP '%dsname%($MACHELP)' CR AS\nSEND %outdir%\\$PCRECV '%dsname%($PCRECV)' CR AS\nSEND %outdir%\\$PCSEND '%dsname%($PCSEND)' CR AS\nSEND %outdir%\\#ISPEXEC '%dsname%(#ISPEXEC)' CR AS\nSEND %outdir%\\#PUTL '%dsname%(#PUTL)' CR AS\nSEND %outdir%\\@ICSXCAR '%dsname%(@ICSXCAR)' CR AS\nSEND %outdir%\\@MACROS '%dsname%(@MACROS)' CR AS\nSEND %outdir%\\ADYN '%dsname%(ADYN)' CR AS\nSEND %outdir%\\ADYNNOTE '%dsname%(ADYNNOTE)' CR AS\nSEND %outdir%\\AMODECHG '%dsname%(AMODECHG)' CR AS\nSEND %outdir%\\CADC '%dsname%(CADC)' CR AS\nSEND %outdir%\\CHHEXMAC '%dsname%(CHHEXMAC)' CR AS\nSEND %outdir%\\CICSXCAC '%dsname%(CICSXCAC)' CR AS\nSEND %outdir%\\CICSXCAR '%dsname%(CICSXCAR)' CR AS\nSEND %outdir%\\CLEARV '%dsname%(CLEARV)' CR AS\nSEND %outdir%\\CTRACE '%dsname%(CTRACE)' CR AS\nSEND %outdir%\\DDSCAN '%dsname%(DDSCAN)' CR AS\nSEND %outdir%\\ESTAERCV '%dsname%(ESTAERCV)' CR AS\nSEND %outdir%\\FBA '%dsname%(FBA)' CR AS\nSEND %outdir%\\GBA '%dsname%(GBA)' CR AS\nSEND %outdir%\\HALATTCH '%dsname%(HALATTCH)' CR AS\nSEND %outdir%\\HEXCHMAC '%dsname%(HEXCHMAC)' CR AS\nSEND %outdir%\\ICDC '%dsname%(ICDC)' CR AS\nSEND %outdir%\\INCLUDE '%dsname%(INCLUDE)' CR AS\nSEND %outdir%\\ISPBRIF '%dsname%(ISPBRIF)' CR AS\nSEND %outdir%\\ISPEXEC '%dsname%(ISPEXEC)' CR AS\nSEND %outdir%\\ISPINIT '%dsname%(ISPINIT)' CR AS\nSEND %outdir%\\ISPVDEFX '%dsname%(ISPVDEFX)' CR AS\nSEND %outdir%\\KICKOFF '%dsname%(KICKOFF)' CR AS\nSEND %outdir%\\MACT1 '%dsname%(MACT1)' CR AS\nSEND %outdir%\\PDUMP '%dsname%(PDUMP)' CR AS\nSEND %outdir%\\PDUMP$ '%dsname%(PDUMP$)' CR AS\nSEND %outdir%\\PLOAD '%dsname%(PLOAD)' CR AS\nSEND %outdir%\\PUTL '%dsname%(PUTL)' CR AS\nSEND %outdir%\\PUTLNOTE '%dsname%(PUTLNOTE)' CR AS\nSEND %outdir%\\RACKOFF '%dsname%(RACKOFF)' CR AS\nSEND %outdir%\\RADC '%dsname%(RADC)' CR AS\nSEND %outdir%\\SBA '%dsname%(SBA)' CR AS\nSEND %outdir%\\SBADC '%dsname%(SBADC)' CR AS\nSEND %outdir%\\SCREEND '%dsname%(SCREEND)' CR AS\nSEND %outdir%\\SCREENL '%dsname%(SCREENL)' CR AS\nSEND %outdir%\\SHOWREGS '%dsname%(SHOWREGS)' CR AS\nSEND %outdir%\\SVC235 '%dsname%(SVC235)' CR AS\nSEND %outdir%\\SVLNK '%dsname%(SVLNK)' CR AS\nSEND %outdir%\\S1 '%dsname%(S1)' CR AS\nSEND %outdir%\\TESTMAC '%dsname%(TESTMAC)' CR AS\nSEND %outdir%\\TODAY '%dsname%(TODAY)' CR AS\nSEND %outdir%\\TRACE#D '%dsname%(TRACE#D)' CR AS\nSEND %outdir%\\TRACE#L '%dsname%(TRACE#L)' CR AS\nSEND %outdir%\\TRACED '%dsname%(TRACED)' CR AS\nSEND %outdir%\\TRACEDA '%dsname%(TRACEDA)' CR AS\nSEND %outdir%\\TRACEIT '%dsname%(TRACEIT)' CR AS\nSEND %outdir%\\TRACEL '%dsname%(TRACEL)' CR AS\nSEND %outdir%\\TRACELA '%dsname%(TRACELA)' CR AS\nSEND %outdir%\\TRACER '%dsname%(TRACER)' CR AS\nSEND %outdir%\\UNPACK '%dsname%(UNPACK)' CR AS\nSEND %outdir%\\WCCDC '%dsname%(WCCDC)' CR AS\nSEND %outdir%\\WCCDCCOL '%dsname%(WCCDCCOL)' CR AS\nSEND %outdir%\\WCCDCMON '%dsname%(WCCDCMON)' CR AS\nSEND %outdir%\\WCCDCV '%dsname%(WCCDCV)' CR AS\nSEND %outdir%\\XESTATE# '%dsname%(XESTATE#)' CR AS\n:exit\n@echo off\nset outdir=\nset dsname=\nPull\nPull\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$TEXTLEN": {"ttr": 261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x009\\x00\\x96%\\x0f\\x00\\x96%\\x0f\\x13$\\x00\\x1f\\x00 \\x00\\x00\\xe3\\xf6\\xf6\\xd2\\xd2\\xd2@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1996-09-06T00:00:00", "modifydate": "1996-09-06T13:24:39", "lines": 31, "newlines": 32, "modlines": 0, "user": "T66KKK"}, "text": ".*--------------------------------------------------------------------*\n.* ESTABLISH LENGTH OF VARIABLE AND MOVE LENGTH                       *\n.*--------------------------------------------------------------------*\n&MSGL    SETA  K'&TRACE#\n         AIF   ('&TRACE#'(&MSGL,1) NE ')').MSGDTOK\n&MSGL1   SETA  &MSGL-1\n&APOST   SETA  0\n.LOOP1   ANOP\n         AIF   (&MSGL1 EQ  0).E4\n         AIF   ('&TRACE#'(&MSGL1,1) EQ ',').LOOP1E\n         AIF   ('&TRACE#'(&MSGL1,1) EQ '(').LOOP2E\n&MSGL1   SETA  &MSGL1-1\n         AGO   .LOOP1\n.LOOP1E  ANOP\n&APOST   SETA  &MSGL1\n&MSGL1   SETA  &MSGL1-1\n.LOOP2   ANOP\n         AIF   (&MSGL1 EQ 0).E4\n         AIF   ('&TRACE#'(&MSGL1,1) EQ '(').LOOP2E\n&MSGL1   SETA  &MSGL1-1\n         AGO   .LOOP2\n.LOOP2E  ANOP\n         AIF   (&APOST EQ 0).VARMSG    <======\n&TRACEL# SETC  '&TRACE#'(&MSGL1+1,&APOST-(&MSGL1+1))\n&TRACE#  SETC  '&TRACE#'(1,&MSGL1).'&TRACE#'(&APOST+1,&MSGL-&APOST)\n         AGO   .MSGDTOK\n.VARMSG  ANOP\n&TRACEL# SETC  '&TRACE#'(&MSGL1+1,&MSGL-(&MSGL1+1))\n&TRACE#  SETC  '&TRACE#'(1,&MSGL1-1)\n.MSGDTOK ANOP\n.*--------------------------------------------------------------------*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$TRACEGE": {"ttr": 263, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00#\\x00\\x96\"/\\x00\\x96%\\x7f\\x13(\\x00\\x9e\\x00S\\x00\\x00\\xe3\\xf6\\xf6\\xd2\\xd2\\xd2@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1996-08-09T00:00:00", "modifydate": "1996-09-13T13:28:23", "lines": 158, "newlines": 83, "modlines": 0, "user": "T66KKK"}, "text": "         MACRO\n&NAME    $TRACEGE &TYPE,           Macro type, START/FAIL              X\n               &FORMAT=CWATERM,    Test format                         X\n               &FAIL=,             Label if miss                       X\n               &CWAO=X'130',       CWA displacement compare start      X\n               &TCTTECIA=TCTTECIA, Term user area access               X\n               &LIST=Y,&HELP=N\n.*\n.*             &CWA=CWA+X'130',    CWA+X'130' access                  X\n.*             &TCTTETI=TCTTETI,   Term id    access                  X\n.*\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the '$TRACEGE' parameters   *\n* and it's use, pass parameter of 'HELP=Yes'.                         *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n* Macro to generate code to test for trace condition based on the     *\n* format supplied.                                                    *\n*                                                                     *\n* PARAMETERS:                                                         *\n* 1. Type             - Type of macro. It can be either a START or    *\n*                       FAIL. The should be paired and should not be  *\n*                       mixed unless the FAIL= option is used. The    *\n*                       default is FAIL as only a label is generated. *\n* 2. FAIL=nnnn        - Number suffix used to control generation of   *\n*                       the miss match                                *\n*                       labels. Without this parameter, the internal  *\n*                       index is used.                                *\n* 3. FORMAT=cccccccc  - The format of the test to be used.            *\n*                       The following options are available.          *\n*                       a) CWATERM - test for termid matching any non *\n*                                    X'00' at X'130' offset from the  *\n*                                    CWA. Up to 30 terminals can be   *\n*                                    defined and use LZAP to ZAP the  *\n*                                    CWA. This is the default.        *\n*                                    Requires addressability to       *\n*                                     . CWA                           *\n*                                     . TCTTE                         *\n*                                    or you may specify your own      *\n*                                    access to                        *\n*    CWA=expression   - any expression to access CWA+X'130' (default) *\n*                       eg. CWAX130 where the CWA is ORG'd            *\n*    TCTTETI=expr     - any expression to access the TCTTETI,         *\n*                       eg. TCTTETI-DFHTCTTE(5) where R5 -> TCTTE     *\n*                       b) CWAUSER - test for userid extracted from   *\n*                                    the TCTUA matching any non       *\n*                                    X'00' at X'130' offset from the  *\n*                                    CWA. Up to 10 users can be       *\n*                                    defined and use LZAP to ZAP the  *\n*                                    CWA. Each userid should be 8     *\n*                                    bytes long with trailing spaces. *\n*                                    Requires addressability to       *\n*                                     . CWA                           *\n*                                     . TCTTE                         *\n*                                    or you may specify your own      *\n*                                    access to                        *\n*    CWA=expression   - any expression to access CWA+X'130' (default) *\n*                       eg. CWAX130 where the CWA is ORG'd            *\n*    TCTTECIA=expr    - any expression to access the TCTTECIA,        *\n*                       eg. TCTTECIA-DFHTCTTE(5) where R5 -> TCTTE    *\n*                                    Requires the following DSECTs    *\n*                                     . TCTUA (KPW0908)               *\n*                                                                     *\n* NOTES - Registers 14 and 15 will be changed.                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         GBLC  &T$MISS\n         LCLC  &T$NAME,&T$LOOP,&T$HIT\n         LCLA  &PL\n.*\n         AIF   (T'&FAIL EQ 'O').NAMES      Use defults\n&T$MISS  SETC  '&FAIL'\n.*\n.NAMES   ANOP\n         AIF   (T'&TYPE EQ 'O').ENDTR      FAIL by default\n         AIF   ('&TYPE'(1,1) NE 'S').ENDTR FAIL specified\n&T$NAME  SETC  'T$'.'&SYSNDX'\n&T$LOOP  SETC  '&T$NAME'.'01'\n&T$HIT   SETC  '&T$NAME'.'02'\n&T$SAVE  SETC  '&T$NAME'.'03'\n         AIF   (T'&FAIL NE 'O').STARTTR    Use supplied label\n&T$MISS  SETC  '&T$NAME'.'09'\n.*--------------------------------------------------------------------*\n.* Start Trace condition testing                                      *\n.*--------------------------------------------------------------------*\n.STARTTR ANOP\n         AIF   (T'&FORMAT EQ 'O').CWATERM  'CWATERM' by default\n         AIF   ('&FORMAT' EQ 'CWATERM').CWATERM  'CWATERM'\n         AIF   ('&FORMAT' EQ 'CWAUSER').CWAUSER  'CWAUSER'\n         AGO   .ERR1\n.CWATERM ANOP\n         L     15,X'21C'(,0)           OLD TCB POINTER (FROM PSA)\n         L     15,X'D0'(,15)           TCB EXTENTION\n         L     15,X'14'(,15)           AFCB\n         L     15,X'08'(,15)           CSA 3.3 OR HIGHER\n         L     14,X'4C'(,15)           TCA (USER)\n         L     14,X'08'(,14)           TCTTE@\n         MVC   &T$SAVE.(4),0(14)       MOVE TERMID\n         L     15,X'E4'(,15)           CWA\n         LA    15,&CWAO.(15)           POINT TO CWA FILLER ZAPED\n         LA    14,30                   LOOP LIMIT\n         B     &T$LOOP                 BYPASS SAVE AREA\n&T$SAVE  DC    CL4'                    '               DATA SAVE AREA\n&T$LOOP  DS    0H\n         CLC   =X'00000000',0(15)      ZAPPED\n         BE    &T$MISS                 NO, BYPASS TRACING\n         CLC   0(4,15),&T$SAVE         MATCH TERMID\n         BE    &T$HIT                  REGISTER\n         LA    15,4(15)                NEXT FIELD\n         BCT   14,&T$LOOP              LOOP TILL END\n         B     &T$MISS                 REACHED LOOP LIMIT\n&T$HIT   DS    0H\n         AGO   .MEXIT1\n.*\n.*--------------------------------------------------------------------*\n.CWAUSER ANOP\n         B     &T$SAVE+L'&T$SAVE       BYPASS SAVE AREA\n         DS    0H                      HALF WORD ALINGMENT\n&T$SAVE  DC    CL8' '                  DATA SAVE AREA\n         L     15,&TCTTECIA            TERMINAL USER AREA\n         MVC   &T$SAVE.(7),TUASIGN-TCTUA(15) SAVE USERID (KPW0908)\n         LA    15,&CWA                 POINT TO CWA FILLER ZAPED\n         LA    14,10                   LOOP LIMIT\n&T$LOOP  DS    0H\n         CLC   =X'00000000',0(15)      ZAPPED\n         BE    &T$MISS                 NO, BYPASS TRACING\n         CLC   0(7,15),&T$SAVE         MATCH USERID\n         BE    &T$HIT                  REGISTER\n         LA    15,8(15)                NEXT FIELD\n         BCT   14,&T$LOOP              LOOP TILL END\n         B     &T$MISS                 REACHED LOOP LIMIT\n&T$HIT   DS    0H\n         AGO   .MEXIT1\n.*\n.*--------------------------------------------------------------------*\n.*\n.*--------------------------------------------------------------------*\n.*\n.ENDTR   ANOP\n&T$MISS  DS    0H\n         AGO   .MEXIT1\n.*--------------------------------------------------------------------*\n.ERR1    MNOTE 8,'FORMAT &FORMAT NOT VALID'\n         AGO   .MEXIT1\n.*--------------------------------------------------------------------*\n.MEXIT1  ANOP\n*---------------------------------------------------------------------*\n         POP PRINT\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$WTOGET": {"ttr": 513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x03\\x00\\x96\\x16O\\x00\\x96%\\x7f\\x17)\\x01k\\x00\\xe1\\x00\\x00\\xe3\\xf6\\xf6\\xd2\\xd2\\xd2@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1996-06-12T00:00:00", "modifydate": "1996-09-13T17:29:03", "lines": 363, "newlines": 225, "modlines": 0, "user": "T66KKK"}, "text": "         MACRO\n&NAME    $WTOGET  &PROG=Missing, Program name (or any 8 byte data)     +\n               &REGS=,           'ALL' or any single numeric register  +\n               &TRACE=,          Data area or quoted literal           +\n               &TRACEL=,         Trace length if not 56 bytes required +\n               &HEX=NO,          Convert data area to HEX b4 display   +\n               &TS=NO,           Write to CICS TSQ                     +\n               &CICS=NO,         Set to YES/AEF 1st time for TSQ       +\n               &YREGS=NO,        Include 'YREGS' on 1st. invocation    +\n               &CSECT=NO,        New CSECT (forces 1st. invocation)    +\n               &INIT=NO,         Used to init macro (w/o commands)     +\n               &LIST=NO,         Produce macro expansion list          +\n               &HELP=NO,         N/A (at this stage)                   +\n               &MF=              Only standard format available. This\n.*                               is used to control HEXCHMAC macro.\n.*------- WTO GE Trace -----------------------------------------------*\n.*                                                                    *\n.* NOTES:                                                             *\n.*  1. To place data to the TSQ, The first invocation of this macro   *\n.*     must have an entry of 'CICS=..'. Thereafter you only need the  *\n.*     'TS=..' parameter. You must specify the CICS= with every new   *\n.*     CSECT=YES entry.                                               *\n.*                                                                    *\n.*  2. If 'CICS' is set to YES, the EI program called is 'DFHEI1'. If *\n.*     it is set to 'AEF', the module called is 'S#EI1'. If it is set *\n.*     to 'NO' (the default) the approprite code is NOT generated.    *\n.*                                                                    *\n.*  3. PROGname can be used for alternative literal tracing.          *\n.*                                                                    *\n.*  4. You may combine the TRACE and TRACEL parameters by providing   *\n.*     syntactically correct address/length data on the TRACE         *\n.*     parameter, eg.                                                 *\n.*        $WTOGET ......,TRACE=SOURCE(15)... <- Implied length of 15  *\n.*        $WTOGET ......,TRACE=X'E4'(36,R3). <- Implied length of 36  *\n.*                                                                    *\n.*  5. The maximum trace length is 56 (excluding the program name).   *\n.*     If registers are traced and HEX conversion is in affect, the   *\n.*     trace length will be adjusted to remain within limits.         *\n.*                                                                    *\n.*  6. Uses macro 'HEXCHMAC'.                                         *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n         AIF   (T'&LIST EQ 'O').BYPRNT1\n         AIF   ('&LIST'(1,1) EQ 'Y').BYPRNT1\n         PUSH  PRINT\n         PRINT OFF\n.BYPRNT1 ANOP\n         GBLB  &WT1ST,&YR1ST,&CICSENV\n         GBLB  &XC1ST,&XC1NAME   <-- Used to synchronise HEXCHMAC macro\n         GBLB  &REGSFLG,&REGDFLG <-- Used to synchronise HEXCHMAC macro\n         GBLC  &WTOON,&WGENAME,&CICSEI\n         LCLA  &R#,&SR,&ER,&LM,&@@,&LTL,&LX,&LTR,&LL,&SUB1\n         LCLC  &PROGN,&DOTS,&TRACEN,&P,&REGSN,&RD,&TRACE#,&TRACEL#\n.*--------------------------------------------------------------------*\n.*\n&LTR     SETA  75-(8+11+9+4*2+1)            Length of trace with reg\n&LTL     SETA  75-(8+11)                    Length of trace 'literal'\n&DOTS    SETC  '.........'\n&PROGN   SETC  '&PROG.&DOTS'(1,8)' +'\n&TRACE#  SETC '&TRACE'                      Set work value\n&TRACEL# SETC '&TRACEL'                     Set work value\n.*--------------------------------------------------------------------*\n.* ESTABLISH LENGTH OF VARIABLE AND MOVE LENGTH IF PRESENT            *\n.*--------------------------------------------------------------------*\n&MSGL    SETA  K'&TRACE#\n         AIF   ('&TRACE#'(&MSGL,1) NE ')').MSGDTOK\n&MSGL1   SETA  &MSGL-1\n&APOST   SETA  0\n.LOOP1   ANOP\n         AIF   (&MSGL1 EQ  0).E4\n         AIF   ('&TRACE#'(&MSGL1,1) EQ ',').LOOP1E\n         AIF   ('&TRACE#'(&MSGL1,1) EQ '(').LOOP2E\n&MSGL1   SETA  &MSGL1-1\n         AGO   .LOOP1\n.LOOP1E  ANOP\n&APOST   SETA  &MSGL1\n&MSGL1   SETA  &MSGL1-1\n.LOOP2   ANOP\n         AIF   (&MSGL1 EQ 0).E4\n         AIF   ('&TRACE#'(&MSGL1,1) EQ '(').LOOP2E\n&MSGL1   SETA  &MSGL1-1\n         AGO   .LOOP2\n.LOOP2E  ANOP\n         AIF   (&APOST EQ 0).VARMSG    <======\n&TRACEL# SETC  '&TRACE#'(&MSGL1+1,&APOST-(&MSGL1+1))\n&TRACE#  SETC  '&TRACE#'(1,&MSGL1).'&TRACE#'(&APOST+1,&MSGL-&APOST)\n         AGO   .MSGDTOK\n.VARMSG  ANOP\n&TRACEL# SETC  '&TRACE#'(&MSGL1+1,&MSGL-(&MSGL1+1))\n&TRACE#  SETC  '&TRACE#'(1,&MSGL1-1)\n.MSGDTOK ANOP\n.*--------------------------------------------------------------------*\n.*\n         AIF   (&WT1ST).A$10           If not 1ST. time thru bypass\n&WGENAME SETC  'WGE'.'&SYSNDX'         Set generic name\n.A$10    ANOP\n         AIF   (T'&CSECT EQ 'O').A$20      Bypass if missing CSECT\n         AIF   ('&CSECT'(1,1) NE 'Y').A$20 Bypass if CSECT not 'YES'\n&WT1ST   SETB  0                       Reset to 1st. time thru\n&CICSENV SETB  0                       Reset to 1st. time thru\n.*--------------------------------------------------------------------*\n&XC1ST   SETB  0        <-----   Used to synchronise HEXCHMAC macro\n&XC1NAME SETB  0        <-----   Used to synchronise HEXCHMAC macro\n&REGSFLG SETB  0        <-----   Used to synchronise HEXCHMAC macro\n&REGDFLG SETB  0        <-----   Used to synchronise HEXCHMAC macro\n.*--------------------------------------------------------------------*\n&WGENAME SETC  'WGE'.'&SYSNDX'         Set generic name <---- Unique\n.A$20    ANOP\n.*--------------------------------------------------------------------*\n&TST     SETC  'N'\n         AIF   (T'&TS EQ 'O').WTOTS01       Bypass if not TS omitted\n&TST     SETC  '&TS'(1,1)\n.WTOTS01 ANOP\n.*--------------------------------------------------------------------*\n&P       SETC  '&WGENAME'\n&WGEBYP  SETC  '&P'.'0'\n&WGERS1  SETC  '&P'.'1'\n&WGERS2  SETC  '&P'.'2'\n&WGETGT  SETC  '&P'.'3'\n&WGEWTO1 SETC  '&P'.'4'\n&WGEWTO2 SETC  '&P'.'5'\n&WGEBTOA SETC  '&P'.'6'\n&WGEBTOI SETC  '&P'.'7'\n&WGEBTOP SETC  '&P'.'P'\n&WGTSLEN SETC  '&P'.'L'                 TS message length\n&WGTSFLG SETC  '&P'.'F'                 TS usage flag\n&WGTSL1  SETC  '&P'.'A'                 TS WRITEQ procedure\n.*--------------------------------------------------------------------*\n         AIF   (&WT1ST).A$30           If not 1ST. time thru bypass\n&WT1ST   SETB  1\n         AIF   ('&YREGS'(1,1) NE 'Y').A$31\n*---------------------------------------------------------------------*\n         AIF   (&YR1ST).A$31           If not 1ST. time thru bypass\n&YR1ST   SETB  1\n         YREGS                         , REGISTER EQUATES\n.A$31    ANOP\n&YR1ST   SETB  1\n         B     &WGEBYP                 BYPASS AROUND CONSTANT CODE/DATA\n&WGERS1  DS    16F                     REG SAVE AREA BEFORE BRANCH\n&WGERS2  DS    16F                     REG SAVE AREA BEFORE WTO\n&WGETGT  DC    CL&LTL.' '              DISPLAY WORK AREA\n         AIF   ('&CICS' EQ 'NO').NCENV01 Bypass if not CICS\n&WGTSLEN DC    H'75'                   TSQ MESSAGE LENGTH\n&WGTSFLG DC    C'N'                    TS USAGE FLAG (OFF)\n&CICSENV SETB  1                       Set CICS environment flag\n&CICSEI  SETC  'DFHEI1'                Set IBM module Address\n         AIF   ('&CICS' NE 'AEF').NCENV01 Bypass if not AEF ENV\n&CICSEI  SETC  'S#EI1'                 Set AEF module Address\n.NCENV01 ANOP\n*\n&WGEWTO1 DS    0H                      TRACE MOVE/DISPLAY\n         STM   0,15,&WGERS1            SAVE REGISTERS\n         MVC   &WGEBTOA+8+11(&LTL),&WGETGT\n         AIF   (NOT &CICSENV).NCENV02  Bypass if not CICS environment\n         CLI   &WGTSFLG,C'Y'           Q. TSQ USAGE\n         BE    &WGTSL1                    Y. PUT TO TS\n.NCENV02 ANOP\n         B     &WGEBTOA                BRANCH TO WTO\n*\n&WGEWTO2 DS    0H                      REGISTER MOVE/DISPLAY\n         STM   0,15,&WGERS1            SAVE REGISTERS\n         MVC   &WGEBTOA+8+11(8),&WGETGT\n         HEXCHMAC &WGETGT+8,&WGEBTOA+8+20,4,LIST=&LIST,MF=&MF\n         AIF   (NOT &CICSENV).NCENV03  Bypass if not CICS environment\n         CLI   &WGTSFLG,C'Y'           Q. TSQ USAGE\n         BE    &WGTSL1                    Y. PUT TO TS\n.NCENV03 ANOP\n         B     &WGEBTOA                BRANCH TO WTO\n*\n&WGEBTOA DS    0F                      WTO AND CLEAR FIELDS\n         WTO   '&PROGN                                                 +\n                                 ',ROUTCDE=11\n         ORG   &WGEBTOA+8              POINT PAST CONSTANTS\n&WGEBTOP DS    CL10                    PLACE FOR PROGRAM NAME\n         ORG                           , END REDEFINES\n&WGEBTOI DS    0H\n         AIF   (NOT &CICSENV).NCENV04  Bypass if not CICS environment\n         MVI   &WGTSFLG,C'N'           TURN TSQ USAGE OFF\n.NCENV04 ANOP\n         MVI   &WGEBTOA+8+11,C' '\n         MVC   &WGEBTOA+8+11+1(74-(8+11)),&WGEBTOA+8+11\n         MVI   &WGETGT,C' '\n         MVC   &WGETGT+1(L'&WGETGT-1),&WGETGT\n         LM    0,15,&WGERS1            RESTORE REGISTERS\n         BR    14                      RETURN TO CALLER\n         AIF   (NOT &CICSENV).NCENV05  Bypass if not CICS environment\n*\n&WGTSL1  DS    0H\n.*--------------------------------------------------------------------*\n.* Generated from the following statement\n.*--------------------------------------------------------------------*\n.*       EXEC  CICS WRITEQ TS QUEUE('$WTOGET') FROM(&WGEBTOA+8)\n.*          LENGTH(&WGTSLEN)\n.*\n.*--------------------------------------------------------------------*\n***********************************************************************\n*        DFHECALL =X'0A02E0000800004100',(CHA8,=CL8'$WTOGET'),(______RF*\n               ,&WGTSL1+8),(FB_2,&WGTSLEN)\n***********************************************************************\n         DS    0H                                                       01-DFHEC\n         LA    1,DFHEIPL                                                01-DFHEC\n         LA    14,=X'0A02E0000800004100'                                01-DFHEC\n         LA    15,=CL8'$WTOGET'                                         01-DFHEC\n         LA    0,&WGEBTOA+8                                             01-DFHEC\n         STM   14,0,0(1)                                                01-DFHEC\n         LA    14,&WGTSLEN                                              01-DFHEC\n         ST    14,12(,1)                                                01-DFHEC\n         OI    12(1),X'80'         LAST ARGUMENT                        01-DFHEC\n         L     15,=V(&CICSEI)      SET EI ADDRESS                       01-DFHEC\n         BALR  14,15               INVOKE EXEC INTERFACE                01-DFHEC\n         B     &WGEBTOI            GO INITIALISE WORK FIELDS\n.NCENV05 ANOP\n***********************************************************************\n&WGEBYP DS     0H\n***** HOW TO USE TRACE ************************************************\n*\n*        $WTOGET PROG=MYPROG,TRACE='AT LABEL MOVEIT'\n*        MVC   TARGET(10),SOURCE1\n*        MVC   TARGET+10(10),SOURCE2\n*        MVC   TARGET+20(10),SOURCE3\n*        B     TARGET+L'TARGET\n*TARGET  DS    CL30\n*        $WTOGET PROG=MYPROG,TRACE=TARGET,TRACEL=56\n*\n***** HOW TO USE REGISTER DISPLAY *************************************\n*\n*        $WTOGET PROG=MYPROG,REGS=9      Note : REGS must be numeric\n*        $WTOGET PROG=MYPROG,REGS=ALL           or 'ALL'\n*\n***********************************************************************\n*\n         AIF   (T'&INIT EQ 'O').A$30        Continue if INIT omitted\n         AIF   ('&INIT'(1,1) EQ 'Y').MEXIT  Exit if init specified\n.A$30    ANOP\n.*--------------------------------------------------------------------*\n&LX      SETA  0                            Set HEX trace length to 0\n         AIF (T'&TRACE# EQ 'O').REGS$$$     Bypass if trace not present\n&LL      SETA  &LTL                         Set HEX length limit\n         AIF (T'&REGS EQ 'O').TABSLOK       Bypass if reg not required\n&LL      SETA  &LTR                         Reset length to allow regs\n.TABSLOK ANOP\n&TRACEN  SETC '&TRACE#'                     Set work value\n&LM      SETA  &LL                          Set default length\n         AIF   (T'&TRACEL# EQ 'O').HAVTRL1  Bypass if length omitted\n         AIF   (&TRACEL# GE &LL).HAVTRL1    Bypass if length > limit\n&LM      SETA  &TRACEL#                     Set required length\n.HAVTRL1 ANOP\n.*--------------------------------------------------------------------*\n.* Process HEX trace request. It is assumed that HEX conversion is    *\n.* required on data area as we would already know the HEX value of    *\n.* a literal constant.                                                *\n.* It is also assumed that if no trace length is given the full       *\n.* limit is to be used. Variable &XL will be used to determine if     *\n.* HEX conversion is requited (ie. &XL > 0).                          *\n.*--------------------------------------------------------------------*\n         AIF   (T'&HEX EQ 'O').HEXLOK1      Bypass if HEX missing\n         AIF   ('&HEX'(1,1) EQ 'N').HEXLOK1 Bypass if no HEX\n&LX      SETA  &LM                          Set HEX length to sup/def\n         AIF   (&LX LE &LL/2).HEXLOK1       Bypass if HEX len 1/2 limit\n&LX      SETA  &LL/2                        Reset to limit\n.HEXLOK1 ANOP\n.*       B     *+20+4                        Use for debug\n.*       DC    CL20'LL=&LL LM=&LM LX=&LX'    Use for debug\n.*--------------------------------------------------------------------*\n         AIF   ('&TRACE#'(1,1) NE '''').KEEPL1 Bypass if not literal\n         AIF   (T'&TRACEL# NE 'O').HAVTRL3  Bypass if have length\n&LM      SETA  K'&TRACE#-2                  Set length w/o quotes\n.HAVTRL3 ANOP\n&TRACEN  SETC '&TRACE#'(2,&LM)              Remove quotes\n         AIF   (&LM LE &LL).KEEPL1          Continue if length < limit\n&LM      SETA  &LL                          Set default length\n.KEEPL1  ANOP\n         AIF   ('&TRACE#'(1,1) NE '(').KEEPL2 Bypass if not register\n&TRACEN  SETC   '0('.'&TRACE#'(2,1)         Set trace\n         AIF   ('&TRACE#'(3,1) EQ ')').FULLRL1 Have full register\n&TRACEN  SETC   '&TRACEN'.'&TRACE#'(3,1)    Set trace\n.FULLRL1 ANOP\n&TRACEN  SETC   '&TRACEN'.')'               Set trace\n.KEEPL2  ANOP\n.*--------------------------------------------------------------------*\n.*\n.REGS$$$ ANOP\n&REGSN   SETC  '&REGS'\n         AIF (T'&REGSN NE 'O').PREGS  Process REGS if present\n         AIF (T'&TRACE# NE 'O').TRACE Process TRACE if present\n&REGSN   SETC  'ALL'     Set to ALL if no REGS or TRACE arguments\n.*\n.PREGS   ANOP\n***********************************************************************\n*     PRINT REGISTER(S)                                               *\n***********************************************************************\n&SR      SETA  0\n&ER      SETA  15\n         AIF   (T'&REGS EQ 'O').SENDP\n         AIF   ('&REGS' EQ 'ALL').SENDP\n&SR      SETA  &REGS\n&ER      SETA  &SR\n.SENDP   ANOP\n&R#      SETA  &SR\n         STM   0,15,&WGERS2            SAVE REGISTERS\n         MVC   &WGEBTOP,=C'&PROGN'     MOVE PROGRAM NAME\n.WRLOOP  ANOP\n         AIF   (&R# GT &ER).WRLOOPE    Exit loop after limit\n&RD      SETC  '&R#., '(1,3)\n         MVC   &WGETGT.(8),=CL8'R&RD. -->'\n.*--------------------------------------------------------------------*\n         AIF   (T'&TRACEN EQ 'O').NORTRC       Bypass if no trace\n         AIF   ('&TRACE#'(1,1) NE '''').REGTRNQ TRACE not quoted\n         MVC   &WGEBTOA+8+20+4*2+1(&LM.),=CL&LM.'&TRACEN.'\n         AGO   .NORTRC\n.REGTRNQ ANOP\n         AIF   (&LX EQ 0).REGTRMV      Bypass if HEX length missing\n         HEXCHMAC &TRACE#,&WGEBTOA+8+20+4*2+1,&LX,MF=&MF,LIST=&LIST\n         AGO   .NORTRC\n.REGTRMV ANOP\n         MVC   &WGEBTOA+8+20+4*2+1(&LM.),&TRACEN\n.*--------------------------------------------------------------------*\n.NORTRC  ANOP\n         ST    &R#.,&WGETGT+8          STORE REGISTER\n         AIF   (NOT &CICSENV).NCENV06  Bypass if not CICS environment\n         MVI   &WGTSFLG,C'&TST'        SET TSQ USAGE\n.NCENV06 ANOP\n         BAL   14,&WGEWTO2             GO WTO IT\n&R#      SETA  &R#+1\n         LM    0,15,&WGERS2            RESTORE REGISTERS\n         AGO   .WRLOOP\n.WRLOOPE ANOP\n         AGO   .MEXIT\n.*\n.*-------------------------------------------------------------------*\n.*\n.TRACE   ANOP\n         STM   0,15,&WGERS2            SAVE REGISTERS\n         MVC   &WGEBTOP,=C'&PROGN'     MOVE PROGRAM NAME\n         AIF   ('&TRACE#'(1,1) NE '''').PUTRACD\n         MVC   &WGETGT.(&LM.),=CL&LM.'&TRACEN'\n         AGO   .TRACEEX                EXIT TRACE PROCESSING\n.PUTRACD ANOP\n         AIF   (&LX EQ 0).PUTTRMV      Bypass if HEX length missing\n         HEXCHMAC &TRACE#,&WGETGT,&LX,MF=&MF,LIST=&LIST\n         AGO   .TRACEEX                EXIT TRACE PROCESSING\n.PUTTRMV ANOP\n         MVC   &WGETGT.(&LM.),&TRACEN MOVE DATA TO TRACE\n.TRACEEX ANOP\n         AIF   (NOT &CICSENV).NCENV07  Bypass if not CICS environment\n         MVI   &WGTSFLG,C'&TST'        SET TSQ USAGE\n.NCENV07 ANOP\n         BAL   14,&WGEWTO1             GO WTO IT\n         LM    0,15,&WGERS2            RESTORE REGISTERS\n         AGO   .MEXIT\n*\n.*\n.*-------------------------------------------------------------------*\n.*  Errors\n.*-------------------------------------------------------------------*\n.E001    MNOTE 12,'Literal with REGS request must be qouted'\n         AGO   .MEXIT\n.*\n.MEXIT   ANOP\n         AIF   ('&LIST'(1,1) EQ 'Y').BYPRNT2\n         POP   PRINT\n.BYPRNT2 ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#$WTOGET": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x13\\x00\\x96%\\x0f\\x00\\x96%\\x0f\\x13\\x08\\x01>\\x01>\\x00\\x00\\xe3\\xf6\\xf6\\xd2\\xd2\\xd2@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1996-09-06T00:00:00", "modifydate": "1996-09-06T13:08:13", "lines": 318, "newlines": 318, "modlines": 0, "user": "T66KKK"}, "text": "         MACRO\n&NAME    $WTOGET  &PROG=Missing, Program name (or any 8 byte data)     +\n               &REGS=,           'ALL' or any single numeric register  +\n               &TRACE=,          Data area or quoted literal           +\n               &TRACEL=,         Trace length if not 36 bytes required +\n               &HEX=NO,          Convert data area to HEX b4 display   +\n               &TS=NO,           Write to CICS TSQ                     +\n               &CICS=NO,         Set to YES/AEF 1st time 4 TSQ         +\n               &YREGS=NO,        Include 'YREGS' on 1st. invocation    +\n               &CSECT=NO,        New CSECT (forces 1st. invocation)    +\n               &INIT=NO,         Used to initialise macro              +\n               &LIST=NO,         Produce macro expansion list          +\n               &HELP=NO,         N/A (at this stage)                   +\n               &MF=              Only standard format available. It is\n.*                               used to control HEXCHMAC macro.\n.*------- WTO GE Trace -----------------------------------------------*\n.*                                                                    *\n.* To place data to the TSQ, The first invocation of this macro must  *\n.* have an entry of 'CICS=..'. Thereafter you only need the 'TS=..'   *\n.* parameter. You must specify the CICS= with every new CSECT=YES     *\n.* entry.                                                             *\n.*                                                                    *\n.* If 'CICS' is set to YES, the EI program called is 'DFHEI1'. If it  *\n.* is set to 'AEF', the module called is 'S#EI1'. If it is set to 'NO'*\n.* the approprite code is NOT generated.                              *\n.*                                                                    *\n.* NOTE - PROGname can be used for alternative literal tracing.       *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n         AIF   (T'&LIST EQ 'O').BYPRNT1\n         AIF   ('&LIST'(1,1) EQ 'Y').BYPRNT1\n         PUSH  PRINT\n         PRINT OFF\n.BYPRNT1 ANOP\n         GBLB  &WT1ST,&YR1ST,&CICSENV\n         GBLB  &XC1ST,&XC1NAME   <-- Used to synchronise HEXCHMAC macro\n         GBLB  &REGSFLG,&REGDFLG <-- Used to synchronise HEXCHMAC macro\n         GBLC  &WTOON,&WGENAME,&CICSEI\n         LCLA  &R#,&SR,&ER,&LM,&@@,&LTL,&LX,&LTR,&LL,&SUB1\n         LCLC  &PROGN,&DOTS,&TRACEN,&P,&REGSN,&RD\n.*--------------------------------------------------------------------*\n.*\n&LTR     SETA  75-(8+11+9+4*2+1)            Length of trace with reg\n&LTL     SETA  75-(8+11)                    Length of trace 'literal'\n&DOTS    SETC  '.........'\n&PROGN   SETC  '&PROG.&DOTS'(1,8)' +'\n.*\n         AIF   (&WT1ST).A$10           If not 1ST. time thru bypass\n&WGENAME SETC  'WGE'.'&SYSNDX'         Set generic name\n.A$10    ANOP\n         AIF   (T'&CSECT EQ 'O').A$20      Bypass if missing CSECT\n         AIF   ('&CSECT'(1,1) NE 'Y').A$20 Bypass if CSECT not 'YES'\n&WT1ST   SETB  0                       Reset to 1st. time thru\n&CICSENV SETB  0                       Reset to 1st. time thru\n.*--------------------------------------------------------------------*\n&XC1ST   SETB  0        <-----   Used to synchronise HEXCHMAC macro\n&XC1NAME SETB  0        <-----   Used to synchronise HEXCHMAC macro\n&REGSFLG SETB  0        <-----   Used to synchronise HEXCHMAC macro\n&REGDFLG SETB  0        <-----   Used to synchronise HEXCHMAC macro\n.*--------------------------------------------------------------------*\n&WGENAME SETC  'WGE'.'&SYSNDX'         Set generic name <---- Unique\n.A$20    ANOP\n.*--------------------------------------------------------------------*\n&TST     SETC  'N'\n         AIF   (T'&TS EQ 'O').WTOTS01       Bypass if not TS omitted\n&TST     SETC  '&TS'(1,1)\n.WTOTS01 ANOP\n.*--------------------------------------------------------------------*\n&P       SETC  '&WGENAME'\n&WGEBYP  SETC  '&P'.'0'\n&WGERS1  SETC  '&P'.'1'\n&WGERS2  SETC  '&P'.'2'\n&WGETGT  SETC  '&P'.'3'\n&WGEWTO1 SETC  '&P'.'4'\n&WGEWTO2 SETC  '&P'.'5'\n&WGEBTOA SETC  '&P'.'6'\n&WGEBTOI SETC  '&P'.'7'\n&WGEBTOP SETC  '&P'.'P'\n&WGTSLEN SETC  '&P'.'L'                 TS message length\n&WGTSFLG SETC  '&P'.'F'                 TS usage flag\n&WGTSL1  SETC  '&P'.'A'                 TS WRITEQ procedure\n.*--------------------------------------------------------------------*\n         AIF   (&WT1ST).A$30           If not 1ST. time thru bypass\n&WT1ST   SETB  1\n         AIF   ('&YREGS'(1,1) NE 'Y').A$31\n*---------------------------------------------------------------------*\n         AIF   (&YR1ST).A$31           If not 1ST. time thru bypass\n&YR1ST   SETB  1\n         YREGS                         , REGISTER EQUATES\n.A$31    ANOP\n&YR1ST   SETB  1\n         B     &WGEBYP                 BYPASS AROUND CONSTANT CODE/DATA\n&WGERS1  DS    16F                     REG SAVE AREA BEFORE BRANCH\n&WGERS2  DS    16F                     REG SAVE AREA BEFORE WTO\n&WGETGT  DC    CL&LTL.' '              DISPLAY WORK AREA\n         AIF   ('&CICS' EQ 'NO').NCENV01 Bypass if not CICS\n&WGTSLEN DC    H'75'                   TSQ MESSAGE LENGTH\n&WGTSFLG DC    C'N'                    TS USAGE FLAG (OFF)\n&CICSENV SETB  1                       Set CICS environment flag\n&CICSEI  SETC  'DFHEI1'                Set IBM module Address\n         AIF   ('&CICS' NE 'AEF').NCENV01 Bypass if not AEF ENV\n&CICSEI  SETC  'S#EI1'                 Set AEF module Address\n.NCENV01 ANOP\n*\n&WGEWTO1 DS    0H                      TRACE MOVE/DISPLAY\n         STM   0,15,&WGERS1            SAVE REGISTERS\n         MVC   &WGEBTOA+8+11(&LTL),&WGETGT\n         AIF   (NOT &CICSENV).NCENV02  Bypass if not CICS environment\n         CLI   &WGTSFLG,C'Y'           Q. TSQ USAGE\n         BE    &WGTSL1                    Y. PUT TO TS\n.NCENV02 ANOP\n         B     &WGEBTOA                BRANCH TO WTO\n*\n&WGEWTO2 DS    0H                      REGISTER MOVE/DISPLAY\n         STM   0,15,&WGERS1            SAVE REGISTERS\n         MVC   &WGEBTOA+8+11(8),&WGETGT\n         HEXCHMAC &WGETGT+8,&WGEBTOA+8+20,4,LIST=&LIST,MF=&MF\n         AIF   (NOT &CICSENV).NCENV03  Bypass if not CICS environment\n         CLI   &WGTSFLG,C'Y'           Q. TSQ USAGE\n         BE    &WGTSL1                    Y. PUT TO TS\n.NCENV03 ANOP\n         B     &WGEBTOA                BRANCH TO WTO\n*\n&WGEBTOA DS    0F                      WTO AND CLEAR FIELDS\n         WTO   '&PROGN                                                 +\n                                 ',ROUTCDE=11\n         ORG   &WGEBTOA+8              POINT PAST CONSTANTS\n&WGEBTOP DS    CL10                    PLACE FOR PROGRAM NAME\n         ORG                           , END REDEFINES\n&WGEBTOI DS    0H\n         AIF   (NOT &CICSENV).NCENV04  Bypass if not CICS environment\n         MVI   &WGTSFLG,C'N'           TURN TSQ USAGE OFF\n.NCENV04 ANOP\n         MVI   &WGEBTOA+8+11,C' '\n         MVC   &WGEBTOA+8+11+1(74-(8+11)),&WGEBTOA+8+11\n         MVI   &WGETGT,C' '\n         MVC   &WGETGT+1(L'&WGETGT-1),&WGETGT\n         LM    0,15,&WGERS1            RESTORE REGISTERS\n         BR    14                      RETURN TO CALLER\n         AIF   (NOT &CICSENV).NCENV05  Bypass if not CICS environment\n*\n&WGTSL1  DS    0H\n.*--------------------------------------------------------------------*\n.* Generated from the following statement\n.*--------------------------------------------------------------------*\n.*       EXEC  CICS WRITEQ TS QUEUE('$WTOGET') FROM(&WGEBTOA+8)\n.*          LENGTH(&WGTSLEN)\n.*\n.*--------------------------------------------------------------------*\n***********************************************************************\n*        DFHECALL =X'0A02E0000800004100',(CHA8,=CL8'$WTOGET'),(______RF*\n               ,&WGTSL1+8),(FB_2,&WGTSLEN)\n***********************************************************************\n         DS    0H                                                       01-DFHEC\n         LA    1,DFHEIPL                                                01-DFHEC\n         LA    14,=X'0A02E0000800004100'                                01-DFHEC\n         LA    15,=CL8'$WTOGET'                                         01-DFHEC\n         LA    0,&WGEBTOA+8                                             01-DFHEC\n         STM   14,0,0(1)                                                01-DFHEC\n         LA    14,&WGTSLEN                                              01-DFHEC\n         ST    14,12(,1)                                                01-DFHEC\n         OI    12(1),X'80'         LAST ARGUMENT                        01-DFHEC\n         L     15,=V(&CICSEI)      SET EI ADDRESS                       01-DFHEC\n         BALR  14,15               INVOKE EXEC INTERFACE                01-DFHEC\n         B     &WGEBTOI            GO INITIALISE WORK FIELDS\n.NCENV05 ANOP\n***********************************************************************\n&WGEBYP DS     0H\n***** HOW TO USE TRACE ************************************************\n*\n*        $WTOGET PROG=MYPROG,TRACE='AT LABEL MOVEIT'\n*        MVC   TARGET(10),SOURCE1\n*        MVC   TARGET+10(10),SOURCE2\n*        MVC   TARGET+20(10),SOURCE3\n*        B     TARGET+L'TARGET\n*TARGET  DS    CL30\n*        $WTOGET PROG=MYPROG,TRACE=TARGET,TRACEL=56\n*\n***** HOW TO USE REGISTER DISPLAY *************************************\n*\n*        $WTOGET PROG=MYPROG,REGS=9      Note : REGS must be numeric\n*        $WTOGET PROG=MYPROG,REGS=ALL           or 'ALL'\n*\n***********************************************************************\n*\n         AIF   (T'&INIT EQ 'O').A$30        Continue if INIT omitted\n         AIF   ('&INIT'(1,1) EQ 'Y').MEXIT  Exit if init specified\n.A$30    ANOP\n.*--------------------------------------------------------------------*\n&LX      SETA  0                            Set HEX trace length to 0\n         AIF (T'&TRACE EQ 'O').REGS$$$      Bypass if trace not present\n&LL      SETA  &LTL                         Set HEX length limit\n         AIF (T'&REGS EQ 'O').TABSLOK       Bypass if reg not required\n&LL      SETA  &LTR                         Reset length to allow regs\n.TABSLOK ANOP\n&TRACEN  SETC '&TRACE'                      Set work value\n&LM      SETA  &LL                          Set default length\n         AIF   (T'&TRACEL EQ 'O').HAVTRL1   Bypass if length omitted\n         AIF   (&TRACEL GE &LL).HAVTRL1     Bypass if length > limit\n&LM      SETA  &TRACEL                      Set required length\n.HAVTRL1 ANOP\n.*--------------------------------------------------------------------*\n.* Process HEX trace request. It is assumed that HEX conversion is    *\n.* required on data area as we would already know the HEX value of    *\n.* a literal constant.                                                *\n.* It is also assumed that if no trace length is given the full       *\n.* limit is to be used. Variable &XL will be used to determine if     *\n.* HEX conversion is requited (ie. &XL > 0).                          *\n.*--------------------------------------------------------------------*\n         AIF   (T'&HEX EQ 'O').HEXLOK1      Bypass if HEX missing\n         AIF   ('&HEX'(1,1) EQ 'N').HEXLOK1 Bypass if no HEX\n&LX      SETA  &LM                          Set HEX length to sup/def\n         AIF   (&LX LE &LL/2).HEXLOK1       Bypass if HEX len 1/2 limit\n&LX      SETA  &LL/2                        Reset to limit\n.HEXLOK1 ANOP\n.*       B     *+20+4                        Use for debug\n.*       DC    CL20'LL=&LL LM=&LM LX=&LX'    Use for debug\n.*--------------------------------------------------------------------*\n         AIF   ('&TRACE'(1,1) NE '''').KEEPL1 Bypass if not literal\n         AIF   (T'&TRACEL NE 'O').HAVTRL3   Bypass if have length\n&LM      SETA  K'&TRACE-2                   Set length w/o quotes\n.HAVTRL3 ANOP\n&TRACEN  SETC '&TRACE'(2,&LM)               Remove quotes\n         AIF   (&LM LE &LL).KEEPL1          Continue if length < limit\n&LM      SETA  &LL                          Set default length\n.KEEPL1  ANOP\n         AIF   ('&TRACE'(1,1) NE '(').KEEPL2 Bypass if not register\n&TRACEN  SETC  '0('.'&TRACE'(2,1)            Set trace\n         AIF   ('&TRACE'(3,1) EQ ')').FULLRL1 Have full register\n&TRACEN  SETC  '&TRACEN'.'&TRACE'(3,1)       Set trace\n.FULLRL1 ANOP\n&TRACEN  SETC  '&TRACEN'.')'                 Set trace\n.KEEPL2  ANOP\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.*\n.REGS$$$ ANOP\n&REGSN   SETC  '&REGS'\n         AIF (T'&REGSN NE 'O').PREGS  Process REGS if present\n         AIF (T'&TRACE NE 'O').TRACE  Process TRACE if present\n&REGSN   SETC  'ALL'     Set to ALL if no REGS or TRACE arguments\n.*\n.PREGS   ANOP\n***********************************************************************\n*     PRINT REGISTER(S)                                               *\n***********************************************************************\n&SR      SETA  0\n&ER      SETA  15\n         AIF   (T'&REGS EQ 'O').SENDP\n         AIF   ('&REGS' EQ 'ALL').SENDP\n&SR      SETA  &REGS\n&ER      SETA  &SR\n.SENDP   ANOP\n&R#      SETA  &SR\n         STM   0,15,&WGERS2            SAVE REGISTERS\n         MVC   &WGEBTOP,=C'&PROGN'     MOVE PROGRAM NAME\n.WRLOOP  ANOP\n         AIF   (&R# GT &ER).WRLOOPE    Exit loop after limit\n&RD      SETC  '&R#., '(1,3)\n         MVC   &WGETGT.(8),=CL8'R&RD. -->'\n.*--------------------------------------------------------------------*\n         AIF   (T'&TRACEN EQ 'O').NORTRC       Bypass if no trace\n         AIF   ('&TRACE'(1,1) NE '''').REGTRNQ TRACE not quoted\n         MVC   &WGEBTOA+8+20+4*2+1(&LM.),=CL&LM.'&TRACEN.'\n         AGO   .NORTRC\n.REGTRNQ ANOP\n         AIF   (&LX EQ 0).REGTRMV      Bypass if HEX length missing\n         HEXCHMAC &TRACE,&WGEBTOA+8+20+4*2+1,&LX,MF=&MF\n         AGO   .NORTRC\n.REGTRMV ANOP\n         MVC   &WGEBTOA+8+20+4*2+1(&LM.),&TRACEN\n.*--------------------------------------------------------------------*\n.NORTRC  ANOP\n         ST    &R#.,&WGETGT+8          STORE REGISTER\n         AIF   (NOT &CICSENV).NCENV06  Bypass if not CICS environment\n         MVI   &WGTSFLG,C'&TST'        SET TSQ USAGE\n.NCENV06 ANOP\n         BAL   14,&WGEWTO2             GO WTO IT\n&R#      SETA  &R#+1\n         LM    0,15,&WGERS2            RESTORE REGISTERS\n         AGO   .WRLOOP\n.WRLOOPE ANOP\n         AGO   .MEXIT\n.*\n.*-------------------------------------------------------------------*\n.*\n.TRACE   ANOP\n         STM   0,15,&WGERS2            SAVE REGISTERS\n         MVC   &WGEBTOP,=C'&PROGN'     MOVE PROGRAM NAME\n         AIF   ('&TRACE'(1,1) NE '''').PUTRACD\n         MVC   &WGETGT.(&LM.),=CL&LM.'&TRACEN'\n         AGO   .TRACEEX                EXIT TRACE PROCESSING\n.PUTRACD ANOP\n         AIF   (&LX EQ 0).PUTTRMV      Bypass if HEX length missing\n         HEXCHMAC &TRACE,&WGETGT,&LX,MF=&MF\n         AGO   .TRACEEX                EXIT TRACE PROCESSING\n.PUTTRMV ANOP\n         MVC   &WGETGT.(&LM.),&TRACEN  MOVE DATA TO TRACE\n.TRACEEX ANOP\n         AIF   (NOT &CICSENV).NCENV07  Bypass if not CICS environment\n         MVI   &WGTSFLG,C'&TST'        SET TSQ USAGE\n.NCENV07 ANOP\n         BAL   14,&WGEWTO1             GO WTO IT\n         LM    0,15,&WGERS2            RESTORE REGISTERS\n         AGO   .MEXIT\n*\n.*\n.*-------------------------------------------------------------------*\n.*  Errors\n.*-------------------------------------------------------------------*\n.E001    MNOTE 12,'Literal with REGS request must be qouted'\n         AGO   .MEXIT\n.*\n.MEXIT   ANOP\n         AIF   ('&LIST'(1,1) EQ 'Y').BYPRNT2\n         POP   PRINT\n.BYPRNT2 ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#ESTATE#": {"ttr": 7171, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x89\\x10\\x8f\\x00\\x89#\\x0f\\x15I\\x00\\x9e\\x00\\x9e\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xc1\\xd2@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1989-04-18T00:00:00", "modifydate": "1989-08-18T15:49:00", "lines": 158, "newlines": 158, "modlines": 0, "user": "TECHAK"}, "text": "*\n**       TITLE:    TSO/CICS CROSS-MEMORY MODULE\n**       SYSTEM:   ISPF/MONITOR 1.0.0\n**       MODULE:   CICSXEST\n**       PROGRAM:  CICSXMEM\n**       FUNCTION: TO INTERCEPT ANY ABENDS THAT MAY BE ENCOUNTERED WHEN\n**                 TRYING TO ACCESS THE CICS ADDRESS SPACE THRU CROSS-\n**                 MEMORY.\n**                 SET UP BY ISSUING THE \"ESTAE\" MACRO IMMEDIATELY\n**                 BEFORE ENTERING KEY ZERO AND CHANGING AUTHORISATION\n**                 INDEX.\n**                 TURNED OFF IMMEDIATELY AFTER DATA HAS BEEN MOVED\n**                 AND RETURNING TO PROBLEM STATE SO THAT NORMAL\n**                 PROGRAM LOGIC BUGS ARE NOT INTERCEPTED.\n**\n**                 THE MAIN ABENDS THAT THIS MODULE INTERCEPS ARE:\n**                    0C4 - ADDRESS SPACE NOT AVAILABLE TO THE REGION\n**                          BEING MONITORED\n**                    ??? - THE ABEND CODE FOR AN ADDRESS SPACE BEING\n**                          UNAVAILABLE DUE TO BEING SWAPPED OUT.\n**                 THE MAIN FUNCTION IS TO INTERCEPT THE SWAPPED OUT\n**                 CONDITION, ISSUE A \"WAIT\" (STIMER) AND TRY AGAIN AT\n**                 A LATER INTERVAL, HOPING CICS HAS FORCED A SWAP IN.\n**\n**       AUTHOR:   A. KARA\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nCICSXEST CSECT\n*        PRINT NOGEN\n         LR    R2,R15                   R1 SET AS BASE\n         USING CICSXEST,R2              BASE REGISTER\n         USING COMMONA,R10              ADDRESABILITY TO COMMON AREA\nSTART    DS    0H\n         LM    R10,R13,12(R15)          RESTORE REGISTERS FROM \"BASES1\"\n         B     MOVEERR                  BYPASS R10 - R13 SAVE AREA\nBASES#1  DS    4F\n*---------------------------------------------------------------------*\nMOVEERR  DS    0H\n         STM   R0,R13,BASES#2           STORE REGISTERS INTO \"BASES2\"\n*---------------------------------------------------------------------*\n*                                                                     *\n*        CONTROL GETS HERE IF THE AN ABEND OCCURED DURING A MOVE      *\n*        FROM SECONDARY TO PRIMARY. USUALLY CAUSED BY AN ADDRESS      *\n*        EXCEPTION ERROR.                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         CL    R0,=F'12'                  Q. SDWA CREATED BY RTM2\n         BE    MESTAER2                      N. DO NOT RETRY\n*---------------------------------------------------------------------*\n* SDWA OK.\n*---------------------------------------------------------------------*\n         LR    R9,R1\n         USING SDWA,R9                    SDWA MAPPING\n         TM    SDWAERRD,SDWACLUP          Q. IS RETRY POSSIBLE\n         BNZ   NORETRY2                      N. DO NOT RETRY\n*        BNZ   NORETRY1                      N. DO NOT RETRY\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DECIDE WHETHER OR NOT WE CAN RETRY. RETRY IS ONLY ALLOWED    *\n*        FOR 0CX SYSTEM ABENDS.                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         L     R3,SDWAABCC                LOAD USER/SYSTEM ABEND CODE\n         SRL   R3,12                      MOVE OUT USER CODE.\n         STCM  R3,3,SYSRCODE              EXTRACT SYSTEM RETURN CODE.\n         NC    SYSRCODE(2),=X'0FFF'       ISOLATE RETURN CODE.\n         CLI   SYSRCODE,X'00'             CHECK FOR SYSTEM\n         BNE   NORETRY1                      ABEND 0CX.\n         TM    SYSRCODE+1,X'C0'                 AND IF NO =\n         BNO   NORETRY1                            NO RETRY\n         B     CONT#10                    BYPASS\nNORETRY1 DS    0H\n         XC    RETRY,RETRY                CANCEL NO OF RETRIES LEFT\n         B     NORETRY2                  <=======\nCONT#10  DS    0H\n*---------------------------------------------------------------------*\n*   PERFORM A DUMMY RETRY. USED TO CLEAR WORK AREAS BEFORE PHYSICAL   *\n*   RETRY.                                                            *\n*---------------------------------------------------------------------*\n         LA    R0,MESTAER\n         LA    R15,4\n         CLC   TARGETX(6),=C'DUMPIT'     Q. DUMP REQUESTED\n         BE    DUMPIT1                      N. GO ISSUE DUMP MACRO\n         SETRP FRESDWA=YES,RC=4,RETADDR=MESTAER,DUMP=NO\n         B     RETURN1                   BUPASS DUMP RETRY\nDUMPIT1  DS    0H\n         SETRP FRESDWA=YES,RC=4,RETADDR=MESTAER,DUMP=YES\nRETURN1  DS    0H\n         BR    R14                       RETURN\nNORETRY2 DS    0H\n         CLC   TARGETX(6),=C'DUMPIT'     Q. DUMP REQUESTED\n         BE    DUMPIT2                      N. GO ISSUE DUMP MACRO\n         SETRP WKAREA=(R9),RC=0,DUMP=NO\n         B     RETURN2                   BUPASS DUMP RETRY\nDUMPIT2  DS    0H\n         SETRP WKAREA=(R9),RC=0,DUMP=YES\nRETURN2  DS    0H\n         LA    R15,MESTAER               ADDRESABILITY BY R15\nMESTAER  DS    0F\n         LM    R0,R13,8(R15)             RESTORE REGISTERS\n         B     MESTAER2\nBASES#2  DS    14F\nMESTAER2 DS    0H\n*---------------------------------------------------------------------*\n         MODESET KEY=ZERO               SUPERVISOR STATE\n         XR    R1,R1                    CLEAR REGISTER\n         ICM   R1,B'0011',PRIMASID      GET PRIMARY ASID\n         SSAR  R1                       SET SECONDARY BACK TO PRIMARY\n         L     R0,PRIMAX                GET PRIMARY AX\n         AXSET AX=(0)\n         MODESET KEY=NZERO              PROBLEM STATE\n         STAX  DEFER=NO                 TURN ATTENTION INTERRUPT ON\n*---------------------------------------------------------------------*\n         CLC   RETRY(2),=H'0'           Q. HAD ALL RETRIES BEEN MADE\n         BNH   THATSIT                     Y. SIGNAL ERROR\n         ESTAE 0                        TURN ESTAE OFF (RETRY ON AGAIN)\n         LH    R1,RETRY                    N. DECREMENT RETRY\n         BCTR  R1,0                           BY 1\n         STH   R1,RETRY                       AND SAVE\n         STIMER WAIT,DINTVL=WTIME       WAIT 5/100 OF A SEC\n         L     R1,RETRYADR              LOAD RETRY ADDRESS\n         BR    R1                       BRANCH TO RETRY ADDRESS\nTHATSIT  DS    0H\n         MVI   RCODE,C'8'               SET ERROR RETURN CODE\nRETMAIN1 DS    0H\n         L     R1,RETNADRS              LOAD RETURN ADDRESS\n         BR    R1                       BRANCH TO RETURN ADDRESS\n*=====================================================================*\n*---------------------------------------------------------------------*\n         LTORG\n*---------------------------------------------------------------------*\nWTIME    DS    0D\n         DC    C'00000005'             WAIT TIME INTERVAL 1/500 SEC.\nSYSRCODE DS    F\nCOMMONA  DSECT\n         COPY CICSXCAR\n         PUSH PRINT\n         PRINT NOGEN\n*\n         IHASDWA DSECT=YES          ENTRY : SDWA\n*\n         POP PRINT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#ICSXCAC": {"ttr": 7169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x00\\x89\\x16_\\x00\\x89\\x16_\\t1\\x00\\xdc\\x00\\xdc\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xc1\\xd2@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1989-06-14T00:00:00", "modifydate": "1989-06-14T09:31:00", "lines": 220, "newlines": 220, "modlines": 0, "user": "TECHAK"}, "text": "*---------------------------------------------------------------------*\n*                                                                     *\n*    162 FREE BYTES LEFT TO MAINTAIN 1 REGISTER ADDRESABILITY         *\n*                                                                     *\n*---------------------------------------------------------------------*\n#DUMMYS  DS    0D                           DOUBLE-WORD ALLIGN\nHEX00    DC    X'00000000'\nSCREENX  EQU   *\n         WCCDC W,,COLOR\n*        WCCDC EWA,,COLOR\nSCL0101  SBADC 1,1,PHN,Y\nSCRNLIN1 DC    CL67'-------- <..:..:.. --------------------------------X\n               ----------------'\nSCL0169  SBADC 1,69,PHN,G\nSCRNLINX DC    CL10'>*********'\nSCL0201  SBADC 2,1,PHN,W\n         DC    C'COMMAND ===>'\nSCL0214  SBADC 2,14,UHY,R\nSCL0214C ICDC  2,15                         CURSOR HERE\nSCREPLY  DC    CL59' '                      COMMAND OUTPUT\nSCL0263  SBADC 2,63,PHN,W\nSCL0264  DC    17C' '\nSCL0301  SBADC 3,1,PHN,T\nSCRNMSG  DS    CL79\n*SCL0401  SBADC 4,1,PLN,P\nSCL0401  SBADC 4,1,PLN,B\nSCREEN   DS    CL1678\n*SCREEN   DS    CL1600\nSCRSIZE  EQU   *-SCREENX\nSCRNCLR  EQU   *\n         WCCDC EW,NYY,COLOR\n*        WCCDC EWA,NYY,COLOR\n         SBADC 1,1,PLN,Y\n         DC    C' '\nCLRSIZE  EQU   *-SCRNCLR\nCHTABLE  DS    0CL256\n         DC    193X'0'\n         DC    X'0A0B0C0D0E0F'\n         DC    41X'0'\n         DC    X'F0010203040506070809'      NOTE - AS ZERO IS VALID\n*               /|\\                           CHAR 'F0' SUBSTITUTED AND\n*                                             LATER CHANGED\n         DC    6X'0'\nHEXTABLE DC    C'0123456789ABCDEF'\nZONES    DC    C'0'\nTRTABLE  DC    16C'.'                       00-0F\n         DC    16C'.'                       10-1F\n         DC    16C'.'                       20-2F\n         DC    16C'.'                       30-3F\n         DC    C' .........\u00a2.<(+|'          40-4F\n         DC    C'&&.........!$*);\u00ac'         50-5F\n         DC    C'-/........\u00a6,%_>?'          60-6F\n         DC    C'..........:#@''=\"'         70-7F\n         DC    C'.abcdefghi......'          80-8F\n         DC    C'.jklmnopqr......'          90-9F\n         DC    C'.~stuvwxyz......'          A0-AF\n         DC    16C'.'                       B0-BF\n         DC    C'{ABCDEFGHI......'          C0-CF\n         DC    C'}JKLMNOPQR......'          D0-DF\n         DC    C'\\.STUVWXYZ......'          E0-EF\n         DC    C'0123456789......'          F0-FF\nFULLWORD DS    F\nHALFWORD DS    H\nRETRY    DC    H'0'\nFTIME    DC    D'00000005'          FIXED TIME INTERVAL 5/100 SEC.\nVTIME    DC    D'00000000'          VARIABLE TIME INTERVAL\nAUTOTIME DC    C'N'                 AUTO YIMER FLAG\nDWORK8   DS    D\nBYTES    DS    0CL2\nBYTE1    DS    CL1\nBYTE2    DS    CL1\nTDISP    DS    H                    TOP DISPLACEMNET OF SCREEN\nLDISP    DS    H                    LAST DISPLACEMNET OF AREA + 1\nFDISP    DS    H                    number of \"lines\" moved\nDISP     DS    H\nDELIMITR DS    C                    PARSE DELIMITER\nFIRSTIME DC    C'Y'                 FIRST TIME THRU FLAG\nREFRESH  DC    C'N'\nADRTYPE  DC    C'C'\nREPEAT   DC    H'0'\nRCODE    DS    2C' '\nPRIMAX   DC    F'0'                 PRIMARY AUTHORISATION INDEX\nCALTADRS DC    F'0'                 CORE ALTER ADDRESS\nFROMVALU DC    F'0'                 FROM VALUE FOR \"CALT\"\nTOVALU   DC    F'0'                 FROM VALUE FOR \"CALT\"\nPRIMASID DC    H'0'                 PRIMARY ASID\nCICSNAME DC    CL8'        '        SUPPLY BY INPUT PARAMETER\nCICSASID DC    H'0'                 CICS ASID\nCICSAREA DS    XL8                  ADDRESS OF CICS DATA\nCICSCSAA DC    CL8'        '        ADDRESS OF CICS CSA\nTIOTADRS DS    CL4                  TASK I/O TABLE CONTROL BLOCK @\nHOMEADRS DC    CL8'        '        ADDRESS OF CICS CSA\nPSEUDPTR DS    XL8                  PSEUDO PTR TO ADDRESS OF CICS DATA\nCPFADRS  DS    F                           ADDRESS OF COMMON PF DSECT\nSTRING   DC    CL16' '\nTARGET   DC    CL80' '\nTARGETX  DS    CL8\nREPLY    DC    CL80'        '\nREPLYS   DS    CL80\nREPLYQ   DC    CL80' '\nSPACES   DC    CL80' '\nSTACKPTR DC    H'0'                 POINTER TO INPUT AREA\nOFFSET   DC    CL20'00'\nCICSINPT DS    CL40'CSA           ' ADDRESS OF CICS DATA\nSHUTTERM DS    CL4'    '            SHUTDOWN TERMINAL FROM PARAMETER\n#BUFFERS DC    H'1'                 # of pages for data move\nWAITTIME DC    H'5'                 SECOND WAIT FOR CHECKING\n***********************************************************************\n*                                                                     *\n*        'MYAREA' IS THE AREA IN WHICH THE CICS DATA IS TO BE         *\n*        PLACED. FOR SIMPLICITY, IT IS ASSUMED THAT NO DATA AREA      *\n*        GREATER THAN 320 BYTES (X'140' = 1 SCREEN FROM CMONEX1)      *\n*        WILL BE MOVED.                                               *\n*                                                                     *\n***********************************************************************\nSTACKEDF DC    C'N'                 STACKED (COMMAND) FLAG\nSTACKEDP DC    C'N'                 STACKED (COMMAND) PROCESSED FLAG\nSCICAREA DS    F\nISITCICS DC    C' '\nCICSVERS DC    X'17'                CICS VERSION\nPAGEFIND DC    C' '\nDSTRING  DC    CL16' '               DISPLAY FIND STRING\nFINDTYPE DC    C' '                 FIND TYPE FLAG C(HAR) X(EX)\nFNDSTRNG DC    C' '                 FINDSTRING FLAG\nSTRNGLEN DS    H                    FINDSTRING LENGTH\nDATAMOVD DC    C' '                 NO DATA MOVED FLAG\nUSCRSIZE DC    H'20'\n*FSCRSIZE DC    H'18'\nTEMPA31  DC    H'18'\nSORTJOBS DC    C'Y'\nAMODE31  DC    C'N'                 24/31 BIT ADDRESS (INIT TO 24)\nTODAY    DC    8C' '\nPRNTDEFD DC    C'Y'\nPRLINE1  DC    CL134' '\nPATTERN  DC    X'402020202120'\nSAVER4   DS    F\nSAVER14  DS    F\nDSNAME   DS    CL54\nUSERID   DC    CL8' '\nCHANGES  DC    CL32' '              CHANGE STRING SAVE AREA\nMYARLEN  DS    H'0'                 LENGTH OF GOT ALLOWING S0C4\nMYAREND  DS    F                    NEXT AREA TO BE DISPLAYED PTR\nPRINTER1 DCB   DDNAME=PRINTER1,                                        X\n               DSORG=PS,                                               X\n               MACRF=(PM)\nRETNADRS DS    F\nRETRYADR DS    F\n*---------------------------------------------------------------------*\nSCREENO  EQU   *                           SCREEN OVERLAY TO ACCEPT\n*                                          SELECTIONS\n         WCCDC W,,COLOR\nSLO0601  SBADC 6,1,PLN,R\n         DC    C' '\nSLO0603  SBADC 6,3,PLN,B\nSLO0701  SBADC 7,1,PLN,R\n         DC    C' '\nSLO0703  SBADC 7,3,PLN,B\nSLO0801  SBADC 8,1,PLN,R\n         DC    C' '\nSLO0803  SBADC 8,3,PLN,B\nSLO0901  SBADC 9,1,PLN,R\n         DC    C' '\nSLO0903  SBADC 9,3,PLN,B\nSLO1001  SBADC 10,1,PLN,R\n         DC    C' '\nSLO1003  SBADC 10,3,PLN,B\nSLO1101  SBADC 11,1,PLN,R\n         DC    C' '\nSLO1103  SBADC 11,3,PLN,B\nSLO1201  SBADC 12,1,PLN,R\n         DC    C' '\nSLO1203  SBADC 12,3,PLN,B\nSLO1301  SBADC 13,1,PLN,R\n         DC    C' '\nSLO1303  SBADC 13,3,PLN,B\nSLO1401  SBADC 14,1,PLN,R\n         DC    C' '\nSLO1403  SBADC 14,3,PLN,B\nSLO1501  SBADC 15,1,PLN,R\n         DC    C' '\nSLO1503  SBADC 15,3,PLN,B\nSLO1601  SBADC 16,1,PLN,R\n         DC    C' '\nSLO1603  SBADC 16,3,PLN,B\nSLO1701  SBADC 17,1,PLN,R\n         DC    C' '\nSLO1703  SBADC 17,3,PLN,B\nSLO1801  SBADC 18,1,PLN,R\n         DC    C' '\nSLO1803  SBADC 18,3,PLN,B\nSLO1901  SBADC 19,1,PLN,R\n         DC    C' '\nSLO1903  SBADC 19,3,PLN,B\nSLO2001  SBADC 20,1,PLN,R\n         DC    C' '\nSLO2003  SBADC 20,3,PLN,B\nSLO2101  SBADC 21,1,PLN,R\n         DC    C' '\nSLO2103  SBADC 21,3,PLN,B\nSLO2201  SBADC 22,1,PLN,R\n         DC    C' '\nSLO2203  SBADC 22,3,PLN,B\nSLO2301  SBADC 23,1,PLN,R\n         DC    C' '\nSLO2303  SBADC 23,3,PLN,B\nSLO2401  SBADC 24,1,PLN,R\n         DC    C' '\nSLO2403  SBADC 24,3,PLN,B\nLSCRO    EQU   *-SCREENO\n*---------------------------------------------------------------------*\nSCL0214N SBADC 2,14,UNY,R           SBA FOR PASSWORD ENTRY\nSCL0214O SBADC 2,14,UHY,R           RESTORE SBA AFTER PASSWORD ENTRY\n*---------------------------------------------------------------------*\nDATAFND  DS    H\nDATATOP  DS    H\nDATAEND  DS    F\n*---------------------------------------------------------------------*\nMYAREA   DS    CL4096\nMYAREA1  DS    CL32760\nMYAREA2  DS    CL32760\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#ICSXCAR": {"ttr": 6915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00\\x13\\x00\\x885\\x1f\\x00\\x95%\\x0f\\x11\\x08\\x00\\xe0\\x00\\xdb\\x00\\x00\\xe4\\xe3\\xd4\\xd7\\xf5\\xf4\\xf3@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "1988-12-16T00:00:00", "modifydate": "1995-09-07T11:08:13", "lines": 224, "newlines": 219, "modlines": 0, "user": "UTMP543"}, "text": "*---------------------------------------------------------------------*\n*                                                                     *\n*    162 FREE BYTES LEFT TO MAINTAIN 1 REGISTER ADDRESABILITY         *\n*                                                                     *\n*---------------------------------------------------------------------*\n#DUMMYS  DS    0D                           DOUBLE-WORD ALLIGN\nTERMTYPE DC    C'C'                         TERMINAL TYPE: MONO/COLOR\nHEX00    DC    X'00000000'\nSCREENX  EQU   *\n         WCCDC W,,MONO\n*        WCCDC EWA,,MONO\nSCL0101  SBADC 1,1,PHN,Y\nSCRNLIN1 DC    CL67'-------- <..:..:.. --------------------------------X\n               ----------------'\nSCL0169  SBADC 1,69,PHN,G\nSCRNLINX DC    CL10'>*********'\nSCL0201  SBADC 2,1,PHN,W\n         DC    C'COMMAND ===>'\nSCL0214  SBADC 2,14,UHY,R\nSCL0214C ICDC  2,15                         CURSOR HERE\nSCREPLY  DC    CL59' '                      COMMAND OUTPUT\nSCL0263  SBADC 2,63,PHN,W\nSCL0264  DC    17C' '\nSCL0301  SBADC 3,1,PHN,T\nSCRNMSG  DS    CL79\n*SCL0401  SBADC 4,1,PLN,P\nSCL0401  SBADC 4,1,PLN,B\nSCREEN   DS    CL1678\n*SCREEN   DS    CL1600\nSCRSIZE  EQU   *-SCREENX\nSCRNCLR  EQU   *\n         WCCDC EW,NYY,MONO\n*        WCCDC EWA,NYY,MONO\n         SBADC 1,1,PLN,Y\n         DC    C' '\nCLRSIZE  EQU   *-SCRNCLR\nCHTABLE  DS    0CL256\n         DC    193X'0'\n         DC    X'0A0B0C0D0E0F'\n         DC    41X'0'\n         DC    X'F0010203040506070809'      NOTE - AS ZERO IS VALID\n*               /|\\                           CHAR 'F0' SUBSTITUTED AND\n*                                             LATER CHANGED\n         DC    6X'0'\nHEXTABLE DC    C'0123456789ABCDEF'\nZONES    DC    C'0'\nTRTABLE  DC    16C'.'                       00-0F\n         DC    16C'.'                       10-1F\n         DC    16C'.'                       20-2F\n         DC    16C'.'                       30-3F\n         DC    C' .........\u00a2.<(+|'          40-4F\n         DC    C'&&.........!$*);\u00ac'         50-5F\n         DC    C'-/........\u00a6,%_>?'          60-6F\n         DC    C'..........:#@''=\"'         70-7F\n         DC    C'.abcdefghi......'          80-8F\n         DC    C'.jklmnopqr......'          90-9F\n         DC    C'.~stuvwxyz......'          A0-AF\n         DC    16C'.'                       B0-BF\n         DC    C'{ABCDEFGHI......'          C0-CF\n         DC    C'}JKLMNOPQR......'          D0-DF\n         DC    C'\\.STUVWXYZ......'          E0-EF\n         DC    C'0123456789......'          F0-FF\nGMAINADR DC    F'0'                 GOTMAIN ADDRESS\nFULLWORD DS    F\nHALFWORD DS    H\nRETRY    DC    H'0'\nFTIME    DC    D'00000005'          FIXED TIME INTERVAL 5/100 SEC.\nVTIME    DC    D'00000000'          VARIABLE TIME INTERVAL\nAUTOTIME DC    C'N'                 AUTO YIMER FLAG\nDWORK8   DS    D\nBYTES    DS    0CL2\nBYTE1    DS    CL1\nBYTE2    DS    CL1\nTDISP    DS    H                    TOP DISPLACEMNET OF SCREEN\nLDISP    DS    H                    LAST DISPLACEMNET OF AREA + 1\nFDISP    DS    H                    number of \"lines\" moved\nDISP     DS    H\nDELIMITR DS    C                    PARSE DELIMITER\nFIRSTIME DC    C'Y'                 FIRST TIME THRU FLAG\nREFRESH  DC    C'N'\nADRTYPE  DC    C'C'\nREPEAT   DC    H'0'\nRCODE    DS    2C' '\nPRIMAX   DC    F'0'                 PRIMARY AUTHORISATION INDEX\nCALTADRS DC    F'0'                 CORE ALTER ADDRESS\nFROMVALU DC    F'0'                 FROM VALUE FOR \"CALT\"\nTOVALU   DC    F'0'                 FROM VALUE FOR \"CALT\"\nPRIMASID DC    H'0'                 PRIMARY ASID\nCICSNAME DC    CL8'        '        SUPPLY BY INPUT PARAMETER\nCICSASID DC    H'0'                 CICS ASID\nCICSAREA DS    XL8                  ADDRESS OF CICS DATA\nCICSCSAA DC    CL8'        '        ADDRESS OF CICS CSA\nTIOTADRS DS    CL4                  TASK I/O TABLE CONTROL BLOCK @\nCICSTCB@ DS    CL4                  CICS (DFHSIP) TCB ADDRESS\nHOMEADRS DC    CL8'        '        ADDRESS OF CICS CSA\nPSEUDPTR DS    XL8                  PSEUDO PTR TO ADDRESS OF CICS DATA\nCPFADRS  DS    F                           ADDRESS OF COMMON PF DSECT\nSTRING   DC    CL16' '\nTARGET   DC    CL80' '\nTARGETX  DS    CL8\nREPLY    DC    CL80'        '\nREPLYS   DS    CL80\nREPLYQ   DC    CL80' '\nSPACES   DC    CL80' '\nSTACKPTR DC    H'0'                 POINTER TO INPUT AREA\nOFFSET   DC    CL20'00'\nCICSINPT DS    CL40'CSA           ' ADDRESS OF CICS DATA\nSHUTTERM DS    CL4'    '            SHUTDOWN TERMINAL FROM PARAMETER\n#BUFFERS DC    H'1'                 # of pages for data move\nWAITTIME DC    H'5'                 SECOND WAIT FOR CHECKING\n***********************************************************************\n*                                                                     *\n*        'MYAREA' IS THE AREA IN WHICH THE CICS DATA IS TO BE         *\n*        PLACED. FOR SIMPLICITY, IT IS ASSUMED THAT NO DATA AREA      *\n*        GREATER THAN 320 BYTES (X'140' = 1 SCREEN FROM CMONEX1)      *\n*        WILL BE MOVED.                                               *\n*                                                                     *\n***********************************************************************\nSTACKEDF DC    C'N'                 STACKED (COMMAND) FLAG\nSTACKEDP DC    C'N'                 STACKED (COMMAND) PROCESSED FLAG\nSCICAREA DS    F\nISITCICS DC    C' '\nCICSVERS DC    X'17'                CICS VERSION\nPAGEFIND DC    C' '\nDSTRING  DC    CL16' '               DISPLAY FIND STRING\nFINDTYPE DC    C' '                 FIND TYPE FLAG C(HAR) X(EX)\nFNDSTRNG DC    C' '                 FINDSTRING FLAG\nSTRNGLEN DS    H                    FINDSTRING LENGTH\nDATAMOVD DC    C' '                 NO DATA MOVED FLAG\nUSCRSIZE DC    H'20'\n*FSCRSIZE DC    H'18'\nTEMPA31  DC    H'18'\nSORTJOBS DC    C'Y'\nAMODE31  DC    C'N'                 24/31 BIT ADDRESS (INIT TO 24)\nTODAY    DC    8C' '\nPRNTDEFD DC    C'Y'\nPRLINE1  DC    CL134' '\nPATTERN  DC    X'402020202120'\nSAVER4   DS    F\nSAVER14  DS    F\nDSNAME   DS    CL54\nUSERID   DC    CL8' '\nCHANGES  DC    CL32' '              CHANGE STRING SAVE AREA\nMYARLEN  DS    H'0'                 LENGTH OF GOT ALLOWING S0C4\nMYAREND  DS    F                    NEXT AREA TO BE DISPLAYED PTR\nPRINTER1 DCB   DDNAME=PRINTER1,                                        X\n               DSORG=PS,                                               X\n               MACRF=(PM)\nRETNADRS DS    F\nRETRYADR DS    F\n*---------------------------------------------------------------------*\nSCREENO  EQU   *                           SCREEN OVERLAY TO ACCEPT\n*                                          SELECTIONS\n         WCCDC W,,MONO\nSLO0601  SBADC 6,1,PLN,R\n         DC    C' '\nSLO0603  SBADC 6,3,PLN,B\nSLO0701  SBADC 7,1,PLN,R\n         DC    C' '\nSLO0703  SBADC 7,3,PLN,B\nSLO0801  SBADC 8,1,PLN,R\n         DC    C' '\nSLO0803  SBADC 8,3,PLN,B\nSLO0901  SBADC 9,1,PLN,R\n         DC    C' '\nSLO0903  SBADC 9,3,PLN,B\nSLO1001  SBADC 10,1,PLN,R\n         DC    C' '\nSLO1003  SBADC 10,3,PLN,B\nSLO1101  SBADC 11,1,PLN,R\n         DC    C' '\nSLO1103  SBADC 11,3,PLN,B\nSLO1201  SBADC 12,1,PLN,R\n         DC    C' '\nSLO1203  SBADC 12,3,PLN,B\nSLO1301  SBADC 13,1,PLN,R\n         DC    C' '\nSLO1303  SBADC 13,3,PLN,B\nSLO1401  SBADC 14,1,PLN,R\n         DC    C' '\nSLO1403  SBADC 14,3,PLN,B\nSLO1501  SBADC 15,1,PLN,R\n         DC    C' '\nSLO1503  SBADC 15,3,PLN,B\nSLO1601  SBADC 16,1,PLN,R\n         DC    C' '\nSLO1603  SBADC 16,3,PLN,B\nSLO1701  SBADC 17,1,PLN,R\n         DC    C' '\nSLO1703  SBADC 17,3,PLN,B\nSLO1801  SBADC 18,1,PLN,R\n         DC    C' '\nSLO1803  SBADC 18,3,PLN,B\nSLO1901  SBADC 19,1,PLN,R\n         DC    C' '\nSLO1903  SBADC 19,3,PLN,B\nSLO2001  SBADC 20,1,PLN,R\n         DC    C' '\nSLO2003  SBADC 20,3,PLN,B\nSLO2101  SBADC 21,1,PLN,R\n         DC    C' '\nSLO2103  SBADC 21,3,PLN,B\nSLO2201  SBADC 22,1,PLN,R\n         DC    C' '\nSLO2203  SBADC 22,3,PLN,B\nSLO2301  SBADC 23,1,PLN,R\n         DC    C' '\nSLO2303  SBADC 23,3,PLN,B\nSLO2401  SBADC 24,1,PLN,R\n         DC    C' '\nSLO2403  SBADC 24,3,PLN,B\nLSCRO    EQU   *-SCREENO\n*---------------------------------------------------------------------*\nSCL0214N SBADC 2,14,UNY,R           SBA FOR PASSWORD ENTRY\nSCL0214O SBADC 2,14,UHY,R           RESTORE SBA AFTER PASSWORD ENTRY\n*---------------------------------------------------------------------*\nDATAEND  DS    F\nDATAFND  DS    H\nDATATOP  DS    H\nDATALEN  DS    F\n*---------------------------------------------------------------------*\nMYAREA   DS    CL4096\nMYAREA1  DS    CL32760\nMYAREA2  DS    CL32760\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@ICSXCAR": {"ttr": 770, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x89\\x05?\\x00\\x89\\x05?\\x13$\\x011\\x011\\x00\\x00\\xc1\\xd3\\xd2@@@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1989-02-22T00:00:00", "modifydate": "1989-02-22T13:24:00", "lines": 305, "newlines": 305, "modlines": 0, "user": "ALK"}, "text": "*---------------------------------------------------------------------*\n*                                                                     *\n*    162 FREE BYTES LEFT TO MAINTAIN 1 REGISTER ADDRESABILITY         *\n*                                                                     *\n*---------------------------------------------------------------------*\n#DUMMYS  DS    0D                           DOUBLE-WORD ALLIGN\nHEX00    DC    X'00000000'\nGETMADRS DS    F\nSCREENX  EQU   *\n         WCCDC W\n*        WCCDC EWA\nSCL0101  SBADC 1,1,PHN,Y\nSCRNLIN1 DC    CL67'-------- <..:..:.. --------------------------------X\n               ----------------'\nSCL0169  SBADC 1,69,PHN,G\nSCRNLINX DC    CL10'>*********'\nSCL0201  SBADC 2,1,PHN,W\n         DC    C'COMMAND ===>'\nSCL0214  SBADC 2,14,UHY,R\nSCL0214C ICDC  2,15                         CURSOR HERE\nSCREPLY  DC    CL59' '                      COMMAND OUTPUT\nSCL0263  SBADC 2,63,PHN,W\nSCL0264  DC    17C' '\nSCL0301  SBADC 3,1,PHN,T\nSCRNMSG  DS    CL79\nSCL0401  SBADC 4,1,PLN,B\nSZHEAD   EQU   *-SCREENX\nSCREEN   DS    CL1678\n*SCREEN   DS    CL1600\nSCRSIZE  EQU   *-SCREENX\nSCRNCLR  EQU   *\n*        WCCDC EW,NYY\n         WCCDC EWA,NYY\n         SBADC 1,1,PLN,Y\n         DC    C' '\nCLRSIZE  EQU   *-SCRNCLR\nCHTABLE  DS    0CL256\n         DC    193X'0'\n         DC    X'0A0B0C0D0E0F'\n         DC    41X'0'\n         DC    X'F0010203040506070809'      NOTE - AS ZERO IS VALID\n*               /|\\                           CHAR 'F0' SUBSTITUTED AND\n*                                             LATER CHANGED\n         DC    6X'0'\nHEXTABLE DC    C'0123456789ABCDEF'\nZONES    DC    C'0'\nTRTABLE  DC    16C'.'                       00-0F\n         DC    16C'.'                       10-1F\n         DC    16C'.'                       20-2F\n         DC    16C'.'                       30-3F\n         DC    C' .........\u00a2.<(+|'          40-4F\n         DC    C'&&.........!$*);\u00ac'         50-5F\n         DC    C'-/........\u00a6,%_>?'          60-6F\n         DC    C'..........:#@''=\"'         70-7F\n         DC    C'.abcdefghi......'          80-8F\n         DC    C'.jklmnopqr......'          90-9F\n         DC    C'.~stuvwxyz......'          A0-AF\n         DC    16C'.'                       B0-BF\n         DC    C'{ABCDEFGHI......'          C0-CF\n         DC    C'}JKLMNOPQR......'          D0-DF\n         DC    C'\\.STUVWXYZ......'          E0-EF\n         DC    C'0123456789......'          F0-FF\nFULLWORD DS    F\nHALFWORD DS    H\nRETRY    DC    H'0'\nFTIME    DC    D'00000005'          FIXED TIME INTERVAL 5/100 SEC.\nVTIME    DC    D'00000000'          VARIABLE TIME INTERVAL\nAUTOTIME DC    C'N'                 AUTO YIMER FLAG\nDWORK8   DS    D\nBYTES    DS    0CL2\nBYTE1    DS    CL1\nBYTE2    DS    CL1\nTDISP    DS    H                    TOP DISPLACEMNET OF SCREEN\nLDISP    DS    H                    LAST DISPLACEMNET OF AREA + 1\nFDISP    DS    H                    number of \"lines\" moved\nDISP     DS    H\nDELIMITR DS    C                    PARSE DELIMITER\nFIRSTIME DC    C'Y'                 FIRST TIME THRU FLAG\nREFRESH  DC    C'N'\nADRTYPE  DC    C'C'\nREPEAT   DC    H'0'\nRCODE    DS    2C' '\nPRIMAX   DC    F'0'                 PRIMARY AUTHORISATION INDEX\nCALTADRS DC    F'0'                 CORE ALTER ADDRESS\nFROMVALU DC    F'0'                 FROM VALUE FOR \"CALT\"\nTOVALU   DC    F'0'                 FROM VALUE FOR \"CALT\"\nPRIMASID DC    H'0'                 PRIMARY ASID\nCICSNAME DC    CL8'        '        SUPPLY BY INPUT PARAMETER\nCICSASID DC    H'0'                 CICS ASID\nCICSAREA DS    XL8                  ADDRESS OF CICS DATA\nCICSCSAA DC    CL8'        '        ADDRESS OF CICS CSA\nTIOTADRS DS    CL4                  TASK I/O TABLE CONTROL BLOCK @\nHOMEADRS DC    CL8'        '        ADDRESS OF CICS CSA\nPSEUDPTR DS    XL8                  PSEUDO PTR TO ADDRESS OF CICS DATA\nCPFADRS  DS    F                           ADDRESS OF COMMON PF DSECT\nSTRING   DC    CL16' '\nTARGET   DC    CL80' '\nTARGETX  DS    CL8\nREPLY    DC    CL80'        '\nREPLYS   DS    CL80\nREPLYQ   DC    CL80' '\nSPACES   DC    CL80' '\nSTACKPTR DC    H'0'                 POINTER TO INPUT AREA\nOFFSET   DC    CL20'00'\nCICSINPT DS    CL40'CSA           ' ADDRESS OF CICS DATA\nSHUTTERM DS    CL4'    '            SHUTDOWN TERMINAL FROM PARAMETER\n#BUFFERS DC    H'1'                 # of pages for data move\nWAITTIME DC    H'5'                 SECOND WAIT FOR CHECKING\n***********************************************************************\n*                                                                     *\n*        'MYAREA' IS THE AREA IN WHICH THE CICS DATA IS TO BE         *\n*        PLACED. FOR SIMPLICITY, IT IS ASSUMED THAT NO DATA AREA      *\n*        GREATER THAN 320 BYTES (X'140' = 1 SCREEN FROM CMONEX1)      *\n*        WILL BE MOVED.                                               *\n*                                                                     *\n***********************************************************************\nSTACKEDF DC    C'N'                 STACKED (COMMAND) FLAG\nSTACKEDP DC    C'N'                 STACKED (COMMAND) PROCESSED FLAG\nSCICAREA DS    F\nISITCICS DC    C' '\nCICSVERS DC    X'17'                CICS VERSION\nPAGEFIND DC    C' '\nDSTRING  DC    CL16' '               DISPLAY FIND STRING\nFINDTYPE DC    C' '                 FIND TYPE FLAG C(HAR) X(EX)\nFNDSTRNG DC    C' '                 FINDSTRING FLAG\nSTRNGLEN DS    H                    FINDSTRING LENGTH\nDATAMOVD DC    C' '                 NO DATA MOVED FLAG\nUSCRSIZE DC    H'20'\nFSCRSIZE DC    H'18'\nSORTJOBS DC    C'Y'\nAMODE31  DC    C'N'                 24/31 BIT ADDRESS (INIT TO 24)\nTODAY    DC    8C' '\nPRNTDEFD DC    C'Y'\nPRLINE1  DC    CL134' '\nPATTERN  DC    X'402020202120'\nSAVER4   DS    F\nSAVER14  DS    F\nDSNAME   DS    CL54\nUSERID   DC    CL8' '\nCHANGES  DC    CL32' '              CHANGE STRING SAVE AREA\nMYARLEN  DS    H'0'                 LENGTH OF GOT ALLOWING S0C4\nMYAREND  DS    F                    NEXT AREA TO BE DISPLAYED PTR\nPRINTER1 DCB   DDNAME=PRINTER1,                                        X\n               DSORG=PS,                                               X\n               MACRF=(PM)\nRETNADRS DS    F\nRETRYADR DS    F\n*---------------------------------------------------------------------*\nSCREENO  EQU   *                           SCREEN OVERLAY TO ACCEPT\n*                                          SELECTIONS\n         WCCDC W\nSLO0601  SBADC 6,1,PLN,R\n         DC    C' '\nSLO0603  SBADC 6,3,PLN,B\nSLO0701  SBADC 7,1,PLN,R\n         DC    C' '\nSLO0703  SBADC 7,3,PLN,B\nSLO0801  SBADC 8,1,PLN,R\n         DC    C' '\nSLO0803  SBADC 8,3,PLN,B\nSLO0901  SBADC 9,1,PLN,R\n         DC    C' '\nSLO0903  SBADC 9,3,PLN,B\nSLO1001  SBADC 10,1,PLN,R\n         DC    C' '\nSLO1003  SBADC 10,3,PLN,B\nSLO1101  SBADC 11,1,PLN,R\n         DC    C' '\nSLO1103  SBADC 11,3,PLN,B\nSLO1201  SBADC 12,1,PLN,R\n         DC    C' '\nSLO1203  SBADC 12,3,PLN,B\nSLO1301  SBADC 13,1,PLN,R\n         DC    C' '\nSLO1303  SBADC 13,3,PLN,B\nSLO1401  SBADC 14,1,PLN,R\n         DC    C' '\nSLO1403  SBADC 14,3,PLN,B\nSLO1501  SBADC 15,1,PLN,R\n         DC    C' '\nSLO1503  SBADC 15,3,PLN,B\nSLO1601  SBADC 16,1,PLN,R\n         DC    C' '\nSLO1603  SBADC 16,3,PLN,B\nSLO1701  SBADC 17,1,PLN,R\n         DC    C' '\nSLO1703  SBADC 17,3,PLN,B\nSLO1801  SBADC 18,1,PLN,R\n         DC    C' '\nSLO1803  SBADC 18,3,PLN,B\nSLO1901  SBADC 19,1,PLN,R\n         DC    C' '\nSLO1903  SBADC 19,3,PLN,B\nSLO2001  SBADC 20,1,PLN,R\n         DC    C' '\nSLO2003  SBADC 20,3,PLN,B\nSLO2101  SBADC 21,1,PLN,R\n         DC    C' '\nSLO2103  SBADC 21,3,PLN,B\nSLO2201  SBADC 22,1,PLN,R\n         DC    C' '\nSLO2203  SBADC 22,3,PLN,B\nSLO2301  SBADC 23,1,PLN,R\n         DC    C' '\nSLO2303  SBADC 23,3,PLN,B\nSLO2401  SBADC 24,1,PLN,R\n         DC    C' '\nSLO2403  SBADC 24,3,PLN,B\nLSCRO    EQU   *-SCREENO\nSLO2501  SBADC 25,1,PLN,R\n         DC    C' '\nSLO2503  SBADC 25,3,PLN,B\nSLO2601  SBADC 26,1,PLN,R\n         DC    C' '\nSLO2603  SBADC 26,3,PLN,B\nSLO2701  SBADC 27,1,PLN,R\n         DC    C' '\nSLO2703  SBADC 27,3,PLN,B\nSLO2801  SBADC 28,1,PLN,R\n         DC    C' '\nSLO2803  SBADC 28,3,PLN,B\nSLO2901  SBADC 29,1,PLN,R\n         DC    C' '\nSLO2903  SBADC 29,3,PLN,B\nSLO3001  SBADC 30,1,PLN,R\n         DC    C' '\nSLO3003  SBADC 30,3,PLN,B\nSLO3101  SBADC 31,1,PLN,R\n         DC    C' '\nSLO3103  SBADC 31,3,PLN,B\nSLO3201  SBADC 32,1,PLN,R\n         DC    C' '\nSLO3203  SBADC 32,3,PLN,B\nLSCRO2   EQU   *-SCREENO\nSLO3301  SBADC 33,1,PLN,R\n         DC    C' '\nSLO3303  SBADC 33,3,PLN,B\nSLO3401  SBADC 34,1,PLN,R\n         DC    C' '\nSLO3403  SBADC 34,3,PLN,B\nSLO3501  SBADC 35,1,PLN,R\n         DC    C' '\nSLO3503  SBADC 35,3,PLN,B\nSLO3601  SBADC 36,1,PLN,R\n         DC    C' '\nSLO3603  SBADC 36,3,PLN,B\nSLO3701  SBADC 37,1,PLN,R\n         DC    C' '\nSLO3703  SBADC 37,3,PLN,B\nSLO3801  SBADC 38,1,PLN,R\n         DC    C' '\nSLO3803  SBADC 38,3,PLN,B\nSLO3901  SBADC 39,1,PLN,R\n         DC    C' '\nSLO3903  SBADC 39,3,PLN,B\nSLO4001  SBADC 40,1,PLN,R\n         DC    C' '\nSLO4003  SBADC 40,3,PLN,B\nSLO4101  SBADC 41,1,PLN,R\n         DC    C' '\nSLO4103  SBADC 41,3,PLN,B\nSLO4201  SBADC 42,1,PLN,R\n         DC    C' '\nSLO4203  SBADC 42,3,PLN,B\nSLO4301  SBADC 43,1,PLN,R\n         DC    C' '\nSLO4303  SBADC 43,3,PLN,B\nLSCRO3   EQU   *-SCREENO\n*---------------------------------------------------------------------*\nSCL0214N SBADC 2,14,UNY,R           SBA FOR PASSWORD ENTRY\nSCL0214O SBADC 2,14,UHY,R           RESTORE SBA AFTER PASSWORD ENTRY\n*---------------------------------------------------------------------*\nDATAFND  DS    H\nDATATOP  DS    H\nDATAEND  DS    F\n*---------------------------------------------------------------------*\nMYAREA   DS    CL4096\nMYAREA1  DS    CL32760\nMYAREA2  DS    CL32760\n*=====================================================================*\nSCREENX# DSECT\n         WCCDC W\n         SBADC 1,1,PHN,Y\n         DC    CL67'-------- <..:..:.. --------------------------------X\n               ----------------'\n         SBADC 1,69,PHN,G\n         DC    CL10'>*********'\n         SBADC 2,1,PHN,W\n         DC    C'COMMAND ===>'\n         SBADC 2,14,UHY,R\n         ICDC  2,15                         CURSOR HERE\n         DC    CL59' '                      COMMAND OUTPUT\n         SBADC 2,63,PHN,W\n         DC    17C' '\n         SBADC 3,1,PHN,T\n         DS    CL79\n         SBADC 4,1,PLN,B\nSZHEAD#  EQU   *-SCREENX#\nSCREEN#  DS    CL1678\nSZ24     EQU   *-SCREENX#\n         DS    CL640\nSZ32     EQU   *-SCREENX#\n         DS    CL880\nSZ43     EQU   *-SCREENX#\nSCREEN#L EQU   *-SCREEN#\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@MACROS": {"ttr": 13825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01;\\x00\\x05\\x00\\x92!\\x9f\\x01\\x08\\x04_\\x14T\\x10\\xf8\\x05D\\x00\\x00\\xc1\\xd3\\xc5\\xe7@@@@@@'", "ispf": {"version": "01.59", "flags": 0, "createdate": "1992-08-06T00:00:00", "modifydate": "2008-02-14T14:54:05", "lines": 4344, "newlines": 1348, "modlines": 0, "user": "ALEX"}, "text": "*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*\n*                                                                     *\n*  General macros used in programs written by ASYSTS Pty. Ltd.        *\n*                                                                     *\n*  SUMMARY:                                                           *\n*  ~~~~~~~~                                                           *\n*    1. KICKOFF  - Initial program entry housekeeping.                *\n*    2. RACKOFF  - Final program exit housekeeping.                   *\n*    3. UNPACK   - Convert HEX numerics to display format             *\n*    4. CLEARV   - Move blanks to variable field (> 255 bytes).       *\n*    5  AMODECHG - Addressing MODE CHanGe                             *\n*    6. HEXCHMAC - Convert HEX to character.                          *\n*    7. CHHEXMAC - Convert character to HEX.                          *\n*    8. ISPVDEFX - Define ISPF variables (ISPVDEF) to program.        *\n*    9. ISPEXEC  - Invoke ISPLINK using 'ISPEXEC' format commands.    *\n*   10. PUTL     o Issue a PUTLINE command within a command processor *\n*   11. ADYN     - DYNAMIC allocation/deallocation etc...             *\n*   12. PDUMPR   - Program dump with REXX/ISPF presentation.          *\n*   13. PDUMP    o Program dump with 3270 datastream presentation.    *\n*                                                                     *\n*   3270 Data Stream macros:                                          *\n*   14. CADC     o Character Attribute Define Constant                *\n*   15. ICDC     o Insert Character Define Constant                   *\n*   16. RADC     o Repeat to Address Define Constant                  *\n*   17. SBA      o Set Buffer Address                                 *\n*   18. SBADC    o Set Buffer Address Define Constant                 *\n*   19. WCCDC    o Write Control Character Define Constant            *\n*       --------\n*                                                                     *\n*  This member can be rebuilt using the MACBUILD edit macro. To make  *\n*  a sub-set, change the '-' after the macro name to the optional     *\n*  indicator 'o'.  This will leave the entry without including the    *\n*  member. Alternatively pass parameter of ALL to MACBUILD to include *\n*  all assembler macros.                                              *\n*                                                                     *\n*  To find the start of the appropriate macro, enter \"F 'MACRO n'\".   *\n*                                                                     *\n*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*\n*------- Macro  1. KICKOFF -------------------------------------------*\n         MACRO\n&NAME    KICKOFF &BASE,&GETMAINS,&GETMAINL,&LIST=NO,&HELP=NO,&DREG=,   X\n               &AMODE=31,&RMODE=ANY,&SAVE=,&LOC=\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'KICKOFF' parameters    *\n* and it's use, pass parameter of 'HELP=Yes'.                         *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n* Macro to generate all the house keeping etc.. at start of a program,*\n* either re-entrant or not.                                           *\n* This macro works in conjunction with the 'RACKOFF' macro.           *\n*                                                                     *\n* PARAMETERS:\n* 1. Base register(s) - Format \"(Rx,Ry,Rz)\" or \"Rx\". May have up to   *\n*                       3 base registers specified. R13 may not be    *\n*                       used for re-entrant programs (refer 2 below). *\n*                       For non re-entrant programs, if R13 is used   *\n*                       as one of the base registers, it will be used *\n*                       as the first base regardless of it's position *\n*                       in the parameter string, and the initial base *\n*                       will be the conventional register save area   *\n*                       NOT the start of the program.                 *\n*                       Default is \"(R11,R12)\".                       *\n* 2. First variable,s name in the DSECT of a GETMAINEd area.  This    *\n*    parameter is optional, however, if it used (eg. re-entrant       *\n*    programs), R13 may not be used as a base register and the first  *\n*    18 full words must be used for register save and linkage         *\n*    conventions.                                                     *\n* 3. Length of the GETMAINEd area (must be an \"EQU\" variable) and must*\n*    be supplied if variable name parameter is supplied.              *\n* 4. AMODE=..  - Addressing mode '24/31' (default = 31)               *\n* 5. DREG=Rn   - Additional DSECT register on GETMAINEd area. (Use    *\n*                only if you have addressability problems on the      *\n*                GETMAINE'd DSECT. Do not enclose in brackets.)       *\n* 6. HELP=...  - Display help comments. 'YES/NO' (default = NO).      *\n* 7. LIST=...  - Display code generated. 'YES/NO' (default = YES).    *\n* 8. LOC=....  - Optional loaction for the GETMAINed area if that     *\n*                option is used. It must be a valid parameter as      *\n*                defined by the IBM GETMAIN macro.                    *\n* 9. RMODE=..  - Load  mode '24/ANY' (default = ANY)                  *\n*10. SAVE=...  - Variable name of register save area if you wish to   *\n*                control it's name. (useful if specialised exit       *\n*                in-lieu of 'RACKOFF'.                                *\n*                                                                     *\n* GENERATES:                                                          *\n* 1. Inserts a \"program_date_time\" stamp at start of module.          *\n* 2. Sets up all the register equates.                                *\n* 3. Saves callers registers R14 thru R12.                            *\n* 4. Points R13 to the programs savearea.                             *\n* 5. Establishes addresability thru supplied register(s) or default   *\n*     base registers R11 + R12.                                       *\n* 6. Workarea is GETMAINEd and the conventional linkage pointers,     *\n*     registers saved and R13 pointed to the start of the work area.  *\n* 7. As R0 + R1 are used as work registers at start, they are restored*\n*     from callers savearea.                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PUSH  PRINT\n         PRINT NOGEN\n.A$XX    ANOP\n         GBLB  &KO1STR1\n         GBLC  &R,&GETMADR,&GETMADL,&SAVREGS\n         LCLC  &E,&BASE1,&BASE2,&BASE3,&BASE#,&#DREG,&#GMM\n         LCLA  &A,&#BASES,&GETMLEN\n         AIF   (T'&GETMAINS EQ 'O').NRENT\n         AIF   (T'&GETMAINL EQ 'O').ERR2\n.NRENT   ANOP\n&GETMADR SETC  '&GETMAINS'\n&GETMADL SETC  '&GETMAINL'\n.*--------------------------------------------------------------------*\n         AIF   (T'&SAVE EQ 'O').DEFSRG      BYPASS IF DEFAULT SAVE NAME\n&SAVREGS SETC  '&SAVE'\n         AGO   .A$$XX                       BYPASS DEFAULT NAME\n.DEFSRG  ANOP\n&SAVREGS SETC  '$SAV'.'&SYSNDX'\n.A$$XX   ANOP\n.*--------------------------------------------------------------------*\n         LCLC  &TNAME\n         AIF   (T'&BASE EQ 'O').DEFAULT\n&BASE1   SETC  '&SYSLIST(1,1)'\n&BASE2   SETC  '&SYSLIST(1,2)'\n&BASE3   SETC  '&SYSLIST(1,3)'\n&#BASES  SETA  N'&SYSLIST(1)\n         AIF   (T'&GETMAINS EQ 'O').A$00    NON-R BYPASS\n         AIF   ('&BASE1' EQ 'R13').ERRR13\n         AIF   ('&BASE2' EQ 'R13').ERRR13\n         AIF   ('&BASE3' EQ 'R13').ERRR13\n         AIF   ('&BASE1' EQ '13').ERRR13\n         AIF   ('&BASE2' EQ '13').ERRR13\n         AIF   ('&BASE3' EQ '13').ERRR13\n.A$00    ANOP\n         AIF   ('&BASE2' EQ 'R13').BASE213\n         AIF   ('&BASE2' EQ '13').BASE213\n         AIF   ('&BASE3' EQ 'R13').BASE313\n         AIF   ('&BASE3' EQ '13').BASE313\n         AGO   .CONT1\n.BASE213 ANOP\n&BASE#   SETC  '&BASE1'\n&BASE1   SETC  '&BASE2'\n&BASE2   SETC  '&BASE#'\n         AGO   .CONT1\n.BASE313 ANOP\n&BASE#   SETC  '&BASE1'\n&BASE1   SETC  '&BASE3'\n&BASE3   SETC  '&BASE#'\n         AGO   .CONT1\n.DEFAULT ANOP\n&#BASES  SETA  2\n&BASE1   SETC  'R11'\n&BASE2   SETC  'R12'\n.CONT1   ANOP\n         AIF   (T'&GETMAINS EQ 'O').NONR0   NON-R BYPASS\n         AIF   (T'&DREG EQ 'O').NONR0       NO 2ND.DSECT REG, BYPASS\n         AIF   ('&DREG' EQ '&BASE1').ERDREG IF SAME AS BASE 1, ERROR\n         AIF   ('&DREG' EQ '&BASE2').ERDREG IF SAME AS BASE 2, ERROR\n         AIF   ('&DREG' EQ '&BASE3').ERDREG IF SAME AS BASE 3, ERROR\n         AIF   ('&DREG' EQ 'R13').ERDREG    IF R13, ERROR\n         AIF   ('&DREG' EQ '13').ERDREG     IF R13, ERROR\n         AIF   ('&DREG' EQ 'RD').ERDREG     IF R13, ERROR\n&#DREG   SETC  ',&DREG'                     SET SECONDARY DSECT REG\n.NONR0   ANOP\n.*--------------------------------------------------------------------*\n         AIF      ('&NAME' EQ '').NONAME\n&E       SETC     '&NAME'\n         AGO      .A\n.NONAME  ANOP\n&E       SETC    'NULL&SYSNDX'\n.A       ANOP\n&E       CSECT\n.TAMODE  ANOP\n         AIF ('&AMODE' NE '31').AM24$\n&E       AMODE  31                          AMODE OF 31\n         AGO    .TRMODE                     Continue\n.AM24$   ANOP\n&E       AMODE  24                          AMODE OF 24 REQUESTED\n&E       RMODE  24                          RMODE OF 24 FORCED\n         AGO    .BYP#10                     Continue\n.TRMODE  ANOP\n         AIF ('&RMODE' NE 'ANY').RM24$$\n&E       RMODE  ANY                         RMODE OF ANY\n         AGO    .BYP#10                     Continue\n.RM24$$  ANOP\n&E       RMODE  24                          RMODE OF 24 REQUESTED\n.BYP#10  ANOP\n&R       SETC     'R'\n         AIF ('&BASE1' EQ 'R13').SAVANCH\n         AIF ('&BASE1' NE '13').TEST1ST\n.SAVANCH ANOP\n&E       SETC     '&SAVREGS'                SET REGISTER SAVE AREA BASE\n.*--------------------------------------------------------------------*\n.TEST1ST ANOP\n         AIF   (&KO1STR1).C                 FIRST TIME THRU\n&KO1STR1 SETB 1\nR0       EQU    0\nR1       EQU    1\nR2       EQU    2\nR3       EQU    3\nR4       EQU    4\nR5       EQU    5\nR6       EQU    6\nR7       EQU    7\nR8       EQU    8\nR9       EQU    9\nR10      EQU   10\nRA       EQU   10\nR11      EQU   11\nRB       EQU   11\nR12      EQU   12\nRC       EQU   12\nR13      EQU   13\nRD       EQU   13\nR14      EQU   14\nRE       EQU   14\nR15      EQU   15\nRF       EQU   15\n*---------------------------------------------------------------------*\n.C       ANOP\n         B     30(&R.15)                    BRANCH AROUND P/D/T STAMP\n         DC    CL8'&NAME'                   PROGRAM STAMP\n         DC    C'_'                         DELIMITER\n         DC    CL8'&SYSDATE'                DATE STAMP\n         DC    C'_'                         DELIMITER\n         DC    CL8'&SYSTIME'                TIME STAMP\n         STM   &R.14,&R.12,12(&R.13)        SAVE REGISTERS\n         AIF   (T'&GETMAINS EQ 'O').NONR1   NON-R BYPASS\n.*--------------------------------------------------------------------*\n.*      RE-ENTRANT PROG                                               *\n.*--------------------------------------------------------------------*\n         LR    2,15                         LOAD R2 WITH START OF PR\n         USING &NAME,2                      USE R2 AS TEMPORARY BASE\n.*--------------------------------------------------------------------*\n         AIF (T'&LOC EQ 'O').NOGMLOC\n*        GETMAIN R,LV=&GETMAINL,&LOC        GETMAIN AREA\n         GETMAIN R,LV=&GETMAINL,&LOC        GETMAIN AREA\n         AGO   .A$$000\n.NOGMLOC ANOP\n*        GETMAIN R,LV=&GETMAINL             GETMAIN AREA\n         GETMAIN R,LV=&GETMAINL             GETMAIN AREA\n.A$$000  ANOP\n.*--------------------------------------------------------------------*\n         ST    &R.13,4(&R.1)                BACKWARD CHAIN\n         ST    &R.1,8(&R.13)                FORWARD CHAIN\n.*--------------------------------------------------------------------*\n.* The next line does horrible things with 31 bit addressing.         *\n.*       NI    12(&R.13),X'00'              CLEAR TRACE BITS\n.*--------------------------------------------------------------------*\n         LR    &R.13,&R.1                   SAVE AREA @\n         AIF   (T'&DREG EQ 'O').NDREG1      NO 2ND.DSECT REG, BYPASS\n         LA    &DREG,4095(&R.13)            POINT 2ND. REG 1K PAST\n         LA    &DREG,1(&DREG)                 1ST. DSECT BASE\n.NDREG1  ANOP\n         USING &GETMADR,&R.13&#DREG         ADDRESABILITY TO GETMAIN\n         LR    &BASE1,&R.2                  &BASE1 IS 1ST. BASE REG\n         DROP  &R.2                         DROP REGISTER 15 AS BASE\n         AIF      (&#BASES GT 1).TWOBASE\n         USING &E,&BASE1                    USING ONE BASE REGISTER\n         AGO      .RESTR0R2\n.NONR1   ANOP\n.*--------------------------------------------------------------------*\n.*      NON RE-ENTRANT PROG                                           *\n.*--------------------------------------------------------------------*\n         USING &NAME,15                     USE R15 AS TEMPORARY BASE\n         ST    &R.13,&SAVREGS.+4            BACKWARD CHAIN\n         LA    &R.0,&SAVREGS                OUR SAVEAREA ADDRESS\n         ST    &R.0,8(&R.13)                FORWARD CHAIN\n.*--------------------------------------------------------------------*\n.* The next line does horrible things with 31 bit addressing.         *\n.*       NI    12(&R.13),X'00'              CLEAR TRACE BITS\n.*--------------------------------------------------------------------*\n         LR    13,0                         R13 POINT TO OUR SAVEAREA\n         AIF ('&E' EQ '&SAVREGS').NOLOAD1   BUPASS BASE LOAD\n         LR    &BASE1,15                    &BASE1 IS 1ST. BASE REG\n.NOLOAD1 ANOP\n         AIF      (&#BASES GT 1).TWOBASE\n         DROP  15                           RELINQUISH ADDRESSABILITY\n         USING &E,&BASE1                    USING ONE BASE REGISTER\n         AGO      .ADROK\n.TWOBASE ANOP\n         LA    &BASE2,4095(&BASE1)          POINT 2ND. REG 1K PAST\n         LA    &BASE2,1(&BASE2)               1ST. BASE\n         AIF      (&#BASES GT 2).THRBASE\n         DROP  15                           RELINQUISH ADDRESSABILITY\n         USING &E,&BASE1,&BASE2             USING TWO BASE REGISTERS\n         AGO      .ADROK\n.THRBASE ANOP\n         LA    &BASE3,4095(&BASE2)          POINT 3RD. REG 1K PAST\n         LA    &BASE3,1(&BASE3)               2ND. BASE\n         DROP  15                           RELINQUISH ADDRESSABILITY\n         USING &E,&BASE1,&BASE2,&BASE3      USING THREE BASE REGISTERS\n.*       AGO      .ADROK\n.ADROK   ANOP\n         AIF   (T'&GETMAINS NE 'O').RESTR0R2 RE-ENT PROCESSING\n         LA    1,&E                         ADDRESS OF CSECT\n         LA    0,&SAVREGS                   NEW BASE ADDRESS\n         SR    1,0                          SUBTRACT THE DIFFERENCE\n         STH   1,KOFFCOMP                   STORE UNDER @ COMPENSATOR\n         B     &SAVREGS.+74                 BRANCH AROUND SAVE AREA\n&SAVREGS DS    18F\nKOFFCOMP DS    H                            KICKOFF BASE @ COMPENSATOR\n         XR    &R.0,&R.0                    ZERO REGISTER 0\n         ST    &R.0,&SAVREGS.+8             CLEAR FORWARD CHAIN\n         L     &R.1,4(&R.13)                LOAD CALLERS SAVEAREA @\n         LM    &R.0,&R.1,20(&R.1)           RESTORE PARM REGISTERS\n         AGO   .MEXIT1\n.*--------------------------------------------------------------------*\n.RESTR0R2 ANOP\n.*--------------------------------------------------------------------*\n.*      RE-ENTRANT PROG                                               *\n.*--------------------------------------------------------------------*\n         XR    &R.0,&R.0                    ZERO REGISTER 0\n         ST    &R.0,8(&R.13)                CLEAR FORWARD CHAIN\n         L     &R.1,4(&R.13)                LOAD CALLERS SAVEAREA @\n         LM    &R.0,&R.2,20(&R.1)           RESTORE PARM REGISTERS\n         AGO   .MEXIT1\n.*--------------------------------------------------------------------*\n.ERR     MNOTE 8,'MUST SUPPLY WORK-AREA DSECT FOR GETMAIN.'\n         AGO   .MEXIT1\n.ERR2    MNOTE 8,'MUST SUPPLY WORK-AREA DSECT LENGTH FOR GETMAIN.'\n         AGO   .MEXIT1\n.ERR3    MNOTE 8,'NO MATCHING RACKOFF FOR PREVIOUS KICKOFF.'\n         AGO   .MEXIT1\n.ERRR13  MNOTE 8,'R13 CANNOT BE USED AS BASE FOR RE-ENTRANT MACRO.'\n         AGO   .MEXIT1\n.ERDREG  MNOTE 8,'XTRA DSECT REGISTER MUST NOT BE A BASE OR R13.'\n         AGO   .MEXIT1\n.MEXIT1  ANOP\n         AIF   ('&LIST'(1,1) NE 'N').MEXIT9\n         POP PRINT\n.MEXIT9  ANOP\n*---------------------------------------------------------------------*\n         MEXIT\n.*--------------------------------------------------------------------*\n         MEND\n*---------------------------------------------------------------------*\n*------- Macro  2. RACKOFF -------------------------------------------*\n         MACRO                                                          RAC00010\n&NAME    RACKOFF &RC=0,&LIST=NO,&R1=,&HELP=NO                           RAC00020\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'RACKOFF' parameter     *\n* and it's use, pass parameter 'HELP=Yes'.                            *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n* Parameters:                                                         *\n*                                                                     *\n*        RC=n       - Numeric return code (default = 0)               *\n*                             - or -                                  *\n*                     RC=(R15) if R15 contains the return code        *\n*        LIST=Y/N   - Generate code from macro expansion (def = NO)   *\n*        HELP=Y/N   - Display this help box (def = Yes)               *\n*        R1=PASS    - 'PASS' infers that R1 contains return parameter *\n*                     value to the caller and is to remain as is. Any *\n*                     other value will include R1 in the register     *\n*                     restoration command 'LM  R14,R12,....'          *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   (T'&NAME EQ 'O').NONAME\n&NAME    DS    0H                                                       RAC00020\n.NONAME  ANOP\n         GBLC  &R,&GETMADR,&GETMADL,&SAVREGS\n&KO1STR  SETB 0                             TURN 1ST TIME THRU OFF\n         AIF   (T'&GETMADL EQ 'O').A$10     NON-R BYPASS\n         AIF   (T'&R1 EQ 'O').A$00          DO NOT PASS R1\n         AIF   ('&R1' NE 'PASS').A$00       IF R1\u00ac=PASS DO NOT PASS R1\n         LR    &R.3,&R.1                    SAVE REGISTER 1 IN CASE\n.A$00    ANOP\n         LR    &R.1,&R.13                   LOAD GETMAINED AREA ADDRESS\n         LR    &R.2,&R.15                   SAVE REGISTER 15 IN CASE\n.A$10    ANOP\n         L     &R.13,4(&R.13)               LOAD CALLERS SAVEAREA @     RAC00040\n         AIF   (T'&GETMADL EQ 'O').A$20     NON-R BYPASS\n*        FREEMAIN R,LV=&GETMADL,A=(1)\n         FREEMAIN R,LV=&GETMADL,A=(1)\n.A$20    ANOP\n         AIF   (T'&R1 EQ 'O').A$21          DO NOT PASS R1\n         AIF   ('&R1' NE 'PASS').A$21       IF R1\u00ac=PASS DO NOT PASS R1\n         LR    &R.1,&R.3                    RESTORE R1\n.A$21    ANOP\n         AIF   ('&RC' EQ '(R15)').SPEC      R15 CONTAINS RC             RAC00050\n         AIF   ('&RC' EQ '(15)').SPEC R15 CONTAINS RC                   RAC00060\n         AIF   (T'&R1 EQ 'O').A$22          DO NOT PASS R1\n         AIF   ('&R1' NE 'PASS').A$22       IF R1\u00ac=PASS DO NOT PASS R1\n         LM    &R.14,&R.0,12(&R.13)         RESTORE REGISTERS 14-0      RAC00070\n*                                           LEAVE R1 AS IS\n         LM    &R.2,&R.12,28(&R.13)         RESTORE REGISTERS 2-12      RAC00070\n         AGO   .A$23                                                    RAC00090\n.A$22    ANOP\n         LM    &R.14,&R.12,12(&R.13)        RESTORE REGISTERS 14-12     RAC00070\n.A$23    ANOP\n         LA    &R.15,&RC                    SET RETURN CODE             RAC00080\n         AGO   .RET1                                                    RAC00090\n.SPEC    ANOP                                                           RAC00100\n         AIF   (T'&GETMADL EQ 'O').A$30     NON-R BYPASS\n         LR    &R.15,&R.2                   RESTORE R15 FROM ABOVE SAVE RAC00100\n.A$30    ANOP\n         L     &R.14,12(&R.13)              RESTORE R14                 RAC00100\n         AIF   (T'&R1 EQ 'O').A$32          DO NOT PASS R1\n         AIF   ('&R1' NE 'PASS').A$32       IF R1\u00ac=PASS DO NOT PASS R1\n         L     &R.0,20(&R.13)               RESTORE REGISTER 0          RAC00110\n*                                           LEAVE R1 AS IS\n         LM    &R.2,&R.12,28(&R.13)         RESTORE REGISTERS 2-12      RAC00110\n         AGO   .RET1                                                    RAC00090\n.A$32    ANOP\n         LM    &R.0,&R.12,20(&R.13)         RESTORE REGISTERS 0-12      RAC00110\n.RET1    ANOP                                                           RAC00120\n.*--------------------------------------------------------------------*\n.* The next line does horrible things with 31 bit addressing.         *\n.*       MVI   12(&R.13),X'FF'              SET TRACE BITS ON           RAC00120\n.*--------------------------------------------------------------------*\n         BR    &R.14                        RETURN                      RAC00130\n         POP   PRINT\n*---------------------------------------------------------------------*\n         MEXIT\n.*--------------------------------------------------------------------*\n.E1      POP   PRINT\n         MNOTE 8,'MACRO KICKOFF MUST BE USED WITH THIS MACRO.'\n         MEXIT\n.*--------------------------------------------------------------------*\n         MEND                                                           KIC00710\n*---------------------------------------------------------------------*\n*------- Macro  3. UNPACK --------------------------------------------*\n         MACRO\n&NAME    UNPACK &REG,&PL,&OUT,&MF=,&LIST=NO,&HELP=NO\n         AIF   ('&HELP' EQ 'YES').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'UNPACK' parameters     *\n* and it's use, pass parameter of 'HELP=Yes'.                         *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n* Macro to unpack a register into a variable.                         *\n*                                                                     *\n*   PARAMETERS:                                                       *\n*       1. Register holding contents                                  *\n*       2. Length to unpack                                           *\n*       3. Output field (default \"upout(8)\")                          *\n*       4. MF=E/L for re-entrant programs.  (Not required for non     *\n*          re-entrant programs.)                                      *\n*       5. LIST=YES/NO, to determine generation of macro statements.  *\n*                                                                     *\n*   NOTE:                                                             *\n*       For re-entrant programs the list format only requires the     *\n*       MF= parameter,                                                *\n*            eg.      UNPACK MF=L                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST' NE 'NO').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   (T'&NAME EQ 'O').A$YY\n&NAME    DS    0H\n.A$YY    ANOP\n         AIF   ('&MF' EQ 'L').A$ZZ\n         AIF   (T'&REG EQ 'O').E1\n         AIF   (T'&PL EQ 'O').E2\n.A$ZZ    ANOP\n         GBLC  &TNAME\n         LCLC  &UPWORK,&UPOUT\n         GBLB  &UNPFST1,&UNPFST2\n         AIF   (&UNPFST1).A$00\n&UNPFST1 SETB  1\n&TNAME   SETC  'UPK'.'&SYSNDX'\n.A$00    ANOP\n&UPWORK  SETC  '&TNAME'.'1'\n&UPOUT   SETC  '&TNAME'.'2'\n         AIF   ('&MF' EQ 'E').A$99          BYPASS IF EXEC FORM OF MAC\n         AIF   ('&MF' EQ 'L').A$11          BYPASS IF LIST FORM OF MAC\n         AIF   (&UNPFST2).A$99\n&UNPFST2 SETB  1\n         B     &TNAME.3                    BRANCH AROUND DATA\n.*--------------------------------------------------------------------*\n.*       DATA STORAGE                                                 *\n.*--------------------------------------------------------------------*\n.A$11    ANOP\n&UPWORK  DS    D\n&UPOUT   DS    CL8\n         AIF   ('&MF' EQ 'L').EXIT         BYPASS IF LIST FORM OF MAC\n.*--------------------------------------------------------------------*\n&TNAME.3 DS    0H\n.A$99    ANOP\n         CVD   &REG,&UPWORK\n         OI    &UPWORK+7,X'0F'\n         UNPK  &UPOUT.(8),&UPWORK+8-&PL.(&PL.)\n         AIF   (T'&OUT EQ 'O').EXIT\n         MVC   &OUT.(&PL.),&UPOUT+8-&PL.\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E1      MNOTE 12,'UNPACK REQUIRES SOURCE A REGISTER'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E2      MNOTE 12,'UNPACK REQUIRES A LENGTH'\n.*--------------------------------------------------------------------*\n.EXIT    ANOP\n         POP   PRINT\n         MEXIT\n         MEND\n*---------------------------------------------------------------------*\n*------- Macro  4. CLEARV --------------------------------------------*\n         MACRO\n&NAME    CLEARV &OUT,&LENGTH,&PAD=40,&MF=,&LIST=YES,&HELP=NO\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'CLEARV'  parameters    *\n* and it's use, pass parameter of 'HELP=Yes'.                         *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Move a particular pad character to any variable. The variable may *\n*   be > 256 characters.                                              *\n*                                                                     *\n*   For variable < 258: uses a ripple move.                           *\n*       variable > 257: uses the MVCL instruction.                    *\n*                                                                     *\n*   NOTE : - All registers are kept in tact by this macro.            *\n*                                                                     *\n*   PARAMETERS:                                                       *\n*     1. Destination variable's name.                                 *\n*     2. Length of the variable. To be supplied if the \"L'varname\"    *\n*        function will not return the required length.                *\n*     3. PAD=xx - HEX notation of the pad character. The default is   *\n*                 X'40' (ie. spaces).                                 *\n*     3. MF=E/L - Macro format. For re-entrant programs, MF=L is      *\n*                 required as the macro requires a register save area.*\n*                 It uses a common save area with other macros,       *\n*                 however, the first macro reserves the storage and it*\n*                 may be this one.                                    *\n*     4. HELP=YES/NO - to generate these comments.                    *\n*     5. LIST=YES/NO - to generate a list of commands generated.      *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         LCLC  &CLNAME\n         LCLA  &VLENGTH,&LT258L\n.*--------------------------------------------------------------------*\n         AIF   ('&MF' EQ 'L').A$YY\n         AIF   (T'&OUT EQ 'O').E1\n         AIF   (T'&LENGTH EQ 'O').NOLEN\n.A$YY    ANOP\n&VLENGTH SETA  &LENGTH\n         AGO   .CONT1\n.NOLEN   ANOP\n&VLENGTH SETA  L'&OUT\n.CONT1   ANOP\n         AIF   (&VLENGTH LT 258).A$RD\n.*--------------------------------------------------------------------*\n         AIF   ('&MF' EQ 'L').A$00\n.A$00    ANOP\n         GBLB  &CLFIRST\n         GBLC  &CLBYP1\n.*--------------------------------------------------------------------*\n         GBLC  &REGSAVR,&REGSMCR\n         GBLB  &REGSFLG,&REGDFLG\n         AIF   (&REGSFLG).A$RS\n&REGSAVR SETC  'GB'.'&SYSNDX'.'#'\n&REGSMCR SETC  'CLEARV'\n&REGSFLG SETB  1\n.A$RS    ANOP\n.*--------------------------------------------------------------------*\n         AIF   ('&MF' EQ 'E').A$88\n         AIF   (&CLFIRST).A$88\n&CLFIRST SETB  1\n&CLNAME  SETC  'CL'.'&SYSNDX'\n&CLBYP1  SETC  '&CLNAME'.'1'\n.*--------------------------------------------------------------------*\n.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *\n.*--------------------------------------------------------------------*\n         AIF   (&REGDFLG).A$RD\n&REGDFLG SETB  1\n         AIF   ('&MF' EQ 'L').A$77\n         B     &CLBYP1                 BRANCH AROUND REGISTER SAVEAREA\n.A$77    ANOP\n&REGSAVR DS    16F                     REGISTER SAVE AREA\n         AIF   ('&MF' EQ 'L').EXIT\n&CLBYP1  DS    0H\n.A$RD    ANOP\n         AIF   ('&MF' EQ 'L').EXIT\n.*--------------------------------------------------------------------*\n.A$88    ANOP\n         AIF   (&VLENGTH GT 257).A$99\n*  Ripple move                                                        *\n&LT258L  SETA  &VLENGTH-1\n         MVI   &OUT,X'&PAD'            MOVE PAD CHARACTER\n         MVC   &OUT+1(&LT258L),&OUT    RIPPLE MOVE TO REST OF VARIABLE\n         AGO   .EXIT\n.A$99    ANOP\n*  MVCL instruction move                                              *\n         STM   R14,R1,&REGSAVR         SAVE REGISTERS\n         LA    R0,&OUT                 LOAD ADDRESS OF VARIABLE\n         L     R1,=F'&VLENGTH'         LOAD LENGTH OF VARIABLE\n         XR    R14,R14                 CLEAR SOUREC ADDRESS\n         XR    R15,R15                 CLEAR SOURCE LENGTH\n         ICM   R15,B'1000',=X'&PAD'    MOVE PAD CHARACTER\n         MVCL  R0,R14                  SET AREA TO ALL SPACES\n         LM    R14,R1,&REGSAVR         RESTORE SAVED REGISTERS\n.*--------------------------------------------------------------------*\n.EXIT    ANOP\n         AGO   .MEXIT1\n.*--------------------------------------------------------------------*\n.E1      MNOTE 12,'CLEAR BIG REQUIRES A DESTINATION VARIABLE.'\n         AGO   .MEXIT1\n.E2      MNOTE 12,'CLEAR BIG LONG REQUIRES A LENGTH.'\n.MEXIT1  ANOP\n         AIF   ('&LIST'(1,1) EQ 'Y').A$ZZ\n         POP PRINT\n.A$ZZ    ANOP\n         MEND\n*---------------------------------------------------------------------*\n*------- Macro  6. HEXCHMAC ------------------------------------------*\n         MACRO\n&NAME    HEXCHMAC &SOURCE,&TARGET,&LENGTH,&MF=,&LIST=NO,&LABEL=YES,    +\n               &HELP=NO,&INIT=NO,&DSECT=NO\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'HEXCHMAC' parameter    *\n* and it's use, pass parameter 'HELP=Yes'.                            *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* CONVERT HEX TO CHARACTERS.                                          *\n* --------------------------                                          *\n*           N O T E - N O T E - N O T E - N O T E - N O T E           *\n*                                                                     *\n*   This routine saves and uses general registers 1, 14 & 15.         *\n*   14 will be altered on return from the macro.                      *\n*   Do NOT use registers 14 or 15 as addresses for passed parameters. *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Parameters:-                                                      *\n*       1. Source                                                     *\n*       2. Target (the target needs 2 times the length of source)     *\n*       3. Length                                                     *\n*       4. MF=E/L -  Macro format for re-entrant programs             *\n*       5. LABEL=YES/NO - Generate data labels. Used for re-entrant   *\n*                         programs with MF=L and you wish to move the *\n*                         constant value from the CSECT over the      *\n*                         the GETMAIN'ed DSECT.                       *\n*                         The default is 'YES'. The parameter can be  *\n*                         ignored if NOTE 2 option is observed.       *\n*       6. LIST=YES/NO - Option to generate macro expansion or not    *\n*       7. HELP=YES/NO - Option to print these help details. Default  *\n*                        is 'YES'.                                    *\n*       8. INIT=YES/NO - Initialise MF=E macro to repeat common code  *\n*                        for multi-DSECT programs. 'NO' is the        *\n*                        default.                                     *\n*       9. DSECT=Y/N   - If DSECT=Y, the translate table is defided   *\n*                        as storage (DS) not constant (DC).           *\n*                        Should be used with MF=L.                    *\n*                                                                     *\n*   NOTE:-                                                            *\n*       1. Parameters may be passed in registers using the (Rn)       *\n*          notation (Note cannot have digits).                        *\n*       2. For execute form of the macro (MF=E) the first occurence of*\n*          the macro must be the first one executed. If a branch      *\n*          causes a initial loop around it, insert a dummy macro to   *\n*          perform a conversion into work areas or use the LABEL=NO   *\n*          parameter.                                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PUSH  PRINT\n         PRINT NOGEN\n.A$XX    ANOP\n&NAME    DS    0H\n         LCLC  &#LENGTH,&#SOURCE,&#TARGET\n         LCLA  &LEN\n         GBLC  &XNAME,&XCBAL,&XCBYPAS,&XCLOOP\n         GBLC  &XCBYTES,&XCBYTE1,&XCBYTE2,&XCTABLE,&XCRETAD\n         GBLB  &XC1ST,&XC1NAME\n.*--------------------------------------------------------------------*\n         GBLC  &REGSAVR,&REGSMCR\n         GBLB  &REGSFLG,&REGDFLG\n         AIF   ('&INIT'(1,1) NE 'Y').A$YY  BYPASS IF NOT INITIALISE\n&XC1ST   SETB  0\n&XNAME   SETC  'XC'.'&SYSNDX'\n&XCBAL   SETC  '&XNAME'.'06'\n&XCLOOP  SETC  '&XNAME'.'07'\n&XCBYPAS SETC  '&XNAME'.'08'\n&XCRETRN SETC  '&XNAME'.'EX'\n.A$YY    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (&REGSFLG).A$RS\n&REGSAVR SETC  'GB'.'&SYSNDX'.'#'\n&REGSMCR SETC  'HEXCHMAC'\n&REGSFLG SETB  1\n.A$RS    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (&XC1NAME).A$$0\n&XNAME   SETC  'XC'.'&SYSNDX'\n&XCRETAD SETC  '&XNAME'.'01'\n&XCTABLE SETC  '&XNAME'.'02'\n&XCBYTES SETC  '&XNAME'.'03'\n&XCBYTE1 SETC  '&XNAME'.'04'\n&XCBYTE2 SETC  '&XNAME'.'05'\n&XCBAL   SETC  '&XNAME'.'06'\n&XCLOOP  SETC  '&XNAME'.'07'\n&XCBYPAS SETC  '&XNAME'.'08'\n&XCRETRN SETC  '&XNAME'.'EX'\n&XC1NAME SETB  1\n         AGO   .A$$0\n.*--------------------------------------------------------------------*\n.A$$0    ANOP\n&XCRETRN SETC  'XC'.'&SYSNDX'.'EX'\n.A$$1    ANOP\n         AIF   ('&MF' EQ 'L').RENT1    IF MF=L PARAMETER PASSED BYPASS\n         AIF   (T'&SOURCE EQ 'O').E1   IF PARM 1 NOT PASSED ERROR\n         AIF   (T'&TARGET EQ 'O').E2   IF PARM 2 NOT PASSED ERROR\n         AIF   (T'&LENGTH EQ 'O').E3   IF PARM 3 NOT PASSED ERROR\n         AIF   ('&SOURCE'(1,1) EQ '(').A$01\n&#SOURCE SETC  '&SOURCE'\n         AGO   .A$02\n.A$01    ANOP\n&#SOURCE SETC  '0(&SOURCE(1))'\n.A$02    ANOP\n         AIF   ('&TARGET'(1,1) EQ '(').A$03\n&#TARGET SETC  '&TARGET'\n         AGO   .A$04\n.A$03    ANOP\n&#TARGET SETC  '0(&TARGET(1))'\n.A$04    ANOP\n         AIF   (&XC1ST).A$11           IF NOT 1ST. TIME THRU\n         AIF   (T'&MF EQ 'O').NONR1    IF NON-RE PROGRAM BYPASS\n*  EXEC FORM OF MACRO 'HEXCHMAC'                                      *\n*---------------------------------------------------------------------*\n.*       MVC   &XCTABLE.(16),=C'0123456789ABCDEF'\n         B     &XCBYPAS                BYPASS COMMON CODE\n         AGO   .RENT2                  BYPASS NON-RE PROCESS\n.NONR1   ANOP\n*  NORMAL FORM OF MACRO 'HEXCHMAC'                                    *\n*---------------------------------------------------------------------*\n         B     &XCBYPAS                BYPASS DATA + COMMON CODE\n*---------------------------------------------------------------------*\n         AGO   .NONR2                  BYPASS RE-ENT PROCESS\n.RENT1   ANOP\n*---------------------------------------------------------------------*\n*  List form of macro 'HEXCHMAC'                                      *\n*---------------------------------------------------------------------*\n.NONR2   ANOP\n         AIF   (T'&MF EQ 'O').LABON1\n         AIF   ('&LABEL'(1,1) EQ 'Y').LABON1\n         DS    0F                      WORD ALIGN\n         DS    F                       RETURNN ADDRESS SAVE AREA\n         AIF   (T'&DSECT EQ 'O').DCTT1\n         AIF   ('&DSECT'(1,1) EQ 'N').DCTT1\n         DS    CL16                    TRANSLATE TABLE\n         AGO   .DCTT1D\n.DCTT1   ANOP\n         DC    C'0123456789ABCDEF'     TRANSLATE TABLE\n.DCTT1D  ANOP\n         DS    0CL2                    BYTE SAVE AREA\n         DS    CL1                     1ST. BYTE\n         DS    CL1                     2ND. BYTE\n         AGO   .LABDONE\n.LABON1  ANOP\n         DS    0F                      WORD ALIGN\n&XCRETAD DS    F                       RETURNN ADDRESS SAVE AREA\n         AIF   (T'&DSECT EQ 'O').DCTT2\n         AIF   ('&DSECT'(1,1) EQ 'N').DCTT2\n&XCTABLE DS    CL16                    TRANSLATE TABLE\n         AGO   .DCTT2D\n.DCTT2   ANOP\n&XCTABLE DC    C'0123456789ABCDEF'     TRANSLATE TABLE\n.DCTT2D  ANOP\n&XCBYTES DS    0CL2                    BYTE SAVE AREA\n&XCBYTE1 DS    CL1                     1ST. BYTE\n&XCBYTE2 DS    CL1                     2ND. BYTE\n.LABDONE ANOP\n.*--------------------------------------------------------------------*\n.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *\n.*--------------------------------------------------------------------*\n         AIF   (&REGDFLG).A$RD\n         AIF   ('&LABEL'(1,1) EQ 'Y').LABON2 BYPASS IF LABEL REQUIRED\n         AIF   ('&REGSMCR' NE 'HEXCHMAC').A$RD\n         DS    0F                      WORD ALIGN\n         DS    16F                     REGISTER SAVE AREA\n         AGO   .A$RD                   DO NOT SET FLAG IF LABEL REQD\n.LABON2  ANOP\n&REGDFLG SETB  1\n         DS    0F                      WORD ALIGN\n&REGSAVR DS    16F                     REGISTER SAVE AREA\n.A$RD    ANOP\n.*--------------------------------------------------------------------*\n.RENT2   ANOP\n*---------------------------------------------------------------------*\n         AIF   ('&MF' EQ 'L').EXIT\n*                                                                     *\n*        Convert HEX to characters.                                   *\n*                                                                     *\n*         R1=source, R14=target, R15=length                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n&XCBAL   DS    0H\n         XR    0,0                     INITIALISE REGISTER\n         AIF   (T'&MF EQ 'O').NONR3    IF NON-RE PROGRAM BYPASS\n         MVC   &XCTABLE.(16),=C'0123456789ABCDEF'\n.NONR3   ANOP\n&XCLOOP  DS    0H\n         IC    0,0(1)                  INSERT CHARACTER FOR TRANS'TN\n         SRL   0,4                     GET RID OF RIGHT NIBBLE\n         STC   0,&XCBYTE1              STORE LEFT NIBBLE\n         TR    &XCBYTE1,&XCTABLE       TRANSLATE NIBBLE TO CHATACTER\n         MVC   0(1,14),&XCBYTE1        MOVE TO DESTINATION\n         MVC   &XCBYTE1,0(1)           MOVE CHARACTER TO WORK AREA\n         NI    &XCBYTE1,15             AND WITH X'0F' REMOVE LEFT NIB\n         TR    &XCBYTE1,&XCTABLE       TRANSLATE TO CHARACTER\n         MVC   1(1,14),&XCBYTE1        MOVE CHAR TO DESTINATION\n         LA    1,1(1)                  UP SOURCE BY 1\n         LA    14,2(14)                UP DESTINATION BY 2\n         BCT   15,&XCLOOP              BRANCH TILL END\n         L     14,&XCRETAD             LOAD RETURN ADDRESS\n         BR    14                      RETURN TO CALLER\n&XCBYPAS DS    0H\n.A$11    ANOP\n         STM   14,12,&REGSAVR          SAVE REGISTERS\n         LA    14,&XCRETRN             LOAD RETURN ADDRESS\n         ST    14,&XCRETAD             STORE RETURN ADDRESS\n         LA    14,&#TARGET             SET UP DESTINATION ADDRESS\n         AIF   ('&LENGTH'(1,1) NE '(').ACTLEN\n&LEN     SETA  K'&LENGTH-2\n&#LENGTH SETC  '&LENGTH'(2,&LEN)       REGISTER\n         LR    15,&#LENGTH             LENGTH TO BE CONVERTED\n         AGO   .FINLMV  ANOP           PASS AROUND\n.ACTLEN  ANOP\n         LA    15,&LENGTH              LENGTH TO BE CONVERTED\n.FINLMV  ANOP\n         LA    1,&#SOURCE              SET UP TO SOURCE ADDRESS\n         B     &XCBAL                  GO TO HEX => CHAR ROUTINE\n&XCRETRN DS    0H\n         LM    14,12,&REGSAVR          RESTORE REGISTERS\n*---------------------------------------------------------------------*\n&XC1ST   SETB  1\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.*       ERROR MESSAGES                                               *\n.*--------------------------------------------------------------------*\n.E1      MNOTE 8,'HEXCHMAC requires a SOURCE field'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E2      MNOTE 8,'HEXCHMAC requires a TARGET field'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E3      MNOTE 8,'HEXCHMAC requires a LENGTH'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E4      MNOTE 8,'Invalid \"MF\" parameter passed'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.EXIT    ANOP\n         AIF   ('&LIST'(1,1) NE 'N').EXIT9\n         POP   PRINT\n.EXIT9   ANOP\n         MEXIT\n         MEND\n*---------------------------------------------------------------------*\n*------- Macro  7. CHHEXMAC ------------------------------------------*\n         MACRO\n&NAME    CHHEXMAC &SOURCE,&TARGET,&LENGTH,&ERRRTN,&MF=,&LIST=NO,       +\n               &LABEL=YES,&HELP=NO\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'CHHEXMAC' parameter    *\n* and it's use pass parameter 'HELP=Yes'.                             *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n*   CONVERT CHARACTERS TO HEX.                                        *\n*   --------------------------                                        *\n*           N O T E - N O T E - N O T E - N O T E - N O T E           *\n*                                                                     *\n*   This routine saves and uses general registers 1, 14 & 15.         *\n*   R14 and R15 will be altered on return from the macro. Do NOT use  *\n*   these two registers to as parameter addresses.                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Parameters:-                                                      *\n*       1. Source                                                     *\n*       2. Target                                                     *\n*       3. Length                                                     *\n*       4. Error routine in case of error or a one byte (two character*\n*          hex value  quoted, ie. 'xx') value to convert invalid      *\n*          characters to and then continue.                           *\n*          NOTE - An invalid supplied HEX substitution parameter will *\n*                 result in X'00' substitution.                       *\n*       5. MF=E/L -  Macro format for re-entrant programs             *\n*       6. LABEL=YES/NO - Generate data labels. Used for reentrant    *\n*                         programs with MF=L and you wish to move the *\n*                         constant value from the CSECT over the      *\n*                         the getmain'ed DSECT.                       *\n*                         The default is 'YES'. the parameter can be  *\n*                         ignored if note 2 option is observed.       *\n*       7. LIST=YES/NO - Option to generate macro expansion or not    *\n*       8. HELP=YES/NO - Option to print these help details. default  *\n*                        is 'YES'.                                    *\n*                                                                     *\n*                                                                     *\n*   If \"error routine\" = 'xx' (quoted) format then on return from     *\n*   macro, R15 will be:-                                              *\n*       set to - 0 if all conversion OK                               *\n*       set to - 8 if conversion error found                          *\n*                                                                     *\n*   NOTE:-                                                            *\n*       1. Parameters may be passed in registers using the (Rn) or    *\n*          d(Rn) (for register displacement) notation.                *\n*          NOTE - cannot have digits).                                *\n*       2. For execute form of the macro (MF=E) the first occurence of*\n*          the macro must be the first one executed. If a branch      *\n*          causes a initial loop around it, insert a dummy macro to   *\n*          perform a conversion into work areas or use the LABEL=NO   *\n*          parameter.                                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n.*--------------------------------------------------------------------*\n         GBLC  &CXBAL,&CXBYPAS,&CXLOOP,&CXBYTES,&CXBYTE1,&CXBYTE2\n         GBLC  &CXBADAT,&CXTABLE,&CXIGERR,&CXER1BR,&CXER2BR\n         GBLC  &CXER1BS,&CXER2BS,&CXRTADR\n         GBLC  &CXCHOK1,&CXERSUB,&CXERRCH,&CXRTCOD,&CXCHXT1,&CXR1SAV\n         GBLB  &CX1NAME,&CX1ST\n         LCLC  &#LENGTH,&#SOURCE,&#TARGET,&#ERRRTN\n         LCLA  &LEN\n.*--------------------------------------------------------------------*\n         GBLC  &REGSAVR,&REGSMCR\n         GBLB  &REGSFLG,&REGDFLG\n         AIF   (&REGSFLG).A$RS\n&REGSAVR SETC  'GB'.'&SYSNDX'.'#'\n&REGSFLG SETB  1\n&REGSMCR SETC  'CHHEXMAC'\n.A$RS    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (&CX1NAME).A$$0\n         LCLC  &TNAME\n&TNAME   SETC  'CX'.'&SYSNDX'\n&CXTABLE SETC  '&TNAME'.'01'\n&CXBYTES SETC  '&TNAME'.'02'\n&CXBYTE1 SETC  '&TNAME'.'03'\n&CXBYTE2 SETC  '&TNAME'.'04'\n&CXERRCH SETC  '&TNAME'.'05'\n&CXR1SAV SETC  '&TNAME'.'06'\n&CXER1BS SETC  '&TNAME'.'07'\n&CXER2BS SETC  '&TNAME'.'08'\n&CXRTADR SETC  '&TNAME'.'09'\n&CXRTCOD SETC  '&TNAME'.'10'\n&CXBAL   SETC  '&TNAME'.'11'\n&CXLOOP  SETC  '&TNAME'.'12'\n&CXIGERR SETC  '&TNAME'.'13'\n&CXCHOK1 SETC  '&TNAME'.'14'\n&CXBADAT SETC  '&TNAME'.'15'\n&CXBYPAS SETC  '&TNAME'.'16'\n&CXCHXT1 SETC  '&TNAME'.'EX'\n&CX1NAME SETB  1\n         AGO   .A$$1                    BYPASS 2ND. INVOCATION\n.*--------------------------------------------------------------------*\n.A$$0    ANOP\n&CXCHXT1 SETC  'CX'.'&SYSNDX'.'EX'\n.A$$1    ANOP\n         AIF   ('&MF' EQ 'L').RENT1     IF MF=L PARM PASSED BYPASS\n         AIF   (T'&SOURCE EQ 'O').E1\n         AIF   (T'&TARGET EQ 'O').E2\n         AIF   (T'&LENGTH EQ 'O').E3\n         AIF   (T'&ERRRTN EQ 'O').E4\n.*--------------------------------------------------------------------*\n         AIF   ('&SOURCE'(1,1) EQ '(').A$01\n&#SOURCE SETC  '&SOURCE'\n         AGO   .A$02\n.A$01    ANOP\n&#SOURCE SETC  '0(&SOURCE(1))'\n.A$02    ANOP\n         AIF   ('&TARGET'(1,1) EQ '(').A$03\n&#TARGET SETC  '&TARGET'\n         AGO   .A$04\n.A$03    ANOP\n&#TARGET SETC  '0(&TARGET(1))'\n.A$04    ANOP\n&CXERSUB SETC  '''00'''                       SET X'00' FOR SUB\n&CXER1BR SETC  '&CXBADAT'                     SET ERROR BRANCH ADDRESS\n&CXER2BR SETC  '&CXIGERR'                     SET IGNORE BRANCH ADDRESS\n         AIF   ('&ERRRTN'(1,1) NE '''').A$07\n&CXERSUB SETC  '&ERRRTN'                      SET IGNORE BRANCH ADDRESS\n&CXER1BR SETC  '&CXIGERR'                     SET IGNORE BRANCH ADDRESS\n         AGO   .A$10\n.A$07    ANOP\n         AIF   ('&ERRRTN'(1,1) EQ '(').A$08\n&#ERRRTN SETC  '&ERRRTN'\n         AGO   .A$09\n.A$08    ANOP\n&#ERRRTN SETC  '0(&ERRRTN(1))'\n.A$09    ANOP\n&CXER2BR SETC  '&#ERRRTN'                     SET ERROR ROUTINE ADDRESS\n.A$10    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (&CX1ST).A$11           IF NOT 1ST. TIME THRU\n         AIF   (T'&MF EQ 'O').NONR1    IF NON-RE PROGRAM BYPASS\n*  EXEC FORM OF MACRO 'CHHEXMAC'                                      *\n*---------------------------------------------------------------------*\n.*       MVI   &CXTABLE,X'00'          HEX FILL FIRST BYTE THEN RIPPLE\n.*       MVC   &CXTABLE.+1(192),&CXTABLE  FILL REST\n.*       MVC   &CXTABLE.+193(06),=X'0A0B0C0D0E0F'\n.*       MVC   &CXTABLE.+199(41),&CXTABLE FILL REST\n.*       MVC   &CXTABLE.+240(10),=X'F0010203040506070809'\n.*       MVC   &CXTABLE.+250(06),&CXTABLE FILL REST\n         B     &CXBYPAS                BYPASS COMMON CODE\n         AGO   .RENT2                  BYPASS NON-RE PROCESS\n.NONR1   ANOP\n*  NORMAL FORM OF MACRO 'CHHEXMAC'                                    *\n*---------------------------------------------------------------------*\n         B     &CXBYPAS                BYPASS DATA + COMMON CODE\n*---------------------------------------------------------------------*\n         AGO   .NONR2                  BYPASS RE-ENT PROCESS\n.RENT1   ANOP\n*---------------------------------------------------------------------*\n*  LIST FORM OF MACRO 'CHHEXMAC'                                      *\n*---------------------------------------------------------------------*\n.NONR2   ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&MF EQ 'O').LABON\n         AIF   ('&LABEL'(1,1) EQ 'Y').LABON\n         DS    0CL256\n         DC    193X'0'\n         DC    X'0A0B0C0D0E0F'\n         DC    41X'0'\n         DC    X'F0010203040506070809' NOTE - AS ZERO IS VALID\n*               /|\\                    CHAR 'F0' SUBSTITUTED AND\n*                                      LATER CHANGED\n         DC    6X'0'\n         DS    0CL2                    BOTH BYTE\n         DS    CL1                     1ST. BYTE\n         DS    CL1                     1ST. BYTE\n         DS    CL2                     CHARACTER SUBSTITUTION\n         DC    4F'0'                   REGISTER 1 SAVE AREA B/C TRT\n         DC    F'0'                    ERROR EXIT SAVE ADDRESS\n         DC    F'0'                    ERROR ROUTINE SAVE ADDRESS\n         DC    F'0'                    RETURN ADDRESS\n         DC    H'0'                    RETURN CODE SAVE AREA\n         AGO   .LABDONE\n.LABON   ANOP\n&CXTABLE DS    0CL256\n         DC    193X'0'\n         DC    X'0A0B0C0D0E0F'\n         DC    41X'0'\n         DC    X'F0010203040506070809' NOTE - AS ZERO IS VALID\n*               /|\\                    CHAR 'F0' SUBSTITUTED AND\n*                                      LATER CHANGED\n         DC    6X'0'\n&CXBYTES DS    0CL2                    BOTH BYTE\n&CXBYTE1 DS    CL1                     1ST. BYTE\n&CXBYTE2 DS    CL1                     1ST. BYTE\n&CXERRCH DS    CL2                     CHARACTER SUBSTITUTION\n&CXR1SAV DC    4F'0'                   REGISTER 1 SAVE AREA B/C TRT\n&CXER1BS DC    F'0'                    ERROR EXIT SAVE ADDRESS\n&CXER2BS DC    F'0'                    ERROR ROUTINE SAVE ADDRESS\n&CXRTADR DC    F'0'                    RETURN ADDRESS\n&CXRTCOD DC    H'0'                    RETURN CODE SAVE AREA\n.LABDONE ANOP\n.*--------------------------------------------------------------------*\n.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *\n.*--------------------------------------------------------------------*\n         AIF   (&REGDFLG).A$RD\n         AIF   ('&LABEL'(1,1) EQ 'Y').LABON2 BYPASS IF LABEL REQUIRED\n         AIF   ('&REGSMCR' NE 'CHHEXMAC').A$RD\n         DS    16F                     REGISTER SAVE AREA\n         AGO   .A$RD                   DO NOT SET FLAG IF LABEL REQD\n.LABON2  ANOP\n&REGDFLG SETB  1\n&REGSAVR DS    16F                     REGISTER SAVE AREA\n.A$RD    ANOP\n.*--------------------------------------------------------------------*\n.RENT2   ANOP\n*---------------------------------------------------------------------*\n         AIF   ('&MF' EQ 'L').EXIT\n*                                                                     *\n*        CONVERT CHARACTERS TO HEX.                                   *\n*                                                                     *\n*         R1=SOURCE, R14=TARGET, R15=LENGTH                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n&CXBAL   DS    0H\n         XC    &CXRTCOD,&CXRTCOD       INITIALISE RETURN CODE\n         AIF   (T'&MF EQ 'O').NONR3    IF NON-RE PROGRAM BYPASS\n         CLC   &CXTABLE.+193(06),=X'0A0B0C0D0E0F' Q. CONSTANTS SET\n         BE    &CXLOOP                               Y. BYPASS\n         MVI   &CXTABLE,X'00'          HEX FILL FIRST BYTE THEN RIPPLE\n         MVC   &CXTABLE.+1(192),&CXTABLE  FILL REST\n         MVC   &CXTABLE.+193(06),=X'0A0B0C0D0E0F'\n         MVC   &CXTABLE.+199(41),&CXTABLE FILL REST\n         MVC   &CXTABLE.+240(10),=X'F0010203040506070809'\n         MVC   &CXTABLE.+250(06),&CXTABLE FILL REST\n.NONR3   ANOP\n&CXLOOP  DS    0H\n         MVC   &CXBYTES.(2),0(1)\n         STM   14,1,&CXR1SAV           SAVE 1 BECAUSE OF TRT\n         MVI   &CXTABLE,X'F0'          SET HEX 00 TO PASS\n         L     14,&CXER1BS             LOAD ERROR EXIT ADDRESS\n         TRT   &CXBYTE1.(1),&CXTABLE   Q. IS IT IN &CXTABLE\n         BZR   14                         N. ERROR\n         TRT   &CXBYTE2.(1),&CXTABLE   Q. IS IT IN &CXTABLE\n         BZR   14                         N. ERROR\n         B     &CXCHOK1                BOTH BYTES OK\n&CXIGERR DS    0H\n         MVC   &CXRTCOD.(2),=H'8'      SET ERROR CODE\n         MVC   &CXBYTES.(2),&CXERRCH   SET ERROR HEX SUBSTITUTION\n&CXCHOK1 DS    0H\n         MVI   &CXTABLE,X'00'          RESET HEX 00\n         TR    &CXBYTES.(2),&CXTABLE   TRANSLATE BOT CHARS\n         NC    &CXBYTES.(2),=X'0F0F'   TURN HIGH NIBL OFF FOR 0 => 'F0'\n         LM    14,1,&CXR1SAV           RESTORE 1 BECAUSE OF TRT\n         PACK  0(1,14),&CXBYTE1        SWAP NIB OF LEFT &CXBYTE AND STO RE\n         OC    0(1,14),&CXBYTE2        OVERLAY 2ND &CXBYTE OVER FIRST\n         LA    1,2(1)                  UP SOURCE BY TWO\n         LA    14,1(14)                UP DESTINATION BY 1\n         BCTR  15,0                    DECREMENT LOOP COUNTER\n         BCTR  15,0                           BY 2\n         LTR   15,15                   Q. REACHED THE END\n         BP    &CXLOOP                    N. LOOP\n         L     14,&CXRTADR             LOAD RETURN ADDRESS\n         BR    14                      RETURN\n&CXBADAT DS    0H\n         LM    14,12,&REGSAVR          RESTORE REGISTERS\n         LH    15,&CXRTCOD             SET RETURN CODE\n         L     14,&CXER2BS             LOAD ERROR ROUTINE ADDRESS\n         BR    14                      BRANCH TO ERROR ROUTINE\n&CXBYPAS DS    0H\n.A$11    ANOP\n         STM   14,12,&REGSAVR          SAVE REGISTERS\n         MVC   &CXERRCH.(2),=C&CXERSUB MOVE HEX ERROR SUBSTITUTE CHAR\n         LA    14,&CXER1BR             LOAD EXIT ADDRESS\n         ST    14,&CXER1BS             SAVE EXIT ADDRESS\n         LA    14,&CXER2BR             LOAD ERROR ROUTINE ADDRESS\n         ST    14,&CXER2BS             SAVE ERROR ROUTINE ADDRESS\n         LA    14,&CXCHXT1             LOAD RETURN ADDRESS\n         ST    14,&CXRTADR             STORE RETURN ADDRESS\n         LA    14,&#TARGET             SET UP DESTINATION ADDRESS\n         AIF   ('&LENGTH'(1,1) NE '(').ACTLEN\n&LEN     SETA  K'&LENGTH-2\n&#LENGTH SETC  '&LENGTH'(2,&LEN)       REGISTER\n         LR    15,&#LENGTH             LENGTH TO BE CONVERTED\n         AGO   .FINLMV                 PASS AROUND\n.ACTLEN  ANOP\n         LA    15,&LENGTH              LENGTH TO BE CONVERTED\n.FINLMV  ANOP\n         LA    1,&#SOURCE              SET UP TO SOURCE ADDRESS\n         B     &CXBAL                  GO TO HEX => CHAR ROUTINE\n&CXCHXT1 DS    0H\n         LM    14,12,&REGSAVR          RESTORE REGISTERS\n         LH    15,&CXRTCOD             SET RETURN CODE\n*---------------------------------------------------------------------*\n&CX1ST   SETB  1\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E1      MNOTE 8,'CHHEX REQUIRES A SOURCE FIELD'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E2      MNOTE 8,'CHHEX REQUIRES A TARGET FIELD'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E3      MNOTE 8,'CHHEX REQUIRES A LENGTH'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E4      MNOTE 8,'CHHEX REQUIRES A CONVERSION ERROR ROUTINE ADDRESS'\n.EXIT    ANOP\n         POP   PRINT\n         MEXIT\n.*--------------------------------------------------------------------*\n         MEND\n*---------------------------------------------------------------------*\n*------- Macro  8. ISPVDEFX ------------------------------------------*\n         MACRO\n&NAME    ISPVDEFX &INM=,&ANM=,&FORMAT=,&LEN=,&OPT=,&MF=,&LIST=NO,      x\n               &TYPE=VAR,&HELP=NO\n         PUSH  PRINT\n         AIF   ('&LIST' NE 'NO').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   ('&HELP' EQ 'YES').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'ISPVDEFX' parameter    *\n* and it's use, pass parameter 'HELP=Yes'.                            *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* This macro is used to define addressability between a program and   *\n* ISPF variables.                                                     *\n*                                                                     *\n* In the normal form:                                                 *\n*   It is designed to create common variables the first time thru and *\n*   re-use them everytime the macro is invoked.                       *\n* In re-entrant form:                                                 *\n*   Use the MF=L and MF=E options.                                    *\n*                                                                     *\n* Parameters (for further details, refer to ISPF DMS manuals):        *\n*   1. INM=..... - ISPF variable name, enclosed in brackets ().       *\n*   2. ANM=..... - Internal (assembler) varaiable name.               *\n*   3. FORMAT=.. - Variable format, valid values are:                 *\n*                        CHAR FIXED BIT HEX DBCS USER                 *\n*   4. LEN=..... - Length of the variable in numeric bytes or         *\n*                  register (2) - (13). If register is used, the      *\n*                  length must be loaded ito the register.            *\n*   5. OPT=..... - Options, valid values are:                         *\n*                        COPY NOBSCAN LIST                            *\n*   6. MF=...... - Macro format. Omit for non re-entrant programs.    *\n*                  For re-entrant programs:                           *\n*                    E - EXEC format of macro                         *\n*                    L - LIST format of macro.                        *\n*   7. TYPE=.... - VARiable/CONstant for MF=L. For re-entrant programs*\n*                  to copy constant into GETMAINed variable.          *\n*   8. LIST=..... - Generate or suppress macro expansion, (YES/NO).   *\n*                                                                     *\n* Example of input:                                                   *\n*      ISPVDEFX INM=(ISPFname),ANM=int.name,FORMAT=CHAR,LEN=20        *\n*          - OR -                                                     *\n*      EXEC format:                                                   *\n*        ISPVDEFX INM=(ISPFname),ANM=int.name,FORMAT=CHAR,LEN=20,MF=E *\n*      LIST format:                                                   *\n*        ISPVDEFX MF=L           (default ,TYPE=VAR)                  *\n*          - or -                                                     *\n*        ISPVDEFX MF=L,TYPE=CONS (and move CONS to VAR)               *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n&NAME    DS    0H\n         GBLC  &VNAME\n         GBLB  &VDFX1ST,&VMFE1ST,&VNMF1ST\n         LCLA  &LL,&VLL\n         LCLC  &REGL\n&LL      SETA  K'&LEN\n&VLL     SETA  K'&ANM\n         AIF   (&VDFX1ST).A$00         IF NOT 1ST. BYPASS\n&VDFX1ST SETB  1                       SET 1ST. TIME THRU FLAG\n&VNAME   SETC  'IVD'.'&SYSNDX'         SET \"INDEX\"\n.A$00    ANOP\n         AIF   ('&MF' EQ 'L').A$11     BYPASS IF RE-ENT\n         AIF   ('&MF' EQ 'E').A$33     BYPASS IF RE-ENT\n         AIF   (T'&MF NE 'O').E1       INVALID FORMAT OF MF PARM\n         AIF   (&VNMF1ST).A$55         BYPASS IF NOT 1ST NON-R\n&VNMF1ST SETB  1                       SET 1ST. TIME THRU FLAG\n         B     &VNAME.L                BYPASS DATA DEFS AFTER 1ST. THRU\n         AGO  .A$111\n.A$11    ANOP\n.*--------------------------------------------------------------------*\n.*   LIST form of macro 'ISPVDEFX'                                    *\n.*--------------------------------------------------------------------*\n.A$111   ANOP\n*---------------------------------------------------------------------*\n*    LIST form of macro 'ISPVDEFX' (constant).                        *\n*---------------------------------------------------------------------*\n         AIF   ('&TYPE'(1,1) NE 'C').A$112\n         DS    F                       VDEFINE\n         DS    F                       ISPF NAME\n         DS    F                       INTERNAL NAME\n         DS    F                       VAR TYPE\n         DS    F                       VAR LENGTH\n         DS    F                       OPTION\n         DC    C'VDEFINE '             VDEF LITERAL\n         DC    CL10'          '        ISPF DEST (ALLOW FOR \"()\")\n         DC    C' '                    SPACER\n         DC    C'CHAR    '             VDEF FORMAT TYPE\n         DC    C' '                    SPACER\n         DS    CL2                     LENGTH SOURCE PRIOR CONVERSION\n         DC    C' '                    SPACER\n         DS    F                       R2 SAVEAREA FOR LEN CONVERSION\n         DS    D                       DBL WD LEN CONVERSION WK FLD\n         DS    F                       LENGTH CONVERTED TO FULL WD BIN\n         DC    C'&OPT    '             OPTIONS (NOT USED BY THIS RTN)\n         DS    F                       INTERNAL NAME ADDRESS STORE\n         AGO   .A$113\n.*--------------------------------------------------------------------*\n.A$112   ANOP\n*---------------------------------------------------------------------*\n*    LIST form of macro 'ISPVDEFX' (modifiable).                      *\n*---------------------------------------------------------------------*\n&VNAME.1 DS    F                       VDEFINE\n         DS    F                       ISPF NAME\n         DS    F                       INTERNAL NAME\n         DS    F                       VAR TYPE\n         DS    F                       VAR LENGTH\n         DS    F                       OPTION\n&VNAME.2 DC    C'VDEFINE '             VDEF LITERAL\n&VNAME.3 DC    CL10'          '        ISPF DEST (ALLOW FOR \"()\")\n         DC    C' '                    SPACER\n&VNAME.4 DC    C'CHAR    '             VDEF FORMAT TYPE\n         DC    C' '                    SPACER\n&VNAME.5 DS    CL2                     LENGTH SOURCE PRIOR CONVERSION\n         DC    C' '                    SPACER\n&VNAME.6 DS    F                       R2 SAVEAREA FOR LEN CONVERSION\n&VNAME.7 DS    D                       DBL WD LEN CONVERSION WK FLD\n&VNAME.8 DS    F                       LENGTH CONVERTED TO FULL WD BIN\n&VNAME.9 DC    C'&OPT    '             OPTIONS (NOT USED BY THIS RTN)\n&VNAME.V DS    F                       INTERNAL NAME ADDRESS STORE\n.A$113   ANOP\n*-----------------------------------------------------------------*\n         AIF   ('&MF' NE 'L').A$22     BYPASS IF NOT MF=L\n         POP   PRINT\n         MEXIT                         EXIT IF MF=L\n.A$22    ANOP\n&VNAME.L DS    0H\n         AIF   (T'&MF EQ 'O').A$44     BYPASS IF RE-ENT\n.A$33    ANOP\n*---------------------------------------------------------------------*\n*    EXEC form of macro 'ISPVDEFX'                                    *\n*---------------------------------------------------------------------*\n.EXMFE   ANOP\n         AIF   (&VMFE1ST).A$55          IF NOT 1ST. BYPASS\n&VMFE1ST SETB  1                        SET 1ST. TIME THRU FLAG\n*    Unique code                                                      *\n*---------------------------------------------------------------------*\n         MVI   &VNAME.2,C' '            SPACE FILL DATA\n         MVC   &VNAME.2+1(55),&VNAME.2  USING RIPPLE MOVE\n         MVC   &VNAME.2(7),=C'VDEFINE'  MOVE LITERAL\n         AGO   .A$441\n.A$44    ANOP\n*    Unique code                                                      *\n*---------------------------------------------------------------------*\n.A$441   ANOP\n         ST    R2,&VNAME.6             SAVE REG2\n         LA    R2,&VNAME.1             R1 DEST VALUE FOR \"CALL\"\n         LA    R1,&VNAME.2             ADDRESS OF PARAMETER\n         ST    R1,0(R2)                STORE ADDRESS\n         LA    R2,4(R2)                POINT TO NEXT ADDRESS POS\n         LA    R1,&VNAME.3             ETC...\n         ST    R1,0(R2)                    \"\n         LA    R2,4(R2)                    \"\n         LA    R2,4(R2)                <-- \" (ALLOW FOR 'INT NAME @')\n         LA    R1,&VNAME.4                 \"\n         ST    R1,0(R2)                    \"\n         LA    R2,4(R2)                    \"\n         LA    R1,&VNAME.8                 \"\n         ST    R1,0(R2)                    \"\n         LA    R2,4(R2)                    \"\n         LA    R1,&VNAME.9                 \"\n         ST    R1,0(R2)                    \"\n         MVI   0(R2),X'80'                 \"\n         L     R2,&VNAME.6                RESET R2\n.A$55    ANOP\n*-----------------------------------------------------------------*\n*    Common code                                                      *\n*---------------------------------------------------------------------*\n         AIF   (T'&MF EQ 'O').A$66\n         MVC   &VNAME.4(8),=CL8'&FORMAT' SET UP \"(ISPF-FORM)\" VALUE\n.A$66    ANOP\n         MVC   &VNAME.3(10),=CL10'&INM'   SET UP \"(ISPF-NAME)\" VALUE\n.*--------------------------------------------------------------------*\n.* Test if length is supplied in a register\n.*--------------------------------------------------------------------*\n         AIF ('&LEN'(1,1) NE '(').NREGL\n&PL      SETA  K'&LEN\n&REGL    SETC  '&LEN'(2,&PL-2)            EXTRACT REGISTER\n         ST    &REGL.,&VNAME.8            SAVE REGISTER PASSED LENGTH\n         AGO   .FINLEN                    .BYPASS NUMERIC LENGTH\n.NREGL   ANOP\n         MVC   &VNAME.5(&LL),=CL&LL'&LEN' SET UP LENGTH\n         PACK  &VNAME.7,&VNAME.5(&LL)     PACK LENGTH FOR CONVERSION\n         CVB   R1,&VNAME.7                CONV LEN TO FULL WD BIN\n         ST    R1,&VNAME.8                SAVE CONVERTED  LENGTH\n.FINLEN  ANOP\n.*--------------------------------------------------------------------*\n         LA    R1,&ANM                    ADDRESS OF INTERNAL NAME\n         ST    R1,&VNAME.1+8              SAVE INT NAME @\n         LA    R1,&VNAME.1                LOAD PARAMETER LIST ADDRESS\n         L     15,ISPLINK                 LOAD \"ISPLINK\" ADDRESS\n.*       L     15,=V(ISPLINK)             LOAD \"ISPLINK\" ADDRESS\n         BALR  14,15                      BRANCH AND LINK\n         POP   PRINT\n         MEXIT\n.*--------------------------------------------------------------------*\n.E1      MNOTE 8,'INVALID \"MF\" PARAMETER PASSED'\n.*--------------------------------------------------------------------*\n         POP   PRINT\n         MEND\n*---------------------------------------------------------------------*\n*------- Macro  9. ISPEXEC -------------------------------------------*\n         MACRO\n&NAME    ISPEXEC &XTEXT,&XLENG,&LIST=NO,&HELP=NO,&LONG=NO,&INIT=NO,    +\n               &MF=,&TYPE=VAR\n         PUSH  PRINT\n         AIF   ('&LIST' NE 'NO').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   ('&HELP' EQ 'YES').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'ISPEXEC' parameter and *\n* it's use, pass parameter 'HELP=Yes'.                                *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro to initialise an \"ISPF\" environment and set up variables to   *\n*   facilitate executing ISPEXEC commands.                            *\n*                                                                     *\n* Format:                                                             *\n*   1. ISPEXEC no.parameter/INIT=Y          (Required on first        *\n*                                            execution. Requires both *\n*                                            MF=L and MF=E for re-    *\n*                                            entrant programs.        *\n*   2. ISPEXEC 'normal CLIST type text'                               *\n*   3. ISPEXEC int.var.name,int.var.length                            *\n*                                                                     *\n* Parameters:                                                         *\n*   1. XTEXT     - a) Quoted literal (follows the normal CLIST syntax *\n*                     after the ISPEXEC command).                     *\n*                            - OR -                                   *\n*                  b) Variable name that contains the normal CLIST    *\n*                     syntax following the ISPEXEC command.           *\n*   2. XLENG     - Length of the variable if Format '2' used for the  *\n*                  'XTEXT' parameter.                                 *\n*   3. LONG=.... - Specify long move (MVCL) if Format '2' used.       *\n*   4. LIST=.... - Generate or suppress macro expansion, (YES/NO).    *\n*   5. INIT=.... - Force initial invocation, (YES/NO).                *\n*   6. TYPE=.... - VARiable/CONstant for MF=L. For re-entrant programs*\n*                  to copy constant into GETMAINed variable.          *\n*   7. MF=....   - Macro format. Only required for re-entrant         *\n*                  programs and then ONLY ON the initialisation       *\n*                  invocation.                                        *\n*                  For re-entrant programs:                           *\n*                    E - EXEC format of macro on INIT invocation.     *\n*                    L - LIST format of macro.                        *\n*                                                                     *\n* NOTE:                                                               *\n*      1. The first execution must be of the macro WITHOUT the XTEXT  *\n*         parameter or WITH the INIT=Y parameter.                     *\n*      2. Does not cover \"VDEF\", \"VCOPY\", \"VDELETE\", \"VRESET\" or      *\n*         \"VREPLACE\".                                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         AIF   (T'&NAME EQ 'O').NONAME1    Bypass if NAME missing\n&NAME    DS    0H\n.NONAME1 ANOP\n         GBLB  &ISPI1ST\n         GBLC  &ISPNAME,&ISPTYP,&ISPEXEP,&ISPBUFA,&ISPBUFL,&ISPBUFR\n         LCLC  &ISPLABB\n         AIF   (&ISPI1ST).A$00\n&ISPI1ST SETB  1\n&ISPNAME SETC  'INI'.'&SYSNDX'\n.A$00    ANOP\n         AIF   ('&INIT'(1,1) EQ 'Y').INITIL\n         AIF   (T'&XTEXT NE 'O').SETEXEC    Bypass if INIT=N + param\n.*--------------------------------------------------------------------*\n.*   Initialisation form of macro                                     *\n.*--------------------------------------------------------------------*\n.INITIL  ANOP\n&ISPTYP  SETC  'LOAD'\n&ISPEXEP SETC  '&ISPNAME'.'1'\n&ISPBUFA SETC  '&ISPNAME'.'2'\n&ISPBUFL SETC  '&ISPNAME'.'3'\n&ISPBUFR SETC  '&ISPNAME'.'4'\n&ISPLABB SETC  '&ISPNAME'.'X'\n         AIF   (T'&MF NE 'O').A$11   RE-ENTRANT BYPASS\n         B     &ISPLABB                PYPASS DATA\n.A$11    ANOP\n         AIF   ('&MF' EQ 'E').A$22   RE-ENTRANT LIST EXIT\n*---------------------------------------------------------------------*\n*    LIST form of macro 'ISPEXEC' initialisation                      *\n*---------------------------------------------------------------------*\n         DS    0F                      FULLWORD ALLIGNMENT\n         AIF   ('&TYPE'(1,1) NE 'C').A$12\n         DS    A                       A(ISPF LINK INTERFACE)\n         DS    A                       A(ISPF EXEC INTERFACE)\n         DC    A(0)                    A(COMMAND LENGTH)\n         DC    A(0)                    A(COMMAND BUFFER)\n         DC    F'0'                    COMMAND LENGTH\n         DS    0CL300                  COMMAND BUFFER\n         AGO   .A$13\n.A$12    ANOP\nISPLINK  DS    A                       A(ISPF LINK INTERFACE)\nISPEXEC  DS    A                       A(ISPF EXEC INTERFACE)\n&ISPEXEP DC    A(&ISPBUFL)             A(COMMAND LENGTH)\n&ISPBUFA DC    A(&ISPBUFR)             A(COMMAND BUFFER)\n&ISPBUFL DC    F'0'                    COMMAND LENGTH\n&ISPBUFR DS    0CL300                  COMMAND BUFFER\n.A$13    ANOP\n         DC    CL250' ',CL50' '        INITIALISED TO SPACES\n         AIF   ('&MF' EQ 'L').MEXIT  Re-entrant list, Exit\n&ISPLABB DS    0H\n.*       AIF   (T'&MF EQ 'O').A$33   Non RE-ENTRANT BYPASS\n.A$22    ANOP\n*---------------------------------------------------------------------*\n*    EXEC form of macro 'ISPEXEC' initialisation                      *\n*---------------------------------------------------------------------*\n         LA    R1,&ISPBUFL             LOAD ADDRESS OF COMMAND LENGTH\n         ST    R1,&ISPEXEP             STORE COMMAND LENGTH ADDRESS\n         LA    R1,&ISPBUFR             LOAD ADDRESS OF COMMAND BUFFER\n         ST    R1,&ISPBUFA             STORE COMMAND BUFFER ADDRESS\n         OI    &ISPBUFA,X'80'          MOVE LAST PARM INDICATOR\n*\n.A$33    ANOP\n*        LOAD  EP=ISPLINK              FETCH ISPF LINK INTERFACE\n         LOAD  EP=ISPLINK              FETCH ISPF LINK INTERFACE\n         ST    R0,ISPLINK              SAVE ITS ADDRESS\n*        LOAD  EP=ISPEXEC              FETCH ISPF EXEC INTERFACE\n         LOAD  EP=ISPEXEC              FETCH ISPF EXEC INTERFACE\n         ST    R0,ISPEXEC              SAVE ITS ADDRESS\n.A$99    ANOP\n*---------------------------------------------------------------------*\n         AIF   (T'&XTEXT EQ 'O').MEXIT      Exit if no parameter\n.*-------------------------------------------------------------------*\n.SETEXEC ANOP\n         AIF   (T'&XLENG NE 'O').MVX2\n         AIF   ('&XTEXT'(1,1) NE '''').E3\n.*-------------------------------------------------------------------*\n         LCLC  &CHAR,&AMPER\n         LCLA  &LC,&QC,&AC\n&AMPER   SETC  '&&'\n&LC      SETA  K'&XTEXT                     LOOP COUNTER\n&QC      SETA  0                            QUOTES COUNTER\n&AC      SETA  0                            AMPERSAND COUNTER\n&CP      SETA  0                            CHARACTER POINTER\n.LOOP1   ANOP\n&CP      SETA  &CP+1                        INCREMENT CHARACTER PTR\n&CHAR    SETC  '&XTEXT'(&CP,1)\n.TQUOT   ANOP\n         AIF   ('&CHAR' NE '''').TAMPR\n&QC      SETA  &QC+1\n         AGO   .NXTCH\n.TAMPR   ANOP\n         AIF   ('&CHAR.&CHAR' NE '&AMPER').NXTCH\n&AC      SETA  &AC+1\n.NXTCH   ANOP\n         AIF   (&CP LT &LC).LOOP1           LOOP TILL END\n&LC      SETA  &LC-2-(((&QC-2)/2)+(&AC/2))\n         MVC   &ISPBUFR.(&LC),=C&XTEXT\n.*-------------------------------------------------------------------*\n         LA    1,&LC                   LOAD LENGTH\n         AGO   .LA\n.MVX2    ANOP\n         AIF   ('&XTEXT'(1,1) EQ '''').E2\n         AIF   ('&LONG'(1,1) EQ 'N').MVX4\n.MVX3    ANOP\n         LA    R0,&ISPBUFR             LOAD ADDRESS OF DESTINATION\n         LA    R1,&XLENG               LOAD LENGTH OF MOVE\n         LA    R14,&XTEXT              LOAD SOURCE ADDRESS\n         LA    R15,&XLENG              LOAD LENGTH OF MOVE\n         ICM   R15,B'1000',=C'         '            MOVE PAD CHARACTER\n         MVCL  R0,R14                  SET AREA TO ALL SPACES\n         AGO   .MVX5\n.MVX4    ANOP\n         MVC   &ISPBUFR.(&XLENG),&XTEXT\n.MVX5    ANOP\n         LA    1,&XLENG                LOAD LENGTH\n.LA      ANOP\n         ST    1,&ISPBUFL              STORE LENGTH\n         LA    1,&ISPEXEP              LOAD PARAMETER LIST POINTER\n         L     15,ISPEXEC              LOAD 'ISPEXEC' MODULE ADDR\n         BALR  14,15                   CALL 'ISPEXEC'\n         AGO   .MEXIT                       Exit macro\n*---------------------------------------------------------------------*\n.E1      MNOTE 12,'ISPEXEC REQUIRES A FUNCTION PARAMETER LIST'\n         AGO   .MEXIT                       Exit macro\n.E2      MNOTE 12,'VARIABLE NAME MUST NOT BE QUOTED'\n         AGO   .MEXIT                       Exit macro\n.E3      MNOTE 12,'VARIABLE NAME REQUIRES A LENGTH'\n         AGO   .MEXIT                       Exit macro\n.*--------------------------------------------------------------------*\n.MEXIT   ANOP\n         POP   PRINT\n         MEND\n*---------------------------------------------------------------------*\n*------- Macro 11. ADYN ----------------------------------------------*\n         MACRO\n&NAME    ADYN  &ACTION=INFO,                                           +\n               &BASE=,                                                 +\n               &BLKSIZE=,                                              +\n               &BUFNO=,                                                +\n               &CCP=YES,                                               +\n               &COPIES=,                                               +\n               &DATA=,                                                 +\n               &DD=,                                                   +\n               &DDC=,                                                  +\n               &DDR=NO,                                                +\n               &DEST=,                                                 +\n               &DISP=,                                                 +\n               &DSN=,                                                  +\n               &DSNR=NO,                                               +\n               &DSORG=,                                                +\n               &ERROR=,                                                +\n               &FCB=,                                                  +\n               &HELP=NO,                                               +\n               &LIST=YES,                                              +\n               &LRECL=,                                                +\n               &MEMBER=,                                               +\n               &MF=,                                                   +\n               &PARMT=PARM,                                            +\n               &PDUMP=NO,                                              +\n               &PDUMPX=,                                               +\n               &PERMA=YES,                                             +\n               &RECFM=,                                                +\n               &REGR=YES,                                              +\n               &REUSE=NO,                                              +\n               &RLSE=,                                                 +\n               &R1=R1,                                                 +\n               &R4=R4,                                                 +\n               &R5=R5,                                                 +\n               &R6=R6,                                                 +\n               &R7=R7,                                                 +\n               &SPACE=,                                                +\n               &SYSOUT=,                                               +\n               &UCLOSE=NO,                                             +\n               &UNIT=,                                                 +\n               &VOLR=NO,                                               +\n               &VOLSER=\n*--------------------------START OF ADYN------------------------------*\n&NAME    DS    0H\n         PUSH  PRINT\n         AIF   ('&LIST' NE 'NO').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   ('&HELP' EQ 'YES').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'ADYN' parameters and   *\n* use pass parameter 'HELP=YES'.                                      *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n***********************************************************************\n*                                                                     *\n* DYNAMIC ALLOCATION MACRO.      Written by A. Kara.                  *\n* -------------------------                                           *\n*           N O T E - N O T E - N O T E - N O T E - N O T E           *\n*                                                                     *\n*   This routine saves and uses the following general registers:      *\n*      R1, R4, R5, R6, R7, R14 and R15.                               *\n*   If any of these registers are used as base registers or anchors   *\n*   for the DSECT containing the DATA format of the macro (if used),  *\n*   either substitute with an unused one (refer parameter 'Rn') or do *\n*   not use this macro.                                               *\n*                                                                     *\n*   This macro is only applicable to DASD and cannot be used for      *\n*   tapes.                                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n* Macro to generate code to dynamically Allocate/Info/Delete/         *\n*  Unallocate|Free/Deconcatenate/Concatenate/Reallocate               *\n*                                                                     *\n*   Parameters:                                                       *\n*       1. ACTION  - valid actions are:                               *\n*                    'Info'    - advise if dataset is allocated.      *\n*                                Requires the following minimum       *\n*                                parameters:                          *\n*                                  DD and DSN.                        *\n*                    'Alloc'   - allocate datest (basically pass jcl  *\n*                                format parameters).                  *\n*                                To reallocate, pass parameter of     *\n*                                REUSE=YES.                           *\n*                    'Unalloc'/'Free'/'DEConc'                        *\n*                              - any one of these command will        *\n*                                unallocate the dataset/concatenations*\n*                    'DELete'  - delete allocates the DSN with        *\n*                                'DISP=(OLD,DELETE,DELETE)' then frees*\n*                                it.                                  *\n*                    'Conc'    - concatenates the dd name defined on  *\n*                                the 'DDC' parameter to the 'DD' parm.*\n*                                                                     *\n*       2. BASE    - Register to be used as a base register for the   *\n*                    SVC 99 DSECT 'S99RBP'. This register must be     *\n*                    loaded with the address of the area where the    *\n*                    SVC 99 parameter list may be built. Also used to *\n*                    invoke the 'DYNALLOC' routine automatically.     *\n*                    (Do not enclose in brackets.)                    *\n*                    If the base parameter is not passed, the         *\n*                    following will need to be explicitly coded:      *\n*                    1. Before the invocation of the 'ADYN' macro:    *\n*                                                                     *\n*                         USING S99RBP,Rn  establish addresability    *\n*                                                                     *\n*                    2. On return from the macro:                     *\n*                                                                     *\n*                         LR    R1,Rn  req blk ptr in R1 for dynalloc *\n*                                      (both Rn must be same register)*\n*                         DYNALLOC                                    *\n*                                                                     *\n*       3. BLKSIZE - Block size. (Same restrictions as 'LRECL').      *\n*                                                                     *\n*       4. CCP     - Wheteher to make concatenation permanent.        *\n*                    Valid values are YES/NO with YES as default.     *\n*                                                                     *\n*       5. COPIES  - Number of copies to print (for SYSOUT DD's)      *\n*                                                                     *\n*       6. DATA    - Valid values are 'VARiable'/'CONstant'/'IBM'.    *\n*                    Set up the data fields if you use the parameter  *\n*                    'PARMT=DATA' in your program:                    *\n*                    Set to 'VARiable' if you want a map of the data  *\n*                    fields used for variable parameter passing. This *\n*                    is required in your getmained DSECT for re-      *\n*                    entrant programs.                                *\n*                    You may initialise this area by coding a macro   *\n*                    with 'DATA=CONstant' in your constant data area  *\n*                    and on the macro pass all the parameters as      *\n*                    though you were coding a macro with 'PARMT=PARM' *\n*                    and moving it over the variable part. The max    *\n*                    length of the data is 123 bytes.  If the program *\n*                    is not re-entrant you only need to code the macro*\n*                    with the parameter of 'DATA=VARiable'.           *\n*                    In all cases supply a macro with 'DATA=IBM' to   *\n*                    define the IBM required macros. If this is not   *\n*                    defined in your program, you must explicitly     *\n*                    define the following ibm macros in your program  *\n*                          'IEFZB4D0'                                 *\n*                          'IEFZB4D2'                                 *\n*                    There should only be 1 macro with DATA=IBM/VAR   *\n*                    however you may have as many DATA=CON as you     *\n*                    like. DATA=IBM/VAR generate labels while 'CON'   *\n*                    does not.                                        *\n*                                                                     *\n*       7. DD      - DD name to be allocated. In case of a 'Conc'     *\n*                    action, concatenate the 'DDC' parm to this.      *\n*                    If parameter 'DDR=YES' is used with 'PARMT=PARM' *\n*                    this paramater must point to a variable name in  *\n*                    the data area.                                   *\n*                                    - or -                           *\n*                    DD=(varname) if the DDname is to be taken from   *\n*                    a variable.                                      *\n*                    For DDR=Yes, allign the DD variable on a full-   *\n*                    word boundary to eliminate allignament warning   *\n*                    assembly messages.                               *\n*                                                                     *\n*       8. DDC     - DD name to concatenate to DD name with 'Conc'.   *\n*                                                                     *\n*       9. DDR     - DD name to be returned and placed in the variable*\n*                    specified for the 'DD' parameter after an        *\n*                    'Alloc' request without a DD parm. Set to either *\n*                    YSE/NO ('NO' is the default).                    *\n*                    If 'PARMT=DATA' is used, the DD name is returned *\n*                    in the variable 'YDD' which would have been      *\n*                    defined by the ADYN macro with 'PARMT=VAR'.      *\n*      10. DEST    - Printer-id destination with 'SYSOUT'             *\n*                                                                     *\n*      11. DISP    - Standard JCL type DISP parameter, eg.            *\n*                    'DISP=(NEW,CATLG,DELETE)'                        *\n*                    (default of 'OLD' for 'Allocate' action.)        *\n*                    For new dataset allocation without a 'DSN='      *\n*                    but rather a 'DSNR=' parameter, the 2nd. and 3rd.*\n*                    disposition parameter will be automatically      *\n*                    changed to '(....,DELETE,DELETE)'.               *\n*                                                                     *\n*      12. DSN     - DSNAME (unquoted of course) or '*' for terminal. *\n*                                    - or -                           *\n*                    Variable name to return the DSN name in, after an*\n*                    'Info' request. (If 'PARMT=DATA' is used the DSN *\n*                    will be returned in the variable 'YDSN' which    *\n*                    would have been defined by the ADYN macro with   *\n*                    'PARMT=VAR'.)                                    *\n*                                    - or -                           *\n*                    If the action is ALLOC and the dataset name is   *\n*                    stored in a variable and PARMT=PARM is required, *\n*                    indicate the variable's name by specifying       *\n*                    'DSN=(varname)'.                                 *\n*                    NOTE - This variable must be specified if the    *\n*                    'DSNR=Yes' parameter is used. Use 'DSN=YDSN' for *\n*                    'PARMT=VAR'.                                     *\n*                    For DSNR=Yes, allign the DSN variable on a full- *\n*                    word boundary to eliminate allignament warning   *\n*                    assembly messages.                               *\n*                                                                     *\n*      13. DSNR    - DSN name to be returned and placed in the        *\n*                    variable specified for the 'DSN' parameter after *\n*                    an 'Alloc' request without a DSN parm. Set to    *\n*                    either YES/NO ('NO' is the default).             *\n*                    If 'PARMT=DATA' is used, the DSN name is returned*\n*                    in the variable 'YDSN' which would have been     *\n*                    defined by the ADYN macro with 'PARMT=VAR'.      *\n*                    >>>>>>>>>>>>>>>>>>>> NOTE <<<<<<<<<<<<<<<<<<<<<< *\n*                    Will force 'DISP=(...,DELETE,DELETE)' to prevent *\n*                    allocations of datasets with variable names all  *\n*                    over the place........                           *\n*                    >>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<< *\n*                                                                     *\n*      14. ERROR   - Label to branch to in case of error. If this     *\n*                    parameter is not passed you will have to code    *\n*                    your own return code test:                       *\n*                          LTR  R15,R15                               *\n*                          BNZ  ERROR01                               *\n*                                                                     *\n*      15. FCB     - Forms Control Buffer image id                    *\n*                                                                     *\n*      16. HELP    - Set to YES/NO to include these parameter comments*\n*                    into the assembly listings. The default is 'NO'. *\n*                                                                     *\n*      17. LIST    - Set to YES/NO to generate macro expansion.       *\n*                    Default is 'YES'.                                *\n*                                                                     *\n*      18. LRECL   - Logical record size. As a keyword, pass as an    *\n*                    integer < 32760. As data pass as a halfword.     *\n*                                                                     *\n*      19. MEMBER  - Member name or GDG generation. The GDG generation*\n*                    must be numeric an can take the format -n, 0, n  *\n*                    or +n.                                           *\n*                                    - or -                           *\n*                    MEMBER=(member) if the member name is to be      *\n*                    taken from a variable and PARMT=PARM.            *\n*                                                                     *\n*      20. MF      - Macro format. Must be coded as MF=E to generate  *\n*                    code and MF=L either in a GETMAINed DSECT and/or *\n*                    data area. MF=L defines 16 full words as a       *\n*                    register save area (will not be defined if the   *\n*                    area has already been defined by a prior macro). *\n*                    These 16 full words are appended to both the     *\n*                    DATA=VAR/CON areas if used.                      *\n*                                                                     *\n*      21. PARMT   - Parameter type.                                  *\n*               'PARM'    - Keyword parameters passed (default) on    *\n*                           the EXEC form of the macro.               *\n*               'DATA'    - Parameters passed as data from the 'ADYN' *\n*                           DSECT. If parameters are passed as        *\n*                           variable data, a keyword entry of 'DATA'  *\n*                           is required to tell the macro to process  *\n*                           that parameter from the data area (in     *\n*                           this case the data area must be set up as *\n*                           required).                                *\n*                           (Default is 'PARM'.)                      *\n*                                                                     *\n*      22. PERMA   - 'Permanent allocate' attribute. Prevents         *\n*                    datasets from being automatically dealocated when*\n*                    closed (in on-line environments).                *\n*                    valid values are YES/NO with 'YES' as default.   *\n*                                                                     *\n*      23. PDUMP   - Invoke the PDUMP utility just prior to issuing   *\n*                    the DYNALLOC SVC.                                *\n*                                                                     *\n*      24. PDUMPX  - This parameter is used with the PDUMP parameter  *\n*                    and you may specify an exit point address to     *\n*                    branch to by entering the 'QUIT' command in      *\n*                    PDUMP thereby bypassing execution of DYNALLOC.   *\n*                                                                     *\n*      25. RECFM   - Record format.                                   *\n*                                                                     *\n*      26. REGR    - Set to YES/NO to restore registers on return     *\n*                    from macro, default is 'YES'.                    *\n*                    (Refer note \"A\" below.)                          *\n*                                                                     *\n*      27. REUSE   - Use this parameter if you wany to reallocate the *\n*                    DD name without having to free it.  The macro    *\n*                    will generate the Free statements prior to       *\n*                    Allocation. Set to YES/NO ('NO' is the default). *\n*                                                                     *\n*      28. RLSE    - Release unused space indicator. Not required for *\n*                    keyword parameters as would be passed on the     *\n*                    SPACE= keyword. However, is required if data     *\n*                    passed as there is no equivalent data area.      *\n*                    Valid values are YES/NO with 'NO' as default.    *\n*                                                                     *\n*      29. Rn      - Substitute specified register for the nominated  *\n*                    register in this routine. Registers that may be  *\n*                    substituted are:                                 *\n*                       R1, R4, R5, R6 and R7.                        *\n*                    NOTE - You may use R14 and R15 as substitute     *\n*                           registers.                                *\n*                                                                     *\n*      30. SPACE   - Standard JCL type space parameter, eg.           *\n*                    'SPACE=(TRK,(2,2,1),RLSE)'                       *\n*                    NOTE - In DATA format of the macro, RLSE is      *\n*                           ignored and you must specify the RLSE=YES *\n*                           paremeter.                                *\n*                                                                     *\n*      31. SYSOUT  - SYSOUT class and writer-name:                    *\n*                    eg. SYSOUT=X, SYSOUT=(A,INTRDR),                 *\n*                        SYSOUT=(A,FREDWRTR)                          *\n*                                                                     *\n*      32. UCLOSE  - Unalloc dataset on closing. If this option is to *\n*                    be effective, it must be coded as UCLOSE=YES for *\n*                    both types of parameter passing as there is no   *\n*                    equivalent data area.                            *\n*                    Valid values are YES/NO with 'NO' as default.    *\n*                                                                     *\n*      33. UNIT    - Device unit type. Any valid device unit as would *\n*                    be accepted on JCL.                              *\n*                                                                     *\n*      34. VOLSER  - Volume serial.                                   *\n*                                    - or -                           *\n*                    VOLSER=(volser) if the member name is to be      *\n*                    taken from a variable and PARMT=PARM.            *\n*                    For VOLR=Yes, allign the VOLSER variable on a    *\n*                    full-word boundary to eliminate allignament      *\n*                    warning assembly messages.                       *\n*                                                                     *\n*      35. VOLR    - VOLSER name to be returned and placed in the     *\n*                    variable specified for the 'VOLSER' parameter    *\n*                    after an 'Alloc' request without a VOLSER value. *\n*                    Set to either YES/NO ('NO' is the default).  If  *\n*                    'PARMT=DATA' is used, the VOLSER name is returned*\n*                    in the variable 'YVOLSER' which would have been  *\n*                    defined by the ADYN macro with 'PARMT=VAR'.      *\n*                                                                     *\n*   NOTES -                                                           *\n*      A) Macro format parameter of 'MF=.' Is mandatory.              *\n*         A macro with 'MF=L' is required in your program to generate *\n*         a register save area as registers R1,R4,R5,R6,R7,R14,R15 are*\n*         used in the program. All registers except R15 will be       *\n*         reset on return from the macro. R15 will contain the return *\n*         code from the 'DYNALLOC' routine.                           *\n*                                                                     *\n*      B) If parameter 'PARMT=DATA' is used:                          *\n*         Must issue an 'ADYN' macro with 'DATA=VARiable'. For re-    *\n*         entrant programs, suggest you initialise the data area in   *\n*         your DSECT by copying over it data initialised in your      *\n*         constant area from an 'ADYN' macro using 'DATA=CONstant'.   *\n*                                                                     *\n*      C) Must have 'DATA=IBM' to include the IBM DSECTs needed for   *\n*         SVC 99.                                                     *\n*                                                                     *\n*      D) Space requirements:                                         *\n*         Allow 300 bytes for SVC 99 parameter list, (ie. data area   *\n*         pointer to by the 'BASE' parameter).                        *\n*         Allow 123 bytes for both constant and variable data area    *\n*         created by the 'DATA=CON/VAR' parameter. Add 64 (16 x 4)    *\n*         bytes if this expansion stores the register save areas      *\n*         (refer to the MF parameter).                                *\n*                                                                     *\n*      E) On the EXEC form of the macro, R15 contains the return code *\n*         from the 'DYNALLOC' routine.  R0 contains the error code in *\n*         the high 2 order bytes and the information reason code in   *\n*         the low 2 order bytes.  All the other registers wiil be     *\n*         reset to their initial value on entering the macro.         *\n*         NOTE - Note the comment about register usage in this macro  *\n*                versus your program's register usage.                *\n*                                                                     *\n***********************************************************************\n.A$HELPE ANOP\n         LCLC  &#DISP,&#DISP1,&#DISP2,&#DISP3,&#ACTION,&#PRIM,&#SECOND\n         LCLC  &#RLSE,&#DSORG,&#BUFNO,&#DIRB,&#SPACET,&#DDC\n         LCLC  &#MEMBER,&#DD,&#DDR,&#DSN,&#RECFM,&#LRECL,&#BLKSZ\n         LCLC  &#UNIT,&#VOLSER,&#CLASS,&#WRTR,&#DEST,&#FCB,&#COPIES\n         LCLC  &@DSNR,&@DDR,&#DSNR,&#DSNV,&#REUSEF\n         LCLC  &#1,&#4,&#5,&#6,&#7\n         LCLC  &#PERMA,&#CHDISP\n         LCLC  &#VOLR,&#VOLV,&@VOLR,&VARNM\n         GBLC  &REGSMC1,&REGSMC2\n.*\n.*--------------------------------------------------------------------*\n.*\n         LCLC  &INDEX,&DELLAB\n.*\n         LCLA  &PL,&TUS\n.*--------------------------------------------------------------------*\n         GBLC  &REGSAVR,&REGSMCR\n         GBLB  &REGSFLG,&REGDFLG,&ADYNFL0,&ADYNFL1\n         AIF   (&REGSFLG).A$RS\n&REGSAVR SETC  'GB'.'&SYSNDX'.'#'\n&REGSMCR SETC  'ADYN'\n&REGSMC1 SETC  'ADYN'\n&REGSMC2 SETC  'ADYN'\n&REGSFLG SETB  1\n.A$RS    ANOP\n&#CHDISP SETC  'NO'\n         AIF   (&ADYNFL0).A$RT\n&ADYNFL0 SETB  1\n.*-------------- ADYN EQUATES FOR MEANINGFULL VALUES -----------------*\n$SHR     EQU X'08'\n$NEW     EQU X'04'\n$MOD     EQU X'02'\n$OLD     EQU X'01'\n$UNCATLG EQU X'01'\n$CATLG   EQU X'02'\n$DELETE  EQU X'04'\n$KEEP    EQU X'08'\n$FBA     EQU X'94'\n$VBA     EQU X'54'\n$FB      EQU X'90'\n$VB      EQU X'50'\n$U       EQU X'C0'\n$F       EQU X'80'\n$V       EQU X'40'\n$POU     EQU X'03'\n$PSU     EQU X'41'\n$DAU     EQU X'21'\n$PO      EQU X'02'\n$PS      EQU X'40'\n$DA      EQU X'20'\n.A$RT    ANOP\n.*--------------------------------------------------------------------*\n.*  INITIALISE SYSLIST TYPE VARIABLES                                 *\n.*--------------------------------------------------------------------*\n&#1      SETC  '&R1.'\n&#4      SETC  '&R4.'\n&#5      SETC  '&R5.'\n&#6      SETC  '&R6.'\n&#7      SETC  '&R7.'\n&#ACTION SETC  '&ACTION'\n&#DISP1  SETC  '&DISP(1)'\n&#DISP2  SETC  '&DISP(2)'\n&#DISP3  SETC  '&DISP(3)'\n         AIF   (T'&DISP EQ 'O').BYPDP3        BYPASS IF DISP OMITTED\n         AIF   ('&#DISP1'(1,1) NE 'N').BYPDP3 BYPASS IF DISP NOT 'NEW'\n         AIF   (T'&#DISP2 NE 'O').BYPDP2      BYP IF DISP2 PRESENT\n&#DISP2  SETC  'CATLG'\n.BYPDP2  ANOP\n         AIF   (T'&#DISP3 NE 'O').BYPDP3      BYP IF DISP3 PRESENT\n&#DISP3  SETC  'DELETE'\n.BYPDP3  ANOP\n&#SPACET SETC  '&SPACE(1)'\n&#PRIM   SETC  '&SPACE(2,1)'\n&#SECOND SETC  '&SPACE(2,2)'\n&#DIRB   SETC  '&SPACE(2,3)'\n&#CLASS  SETC  '&SYSOUT(1)'\n&#WRTR   SETC  '&SYSOUT(2)'\n&#RLSE   SETC  '&SPACE(3)'\n         AIF (T'&#RLSE EQ 'O').TPARMT1     BYPASS IF NO 'RLSE' PARM\n&#RLSE   SETC '&#RLSE'(1,1)                EXTRACT 1ST. CHAR\n.TPARMT1 ANOP\n         AIF ('&PARMT'(1,1) EQ 'P').GRELSE IF NON-VAR RLSE IN SPACE\n         AIF (T'&#RLSE NE 'YES').GRELSE    BYPASS IF 'RLSE=YES' NOT REQ\n&#RLSE   SETC  'R'                         SET 'RLSE' PARM\n.GRELSE  ANOP\n&#DSORG  SETC  '&DSORG'                    SET 'DSORG' WORK PARM\n         AIF (T'&#DSORG NE 'O').DSORGE     IF DSORG PARM SUPPLIED BYP\n         AIF (T'&#SPACET EQ 'O').DSORGE    IF NO SPACE TYPE BYPASS\n         AIF (T'&#DIRB EQ 'O').DSORGPS     IF DIRB NOT SUPPLIED PS ORG\n&#DSORG  SETC  'PO'\n         AGO .DSORGE\n.DSORGPS ANOP\n&#DSORG  SETC  'PS'\n.DSORGE  ANOP\n.*-------------------------------------------------------------------*\n.*     INITIALISE VARIABLES SO THEY MAY BE MANIPULATED               *\n.*-------------------------------------------------------------------*\n&#DD     SETC '&DD'\n&#DDC    SETC '&DDC'\n&#DDR    SETC '&DDR'\n&#DSNR   SETC '&DSNR'\n&#DSN    SETC '&DSN'\n&#MEMBER SETC '&MEMBER'\n&#VOLSER SETC '&VOLSER'\n&#VOLR   SETC '&VOLR'\n&#UNIT   SETC '&UNIT'\n&#DEST   SETC '&DEST'\n&#FCB    SETC '&FCB'\n&#COPIES SETC '&COPIES'\n&#BUFNO  SETC '&BUFNO'\n&#RECFM  SETC '&RECFM'\n&#LRECL  SETC '&LRECL'\n&#BLKSZ  SETC '&BLKSIZE'\n.*--------------------------------------------------------------------*\n         AIF  (T'&DATA NE 'O').DATAMAP   GO PROCESS DATA TYPE\n         AIF  ('&MF' EQ 'L').MFELIST     GO PROCESS LIST FORM\n.*--------------------------------------------------------------------*\n.MFEEXEC ANOP\n.*--------------------------------------------------------------------*\n&#PERMA  SETC '&PERMA'\n         AIF ('&#ACTION'(1,1) NE 'A').BPREAL1  NOT REALLOC BYPASS'\n         AIF ('&REUSE'(1,1) NE 'Y').BPREAL1    REUSE NOT REQUIRED\n         AIF ('&#REUSEF' EQ 'Y').BPREAL1       REUSE RESET BYPASS\n&#ACTION SETC 'FREE'\n         AGO .ISFREE1                          GO FREE IT\n.*--------------------------------------------------------------------*\n.BPREAL1 ANOP\n         AIF ('&#ACTION'(1,1) EQ 'U').ISFREE1  PROCESS 'UNALLOC'\n         AIF ('&#ACTION'(1,1) NE 'F').TSTINF1 BYPASS IF NOT 'FREE'\n.ISFREE1 ANOP     ENSURE ALL APPROPRIATE FIELDS ARE BLANK FOR FREE\n         AIF (T'&#DD EQ 'O').LVFREE  BYPASS IF DD NOT SUPPLIED\n&#DSN    SETC ''\n&#DSNR   SETC 'NO'\n&#MEMBER SETC ''\n.LVFREE  ANOP\n.* &#DD     SETC ''\n.* &#DDR    SETC 'NO'\n.* &#DSNR   SETC 'NO'\n.* &#DSN    SETC ''\n.* &#MEMBER SETC ''\n&#DISP1  SETC ''\n&#DISP2  SETC ''\n&#DISP3  SETC ''\n&#SPACET SETC ''\n&#PRIM   SETC ''\n&#SECOND SETC ''\n&#DIRB   SETC ''\n&#RLSE   SETC ''\n&#UNIT   SETC ''\n&#VOLSER SETC ''\n&#VOLR   SETC 'NO'\n&#RECFM  SETC ''\n&#LRECL  SETC ''\n&#BLKSZ  SETC ''\n&#BUFNO  SETC ''\n&#DSORG  SETC ''\n&#CLASS  SETC ''\n&#DEST   SETC ''\n&#FCB    SETC ''\n&#COPIES SETC ''\n&#WRTR   SETC ''\n&#PERMA  SETC 'NO'\n         AGO .NOTDELT\n.*--------------------------------------------------------------------*\n.TSTINF1 ANOP\n         AIF ('&#ACTION'(1,1) NE 'I').TSTCON1 BYPASS IF NOT 'INFO'\n.* &#DD     SETC ''\n.* &#DDR    SETC 'NO'\n.* &#DSNR   SETC 'NO'\n.* &#VOLR   SETC 'NO'\n&#ACTION SETC 'INFO'\n&#DSN    SETC '&DSN'\n&#MEMBER SETC ''\n&#DISP1  SETC ''\n&#DISP2  SETC ''\n&#DISP3  SETC ''\n&#SPACET SETC ''\n&#PRIM   SETC ''\n&#SECOND SETC ''\n&#DIRB   SETC ''\n&#RLSE   SETC ''\n&#UNIT   SETC ''\n&#VOLSER SETC ''\n&#RECFM  SETC ''\n&#LRECL  SETC ''\n&#BLKSZ  SETC ''\n&#BUFNO  SETC ''\n&#DSORG  SETC ''\n&#CLASS  SETC ''\n&#DEST   SETC ''\n&#FCB    SETC ''\n&#COPIES SETC ''\n&#WRTR   SETC ''\n&#PERMA  SETC 'NO'\n         AGO .NOTDELT\n.*--------------------------------------------------------------------*\n.TSTCON1 ANOP\n         AIF ('&#ACTION'(1,1) NE 'C').TSTDEC1 BYPASS IF NOT 'CONCAT'\n&#ACTION SETC 'CONCAT'\n&#DDC    SETC '&DDC'\n&#DSN    SETC ''\n&#MEMBER SETC ''\n&#DISP1  SETC ''\n&#DISP2  SETC ''\n&#DISP3  SETC ''\n&#SPACET SETC ''\n&#PRIM   SETC ''\n&#SECOND SETC ''\n&#DIRB   SETC ''\n&#RLSE   SETC ''\n&#UNIT   SETC ''\n&#VOLSER SETC ''\n&#RECFM  SETC ''\n&#LRECL  SETC ''\n&#BLKSZ  SETC ''\n&#BUFNO  SETC ''\n&#DSORG  SETC ''\n&#CLASS  SETC ''\n&#DEST   SETC ''\n&#FCB    SETC ''\n&#COPIES SETC ''\n&#WRTR   SETC ''\n&#PERMA  SETC 'NO'\n         AGO .NOTDELT\n.*--------------------------------------------------------------------*\n.TSTDEC1 ANOP\n         AIF ('&#ACTION'(1,3) NE 'DEC').TSTDLT1 BYP IF NOT 'DECONCAT'\n&#ACTION SETC 'DECONCAT'\n&#DDC    SETC '&DDC'\n&#DSN    SETC ''\n&#MEMBER SETC ''\n&#DISP1  SETC ''\n&#DISP2  SETC ''\n&#DISP3  SETC ''\n&#SPACET SETC ''\n&#PRIM   SETC ''\n&#SECOND SETC ''\n&#DIRB   SETC ''\n&#RLSE   SETC ''\n&#UNIT   SETC ''\n&#VOLSER SETC ''\n&#RECFM  SETC ''\n&#LRECL  SETC ''\n&#BLKSZ  SETC ''\n&#BUFNO  SETC ''\n&#DSORG  SETC ''\n&#CLASS  SETC ''\n&#DEST   SETC ''\n&#FCB    SETC ''\n&#COPIES SETC ''\n&#WRTR   SETC ''\n&#PERMA  SETC 'NO'\n         AGO .NOTDELT\n.*--------------------------------------------------------------------*\n.TSTDLT1 ANOP\n         AIF ('&#ACTION'(1,3) NE 'DEL').NOTDELT  BYP IF NOT 'DELETE'\n*---------------------------------------------------------------------*\n*  FOR 'DELETE', ALLOCATING DATASET WITH A STATUS OF:                 *\n*     DISP=(OLD,DELETE,DELETE)                                        *\n*---------------------------------------------------------------------*\n&#ACTION SETC 'ALLOC'\n&#DISP1  SETC 'OLD'\n&#DISP2  SETC 'DELETE'\n&#DISP3  SETC 'DELETE'\n&#MEMBER SETC ''\n&#VOLSER SETC ''\n&#DEST   SETC ''\n&#FCB    SETC ''\n&#COPIES SETC ''\n&#SPACET SETC ''\n&#PRIM   SETC ''\n&#SECOND SETC ''\n&#DIRB   SETC ''\n&#BUFNO  SETC ''\n&#UNIT   SETC ''\n&#RECFM  SETC ''\n&#LRECL  SETC ''\n&#BLKSZ  SETC ''\n&#PERMA  SETC ''\n&#PERMA  SETC 'NO'\n.NOTDELT ANOP\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.*    EXEC FORM OF MACRO\n.*--------------------------------------------------------------------*\n         AIF   ('&REGR' EQ 'NO').NORSAV1 BYPASS IF REGS NOT 2 BE REST'D\n         STM   R0,R14,&REGSAVR      SAVE REGISTERS\n.NORSAV1 ANOP\n         AIF   (T'&BASE EQ 'O').NOBASE   BYPASS IF NO 'BASE' PASSED\n         USING S99RBP,&BASE         ESTABLISH ADDRESABILITY\n.NOBASE  ANOP\n         LA    &#4,S99RBPTR+4       POINT PAST RBPTR\n         USING S99RB,&#4            EST ADDRESABILITY FOR \"RB\" DSECT\n         ST    &#4,S99RBPTR         MAKE \"RBPTR\" TO \"RB\"\n         OI    S99RBPTR,S99RBPND    TURN ON HIGH ORDER BIT OF \"RBPTR\"\n         XC    S99RB(S99RBEND-S99RB),S99RB INITIALISE \"RB\" ENTIRELY\n         MVI   S99RBLN,S99RBEND-S99RB      PUT LEN OF \"RB\" IN ITS FLD\n         LA    &#5,S99RB+(S99RBEND-S99RB)  POINT 20 BYTES PAST 'RB'\n         USING S99TUPL,&#5          EST ADDRESABILITY TO TEXT UNIT PTRS\n         ST    &#5,S99TXTPP         INIT TEXT POINTER IN 'RB'\n.*--------------------------------------------------------------------*\n.*    TEST ACTION AND SET VERB ACCORDINGLY                            *\n.*--------------------------------------------------------------------*\n&DELLAB  SETC  'AY'.'&SYSNDX'.'E'   SET LABEL FOR DELETE ERROR BYPASS\n&TUS     SETA  0                    SET UNALLOCATE # TEXT UNITS\n         AIF ('&#ACTION'(1,1) NE 'A').A1DD\n         MVI   S99VERB,S99VRBAL     SET VERB FOR INFO ALLOCATION\n         AIF ('&#DDR'(1,1) EQ 'Y').A1DDR\n         LA    &#7,DALDDNAM         SET KEY FOR DDNAME SPECIFICATION\n         AGO   .A1DD\n.A1DDR   ANOP\n         LA    &#7,DALRTDDN         SET KEY FOR DDNAME RETURN\n         AIF ('&#ACTION'(1,1) EQ 'A').A1DDR1 BYPASS IF ACTION ADD\n         MNOTE 12,'DD NAME RETURN ONLY APPLICABLE TO ALLOCATIONS.'\n         AGO .MEXIT\n.A1DDR1  ANOP\n         AIF (T'&#DD NE 'O').A1DD   BYPASS IF DD SPECIFIED\n         AIF ('&PARMT'(1,1) EQ 'D').A1DD\n         MNOTE 12,'DD NAME RETURN MUST SPECIFY VARIABLE FOR PARMT=PARM'\n         AGO .MEXIT\n.A1DD    ANOP\n         AIF ('&#DDR'(1,1) EQ 'Y').A1DDFC DD RETURN REQUESTED\n         AIF (T'&#DD EQ 'O').A1DSNR1\n.A1DDFC  ANOP\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR DDNAME                                             *\n.A1DSNR1 ANOP\n         AIF ('&#ACTION'(1,1) EQ 'C').CONC11\n         AIF ('&#ACTION'(1,1) EQ 'F').A1DSN\n         AIF ('&#ACTION'(1,1) EQ 'D').A1DSN\n         AIF ('&#ACTION'(1,1) EQ 'U').A1DSN\n         AIF (T'&#DSN NE 'O').A1DSN  BYPASS IF DSNAME SPECIFIED\n         AIF (T'&SYSOUT NE 'O').A1DSN  BYPASS IF SYSOUT SPECIFIED\n         AIF ('&PARMT'(1,1) EQ 'D').A1DSN\n         MNOTE 12,'DSNAME RETURN MUST SPECIFY VARIABLE FOR PARMT=PARM'\n         AGO .MEXIT\n.A1DSN   ANOP\n         AIF ('&#DSNR'(1,1) EQ 'Y').A1DSNFC DSN RETURN REQUESTED\n         AIF (T'&#DSN EQ 'O').A1DISP1\n.A1DSNFC ANOP\n&TUS     SETA  &TUS+1\n*  1 TEXT UNIT FOR DSNAME                                             *\n         AIF ('&#ACTION'(1,1) EQ 'I').INFO11\n.A1DISP1 ANOP\n         AIF (T'&#DISP1 NE 'O').A1DIS11       PROCESS IF NOT OMITTED\n         AIF ('&#ACTION'(1,1) NE 'A').A1MEMBR BYPASS IF NOT ALLOCATE\n         AIF (T'&#CLASS NE 'O').A1MEMBR       BYPASS IF SYSOUT CLASS\n&#DISP1  SETC 'OLD'                           SET STATUS AS OLD\n*        DEFAULT STATUS OF 'OLD' ASSIGNED                             *\n.A1DIS11 ANOP\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR STATUS                                             *\n.A1MEMBR ANOP\n         AIF (T'&#MEMBER EQ 'O').A1VOLS\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR MEMBER                                             *\n.A1VOLS  ANOP\n         AIF ('&#VOLR'(1,1) EQ 'Y').A1VOLSR\n         AIF (T'&#VOLSER EQ 'O').A1DEST\n.A1VOLSR ANOP\n         AIF ('&PARMT'(1,1) EQ 'D').A1VOLS1\n         AIF (T'&#VOLSER NE 'O').A1VOLS1\n         MNOTE 12,'VOLSER RETURN MUST SPECIFY VARIABLE FOR PARMT=PARM'\n         AGO .MEXIT\n.A1VOLS1 ANOP\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR VOLSER                                             *\n.A1DEST  ANOP\n         AIF (T'&#DEST EQ 'O').A1FCB\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR SYSOUT DESTINATION                                 *\n.A1FCB   ANOP\n         AIF (T'&#FCB EQ 'O').A1COPYS\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR FCB                                                *\n.A1COPYS ANOP\n         AIF (T'&#COPIES EQ 'O').A1T1\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR COPIES                                             *\n.A1T1    ANOP\n         AIF (T'&#DISP2 EQ 'O').A1DISP3\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR NORMAL DISPOSITION                                 *\n.A1DISP3 ANOP\n         AIF (T'&#DISP3 EQ 'O').A1BLK\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR CONDITIONAL/ABNORMAL TERMINATION                   *\n.A1BLK   ANOP\n         AIF (T'&#BLKSZ EQ 'O').A1LREC\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR BLKSIZE                                            *\n.A1LREC  ANOP\n         AIF (T'&#LRECL EQ 'O').A1RECFM\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR LRECL                                              *\n.A1RECFM ANOP\n         AIF (T'&#RECFM EQ 'O').A1DSORG\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR RECFM                                              *\n.A1DSORG ANOP\n         AIF (T'&#DSORG EQ 'O').A1SPACE\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR DSORG                                              *\n.A1SPACE ANOP\n         AIF (T'&#SPACET EQ 'O').A1PRIM\n&TUS     SETA  &TUS+2               SET UNALLOCATE # TEXT UNITS\n*  2 TEXT UNIT FOR ALLOCATION UNITS (CYL, TRK or block size)          *\n.A1PRIM  ANOP\n         AIF (T'&#PRIM EQ 'O').A1SECON\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR PRIMARY ALLOCATION                                 *\n.A1SECON ANOP\n         AIF (T'&#SECOND EQ 'O').A1DIRB\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR SECONDARY ALLOCATION                               *\n.A1DIRB  ANOP\n         AIF ('&#PERMA'(1,1) NE 'Y').A1PERMA\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR PERMANENT ALLOCATE ATTRIBUTE                       *\n.A1PERMA ANOP\n         AIF (T'&#DIRB EQ 'O').A1BUFNO\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR DIRECTORY BLOCKS                                   *\n.A1BUFNO ANOP\n         AIF (T'&#BUFNO EQ 'O').A1UNIT\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR BUFFER COUNT/DCB                                   *\n.A1UNIT  ANOP\n         AIF (T'&#UNIT NE 'O').A1UNI11   PROCESS IF NOT OMITTED\n         AIF ('&#DISP1' NE 'NEW').A1WRTR BYPASS IF OMMITED AND NOT NEW\n&#UNIT   SETC 'SYSALLDA'                 SET UNIT AS 'SYSALLDA'\n*        DEFAULT DEVICE UNIT OF 'SYSALLDA' ASSIGNED                   *\n.A1UNI11 ANOP\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR DEVICE UNIT                                        *\n.A1WRTR  ANOP\n         AIF (T'&#WRTR EQ 'O').A1CLASS\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR SYSOUT WRITER-NAME/INTERNAL-READER                 *\n.A1CLASS ANOP\n         AIF (T'&#CLASS EQ 'O').A1RLSE\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR SYSOUT CLASS                                       *\n.A1RLSE  ANOP\n         AIF (T'&#RLSE EQ 'O').A1UCLOS\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR RLSE\n.A1UCLOS ANOP\n         AIF ('&#ACTION'(1,1) NE 'A').A$OPTE  BYPASS IF NOT 'ALLOACTE'\n         AIF ('&UCLOSE' NE 'YES').A$OPTE\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR UCLOSE                                             *\n.A$OPTE  ANOP\n         AIF ('&#ACTION'(1,1) EQ 'A').CON#000\n.UNAL1   ANOP\n         AIF ('&#ACTION'(1,1) EQ 'U').UNAL11\n         AIF ('&#ACTION'(1,1) NE 'F').INFO1\n.UNAL11  ANOP\n         MVI   S99VERB,S99VRBUN     SET VERB FOR UNALLOCATION\n         LA    &#7,DUNDDNAM         GET THE KEY FOR DDNAME\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR REMOVE 'IN-USE' ATTRIBUTE (UNALLOCATE)             *\n.*  1 TEXT UNIT FOR UNALLOCATE ATTRIBUTE\n         AGO .CON#000\n.INFO1   ANOP\n         AIF ('&#ACTION'(1,1) NE 'I').CONC1\n.INFO11  ANOP\n         MVI   S99VERB,S99VRBIN     SET VERB FOR INFO RETRIEVAL\n         LA    &#7,DINDDNAM         GET THE KEY FOR DDNAME\n         AIF ('&PARMT'(1,1) EQ 'P').CON#000\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR DSNAME RETURN                                      *\n         AGO .CON#000\n.CONC1   ANOP\n         AIF ('&#ACTION'(1,1) NE 'C').DEAL1\n         AIF (T'&#DDC NE 'O').CONC11\n         MNOTE 12,'CONCATENATION MUST HAVE A \"DDC\" PARAMETER.'\n         AGO .MEXIT\n.CONC11  ANOP\n         MVI   S99VERB,S99VRBCC     SET VERB FOR INFO CONCATENATE\n         LA    &#7,DCCDDNAM         GET THE KEY FOR DDNAME\n         AIF ('&CCP'(1,1) EQ 'N').CON#000\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR PERMANENT CONCATENATION\n         AGO .CON#000\n.DEAL1   ANOP\n         AIF ('&#ACTION'(1,3) NE 'DEC').CON#000\n         AIF (T'&#DDC NE 'O').DEAL11\n         MNOTE 12,'DECONCATENATION MUST HAVE A \"DDC\" PARAMETER.'\n         AGO .MEXIT\n.DEAL11  ANOP\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n         MVI   S99VERB,S99VRBDC     SET VERB FOR INFO DECONCATENATE\n         LA    &#7,DDCDDNAM         GET THE KEY FOR DDNAME\n.CON#000 ANOP\n         LA    &#6,S99TUPL+(&TUS*4) POINT JUST PAST THE TEXT UNIT PTRS\n         USING S99TUNIT,&#6         ADDRESABILITY FOR 1ST TEXT UNIT\n&TUS     SETA  0                    SET TEXT UNITS PTR INCREMENT\n.*-------------------------------------------------------------------*\n.A2DDC   ANOP\n         AIF ('&#ACTION'(1,1) NE 'C').A2DEC\n*--------------------------------------------------------------------*\n*   ADYN-SET UP DDNAME TO CONCATENATE                                *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT\n         ST    &#6,S99TUPTR         POINT 1ST TXT UNIT PTR TO 1ST TXT U\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,2                BECAUSE THE DSNAME KEY REQUIRES 2\n         STH   &#7,S99TUNUM           PARM, STORE 2 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2DDC#\n         LA    &#7,8                MAXIMUM LENGTH OF DATASET\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         STH   &#7,S99TULNG+10      STORE TEXT UNIT LENGTH TO CONCAT\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99DDN          MOVE DDNAME\n         EX    &#7,MV99DDCN         MOVE DDNAME TO CONCATENATE\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         AIF ('&CCP'(1,1) EQ 'N').A$END\n         LA    &#6,4(&#6)           POINT PAST KEY, # (NOT LENGTH)\n         LA    &#7,3(&#7)           BACK TO NORMAL LENGTH + LENGTH FLD\n         AR    &#6,&#7              POINT PAST DDNAME\n         AR    &#6,&#7              POINT PAST DDNAME CONCATENATION\n         AGO   .A2DDC#0             EXIT PROCESS\n.A2DDC#  ANOP\n&PL      SETA  K'&#DD\n&PLC     SETA  K'&#DDC\n         LA    &#7,&PL              LENGTH OF DDNAME\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#7,&PLC             LENGTH OF CONCAT DDNAME\n         STH   &#7,S99TULNG+&PL+2   STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&#DD' MOVE DDNAME\n         MVC   S99TUPAR+&PL+2(&PLC),=C'&#DDC' MOVE DDNAME TO CONCAT\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         AIF ('&CCP'(1,1) EQ 'N').A$END\n         LA    &#6,4(&#6)           POINT PAST KEY, # (NOT LENGTH)\n         LA    &#7,&PL+2            LENGTH OF DDNAME + LENGTH FIELD\n         LA    &#7,&PLC+2(&#7)      LENGTH OF DDNAME + LENGTH FIELD\n         AR    &#6,&#7              POINT PAST DSNAME\n.A2DDC#0 ANOP\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DCCPERMC         GET THE KEY FOR PERMANENT CONCAT\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,0                BECAUSE THE PERMCON KEY REQUIRES 0\n         STH   &#7,S99TUNUM           PARM, STORE 0 IN NUMBER FIELD\n         AGO   .A$END\n.*-------------------------------------------------------------------*\n.A2DEC   ANOP\n         AIF ('&#ACTION'(1,3) NE 'DEC').A2DD\n*--------------------------------------------------------------------*\n*   ADYN-SET UP DDNAME TO DECONCATENATE                              *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT\n         ST    &#6,S99TUPTR         POINT 1ST TXT UNIT PTR TO 1ST TXT U\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2DEC#\n         LA    &#7,8                MAXIMUM LENGTH OF DATASET\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99DDCN         MOVE DDNAME TO DECONCATENATE\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         AGO   .A2DEC#0             EXIT PROCESS\n.A2DEC#  ANOP\n&PLC     SETA  K'&#DDC\n         LA    &#7,&PLC             LENGTH OF CONCAT DDNAME\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PLC),=C'&#DDC' MOVE DDNAME TO DECONCATENATE\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n.A2DEC#0 ANOP\n         AGO   .A$END\n.*-------------------------------------------------------------------*\n.A2DD    ANOP\n&@DDR    SETC  ''\n         AIF ('&#DDR'(1,1) EQ 'Y').A2DDRIY\n         AIF (T'&#DD  EQ 'O').A2DSN\n         AGO   .A2DDACT\n.A2DDRIY ANOP\n         AIF ('&PARMT'(1,1) EQ 'P').A2DDRIP\n&@DDR    SETC  'YDD'\n         AGO   .A2DDACT\n.A2DDRIP ANOP\n&@DDR    SETC  '&#DD'\n.A2DDACT ANOP\n*--------------------------------------------------------------------*\n*   ADYN-SET UP DDNAME                                               *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT\n         ST    &#6,S99TUPTR         POINT 1ST TXT UNIT PTR TO 1ST TXT U\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         LA    &#7,8                MAXIMUM LENGTH OF DATASET\n         AIF ('&#DDR'(1,1) EQ 'Y').A2DDR0 IF DD RETURN REQ'D BYPASS\n         AIF ('&PARMT'(1,1) EQ 'P').A2DD#\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99DDN          MOVE DDNAME\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AGO   .A2DDR1\n.A2DDR0  ANOP\n         LA    &#1,S99TUPAR         LOAD DDNAME VARIABLE ADDRESS\n&VARNM   SETC  '&#DD'               SET VARIABLE NAME\n         AIF ('&#DD'(1,1) NE '(').NDDVAR1\n&PL      SETA  K'&#DD\n&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME\n.NDDVAR1 ANOP\n         ST    &#1,&VARNM           SAVE FOR LATER USE\n.A2DDR1  ANOP\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST DSNAME\n         AGO   .A2DD#0              EXIT PROCESS\n.A2DD#   ANOP\n&PL      SETA  K'&#DD\n         AIF ('&#DD'(1,1) NE '(').NDDVAR2\n&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME\n         MVC   S99TUPAR(L'&VARNM),&VARNM  MOVE VARIABLE NAME\n         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME\n         AGO   .A2DD#0  ANOP\n.NDDVAR2 ANOP\n         LA    &#7,&PL              MAXIMUM LENGTH OF DATASET\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&#DD'\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST DDNAME\n.A2DD#0  ANOP\n*--------------------------------------------------------------------*\n*   ADYN-SET UP DSNAME                                               *\n*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.A2DSN   ANOP\n         AIF ('&#ACTION'(1,1) EQ 'I').INFO2\n         AIF ('&#DSN' EQ 'DUMMY').A2DUMMY\n         AIF ('&#DSN' EQ '*').A2TERML\n&@DSNR   SETC  ''\n&#DSNV   SETC  'DALDSNAM'\n         AIF ('&#DSNR'(1,1) EQ 'Y').A2DSRIY\n         AIF (T'&#DSN EQ 'O').A2MEMBR\n         AGO  .A2DSACT\n.A2DSRIY ANOP\n&#DSNV   SETC  'DALRTDSN'\n&#DISP2  SETC  'DELETE'\n&#DISP3  SETC  'DELETE'\n         AIF ('&PARMT'(1,1) EQ 'P').A2DSRIP\n&@DSNR   SETC  'YDSN'\n         AGO   .A2DSACT\n.A2DSRIP ANOP\n&@DSNR   SETC  '&#DSN'\n.A2DSACT ANOP\n.*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,&#DSNV           GET THE KEY FOR DSNAME\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         LA    &#7,44               MAXIMUM LENGTH OF DATASET NAME\n         AIF ('&#DSNR'(1,1) EQ 'Y').A2DSNR0 IF DSN RETURN REQ'D BYPASS\n         AIF ('&PARMT'(1,1) EQ 'P').A2DSN#\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99DSN          MOVE DSNAME\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AGO   .A2DSNR1\n.A2DSNR0 ANOP\n         LA    &#1,S99TUPAR         LOAD DSNAME VARIABLE ADDRESS\n&VARNM   SETC  '&#DSN'              SET VARIABLE NAME\n         AIF (T'&#DSN EQ 'O').NDSNVA1\n         AIF ('&#DSN'(1,1) NE '(').NDSNVA1\n&PL      SETA  K'&#DSN\n&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME\n.NDSNVA1 ANOP\n.*       ST    &#1,&VARNM           SAVE FOR LATER USE\n         ST    &#1,&@DSNR           SAVE FOR LATER USE\n.A2DSNR1 ANOP\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST DSNAME\n         AGO   .A2DSN#0             EXIT PROCESS\n.A2DSN#  ANOP\n&PL      SETA  K'&#DSN\n         AIF ('&#DSN'(1,1) NE '(').NDSNVA2\n&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME\n         MVC   S99TUPAR(L'&VARNM),&VARNM     MOVE VARIABLE NAME\n         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME\n         AGO   .A2DSN#0             EXIT PROCESS\n.NDSNVA2 ANOP\n         MVC   S99TUPAR(&PL),=C'&#DSN'\n         LA    &#7,&PL              LENGTH OF DATASET\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST DSNAME\n.A2DSN#0 ANOP\n         AGO   .A2MEMBR\n.*--------------------------------------------------------------------*\n.A2DUMMY ANOP\n*--------------------------------------------------------------------*\n*   ADYN-SET UP DUMMY DSNAME                                         *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALDUMMY         GET THE KEY FOR DUMMY DSNAME\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n         AGO   .A2MEMBR\n.A2TERML ANOP\n*--------------------------------------------------------------------*\n*   ADYN-OUTPUT TO A TERMINAL FOR ON-LINE SESSIONS                   *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALTERM          GET KEY FOR TERMINAL OUTPUT\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n         AGO   .A2MEMBR\n.A2MEMBR ANOP\n         AIF (T'&#MEMBER EQ 'O').A2VOLS\n*--------------------------------------------------------------------*\n*   ADYN-SET UP MEMBER                                               *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALMEMBR         GET THE KEY FOR DSNAME\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2MEM#\n         LA    &#7,8                MAXIMUM LENGTH OF MEMBER NAME\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99MEMB         MOVE MEMBER\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AR    &#6,&#7              POINT PAST DSNAME\n         AGO   .A2VOLS\n.A2MEM#  ANOP\n&PL      SETA  K'&MEMBER\n         AIF ('&MEMBER'(1,1) NE '(').NMEMVAR\n&VARNM   SETC  '&MEMBER'(2,&PL-2)   SET VARIABLE NAME\n         MVC   S99TUPAR(L'&VARNM),&VARNM     MOVE VARIABLE NAME\n         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME\n         AGO   .A2VOLS              EXIT PROCESS\n.NMEMVAR ANOP\n&PL      SETA  K'&MEMBER\n         LA    &#7,&PL              MAXIMUM LENGTH OF MEMBER NAME\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&MEMBER'\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST DSNAME\n.A2VOLS  ANOP\n         AIF ('&#VOLR'(1,1) EQ 'Y').A2VOLSF\n         AIF (T'&#VOLSER EQ 'O').A2DEST\n*--------------------------------------------------------------------*\n*   ADYN-SET UP VOLSER                                               *\n*--------------------------------------------------------------------*\n.A2VOLSF ANOP\n&@VOLR   SETC  ''\n&#VOLV   SETC  'DALVLSER'\n         AIF ('&#VOLR'(1,1) NE 'Y').A2VOACT\n&#VOLV   SETC  'DALRTVOL'\n.A2VORIY ANOP\n         AIF ('&PARMT'(1,1) EQ 'P').A2VORIP\n&@VOLR   SETC  'YVOLSER'\n         AGO   .A2VOACT\n.A2VORIP ANOP\n&@VOLR   SETC  '&#VOL'\n.A2VOACT ANOP\n.*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,&#VOLV           GET THE KEY FOR VOLSER\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         LA    &#7,6                MAXIMUM LENGTH OF DATASET NAME\n         AIF ('&#DSNR'(1,1) EQ 'Y').A2VOLR0 IF VOL RETURN REQ'D BYPASS\n         AIF ('&PARMT'(1,1) EQ 'P').A2VOL#\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99VOLS         MOVE VOLSER\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AGO   .A2VOLR1\n.A2VOLR0 ANOP\n         LA    &#1,S99TUPAR         LOAD VOLSER VARIABLE ADDRESS\n&VARNM   SETC  '&#VOLSER'           SET VARIABLE NAME\n         AIF (T'&#VOLSER EQ 'O').NVOLVA1\n         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA1\n&PL      SETA  K'&#VOLSER\n&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME\n.NVOLVA1 ANOP\n         ST    &#1,&@VOLR           SAVE FOR LATER USE\n.A2VOLR1 ANOP\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST DSNAME\n         AGO   .A2VOL#0             EXIT PROCESS\n.A2VOL#  ANOP\n&PL      SETA  K'&#VOLSER\n         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA2\n&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME\n         MVC   S99TUPAR(L'&VARNM),&VARNM     MOVE VARIABLE NAME\n         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME\n         AGO   .A2VOL#0             EXIT PROCESS\n.NVOLVA2 ANOP\n         LA    &#7,&PL              MAXIMUM LENGTH OF VOLSER\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&#VOLSER'\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST DSNAME\n.A2VOL#0 ANOP\n.*--------------------------------------------------------------------*\n.A2DEST  ANOP\n         AIF (T'&#DEST EQ 'O').A2FCB\n*--------------------------------------------------------------------*\n*   ADYN-SET UP PRINTER DESTINATION                                  *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALSUSER         GET THE KEY FOR DESTINATION\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2DEST#\n         LA    &#7,8                LENGTH OF DESTINATION\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99DEST         MOVE DESTINATION\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AR    &#6,&#7              POINT PAST DSNAME\n         AGO   .A2FCB\n.A2DEST# ANOP\n&PL      SETA  K'&DEST\n         LA    &#7,&PL              LENGTH OF VOLOSER\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&DEST' MOVE PRINTER-ID\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST DSNAME\n.A2FCB   ANOP\n         AIF (T'&#FCB EQ 'O').A2COPY\n*--------------------------------------------------------------------*\n*   ADYN-SET UP FCB                                                  *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALFCBIM         GET THE KEY FOR FCB\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2FCB#\n         LA    &#7,4                LENGTH OF FCB\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99FCB          MOVE FCB\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AR    &#6,&#7              POINT PAST DSNAME\n         AGO   .A2DISP\n.A2FCB#  ANOP\n&PL      SETA  K'&FCB\n         LA    &#7,&PL              LENGTH OF VOLOSER\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&FCB' MOVE FCB\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST DSNAME\n.A2COPY  ANOP\n         AIF (T'&#COPIES EQ 'O').A2DISP\n*--------------------------------------------------------------------*\n*   ADYN-SET UP COPIES                                               *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALCOPYS         GET KEY FOR # OF COPIES\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE COPYS KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2CPY#\n         MVC   S99TUPAR(1),YCOPIES  SET # OF COPIES\n         AGO .A2CPY#0\n.A2CPY#  ANOP\n         MVC   S99TUPAR(1),=AL1(&COPIES) SET # OF COPIES\n.A2CPY#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2DISP  ANOP\n         AIF (T'&#DISP1 EQ 'O').A2DISP2\n*--------------------------------------------------------------------*\n*   ADYN-DATASET STATUS DESIRED                                      *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALSTATS         GET KEY FOR STATUS SPECIFICATIONS\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2DIS#\n         MVC   S99TUPAR(1),YDISP       SET DISPOSITION\n         AGO  .A2DIS#0\n.A2DIS#  ANOP\n         MVI   S99TUPAR,$&#DISP1    SET DISPOSITION\n.A2DIS#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2DISP2 ANOP\n         AIF (T'&#DISP2 EQ 'O').A2DISP3\n*--------------------------------------------------------------------*\n*   ADYN-DATASET DISPOSITION ON NORMAL COMPLETION                    *\n         AIF ('&#CHDISP' EQ 'NO').A2DCM12\n         AIF ('&#CHDISP' EQ 'YES').A2DCM11\n         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN CATALOGUED.'\n         AGO   .A2DCM12  ANOP\n.A2DCM11  ANOP\n         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN FORCED TO ''DELETE'''\n.A2DCM12  ANOP\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALNDISP         GET KEY FOR NORMAL DISPOSITION\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2NDS#\n         MVC   S99TUPAR(1),YNDISP   SET DISPOSITION\n         AGO .A2NDS#0\n.A2NDS#  ANOP\n         MVI   S99TUPAR,$&#DISP2    SET DISPOSITION\n.A2NDS#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2DISP3 ANOP\n         AIF (T'&#DISP3 EQ 'O').A2RECFM\n*--------------------------------------------------------------------*\n*   ADYN-DATASET DISPOSITION ON ABNORMAL COMPLETION                  *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALCDISP         GET KEY FOR CONDITIONAL DISPOSITION\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2CDS#\n         MVC   S99TUPAR(1),YCDISP   SET DISPOSITION\n         AGO .A2CDS#0\n.A2CDS#  ANOP\n         MVI   S99TUPAR,$&#DISP3    SET DISPOSITION\n.A2CDS#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2RECFM ANOP\n         AIF (T'&#RECFM EQ 'O').A2DSORG\n*--------------------------------------------------------------------*\n*   ADYN-RECORD FORMAT                                               *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALRECFM         GET KEY FOR RECORD FORMAT\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2RFM#\n         MVC   S99TUPAR(1),YRECFM   SET RECORD FORMAT\n         AGO .A2RFM#0\n.A2RFM#  ANOP\n         AIF ('&#RECFM' EQ 'FBA').CON#130\n         AIF ('&#RECFM' EQ 'VBA').CON#130\n         AIF ('&#RECFM' EQ 'VB').CON#130\n         AIF ('&#RECFM' EQ 'FB').CON#130\n         AIF ('&#RECFM' EQ 'U').CON#130\n         AIF ('&#RECFM' EQ 'F').CON#130\n         AIF ('&#RECFM' EQ 'V').CON#130\n         MNOTE 12,'RECFM OF \"&#RECFM\" NOT ALLOWED FOR.'\n         AGO .MEXIT\n.CON#130 ANOP\n         MVI   S99TUPAR,$&RECFM     SET RECFM\n.A2RFM#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2DSORG ANOP\n         AIF (T'&#DSORG EQ 'O').A2LRECL\n*--------------------------------------------------------------------*\n*   ADYN-DATASET ORGANISATION                                        *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALDSORG         GET KEY FOR DSORG\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#7,2                PARAMETER LENGTH OF 2\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2DSO#\n         MVC   S99TUPAR(2),YDSORG   SET DATASET ORGANISATION\n         AGO .A2DSO#0\n.A2DSO#  ANOP\n         AIF ('&#DSORG' EQ 'PO').CON#135\n         AIF ('&#DSORG' EQ 'PS').CON#135\n         AIF ('&#DSORG' EQ 'DA').CON#135\n         AIF ('&#DSORG' EQ 'POU').CON#135\n         AIF ('&#DSORG' EQ 'PSU').CON#135\n         AIF ('&#DSORG' EQ 'DAU').CON#135\n         MNOTE 12,'DSORG OF \"&#DSORG\" NOT ALLOWED FOR.'\n         AGO .MEXIT\n.CON#135 ANOP\n         XC    S99TUPAR+1(1),S99TUPAR+1 INIT LOW ORDER BYTE OF ORG\n         MVI   S99TUPAR,$&#DSORG    SET DATASET ORG\n.A2DSO#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2CONVA ANOP\n.A2LRECL ANOP\n         AIF (T'&#LRECL EQ 'O').A2BLKSZ\n*--------------------------------------------------------------------*\n*   ADYN-LOGICAL RECORD LENGTH                                       *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALLRECL         GET KEY FOR LOGICAL RECORD LENGTH\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#7,2                BECAUSE THE LRECL PARM REQUIRES 1\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2LRL#\n         MVC   S99TUPAR(2),YLRECL   SET RECORD LENGTH\n         AGO .A2LRL#0\n.A2LRL#  ANOP\n         MVC   S99TUPAR(2),=H'&LRECL' SET RECORD LENGTH\n.A2LRL#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2BLKSZ ANOP\n         AIF (T'&#BLKSZ EQ 'O').A2UNIT\n*--------------------------------------------------------------------*\n*   ADYN-BLOCK SIZE                                                  *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALBLKSZ         GET KEY FOR BLOCK SIZE\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#7,2                BECAUSE THE LRECL PARM REQUIRES 1\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n         AIF ('&PARMT'(1,1) EQ 'P').A2BLK#\n         MVC   S99TUPAR(2),YBLKSIZE SET BLOCK SIZE\n         AGO .A2BLK#0\n.A2BLK#  ANOP\n         MVC   S99TUPAR(2),=H'&BLKSIZE' SET BLOCK SIZE\n.A2BLK#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.*--------------------------------------------------------------------*\n.A2UNIT  ANOP\n         AIF (T'&#UNIT EQ 'O').A2AUNIT\n*--------------------------------------------------------------------*\n*   ADYN-DEVICE UNIT                                                 *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALUNIT          GET KEY FOR UNIT\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2UNI#\n         LA    &#7,8                LENGTH OF VOLOSER\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99UNIT         MOVE VOLUME\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AR    &#6,&#7              POINT PAST DSNAME\n         AGO   .A2AUNIT\n.A2UNI#  ANOP\n&PL      SETA  K'&#UNIT\n         LA    &#7,&PL              LENGTH OF VOLOSER\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&#UNIT' MOVE UNIT\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST DSNAME\n.A2AUNIT ANOP\n         AIF (T'&#SPACET EQ 'O').A2PRIM\n*--------------------------------------------------------------------*\n*   ADYN-SPACE ALLOCATION INIT (CYL, TRK or block_size)              *\n*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS      POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR          POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         AIF ('&PARMT'(1,1) EQ 'P').A2ATY#\n         MVI   S99TUKEY,X'00'        CLEAR HIGH ORDER BYTE\n         MVC   S99TUKEY+1(1),YSPACET MOVE ALLOCATION TYPE TO KEY\n         AGO   .A2ATY#0\n.A2ATY#  ANOP\n         AIF ('&#SPACET' EQ 'TRK').A2TRK\n         AIF ('&#SPACET' EQ 'CYL').A2CYL\n         MNOTE 12,'ALLOCATION TYPE OF \"&#SPACET\" NOT ALLOWED FOR.'\n         AGO .MEXIT\n.A2TRK   ANOP\n&#DISP   SETC  'DALTRK'\n         AGO .CON#140\n.A2CYL   ANOP\n&#DISP   SETC  'DALCYL'\n.CON#140 ANOP\n         LA    &#7,&#DISP           GET KEY FOR ALLOCATION UNITS\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n.A2ATY#0 ANOP\n         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n*   ADYN-AR    &#6,&#7              POINT PAST PARAMETER\n.A2PRIM  ANOP\n         AIF (T'&#PRIM EQ 'O').A2SECND\n*--------------------------------------------------------------------*\n*   ADYN-PRIMARY ALLOCATION                                          *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALPRIME         GET KEY FOR RECORD PRIMARY ALLOC\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#7,3                BECAUSE THE LRECL PARM REQUIRES 1\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n         MVI   S99TUPAR,X'00'       CLEAR HIGH ORDER BYTE\n         AIF ('&PARMT'(1,1) EQ 'P').A2PRI#\n         MVC   S99TUPAR+1(2),YPRIM  MOVE PRIMARY ALLOCATION\n         AGO .A2PRI#0\n.A2PRI#  ANOP\n         MVC   S99TUPAR+1(2),=H'&#PRIM' SET PRIMARY ALLOCATION\n.A2PRI#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2SECND ANOP\n         AIF (T'&#SECOND EQ 'O').A2DIRB\n*--------------------------------------------------------------------*\n*   ADYN-SECONDARY ALLOCATION                                        *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALSECND         GET KEY FOR RECORD PRIMARY ALLOC\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#7,3                BECAUSE THE LRECL PARM REQUIRES 1\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n         MVI   S99TUPAR,X'00'       CLEAR HIGH ORDER BYTE\n         AIF ('&PARMT'(1,1) EQ 'P').A2SEC#\n         MVC   S99TUPAR+1(2),YSECOND  MOVE SECONDARY ALLOCATION\n         AGO .A2SEC#0\n.A2SEC#  ANOP\n         MVC   S99TUPAR+1(2),=H'&#SECOND' SET SECONDARY ALLOCATION\n.A2SEC#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2DIRB  ANOP\n         AIF (T'&#DIRB EQ 'O').A2PERMA\n*--------------------------------------------------------------------*\n*   ADYN-DIRECTORY BLOCKS                                            *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALDIR           GET KEY FOR RECORD PRIMARY ALLOC\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#7,3                BECAUSE THE LRECL PARM REQUIRES 1\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n         MVI   S99TUPAR,X'00'       CLEAR HIGH ORDER BYTE\n         AIF ('&PARMT'(1,1) EQ 'P').A2DIR#\n         MVC   S99TUPAR+1(2),YDIRB  MOVE DIRECTORY BLOCKS\n         AGO .A2DIR#0\n.A2DIR#  ANOP\n         MVC   S99TUPAR+1(2),=H'&#DIRB' MOVE DIRECTORY BLOCKS\n.A2DIR#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2PERMA ANOP\n         AIF ('&#PERMA'(1,1) EQ 'N').A2BUFNO\n*--------------------------------------------------------------------*\n*   ADYN-PERMANENT ALLOCATED ATTRIBUTE                               *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALPERMA         GET KEY PERMANENT ATTRIBUTE\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,0                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2BUFNO ANOP\n         AIF (T'&#BUFNO EQ 'O').A2UCLOS\n*--------------------------------------------------------------------*\n*   ADYN-NO OF BUFFERS PER DCB                                       *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALBUFNO         GET KEY FOR NUMBER OF BUFFERS\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#7,1                BECAUSE THE LRECL PARM REQUIRES 1\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n         AIF ('&PARMT'(1,1) EQ 'P').A2BUF#\n         MVC   S99TUPAR(2),YBUFNO   MOVE NUMBER OF BUFFERS\n         AGO .A2BUF#0\n.A2BUF#  ANOP\n         MVC   S99TUPAR(1),=C'&BUFNO' MOVE NUMBER OF BUFFERS\n.A2BUF#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2UCLOS ANOP\n         AIF ('&UCLOSE' NE 'YES').A2RLSE\n         AIF ('&#ACTION'(1,1) NE 'A').A2RLSE\n*--------------------------------------------------------------------*\n*   ADYN-UNALLOCATE DATASET ON CLOSING                               *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALCLOSE         GET KEY FOR UNALLOCATE ON CLOSE\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2RLSE  ANOP\n         AIF ('&#RLSE' NE 'R').A2CLASS\n*--------------------------------------------------------------------*\n*   ADYN-RELEASE ANY UNUSED SPACE AFTRE CLOSING                      *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALRLSE          GET KEY FOR RELEASE\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2CLASS ANOP\n         AIF (T'&#CLASS EQ 'O').A2WRTR\n*--------------------------------------------------------------------*\n*   ADYN-ALLOCATE SYSOUT CLASS                                       *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALSYSOU         GET KEY FOR CLASS\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n         AIF ('&PARMT'(1,1) EQ 'P').A2CLA#\n         MVC   S99TUPAR(1),YCLASS   MOVE SYSOUT CLASS\n         AGO .A2CLA#0\n.A2CLA#  ANOP\n         MVC   S99TUPAR(1),=C'&#CLASS' SET SYSOUT CLASS\n.A2CLA#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2WRTR  ANOP\n         AIF (T'&#WRTR EQ 'O').A3ALOC\n*--------------------------------------------------------------------*\n*   ADYN-ALLOCATE SYSOUT WRITER-NAME/INTERNAL-READER                 *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALSPGNM         GET KEY FOR UNIT\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2PRG#\n         LA    &#7,8                LENGTH OF VOLOSER\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99WRTR         MOVE WRITER-NAME/INTRDR\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AR    &#6,&#7              POINT PAST WRITER-NAME\n         AGO   .A3ALOC\n.A2PRG#  ANOP\n&PL      SETA  K'&#WRTR\n         LA    &#7,&PL              LENGTH OF VOLOSER\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&#WRTR' MOVE WRITER-NAME/INTRDR\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST WRITER-NAME\n.*--------------------------------------------------------------------*\n.A3ALOC  ANOP\n         AIF ('&#ACTION'(1,1) EQ 'U').UNAL2\n         AIF ('&#ACTION'(1,1) EQ 'F').UNAL2\n         AGO   .A$END\n.*--------------------------------------------------------------------*\n.UNAL2   ANOP\n*--------------------------------------------------------------------*\n*   ADYN-UNALLOCATE/FREE DATASET                                     *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DUNUNALC         GET KEY FOR RETURN DSNAME\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,0                BECAUSE THE UNALLOC KEY REQUIRES 0\n         STH   &#7,S99TUNUM           PARM, STORE 0 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   REMOVE IN-USE ATTRIBUTE                                          *\n.*--------------------------------------------------------------------*\n.*        LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n.*        ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n.*        LA    &#7,DUNREMOV         GET KEY FOR REMOVE IN-USE\n.*        STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n.*        LA    &#7,0                BECAUSE THE UNALLOC KEY REQUIRES 0\n.*        STH   &#7,S99TUNUM           PARM, STORE 0 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n         OI    S99TUPTR,S99TUPLN    TURN ON HIGH ORDER BIT FOR LAST PTR\n         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n         AGO   .A$END\n.*--------------------------------------------------------------------*\n.INFO2   ANOP\n&@DSNR   SETC  ''\n         AIF ('&PARMT'(1,1) EQ 'D').SETDSNR\n         AIF (T'&#DSN EQ 'O').A$END\n.SETDSNR ANOP\n*--------------------------------------------------------------------*\n*   ADYN-INFO/ RETURN DSNAME FROM DDNAME                             *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DINRTDSN         GET KEY FOR RETURN DSNAME\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         LA    &#7,44               MAXIMUM LENGTH OF DATASET\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#1,S99TUPAR         LOAD DDNAME VARIABLE ADDRESS\n         AIF ('&PARMT'(1,1) EQ 'P').A2DSNI\n         ST    &#1,YDSN             SAVE FOR LATER USE\n&@DSNR   SETC  'YDSN'\n         AGO   .A$END\n.A2DSNI  ANOP\n         ST    &#1,&DSN             SAVE FOR LATER USE\n&@DSNR   SETC  '&DSN'\n         AGO   .A$END\n.*--------------------------------------------------------------------*\n.CONC2   ANOP\n         AGO .CON#0E0\n.DEAL2   ANOP\n         AGO .CON#0E0\n.*--------------------------------------------------------------------*\n.A$END   ANOP\n         OI    S99TUPTR,S99TUPLN    TURN ON HIGH ORDER BIT FOR LAST PTR\n         AIF ('&PARMT'(1,1) EQ 'P').A$NOEXO\n         AIF (&ADYNFL1).A$NOEXO\n&ADYNFL1 SETB  1\n         B     BYPASEX              BYPASS EX STATEMENTS\n*---------------------------------------------------------------------*\n*  CODE TO BE 'EX'D DURING PARAMETER BUILDING FROM PARAMETERS PASSED  *\n*  AS DATA IN FIELD VARIABLES.                                        *\n*---------------------------------------------------------------------*\nMV99DSN  MVC   S99TUPAR(0),YDSN     MOVE DSNAME\nMV99DDN  MVC   S99TUPAR(0),YDD      MOVE DDNAME\nMV99DDCN MVC   S99TUPAR+10(0),YDDC  MOVE DDNAME TO CONCATENATE\nMV99MEMB MVC   S99TUPAR(0),YMEMBER  MOVE MEMBER\nMV99VOLS MVC   S99TUPAR(0),YVOLSER  MOVE VOLSER\nMV99UNIT MVC   S99TUPAR(0),YUNIT    MOVE DVICE TYPE\nMV99WRTR MVC   S99TUPAR(0),YWRITER  MOVE SYSOUT WRITER-NAME/INTRDR\nMV99DEST MVC   S99TUPAR(0),YDEST    MOVE PRINTER-ID DESTINATION\nMV99FCB  MVC   S99TUPAR(0),YFCB     MOVE FCB\n*---------------------------------------------------------------------*\nBYPASEX  DS    0H\n.A$NOEXO ANOP\n         AIF   ('&REGR' EQ 'NO').NORSAV2 BYPASS IF REGS NOT 2 BE REST'D\n         LM    R0,R14,&REGSAVR      RESTORE USED REGISTERS\n.NORSAV2 ANOP\n         AIF (T'&BASE EQ 'O').UCALLIT\n*---------------------------------------------------------------------*\n*  IMPLICIT INVOCATION OF THE DYNALLOC COMMAND IF 'BASE' SUPPLIED     *\n*---------------------------------------------------------------------*\n         AIF ('&#DDR'(1,1) NE 'Y').A$DDR0 IF DD RETURN REQ'D BYPASS\n&VARNM   SETC  '&#DD'               SET VARIABLE NAME\n         AIF ('&#DD'(1,1) NE '(').NDDVAR3\n&PL      SETA  K'&#DD\n&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME\n.NDDVAR3 ANOP\n         MVC   &REGSAVR.(4),&VARNM  MOVE DDNAME VARIABLE ADDRESS SAVED\n.A$DDR0  ANOP\n         AIF ('&#DSNR'(1,1) NE 'Y').NODSNR\n&VARNM   SETC  '&#DSN'              SET VARIABLE NAME\n         AIF (T'&#DSN NE 'O').NDSNOM3\n&VARNM   SETC  '&@DSNR'             SET VARIABLE NAME\n         AGO   .NDSNVA3\n.NDSNOM3 ANOP\n         AIF ('&#DSN'(1,1) NE '(').NDSNVA3\n&PL      SETA  K'&#DSN\n&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME\n.NDSNVA3 ANOP\n         MVC   &REGSAVR.(4),&VARNM  MOVE DSNAME VARIABLE ADDRESS SAVED\n.NODSNR  ANOP\n         AIF ('&#VOLR'(1,1) NE 'Y').NOVOLR\n&VARNM   SETC  '&#VOLSER'           SET VARIABLE NAME\n         AIF (T'&#VOLSER NE 'O').NVOLOM3\n&VARNM   SETC  '&@VOLR'             SET VARIABLE NAME\n         AGO   .NVOLVA3\n.NVOLOM3 ANOP\n         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA3\n&PL      SETA  K'&#VOLSER\n&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME\n.NVOLVA3 ANOP\n         MVC   &REGSAVR.+4(4),&VARNM  MOVE VOL VARIABLE ADDRESS SAVED\n.NOVOLR  ANOP\n         AIF ('&PDUMP'(1,1) NE 'Y').DYNALOC\n         AIF (T'&PDUMPX EQ 'O').PDUMPWX\n         PDUMP (&BASE),MSG='JUST ABOUT TO INVOKE DYNALLOC \"&#ACTION\". NO\n               O EXIT AVAILABLE.'\n         AGO   .DYNALOC\n.PDUMPWX ANOP\n         PDUMP (&BASE),MSG='JUST ABOUT TO INVOKE DYNALLOC \"&#ACTION\". EX\n               XIT AVAILABLE  THRU \"QUIT\" COMMAND.'\n.DYNALOC ANOP\n         LR    &#1,&BASE            REQ BLK PTR ADR IN &#1 FOR DYNALLOC\n         DYNALLOC\n         AIF (T'&ERROR EQ 'O').TSTDELT\n         LTR   R15,R15              Q. ZERO RETURN CODE FROM ADYN\n         BNZ   &ERROR                  N. GO TO ERROR ROUTINE\n.TSTDELT ANOP\n         AIF ('&#VOLR'(1,1) NE 'Y').A$DSR1\n         L     R14,&REGSAVR+4       LOAD VOLSER VARIABLE ADDRESS SAVED\n         AIF (T'&#VOLSER NE 'O').NVOLOM4\n&VARNM   SETC  '&@VOLR'             SET VARIABLE NAME\n         AGO   .NVOLVA4 ANOP\n.NVOLOM4 ANOP\n         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA4\n&PL      SETA  K'&#VOLSER\n&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME\n.NVOLVA4 ANOP\n         MVC   &VARNM.(6),0(R14)    MOVE VOLSER RETURNED BY DYNALLOC\n.A$DSR1  ANOP\n         AIF ('&#DSNR'(1,1) NE 'Y').A$DDR1\n         L     R14,&REGSAVR         LOAD DSNAME VARIABLE ADDRESS SAVED\n         AIF (T'&#DSN NE 'O').NDSNOM4\n&VARNM   SETC  '&@DSNR'             SET VARIABLE NAME\n         AGO   .NDSNVA4\n.NDSNOM4 ANOP\n         AIF ('&#DSN'(1,1) NE '(').NDSNVA4\n&PL      SETA  K'&#DSN\n&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME\n.NDSNVA4 ANOP\n         MVC   &VARNM.(44),0(R14)   MOVE DSNAME RETURNED BY DYNALLOC\n         OC    &VARNM.(44),=CL44' ' CONVERT TRAILING X'00' TO SPACES\n*                                          /\u00a6\\ <------\n         AGO   .A$DDR2\n.A$DDR1  ANOP\n         AIF ('&#DDR'(1,1) NE 'Y').A$DDR2 IF DD RETURN REQ'D BYPASS\n         L     R14,&REGSAVR         LOAD DDNAME VARIABLE ADDRESS SAVED\n         AIF ('&#DD'(1,1) NE '(').NDDVAR4\n&PL      SETA  K'&#DD\n&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME\n.NDDVAR4 ANOP\n         MVC   &VARNM.(8),0(R14)    MOVE DDNAME RETURNED BY DYNALLOC\n.A$DDR2  ANOP\n         AIF ('&#ACTION'(1,1) NE 'F').BPALOC2 BYPASS IF NOT FREE\n         AIF ('&ACTION'(1,1) NE 'A').BPALOC2  BYPASS IF NOT ALLOCATE\n&#REUSEF SETC 'Y'\n         AGO .A$RT                             GO ALLOCATE IT\n.BPALOC2 ANOP\n         AIF ('&#ACTION' NE 'ALLOC').UCALLIT\n         AIF ('&ACTION'(1,3) NE 'DEL').UCALLIT\n.*--------------------------------------------------------------------*\n.*    CONTROL GETS HERE IF ACTION WAS DELETE AND WE HAVE JUST ALLOC'D *\n.*    WITH DISP=(OLD,DELETE,DELETE)                                   *\n.*--------------------------------------------------------------------*\n         LTR   R15,R15              Q. ZERO RETURN CODE FROM ADYN\n         BNZ   &DELLAB                 N. BYPASS FREEING FOR DELETE\n&#ACTION SETC 'FREE'                INIT PARMS FOR 'FREE'\n&#DISP1  SETC ''\n&#DISP2  SETC ''\n&#DISP3  SETC ''\n*---------------------------------------------------------------------*\n*  FOR 'DELETE', RETURNING TO UNALLOCATE DATASET JUST ALLOCATED WITH: *\n*     DISP=(OLD,DELETE,DELETE)                                        *\n*---------------------------------------------------------------------*\n         AGO .NOTDELT               GO SET UP FREE COMMANDS\n.UCALLIT ANOP\n.*--------------------------------------------------------------------*\n.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *\n.*--------------------------------------------------------------------*\n         AIF   ('&MF' EQ 'E').NOREGSV BYPASS SAVE REGISTERS\n         AIF   (&REGDFLG).NOREGSV EXIT IF ALREADY PROCESSED\n&REGDFLG SETB  1\n         B     &DELLAB       BRANCH AROUND REG SAVE AREA\n&REGSAVR DS    16F           GLOBAL REGISTER SAVE AREA\n.NOREGSV ANOP\n&DELLAB  DS    0H\n*------------ END OF ADYN PARAMETER LIST BUILD -----------------------*\n         AGO .MEXIT\n*---------------------------------------------------------------------*\n.MFELIST ANOP\n.*--------------------------------------------------------------------*\n.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *\n.*--------------------------------------------------------------------*\n         AIF   (&REGDFLG).MEXIT  EXIT IF ALREADY PROCESSED\n&REGDFLG SETB  1\n&REGSAVR DS    16F           GLOBAL REGISTER SAVE AREA\n         AGO .MEXIT\n.*-----------------CONSTANT MAPPING OF ADYN VARIABLES-----------------*\n.DATAMAP ANOP\n         AIF  ('&DATA'(1,3) EQ 'IBM').DATAIBM\n.*-------------------------------------------------------------------*\n.*     INITIALISE VARIABLES IF NOT PASSED                            *\n.*-------------------------------------------------------------------*\n.A2UNITD ANOP\n         AIF (T'&#UNIT NE 'O').A2UNI11   PROCESS IF NOT OMITTED\n         AIF ('&#DISP1' NE 'NEW').A2UNI11 BYPASS IF OMMITED AND NOT NEW\n&#UNIT   SETC 'SYSALLDA'                 SET UNIT AS 'SYSALLDA'\n*        DEFAULT DEVICE UNIT OF 'SYSALLDA' ASSIGNED                   *\n.A2UNI11 ANOP\n.CDDNAME ANOP\n&#DDR    SETC '&DDR'\n         AIF ('&#DDR'(1,1) EQ 'Y').A$DDR3 IF DD RETURN REQ'D BLANK DD\n         AIF (T'&#DD NE 'O').CDDCNAM\n.A$DDR3  ANOP\n&#DD     SETC ' '\n.CDDCNAM ANOP\n         AIF (T'&#DDC NE 'O').CDSNAME\n&#DDC    SETC ' '\n.CDSNAME ANOP\n         AIF (T'&#DSN NE 'O').CMEMBER\n&#DSN    SETC ' '\n.CMEMBER ANOP\n         AIF (T'&#MEMBER NE 'O').CVOLSER\n&#MEMBER SETC ' '\n.CVOLSER ANOP\n         AIF (T'&#VOLSER NE 'O').CDEST\n&#VOLSER SETC ' '\n.CDEST   ANOP\n         AIF (T'&#DEST NE 'O').CFCB\n&#DEST   SETC ' '\n.CFCB    ANOP\n         AIF (T'&#FCB NE 'O').CCOPYS\n&#FCB    SETC ' '\n.CCOPYS  ANOP\n         AIF (T'&#COPIES NE 'O').CDISP\n&#COPIES SETC '0'\n.CDISP   ANOP\n         AIF (T'&#DISP1 NE 'O').CDISPV\n&#DISP1  SETC '00'\n         AGO .CNDISP\n.CDISPV  ANOP\n         AIF ('&#DISP1' EQ 'NEW').C2NEW\n         AIF ('&#DISP1' EQ 'OLD').C2OLD\n         AIF ('&#DISP1' EQ 'MOD').C2MOD\n         AIF ('&#DISP1' EQ 'SHR').C2SHR\n         AGO .CNDISP\n.C2SHR   ANOP\n&#DISP1  SETC  '08'\n         AGO .CNDISP\n.C2NEW   ANOP\n&#DISP1  SETC  '04'\n         AGO .CNDISP\n.C2MOD   ANOP\n&#DISP1  SETC  '02'\n         AGO .CNDISP\n.C2OLD   ANOP\n&#DISP1  SETC  '01'\n.CNDISP  ANOP\n         AIF (T'&#DISP2 NE 'O').CNDISPV\n&#DISP2  SETC '00'\n         AGO .CCDISP\n.CNDISPV ANOP\n         AIF ('&#DISP2' EQ 'UNCATLG').C2UNC1\n         AIF ('&#DISP2' EQ 'CATLG').C2CAT1\n         AIF ('&#DISP2' EQ 'DELETE').C2DEL1\n         AIF ('&#DISP2' EQ 'KEEP').C2KEP1\n         AGO .CCDISP\n.C2KEP1  ANOP\n&#DISP2  SETC  '08'\n         AGO .CCDISP\n.C2UNC1  ANOP\n&#DISP2  SETC  '01'\n         AGO .CCDISP\n.C2CAT1  ANOP\n&#DISP2  SETC  '02'\n         AGO .CCDISP\n.C2DEL1  ANOP\n&#DISP2  SETC  '04'\n.CCDISP  ANOP\n         AIF (T'&#DISP3 NE 'O').CCDISPV\n&#DISP3  SETC '00'\n.CCDISPV ANOP\n         AIF ('&#DISP3' EQ 'UNCATLG').C2UNC2\n         AIF ('&#DISP3' EQ 'CATLG').C2CAT2\n         AIF ('&#DISP3' EQ 'DELETE').C2DEL2\n         AIF ('&#DISP3' EQ 'KEEP').C2KEP2\n         AGO .CSPACET\n.C2KEP2  ANOP\n&#DISP3  SETC  '08'\n         AGO .CSPACET\n.C2UNC2  ANOP\n&#DISP3  SETC  '01'\n         AGO .CSPACET\n.C2CAT2  ANOP\n&#DISP3  SETC  '02'\n         AGO .CSPACET\n.C2DEL2  ANOP\n&#DISP3  SETC  '04'\n.CSPACET ANOP\n         AIF (T'&#SPACET NE 'O').CSPACEV\n&#SPACET SETC '00'\n         AGO .CPRIM\n.CSPACEV ANOP\n         AIF ('&#SPACET' NE 'CYL').C2TRK1\n&#SPACET SETC  '08'\n         AGO .CPRIM\n.C2TRK1  ANOP\n&#SPACET SETC  '07'\n.CPRIM   ANOP\n         AIF (T'&#PRIM NE 'O').CSECOND\n&#PRIM   SETC '0'\n.CSECOND ANOP\n         AIF (T'&#SECOND NE 'O').CDIRB\n&#SECOND SETC '0'\n.CDIRB   ANOP\n         AIF (T'&#DIRB NE 'O').CBUFNO\n&#DIRB   SETC '0'\n.CBUFNO  ANOP\n         AIF (T'&#BUFNO NE 'O').CUNIT\n&#BUFNO  SETC '0'\n.CUNIT   ANOP\n         AIF (T'&#UNIT NE 'O').CRECFM\n&#UNIT   SETC ' '\n.CRECFM  ANOP\n         AIF (T'&#RECFM NE 'O').CRECFMV\n&#RECFM  SETC '00'\n         AGO .CDSORG\n.CRECFMV ANOP\n         AIF ('&#RECFM' EQ 'FBA').C2FBA\n         AIF ('&#RECFM' EQ 'VBA').C2VBA\n         AIF ('&#RECFM' EQ 'VB').C2VB\n         AIF ('&#RECFM' EQ 'FB').C2FB\n         AIF ('&#RECFM' EQ 'U').C2U\n         AIF ('&#RECFM' EQ 'F').C2F\n         AIF ('&#RECFM' EQ 'V').C2V\n         AGO .CDSORG\n.C2FBA   ANOP\n&#RECFM  SETC  '94'\n         AGO .CDSORG\n.C2VBA   ANOP\n&#RECFM  SETC  '54'\n         AGO .CDSORG\n.C2FB    ANOP\n&#RECFM  SETC  '90'\n         AGO .CDSORG\n.C2VB    ANOP\n&#RECFM  SETC  '50'\n         AGO .CDSORG\n.C2U     ANOP\n&#RECFM  SETC  'C0'\n         AGO .CDSORG\n.C2F     ANOP\n&#RECFM  SETC  '80'\n         AGO .CDSORG\n.C2V     ANOP\n&#RECFM  SETC  '40'\n.CDSORG  ANOP\n         AIF (T'&#DSORG NE 'O').CDSORGV\n&#DSORG  SETC '0000'\n         AGO .CLRECL\n.CDSORGV ANOP\n         AIF ('&#DSORG' EQ 'PO').C2OPO\n         AIF ('&#DSORG' EQ 'PS').C2OPS\n         AIF ('&#DSORG' EQ 'DA').C2ODA\n         AIF ('&#DSORG' EQ 'POU').C2OPOU\n         AIF ('&#DSORG' EQ 'PSU').C2OPSU\n         AIF ('&#DSORG' EQ 'DAU').C2ODAU\n         AGO .CLRECL\n.C2OPOU  ANOP\n&#DSORG  SETC  '0300'\n         AGO .CLRECL\n.C2OPSU  ANOP\n&#DSORG  SETC  '4100'\n         AGO .CLRECL\n.C2ODAU  ANOP\n&#DSORG  SETC  '2100'\n         AGO .CLRECL\n.C2OPO   ANOP\n&#DSORG  SETC  '0200'\n         AGO .CLRECL\n.C2OPS   ANOP\n&#DSORG  SETC  '4000'\n         AGO .CLRECL\n.C2ODA   ANOP\n&#DSORG  SETC  '2000'\n.CLRECL  ANOP\n         AIF (T'&#LRECL NE 'O').CBLKSZ\n&#LRECL  SETC '0'\n.CBLKSZ  ANOP\n         AIF (T'&#BLKSZ NE 'O').CCLASS\n&#BLKSZ  SETC '0'\n.CCLASS  ANOP\n         AIF (T'&#CLASS NE 'O').CWRTR\n&#CLASS  SETC ' '\n.CWRTR   ANOP\n         AIF (T'&#WRTR NE 'O').CRLSE\n&#WRTR   SETC ' '\n.CRLSE   ANOP\n         AIF (T'&#RLSE NE 'O').D$0END\n&#RLSE   SETC 'N'\n         AGO .D$0END\n.D$0END  ANOP\n.*-------------------------------------------------------------------*\n         AIF  ('&DATA'(1,3) EQ 'VAR').DATAVAR\n         AIF  ('&DATA'(1,3) EQ 'CON').DATACON\n         MNOTE 12,'INVALID 'DATA' PARAMETER OF \"&DATA\".'\n         AGO .MEXIT\n.DATACON ANOP\n*--------------------------------------------------------------------*\n* CONSTANT MAP OF 'ADYN' DATA.                                       *\n*--------------------------------------------------------------------*\n         DC    CL8'&#DD'     DD NAME\n         DC    CL8'&#DDC'    DD NAME TO CONCATENATE\n         DC    CL44'&#DSN'   DSN NAME OR '*' FOR TERMINAL\n         DC    CL8'&#MEMBER' MEMBER NAME OR GDG GENERATION\n         DC    CL6'&#VOLSER' DISK DATASET RESIDES ON\n         DC    XL1'&#DISP1'  1ST. BYTE OF STATUS (NEW,OLD,MOD,SHR)\n.*-------------------------------------------------------------------*\n         AIF ('&#CHDISP' EQ 'NO').A2DCM22\n         AIF ('&#CHDISP' EQ 'YES').A2DCM21\n         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN CATALOGUED.'\n         AGO   .A2DCM22  ANOP\n.A2DCM21  ANOP\n         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN FORCED TO ''DELETE'''\n.A2DCM22  ANOP\n.*-------------------------------------------------------------------*\n         DC    XL1'&#DISP2'  1ST. BYTE OF NORMAL DISPOSITION\n*                              CATLG,UNCATLG,DELETE,KEEP\n         DC    XL1'&#DISP3'  1ST. BYTE OF CONDITIONALODISPOSITION\n*                              SAME VALUES AS FOR 'ANDISP'\n         DC    XL1'&#SPACET' SPACE TYPE TRK OR CYL (BLOCK NOT ALLOWED)\n         DC    H'&#PRIM'     PRIMARY SPACE ALLOCATION\n         DC    H'&#SECOND'   SECONDARY SPACE ALLOCATION\n         DC    H'&#DIRB'     DIRECTORY BLOCKS\n         DC    CL1'&#BUFNO'  NUMBER OF BUFFERS\n         DC    CL8'&#UNIT'   DEVICE UNIT TYPE (SYSALLDA,SYSDA,ETC...)\n         DC    XL1'&#RECFM'  RECFM (RECORD FORMAT VALID EQUATES BELOW)\n         DC    XL2'&#DSORG'  DATASET ORGANISATION (VALID EQUATES BELOW)\n         DC    H'&#LRECL'    RECORD LENGTH\n         DC    H'&#BLKSZ'    BLOCK SIZE\n         DC    CL1'&#CLASS'  SYSOUT CLASS (ANY VALID CLASS)\n         DC    CL8'&#WRTR'   SYSOUT WRITER-NAME/INTRDR\n         DC    CL8'&#DEST'   DESTINATION PRINTER-ID\n         DC    CL4'&#FCB'    FCB\n         DC    AL1(&#COPIES) NUMBER OF COPIES\n         DC    CL1'&#RLSE'   FLAG TO INDICATE RELEASE OF UNUSED SPACE\n*                              SET TO NON X'00'\n         AIF   ('&REGSMC1' NE 'ADYN').ECONST1\n         DS    16F           GLOBAL REGISTER SAVE AREA\n&REGSMC1 SETC  '    '\n.ECONST1 ANOP\n*--------------------END OF ADYN DSECT FORMAT-------------------------*\n         AGO   .MEXIT\n.*-------------------END OF CONSTANT FORMAT---------------------------*\n.*\n.*\n.*--------------------DSECT MAPPING OF ADYN VARIABLES-----------------*\n.DATAVAR ANOP\n.*&NAME    DSECT\n*--------------------------------------------------------------------*\n* DSECT USED TO MOVE VARIABLE DYNAMIC ALLOCATION DATASET DETAILS.    *\n*--------------------------------------------------------------------*\nYDD      DC    CL8'&#DD'     DD NAME\nYDDC     DC    CL8'&#DDC'    DD NAME TO CONCATENATE\nYDSN     DC    CL44'&#DSN'   DSN NAME OR '*' FOR TERMINAL\nYMEMBER  DC    CL8'&#MEMBER' MEMBER NAME OR GDG GENERATION (-N,0,+N)\nYVOLSER  DC    CL6'&#VOLSER' DISK DATASET RESIDES ON\n*\nYDISP    DC    XL1'&#DISP1'  1ST. BYTE OF STATUS (NEW,OLD,MOD,SHR)\nYSHR     EQU   X'08'          - SHARE DISPOSITION (STATUS)\nYNEW     EQU   X'04'          - NEW   DISPOSITION (STATUS)\nYMOD     EQU   X'02'          - MOD   DISPOSITION (STATUS)\nYOLD     EQU   X'01'          - OLD   DISPOSITION (STATUS)\n*\n.*-------------------------------------------------------------------*\n         AIF ('&#CHDISP' EQ 'NO').A2DCM32\n         AIF ('&#CHDISP' EQ 'YES').A2DCM31\n         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN CATALOGUED.'\n         AGO   .A2DCM32  ANOP\n.A2DCM31  ANOP\n         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN FORCED TO ''DELETE'''\n.A2DCM32  ANOP\n.*-------------------------------------------------------------------*\nYNDISP   DC    XL1'&#DISP2'  1ST. BYTE OF NORMAL DISPOSITION\n*                              CATLG,UNCATLG,DELETE,KEEP\nYUNCAT   EQU   X'01'           - UNCATALOG\nYCATLG   EQU   X'02'           - CATALOG\nYDELETE  EQU   X'04'           - DELETE\nYKEEP    EQU   X'08'           - KEEP\nYCDISP   DC    XL1'&#DISP3'  1ST. BYTE OF CONDITIONALODISPOSITION\n*                              SAME VALUES AS FOR 'ANDISP'\nYSPACET  DC    XL1'&#SPACET' SPACE TYPE TRK OR CYL (BLOCK NOT ALLOWED)\nYTRK     EQU   X'07'           - TRACK MASK\nYCYL     EQU   X'08'           - CYLINDER MASK\n*\nYPRIM    DC    H'&#PRIM'     PRIMARY SPACE ALLOCATION\nYSECOND  DC    H'&#SECOND'   SECONDARY SPACE ALLOCATION\nYDIRB    DC    H'&#DIRB'     DIRECTORY BLOCKS\nYBUFNO   DC    CL1'&#BUFNO'  NUMBER OF BUFFERS\nYUNIT    DC    CL8'&#UNIT'   DEVICE UNIT TYPE (SYSALLDA,SYSDA,ETC...)\n*\nYRECFM   DC    XL1'&#RECFM'  RECFM (RECORD FORMAT VALID EQUATES BELOW)\nYFBA     EQU   X'94'           - FBA\nYVBA     EQU   X'54'           - VBA\nYFB      EQU   X'90'           - FB\nYVB      EQU   X'50'           - VB\nYU       EQU   X'C0'           - U\nYF       EQU   X'80'           - F\nYV       EQU   X'40'           - V\n*\nYDSORG   DC    XL2'&#DSORG'  DATASET ORGANISATION (VALID EQUATES BELOW)\nYDSOPOU  EQU   X'0300'         - POU\nYDSOPSU  EQU   X'4100'         - PSU\nYDSODAU  EQU   X'2100'         - DAU\nYDSOPO   EQU   X'0200'         - PO\nYDSOPS   EQU   X'4000'         - PS\nYDSODA   EQU   X'2000'         - DA\n*\nYLRECL   DC    H'&#LRECL'    RECORD LENGTH\nYBLKSIZE DC    H'&#BLKSZ'    BLOCK SIZE\nYCLASS   DC    CL1'&#CLASS'  SYSOUT CLASS (ANY VALID CLASS)\nYWRITER DC     CL8'&#WRTR'   SYSOUT WRITER-MAME/INTRDR\nYDEST    DC    CL8'&#DEST'   DESTINATION PRINTER-ID\nYFCB     DC    CL4'&#FCB'    FCB\nYCOPIES  DC    AL1(&#COPIES) NUMBER OF COPIES\nYRLSE    DC    CL1'&#RLSE'   FLAG TO INDICATE RELEASE OF UNUSED SPACE\n*                              SET TO NON X'00'\n         AIF   ('&REGSMC2' NE 'ADYN').EDSECT1\n&REGSMC2 SETC  '    '\n         AIF   (&REGDFLG).EDSECT1 EXIT IF ALREADY PROCESSED\n&REGDFLG SETB  1\n&REGSAVR DS    16F           GLOBAL REGISTER SAVE AREA\n.EDSECT1 ANOP\n*--------------------END OF ADYN DSECT FORMAT-------------------------*\n         AGO .MEXIT\n.DATAIBM ANOP\n*---------------------------------------------------------------------*\n*     IBM REQUIRED MACROS                                             *\n*---------------------------------------------------------------------*\n         IEFZB4D0\n         IEFZB4D2\n         AGO .MEXIT\n*---------------------------------------------------------------------*\n.CON#0E0 MNOTE 12,'\"&#ACTION\" NOT DEFINED YET.'\n.MEXIT   ANOP\n         MEXIT\n         MEND\n*---------------------------------------------------------------------*\n*------- Macro 12. PDUMPR --------------------------------------------*\n         MACRO\n&NAME    PDUMPR &ADDR,          Address to display                     X\n               &REGP=YES,       Ser REGP= parameter                    X\n               &TYPE=VAR,       CONstant/VARiable type for MF=L        X\n               &ISPI=YES,       Invoke ISPEXEC INIT=Y explicitly       X\n               &X2CE=NO,        HEXCHMAC MF=E required ?               X\n               &X2CL=NO,        HEXCHMAC MF=L required ?               X\n               &REXX=SHOWSTOR,  REXX EXEC                              X\n               &HELP=NO,        Help in expansion                      X\n               &MSG=,           Message area for GC009                 X\n               &LIST=NO,        List expansion                         X\n               &DISPLAY=ASIS,   Process SHOWSTOR display               X\n               &DISP=ASIS,      Alias for DISPLAY                      X\n               &QUIT=,          R15 set to 'QUIT' branch               X\n               &MF=             EXEC/LIST format\n.*\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP   Go full help\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'PDUMPR' parameter and  *\n* it's use, pass parameter 'HELP=Yes'.                                *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE                         Bypass full help\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* This facility is used to display memory from within a program using *\n* the SHOWSTOR memory mapper written in REXX, using ISPF services.    *\n*                                                                     *\n* All parameters are keyword parameters except the first which is the *\n* only positional parameter for the address to be displayed. The      *\n* format is as follows:                                               *\n*                                                                     *\n*   PDUMPR addr,kw1=..,kw2=..,kwn=...                                 *\n*                                                                     *\n* The following are permissable parameters:                           *\n*   addr          - Address to be displayed. May be any relocatable   *\n*                   address, a register in parentheses or a displace- *\n*                   memt and register in parentheses.                 *\n*   ISPI=Yes/No   o Invoke the ISPEXEC macro with the INIT option in  *\n*                   it. Default is Yes. Set to No if you explicitly   *\n*                   use the ISPEXEC macro in your program.            *\n*   X2CE=Yes/No   o Invoke the HEXCHMAC macro MF=E format. This is    *\n*                   only used if the HEXCHMAC with MF=E is explicitly *\n*                   used in the same program and will prevent         *\n*                   duplicate variable names. If PDUMPR is invoked    *\n*                   with MF=E then this feature is automatically      *\n*                   enabled. The default is NO.                       *\n*   X2CL=Yes/No   o Invoke the HEXCHMAC macro MF=L format. Similar to *\n*                   X2CE parameter. Default is No.                    *\n*   MSG='....'    - MEssage to display on entering SHOWSTOR. Literal  *\n*      =label()     padded/truncated to 256 bytes or a label where    *\n*                   256 bytes or length of variable subscripted is    *\n*                   moved, eg. MSG=MSGSRCE(80).                       *\n*   QUIT=label    - Label of the instruction where control is to be   *\n*                   passed if SHOWSTOR is terminated using the 'QUIT' *\n*                   feature. Refer to SHOWSTOR documentation for      *\n*                   further details.                                  *\n*   REGP=Yes/No   - Set REGP= parameter on entry. this will enable    *\n*                   the use of the /REGS* command. (Refer to SHOWSTOR *\n*                   documentation.) Default is Yes and you would be   *\n*                   a fool to suppress this handy feature.            *\n*   REXX=SHOWSTOR - REXX EXEC to be executed from the macro. This     *\n*                   should not be changed.                            *\n*   TYPE=Var/Con  - Constatnt/Variable type for MF=L format. VAR is   *\n*                   the default.                                      *\n*   DISPLAY=Yes/No/Asis                                               *\n*                 - Activate or bypass SHOWSTOR displays. Used to     *\n*                   control SHOWSTOR displays during looping. Any     *\n*                   value other than 'N' or 'Y' will default to 'A'.  *\n*                   Use this parameter without an Address to set the  *\n*                   condition without a display.                      *\n*   HELP=No/Yes   - Help in expansion of this macro.                  *\n*   LIST=No/Yes   - List expansion.                                   *\n*   MF=           - Exec/List format.                                 *\n*                                                                     *\n* To use this feature you will also need access to macros ISPEXEC and *\n* HEXCHMAC.                                                           *\n* Parameters with an 'o' seperator are parameters whose values are    *\n* dependant on the requirements of the ISPEXEC or HEXCHMAC macros.    *\n* Refer to the actual macros for further details.                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* Known GOTCHAs:                                                      *\n* - This facility cannot be invoked from an authorised program        *\n*   because of ISPF's limitations with authorised programs.           *\n* - Because the macros used are designed in subroutine format, ensure *\n*   that the first physical occurance of this macro (or it's related  *\n*   counterparts of ISPEXEC and HEXCHMAC) are the ones actually       *\n*   executed first to ensure all variables/settings are initialised.  *\n*   This can be a problem in programs with a lot of branching logic.  *\n*   To safeguard against this, invoke the macro as early as possible  *\n*   in your program without an \"addr\" parameter to force              *\n*   initialisation of all 3 macros (PDUMPR, ISPEXEC and HEXCHMAC).    *\n* - Take care when explicitly using ISPEXEC and HEXCHMAC macros       *\n*   outside this macro. You may need to fine tune the ISPI= and the   *\n*   X2CE= and X2CL= parameters to prevent duplicate names.            *\n*                                                                     *\n*---------------------------------------------------------------------*\n.*\n.A$HELPE ANOP\n.*\n         AIF   ('&LIST'(1,1) EQ 'Y').A$XXX\n         PUSH  PRINT\n         PRINT NOGEN\n.A$XXX   ANOP\n.*\n         LCLC  &SMXVAR,&L,&#DISP,&#ADR\n         GBLB  &SMXFST1,&SMXEXE1,&SMXLST1\n         GBLC  &SMXFXD\n         GBLB  &XC1ST\n.*\n.*--------------------------------------------------------------------*\n.* Evaluate and set Display requirements                              *\n.*--------------------------------------------------------------------*\n         AIF   (T'&DISPLAY EQ 'O').A$001 Test for 'alias'\n&#DISP   SETC  '&DISPLAY'                Set to parameter\n         AGO   .A$002                    GoAround alternate process\n.A$001   ANOP\n         AIF   (T'&DISP EQ 'O').A$002    Bypass\n&#DISP   SETC  '&DISP'                   Set to 'alias' parameter\n.A$002   ANOP\n.*\n.*--------------------------------------------------------------------*\n.* Evaluate address if passed as (reg)....                            *\n.*--------------------------------------------------------------------*\n&#ADR    SETC  '&ADDR'                Set to parameter\n         AIF   (T'&#ADR EQ 'O').A$003 Bypass processing\n         AIF   ('&#ADR'(1,1) NE '(').A$003 Bypass if 1st char not '('\n&#ADR    SETC  '0&#ADR.'              Set to Offset zero\n.A$003   ANOP\n.*--------------------------------------------------------------------*\n.*\n         AIF   (&SMXFST1).A$010\n.*--------------------------------------------------------------------*\n.* Global variables on initial invocation\n.*--------------------------------------------------------------------*\n&SMXFST1 SETB  1                       Set 1st. time thru  flag\n&SMXFXD  SETC  'SMX'.'&SYSNDX'         Set fixed index value\n&#DISP   SETC  'YES'                   Force display 1st. time thru\n.A$010   ANOP\n.*--------------------------------------------------------------------*\n.* Local variables on each invocation\n.*--------------------------------------------------------------------*\n&SMXVAR  SETC  'SMX'.'&SYSNDX'         Set variable index value\n.*--------------------------------------------------------------------*\n.* Global variables on each invocation\n.*--------------------------------------------------------------------*\n&SMXLB0  SETC  '&SMXVAR'.'0'           Set variables (Full word branch)\n&SMXLB1  SETC  '&SMXFXD'.'1'           Set variables\n&SMXLB2  SETC  '&SMXVAR'.'2'           Set variables\n&SMXLB3  SETC  '&SMXVAR'.'3'           Set variables\n&SMXLB4  SETC  '&SMXFXD'.'4'           Set variables\n&SMXLB5  SETC  '&SMXFXD'.'5'           Set variables\n&SMXLB6  SETC  '&SMXVAR'.'6'           SPARE - NOT USED\n&SMXLB7  SETC  '&SMXVAR'.'Z'           Set variable (PDUMPR terminator)\n&SMXLB8  SETC  '&SMXVAR'.'X'           Set variable (PDUMPR start)\n&SMXWK1  SETC  '&SMXFXD'.'8'           Set variables\n&SMXWK2  SETC  '&SMXFXD'.'9'           Set variables\n&SMXWK3  SETC  '&SMXFXD'.'A'           Set variables\n&SMXWK4  SETC  '&SMXFXD'.'B'           Set variables\n&SMXWK5  SETC  '&SMXFXD'.'C'           Set variables\n&SMXWK6  SETC  '&SMXFXD'.'D'           Set variables\n&SMXWK7  SETC  '&SMXFXD'.'E'           Set variables\n&SMXWK8  SETC  '&SMXFXD'.'F'           Set variables\n&SMXWK9  SETC  '&SMXFXD'.'G'           Set variables\n&SMXWK10 SETC  '&SMXFXD'.'H'           Set variables\n&SMXWK11 SETC  '&SMXFXD'.'I'           Set variables\n&SMXWK12 SETC  '&SMXFXD'.'J'           Set variables\n.*--------------------------------------------------------------------*\n&L       SETC  '&LIST'\n         AIF   (T'&NAME EQ 'O').A$YYY  Bypass if label passed\n&SMXLB0  SETC  '&NAME'                 Use invocation name fro label\n.A$YYY   ANOP\n.*\n         AIF   ('&MF' EQ 'L').A$200    Process list form of macro\n.*\n&SMXLB8  DS    0H                      START ANCHOR\n         B     &SMXLB0                 ENSURE FULL WORD BRANCH\n         AIF   (T'&MF EQ 'O').A$200    Process list form of macro\n.A$020   ANOP\n&SMXLB0  DS    0F                      ENSURE FULL WORD ALLIGNMENT\n.*\n         AIF   (&SMXEXE1).A$050        Bypass if not 1st. MF=E\n&SMXEXE1 SETB  1\n         STM   R0,R15,&SMXWK9          SAVE ALL REGISTERS\n         AIF   ('&ISPI'(1,1) NE 'Y').A$022A Bypass if ISPEXEC not req\n         AIF   ('&LIST'(1,1) EQ 'Y').A$021  Process list form yes\n         ISPEXEC INIT=Y,MF=E           INITIALISE ISPF ENVIRONMENT\n         AGO   .A$022\n.A$021   ANOP\n         ISPEXEC INIT=Y,MF=E,LIST=&L   INITIALISE ISPF ENVIRONMENT\n.A$022   ANOP\n         LM    R0,R15,&SMXWK9          RESTORE REGISTERS\n.A$022A  ANOP\n         B     &SMXLB2                 BRANCH AROUND CODE\n&SMXLB1  DS    0H\n         ST    R1,&SMXWK8              STORE FOR CONVERSION\n         AIF   ('&X2CE'(1,1) EQ 'Y').X2C012 Process MF=E format\n         AIF   ('&MF' EQ 'E').X2C011   Process MF=E format\n.X2C010  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK2,4,LIST=&L HEX TO CHARACTER\n         AGO   .X2C012                 Bypass MF=E format\n.X2C011  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK2,4,LIST=&L,MF=E HEX TO CHARACTER\n.X2C012  ANOP\n.*\n         CLI   &SMXWK7,C'Y'            Q. SETUP REGISTERS\n         BE    &SMXLB4                    Y. GO DO IT\n         MVI   &SMXWK3,C' '            BLANK FILL (RIPPLE)\n         MVC   &SMXWK3.+1(L'&SMXWK3.+L'&SMXWK4.-1),&SMXWK3\n         B     &SMXLB5                 BYPASS SETUP REGISTER\n&SMXLB4  DS    0H\n         MVC   &SMXWK3.(06),=C' REGP=' SET REGISTER\n         LA    R1,&SMXWK9              LOAD ADDRESS REGISTER SAVE AREA\n         ST    R1,&SMXWK8              STORE FOR CONVERSION\n         AIF   ('&X2CE'(1,1) EQ 'Y').X2C022 Process MF=E format\n         AIF   ('&MF' EQ 'E').X2C021   Process MF=E format\n.X2C020  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK4,4,LIST=&L HEX TO CHARACTER\n         AGO   .X2C022                 Bypass MF=E format\n.X2C021  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK4,4,LIST=&L,MF=E HEX TO CHARACTER\n.X2C022  ANOP\n*---------------------------------------------------------------------*\n&SMXLB5  DS    0H\n         AIF   ('&LIST'(1,1) EQ 'Y').A$041 Process list form Yes\n         ISPEXEC &SMXWK1,&SMXWK6       CALL 'SHOSTOR' REXX EXEC\n         AGO   .A$042\n.A$041   ANOP\n         ISPEXEC &SMXWK1,&SMXWK6.,LIST=&L CALL 'SHOSTOR' REXX EXEC\n.A$042   ANOP\n         L     R14,&SMXWK8.+4          LOAD RETURN ADDRESS\n         BR    R14                     RETURN TO CALLER\n&SMXLB2  DS    0H\n.*\n.A$050   ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&#DISP EQ 'O').A$058 Do not set, just test\n         AIF   ('&#DISP'(1,1) EQ 'Y').A$057 Use passed value\n         AIF   ('&#DISP'(1,1) NE 'N').A$058 Bypass value setting\n.A$057   ANOP\n&#DISP   SETC  '&#DISP'(1,1)          Use 1st. byte\n         MVI   &SMXWK11,C'&#DISP'      SET DISPLAY REQUIREMENT\n         AIF   (T'&#ADR EQ 'O').SETEXT Continue if have an address\n         AIF   ('&#DISP'(1,1) EQ 'Y').A$059 Bypass test if set 2 'Y'\n         AIF   ('&#DISP'(1,1) EQ 'N').A$090 Bypass all if 'N' req'd\n.A$058   ANOP\n         AIF   (T'&#ADR EQ 'O').SETEXT Continue if have an address\n         CLI   &SMXWK11,C'N'           Q. DISPLAY REQUIRED\n         BE    &SMXLB7                    N. BYPASS\n.A$059   ANOP\n.*--------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n* Set up PDUMPR start and end addresses for potential anchor points.  *\n*---------------------------------------------------------------------*\n         MVC   &SMXWK12.(21),=C'RR=......../........ '\n         LA    R1,&SMXLB8              START PDUMPR ADDRESS\n         ST    R1,&SMXWK8              STORE FOR CONVERSION\n         AIF   ('&X2CE'(1,1) EQ 'Y').X2C032 Process MF=E format\n         AIF   ('&MF' EQ 'E').X2C031   Process MF=E format\n.X2C030  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK12+3,4,LIST=&L HEX TO CHARACTER\n         AGO   .X2C032                 Bypass MF=E format\n.X2C031  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK12+3,4,LIST=&L,MF=E HEX TO CHARACTER\n.X2C032  ANOP\n.*--------------------------------------------------------------------*\n         LA    R1,&SMXLB7              END PDUMPR ADDRESS\n         ST    R1,&SMXWK8              STORE FOR CONVERSION\n         AIF   ('&X2CE'(1,1) EQ 'Y').X2C042 Process MF=E format\n         AIF   ('&MF' EQ 'E').X2C041   Process MF=E format\n.X2C040  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK12+12,4,LIST=&L HEX TO CHARACTER\n         AGO   .X2C042                 Bypass MF=E format\n.X2C041  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK12+12,4,LIST=&L,MF=E HEX TO CHARACTER\n.X2C042  ANOP\n.*--------------------------------------------------------------------*\n         STM   R0,R15,&SMXWK9          SAVE ALL REGISTERS\n         LA    R0,&SMXLB3              LOAD RETURN ADDRESS\n         ST    R0,&SMXWK8.+4           SAVE RETURN ADDRESS\n         AIF   ('&REGP'(1,1) EQ 'N').A$060  Bypass if REGP=No\n         MVI   &SMXWK7,C'Y'            SETUP REGISTERS REQUEST\n         AGO   .A$065                  Branch around negative set\n.A$060   ANOP\n         MVI   &SMXWK7,C'N'            REGISTERS NOT REQUIRED\n.A$065   ANOP\n         AIF   (T'&MSG EQ 'O').A$075  Bypass if deliberate omission\n         MVI   &SMXWK10,C' '           INITIALISE OUTPUT MESSAGE USING\n         MVC   &SMXWK10.+1(L'&SMXWK10.-1),&SMXWK10 ..RIPPLE MOVE\n&MSGNW   SETC  '&MSG'                 Set message to move from label\n         AIF   ('&MSG'(1,1) EQ '''').A$072 Go process literal message\n.*--------------------------------------------------------------------*\n.* Establish length of literal and move length                        *\n.*--------------------------------------------------------------------*\n         LCLA  &APOST\n&MSGL    SETA  K'&MSG                     Set length of message\n         AIF   ('&MSG'(&MSGL,1) EQ ')').A$071\n         MVC   &SMXWK10,&MSGNW         MOVE MESSAGE TO OUTPUT\n         AGO   .A$075                       Leave process\n.A$071   ANOP\n&MSGL1   SETA  &MSGL-1\n&APOST   SETA  0\n.LOOP1   ANOP\n         AIF   (&MSGL1 EQ  0).E4\n         AIF   ('&MSG'(&MSGL1,1) EQ ',').LOOP1E\n         AIF   ('&MSG'(&MSGL1,1) EQ '(').LOOP2E\n&MSGL1   SETA  &MSGL1-1\n         AGO   .LOOP1\n.LOOP1E  ANOP\n&APOST   SETA  &MSGL1\n&MSGL1   SETA  &MSGL1-1\n.LOOP2   ANOP\n         AIF   (&MSGL1 EQ 0).E4\n         AIF   ('&MSG'(&MSGL1,1) EQ '(').LOOP2E\n&MSGL1   SETA  &MSGL1-1\n         AGO   .LOOP2\n.LOOP2E  ANOP\n         AIF   (&APOST EQ 0).VARMSG\n&MSGL3   SETC  '&MSG'(&MSGL1+1,&APOST-(&MSGL1+1))\n&MSGNW   SETC  '&MSG'(1,&MSGL1).'&MSG'(&APOST+1,&MSGL-&APOST)\n         AGO   .MSGDTOK\n.VARMSG  ANOP\n&MSGL3   SETC  '&MSG'(&MSGL1+1,&MSGL-(&MSGL1+1))\n&MSGNW   SETC  '&MSG'(1,&MSGL1-1)\n.MSGDTOK ANOP\n         MVC   &SMXWK10.(&MSGL3),&MSGNW MOVE MESSAGE TO OUTPUT\n         AGO   .A$075                       Leave process\n.*-------------------------------------------------------------------*\n.* Establish length of variable and move length                      *\n.*-------------------------------------------------------------------*\n.A$072   ANOP\n         LCLC  &CHAR,&AMPER\n         LCLA  &LC,&QC,&AC\n&AMPER   SETC  '&&'\n&MSGL    SETA  K'&MSG                       Loop counter (message len)\n&QC      SETA  0                            Quotes counter\n&AC      SETA  0                            Ampersand counter\n&CP      SETA  0                            Character pointer\n.LOOP3   ANOP\n&CP      SETA  &CP+1                        Iincrement char pointer\n&CHAR    SETC  '&MSG'(&CP,1)                Set character value\n.TQUOT   ANOP\n         AIF   ('&CHAR' NE '''').TAMPR      Bypass if char not \"'\"\n&QC      SETA  &QC+1                        Bump quotes counter\n         AGO   .NXTCH                       Get nest char\n.TAMPR   ANOP\n         AIF   ('&CHAR.&CHAR' NE '&AMPER').NXTCH Bypass if not \"&\"\n&AC      SETA  &AC+1                        Bump amper counter\n.NXTCH   ANOP\n         AIF   (&CP LT &MSGL).LOOP3         Loop till end\n&MSGL    SETA  &MSGL-2-(((&QC-2)/2)+(&AC/2)) Get actual length\n         MVC   &SMXWK10.(&MSGL),=CL(&MSGL)&MSG\n.A$075   ANOP\n.*--------------------------------------------------------------------*\n         LA    R1,&#ADR                LOAD ADDRESS OF ADDRESS\n         B     &SMXLB1                 BRANCH TO COMMON CODE\n&SMXLB3  DS    0H\n         LM    R0,R15,&SMXWK9          RESTORE ALL REGISTERS\n         AIF   (T'&QUIT EQ 'O').A$080  Bypass if no QUIT\n         C     R15,=C'QUIT'            Q. QUIT REQUESTED\n         BE    &QUIT                      Y. GO TO LABEL\n.A$080   ANOP\n         C     R15,=C'DOFF'            Q. DISPLAY OFF REQUESTED\n         BNE   &SMXLB7                    N. BYPASS\n         MVI   &SMXWK11,C'N'           SET DISPLAY OFF\n&SMXLB7  DS    0H                      EXIT ANCHOR\n.A$090   ANOP\n         AGO   .MEXIT                  Exit macro\n.*\n.A$200   ANOP\n         AIF   (T'&MF NE 'O').A$205    Bypass if MF is set\n         AIF   (&SMXEXE1).A$020        Return if previously executed\n.A$205   ANOP\n         AIF   ('&TYPE'(1,1) NE 'C').A$210  Bypass if not constant\n&SMXWK1  SETC  ''\n&SMXWK2  SETC  ''\n&SMXWK3  SETC  ''\n&SMXWK4  SETC  ''\n&SMXWK5  SETC  ''\n&SMXWK6  SETC  ''\n&SMXWK7  SETC  ''\n&SMXWK8  SETC  ''\n&SMXWK9  SETC  ''\n&SMXWK10 SETC  ''\n&SMXWK11 SETC  ''\n&SMXWK12 SETC  ''\n.*\n.A$210   ANOP\n.*\n         AIF   ('&ISPI'(1,1) NE 'Y').A$224 Bypass if ISPEXEC not req'd\n         AIF   ('&LIST'(1,1) EQ 'Y').A$221 Process list form Yes\n         ISPEXEC  MF=L,INIT=Y,TYPE=&TYPE INIT ISPF ENVIRONMENT\n         AGO   .A$224\n.A$221   ANOP\n         AIF   ('&ISPI'(1,1) EQ 'N').A$224 Bypass if INIT=No\n.A$222   ANOP\n         ISPEXEC  MF=L,INIT=Y,LIST=&L,TYPE=&TYPE INIT ISPF ENVIRONMENT\n.A$224   ANOP\n         DS    0F                      WORD ALLIGN\n&SMXWK8  DS    2F                      WORK AREA\n&SMXWK9  DS    16F                     REGISTER SAVE AREA FRO MACRO\n&SMXWK1  DC    C'SELECT CMD(%SHOWSTOR ' WHAT WE WANT TO EXECUTE\n&SMXWK2  DC    C'        '             ADDRESS WE WANT TO DISPLAY\n&SMXWK3  DC    C' REGP='               REGISTER EQUATE LITERAL\n&SMXWK4  DC    C'        '             ADDRESS WE WANT TO DISPLAY\n         DC    C' '                    FILLER\n&SMXWK12 DC    CL21'RR=......../........ ' Start and finish\n.*-------------------------------------------------------------------*\n.*   NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE    *\n.*-------------------------------------------------------------------*\n.* Modify the length of the next field to ensure the value (length)  *\n.* of variable &SMXWK6 does not exceed 256 as &SMXWK1 and &SMXWK6    *\n.* are used in a MVC instruction.                                    *\n.*-------------------------------------------------------------------*\n&SMXWK10 DC    CL190' '                MESSAGE AREA\n.*-------------------------------------------------------------------*\n&SMXWK5  DC    C')'                    WHAT WE WANT TO EXECUTE\n         AIF   ('&TYPE'(1,1) EQ 'C').A$223  Bypass if constant\n&SMXWK6  EQU   *-&SMXWK1               ISPF COMMAND LENGTH\n.A$223   ANOP\n&SMXWK7  DC    C'Y'                    REGISTER GENERATE FLAG\n&SMXWK11 DC    C'Y'                    DISPLAY ON\n         AIF   ('&X2CL'(1,1) NE 'Y').X2C090 BYpass MF=L for HEXCHMAC\n         HEXCHMAC MF=L\n.X2C090  ANOP\n         AIF   (T'&MF EQ 'O').A$020    Return\n         AGO   .MEXIT                  Exit\n.*--------------------------------------------------------------------*\n.E0      MNOTE 12,'No Errors at this stage'\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.SETEXT  ANOP\n&SMXLB7  DS    0H                      EXIT ANCHOR\n.MEXIT   ANOP\n         AIF   ('&LIST'(1,1) EQ 'Y').MEXIT9\n         POP   PRINT\n.MEXIT9  ANOP\n         MEXIT\n         MEND\n*---------------------------------------------------------------------*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADYN": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x19\\x00'\\x00\\x93\\x05\\x0f\\x00\\x952\\x7f\\x17\\x14\\t\\x08\\x08D\\x00\\x00\\xe4\\xe3\\xd4\\xd7\\xf5\\xf4\\xf3@@@\"", "ispf": {"version": "01.25", "flags": 0, "createdate": "1993-02-19T00:00:00", "modifydate": "1995-11-23T17:14:27", "lines": 2312, "newlines": 2116, "modlines": 0, "user": "UTMP543"}, "text": "         MACRO\n&NAME    ADYN  &ACTION=INFO,                                           +\n               &BASE=,                                                 +\n               &BLKSIZE=,                                              +\n               &BUFNO=,                                                +\n               &CCP=YES,                                               +\n               &COPIES=,                                               +\n               &DATA=,                                                 +\n               &DD=,                                                   +\n               &DDC=,                                                  +\n               &DDR=NO,                                                +\n               &DEST=,                                                 +\n               &DISP=,                                                 +\n               &DSN=,                                                  +\n               &DSNR=NO,                                               +\n               &DSORG=,                                                +\n               &ERROR=,                                                +\n               &FCB=,                                                  +\n               &HELP=NO,                                               +\n               &LIST=YES,                                              +\n               &LRECL=,                                                +\n               &MEMBER=,                                               +\n               &MF=,                                                   +\n               &PARMT=PARM,                                            +\n               &PDUMP=NO,                                              +\n               &PDUMPX=,                                               +\n               &PERMA=YES,                                             +\n               &RECFM=,                                                +\n               &REGR=YES,                                              +\n               &REUSE=NO,                                              +\n               &RLSE=,                                                 +\n               &R1=R1,                                                 +\n               &R4=R4,                                                 +\n               &R5=R5,                                                 +\n               &R6=R6,                                                 +\n               &R7=R7,                                                 +\n               &SPACE=,                                                +\n               &SYSOUT=,                                               +\n               &UCLOSE=NO,                                             +\n               &UNIT=,                                                 +\n               &VOLR=NO,                                               +\n               &VOLSER=\n*--------------------------START OF ADYN------------------------------*\n&NAME    DS    0H\n         PUSH  PRINT\n         AIF   ('&LIST' NE 'NO').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   ('&HELP' EQ 'YES').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'ADYN' parameters and   *\n* use pass parameter 'HELP=YES'.                                      *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n***********************************************************************\n*                                                                     *\n* DYNAMIC ALLOCATION MACRO.      Written by A. Kara.                  *\n* -------------------------                                           *\n*           N O T E - N O T E - N O T E - N O T E - N O T E           *\n*                                                                     *\n*   This routine saves and uses the following general registers:      *\n*      R1, R4, R5, R6, R7, R14 and R15.                               *\n*   If any of these registers are used as base registers or anchors   *\n*   for the DSECT containing the DATA format of the macro (if used),  *\n*   either substitute with an unused one (refer parameter 'Rn') or do *\n*   not use this macro.                                               *\n*                                                                     *\n*   This macro is only applicable to DASD and cannot be used for      *\n*   tapes.                                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n* Macro to generate code to dynamically Allocate/Info/Delete/         *\n*  Unallocate|Free/Deconcatenate/Concatenate/Reallocate               *\n*                                                                     *\n*   Parameters:                                                       *\n*       1. ACTION  - valid actions are:                               *\n*                    'Info'    - advise if dataset is allocated.      *\n*                                Requires the following minimum       *\n*                                parameters:                          *\n*                                  DD and DSN.                        *\n*                    'Alloc'   - allocate datest (basically pass jcl  *\n*                                format parameters).                  *\n*                                To reallocate, pass parameter of     *\n*                                REUSE=YES.                           *\n*                    'Unalloc'/'Free'/'DEConc'                        *\n*                              - any one of these command will        *\n*                                unallocate the dataset/concatenations*\n*                    'DELete'  - delete allocates the DSN with        *\n*                                'DISP=(OLD,DELETE,DELETE)' then frees*\n*                                it.                                  *\n*                    'Conc'    - concatenates the dd name defined on  *\n*                                the 'DDC' parameter to the 'DD' parm.*\n*                                                                     *\n*       2. BASE    - Register to be used as a base register for the   *\n*                    SVC 99 DSECT 'S99RBP'. This register must be     *\n*                    loaded with the address of the area where the    *\n*                    SVC 99 parameter list may be built. Also used to *\n*                    invoke the 'DYNALLOC' routine automatically.     *\n*                    (Do not enclose in brackets.)                    *\n*                    If the base parameter is not passed, the         *\n*                    following will need to be explicitly coded:      *\n*                    1. Before the invocation of the 'ADYN' macro:    *\n*                                                                     *\n*                         USING S99RBP,Rn  establish addresability    *\n*                                                                     *\n*                    2. On return from the macro:                     *\n*                                                                     *\n*                         LR    R1,Rn  req blk ptr in R1 for dynalloc *\n*                                      (both Rn must be same register)*\n*                         DYNALLOC                                    *\n*                                                                     *\n*       3. BLKSIZE - Block size. (Same restrictions as 'LRECL').      *\n*                                                                     *\n*       4. CCP     - Wheteher to make concatenation permanent.        *\n*                    Valid values are YES/NO with YES as default.     *\n*                                                                     *\n*       5. COPIES  - Number of copies to print (for SYSOUT DD's)      *\n*                                                                     *\n*       6. DATA    - Valid values are 'VARiable'/'CONstant'/'IBM'.    *\n*                    Set up the data fields if you use the parameter  *\n*                    'PARMT=DATA' in your program:                    *\n*                    Set to 'VARiable' if you want a map of the data  *\n*                    fields used for variable parameter passing. This *\n*                    is required in your getmained DSECT for re-      *\n*                    entrant programs.                                *\n*                    You may initialise this area by coding a macro   *\n*                    with 'DATA=CONstant' in your constant data area  *\n*                    and on the macro pass all the parameters as      *\n*                    though you were coding a macro with 'PARMT=PARM' *\n*                    and moving it over the variable part. The max    *\n*                    length of the data is 123 bytes.  If the program *\n*                    is not re-entrant you only need to code the macro*\n*                    with the parameter of 'DATA=VARiable'.           *\n*                    In all cases supply a macro with 'DATA=IBM' to   *\n*                    define the IBM required macros. If this is not   *\n*                    defined in your program, you must explicitly     *\n*                    define the following ibm macros in your program  *\n*                          'IEFZB4D0'                                 *\n*                          'IEFZB4D2'                                 *\n*                    There should only be 1 macro with DATA=IBM/VAR   *\n*                    however you may have as many DATA=CON as you     *\n*                    like. DATA=IBM/VAR generate labels while 'CON'   *\n*                    does not.                                        *\n*                                                                     *\n*       7. DD      - DD name to be allocated. In case of a 'Conc'     *\n*                    action, concatenate the 'DDC' parm to this.      *\n*                    If parameter 'DDR=YES' is used with 'PARMT=PARM' *\n*                    this paramater must point to a variable name in  *\n*                    the data area.                                   *\n*                                    - or -                           *\n*                    DD=(varname) if the DDname is to be taken from   *\n*                    a variable.                                      *\n*                    For DDR=Yes, allign the DD variable on a full-   *\n*                    word boundary to eliminate allignament warning   *\n*                    assembly messages.                               *\n*                                                                     *\n*       8. DDC     - DD name to concatenate to DD name with 'Conc'.   *\n*                                                                     *\n*       9. DDR     - DD name to be returned and placed in the variable*\n*                    specified for the 'DD' parameter after an        *\n*                    'Alloc' request without a DD parm. Set to either *\n*                    YSE/NO ('NO' is the default).                    *\n*                    If 'PARMT=DATA' is used, the DD name is returned *\n*                    in the variable 'YDD' which would have been      *\n*                    defined by the ADYN macro with 'PARMT=VAR'.      *\n*      10. DEST    - Printer-id destination with 'SYSOUT'             *\n*                                                                     *\n*      11. DISP    - Standard JCL type DISP parameter, eg.            *\n*                    'DISP=(NEW,CATLG,DELETE)'                        *\n*                    (default of 'OLD' for 'Allocate' action.)        *\n*                    For new dataset allocation without a 'DSN='      *\n*                    but rather a 'DSNR=' parameter, the 2nd. and 3rd.*\n*                    disposition parameter will be automatically      *\n*                    changed to '(....,DELETE,DELETE)'.               *\n*                                                                     *\n*      12. DSN     - DSNAME (unquoted of course) or '*' for terminal. *\n*                                    - or -                           *\n*                    Variable name to return the DSN name in, after an*\n*                    'Info' request. (If 'PARMT=DATA' is used the DSN *\n*                    will be returned in the variable 'YDSN' which    *\n*                    would have been defined by the ADYN macro with   *\n*                    'PARMT=VAR'.)                                    *\n*                                    - or -                           *\n*                    If the action is ALLOC and the dataset name is   *\n*                    stored in a variable and PARMT=PARM is required, *\n*                    indicate the variable's name by specifying       *\n*                    'DSN=(varname)'.                                 *\n*                    NOTE - This variable must be specified if the    *\n*                    'DSNR=Yes' parameter is used. Use 'DSN=YDSN' for *\n*                    'PARMT=VAR'.                                     *\n*                    For DSNR=Yes, allign the DSN variable on a full- *\n*                    word boundary to eliminate allignament warning   *\n*                    assembly messages.                               *\n*                                                                     *\n*      13. DSNR    - DSN name to be returned and placed in the        *\n*                    variable specified for the 'DSN' parameter after *\n*                    an 'Alloc' request without a DSN parm. Set to    *\n*                    either YES/NO ('NO' is the default).             *\n*                    If 'PARMT=DATA' is used, the DSN name is returned*\n*                    in the variable 'YDSN' which would have been     *\n*                    defined by the ADYN macro with 'PARMT=VAR'.      *\n*                    >>>>>>>>>>>>>>>>>>>> NOTE <<<<<<<<<<<<<<<<<<<<<< *\n*                    Will force 'DISP=(...,DELETE,DELETE)' to prevent *\n*                    allocations of datasets with variable names all  *\n*                    over the place........                           *\n*                    >>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<< *\n*                                                                     *\n*      14. ERROR   - Label to branch to in case of error. If this     *\n*                    parameter is not passed you will have to code    *\n*                    your own return code test:                       *\n*                          LTR  R15,R15                               *\n*                          BNZ  ERROR01                               *\n*                                                                     *\n*      15. FCB     - Forms Control Buffer image id                    *\n*                                                                     *\n*      16. HELP    - Set to YES/NO to include these parameter comments*\n*                    into the assembly listings. The default is 'NO'. *\n*                                                                     *\n*      17. LIST    - Set to YES/NO to generate macro expansion.       *\n*                    Default is 'YES'.                                *\n*                                                                     *\n*      18. LRECL   - Logical record size. As a keyword, pass as an    *\n*                    integer < 32760. As data pass as a halfword.     *\n*                                                                     *\n*      19. MEMBER  - Member name or GDG generation. The GDG generation*\n*                    must be numeric an can take the format -n, 0, n  *\n*                    or +n.                                           *\n*                                    - or -                           *\n*                    MEMBER=(member) if the member name is to be      *\n*                    taken from a variable and PARMT=PARM.            *\n*                                                                     *\n*      20. MF      - Macro format. Must be coded as MF=E to generate  *\n*                    code and MF=L either in a GETMAINed DSECT and/or *\n*                    data area. MF=L defines 16 full words as a       *\n*                    register save area (will not be defined if the   *\n*                    area has already been defined by a prior macro). *\n*                    These 16 full words are appended to both the     *\n*                    DATA=VAR/CON areas if used.                      *\n*                                                                     *\n*      21. PARMT   - Parameter type.                                  *\n*               'PARM'    - Keyword parameters passed (default) on    *\n*                           the EXEC form of the macro.               *\n*               'DATA'    - Parameters passed as data from the 'ADYN' *\n*                           DSECT. If parameters are passed as        *\n*                           variable data, a keyword entry of 'DATA'  *\n*                           is required to tell the macro to process  *\n*                           that parameter from the data area (in     *\n*                           this case the data area must be set up as *\n*                           required).                                *\n*                           (Default is 'PARM'.)                      *\n*                                                                     *\n*      22. PERMA   - 'Permanent allocate' attribute. Prevents         *\n*                    datasets from being automatically dealocated when*\n*                    closed (in on-line environments).                *\n*                    valid values are YES/NO with 'YES' as default.   *\n*                                                                     *\n*      23. PDUMP   - Invoke the PDUMP utility just prior to issuing   *\n*                    the DYNALLOC SVC.                                *\n*                                                                     *\n*      24. PDUMPX  - This parameter is used with the PDUMP parameter  *\n*                    and you may specify an exit point address to     *\n*                    branch to by entering the 'QUIT' command in      *\n*                    PDUMP thereby bypassing execution of DYNALLOC.   *\n*                                                                     *\n*      25. RECFM   - Record format.                                   *\n*                                                                     *\n*      26. REGR    - Set to YES/NO to restore registers on return     *\n*                    from macro, default is 'YES'.                    *\n*                    (Refer note \"A\" below.)                          *\n*                                                                     *\n*      27. REUSE   - Use this parameter if you wany to reallocate the *\n*                    DD name without having to free it.  The macro    *\n*                    will generate the Free statements prior to       *\n*                    Allocation. Set to YES/NO ('NO' is the default). *\n*                                                                     *\n*      28. RLSE    - Release unused space indicator. Not required for *\n*                    keyword parameters as would be passed on the     *\n*                    SPACE= keyword. However, is required if data     *\n*                    passed as there is no equivalent data area.      *\n*                    Valid values are YES/NO with 'NO' as default.    *\n*                                                                     *\n*      29. Rn      - Substitute specified register for the nominated  *\n*                    register in this routine. Registers that may be  *\n*                    substituted are:                                 *\n*                       R1, R4, R5, R6 and R7.                        *\n*                    NOTE - You may use R14 and R15 as substitute     *\n*                           registers.                                *\n*                                                                     *\n*      30. SPACE   - Standard JCL type space parameter, eg.           *\n*                    'SPACE=(TRK,(2,2,1),RLSE)'                       *\n*                    NOTE - In DATA format of the macro, RLSE is      *\n*                           ignored and you must specify the RLSE=YES *\n*                           paremeter.                                *\n*                                                                     *\n*      31. SYSOUT  - SYSOUT class and writer-name:                    *\n*                    eg. SYSOUT=X, SYSOUT=(A,INTRDR),                 *\n*                        SYSOUT=(A,FREDWRTR)                          *\n*                                                                     *\n*      32. UCLOSE  - Unalloc dataset on closing. If this option is to *\n*                    be effective, it must be coded as UCLOSE=YES for *\n*                    both types of parameter passing as there is no   *\n*                    equivalent data area.                            *\n*                    Valid values are YES/NO with 'NO' as default.    *\n*                                                                     *\n*      33. UNIT    - Device unit type. Any valid device unit as would *\n*                    be accepted on JCL.                              *\n*                                                                     *\n*      34. VOLSER  - Volume serial.                                   *\n*                                    - or -                           *\n*                    VOLSER=(volser) if the member name is to be      *\n*                    taken from a variable and PARMT=PARM.            *\n*                    For VOLR=Yes, allign the VOLSER variable on a    *\n*                    full-word boundary to eliminate allignament      *\n*                    warning assembly messages.                       *\n*                                                                     *\n*      35. VOLR    - VOLSER name to be returned and placed in the     *\n*                    variable specified for the 'VOLSER' parameter    *\n*                    after an 'Alloc' request without a VOLSER value. *\n*                    Set to either YES/NO ('NO' is the default).  If  *\n*                    'PARMT=DATA' is used, the VOLSER name is returned*\n*                    in the variable 'YVOLSER' which would have been  *\n*                    defined by the ADYN macro with 'PARMT=VAR'.      *\n*                                                                     *\n*   NOTES -                                                           *\n*      A) Macro format parameter of 'MF=.' Is mandatory.              *\n*         A macro with 'MF=L' is required in your program to generate *\n*         a register save area as registers R1,R4,R5,R6,R7,R14,R15 are*\n*         used in the program. All registers except R15 will be       *\n*         reset on return from the macro. R15 will contain the return *\n*         code from the 'DYNALLOC' routine.                           *\n*                                                                     *\n*      B) If parameter 'PARMT=DATA' is used:                          *\n*         Must issue an 'ADYN' macro with 'DATA=VARiable'. For re-    *\n*         entrant programs, suggest you initialise the data area in   *\n*         your DSECT by copying over it data initialised in your      *\n*         constant area from an 'ADYN' macro using 'DATA=CONstant'.   *\n*                                                                     *\n*      C) Must have 'DATA=IBM' to include the IBM DSECTs needed for   *\n*         SVC 99.                                                     *\n*                                                                     *\n*      D) Space requirements:                                         *\n*         Allow 300 bytes for SVC 99 parameter list, (ie. data area   *\n*         pointer to by the 'BASE' parameter).                        *\n*         Allow 123 bytes for both constant and variable data area    *\n*         created by the 'DATA=CON/VAR' parameter. Add 64 (16 x 4)    *\n*         bytes if this expansion stores the register save areas      *\n*         (refer to the MF parameter).                                *\n*                                                                     *\n*      E) On the EXEC form of the macro, R15 contains the return code *\n*         from the 'DYNALLOC' routine.  R0 contains the error code in *\n*         the high 2 order bytes and the information reason code in   *\n*         the low 2 order bytes.  All the other registers wiil be     *\n*         reset to their initial value on entering the macro.         *\n*         NOTE - Note the comment about register usage in this macro  *\n*                versus your program's register usage.                *\n*                                                                     *\n***********************************************************************\n.A$HELPE ANOP\n         LCLC  &#DISP,&#DISP1,&#DISP2,&#DISP3,&#ACTION,&#PRIM,&#SECOND\n         LCLC  &#RLSE,&#DSORG,&#BUFNO,&#DIRB,&#SPACET,&#DDC\n         LCLC  &#MEMBER,&#DD,&#DDR,&#DSN,&#RECFM,&#LRECL,&#BLKSZ\n         LCLC  &#UNIT,&#VOLSER,&#CLASS,&#WRTR,&#DEST,&#FCB,&#COPIES\n         LCLC  &@DSNR,&@DDR,&#DSNR,&#DSNV,&#REUSEF\n         LCLC  &#1,&#4,&#5,&#6,&#7\n         LCLC  &#PERMA,&#CHDISP\n         LCLC  &#VOLR,&#VOLV,&@VOLR,&VARNM\n         GBLC  &REGSMC1,&REGSMC2\n.*\n.*--------------------------------------------------------------------*\n.*\n         LCLC  &INDEX,&DELLAB\n.*\n         LCLA  &PL,&TUS\n.*--------------------------------------------------------------------*\n         GBLC  &REGSAVR,&REGSMCR\n         GBLB  &REGSFLG,&REGDFLG,&ADYNFL0,&ADYNFL1\n         AIF   (&REGSFLG).A$RS\n&REGSAVR SETC  'GB'.'&SYSNDX'.'#'\n&REGSMCR SETC  'ADYN'\n&REGSMC1 SETC  'ADYN'\n&REGSMC2 SETC  'ADYN'\n&REGSFLG SETB  1\n.A$RS    ANOP\n&#CHDISP SETC  'NO'\n         AIF   (&ADYNFL0).A$RT\n&ADYNFL0 SETB  1\n.*-------------- ADYN EQUATES FOR MEANINGFULL VALUES -----------------*\n$SHR     EQU X'08'\n$NEW     EQU X'04'\n$MOD     EQU X'02'\n$OLD     EQU X'01'\n$UNCATLG EQU X'01'\n$CATLG   EQU X'02'\n$DELETE  EQU X'04'\n$KEEP    EQU X'08'\n$FBA     EQU X'94'\n$VBA     EQU X'54'\n$FB      EQU X'90'\n$VB      EQU X'50'\n$U       EQU X'C0'\n$F       EQU X'80'\n$V       EQU X'40'\n$POU     EQU X'03'\n$PSU     EQU X'41'\n$DAU     EQU X'21'\n$PO      EQU X'02'\n$PS      EQU X'40'\n$DA      EQU X'20'\n.A$RT    ANOP\n.*--------------------------------------------------------------------*\n.*  INITIALISE SYSLIST TYPE VARIABLES                                 *\n.*--------------------------------------------------------------------*\n&#1      SETC  '&R1.'\n&#4      SETC  '&R4.'\n&#5      SETC  '&R5.'\n&#6      SETC  '&R6.'\n&#7      SETC  '&R7.'\n&#ACTION SETC  '&ACTION'\n&#DISP1  SETC  '&DISP(1)'\n&#DISP2  SETC  '&DISP(2)'\n&#DISP3  SETC  '&DISP(3)'\n         AIF   (T'&DISP EQ 'O').BYPDP3        BYPASS IF DISP OMITTED\n         AIF   ('&#DISP1'(1,1) NE 'N').BYPDP3 BYPASS IF DISP NOT 'NEW'\n         AIF   (T'&#DISP2 NE 'O').BYPDP2      BYP IF DISP2 PRESENT\n&#DISP2  SETC  'CATLG'\n.BYPDP2  ANOP\n         AIF   (T'&#DISP3 NE 'O').BYPDP3      BYP IF DISP3 PRESENT\n&#DISP3  SETC  'DELETE'\n.BYPDP3  ANOP\n&#SPACET SETC  '&SPACE(1)'\n&#PRIM   SETC  '&SPACE(2,1)'\n&#SECOND SETC  '&SPACE(2,2)'\n&#DIRB   SETC  '&SPACE(2,3)'\n&#CLASS  SETC  '&SYSOUT(1)'\n&#WRTR   SETC  '&SYSOUT(2)'\n&#RLSE   SETC  '&SPACE(3)'\n         AIF (T'&#RLSE EQ 'O').TPARMT1     BYPASS IF NO 'RLSE' PARM\n&#RLSE   SETC '&#RLSE'(1,1)                EXTRACT 1ST. CHAR\n.TPARMT1 ANOP\n         AIF ('&PARMT'(1,1) EQ 'P').GRELSE IF NON-VAR RLSE IN SPACE\n         AIF (T'&#RLSE NE 'YES').GRELSE    BYPASS IF 'RLSE=YES' NOT REQ\n&#RLSE   SETC  'R'                         SET 'RLSE' PARM\n.GRELSE  ANOP\n&#DSORG  SETC  '&DSORG'                    SET 'DSORG' WORK PARM\n         AIF (T'&#DSORG NE 'O').DSORGE     IF DSORG PARM SUPPLIED BYP\n         AIF (T'&#SPACET EQ 'O').DSORGE    IF NO SPACE TYPE BYPASS\n         AIF (T'&#DIRB EQ 'O').DSORGPS     IF DIRB NOT SUPPLIED PS ORG\n&#DSORG  SETC  'PO'\n         AGO .DSORGE\n.DSORGPS ANOP\n&#DSORG  SETC  'PS'\n.DSORGE  ANOP\n.*-------------------------------------------------------------------*\n.*     INITIALISE VARIABLES SO THEY MAY BE MANIPULATED               *\n.*-------------------------------------------------------------------*\n&#DD     SETC '&DD'\n&#DDC    SETC '&DDC'\n&#DDR    SETC '&DDR'\n&#DSNR   SETC '&DSNR'\n&#DSN    SETC '&DSN'\n&#MEMBER SETC '&MEMBER'\n&#VOLSER SETC '&VOLSER'\n&#VOLR   SETC '&VOLR'\n&#UNIT   SETC '&UNIT'\n&#DEST   SETC '&DEST'\n&#FCB    SETC '&FCB'\n&#COPIES SETC '&COPIES'\n&#BUFNO  SETC '&BUFNO'\n&#RECFM  SETC '&RECFM'\n&#LRECL  SETC '&LRECL'\n&#BLKSZ  SETC '&BLKSIZE'\n.*--------------------------------------------------------------------*\n         AIF  (T'&DATA NE 'O').DATAMAP   GO PROCESS DATA TYPE\n         AIF  ('&MF' EQ 'L').MFELIST     GO PROCESS LIST FORM\n.*--------------------------------------------------------------------*\n.MFEEXEC ANOP\n.*--------------------------------------------------------------------*\n&#PERMA  SETC '&PERMA'\n         AIF ('&#ACTION'(1,1) NE 'A').BPREAL1  NOT REALLOC BYPASS'\n         AIF ('&REUSE'(1,1) NE 'Y').BPREAL1    REUSE NOT REQUIRED\n         AIF ('&#REUSEF' EQ 'Y').BPREAL1       REUSE RESET BYPASS\n&#ACTION SETC 'FREE'\n         AGO .ISFREE1                          GO FREE IT\n.*--------------------------------------------------------------------*\n.BPREAL1 ANOP\n         AIF ('&#ACTION'(1,1) EQ 'U').ISFREE1  PROCESS 'UNALLOC'\n         AIF ('&#ACTION'(1,1) NE 'F').TSTINF1 BYPASS IF NOT 'FREE'\n.ISFREE1 ANOP     ENSURE ALL APPROPRIATE FIELDS ARE BLANK FOR FREE\n         AIF (T'&#DD EQ 'O').LVFREE  BYPASS IF DD NOT SUPPLIED\n&#DSN    SETC ''\n&#DSNR   SETC 'NO'\n&#MEMBER SETC ''\n.LVFREE  ANOP\n.* &#DD     SETC ''\n.* &#DDR    SETC 'NO'\n.* &#DSNR   SETC 'NO'\n.* &#DSN    SETC ''\n.* &#MEMBER SETC ''\n&#DISP1  SETC ''\n&#DISP2  SETC ''\n&#DISP3  SETC ''\n&#SPACET SETC ''\n&#PRIM   SETC ''\n&#SECOND SETC ''\n&#DIRB   SETC ''\n&#RLSE   SETC ''\n&#UNIT   SETC ''\n&#VOLSER SETC ''\n&#VOLR   SETC 'NO'\n&#RECFM  SETC ''\n&#LRECL  SETC ''\n&#BLKSZ  SETC ''\n&#BUFNO  SETC ''\n&#DSORG  SETC ''\n&#CLASS  SETC ''\n&#DEST   SETC ''\n&#FCB    SETC ''\n&#COPIES SETC ''\n&#WRTR   SETC ''\n&#PERMA  SETC 'NO'\n         AGO .NOTDELT\n.*--------------------------------------------------------------------*\n.TSTINF1 ANOP\n         AIF ('&#ACTION'(1,1) NE 'I').TSTCON1 BYPASS IF NOT 'INFO'\n.* &#DD     SETC ''\n.* &#DDR    SETC 'NO'\n.* &#DSNR   SETC 'NO'\n.* &#VOLR   SETC 'NO'\n&#ACTION SETC 'INFO'\n&#DSN    SETC '&DSN'\n&#MEMBER SETC ''\n&#DISP1  SETC ''\n&#DISP2  SETC ''\n&#DISP3  SETC ''\n&#SPACET SETC ''\n&#PRIM   SETC ''\n&#SECOND SETC ''\n&#DIRB   SETC ''\n&#RLSE   SETC ''\n&#UNIT   SETC ''\n&#VOLSER SETC ''\n&#RECFM  SETC ''\n&#LRECL  SETC ''\n&#BLKSZ  SETC ''\n&#BUFNO  SETC ''\n&#DSORG  SETC ''\n&#CLASS  SETC ''\n&#DEST   SETC ''\n&#FCB    SETC ''\n&#COPIES SETC ''\n&#WRTR   SETC ''\n&#PERMA  SETC 'NO'\n         AGO .NOTDELT\n.*--------------------------------------------------------------------*\n.TSTCON1 ANOP\n         AIF ('&#ACTION'(1,1) NE 'C').TSTDEC1 BYPASS IF NOT 'CONCAT'\n&#ACTION SETC 'CONCAT'\n&#DDC    SETC '&DDC'\n&#DSN    SETC ''\n&#MEMBER SETC ''\n&#DISP1  SETC ''\n&#DISP2  SETC ''\n&#DISP3  SETC ''\n&#SPACET SETC ''\n&#PRIM   SETC ''\n&#SECOND SETC ''\n&#DIRB   SETC ''\n&#RLSE   SETC ''\n&#UNIT   SETC ''\n&#VOLSER SETC ''\n&#RECFM  SETC ''\n&#LRECL  SETC ''\n&#BLKSZ  SETC ''\n&#BUFNO  SETC ''\n&#DSORG  SETC ''\n&#CLASS  SETC ''\n&#DEST   SETC ''\n&#FCB    SETC ''\n&#COPIES SETC ''\n&#WRTR   SETC ''\n&#PERMA  SETC 'NO'\n         AGO .NOTDELT\n.*--------------------------------------------------------------------*\n.TSTDEC1 ANOP\n         AIF ('&#ACTION'(1,3) NE 'DEC').TSTDLT1 BYP IF NOT 'DECONCAT'\n&#ACTION SETC 'DECONCAT'\n&#DDC    SETC '&DDC'\n&#DSN    SETC ''\n&#MEMBER SETC ''\n&#DISP1  SETC ''\n&#DISP2  SETC ''\n&#DISP3  SETC ''\n&#SPACET SETC ''\n&#PRIM   SETC ''\n&#SECOND SETC ''\n&#DIRB   SETC ''\n&#RLSE   SETC ''\n&#UNIT   SETC ''\n&#VOLSER SETC ''\n&#RECFM  SETC ''\n&#LRECL  SETC ''\n&#BLKSZ  SETC ''\n&#BUFNO  SETC ''\n&#DSORG  SETC ''\n&#CLASS  SETC ''\n&#DEST   SETC ''\n&#FCB    SETC ''\n&#COPIES SETC ''\n&#WRTR   SETC ''\n&#PERMA  SETC 'NO'\n         AGO .NOTDELT\n.*--------------------------------------------------------------------*\n.TSTDLT1 ANOP\n         AIF ('&#ACTION'(1,3) NE 'DEL').NOTDELT  BYP IF NOT 'DELETE'\n*---------------------------------------------------------------------*\n*  FOR 'DELETE', ALLOCATING DATASET WITH A STATUS OF:                 *\n*     DISP=(OLD,DELETE,DELETE)                                        *\n*---------------------------------------------------------------------*\n&#ACTION SETC 'ALLOC'\n&#DISP1  SETC 'OLD'\n&#DISP2  SETC 'DELETE'\n&#DISP3  SETC 'DELETE'\n&#MEMBER SETC ''\n&#VOLSER SETC ''\n&#DEST   SETC ''\n&#FCB    SETC ''\n&#COPIES SETC ''\n&#SPACET SETC ''\n&#PRIM   SETC ''\n&#SECOND SETC ''\n&#DIRB   SETC ''\n&#BUFNO  SETC ''\n&#UNIT   SETC ''\n&#RECFM  SETC ''\n&#LRECL  SETC ''\n&#BLKSZ  SETC ''\n&#PERMA  SETC ''\n&#PERMA  SETC 'NO'\n.NOTDELT ANOP\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.*    EXEC FORM OF MACRO\n.*--------------------------------------------------------------------*\n         AIF   ('&REGR' EQ 'NO').NORSAV1 BYPASS IF REGS NOT 2 BE REST'D\n         STM   R0,R14,&REGSAVR      SAVE REGISTERS\n.NORSAV1 ANOP\n         AIF   (T'&BASE EQ 'O').NOBASE   BYPASS IF NO 'BASE' PASSED\n         USING S99RBP,&BASE         ESTABLISH ADDRESABILITY\n.NOBASE  ANOP\n         LA    &#4,S99RBPTR+4       POINT PAST RBPTR\n         USING S99RB,&#4            EST ADDRESABILITY FOR \"RB\" DSECT\n         ST    &#4,S99RBPTR         MAKE \"RBPTR\" TO \"RB\"\n         OI    S99RBPTR,S99RBPND    TURN ON HIGH ORDER BIT OF \"RBPTR\"\n         XC    S99RB(S99RBEND-S99RB),S99RB INITIALISE \"RB\" ENTIRELY\n         MVI   S99RBLN,S99RBEND-S99RB      PUT LEN OF \"RB\" IN ITS FLD\n         LA    &#5,S99RB+(S99RBEND-S99RB)  POINT 20 BYTES PAST 'RB'\n         USING S99TUPL,&#5          EST ADDRESABILITY TO TEXT UNIT PTRS\n         ST    &#5,S99TXTPP         INIT TEXT POINTER IN 'RB'\n.*--------------------------------------------------------------------*\n.*    TEST ACTION AND SET VERB ACCORDINGLY                            *\n.*--------------------------------------------------------------------*\n&DELLAB  SETC  'AY'.'&SYSNDX'.'E'   SET LABEL FOR DELETE ERROR BYPASS\n&TUS     SETA  0                    SET UNALLOCATE # TEXT UNITS\n         AIF ('&#ACTION'(1,1) NE 'A').A1DD\n         MVI   S99VERB,S99VRBAL     SET VERB FOR INFO ALLOCATION\n         AIF ('&#DDR'(1,1) EQ 'Y').A1DDR\n         LA    &#7,DALDDNAM         SET KEY FOR DDNAME SPECIFICATION\n         AGO   .A1DD\n.A1DDR   ANOP\n         LA    &#7,DALRTDDN         SET KEY FOR DDNAME RETURN\n         AIF ('&#ACTION'(1,1) EQ 'A').A1DDR1 BYPASS IF ACTION ADD\n         MNOTE 12,'DD NAME RETURN ONLY APPLICABLE TO ALLOCATIONS.'\n         AGO .MEXIT\n.A1DDR1  ANOP\n         AIF (T'&#DD NE 'O').A1DD   BYPASS IF DD SPECIFIED\n         AIF ('&PARMT'(1,1) EQ 'D').A1DD\n         MNOTE 12,'DD NAME RETURN MUST SPECIFY VARIABLE FOR PARMT=PARM'\n         AGO .MEXIT\n.A1DD    ANOP\n         AIF ('&#DDR'(1,1) EQ 'Y').A1DDFC DD RETURN REQUESTED\n         AIF (T'&#DD EQ 'O').A1DSNR1\n.A1DDFC  ANOP\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR DDNAME                                             *\n.A1DSNR1 ANOP\n         AIF ('&#ACTION'(1,1) EQ 'C').CONC11\n         AIF ('&#ACTION'(1,1) EQ 'F').A1DSN\n         AIF ('&#ACTION'(1,1) EQ 'D').A1DSN\n         AIF ('&#ACTION'(1,1) EQ 'U').A1DSN\n         AIF (T'&#DSN NE 'O').A1DSN  BYPASS IF DSNAME SPECIFIED\n         AIF (T'&SYSOUT NE 'O').A1DSN  BYPASS IF SYSOUT SPECIFIED\n         AIF ('&PARMT'(1,1) EQ 'D').A1DSN\n         MNOTE 12,'DSNAME RETURN MUST SPECIFY VARIABLE FOR PARMT=PARM'\n         AGO .MEXIT\n.A1DSN   ANOP\n         AIF ('&#DSNR'(1,1) EQ 'Y').A1DSNFC DSN RETURN REQUESTED\n         AIF (T'&#DSN EQ 'O').A1DISP1\n.A1DSNFC ANOP\n&TUS     SETA  &TUS+1\n*  1 TEXT UNIT FOR DSNAME                                             *\n         AIF ('&#ACTION'(1,1) EQ 'I').INFO11\n.A1DISP1 ANOP\n         AIF (T'&#DISP1 NE 'O').A1DIS11       PROCESS IF NOT OMITTED\n         AIF ('&#ACTION'(1,1) NE 'A').A1MEMBR BYPASS IF NOT ALLOCATE\n         AIF (T'&#CLASS NE 'O').A1MEMBR       BYPASS IF SYSOUT CLASS\n&#DISP1  SETC 'OLD'                           SET STATUS AS OLD\n*        DEFAULT STATUS OF 'OLD' ASSIGNED                             *\n.A1DIS11 ANOP\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR STATUS                                             *\n.A1MEMBR ANOP\n         AIF (T'&#MEMBER EQ 'O').A1VOLS\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR MEMBER                                             *\n.A1VOLS  ANOP\n         AIF ('&#VOLR'(1,1) EQ 'Y').A1VOLSR\n         AIF (T'&#VOLSER EQ 'O').A1DEST\n.A1VOLSR ANOP\n         AIF ('&PARMT'(1,1) EQ 'D').A1VOLS1\n         AIF (T'&#VOLSER NE 'O').A1VOLS1\n         MNOTE 12,'VOLSER RETURN MUST SPECIFY VARIABLE FOR PARMT=PARM'\n         AGO .MEXIT\n.A1VOLS1 ANOP\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR VOLSER                                             *\n.A1DEST  ANOP\n         AIF (T'&#DEST EQ 'O').A1FCB\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR SYSOUT DESTINATION                                 *\n.A1FCB   ANOP\n         AIF (T'&#FCB EQ 'O').A1COPYS\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR FCB                                                *\n.A1COPYS ANOP\n         AIF (T'&#COPIES EQ 'O').A1T1\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR COPIES                                             *\n.A1T1    ANOP\n         AIF (T'&#DISP2 EQ 'O').A1DISP3\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR NORMAL DISPOSITION                                 *\n.A1DISP3 ANOP\n         AIF (T'&#DISP3 EQ 'O').A1BLK\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR CONDITIONAL/ABNORMAL TERMINATION                   *\n.A1BLK   ANOP\n         AIF (T'&#BLKSZ EQ 'O').A1LREC\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR BLKSIZE                                            *\n.A1LREC  ANOP\n         AIF (T'&#LRECL EQ 'O').A1RECFM\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR LRECL                                              *\n.A1RECFM ANOP\n         AIF (T'&#RECFM EQ 'O').A1DSORG\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR RECFM                                              *\n.A1DSORG ANOP\n         AIF (T'&#DSORG EQ 'O').A1SPACE\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR DSORG                                              *\n.A1SPACE ANOP\n         AIF (T'&#SPACET EQ 'O').A1PRIM\n&TUS     SETA  &TUS+2               SET UNALLOCATE # TEXT UNITS\n*  2 TEXT UNIT FOR ALLOCATION UNITS (CYL, TRK or block size)          *\n.A1PRIM  ANOP\n         AIF (T'&#PRIM EQ 'O').A1SECON\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR PRIMARY ALLOCATION                                 *\n.A1SECON ANOP\n         AIF (T'&#SECOND EQ 'O').A1DIRB\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR SECONDARY ALLOCATION                               *\n.A1DIRB  ANOP\n         AIF ('&#PERMA'(1,1) NE 'Y').A1PERMA\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR PERMANENT ALLOCATE ATTRIBUTE                       *\n.A1PERMA ANOP\n         AIF (T'&#DIRB EQ 'O').A1BUFNO\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR DIRECTORY BLOCKS                                   *\n.A1BUFNO ANOP\n         AIF (T'&#BUFNO EQ 'O').A1UNIT\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR BUFFER COUNT/DCB                                   *\n.A1UNIT  ANOP\n         AIF (T'&#UNIT NE 'O').A1UNI11   PROCESS IF NOT OMITTED\n         AIF ('&#DISP1' NE 'NEW').A1WRTR BYPASS IF OMMITED AND NOT NEW\n&#UNIT   SETC 'SYSALLDA'                 SET UNIT AS 'SYSALLDA'\n*        DEFAULT DEVICE UNIT OF 'SYSALLDA' ASSIGNED                   *\n.A1UNI11 ANOP\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR DEVICE UNIT                                        *\n.A1WRTR  ANOP\n         AIF (T'&#WRTR EQ 'O').A1CLASS\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR SYSOUT WRITER-NAME/INTERNAL-READER                 *\n.A1CLASS ANOP\n         AIF (T'&#CLASS EQ 'O').A1RLSE\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR SYSOUT CLASS                                       *\n.A1RLSE  ANOP\n         AIF (T'&#RLSE EQ 'O').A1UCLOS\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR RLSE\n.A1UCLOS ANOP\n         AIF ('&#ACTION'(1,1) NE 'A').A$OPTE  BYPASS IF NOT 'ALLOACTE'\n         AIF ('&UCLOSE' NE 'YES').A$OPTE\n&TUS     SETA  &TUS+1               INCREMENT TEXT UNITS\n*  1 TEXT UNIT FOR UCLOSE                                             *\n.A$OPTE  ANOP\n         AIF ('&#ACTION'(1,1) EQ 'A').CON#000\n.UNAL1   ANOP\n         AIF ('&#ACTION'(1,1) EQ 'U').UNAL11\n         AIF ('&#ACTION'(1,1) NE 'F').INFO1\n.UNAL11  ANOP\n         MVI   S99VERB,S99VRBUN     SET VERB FOR UNALLOCATION\n         LA    &#7,DUNDDNAM         GET THE KEY FOR DDNAME\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR REMOVE 'IN-USE' ATTRIBUTE (UNALLOCATE)             *\n.*  1 TEXT UNIT FOR UNALLOCATE ATTRIBUTE\n         AGO .CON#000\n.INFO1   ANOP\n         AIF ('&#ACTION'(1,1) NE 'I').CONC1\n.INFO11  ANOP\n         MVI   S99VERB,S99VRBIN     SET VERB FOR INFO RETRIEVAL\n         LA    &#7,DINDDNAM         GET THE KEY FOR DDNAME\n         AIF ('&PARMT'(1,1) EQ 'P').CON#000\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR DSNAME RETURN                                      *\n         AGO .CON#000\n.CONC1   ANOP\n         AIF ('&#ACTION'(1,1) NE 'C').DEAL1\n         AIF (T'&#DDC NE 'O').CONC11\n         MNOTE 12,'CONCATENATION MUST HAVE A \"DDC\" PARAMETER.'\n         AGO .MEXIT\n.CONC11  ANOP\n         MVI   S99VERB,S99VRBCC     SET VERB FOR INFO CONCATENATE\n         LA    &#7,DCCDDNAM         GET THE KEY FOR DDNAME\n         AIF ('&CCP'(1,1) EQ 'N').CON#000\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n*  1 TEXT UNIT FOR PERMANENT CONCATENATION\n         AGO .CON#000\n.DEAL1   ANOP\n         AIF ('&#ACTION'(1,3) NE 'DEC').CON#000\n         AIF (T'&#DDC NE 'O').DEAL11\n         MNOTE 12,'DECONCATENATION MUST HAVE A \"DDC\" PARAMETER.'\n         AGO .MEXIT\n.DEAL11  ANOP\n&TUS     SETA  &TUS+1               SET UNALLOCATE # TEXT UNITS\n         MVI   S99VERB,S99VRBDC     SET VERB FOR INFO DECONCATENATE\n         LA    &#7,DDCDDNAM         GET THE KEY FOR DDNAME\n.CON#000 ANOP\n         LA    &#6,S99TUPL+(&TUS*4) POINT JUST PAST THE TEXT UNIT PTRS\n         USING S99TUNIT,&#6         ADDRESABILITY FOR 1ST TEXT UNIT\n&TUS     SETA  0                    SET TEXT UNITS PTR INCREMENT\n.*-------------------------------------------------------------------*\n.A2DDC   ANOP\n         AIF ('&#ACTION'(1,1) NE 'C').A2DEC\n*--------------------------------------------------------------------*\n*   ADYN-SET UP DDNAME TO CONCATENATE                                *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT\n         ST    &#6,S99TUPTR         POINT 1ST TXT UNIT PTR TO 1ST TXT U\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,2                BECAUSE THE DSNAME KEY REQUIRES 2\n         STH   &#7,S99TUNUM           PARM, STORE 2 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2DDC#\n         LA    &#7,8                MAXIMUM LENGTH OF DATASET\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         STH   &#7,S99TULNG+10      STORE TEXT UNIT LENGTH TO CONCAT\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99DDN          MOVE DDNAME\n         EX    &#7,MV99DDCN         MOVE DDNAME TO CONCATENATE\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         AIF ('&CCP'(1,1) EQ 'N').A$END\n         LA    &#6,4(&#6)           POINT PAST KEY, # (NOT LENGTH)\n         LA    &#7,3(&#7)           BACK TO NORMAL LENGTH + LENGTH FLD\n         AR    &#6,&#7              POINT PAST DDNAME\n         AR    &#6,&#7              POINT PAST DDNAME CONCATENATION\n         AGO   .A2DDC#0             EXIT PROCESS\n.A2DDC#  ANOP\n&PL      SETA  K'&#DD\n&PLC     SETA  K'&#DDC\n         LA    &#7,&PL              LENGTH OF DDNAME\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#7,&PLC             LENGTH OF CONCAT DDNAME\n         STH   &#7,S99TULNG+&PL+2   STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&#DD' MOVE DDNAME\n         MVC   S99TUPAR+&PL+2(&PLC),=C'&#DDC' MOVE DDNAME TO CONCAT\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         AIF ('&CCP'(1,1) EQ 'N').A$END\n         LA    &#6,4(&#6)           POINT PAST KEY, # (NOT LENGTH)\n         LA    &#7,&PL+2            LENGTH OF DDNAME + LENGTH FIELD\n         LA    &#7,&PLC+2(&#7)      LENGTH OF DDNAME + LENGTH FIELD\n         AR    &#6,&#7              POINT PAST DSNAME\n.A2DDC#0 ANOP\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DCCPERMC         GET THE KEY FOR PERMANENT CONCAT\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,0                BECAUSE THE PERMCON KEY REQUIRES 0\n         STH   &#7,S99TUNUM           PARM, STORE 0 IN NUMBER FIELD\n         AGO   .A$END\n.*-------------------------------------------------------------------*\n.A2DEC   ANOP\n         AIF ('&#ACTION'(1,3) NE 'DEC').A2DD\n*--------------------------------------------------------------------*\n*   ADYN-SET UP DDNAME TO DECONCATENATE                              *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT\n         ST    &#6,S99TUPTR         POINT 1ST TXT UNIT PTR TO 1ST TXT U\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2DEC#\n         LA    &#7,8                MAXIMUM LENGTH OF DATASET\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99DDCN         MOVE DDNAME TO DECONCATENATE\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         AGO   .A2DEC#0             EXIT PROCESS\n.A2DEC#  ANOP\n&PLC     SETA  K'&#DDC\n         LA    &#7,&PLC             LENGTH OF CONCAT DDNAME\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PLC),=C'&#DDC' MOVE DDNAME TO DECONCATENATE\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n.A2DEC#0 ANOP\n         AGO   .A$END\n.*-------------------------------------------------------------------*\n.A2DD    ANOP\n&@DDR    SETC  ''\n         AIF ('&#DDR'(1,1) EQ 'Y').A2DDRIY\n         AIF (T'&#DD  EQ 'O').A2DSN\n         AGO   .A2DDACT\n.A2DDRIY ANOP\n         AIF ('&PARMT'(1,1) EQ 'P').A2DDRIP\n&@DDR    SETC  'YDD'\n         AGO   .A2DDACT\n.A2DDRIP ANOP\n&@DDR    SETC  '&#DD'\n.A2DDACT ANOP\n*--------------------------------------------------------------------*\n*   ADYN-SET UP DDNAME                                               *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT\n         ST    &#6,S99TUPTR         POINT 1ST TXT UNIT PTR TO 1ST TXT U\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         LA    &#7,8                MAXIMUM LENGTH OF DATASET\n         AIF ('&#DDR'(1,1) EQ 'Y').A2DDR0 IF DD RETURN REQ'D BYPASS\n         AIF ('&PARMT'(1,1) EQ 'P').A2DD#\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99DDN          MOVE DDNAME\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AGO   .A2DDR1\n.A2DDR0  ANOP\n         LA    &#1,S99TUPAR         LOAD DDNAME VARIABLE ADDRESS\n&VARNM   SETC  '&#DD'               SET VARIABLE NAME\n         AIF ('&#DD'(1,1) NE '(').NDDVAR1\n&PL      SETA  K'&#DD\n&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME\n.NDDVAR1 ANOP\n         ST    &#1,&VARNM           SAVE FOR LATER USE\n.A2DDR1  ANOP\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST DSNAME\n         AGO   .A2DD#0              EXIT PROCESS\n.A2DD#   ANOP\n&PL      SETA  K'&#DD\n         AIF ('&#DD'(1,1) NE '(').NDDVAR2\n&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME\n         MVC   S99TUPAR(L'&VARNM),&VARNM  MOVE VARIABLE NAME\n         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME\n         AGO   .A2DD#0  ANOP\n.NDDVAR2 ANOP\n         LA    &#7,&PL              MAXIMUM LENGTH OF DATASET\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&#DD'\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST DDNAME\n.A2DD#0  ANOP\n*--------------------------------------------------------------------*\n*   ADYN-SET UP DSNAME                                               *\n*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.A2DSN   ANOP\n         AIF ('&#ACTION'(1,1) EQ 'I').INFO2\n         AIF ('&#DSN' EQ 'DUMMY').A2DUMMY\n         AIF ('&#DSN' EQ '*').A2TERML\n&@DSNR   SETC  ''\n&#DSNV   SETC  'DALDSNAM'\n         AIF ('&#DSNR'(1,1) EQ 'Y').A2DSRIY\n         AIF (T'&#DSN EQ 'O').A2MEMBR\n         AGO  .A2DSACT\n.A2DSRIY ANOP\n&#DSNV   SETC  'DALRTDSN'\n&#DISP2  SETC  'DELETE'\n&#DISP3  SETC  'DELETE'\n         AIF ('&PARMT'(1,1) EQ 'P').A2DSRIP\n&@DSNR   SETC  'YDSN'\n         AGO   .A2DSACT\n.A2DSRIP ANOP\n&@DSNR   SETC  '&#DSN'\n.A2DSACT ANOP\n.*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,&#DSNV           GET THE KEY FOR DSNAME\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         LA    &#7,44               MAXIMUM LENGTH OF DATASET NAME\n         AIF ('&#DSNR'(1,1) EQ 'Y').A2DSNR0 IF DSN RETURN REQ'D BYPASS\n         AIF ('&PARMT'(1,1) EQ 'P').A2DSN#\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99DSN          MOVE DSNAME\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AGO   .A2DSNR1\n.A2DSNR0 ANOP\n         LA    &#1,S99TUPAR         LOAD DSNAME VARIABLE ADDRESS\n&VARNM   SETC  '&#DSN'              SET VARIABLE NAME\n         AIF (T'&#DSN EQ 'O').NDSNVA1\n         AIF ('&#DSN'(1,1) NE '(').NDSNVA1\n&PL      SETA  K'&#DSN\n&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME\n.NDSNVA1 ANOP\n.*       ST    &#1,&VARNM           SAVE FOR LATER USE\n         ST    &#1,&@DSNR           SAVE FOR LATER USE\n.A2DSNR1 ANOP\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST DSNAME\n         AGO   .A2DSN#0             EXIT PROCESS\n.A2DSN#  ANOP\n&PL      SETA  K'&#DSN\n         AIF ('&#DSN'(1,1) NE '(').NDSNVA2\n&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME\n         MVC   S99TUPAR(L'&VARNM),&VARNM     MOVE VARIABLE NAME\n         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME\n         AGO   .A2DSN#0             EXIT PROCESS\n.NDSNVA2 ANOP\n         MVC   S99TUPAR(&PL),=C'&#DSN'\n         LA    &#7,&PL              LENGTH OF DATASET\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST DSNAME\n.A2DSN#0 ANOP\n         AGO   .A2MEMBR\n.*--------------------------------------------------------------------*\n.A2DUMMY ANOP\n*--------------------------------------------------------------------*\n*   ADYN-SET UP DUMMY DSNAME                                         *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n&TUS     SETA  4                    SET TEXT UNITS PTR INCREMENT\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALDUMMY         GET THE KEY FOR DUMMY DSNAME\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n         AGO   .A2MEMBR\n.A2TERML ANOP\n*--------------------------------------------------------------------*\n*   ADYN-OUTPUT TO A TERMINAL FOR ON-LINE SESSIONS                   *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALTERM          GET KEY FOR TERMINAL OUTPUT\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n         AGO   .A2MEMBR\n.A2MEMBR ANOP\n         AIF (T'&#MEMBER EQ 'O').A2VOLS\n*--------------------------------------------------------------------*\n*   ADYN-SET UP MEMBER                                               *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALMEMBR         GET THE KEY FOR DSNAME\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2MEM#\n         LA    &#7,8                MAXIMUM LENGTH OF MEMBER NAME\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99MEMB         MOVE MEMBER\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AR    &#6,&#7              POINT PAST DSNAME\n         AGO   .A2VOLS\n.A2MEM#  ANOP\n&PL      SETA  K'&MEMBER\n         AIF ('&MEMBER'(1,1) NE '(').NMEMVAR\n&VARNM   SETC  '&MEMBER'(2,&PL-2)   SET VARIABLE NAME\n         MVC   S99TUPAR(L'&VARNM),&VARNM     MOVE VARIABLE NAME\n         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME\n         AGO   .A2VOLS              EXIT PROCESS\n.NMEMVAR ANOP\n&PL      SETA  K'&MEMBER\n         LA    &#7,&PL              MAXIMUM LENGTH OF MEMBER NAME\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&MEMBER'\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST DSNAME\n.A2VOLS  ANOP\n         AIF ('&#VOLR'(1,1) EQ 'Y').A2VOLSF\n         AIF (T'&#VOLSER EQ 'O').A2DEST\n*--------------------------------------------------------------------*\n*   ADYN-SET UP VOLSER                                               *\n*--------------------------------------------------------------------*\n.A2VOLSF ANOP\n&@VOLR   SETC  ''\n&#VOLV   SETC  'DALVLSER'\n         AIF ('&#VOLR'(1,1) NE 'Y').A2VOACT\n&#VOLV   SETC  'DALRTVOL'\n.A2VORIY ANOP\n         AIF ('&PARMT'(1,1) EQ 'P').A2VORIP\n&@VOLR   SETC  'YVOLSER'\n         AGO   .A2VOACT\n.A2VORIP ANOP\n&@VOLR   SETC  '&#VOL'\n.A2VOACT ANOP\n.*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,&#VOLV           GET THE KEY FOR VOLSER\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         LA    &#7,6                MAXIMUM LENGTH OF DATASET NAME\n         AIF ('&#DSNR'(1,1) EQ 'Y').A2VOLR0 IF VOL RETURN REQ'D BYPASS\n         AIF ('&PARMT'(1,1) EQ 'P').A2VOL#\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99VOLS         MOVE VOLSER\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AGO   .A2VOLR1\n.A2VOLR0 ANOP\n         LA    &#1,S99TUPAR         LOAD VOLSER VARIABLE ADDRESS\n&VARNM   SETC  '&#VOLSER'           SET VARIABLE NAME\n         AIF (T'&#VOLSER EQ 'O').NVOLVA1\n         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA1\n&PL      SETA  K'&#VOLSER\n&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME\n.NVOLVA1 ANOP\n         ST    &#1,&@VOLR           SAVE FOR LATER USE\n.A2VOLR1 ANOP\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST DSNAME\n         AGO   .A2VOL#0             EXIT PROCESS\n.A2VOL#  ANOP\n&PL      SETA  K'&#VOLSER\n         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA2\n&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME\n         MVC   S99TUPAR(L'&VARNM),&VARNM     MOVE VARIABLE NAME\n         LA    &#7,L'&VARNM         MAXIMUM LENGTH OF VARIABLE\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,L'&VARNM.(&#6)   POINT PAST DSNAME\n         AGO   .A2VOL#0             EXIT PROCESS\n.NVOLVA2 ANOP\n         LA    &#7,&PL              MAXIMUM LENGTH OF VOLSER\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&#VOLSER'\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST DSNAME\n.A2VOL#0 ANOP\n.*--------------------------------------------------------------------*\n.A2DEST  ANOP\n         AIF (T'&#DEST EQ 'O').A2FCB\n*--------------------------------------------------------------------*\n*   ADYN-SET UP PRINTER DESTINATION                                  *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALSUSER         GET THE KEY FOR DESTINATION\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2DEST#\n         LA    &#7,8                LENGTH OF DESTINATION\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99DEST         MOVE DESTINATION\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AR    &#6,&#7              POINT PAST DSNAME\n         AGO   .A2FCB\n.A2DEST# ANOP\n&PL      SETA  K'&DEST\n         LA    &#7,&PL              LENGTH OF VOLOSER\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&DEST' MOVE PRINTER-ID\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST DSNAME\n.A2FCB   ANOP\n         AIF (T'&#FCB EQ 'O').A2COPY\n*--------------------------------------------------------------------*\n*   ADYN-SET UP FCB                                                  *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALFCBIM         GET THE KEY FOR FCB\n         STH   &#7,S99TUKEY         PUT KEY IN TEXT UNIT KEY FLD\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2FCB#\n         LA    &#7,4                LENGTH OF FCB\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99FCB          MOVE FCB\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AR    &#6,&#7              POINT PAST DSNAME\n         AGO   .A2DISP\n.A2FCB#  ANOP\n&PL      SETA  K'&FCB\n         LA    &#7,&PL              LENGTH OF VOLOSER\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&FCB' MOVE FCB\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST DSNAME\n.A2COPY  ANOP\n         AIF (T'&#COPIES EQ 'O').A2DISP\n*--------------------------------------------------------------------*\n*   ADYN-SET UP COPIES                                               *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALCOPYS         GET KEY FOR # OF COPIES\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE COPYS KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2CPY#\n         MVC   S99TUPAR(1),YCOPIES  SET # OF COPIES\n         AGO .A2CPY#0\n.A2CPY#  ANOP\n         MVC   S99TUPAR(1),=AL1(&COPIES) SET # OF COPIES\n.A2CPY#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2DISP  ANOP\n         AIF (T'&#DISP1 EQ 'O').A2DISP2\n*--------------------------------------------------------------------*\n*   ADYN-DATASET STATUS DESIRED                                      *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALSTATS         GET KEY FOR STATUS SPECIFICATIONS\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2DIS#\n         MVC   S99TUPAR(1),YDISP       SET DISPOSITION\n         AGO  .A2DIS#0\n.A2DIS#  ANOP\n         MVI   S99TUPAR,$&#DISP1    SET DISPOSITION\n.A2DIS#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2DISP2 ANOP\n         AIF (T'&#DISP2 EQ 'O').A2DISP3\n*--------------------------------------------------------------------*\n*   ADYN-DATASET DISPOSITION ON NORMAL COMPLETION                    *\n         AIF ('&#CHDISP' EQ 'NO').A2DCM12\n         AIF ('&#CHDISP' EQ 'YES').A2DCM11\n         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN CATALOGUED.'\n         AGO   .A2DCM12  ANOP\n.A2DCM11  ANOP\n         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN FORCED TO ''DELETE'''\n.A2DCM12  ANOP\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALNDISP         GET KEY FOR NORMAL DISPOSITION\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2NDS#\n         MVC   S99TUPAR(1),YNDISP   SET DISPOSITION\n         AGO .A2NDS#0\n.A2NDS#  ANOP\n         MVI   S99TUPAR,$&#DISP2    SET DISPOSITION\n.A2NDS#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2DISP3 ANOP\n         AIF (T'&#DISP3 EQ 'O').A2RECFM\n*--------------------------------------------------------------------*\n*   ADYN-DATASET DISPOSITION ON ABNORMAL COMPLETION                  *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALCDISP         GET KEY FOR CONDITIONAL DISPOSITION\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2CDS#\n         MVC   S99TUPAR(1),YCDISP   SET DISPOSITION\n         AGO .A2CDS#0\n.A2CDS#  ANOP\n         MVI   S99TUPAR,$&#DISP3    SET DISPOSITION\n.A2CDS#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2RECFM ANOP\n         AIF (T'&#RECFM EQ 'O').A2DSORG\n*--------------------------------------------------------------------*\n*   ADYN-RECORD FORMAT                                               *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALRECFM         GET KEY FOR RECORD FORMAT\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2RFM#\n         MVC   S99TUPAR(1),YRECFM   SET RECORD FORMAT\n         AGO .A2RFM#0\n.A2RFM#  ANOP\n         AIF ('&#RECFM' EQ 'FBA').CON#130\n         AIF ('&#RECFM' EQ 'VBA').CON#130\n         AIF ('&#RECFM' EQ 'VB').CON#130\n         AIF ('&#RECFM' EQ 'FB').CON#130\n         AIF ('&#RECFM' EQ 'U').CON#130\n         AIF ('&#RECFM' EQ 'F').CON#130\n         AIF ('&#RECFM' EQ 'V').CON#130\n         MNOTE 12,'RECFM OF \"&#RECFM\" NOT ALLOWED FOR.'\n         AGO .MEXIT\n.CON#130 ANOP\n         MVI   S99TUPAR,$&RECFM     SET RECFM\n.A2RFM#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2DSORG ANOP\n         AIF (T'&#DSORG EQ 'O').A2LRECL\n*--------------------------------------------------------------------*\n*   ADYN-DATASET ORGANISATION                                        *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALDSORG         GET KEY FOR DSORG\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#7,2                PARAMETER LENGTH OF 2\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2DSO#\n         MVC   S99TUPAR(2),YDSORG   SET DATASET ORGANISATION\n         AGO .A2DSO#0\n.A2DSO#  ANOP\n         AIF ('&#DSORG' EQ 'PO').CON#135\n         AIF ('&#DSORG' EQ 'PS').CON#135\n         AIF ('&#DSORG' EQ 'DA').CON#135\n         AIF ('&#DSORG' EQ 'POU').CON#135\n         AIF ('&#DSORG' EQ 'PSU').CON#135\n         AIF ('&#DSORG' EQ 'DAU').CON#135\n         MNOTE 12,'DSORG OF \"&#DSORG\" NOT ALLOWED FOR.'\n         AGO .MEXIT\n.CON#135 ANOP\n         XC    S99TUPAR+1(1),S99TUPAR+1 INIT LOW ORDER BYTE OF ORG\n         MVI   S99TUPAR,$&#DSORG    SET DATASET ORG\n.A2DSO#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2CONVA ANOP\n.A2LRECL ANOP\n         AIF (T'&#LRECL EQ 'O').A2BLKSZ\n*--------------------------------------------------------------------*\n*   ADYN-LOGICAL RECORD LENGTH                                       *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALLRECL         GET KEY FOR LOGICAL RECORD LENGTH\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#7,2                BECAUSE THE LRECL PARM REQUIRES 1\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2LRL#\n         MVC   S99TUPAR(2),YLRECL   SET RECORD LENGTH\n         AGO .A2LRL#0\n.A2LRL#  ANOP\n         MVC   S99TUPAR(2),=H'&LRECL' SET RECORD LENGTH\n.A2LRL#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2BLKSZ ANOP\n         AIF (T'&#BLKSZ EQ 'O').A2UNIT\n*--------------------------------------------------------------------*\n*   ADYN-BLOCK SIZE                                                  *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALBLKSZ         GET KEY FOR BLOCK SIZE\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#7,2                BECAUSE THE LRECL PARM REQUIRES 1\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n         AIF ('&PARMT'(1,1) EQ 'P').A2BLK#\n         MVC   S99TUPAR(2),YBLKSIZE SET BLOCK SIZE\n         AGO .A2BLK#0\n.A2BLK#  ANOP\n         MVC   S99TUPAR(2),=H'&BLKSIZE' SET BLOCK SIZE\n.A2BLK#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.*--------------------------------------------------------------------*\n.A2UNIT  ANOP\n         AIF (T'&#UNIT EQ 'O').A2AUNIT\n*--------------------------------------------------------------------*\n*   ADYN-DEVICE UNIT                                                 *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALUNIT          GET KEY FOR UNIT\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2UNI#\n         LA    &#7,8                LENGTH OF VOLOSER\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99UNIT         MOVE VOLUME\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AR    &#6,&#7              POINT PAST DSNAME\n         AGO   .A2AUNIT\n.A2UNI#  ANOP\n&PL      SETA  K'&#UNIT\n         LA    &#7,&PL              LENGTH OF VOLOSER\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&#UNIT' MOVE UNIT\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST DSNAME\n.A2AUNIT ANOP\n         AIF (T'&#SPACET EQ 'O').A2PRIM\n*--------------------------------------------------------------------*\n*   ADYN-SPACE ALLOCATION INIT (CYL, TRK or block_size)              *\n*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS      POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR          POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         AIF ('&PARMT'(1,1) EQ 'P').A2ATY#\n         MVI   S99TUKEY,X'00'        CLEAR HIGH ORDER BYTE\n         MVC   S99TUKEY+1(1),YSPACET MOVE ALLOCATION TYPE TO KEY\n         AGO   .A2ATY#0\n.A2ATY#  ANOP\n         AIF ('&#SPACET' EQ 'TRK').A2TRK\n         AIF ('&#SPACET' EQ 'CYL').A2CYL\n         MNOTE 12,'ALLOCATION TYPE OF \"&#SPACET\" NOT ALLOWED FOR.'\n         AGO .MEXIT\n.A2TRK   ANOP\n&#DISP   SETC  'DALTRK'\n         AGO .CON#140\n.A2CYL   ANOP\n&#DISP   SETC  'DALCYL'\n.CON#140 ANOP\n         LA    &#7,&#DISP           GET KEY FOR ALLOCATION UNITS\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n.A2ATY#0 ANOP\n         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n*   ADYN-AR    &#6,&#7              POINT PAST PARAMETER\n.A2PRIM  ANOP\n         AIF (T'&#PRIM EQ 'O').A2SECND\n*--------------------------------------------------------------------*\n*   ADYN-PRIMARY ALLOCATION                                          *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALPRIME         GET KEY FOR RECORD PRIMARY ALLOC\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#7,3                BECAUSE THE LRECL PARM REQUIRES 1\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n         MVI   S99TUPAR,X'00'       CLEAR HIGH ORDER BYTE\n         AIF ('&PARMT'(1,1) EQ 'P').A2PRI#\n         MVC   S99TUPAR+1(2),YPRIM  MOVE PRIMARY ALLOCATION\n         AGO .A2PRI#0\n.A2PRI#  ANOP\n         MVC   S99TUPAR+1(2),=H'&#PRIM' SET PRIMARY ALLOCATION\n.A2PRI#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2SECND ANOP\n         AIF (T'&#SECOND EQ 'O').A2DIRB\n*--------------------------------------------------------------------*\n*   ADYN-SECONDARY ALLOCATION                                        *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALSECND         GET KEY FOR RECORD PRIMARY ALLOC\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#7,3                BECAUSE THE LRECL PARM REQUIRES 1\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n         MVI   S99TUPAR,X'00'       CLEAR HIGH ORDER BYTE\n         AIF ('&PARMT'(1,1) EQ 'P').A2SEC#\n         MVC   S99TUPAR+1(2),YSECOND  MOVE SECONDARY ALLOCATION\n         AGO .A2SEC#0\n.A2SEC#  ANOP\n         MVC   S99TUPAR+1(2),=H'&#SECOND' SET SECONDARY ALLOCATION\n.A2SEC#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2DIRB  ANOP\n         AIF (T'&#DIRB EQ 'O').A2PERMA\n*--------------------------------------------------------------------*\n*   ADYN-DIRECTORY BLOCKS                                            *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALDIR           GET KEY FOR RECORD PRIMARY ALLOC\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#7,3                BECAUSE THE LRECL PARM REQUIRES 1\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n         MVI   S99TUPAR,X'00'       CLEAR HIGH ORDER BYTE\n         AIF ('&PARMT'(1,1) EQ 'P').A2DIR#\n         MVC   S99TUPAR+1(2),YDIRB  MOVE DIRECTORY BLOCKS\n         AGO .A2DIR#0\n.A2DIR#  ANOP\n         MVC   S99TUPAR+1(2),=H'&#DIRB' MOVE DIRECTORY BLOCKS\n.A2DIR#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2PERMA ANOP\n         AIF ('&#PERMA'(1,1) EQ 'N').A2BUFNO\n*--------------------------------------------------------------------*\n*   ADYN-PERMANENT ALLOCATED ATTRIBUTE                               *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALPERMA         GET KEY PERMANENT ATTRIBUTE\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,0                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2BUFNO ANOP\n         AIF (T'&#BUFNO EQ 'O').A2UCLOS\n*--------------------------------------------------------------------*\n*   ADYN-NO OF BUFFERS PER DCB                                       *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALBUFNO         GET KEY FOR NUMBER OF BUFFERS\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#7,1                BECAUSE THE LRECL PARM REQUIRES 1\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n         AIF ('&PARMT'(1,1) EQ 'P').A2BUF#\n         MVC   S99TUPAR(2),YBUFNO   MOVE NUMBER OF BUFFERS\n         AGO .A2BUF#0\n.A2BUF#  ANOP\n         MVC   S99TUPAR(1),=C'&BUFNO' MOVE NUMBER OF BUFFERS\n.A2BUF#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2UCLOS ANOP\n         AIF ('&UCLOSE' NE 'YES').A2RLSE\n         AIF ('&#ACTION'(1,1) NE 'A').A2RLSE\n*--------------------------------------------------------------------*\n*   ADYN-UNALLOCATE DATASET ON CLOSING                               *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALCLOSE         GET KEY FOR UNALLOCATE ON CLOSE\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2RLSE  ANOP\n         AIF ('&#RLSE' NE 'R').A2CLASS\n*--------------------------------------------------------------------*\n*   ADYN-RELEASE ANY UNUSED SPACE AFTRE CLOSING                      *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALRLSE          GET KEY FOR RELEASE\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,0                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2CLASS ANOP\n         AIF (T'&#CLASS EQ 'O').A2WRTR\n*--------------------------------------------------------------------*\n*   ADYN-ALLOCATE SYSOUT CLASS                                       *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALSYSOU         GET KEY FOR CLASS\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n         STH   &#7,S99TULNG         SET STATUS PARM LENGTH ALSO TO 1\n         AIF ('&PARMT'(1,1) EQ 'P').A2CLA#\n         MVC   S99TUPAR(1),YCLASS   MOVE SYSOUT CLASS\n         AGO .A2CLA#0\n.A2CLA#  ANOP\n         MVC   S99TUPAR(1),=C'&#CLASS' SET SYSOUT CLASS\n.A2CLA#0 ANOP\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n.A2WRTR  ANOP\n         AIF (T'&#WRTR EQ 'O').A3ALOC\n*--------------------------------------------------------------------*\n*   ADYN-ALLOCATE SYSOUT WRITER-NAME/INTERNAL-READER                 *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 3ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 3ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DALSPGNM         GET KEY FOR UNIT\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE LRECL KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         AIF ('&PARMT'(1,1) EQ 'P').A2PRG#\n         LA    &#7,8                LENGTH OF VOLOSER\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         BCTR  &#7,0                SUBTRACT 1 FROM LENGTH FOR REL MOVE\n         EX    &#7,MV99WRTR         MOVE WRITER-NAME/INTRDR\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#7,1(&#7)           BACK TO NORMAL LENGTH\n         AR    &#6,&#7              POINT PAST WRITER-NAME\n         AGO   .A3ALOC\n.A2PRG#  ANOP\n&PL      SETA  K'&#WRTR\n         LA    &#7,&PL              LENGTH OF VOLOSER\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         MVC   S99TUPAR(&PL),=C'&#WRTR' MOVE WRITER-NAME/INTRDR\n         LA    &#6,S99TUNIT         POINT JUST PAST THE 1ST TEXT UNIT\n         LA    &#6,6(&#6)           POINT PAST KEY, # AND LENGTH\n         LA    &#6,&PL.(&#6)        POINT PAST WRITER-NAME\n.*--------------------------------------------------------------------*\n.A3ALOC  ANOP\n         AIF ('&#ACTION'(1,1) EQ 'U').UNAL2\n         AIF ('&#ACTION'(1,1) EQ 'F').UNAL2\n         AGO   .A$END\n.*--------------------------------------------------------------------*\n.UNAL2   ANOP\n*--------------------------------------------------------------------*\n*   ADYN-UNALLOCATE/FREE DATASET                                     *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DUNUNALC         GET KEY FOR RETURN DSNAME\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,0                BECAUSE THE UNALLOC KEY REQUIRES 0\n         STH   &#7,S99TUNUM           PARM, STORE 0 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   REMOVE IN-USE ATTRIBUTE                                          *\n.*--------------------------------------------------------------------*\n.*        LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n.*        ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n.*        LA    &#7,DUNREMOV         GET KEY FOR REMOVE IN-USE\n.*        STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n.*        LA    &#7,0                BECAUSE THE UNALLOC KEY REQUIRES 0\n.*        STH   &#7,S99TUNUM           PARM, STORE 0 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n         OI    S99TUPTR,S99TUPLN    TURN ON HIGH ORDER BIT FOR LAST PTR\n         LA    &#6,4(&#6)           POINT PAST KEY, # AND LENGTH\n         AR    &#6,&#7              POINT PAST PARAMETER\n         AGO   .A$END\n.*--------------------------------------------------------------------*\n.INFO2   ANOP\n&@DSNR   SETC  ''\n         AIF ('&PARMT'(1,1) EQ 'D').SETDSNR\n         AIF (T'&#DSN EQ 'O').A$END\n.SETDSNR ANOP\n*--------------------------------------------------------------------*\n*   ADYN-INFO/ RETURN DSNAME FROM DDNAME                             *\n*--------------------------------------------------------------------*\n         LA    &#5,S99TUPL+&TUS     POINT TO 2ND TEXT UNIT PTR IN LIST\n         ST    &#6,S99TUPTR         POINT 2ND TXT UNIT PTR TO 2ND T.U.\n         LA    &#7,DINRTDSN         GET KEY FOR RETURN DSNAME\n         STH   &#7,S99TUKEY         PUT THE KEY IN TEXT UNIT\n         LA    &#7,1                BECAUSE THE DSNAME KEY REQUIRES 1\n         STH   &#7,S99TUNUM           PARM, STORE 1 IN NUMBER FIELD\n.*--------------------------------------------------------------------*\n.*   TEST FOR PARAMETER TYPE                                          *\n.*--------------------------------------------------------------------*\n         LA    &#7,44               MAXIMUM LENGTH OF DATASET\n         STH   &#7,S99TULNG         STORE TEXT UNIT LENGTH\n         LA    &#1,S99TUPAR         LOAD DDNAME VARIABLE ADDRESS\n         AIF ('&PARMT'(1,1) EQ 'P').A2DSNI\n         ST    &#1,YDSN             SAVE FOR LATER USE\n&@DSNR   SETC  'YDSN'\n         AGO   .A$END\n.A2DSNI  ANOP\n         ST    &#1,&DSN             SAVE FOR LATER USE\n&@DSNR   SETC  '&DSN'\n         AGO   .A$END\n.*--------------------------------------------------------------------*\n.CONC2   ANOP\n         AGO .CON#0E0\n.DEAL2   ANOP\n         AGO .CON#0E0\n.*--------------------------------------------------------------------*\n.A$END   ANOP\n         OI    S99TUPTR,S99TUPLN    TURN ON HIGH ORDER BIT FOR LAST PTR\n         AIF ('&PARMT'(1,1) EQ 'P').A$NOEXO\n         AIF (&ADYNFL1).A$NOEXO\n&ADYNFL1 SETB  1\n         B     BYPASEX              BYPASS EX STATEMENTS\n*---------------------------------------------------------------------*\n*  CODE TO BE 'EX'D DURING PARAMETER BUILDING FROM PARAMETERS PASSED  *\n*  AS DATA IN FIELD VARIABLES.                                        *\n*---------------------------------------------------------------------*\nMV99DSN  MVC   S99TUPAR(0),YDSN     MOVE DSNAME\nMV99DDN  MVC   S99TUPAR(0),YDD      MOVE DDNAME\nMV99DDCN MVC   S99TUPAR+10(0),YDDC  MOVE DDNAME TO CONCATENATE\nMV99MEMB MVC   S99TUPAR(0),YMEMBER  MOVE MEMBER\nMV99VOLS MVC   S99TUPAR(0),YVOLSER  MOVE VOLSER\nMV99UNIT MVC   S99TUPAR(0),YUNIT    MOVE DVICE TYPE\nMV99WRTR MVC   S99TUPAR(0),YWRITER  MOVE SYSOUT WRITER-NAME/INTRDR\nMV99DEST MVC   S99TUPAR(0),YDEST    MOVE PRINTER-ID DESTINATION\nMV99FCB  MVC   S99TUPAR(0),YFCB     MOVE FCB\n*---------------------------------------------------------------------*\nBYPASEX  DS    0H\n.A$NOEXO ANOP\n         AIF   ('&REGR' EQ 'NO').NORSAV2 BYPASS IF REGS NOT 2 BE REST'D\n         LM    R0,R14,&REGSAVR      RESTORE USED REGISTERS\n.NORSAV2 ANOP\n         AIF (T'&BASE EQ 'O').UCALLIT\n*---------------------------------------------------------------------*\n*  IMPLICIT INVOCATION OF THE DYNALLOC COMMAND IF 'BASE' SUPPLIED     *\n*---------------------------------------------------------------------*\n         AIF ('&#DDR'(1,1) NE 'Y').A$DDR0 IF DD RETURN REQ'D BYPASS\n&VARNM   SETC  '&#DD'               SET VARIABLE NAME\n         AIF ('&#DD'(1,1) NE '(').NDDVAR3\n&PL      SETA  K'&#DD\n&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME\n.NDDVAR3 ANOP\n         MVC   &REGSAVR.(4),&VARNM  MOVE DDNAME VARIABLE ADDRESS SAVED\n.A$DDR0  ANOP\n         AIF ('&#DSNR'(1,1) NE 'Y').NODSNR\n&VARNM   SETC  '&#DSN'              SET VARIABLE NAME\n         AIF (T'&#DSN NE 'O').NDSNOM3\n&VARNM   SETC  '&@DSNR'             SET VARIABLE NAME\n         AGO   .NDSNVA3\n.NDSNOM3 ANOP\n         AIF ('&#DSN'(1,1) NE '(').NDSNVA3\n&PL      SETA  K'&#DSN\n&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME\n.NDSNVA3 ANOP\n         MVC   &REGSAVR.(4),&VARNM  MOVE DSNAME VARIABLE ADDRESS SAVED\n.NODSNR  ANOP\n         AIF ('&#VOLR'(1,1) NE 'Y').NOVOLR\n&VARNM   SETC  '&#VOLSER'           SET VARIABLE NAME\n         AIF (T'&#VOLSER NE 'O').NVOLOM3\n&VARNM   SETC  '&@VOLR'             SET VARIABLE NAME\n         AGO   .NVOLVA3\n.NVOLOM3 ANOP\n         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA3\n&PL      SETA  K'&#VOLSER\n&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME\n.NVOLVA3 ANOP\n         MVC   &REGSAVR.+4(4),&VARNM  MOVE VOL VARIABLE ADDRESS SAVED\n.NOVOLR  ANOP\n         AIF ('&PDUMP'(1,1) NE 'Y').DYNALOC\n         AIF (T'&PDUMPX EQ 'O').PDUMPWX\n         PDUMP (&BASE),MSG='JUST ABOUT TO INVOKE DYNALLOC \"&#ACTION\". NO\n               O EXIT AVAILABLE.'\n         AGO   .DYNALOC\n.PDUMPWX ANOP\n         PDUMP (&BASE),MSG='JUST ABOUT TO INVOKE DYNALLOC \"&#ACTION\". EX\n               XIT AVAILABLE  THRU \"QUIT\" COMMAND.'\n.DYNALOC ANOP\n         LR    &#1,&BASE            REQ BLK PTR ADR IN &#1 FOR DYNALLOC\n         DYNALLOC\n         AIF (T'&ERROR EQ 'O').TSTDELT\n         LTR   R15,R15              Q. ZERO RETURN CODE FROM ADYN\n         BNZ   &ERROR                  N. GO TO ERROR ROUTINE\n.TSTDELT ANOP\n         AIF ('&#VOLR'(1,1) NE 'Y').A$DSR1\n         L     R14,&REGSAVR+4       LOAD VOLSER VARIABLE ADDRESS SAVED\n         AIF (T'&#VOLSER NE 'O').NVOLOM4\n&VARNM   SETC  '&@VOLR'             SET VARIABLE NAME\n         AGO   .NVOLVA4 ANOP\n.NVOLOM4 ANOP\n         AIF ('&#VOLSER'(1,1) NE '(').NVOLVA4\n&PL      SETA  K'&#VOLSER\n&VARNM   SETC  '&#VOLSER'(2,&PL-2)  SET VARIABLE NAME\n.NVOLVA4 ANOP\n         MVC   &VARNM.(6),0(R14)    MOVE VOLSER RETURNED BY DYNALLOC\n.A$DSR1  ANOP\n         AIF ('&#DSNR'(1,1) NE 'Y').A$DDR1\n         L     R14,&REGSAVR         LOAD DSNAME VARIABLE ADDRESS SAVED\n         AIF (T'&#DSN NE 'O').NDSNOM4\n&VARNM   SETC  '&@DSNR'             SET VARIABLE NAME\n         AGO   .NDSNVA4\n.NDSNOM4 ANOP\n         AIF ('&#DSN'(1,1) NE '(').NDSNVA4\n&PL      SETA  K'&#DSN\n&VARNM   SETC  '&#DSN'(2,&PL-2)     SET VARIABLE NAME\n.NDSNVA4 ANOP\n         MVC   &VARNM.(44),0(R14)   MOVE DSNAME RETURNED BY DYNALLOC\n         OC    &VARNM.(44),=CL44' ' CONVERT TRAILING X'00' TO SPACES\n*                                          /\u00a6\\ <------\n         AGO   .A$DDR2\n.A$DDR1  ANOP\n         AIF ('&#DDR'(1,1) NE 'Y').A$DDR2 IF DD RETURN REQ'D BYPASS\n         L     R14,&REGSAVR         LOAD DDNAME VARIABLE ADDRESS SAVED\n         AIF ('&#DD'(1,1) NE '(').NDDVAR4\n&PL      SETA  K'&#DD\n&VARNM   SETC  '&#DD'(2,&PL-2)      SET VARIABLE NAME\n.NDDVAR4 ANOP\n         MVC   &VARNM.(8),0(R14)    MOVE DDNAME RETURNED BY DYNALLOC\n.A$DDR2  ANOP\n         AIF ('&#ACTION'(1,1) NE 'F').BPALOC2 BYPASS IF NOT FREE\n         AIF ('&ACTION'(1,1) NE 'A').BPALOC2  BYPASS IF NOT ALLOCATE\n&#REUSEF SETC 'Y'\n         AGO .A$RT                             GO ALLOCATE IT\n.BPALOC2 ANOP\n         AIF ('&#ACTION' NE 'ALLOC').UCALLIT\n         AIF ('&ACTION'(1,3) NE 'DEL').UCALLIT\n.*--------------------------------------------------------------------*\n.*    CONTROL GETS HERE IF ACTION WAS DELETE AND WE HAVE JUST ALLOC'D *\n.*    WITH DISP=(OLD,DELETE,DELETE)                                   *\n.*--------------------------------------------------------------------*\n         LTR   R15,R15              Q. ZERO RETURN CODE FROM ADYN\n         BNZ   &DELLAB                 N. BYPASS FREEING FOR DELETE\n&#ACTION SETC 'FREE'                INIT PARMS FOR 'FREE'\n&#DISP1  SETC ''\n&#DISP2  SETC ''\n&#DISP3  SETC ''\n*---------------------------------------------------------------------*\n*  FOR 'DELETE', RETURNING TO UNALLOCATE DATASET JUST ALLOCATED WITH: *\n*     DISP=(OLD,DELETE,DELETE)                                        *\n*---------------------------------------------------------------------*\n         AGO .NOTDELT               GO SET UP FREE COMMANDS\n.UCALLIT ANOP\n.*--------------------------------------------------------------------*\n.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *\n.*--------------------------------------------------------------------*\n         AIF   ('&MF' EQ 'E').NOREGSV BYPASS SAVE REGISTERS\n         AIF   (&REGDFLG).NOREGSV EXIT IF ALREADY PROCESSED\n&REGDFLG SETB  1\n         B     &DELLAB       BRANCH AROUND REG SAVE AREA\n&REGSAVR DS    16F           GLOBAL REGISTER SAVE AREA\n.NOREGSV ANOP\n&DELLAB  DS    0H\n*------------ END OF ADYN PARAMETER LIST BUILD -----------------------*\n         AGO .MEXIT\n*---------------------------------------------------------------------*\n.MFELIST ANOP\n.*--------------------------------------------------------------------*\n.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *\n.*--------------------------------------------------------------------*\n         AIF   (&REGDFLG).MEXIT  EXIT IF ALREADY PROCESSED\n&REGDFLG SETB  1\n&REGSAVR DS    16F           GLOBAL REGISTER SAVE AREA\n         AGO .MEXIT\n.*-----------------CONSTANT MAPPING OF ADYN VARIABLES-----------------*\n.DATAMAP ANOP\n         AIF  ('&DATA'(1,3) EQ 'IBM').DATAIBM\n.*-------------------------------------------------------------------*\n.*     INITIALISE VARIABLES IF NOT PASSED                            *\n.*-------------------------------------------------------------------*\n.A2UNITD ANOP\n         AIF (T'&#UNIT NE 'O').A2UNI11   PROCESS IF NOT OMITTED\n         AIF ('&#DISP1' NE 'NEW').A2UNI11 BYPASS IF OMMITED AND NOT NEW\n&#UNIT   SETC 'SYSALLDA'                 SET UNIT AS 'SYSALLDA'\n*        DEFAULT DEVICE UNIT OF 'SYSALLDA' ASSIGNED                   *\n.A2UNI11 ANOP\n.CDDNAME ANOP\n&#DDR    SETC '&DDR'\n         AIF ('&#DDR'(1,1) EQ 'Y').A$DDR3 IF DD RETURN REQ'D BLANK DD\n         AIF (T'&#DD NE 'O').CDDCNAM\n.A$DDR3  ANOP\n&#DD     SETC ' '\n.CDDCNAM ANOP\n         AIF (T'&#DDC NE 'O').CDSNAME\n&#DDC    SETC ' '\n.CDSNAME ANOP\n         AIF (T'&#DSN NE 'O').CMEMBER\n&#DSN    SETC ' '\n.CMEMBER ANOP\n         AIF (T'&#MEMBER NE 'O').CVOLSER\n&#MEMBER SETC ' '\n.CVOLSER ANOP\n         AIF (T'&#VOLSER NE 'O').CDEST\n&#VOLSER SETC ' '\n.CDEST   ANOP\n         AIF (T'&#DEST NE 'O').CFCB\n&#DEST   SETC ' '\n.CFCB    ANOP\n         AIF (T'&#FCB NE 'O').CCOPYS\n&#FCB    SETC ' '\n.CCOPYS  ANOP\n         AIF (T'&#COPIES NE 'O').CDISP\n&#COPIES SETC '0'\n.CDISP   ANOP\n         AIF (T'&#DISP1 NE 'O').CDISPV\n&#DISP1  SETC '00'\n         AGO .CNDISP\n.CDISPV  ANOP\n         AIF ('&#DISP1' EQ 'NEW').C2NEW\n         AIF ('&#DISP1' EQ 'OLD').C2OLD\n         AIF ('&#DISP1' EQ 'MOD').C2MOD\n         AIF ('&#DISP1' EQ 'SHR').C2SHR\n         AGO .CNDISP\n.C2SHR   ANOP\n&#DISP1  SETC  '08'\n         AGO .CNDISP\n.C2NEW   ANOP\n&#DISP1  SETC  '04'\n         AGO .CNDISP\n.C2MOD   ANOP\n&#DISP1  SETC  '02'\n         AGO .CNDISP\n.C2OLD   ANOP\n&#DISP1  SETC  '01'\n.CNDISP  ANOP\n         AIF (T'&#DISP2 NE 'O').CNDISPV\n&#DISP2  SETC '00'\n         AGO .CCDISP\n.CNDISPV ANOP\n         AIF ('&#DISP2' EQ 'UNCATLG').C2UNC1\n         AIF ('&#DISP2' EQ 'CATLG').C2CAT1\n         AIF ('&#DISP2' EQ 'DELETE').C2DEL1\n         AIF ('&#DISP2' EQ 'KEEP').C2KEP1\n         AGO .CCDISP\n.C2KEP1  ANOP\n&#DISP2  SETC  '08'\n         AGO .CCDISP\n.C2UNC1  ANOP\n&#DISP2  SETC  '01'\n         AGO .CCDISP\n.C2CAT1  ANOP\n&#DISP2  SETC  '02'\n         AGO .CCDISP\n.C2DEL1  ANOP\n&#DISP2  SETC  '04'\n.CCDISP  ANOP\n         AIF (T'&#DISP3 NE 'O').CCDISPV\n&#DISP3  SETC '00'\n.CCDISPV ANOP\n         AIF ('&#DISP3' EQ 'UNCATLG').C2UNC2\n         AIF ('&#DISP3' EQ 'CATLG').C2CAT2\n         AIF ('&#DISP3' EQ 'DELETE').C2DEL2\n         AIF ('&#DISP3' EQ 'KEEP').C2KEP2\n         AGO .CSPACET\n.C2KEP2  ANOP\n&#DISP3  SETC  '08'\n         AGO .CSPACET\n.C2UNC2  ANOP\n&#DISP3  SETC  '01'\n         AGO .CSPACET\n.C2CAT2  ANOP\n&#DISP3  SETC  '02'\n         AGO .CSPACET\n.C2DEL2  ANOP\n&#DISP3  SETC  '04'\n.CSPACET ANOP\n         AIF (T'&#SPACET NE 'O').CSPACEV\n&#SPACET SETC '00'\n         AGO .CPRIM\n.CSPACEV ANOP\n         AIF ('&#SPACET' NE 'CYL').C2TRK1\n&#SPACET SETC  '08'\n         AGO .CPRIM\n.C2TRK1  ANOP\n&#SPACET SETC  '07'\n.CPRIM   ANOP\n         AIF (T'&#PRIM NE 'O').CSECOND\n&#PRIM   SETC '0'\n.CSECOND ANOP\n         AIF (T'&#SECOND NE 'O').CDIRB\n&#SECOND SETC '0'\n.CDIRB   ANOP\n         AIF (T'&#DIRB NE 'O').CBUFNO\n&#DIRB   SETC '0'\n.CBUFNO  ANOP\n         AIF (T'&#BUFNO NE 'O').CUNIT\n&#BUFNO  SETC '0'\n.CUNIT   ANOP\n         AIF (T'&#UNIT NE 'O').CRECFM\n&#UNIT   SETC ' '\n.CRECFM  ANOP\n         AIF (T'&#RECFM NE 'O').CRECFMV\n&#RECFM  SETC '00'\n         AGO .CDSORG\n.CRECFMV ANOP\n         AIF ('&#RECFM' EQ 'FBA').C2FBA\n         AIF ('&#RECFM' EQ 'VBA').C2VBA\n         AIF ('&#RECFM' EQ 'VB').C2VB\n         AIF ('&#RECFM' EQ 'FB').C2FB\n         AIF ('&#RECFM' EQ 'U').C2U\n         AIF ('&#RECFM' EQ 'F').C2F\n         AIF ('&#RECFM' EQ 'V').C2V\n         AGO .CDSORG\n.C2FBA   ANOP\n&#RECFM  SETC  '94'\n         AGO .CDSORG\n.C2VBA   ANOP\n&#RECFM  SETC  '54'\n         AGO .CDSORG\n.C2FB    ANOP\n&#RECFM  SETC  '90'\n         AGO .CDSORG\n.C2VB    ANOP\n&#RECFM  SETC  '50'\n         AGO .CDSORG\n.C2U     ANOP\n&#RECFM  SETC  'C0'\n         AGO .CDSORG\n.C2F     ANOP\n&#RECFM  SETC  '80'\n         AGO .CDSORG\n.C2V     ANOP\n&#RECFM  SETC  '40'\n.CDSORG  ANOP\n         AIF (T'&#DSORG NE 'O').CDSORGV\n&#DSORG  SETC '0000'\n         AGO .CLRECL\n.CDSORGV ANOP\n         AIF ('&#DSORG' EQ 'PO').C2OPO\n         AIF ('&#DSORG' EQ 'PS').C2OPS\n         AIF ('&#DSORG' EQ 'DA').C2ODA\n         AIF ('&#DSORG' EQ 'POU').C2OPOU\n         AIF ('&#DSORG' EQ 'PSU').C2OPSU\n         AIF ('&#DSORG' EQ 'DAU').C2ODAU\n         AGO .CLRECL\n.C2OPOU  ANOP\n&#DSORG  SETC  '0300'\n         AGO .CLRECL\n.C2OPSU  ANOP\n&#DSORG  SETC  '4100'\n         AGO .CLRECL\n.C2ODAU  ANOP\n&#DSORG  SETC  '2100'\n         AGO .CLRECL\n.C2OPO   ANOP\n&#DSORG  SETC  '0200'\n         AGO .CLRECL\n.C2OPS   ANOP\n&#DSORG  SETC  '4000'\n         AGO .CLRECL\n.C2ODA   ANOP\n&#DSORG  SETC  '2000'\n.CLRECL  ANOP\n         AIF (T'&#LRECL NE 'O').CBLKSZ\n&#LRECL  SETC '0'\n.CBLKSZ  ANOP\n         AIF (T'&#BLKSZ NE 'O').CCLASS\n&#BLKSZ  SETC '0'\n.CCLASS  ANOP\n         AIF (T'&#CLASS NE 'O').CWRTR\n&#CLASS  SETC ' '\n.CWRTR   ANOP\n         AIF (T'&#WRTR NE 'O').CRLSE\n&#WRTR   SETC ' '\n.CRLSE   ANOP\n         AIF (T'&#RLSE NE 'O').D$0END\n&#RLSE   SETC 'N'\n         AGO .D$0END\n.D$0END  ANOP\n.*-------------------------------------------------------------------*\n         AIF  ('&DATA'(1,3) EQ 'VAR').DATAVAR\n         AIF  ('&DATA'(1,3) EQ 'CON').DATACON\n         MNOTE 12,'INVALID 'DATA' PARAMETER OF \"&DATA\".'\n         AGO .MEXIT\n.DATACON ANOP\n*--------------------------------------------------------------------*\n* CONSTANT MAP OF 'ADYN' DATA.                                       *\n*--------------------------------------------------------------------*\n         DC    CL8'&#DD'     DD NAME\n         DC    CL8'&#DDC'    DD NAME TO CONCATENATE\n         DC    CL44'&#DSN'   DSN NAME OR '*' FOR TERMINAL\n         DC    CL8'&#MEMBER' MEMBER NAME OR GDG GENERATION\n         DC    CL6'&#VOLSER' DISK DATASET RESIDES ON\n         DC    XL1'&#DISP1'  1ST. BYTE OF STATUS (NEW,OLD,MOD,SHR)\n.*-------------------------------------------------------------------*\n         AIF ('&#CHDISP' EQ 'NO').A2DCM22\n         AIF ('&#CHDISP' EQ 'YES').A2DCM21\n         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN CATALOGUED.'\n         AGO   .A2DCM22  ANOP\n.A2DCM21  ANOP\n         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN FORCED TO ''DELETE'''\n.A2DCM22  ANOP\n.*-------------------------------------------------------------------*\n         DC    XL1'&#DISP2'  1ST. BYTE OF NORMAL DISPOSITION\n*                              CATLG,UNCATLG,DELETE,KEEP\n         DC    XL1'&#DISP3'  1ST. BYTE OF CONDITIONALODISPOSITION\n*                              SAME VALUES AS FOR 'ANDISP'\n         DC    XL1'&#SPACET' SPACE TYPE TRK OR CYL (BLOCK NOT ALLOWED)\n         DC    H'&#PRIM'     PRIMARY SPACE ALLOCATION\n         DC    H'&#SECOND'   SECONDARY SPACE ALLOCATION\n         DC    H'&#DIRB'     DIRECTORY BLOCKS\n         DC    CL1'&#BUFNO'  NUMBER OF BUFFERS\n         DC    CL8'&#UNIT'   DEVICE UNIT TYPE (SYSALLDA,SYSDA,ETC...)\n         DC    XL1'&#RECFM'  RECFM (RECORD FORMAT VALID EQUATES BELOW)\n         DC    XL2'&#DSORG'  DATASET ORGANISATION (VALID EQUATES BELOW)\n         DC    H'&#LRECL'    RECORD LENGTH\n         DC    H'&#BLKSZ'    BLOCK SIZE\n         DC    CL1'&#CLASS'  SYSOUT CLASS (ANY VALID CLASS)\n         DC    CL8'&#WRTR'   SYSOUT WRITER-NAME/INTRDR\n         DC    CL8'&#DEST'   DESTINATION PRINTER-ID\n         DC    CL4'&#FCB'    FCB\n         DC    AL1(&#COPIES) NUMBER OF COPIES\n         DC    CL1'&#RLSE'   FLAG TO INDICATE RELEASE OF UNUSED SPACE\n*                              SET TO NON X'00'\n         AIF   ('&REGSMC1' NE 'ADYN').ECONST1\n         DS    16F           GLOBAL REGISTER SAVE AREA\n&REGSMC1 SETC  '    '\n.ECONST1 ANOP\n*--------------------END OF ADYN DSECT FORMAT-------------------------*\n         AGO   .MEXIT\n.*-------------------END OF CONSTANT FORMAT---------------------------*\n.*\n.*\n.*--------------------DSECT MAPPING OF ADYN VARIABLES-----------------*\n.DATAVAR ANOP\n.*&NAME    DSECT\n*--------------------------------------------------------------------*\n* DSECT USED TO MOVE VARIABLE DYNAMIC ALLOCATION DATASET DETAILS.    *\n*--------------------------------------------------------------------*\nYDD      DC    CL8'&#DD'     DD NAME\nYDDC     DC    CL8'&#DDC'    DD NAME TO CONCATENATE\nYDSN     DC    CL44'&#DSN'   DSN NAME OR '*' FOR TERMINAL\nYMEMBER  DC    CL8'&#MEMBER' MEMBER NAME OR GDG GENERATION (-N,0,+N)\nYVOLSER  DC    CL6'&#VOLSER' DISK DATASET RESIDES ON\n*\nYDISP    DC    XL1'&#DISP1'  1ST. BYTE OF STATUS (NEW,OLD,MOD,SHR)\nYSHR     EQU   X'08'          - SHARE DISPOSITION (STATUS)\nYNEW     EQU   X'04'          - NEW   DISPOSITION (STATUS)\nYMOD     EQU   X'02'          - MOD   DISPOSITION (STATUS)\nYOLD     EQU   X'01'          - OLD   DISPOSITION (STATUS)\n*\n.*-------------------------------------------------------------------*\n         AIF ('&#CHDISP' EQ 'NO').A2DCM32\n         AIF ('&#CHDISP' EQ 'YES').A2DCM31\n         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN CATALOGUED.'\n         AGO   .A2DCM32  ANOP\n.A2DCM31  ANOP\n         MNOTE 4,'NON-SPECIFIED DSNAME HAS BEEN FORCED TO ''DELETE'''\n.A2DCM32  ANOP\n.*-------------------------------------------------------------------*\nYNDISP   DC    XL1'&#DISP2'  1ST. BYTE OF NORMAL DISPOSITION\n*                              CATLG,UNCATLG,DELETE,KEEP\nYUNCAT   EQU   X'01'           - UNCATALOG\nYCATLG   EQU   X'02'           - CATALOG\nYDELETE  EQU   X'04'           - DELETE\nYKEEP    EQU   X'08'           - KEEP\nYCDISP   DC    XL1'&#DISP3'  1ST. BYTE OF CONDITIONALODISPOSITION\n*                              SAME VALUES AS FOR 'ANDISP'\nYSPACET  DC    XL1'&#SPACET' SPACE TYPE TRK OR CYL (BLOCK NOT ALLOWED)\nYTRK     EQU   X'07'           - TRACK MASK\nYCYL     EQU   X'08'           - CYLINDER MASK\n*\nYPRIM    DC    H'&#PRIM'     PRIMARY SPACE ALLOCATION\nYSECOND  DC    H'&#SECOND'   SECONDARY SPACE ALLOCATION\nYDIRB    DC    H'&#DIRB'     DIRECTORY BLOCKS\nYBUFNO   DC    CL1'&#BUFNO'  NUMBER OF BUFFERS\nYUNIT    DC    CL8'&#UNIT'   DEVICE UNIT TYPE (SYSALLDA,SYSDA,ETC...)\n*\nYRECFM   DC    XL1'&#RECFM'  RECFM (RECORD FORMAT VALID EQUATES BELOW)\nYFBA     EQU   X'94'           - FBA\nYVBA     EQU   X'54'           - VBA\nYFB      EQU   X'90'           - FB\nYVB      EQU   X'50'           - VB\nYU       EQU   X'C0'           - U\nYF       EQU   X'80'           - F\nYV       EQU   X'40'           - V\n*\nYDSORG   DC    XL2'&#DSORG'  DATASET ORGANISATION (VALID EQUATES BELOW)\nYDSOPOU  EQU   X'0300'         - POU\nYDSOPSU  EQU   X'4100'         - PSU\nYDSODAU  EQU   X'2100'         - DAU\nYDSOPO   EQU   X'0200'         - PO\nYDSOPS   EQU   X'4000'         - PS\nYDSODA   EQU   X'2000'         - DA\n*\nYLRECL   DC    H'&#LRECL'    RECORD LENGTH\nYBLKSIZE DC    H'&#BLKSZ'    BLOCK SIZE\nYCLASS   DC    CL1'&#CLASS'  SYSOUT CLASS (ANY VALID CLASS)\nYWRITER DC     CL8'&#WRTR'   SYSOUT WRITER-MAME/INTRDR\nYDEST    DC    CL8'&#DEST'   DESTINATION PRINTER-ID\nYFCB     DC    CL4'&#FCB'    FCB\nYCOPIES  DC    AL1(&#COPIES) NUMBER OF COPIES\nYRLSE    DC    CL1'&#RLSE'   FLAG TO INDICATE RELEASE OF UNUSED SPACE\n*                              SET TO NON X'00'\n         AIF   ('&REGSMC2' NE 'ADYN').EDSECT1\n&REGSMC2 SETC  '    '\n         AIF   (&REGDFLG).EDSECT1 EXIT IF ALREADY PROCESSED\n&REGDFLG SETB  1\n&REGSAVR DS    16F           GLOBAL REGISTER SAVE AREA\n.EDSECT1 ANOP\n*--------------------END OF ADYN DSECT FORMAT-------------------------*\n         AGO .MEXIT\n.DATAIBM ANOP\n*---------------------------------------------------------------------*\n*     IBM REQUIRED MACROS                                             *\n*---------------------------------------------------------------------*\n         IEFZB4D0\n         IEFZB4D2\n         AGO .MEXIT\n*---------------------------------------------------------------------*\n.CON#0E0 MNOTE 12,'\"&#ACTION\" NOT DEFINED YET.'\n.MEXIT   ANOP\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADYNNOTE": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00@\\x00\\x93\\x05\\x0f\\x00\\x93$/\\x15I\\x01\\x1c\\x08D\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1993-02-19T00:00:00", "modifydate": "1993-08-30T15:49:40", "lines": 284, "newlines": 2116, "modlines": 0, "user": "ZTSALK"}, "text": "     ***********************************************************************\n     *                                                                     *\n     * DYNAMIC ALLOCATION MACRO.      Written by A. Kara.                  *\n     * -------------------------                                           *\n     *           N O T E - N O T E - N O T E - N O T E - N O T E           *\n     *                                                                     *\n     *   This routine saves and uses the following general registers:      *\n     *      R1, R4, R5, R6, R7, R14 and R15.                               *\n     *   If any of these registers are used as base registers or anchors   *\n     *   for the DSECT containing the DATA format of the macro (if used),  *\n     *   either substitute with an unused one (refer parameter 'Rn') or do *\n     *   not use this macro.                                               *\n     *                                                                     *\n     *   This macro is only applicable to DASD and cannot be used for      *\n     *   tapes.                                                            *\n     *                                                                     *\n     *---------------------------------------------------------------------*\n     * Macro to generate code to dynamically Allocate/Info/Delete/         *\n     *  Unallocate|Free/Deconcatenate/Concatenate/Reallocate               *\n     *                                                                     *\n     *   Parameters:                                                       *\n     *       1. ACTION  - valid actions are:                               *\n     *                    'Info'    - advise if dataset is allocated.      *\n     *                                Requires the following minimum       *\n     *                                parameters:                          *\n     *                                  DD and DSN.                        *\n     *                    'Alloc'   - allocate datest (basically pass jcl  *\n     *                                format parameters).                  *\n     *                                To reallocate, pass parameter of     *\n     *                                REUSE=YES.                           *\n     *                    'Unalloc'/'Free'/'DEConc'                        *\n     *                              - any one of these command will        *\n     *                                unallocate the dataset/concatenations*\n     *                    'DELete'  - delete allocates the DSN with        *\n     *                                'DISP=(OLD,DELETE,DELETE)' then frees*\n     *                                it.                                  *\n     *                    'Conc'    - concatenates the dd name defined on  *\n     *                                the 'DDC' parameter to the 'DD' parm.*\n     *                                                                     *\n     *       2. BASE    - Register to be used as a base register for the   *\n     *                    SVC 99 DSECT 'S99RBP'. This register must be     *\n     *                    loaded with the address of the area where the    *\n     *                    SVC 99 parameter list may be built. Also used to *\n     *                    invoke the 'DYNALLOC' routine automatically.     *\n     *                    (Do not enclose in brackets.)                    *\n     *                    If the base parameter is not passed, the         *\n     *                    following will need to be explicitly coded:      *\n     *                    1. Before the invocation of the 'ADYN' macro:    *\n     *                                                                     *\n     *                         USING S99RBP,Rn  establish addresability    *\n     *                                                                     *\n     *                    2. On return from the macro:                     *\n     *                                                                     *\n     *                         LR    R1,Rn  req blk ptr in R1 for dynalloc *\n     *                                      (both Rn must be same register)*\n     *                         DYNALLOC                                    *\n     *                                                                     *\n     *       3. BLKSIZE - Block size. (Same restrictions as 'LRECL').      *\n     *                                                                     *\n     *       4. CCP     - Wheteher to make concatenation permanent.        *\n     *                    Valid values are YES/NO with YES as default.     *\n     *                                                                     *\n     *       5. COPIES  - Number of copies to print (for SYSOUT DD's)      *\n     *                                                                     *\n     *       6. DATA    - Valid values are 'VARiable'/'CONstant'/'IBM'.    *\n     *                    Set up the data fields if you use the parameter  *\n     *                    'PARMT=DATA' in your program:                    *\n     *                    Set to 'VARiable' if you want a map of the data  *\n     *                    fields used for variable parameter passing. This *\n     *                    is required in your getmained DSECT for re-      *\n     *                    entrant programs.                                *\n     *                    You may initialise this area by coding a macro   *\n     *                    with 'DATA=CONstant' in your constant data area  *\n     *                    and on the macro pass all the parameters as      *\n     *                    though you were coding a macro with 'PARMT=PARM' *\n     *                    and moving it over the variable part. The max    *\n     *                    length of the data is 123 bytes.  If the program *\n     *                    is not re-entrant you only need to code the macro*\n     *                    with the parameter of 'DATA=VARiable'.           *\n     *                  In all cases supply a macro with 'DATA=IBM' to     *\n     *                    define the IBM required macros. If this is not   *\n     *                    defined in your program, you must explicitly     *\n     *                    define the following ibm macros in your program  *\n     *                          'IEFZB4D0'                                 *\n     *                          'IEFZB4D2'                                 *\n     *                  There should only be 1 macro with DATA=IBM/VAR     *\n     *                    however you may have as many DATA=CON as you     *\n     *                    like. DATA=IBM/VAR generate labels while 'CON'   *\n     *                    does not.                                        *\n     *                                                                     *\n     *       7. DD      - DD name to be allocated. In case of a 'Conc'     *\n     *                    action, concatenate the 'DDC' parm to this.      *\n     *                    If parameter 'DDR=YES' is used with 'PARMT=PARM' *\n     *                    this paramater must point to a variable name in  *\n     *                    the data area.                                   *\n     *                                    - or -                           *\n     *                    DD=(varname) if the DDname is to be taken from   *\n     *                    a variable.                                      *\n     *                                                                     *\n     *       8. DDC     - DD name to concatenate to DD name with 'Conc'.   *\n     *                                                                     *\n     *       9. DDR     - DD name to be returned and placed in the variable*\n     *                    specified for the 'DD' parameter after an        *\n     *                    'Alloc' request without a DD parm. Set to either *\n     *                    YSE/NO ('NO' is the default).                    *\n     *                    If 'PARMT=DATA' is used, the DD name is returned *\n     *                    in the variable 'YDD' which would have been      *\n     *                    defined by the ADYN macro with 'PARMT=VAR'.      *\n     *      10. DEST    - Printer-id destination with 'SYSOUT'             *\n     *                                                                     *\n     *      11. DISP    - Standard JCL type DISP parameter, eg.            *\n     *                    'DISP=(NEW,CATLG,DELETE)'                        *\n     *                    (default of 'OLD' for 'Allocate' action.)        *\n     *                    For new dataset allocation without a 'DSN='      *\n     *                    but rather a 'DSNR=' parameter, the 2nd. and 3rd.*\n     *                    disposition parameter will be automatically      *\n     *                    changed to '(....,DELETE,DELETE)'.               *\n     *                                                                     *\n     *      12. DSN     - DSNAME (unquoted of course) or '*' for terminal. *\n     *                                    - or -                           *\n     *                    Variable name to return the DSN name in, after an*\n     *                    'Info' request. (If 'PARMT=DATA' is used the DSN *\n     *                    will be returned in the variable 'YDSN' which    *\n     *                    would have been defined by the ADYN macro with   *\n     *                    'PARMT=VAR'.)                                    *\n     *                                    - or -                           *\n     *                    If the action is ALLOC and the dataset name is   *\n     *                    stored in a variable and PARMT=PARM is required, *\n     *                    indicate the variable's name by specifying       *\n     *                    'DSN=(varname)'.                                 *\n     *                    NOTE - This variable must be specified if the    *\n     *                    'DSNR=Yes' parameter is used. Use 'DSN=YDSN' for *\n     *                    'PARMT=VAR'.                                     *\n     *                                                                     *\n     *      13. DSNR    - DSN name to be returned and placed in the        *\n     *                    variable specified for the 'DSN' parameter after *\n     *                    an 'Alloc' request without a DSN parm. Set to    *\n     *                    either YES/NO ('NO' is the default).             *\n     *                    If 'PARMT=DATA' is used, the DSN name is returned*\n     *                    in the variable 'YDSN' which would have been     *\n     *                    defined by the ADYN macro with 'PARMT=VAR'.      *\n     *                    >>>>>>>>>>>>>>>>>>>> NOTE <<<<<<<<<<<<<<<<<<<<<< *\n     *                    Will force 'DISP=(...,DELETE,DELETE)' to prevent *\n     *                    allocations of datasets with variable names all  *\n     *                    over the place........                           *\n     *                    >>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<< *\n     *                                                                     *\n     *      14. ERROR   - Label to branch to in case of error. If this     *\n     *                    parameter is not passed you will have to code    *\n     *                    your own return code test:                       *\n     *                          LTR  R15,R15                               *\n     *                          BNZ  ERROR01                               *\n     *                                                                     *\n     *      15. FCB     - Forms Control Buffer image id                    *\n     *                                                                     *\n     *      16. HELP    - Set to YES/NO to include these parameter comments*\n     *                    into the assembly listings. The default is 'NO'. *\n     *                                                                     *\n     *      17. LIST    - Set to YES/NO to generate macro expansion.       *\n     *                    Default is 'YES'.                                *\n     *                                                                     *\n     *      18. LRECL   - Logical record size. As a keyword, pass as an    *\n     *                    integer < 32760. As data pass as a halfword.     *\n     *                                                                     *\n     *      19. MF      - Macro format. Must be coded as MF=E to generate  *\n     *                    code and MF=L either in a GETMAINed DSECT and/or *\n     *                    data area. MF=L defines 16 full words as a       *\n     *                    register save area (will not be defined if the   *\n     *                    area has already been defined by a prior macro). *\n     *                    These 16 full words are appended to both the     *\n     *                    DATA=VAR/CON areas if used.                      *\n     *                                                                     *\n     *      20. PARMT   - Parameter type.                                  *\n     *               'PARM'    - Keyword parameters passed (default) on    *\n     *                           the EXEC form of the macro.               *\n     *               'DATA'    - Parameters passed as data from the 'ADYN' *\n     *                           DSECT. If parameters are passed as        *\n     *                           variable data, a keyword entry of 'DATA'  *\n     *                           is required to tell the macro to process  *\n     *                           that parameter from the data area (in     *\n     *                           this case the data area must be set up as *\n     *                           required).                                *\n     *                           (Default is 'PARM'.)                      *\n     *                                                                     *\n     *      21. PERMA   - 'Permanent allocate' attribute. Prevents         *\n     *                    datasets from being automatically dealocated when*\n     *                    closed (in on-line environments).                *\n     *                    valid values are YES/NO with 'YES' as default.   *\n     *                                                                     *\n     *      22. PDUMP   - Invoke the PDUMP utility just prior to issuing   *\n     *                    the DYNALLOC SVC.                                *\n     *                                                                     *\n     *      22. PDUMPX  - This parameter is used with the PDUMP parameter  *\n     *                    and you may specify an exit point address to     *\n     *                    branch to by entering the 'QUIT' command in      *\n     *                    PDUMP thereby bypassing execution of DYNALLOC.   *\n     *                                                                     *\n     *      23. RECFM   - Record format.                                   *\n     *                                                                     *\n     *      24. REGR    - Set to YES/NO to restore registers on return     *\n     *                    from macro, default is 'YES'.                    *\n     *                    (Refer note \"A\" below.)                          *\n     *                                                                     *\n     *      25. REUSE   - Use this parameter if you wany to reallocate the *\n     *                    DD name without having to free it.  The macro    *\n     *                    will generate the Free statements prior to       *\n     *                    Allocation. Set to YES/NO ('NO' is the default). *\n     *                                                                     *\n     *      26. RLSE    - Release unused space indicator. Not required for *\n     *                    keyword parameters as would be passed on the     *\n     *                    SPACE= keyword. However, is required if data     *\n     *                    passed as there is no equivalent data area.      *\n     *                    Valid values are YES/NO with 'NO' as default.    *\n     *                                                                     *\n     *      27. Rn      - Substitute specified register for the nominated  *\n     *                    register in this routine. Registers that may be  *\n     *                    substituted are:                                 *\n     *                       R1, R4, R5, R6 and R7.                        *\n     *                    NOTE - You may use R14 and R15 as substitute     *\n     *                           registers.                                *\n     *                                                                     *\n     *      28. SPACE   - Standard JCL type space parameter, eg.           *\n     *                    'SPACE=(TRK,(2,2,1),RLSE)'                       *\n     *                    NOTE - In DATA format of the macro, RLSE is      *\n     *                           ignored and you must specify the RLSE=YES *\n     *                           paremeter.                                *\n     *                                                                     *\n     *      29. SYSOUT  - SYSOUT class and writer-name:                    *\n     *                    eg. SYSOUT=X, SYSOUT=(A,INTRDR),                 *\n     *                        SYSOUT=(A,FREDWRTR)                          *\n     *                                                                     *\n     *      30. UCLOSE  - Unalloc dataset on closing. If this option is to *\n     *                    be effective, it must be coded as UCLOSE=YES for *\n     *                    both types of parameter passing as there is no   *\n     *                    equivalent data area.                            *\n     *                    Valid values are YES/NO with 'NO' as default.    *\n     *                                                                     *\n     *      31. UNIT    - Device unit type. Any valid device unit as would *\n     *                    be accepted on JCL.                              *\n     *                                                                     *\n     *      32. VOLSER  - Volume serial.                                   *\n     *                                                                     *\n     *      33. VOLR    - VOLSER name to be returned and placed in the     *\n     *                    variable specified for the 'VOLSER' parameter    *\n     *                    after an 'Alloc' request without a VOLSER value. *\n     *                    Set to either YES/NO ('NO' is the default).  If  *\n     *                    'PARMT=DATA' is used, the VOLSER name is returned*\n     *                    in the variable 'YVOLSER' which would have been  *\n     *                    defined by the ADYN macro with 'PARMT=VAR'.      *\n     *                                                                     *\n     *   NOTES -                                                           *\n     *      A) Macro format parameter of 'MF=.' Is mandatory.              *\n     *         A macro with 'MF=L' is required in your program to generate *\n     *         a register save area as registers R1,R4,R5,R6,R7,R14,R15 are*\n     *         used in the program. All registers except R15 will be       *\n     *         reset on return from the macro. R15 will contain the return *\n     *         code from the 'DYNALLOC' routine.                           *\n     *                                                                     *\n     *      B) If parameter 'PARMT=DATA' is used:                          *\n     *         Must issue an 'ADYN' macro with 'DATA=VARiable'. For re-    *\n     *         entrant programs, suggest you initialise the data area in   *\n     *         your DSECT by copying over it data initialised in your      *\n     *         constant area from an 'ADYN' macro using 'DATA=CONstant'.   *\n     *                                                                     *\n     *      C) Must have 'DATA=IBM' to include the IBM DSECTs needed for   *\n     *         SVC 99.                                                     *\n     *                                                                     *\n     *      D) Space requirements:                                         *\n     *         Allow 300 bytes for SVC 99 parameter list, (ie. data area   *\n     *         pointer to by the 'BASE' parameter).                        *\n     *         Allow 123 bytes for both constant and variable data area    *\n     *         created by the 'DATA=CON/VAR' parameter. Add 64 (16 x 4)    *\n     *         bytes if this expansion stores the register save areas      *\n     *         (refer to the MF parameter).                                *\n     *                                                                     *\n     *      E) On the EXEC form of the macro, R15 contains the return code *\n     *         from the 'DYNALLOC' routine.  R0 contains the error code in *\n     *         the high 2 order bytes and the information reason code in   *\n     *         the low 2 order bytes.  All the other registers wiil be     *\n     *         reset to their initial value on entering the macro.         *\n     *         NOTE - Note the comment about register usage in this macro  *\n     *                versus your program's register usage.                *\n     *                                                                     *\n     ***********************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AMODECHG": {"ttr": 10246, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00 \\x00\\x92)?\\x01\\x02\\x05/\\x13\\x03\\x00~\\x00/\\x00\\x00\\xc3\\xf8\\xf3\\xf8\\xf7\\xf0\\xf4@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1992-10-19T00:00:00", "modifydate": "2002-02-21T13:03:20", "lines": 126, "newlines": 47, "modlines": 0, "user": "C838704"}, "text": "         MACRO\n&NAME    AMODECHG &MODE,&REG,&ST=\n         AGO .A$HELPE\n*---------------------------------------------------------------------*\n*                                                                     *\n* CHANGE ADDRESSING MODE.                                             *\n* -----------------------                                             *\n* The purpose of this macro is to change addressing modes (AMODE)     *\n* during execution of a program or to return the addressing mode for  *\n* subsequent testing.                                                 *\n*                                                                     *\n* Parameters:                                                         *\n*    MODE        - New addressing mode. This is a positional          *\n*                  parameter and must have value of 24, 31,           *\n*                  O(riginal) or Q(uery).                             *\n*                  Under 'O' mode, ST= parameter must be passed.      *\n*                  Under 'Q' mode, the register (specified or defautl)*\n*                  will be set to Hex zeros if amode is 24 and        *\n*                  non-zero (X'80000000') if 31 bit addressing. You   *\n*                  may also store mode under query.                   *\n*                                                                     *\n*                    eg. LABEL1  AMODECHG 31,ST=AMODEIN               *\n*                        LABEL2  AMODECHG 24                          *\n*                        LABEL3  AMODECHG O,ST=AMODEIN                *\n*                        LABEL4  AMODECHG Q                           *\n*                        LTR     15,15              Q. 24 BIT         *\n*                        BZ      A24BIT                Y. PROCESS 24  *\n*                                                                     *\n*    REG         - Work register (default is 15).                     *\n*    ST=cccc     - Address to store current addressing mode for       *\n*                  subsequent reversal.                               *\n*                                                                     *\n* Notes:                                                              *\n*    1. The same format of this macro can be used in any type of      *\n*       programs, (ie. can be used in re-entrant programs).           *\n*    2. This macro WILL change the contents of register 15 if no      *\n*       register parameter is passed.                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         LCLC  &LABEL11,&LABEL21,&ST#\n         GBLB  &AMODE31,&AMODE24\n         LCLC  &WREG1,&WREG2,&LABEL1\n         AIF   (T'&NAME EQ 'O').A$YY\n&NAME    DS    0H\n.A$YY    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&MODE EQ 'O').ERR1\n&WREG1   SETC  '15'                    Set work register\n         AIF   (T'&REG EQ 'O').WREGST1 Bypass if register omitted\n&WREG1   SETC  '&REG'                  Set work register\n.WREGST1 ANOP\n         AIF   ('&MODE' EQ 'Q').A$LQR10\n         AIF   ('&MODE' NE 'O').A$LXX10\n.*--------------------------------------------------------------------*\n.A$OR    ANOP\n*---------------------------------------------------------------------*\n*  ===>  Change to original addressing mode in stream                 *\n*---------------------------------------------------------------------*\n&LABEL1  SETC  'AOR'.'&SYSNDX'.'1'\n         LA    &WREG1,&LABEL1          Set BSM address\n         AIF   (T'&ST EQ 'O').ERR2\n         O     &WREG1,&ST              Hit with original mode\n         BSM   &WREG1,&WREG1           Change mode to original mode\n&LABEL1  EQU   *\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.A$LXX10 ANOP\n*---------------------------------------------------------------------*\n         AIF   ('&MODE' EQ '31').A$L3110      Set 31 comment\n*---------------------------------------------------------------------*\n*  ===>  Change to 24 bit addressing mode in stream                   *\n*---------------------------------------------------------------------*\n&LABEL1  SETC  'A24'.'&SYSNDX'.'1'\n         AGO   .A$LXX20                       Bypass\n.A$L3110 ANOP\n*---------------------------------------------------------------------*\n*  ===>  Change to 31 bit addressing mode in stream                   *\n*---------------------------------------------------------------------*\n&LABEL1  SETC  'A31'.'&SYSNDX'.'1'\n.A$LXX20 ANOP\n*---------------------------------------------------------------------*\n         LA    &WREG1,&LABEL1          Set BSM address\n         AIF   ('&MODE' EQ '31').A$LXX25      Bypass for 31 bits\n         N     &WREG1,=X'7FFFFFFF'     Set 32nd bit for swap to 24 bit\n         AGO   .A$LXX35\n.A$LXX25 ANOP\n         O     &WREG1,=X'80000000'     Set 32nd bit for swap to 31 bit\n.A$LXX30 ANOP\n         AIF   (T'&ST EQ 'O').A$LXX35\n         BASSM &WREG1,&WREG1           Change mode and save current\n         AGO   .A$LXX40\n.A$LXX35 ANOP\n         BSM   &WREG1,&WREG1           Change mode\n.A$LXX40 ANOP\n&LABEL1  EQU   *\n         AIF   (T'&ST EQ 'O').MEXIT\n         N     &WREG1,=X'80000000'     Original AMODE\n         ST    &WREG1,&ST              Store it\n         AGO   .MEXIT\n.*\n.*--------------------------------------------------------------------*\n.*\n.A$LQR10 ANOP\n*---------------------------------------------------------------------*\n* Query addressing mode                                               *\n*---------------------------------------------------------------------*\n&LABEL1  SETC  'AQR'.'&SYSNDX'.'1'\n         BAS   &WREG1,&LABEL1          Dranch and set addressing mode\n&LABEL1  EQU   *\n         N     &WREG1,=X'80000000'     Set reg zero/24, non-zero/31\n         AIF   (T'&ST EQ 'O').MEXIT\n         ST    &WREG1,&ST              Store it\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.*       ERROR MESSAGES                                               *\n.*--------------------------------------------------------------------*\n.ERR1    MNOTE 8,'Missing addressing mode parameter (24, 31, O or Q).'\n         AGO   .MEXIT\n.ERR2    MNOTE 8,'Original restore mode requires a \"ST=\" parameter.'\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.MEXIT   ANOP\n         MEXIT\n.*--------------------------------------------------------------------*\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CADC": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01$\\x00\\x10\\x00\\x925/\\x00\\x925\\x7f\\x14E\\x01&\\x00\\xa5\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.36", "flags": 0, "createdate": "1992-12-17T00:00:00", "modifydate": "1992-12-22T14:45:10", "lines": 294, "newlines": 165, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    CADC &TEXTL=,&TEXTC=,&TEXTH=,&REP=1,&LIST=YES,&HELP=NO,       X\n               &RESET=YES\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n.*--------------------------------------------------------------------*\n         GBLB  &CADC1ST\n         GBLC  &CADCCPT,&CADCHPT\n         AIF   (&CADC1ST).A$HELPE      IF NOT 1ST. TIME THRU\n&CADC1ST SETB  1\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'CADC' parameter and    *\n* it's use, pass parameter 'HELP=Yes'.                                *\n.*--------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* Character Attribute Define Constant (CADC).                         *\n* -------------------------------------------                         *\n* Macro used  to expand a text to include character attributes to     *\n* permit each character to be a diffrent color with different         *\n* attributes.                                                         *\n*                                                                     *\n* Parameters:                                                         *\n*   1. TEXTL=   - Text literal to have character attributes inserted. *\n*                 If text contain spaces, enclose field in quotes,    *\n*                 eg. TEXTL='TEXTL HAS BLANKS'                        *\n*                 If the text contains quotes \"'\" or ampersand \"&\"    *\n*                 they should be doubled up. (This should not be      *\n*                 necessary but is required to keep syntax in line    *\n*                 with assembler requirements.)                       *\n*   2. TEXTC=   - A color prefix letter corresponding to each         *\n*                 character in the TEXTL= parameter, where:           *\n*                 B - Blue                                            *\n*                 G - Green                                           *\n*                 O - OFF (USE DEFAULT COLOR)                         *\n*                 P - Pink                                            *\n*                 R - Red                                             *\n*                 T - Turqoise                                        *\n*                 W - White                                           *\n*                 Y - Yellow                                          *\n*                 The character color may be left blank if you wish   *\n*                 to retain the color of the previous character.      *\n*                 Both upper an lower case characters are acceptable. *\n*   3. TEXTH=   - An hilite letter corresponding to each character    *\n*                 in the TEXTL= parameter, where:                     *\n*                 B - Blink                                           *\n*                 O - Off (no special hilite)                         *\n*                 R - Reverse                                         *\n*                 U - Underscore                                      *\n*                 The character hilite may be left blank if you wish  *\n*                 retain the color of the previous character.         *\n*                 Both upper an lower case characters are acceptable. *\n*   4. REP=     - Repetition number. Number of times to repeat the    *\n*                 string. The default is 1.                           *\n*   5. LIST=    - List the macro expansion. Default is NO.            *\n*   6. HELP=    - Provide this help listing. Default is NO.           *\n*                                                                     *\n*   7. RESET=   - Reset character attributes to default values.       *\n*                 Refer to Note 4 below. Valid values are YES/NO with *\n*                 NO being the default.                               *\n*                                                                     *\n* NOTE:                                                               *\n*      1. There is no seperate EXEC or LIST formats.                  *\n*                                                                     *\n*      2. If you omit the TEXTL= parameter, the values supplied on    *\n*         TEXTC= and TEXTH= parameters will be used as defaults for   *\n*         subsequent macro processing if either of the two parameters *\n*         are not supplied on the macro.  The default values may be   *\n*         turned off by passing the parameter(s) without values,      *\n*          eg. TEXTC=,TEXTL=                                          *\n*                                                                     *\n*      3. If you omit the TEXTC= and/or TEXTH= parameters, the values *\n*         will be taken from the paramater values from the last       *\n*         processed macro without the TEXTL= parameter.               *\n*         If you resort to using this define default facility, the    *\n*         length of the supplied default string must be equal to or   *\n*         longer than the TEXTL= value's length.                      *\n*                                                                     *\n*      4. Once you have introduced character attributes (either by    *\n*         using this macro on any other macro), the last character    *\n*         attribute used is retained UNLESS you turn it off by either:*\n*                                                                     *\n*         a) Using the RESET=YES parameter either as a complementary  *\n*            or sole (default) parameter, ie code the CADC macro      *\n*            without parameters.                                      *\n*         b) setting the last character as a space and setting its    *\n*            attribute(s) to 'O' (Off).                               *\n*         c) include the following HEX code in your data              *\n*            stream:    DC   X'284200'     turns on default color     *\n*                       DC   X'284100'     turns on default hilite    *\n*                                                                     *\n.*--------------------------------------------------------------------*\n.A$HELPE ANOP\n         LCLA  &TLEN,&CLEN,&HLEN,&#REP,&LCTR\n         LCLC  &CCOL,&CHAR,&CHIL,&TCOL,&THIL,&#TEXTL,&#TEXTC,&#TEXTH\n.*--------------------------------------------------------------------*\n         AIF   (T'&TEXTL NE 'O').STD0       BYPASS IF TEXT NOT MISSING\n         AIF   (T'&TEXTC NE 'O').SETDFL0    SET DEF IF COLOR PRESENT\n         AIF   (T'&TEXTH NE 'O').SETDFL0    SET DEF IF COLOR PRESENT\n.*--------------------------------------------------------------------*\n.*    ALL MAJOR PARAMETERS MISSING                                    *\n*---------------------------------------------------------------------*\n         AIF   (T'&RESET EQ 'O').E0         NO PARAMETERS ???\n         AIF   ('&RESET'(1,1) NE 'Y').E0         NO PARAMETERS ???\n         DC   X'284200284100'          TURN ON DEFAULT COLOR AND HILITE\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.SETDFL0 ANOP\n*---------------------------------------------------------------------*\n&CADCCPT SETC  '&TEXTC'                     SET GLOBAL DEFAULT COLOR\n&CADCHPT SETC  '&TEXTH'                     SET GLOBAL DEFAULT HILITE\n         MNOTE 0,'COLOR AND HILITE DEFAULTS STORED'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.STD0    ANOP\n&#REP    SETA  &REP\n&#TEXTC  SETC  '&TEXTC'\n&#TEXTH  SETC  '&TEXTH'\n         AIF   (T'&TEXTC NE 'O').STD1       BYPASS IF COLOR SUPPLIED\n&#TEXTC  SETC  '&CADCCPT'                   SET GLOBAL DEFAULT COLOR\n.STD1    ANOP\n         AIF   (T'&TEXTH NE 'O').QT0        BYPASS IF HILITE SUPPLIED\n&#TEXTH  SETC  '&CADCHPT'                   SET GLOBAL DEFAULT HILITE\n.QT0     ANOP                               UNQUOTE TEXT\n         AIF   ('&TEXTL'(1,1) EQ '''').QT2  IF QUOTED GO UNQUOTE\n.QT1     ANOP                               UNQUOTE TEXT\n&TLEN    SETA  K'&TEXTL(1)\n&#TEXTL  SETC  '&TEXTL'\n         AGO   .QC0\n.QT2     ANOP                               UNQUOTE TEXT\n&TLEN    SETA  K'&TEXTL(1)-2\n&#TEXTL  SETC  '&TEXTL'(2,&TLEN)\n.QC0     ANOP\n         AIF   (T'&#TEXTC EQ 'O').BP1       BYPASS IF COLOR IS MISSING\n         AIF   ('&#TEXTC'(1,1) EQ '''').QC2 IF QUOTED GO UNQUOTE\n.QC1     ANOP                               UNQUOTE TEXT\n&CLEN    SETA  K'&#TEXTC\n&#TEXTC  SETC  '&#TEXTC'\n         AGO   .QC3\n.QC2     ANOP                               UNQUOTE TEXT\n&CLEN    SETA  K'&#TEXTC-2\n&#TEXTC  SETC  '&#TEXTC'(2,&CLEN)\n.QC3     ANOP\n         AIF   (&TLEN GT &CLEN).E1          ERRO IF LENGTH < TEXT LEN\n.BP1     ANOP\n.QH0     ANOP\n         AIF   (T'&#TEXTH EQ 'O').BP2       BYPASS IF COLOR IS MISSING\n         AIF   ('&#TEXTH'(1,1) EQ '''').QH2 IF QUOTED GO UNQUOTE\n.QH1     ANOP                               UNQUOTE TEXT\n&HLEN    SETA  K'&#TEXTH\n&#TEXTH  SETC  '&#TEXTH'\n         AGO   .QH3\n.QH2     ANOP                               UNQUOTE TEXT\n&HLEN    SETA  K'&#TEXTH-2\n&#TEXTH  SETC  '&#TEXTH'(2,&HLEN)\n.QH3     ANOP\n         AIF   (&TLEN GT &HLEN).E2          ERRO IF LENGTH < TEXT LEN\n.BP2     ANOP\n&#NAME   SETC '&NAME'\n.*--------------------------------------------------------------------*\n.LOOP1   AIF   (&#REP LT 1).LOOP1E\n*---------------------------------------------------------------------*\n&LCTR    SETA  1                            LOOP COUNTER\n.LOOP2   ANOP\n         AIF   (&LCTR GT &TLEN).LOOP2E\n.*--------------------------------------------------------------------*\n.TSTCO1  AIF   (T'&#TEXTC EQ 'O').TSTHI1    TEST HILITE IF NO COLOR\n&CCOL    SETC  '&#TEXTC'(&LCTR,1)\n         AIF   ('&CCOL' EQ ' ').TSTHI1 KEEP LAST IF OMITTED\n&#NAME   DC   X'2842'                  COLOR CAHARACTER ATTRIBUTE\n&#NAME   SETC ' '\n         AIF   ('&CCOL' EQ 'B').B1\n         AIF   ('&CCOL' EQ 'G').G1\n         AIF   ('&CCOL' EQ 'O').O1\n         AIF   ('&CCOL' EQ 'P').P1\n         AIF   ('&CCOL' EQ 'R').R1\n         AIF   ('&CCOL' EQ 'T').T1\n         AIF   ('&CCOL' EQ 'W').W1\n         AIF   ('&CCOL' EQ 'Y').Y1\n         AIF   ('&CCOL' EQ 'b').B1\n         AIF   ('&CCOL' EQ 'g').G1\n         AIF   ('&CCOL' EQ 'o').O1\n         AIF   ('&CCOL' EQ 'p').P1\n         AIF   ('&CCOL' EQ 'r').R1\n         AIF   ('&CCOL' EQ 't').T1\n         AIF   ('&CCOL' EQ 'w').W1\n         AIF   ('&CCOL' EQ 'y').Y1\n         AGO   .E3\n.B1      ANOP\n&CCOL    SETC  'F1'\n         DC   X'&CCOL'                 COLOR = BLUE\n         AGO   .TSTHI1\n.G1      ANOP\n&CCOL    SETC  'F4'\n         DC   X'&CCOL'                 COLOR = GREEN\n         AGO   .TSTHI1\n.O1      ANOP\n&CCOL    SETC  '00'\n         DC   X'&CCOL'                 COLOR = OFF\n         AGO   .TSTHI1\n.P1      ANOP\n&CCOL    SETC  'F3'\n         DC   X'&CCOL'                 COLOR = PINK\n         AGO   .TSTHI1\n.R1      ANOP\n&CCOL    SETC  'F2'\n         DC   X'&CCOL'                 COLOR = RED\n         AGO   .TSTHI1\n.T1      ANOP\n&CCOL    SETC  'F5'\n         DC   X'&CCOL'                 COLOR = TURQUOISE\n         AGO   .TSTHI1\n.W1      ANOP\n&CCOL    SETC  'F7'\n         DC   X'&CCOL'                 COLOR = WHITE\n         AGO   .TSTHI1\n.Y1      ANOP\n&CCOL    SETC  'F6'\n         DC   X'&CCOL'                 COLOR = YELLOW\n.*--------------------------------------------------------------------*\n.TSTHI1  AIF   (T'&#TEXTH EQ 'O').SETCH\n&CHIL    SETC  '&#TEXTH'(&LCTR,1)           SET HILITE CHARACTER\n         AIF   ('&CHIL' EQ ' ').SETCH  KEEP LAST IF OMITTED\n         DC   X'2841'                  HILITE CHARACTER ATTRIBUTE\n         AIF   ('&CHIL' EQ 'B').B2\n         AIF   ('&CHIL' EQ 'O').O2\n         AIF   ('&CHIL' EQ 'R').R2\n         AIF   ('&CHIL' EQ 'U').U2\n         AIF   ('&CHIL' EQ 'b').B2\n         AIF   ('&CHIL' EQ 'o').O2\n         AIF   ('&CHIL' EQ 'r').R2\n         AIF   ('&CHIL' EQ 'u').U2\n         AGO   .E4\n.B2      ANOP\n&CHIL    SETC  'F1'\n         DC   X'&CHIL'                 HIGHLIHT = BLINK\n         AGO   .SETCH\n.O2      ANOP\n&CHIL    SETC  '00'\n         DC   X'&CHIL'                 HIGHLIHT = OFF\n         AGO   .SETCH\n.R2      ANOP\n&CHIL    SETC  'F2'\n         DC   X'&CHIL'                 HIGHLIHT = REVERSE\n         AGO   .SETCH\n.U2      ANOP\n&CHIL    SETC  'F4'\n         DC   X'&CHIL'                 HIGHLIHT = UNDERSCORE\n.*\n.*--------------------------------------------------------------------*\n.*\n.SETCH   ANOP\n&CHAR    SETC  '&#TEXTL'(&LCTR,1)      SET HILITE CHARACTER\n         AIF  ('&CHAR' EQ '''').DBLCH  REMOVE DOUBLE CHARACTER\n         AIF  ('&CHAR.&CHAR' NE '&&').DEFCH REMOVE DOUBLE CHARACTER\n.DBLCH   ANOP\n&CHAR    SETC  '&CHAR.&CHAR'\n&LCTR    SETA  &LCTR+1\n.DEFCH   ANOP\n&CHAR    SETC  '''&CHAR''            &CHAR'\n         DC   C&CHAR.                  CHARACTER\n&LCTR    SETA  &LCTR+1\n         AGO   .LOOP2\n.LOOP2E  ANOP\n&#REP    SETA &#REP-1\n         AGO   .LOOP1\n*---------------------------------------------------------------------*\n.LOOP1E  ANOP\n         AIF   (T'&RESET EQ 'O').EXIT       EXIT IF RESET NOT REQUESTED\n         AIF   ('&RESET'(1,1) EQ 'N').EXIT  EXIT IF RESET NOT REQUESTED\n.TSTCO2  AIF   (T'&#TEXTC EQ 'O').TSTHI2    TEST HILITE IF NO COLOR\n         DC   X'284200'                TURN ON DEFAULT COLOR\n.TSTHI2  AIF   (T'&#TEXTH EQ 'O').EXIT      EXIT IF NO HILITE\n         DC   X'284100'                TURN ON DEFAULT HILITE\n         AGO   .EXIT\n.E0      MNOTE 12,'MISSING PARAMETERS ????'\n         AGO   .EXIT\n.E1      MNOTE 12,'TEXTC PARAMETER DOES NOT CORESPOND WITH TEXT LENGTH'\n         AGO   .EXIT\n.E2      MNOTE 12,'TEXTH PARAMETER DOES NOT CORESPOND WITH TEXT LENGTH'\n         AGO   .EXIT\n.E3      MNOTE 12,'INVALID COLOR ATTRIBUTE CHARACTER ''&CCOL'''\n         AGO   .EXIT\n.E4      MNOTE 12,'INVALID HILITE ATTRIBUTE CHARACTER ''&CHIL'''\n         AGO   .EXIT\n.EXIT    ANOP\n         POP   PRINT\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHHEXMAC": {"ttr": 9731, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\"\\x00\\x92 _\\x01\\x01\\x16/\\x028\\x01;\\x01/\\x00\\x00\\xd7\\xe2\\xc1\\xe9\\xd2@@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1992-07-23T00:00:00", "modifydate": "2001-06-11T02:38:22", "lines": 315, "newlines": 303, "modlines": 0, "user": "PSAZK"}, "text": "         MACRO\n&NAME    CHHEXMAC &SOURCE,&TARGET,&LENGTH,&ERRRTN,&MF=,&LIST=NO,       +\n               &LABEL=YES,&HELP=NO\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'CHHEXMAC' parameter    *\n* and it's use pass parameter 'HELP=Yes'.                             *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n*   CONVERT CHARACTERS TO HEX.                                        *\n*   --------------------------                                        *\n*           N O T E - N O T E - N O T E - N O T E - N O T E           *\n*                                                                     *\n*   This routine saves and uses general registers 1, 14 & 15.         *\n*   R14 and R15 will be altered on return from the macro. Do NOT use  *\n*   these two registers to as parameter addresses.                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Parameters:-                                                      *\n*       1. Source                                                     *\n*       2. Target                                                     *\n*       3. Length                                                     *\n*       4. Error routine in case of error or a one byte (two character*\n*          hex value  quoted, ie. 'xx') value to convert invalid      *\n*          characters to and then continue.                           *\n*          NOTE - An invalid supplied HEX substitution parameter will *\n*                 result in X'00' substitution.                       *\n*       5. MF=E/L -  Macro format for re-entrant programs             *\n*       6. LABEL=YES/NO - Generate data labels. Used for reentrant    *\n*                         programs with MF=L and you wish to move the *\n*                         constant value from the CSECT over the      *\n*                         the getmain'ed DSECT.                       *\n*                         The default is 'YES'. the parameter can be  *\n*                         ignored if note 2 option is observed.       *\n*       7. LIST=YES/NO - Option to generate macro expansion or not    *\n*       8. HELP=YES/NO - Option to print these help details. default  *\n*                        is 'YES'.                                    *\n*                                                                     *\n*                                                                     *\n*   If \"error routine\" = 'xx' (quoted) format then on return from     *\n*   macro, R15 will be:-                                              *\n*       set to - 0 if all conversion OK                               *\n*       set to - 8 if conversion error found                          *\n*                                                                     *\n*   NOTE:-                                                            *\n*       1. Parameters may be passed in registers using the (Rn) or    *\n*          d(Rn) (for register displacement) notation.                *\n*          NOTE - cannot have digits).                                *\n*       2. For execute form of the macro (MF=E) the first occurence of*\n*          the macro must be the first one executed. If a branch      *\n*          causes a initial loop around it, insert a dummy macro to   *\n*          perform a conversion into work areas or use the LABEL=NO   *\n*          parameter.                                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n.*--------------------------------------------------------------------*\n         GBLC  &CXBAL,&CXBYPAS,&CXLOOP,&CXBYTES,&CXBYTE1,&CXBYTE2\n         GBLC  &CXBADAT,&CXTABLE,&CXIGERR,&CXER1BR,&CXER2BR\n         GBLC  &CXER1BS,&CXER2BS,&CXRTADR\n         GBLC  &CXCHOK1,&CXERSUB,&CXERRCH,&CXRTCOD,&CXCHXT1,&CXR1SAV\n         GBLB  &CX1NAME,&CX1ST\n         LCLC  &#LENGTH,&#SOURCE,&#TARGET,&#ERRRTN\n         LCLA  &LEN\n.*--------------------------------------------------------------------*\n         GBLC  &REGSAVR,&REGSMCR\n         GBLB  &REGSFLG,&REGDFLG\n         AIF   (&REGSFLG).A$RS\n&REGSAVR SETC  'GB'.'&SYSNDX'.'#'\n&REGSFLG SETB  1\n&REGSMCR SETC  'CHHEXMAC'\n.A$RS    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (&CX1NAME).A$$0\n         LCLC  &TNAME\n&TNAME   SETC  'CX'.'&SYSNDX'\n&CXTABLE SETC  '&TNAME'.'01'\n&CXBYTES SETC  '&TNAME'.'02'\n&CXBYTE1 SETC  '&TNAME'.'03'\n&CXBYTE2 SETC  '&TNAME'.'04'\n&CXERRCH SETC  '&TNAME'.'05'\n&CXR1SAV SETC  '&TNAME'.'06'\n&CXER1BS SETC  '&TNAME'.'07'\n&CXER2BS SETC  '&TNAME'.'08'\n&CXRTADR SETC  '&TNAME'.'09'\n&CXRTCOD SETC  '&TNAME'.'10'\n&CXBAL   SETC  '&TNAME'.'11'\n&CXLOOP  SETC  '&TNAME'.'12'\n&CXIGERR SETC  '&TNAME'.'13'\n&CXCHOK1 SETC  '&TNAME'.'14'\n&CXBADAT SETC  '&TNAME'.'15'\n&CXBYPAS SETC  '&TNAME'.'16'\n&CXCHXT1 SETC  '&TNAME'.'EX'\n&CX1NAME SETB  1\n         AGO   .A$$1                    BYPASS 2ND. INVOCATION\n.*--------------------------------------------------------------------*\n.A$$0    ANOP\n&CXCHXT1 SETC  'CX'.'&SYSNDX'.'EX'\n.A$$1    ANOP\n         AIF   ('&MF' EQ 'L').RENT1     IF MF=L PARM PASSED BYPASS\n         AIF   (T'&SOURCE EQ 'O').E1\n         AIF   (T'&TARGET EQ 'O').E2\n         AIF   (T'&LENGTH EQ 'O').E3\n         AIF   (T'&ERRRTN EQ 'O').E4\n.*--------------------------------------------------------------------*\n         AIF   ('&SOURCE'(1,1) EQ '(').A$01\n&#SOURCE SETC  '&SOURCE'\n         AGO   .A$02\n.A$01    ANOP\n&#SOURCE SETC  '0(&SOURCE(1))'\n.A$02    ANOP\n         AIF   ('&TARGET'(1,1) EQ '(').A$03\n&#TARGET SETC  '&TARGET'\n         AGO   .A$04\n.A$03    ANOP\n&#TARGET SETC  '0(&TARGET(1))'\n.A$04    ANOP\n&CXERSUB SETC  '''00'''                       SET X'00' FOR SUB\n&CXER1BR SETC  '&CXBADAT'                     SET ERROR BRANCH ADDRESS\n&CXER2BR SETC  '&CXIGERR'                     SET IGNORE BRANCH ADDRESS\n         AIF   ('&ERRRTN'(1,1) NE '''').A$07\n&CXERSUB SETC  '&ERRRTN'                      SET IGNORE BRANCH ADDRESS\n&CXER1BR SETC  '&CXIGERR'                     SET IGNORE BRANCH ADDRESS\n         AGO   .A$10\n.A$07    ANOP\n         AIF   ('&ERRRTN'(1,1) EQ '(').A$08\n&#ERRRTN SETC  '&ERRRTN'\n         AGO   .A$09\n.A$08    ANOP\n&#ERRRTN SETC  '0(&ERRRTN(1))'\n.A$09    ANOP\n&CXER2BR SETC  '&#ERRRTN'                     SET ERROR ROUTINE ADDRESS\n.A$10    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (&CX1ST).A$11           IF NOT 1ST. TIME THRU\n         AIF   (T'&MF EQ 'O').NONR1    IF NON-RE PROGRAM BYPASS\n*  EXEC FORM OF MACRO 'CHHEXMAC'                                      *\n*---------------------------------------------------------------------*\n.*       MVI   &CXTABLE,X'00'          HEX FILL FIRST BYTE THEN RIPPLE\n.*       MVC   &CXTABLE.+1(192),&CXTABLE  FILL REST\n.*       MVC   &CXTABLE.+193(06),=X'0A0B0C0D0E0F'\n.*       MVC   &CXTABLE.+199(41),&CXTABLE FILL REST\n.*       MVC   &CXTABLE.+240(10),=X'F0010203040506070809'\n.*       MVC   &CXTABLE.+250(06),&CXTABLE FILL REST\n         B     &CXBYPAS                BYPASS COMMON CODE\n         AGO   .RENT2                  BYPASS NON-RE PROCESS\n.NONR1   ANOP\n*  NORMAL FORM OF MACRO 'CHHEXMAC'                                    *\n*---------------------------------------------------------------------*\n         B     &CXBYPAS                BYPASS DATA + COMMON CODE\n*---------------------------------------------------------------------*\n         AGO   .NONR2                  BYPASS RE-ENT PROCESS\n.RENT1   ANOP\n*---------------------------------------------------------------------*\n*  LIST FORM OF MACRO 'CHHEXMAC'                                      *\n*---------------------------------------------------------------------*\n.NONR2   ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&MF EQ 'O').LABON\n         AIF   ('&LABEL'(1,1) EQ 'Y').LABON\n         DS    0CL256\n         DC    193X'0'\n         DC    X'0A0B0C0D0E0F'\n         DC    41X'0'\n         DC    X'F0010203040506070809' NOTE - AS ZERO IS VALID\n*               /|\\                    CHAR 'F0' SUBSTITUTED AND\n*                                      LATER CHANGED\n         DC    6X'0'\n         DS    0CL2                    BOTH BYTE\n         DS    CL1                     1ST. BYTE\n         DS    CL1                     1ST. BYTE\n         DS    CL2                     CHARACTER SUBSTITUTION\n         DC    4F'0'                   REGISTER 1 SAVE AREA B/C TRT\n         DC    F'0'                    ERROR EXIT SAVE ADDRESS\n         DC    F'0'                    ERROR ROUTINE SAVE ADDRESS\n         DC    F'0'                    RETURN ADDRESS\n         DC    H'0'                    RETURN CODE SAVE AREA\n         AGO   .LABDONE\n.LABON   ANOP\n&CXTABLE DS    0CL256\n         DC    193X'0'\n         DC    X'0A0B0C0D0E0F'\n         DC    41X'0'\n         DC    X'F0010203040506070809' NOTE - AS ZERO IS VALID\n*               /|\\                    CHAR 'F0' SUBSTITUTED AND\n*                                      LATER CHANGED\n         DC    6X'0'\n&CXBYTES DS    0CL2                    BOTH BYTE\n&CXBYTE1 DS    CL1                     1ST. BYTE\n&CXBYTE2 DS    CL1                     1ST. BYTE\n&CXERRCH DS    CL2                     CHARACTER SUBSTITUTION\n&CXR1SAV DC    4F'0'                   REGISTER 1 SAVE AREA B/C TRT\n&CXER1BS DC    F'0'                    ERROR EXIT SAVE ADDRESS\n&CXER2BS DC    F'0'                    ERROR ROUTINE SAVE ADDRESS\n&CXRTADR DC    F'0'                    RETURN ADDRESS\n&CXRTCOD DC    H'0'                    RETURN CODE SAVE AREA\n.LABDONE ANOP\n.*--------------------------------------------------------------------*\n.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *\n.*--------------------------------------------------------------------*\n         AIF   (&REGDFLG).A$RD\n         AIF   ('&LABEL'(1,1) EQ 'Y').LABON2 BYPASS IF LABEL REQUIRED\n         AIF   ('&REGSMCR' NE 'CHHEXMAC').A$RD\n         DS    16F                     REGISTER SAVE AREA\n         AGO   .A$RD                   DO NOT SET FLAG IF LABEL REQD\n.LABON2  ANOP\n&REGDFLG SETB  1\n&REGSAVR DS    16F                     REGISTER SAVE AREA\n.A$RD    ANOP\n.*--------------------------------------------------------------------*\n.RENT2   ANOP\n*---------------------------------------------------------------------*\n         AIF   ('&MF' EQ 'L').EXIT\n*                                                                     *\n*        CONVERT CHARACTERS TO HEX.                                   *\n*                                                                     *\n*         R1=SOURCE, R14=TARGET, R15=LENGTH                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n&CXBAL   DS    0H\n         XC    &CXRTCOD,&CXRTCOD       INITIALISE RETURN CODE\n         AIF   (T'&MF EQ 'O').NONR3    IF NON-RE PROGRAM BYPASS\n         CLC   &CXTABLE.+193(06),=X'0A0B0C0D0E0F' Q. CONSTANTS SET\n         BE    &CXLOOP                               Y. BYPASS\n         MVI   &CXTABLE,X'00'          HEX FILL FIRST BYTE THEN RIPPLE\n         MVC   &CXTABLE.+1(192),&CXTABLE  FILL REST\n         MVC   &CXTABLE.+193(06),=X'0A0B0C0D0E0F'\n         MVC   &CXTABLE.+199(41),&CXTABLE FILL REST\n         MVC   &CXTABLE.+240(10),=X'F0010203040506070809'\n         MVC   &CXTABLE.+250(06),&CXTABLE FILL REST\n.NONR3   ANOP\n&CXLOOP  DS    0H\n         MVC   &CXBYTES.(2),0(1)\n         STM   14,1,&CXR1SAV           SAVE 1 BECAUSE OF TRT\n         MVI   &CXTABLE,X'F0'          SET HEX 00 TO PASS\n         L     14,&CXER1BS             LOAD ERROR EXIT ADDRESS\n         TRT   &CXBYTE1.(1),&CXTABLE   Q. IS IT IN &CXTABLE\n         BZR   14                         N. ERROR\n         TRT   &CXBYTE2.(1),&CXTABLE   Q. IS IT IN &CXTABLE\n         BZR   14                         N. ERROR\n         B     &CXCHOK1                BOTH BYTES OK\n&CXIGERR DS    0H\n         MVC   &CXRTCOD.(2),=H'8'      SET ERROR CODE\n         MVC   &CXBYTES.(2),&CXERRCH   SET ERROR HEX SUBSTITUTION\n&CXCHOK1 DS    0H\n         MVI   &CXTABLE,X'00'          RESET HEX 00\n         TR    &CXBYTES.(2),&CXTABLE   TRANSLATE BOT CHARS\n         NC    &CXBYTES.(2),=X'0F0F'   TURN HIGH NIBL OFF FOR 0 => 'F0'\n         LM    14,1,&CXR1SAV           RESTORE 1 BECAUSE OF TRT\n         PACK  0(1,14),&CXBYTE1        SWAP NIB OF LEFT &CXBYTE AND STO RE\n         OC    0(1,14),&CXBYTE2        OVERLAY 2ND &CXBYTE OVER FIRST\n         LA    1,2(1)                  UP SOURCE BY TWO\n         LA    14,1(14)                UP DESTINATION BY 1\n         BCTR  15,0                    DECREMENT LOOP COUNTER\n         BCTR  15,0                           BY 2\n         LTR   15,15                   Q. REACHED THE END\n         BP    &CXLOOP                    N. LOOP\n         L     14,&CXRTADR             LOAD RETURN ADDRESS\n         BR    14                      RETURN\n&CXBADAT DS    0H\n         LM    14,12,&REGSAVR          RESTORE REGISTERS\n         LH    15,&CXRTCOD             SET RETURN CODE\n         L     14,&CXER2BS             LOAD ERROR ROUTINE ADDRESS\n         BR    14                      BRANCH TO ERROR ROUTINE\n&CXBYPAS DS    0H\n.A$11    ANOP\n         STM   14,12,&REGSAVR          SAVE REGISTERS\n         MVC   &CXERRCH.(2),=C&CXERSUB MOVE HEX ERROR SUBSTITUTE CHAR\n         LA    14,&CXER1BR             LOAD EXIT ADDRESS\n         ST    14,&CXER1BS             SAVE EXIT ADDRESS\n         LA    14,&CXER2BR             LOAD ERROR ROUTINE ADDRESS\n         ST    14,&CXER2BS             SAVE ERROR ROUTINE ADDRESS\n         LA    14,&CXCHXT1             LOAD RETURN ADDRESS\n         ST    14,&CXRTADR             STORE RETURN ADDRESS\n         LA    14,&#TARGET             SET UP DESTINATION ADDRESS\n         AIF   ('&LENGTH'(1,1) NE '(').ACTLEN\n&LEN     SETA  K'&LENGTH-2\n&#LENGTH SETC  '&LENGTH'(2,&LEN)       REGISTER\n         LR    15,&#LENGTH             LENGTH TO BE CONVERTED\n         AGO   .FINLMV                 PASS AROUND\n.ACTLEN  ANOP\n         LA    15,&LENGTH              LENGTH TO BE CONVERTED\n.FINLMV  ANOP\n         LA    1,&#SOURCE              SET UP TO SOURCE ADDRESS\n         B     &CXBAL                  GO TO HEX => CHAR ROUTINE\n&CXCHXT1 DS    0H\n         LM    14,12,&REGSAVR          RESTORE REGISTERS\n         LH    15,&CXRTCOD             SET RETURN CODE\n*---------------------------------------------------------------------*\n&CX1ST   SETB  1\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E1      MNOTE 8,'CHHEX REQUIRES A SOURCE FIELD'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E2      MNOTE 8,'CHHEX REQUIRES A TARGET FIELD'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E3      MNOTE 8,'CHHEX REQUIRES A LENGTH'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E4      MNOTE 8,'CHHEX REQUIRES A CONVERSION ERROR ROUTINE ADDRESS'\n.EXIT    ANOP\n         POP   PRINT\n         MEXIT\n.*--------------------------------------------------------------------*\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CICS@": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00A\\x00\\x96\\x15_\\x00\\x96%_\\x12C\\x01\\xb4\\x01E\\x00\\x00\\xe3\\xf6\\xf6\\xd2\\xd2\\xd2@@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "1996-06-03T00:00:00", "modifydate": "1996-09-11T12:43:41", "lines": 436, "newlines": 325, "modlines": 0, "user": "T66KKK"}, "text": "         MACRO\n&NAME    CICS@ &ADDR,                            Returned address      +\n               &BASE=15,                         Base for return @     +\n               &CSA=DFHCSADS,                    CSA DSECT name        +\n               &CWA=CWA,                         CWA DSECT name        +\n               &TCA=DFHTCADY,                    TCA DSECT name        +\n               &CSA@=,                           CSA return address    +\n               &CWA@=,                           CWA return address    +\n               &TCA@=,                           TCA return address    +\n               &CICS=NO,                         CICS request          +\n               &VER=3.3,                         CICS version          +\n               &USING=YES,                       Retaing addresability +\n               &LIST=YES,&HELP=NO,               Misc listing params   +\n               &MF=E                             Macro format\n         AIF   ('&MF' EQ 'L').A$HELPE         Bypass if list format\n         AIF   ('&LIST'(1,1) NE 'N').A$XX     Bypass if listing req'd\n         PUSH  PRINT\n         PRINT OFF\n.A$XX    ANOP\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP   Go process help listing\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'CICS@' parameter and   *\n* it's use, pass parameter 'HELP=Yes'.                                *\n.*--------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro to set specified register to a specific CICS address          *\n*   established from MVS control block navigation.                    *\n*   Available addresses are: CSA, CWA, TCA(User), TCAS(ystem).        *\n*                                                                     *\n* Format:                                                             *\n*   Exec -  CICS@ CWA,BASE=3                                          *\n*   List -  CICS@ (@@@,TCA),MF=L                                      *\n*                                                                     *\n* Parameters:                                                         *\n*   1. addr      - One of the accepted reserved words for MF=E.       *\n*                      CSA, CWA, TCA/TCAU or TCAS.                    *\n*                  CSA is the default (default will turn USING off).  *\n*                                                                     *\n*                  For MF=L you need to specify a string of DSECTS    *\n*                  seperated by commas and enclosed in parentheses.   *\n*                  By default or if the first parameter is '@@@'      *\n*                  the following DSECTS will automatically be included*\n*                     PSA, CVT, TCB, AFCD and CSA as follows:         *\n*                            IHAPSA                                   *\n*                            CVT      DSECT=YES,LIST=NO    CVT        *\n*                            IKJTCB                                   *\n*                            DFHAFCD TYPE=DSECT                       *\n*                            COPY DFHCSADS                            *\n*                                                                     *\n*                  Aditional DSECTS are TCA, TCT.                     *\n*                            DFHTCA CICSYST=YES                       *\n*                            DFHTCTZE CICSYST=YES                     *\n*                  If you want the TCA DSECT as well as the defaults, *\n*                  code the first positiuonal parameter as:           *\n*                     (@@@,TCA)                                       *\n*                  If you want all the dafault and the TCA without    *\n*                  say the CVT you will have to explicitly list all   *\n*                  required:  eg.                                     *\n*                     (PSA,TCB,AFCD,CSA,TCA)                          *\n*   2. BASE=n    - Acceptable notation for loading the address into   *\n*                  a register (default is 15).                        *\n*   3. CSA=ccc   - CSA DSECT name. Default is 'DFHCSADS'.             *\n*   4. CWA=ccc   - CWA DSECT name. Default is 'CWA'.                  *\n*   5. TCA=ccc   - TCA DSECT name. Default is 'DFHTCADY'.             *\n*   6. CSA@=ccc  - Variable to store CSA address in.                  *\n*   7. CWA@=ccc  - Variable to store CWA address in.                  *\n*   8. TCA@=ccc  - Variable to store TCA (user) address in unless the *\n*                  requested address is TCAS with this parameter      *\n*                  whereby the system's address will be stored.       *\n*   9. USING=Y/N - Establish addresability between base and DSECT.    *\n*                  Default is 'YES'.                                  *\n*                  Will be forced to 'NO' if address is defaulted.    *\n*  10. VER=n.n   - CICS version.                                      *\n*  11. CICS=Y/N  - Used to determine how the CWA (and TCA if required *\n*                  is obtained. 'NO' forces MVS control block         *\n*                  naigation while 'YES' will issue an 'EXEC CICS     *\n*                    ADDRESS CWA(Rx)'.                                *\n*                  Default is 'NO'.                                   *\n*  12. LIST=Y/N  - Generate or suppress macro expansion, (YES/NO).    *\n*                  Default is 'YES'.                                  *\n*  13. HELP=Y/N  - Display these help comments, (YES/NO).             *\n*                  Default is 'NO'.                                   *\n*  14. MF=E/L    - Macro format.                                      *\n*                    E - EXEC format of macro (default)               *\n*                    L - LIST format of macro.                        *\n*                                                                     *\n.*--------------------------------------------------------------------*\n.A$HELPE ANOP\n         LCLC  &B,&DS,&LOSTCSA,&LUSE,&ADDRN,&TCAUSG,&USINGN,&VERN\n         AIF   (T'&NAME EQ 'O').NONAME1  Bypass if NAME missing\n&NAME    DS    0H\n.NONAME1 ANOP\n         AIF   ('&MF' EQ 'L').LIST1    Process LIST format\n         AIF (T'&BASE EQ 'O').E002     Must have a base (cannot be     +\n                                         explicitly turned off).\n&B       SETC  '&BASE'                 Set base (work) register\n&LOSTCSA SETC  'N'                     Turn lost CSA a'bility off\n&ADDRN   SETC  '&ADDR'                 Set work variable\n&VERN    SETC  '&VER'                  Set CICS version\n&USINGN  SETC  '&USING'                Set work variable\n         AIF (T'&ADDRN NE 'O').EXECFM1 Bypass if not omitted\n&ADDRN   SETC  'CSA'                   Set CSA as default address\n&USINGN  SETC  'NO'                    Set USING requirements off\n.EXECFM1 ANOP\n*---------------------------------------------------------------------*\n*    EXEC form of macro 'CICS@'                                       *\n*---------------------------------------------------------------------*\n         AIF ('&CICS'(1,1) NE 'Y').NOTCICS  Bypass if not CICS request\n         EXEC CICS ADDRESS CWA(&B)\n         AIF ('&USINGN' NE 'YES').MEXIT Exit if USING not required\n         USING CWA,&B                      ADDRESSABILITY TO CWA\n&LUSE    SETC   'CWA'                  Indicate last user\n         AGO   .MEXIT                  Exit MACRO\n.NOTCICS ANOP\n         AIF (T'&VER NE 'O').VERVER1   Bypass if version passed\n.*--------------------------------------------------------------------*\n.*\n.*\n.*\n&VERN    SETC '3.3'                    Default version\n.*\n.*\n.*\n.*--------------------------------------------------------------------*\n.VERVER1 ANOP\n         AIF ('&VERN' EQ '3.1').VALVER1      Valid CICS version\n         AIF ('&VERN' EQ '3.3').VALVER1      Valid CICS version\n         AGO   .E000                   Tell of error\n.VALVER1 ANOP\n         AIF ('&ADDRN' EQ 'CSA').VALADDR     Valid CSA request\n         AIF ('&ADDRN' EQ 'CWA').VALADDR     Valid CWA request\n         AIF ('&ADDRN'(1,3) EQ 'TCA').VALADDR Valid TCA request\n         AGO   .E001                   Tell of error\n.VALADDR ANOP\n         L     &B,PSATOLD-PSA(,0)          OLD TCB POINTER (FROM PSA)\n         L     &B,TCBMDIDS-TCBFIX(,&B)     TCB EXTENTION\n         L     &B,TCBCAUF-TCBXTNT2(,&B)    AFCB\n         AIF ('&VERN' EQ '3.1').CSA31C1    Set CICS 3.1\n.CSA33C1 ANOP\n         L     &B,AFCSA-DFHAFCB(,&B)       CSA 3.3 OR HIGHER\n         AGO   .CSAVST1               Have CSA set\n.CSA31C1 ANOP\n         LA    &B,512(,&B)                 CSA 3.1 OR LOWER\n         AGO   .CSAVST1               Have CSA set\n.CSAVST1 ANOP\n&LUSE    SETC  'CSA'                   Indicate last user\n         AIF   (T'&CSA@ EQ 'O').GOTCSA Bypass if CSA@ not required\n         ST    &B,&CSA@                    SAVE CSA@\n         NI    &CSA@,X'0F'                 TURN OFF 4 HIGH-ORDER BITS   DPSO7746\n.GOTCSA  ANOP\n         AIF   ('&ADDRN'(1,3) EQ 'TCA').TSTTCA Process TCA* request\n         AIF   (T'&TCA@ NE 'O').TSTTCA Process TCA if TCA@ requested\n         AGO   .SCWA                   Test if CWA required\n.TSTTCA  ANOP\n         AIF   ('&ADDRN'(1,3) NE 'TCA').OKTTCA Bypass address reset\n         AIF   ('&ADDRN' EQ 'TCAS').OKTTCA Process TCA* request\n&ADDRN   SETC  'TCAU'\n.OKTTCA  ANOP\n         L     &B,CSACDTA-&CSA.(,&B)       TCA (USER)\n&TCAUSG  SETC  'DFHTCADS'              Set dsect name\n&LUSE    SETC   'TCAU'                 Indicate who is using\n&LOSTCSA SETC  'Y'                     Set lost CSA addressability\n         AIF ('&ADDRN'(1,3) NE 'TCA').BYPUSR  Bypass if not TCA req\n         AIF ('&ADDRN'(4,1) NE 'S').BYPUSR  Bypass if not SYSTEM req\n         L     &B,TCASYAA-DFHTCADS(,&B)    TCA (SYSTEM)\n&TCAUSG  SETC  'DFHTCADY'              Set dsect name\n&LUSE    SETC  'TCAS'                  Indicate who is using\n.BYPUSR  ANOP\n         AIF   (T'&TCA@ EQ 'O').GOTTCA Bypass if TCA save not required\n         AIF   ('&LUSE' EQ 'TCAU').TCAUMS1 USE THE RIGHT LITERAL\n         ST    &B,&TCA@                    SAVE TCA@ (SYSTEM)\n         AGO   .GOTTCA                 Bupass 'SYSTEM' message\n.TCAUMS1 ANOP\n         ST    &B,&TCA@                    SAVE TCA@ (USER)\n.GOTTCA  ANOP\n.SCWA    ANOP\n         AIF   (T'&CWA@ NE 'O').TSTCWA If CWA@ requested, cont\n         AIF   ('&ADDRN' EQ 'CWA').TSTCWA If CWA requested, cont\n         AGO   .TUSING                 Exit if no other parms\n.TSTCWA  ANOP\n         AIF   ('&LOSTCSA' EQ 'N').SCWAOK Bypass if CSA@ in tact\n         AIF   (T'&CSA@ EQ 'O').E004   Error if missing CSA storage @\n         L     &B,&CSA@                    RESTORE CSA@\n&LUSE    SETC  'CSA'                   Indicate who is using\n.SCWAOK  ANOP\n         L     &B,CSACWAA-&CSA.(,&B)       CWA\n&LUSE    SETC   'CWA'                  Indicate last user\n         AIF   (T'&CWA@ EQ 'O').GOTCWA Bypass if CWA@ not required\n         ST    &B,&CWA@                    SAVE CWA@\n.GOTCWA  ANOP\n.TUSING  ANOP\n         AIF ('&LUSE' EQ '&ADDRN').STUSING Go set using if @ same\n         AIF ('&ADDRN' EQ 'CWA').TUCWA Process CWA restoration\n         AIF ('&ADDRN'(1,3) EQ 'TCA').TUTCA Process TCA restoration\n         AIF   (T'&CSA@ EQ 'O').E004   Error if missing CSA storage @\n         L     &B,&CSA@                    RESTORE CSA@\n&LUSE    SETC  'CSA'                   Indicate who is using\n         AGO  .STUSING                 Go test if using required\n.TUCWA   ANOP\n         AIF   (T'&CWA@ EQ 'O').E005   Error if missing CWA storage @\n         L     &B,&CWA@                    RESTORE CWA@\n&LUSE    SETC  'CSA'                   Indicate who is using\n         AGO  .STUSING                 Go test if using required\n.*\n.TUTCA   ANOP\n         AIF   (T'&TCA@ EQ 'O').E006   Error if missing TCA storage @\n         L     &B,&TCA@                    RESTORE TCA@\n         AGO  .STUSING                 Go test if using required\n.*\n.STUSING ANOP\n         AIF ('&USINGN'(1,1) EQ 'N').MEXIT Exit if not Using\n         AIF ('&LUSE' EQ 'CSA').USECSA Set CSA for using\n         AIF ('&LUSE' EQ 'CWA').USECWA Set CWA for using\n         AIF   ('&LUSE' EQ 'TCAU').TCAUMS2 Use the right literal\n         USING &TCAUSG,&B                  TCA (SYSTEM) ADDRESSABILITY\n         AGO  .MEXIT\n.TCAUMS2 ANOP\n         USING &TCAUSG,&B                  TCA (USER) ADDRESSABILITY\n         AGO  .MEXIT\n.USECSA  ANOP\n         USING &CSA,&B                     CSA ADDRESSABILITY\n         AGO  .MEXIT\n.USECWA  ANOP\n         USING &CWA,&B                     CWA ADDRESSABILITY\n         AGO  .MEXIT\n*\n.LIST1   ANOP\n.*       LCLC  &ADDR1,&ADDR2,&ADDR3\n.*       LCLC  &ADDR4,&ADDR5,&ADDR6\n.*       LCLC  &ADDR7,&ADDR8,&ADDR9\n         LCLB  &IPSA,&ICVT,&ITCB,&IAFCD,&ICSA,&ITCA,&ITCT\n&ADDR1   SETC  '@@@'\n&ADDR2   SETC  '    '\n&ADDR3   SETC  '    '\n&ADDR4   SETC  '    '\n&ADDR5   SETC  '    '\n&ADDR6   SETC  '    '\n&ADDR7   SETC  '    '\n&ADDR8   SETC  '    '\n&ADDR9   SETC  '    '\n         AIF   (T'&ADDR EQ 'O').LISTIT1 Bypass with defaults\n&ADDR1   SETC  '&SYSLIST(1,1)'\n&ADDR2   SETC  '&SYSLIST(1,2)'\n&ADDR3   SETC  '&SYSLIST(1,3)'\n&ADDR4   SETC  '&SYSLIST(1,4)'\n&ADDR5   SETC  '&SYSLIST(1,5)'\n&ADDR6   SETC  '&SYSLIST(1,6)'\n&ADDR7   SETC  '&SYSLIST(1,7)'\n&ADDR8   SETC  '&SYSLIST(1,8)'\n&ADDR9   SETC  '&SYSLIST(1,9)'\n.LISTIT1 ANOP\n*---------------------------------------------------------------------*\n*    LIST form of macro 'CICS@'                                       *\n*---------------------------------------------------------------------*\n         AIF ('&ADDR1' EQ '@@@').DSPSA\n         AIF ('&ADDR1' EQ 'PSA').DSPSA\n         AIF ('&ADDR2' EQ 'PSA').DSPSA\n         AIF ('&ADDR3' EQ 'PSA').DSPSA\n         AIF ('&ADDR4' EQ 'PSA').DSPSA\n         AIF ('&ADDR5' EQ 'PSA').DSPSA\n         AIF ('&ADDR6' EQ 'PSA').DSPSA\n         AIF ('&ADDR7' EQ 'PSA').DSPSA\n         AIF ('&ADDR8' EQ 'PSA').DSPSA\n         AIF ('&ADDR9' EQ 'PSA').DSPSA\n         AIF (T'&ADDR1 EQ 'O').DSPSA\n         AGO  .T$CVT\n.DSPSA   ANOP\n&IPSA    SETB   1\n.T$CVT   ANOP\n         AIF ('&ADDR1' EQ '@@@').DSCVT\n         AIF ('&ADDR1' EQ 'CVT').DSCVT\n         AIF ('&ADDR2' EQ 'CVT').DSCVT\n         AIF ('&ADDR3' EQ 'CVT').DSCVT\n         AIF ('&ADDR4' EQ 'CVT').DSCVT\n         AIF ('&ADDR5' EQ 'CVT').DSCVT\n         AIF ('&ADDR6' EQ 'CVT').DSCVT\n         AIF ('&ADDR7' EQ 'CVT').DSCVT\n         AIF ('&ADDR8' EQ 'CVT').DSCVT\n         AIF ('&ADDR9' EQ 'CVT').DSCVT\n         AIF (T'&ADDR1 EQ 'O').DSCVT\n         AGO  .T$TCB\n.DSCVT   ANOP\n&ICVT    SETB   1\n.T$TCB   ANOP\n         AIF ('&ADDR1' EQ '@@@').DSTCB\n         AIF ('&ADDR1' EQ 'TCB').DSTCB\n         AIF ('&ADDR2' EQ 'TCB').DSTCB\n         AIF ('&ADDR3' EQ 'TCB').DSTCB\n         AIF ('&ADDR4' EQ 'TCB').DSTCB\n         AIF ('&ADDR5' EQ 'TCB').DSTCB\n         AIF ('&ADDR6' EQ 'TCB').DSTCB\n         AIF ('&ADDR7' EQ 'TCB').DSTCB\n         AIF ('&ADDR8' EQ 'TCB').DSTCB\n         AIF ('&ADDR9' EQ 'TCB').DSTCB\n         AIF (T'&ADDR1 EQ 'O').DSTCB\n         AGO  .T$AFCD\n.DSTCB   ANOP\n&ITCB    SETB   1\n.T$AFCD  ANOP\n         AIF ('&ADDR1' EQ '@@@').DSAFCD\n         AIF ('&ADDR1' EQ 'AFCD').DSAFCD\n         AIF ('&ADDR2' EQ 'AFCD').DSAFCD\n         AIF ('&ADDR3' EQ 'AFCD').DSAFCD\n         AIF ('&ADDR4' EQ 'AFCD').DSAFCD\n         AIF ('&ADDR5' EQ 'AFCD').DSAFCD\n         AIF ('&ADDR6' EQ 'AFCD').DSAFCD\n         AIF ('&ADDR7' EQ 'AFCD').DSAFCD\n         AIF ('&ADDR8' EQ 'AFCD').DSAFCD\n         AIF ('&ADDR9' EQ 'AFCD').DSAFCD\n         AIF (T'&ADDR1 EQ 'O').DSAFCD\n         AGO  .T$CSA\n.DSAFCD  ANOP\n&IAFCD   SETB   1\n.T$CSA   ANOP\n         AIF ('&VERN' EQ '3.1').T$TCA      Bypass CSA DSECT if 3.1\n         AIF ('&ADDR1' EQ '@@@').DSCSA\n         AIF ('&ADDR1' EQ 'CSA').DSCSA\n         AIF ('&ADDR2' EQ 'CSA').DSCSA\n         AIF ('&ADDR3' EQ 'CSA').DSCSA\n         AIF ('&ADDR4' EQ 'CSA').DSCSA\n         AIF ('&ADDR5' EQ 'CSA').DSCSA\n         AIF ('&ADDR6' EQ 'CSA').DSCSA\n         AIF ('&ADDR7' EQ 'CSA').DSCSA\n         AIF ('&ADDR8' EQ 'CSA').DSCSA\n         AIF ('&ADDR9' EQ 'CSA').DSCSA\n         AIF (T'&ADDR1 EQ 'O').DSCSA\n         AGO   .T$TCA\n.DSCSA   ANOP\n&ICSA    SETB   1\n.T$TCA   ANOP\n.*       AIF ('&ADDR1' EQ '@@@').DSTCA\n         AIF ('&ADDR1'(1,3) EQ 'TCA').DSTCA\n         AIF ('&ADDR2'(1,3) EQ 'TCA').DSTCA\n         AIF ('&ADDR3'(1,3) EQ 'TCA').DSTCA\n         AIF ('&ADDR4'(1,3) EQ 'TCA').DSTCA\n         AIF ('&ADDR5'(1,3) EQ 'TCA').DSTCA\n         AIF ('&ADDR6'(1,3) EQ 'TCA').DSTCA\n         AIF ('&ADDR7'(1,3) EQ 'TCA').DSTCA\n         AIF ('&ADDR8'(1,3) EQ 'TCA').DSTCA\n         AIF ('&ADDR9'(1,3) EQ 'TCA').DSTCA\n         AGO   .T$TCT\n.DSTCA   ANOP\n&ITCA    SETB   1\n.T$TCT   ANOP\n.*       AIF ('&ADDR1' EQ '@@@').DSTCT\n         AIF ('&ADDR1' EQ 'TCT').DSTCT\n         AIF ('&ADDR2' EQ 'TCT').DSTCT\n         AIF ('&ADDR3' EQ 'TCT').DSTCT\n         AIF ('&ADDR4' EQ 'TCT').DSTCT\n         AIF ('&ADDR5' EQ 'TCT').DSTCT\n         AIF ('&ADDR6' EQ 'TCT').DSTCT\n         AIF ('&ADDR7' EQ 'TCT').DSTCT\n         AIF ('&ADDR8' EQ 'TCT').DSTCT\n         AIF ('&ADDR9' EQ 'TCT').DSTCT\n         AGO   .T$XXX\n.DSTCT   ANOP\n&ITCT    SETB   1\n.T$XXX   ANOP\n.T$$$$   ANOP\n.*--------------------------------------------------------------------*\n         AIF   ('&LIST'(1,1) NE 'N').A$X1     Bypass if listing req'd\n.NXT10   ANOP\n         AIF   (NOT &IPSA).NXT11    Bypass if required\n*        IHAPSA\n.NXT11   ANOP\n         AIF   (NOT &ICVT).NXT12    Bypass if required\n*        CVT      DSECT=YES,LIST=NO    CVT\n.NXT12   ANOP\n         AIF   (NOT &ITCB).NXT13    Bypass if required\n*        IKJTCB\n.NXT13   ANOP\n         AIF   (NOT &IAFCD).NXT14   Bypass if required\n*        DFHAFCD TYPE=DSECT\n.NXT14   ANOP\n         AIF   (NOT &ICSA).NXT15    Bypass if required\n*        COPY DFHCSADS\n.NXT15   ANOP\n         AIF   (NOT &ITCA).NXT16    Bypass if required\n*        DFHTCA CICSYST=YES\n.NXT16   ANOP\n         AIF   (NOT &ITCT).NXT17    Bypass if required\n*        DFHTCTZE CICSYST=YES\n.NXT17   ANOP\n.*--------------------------------------------------------------------*\n         PUSH  PRINT\n         PRINT OFF\n.A$X1    ANOP\n.*--------------------------------------------------------------------*\n.NXT20   ANOP\n         AIF   (NOT &IPSA).NXT21    Bypass if required\n         IHAPSA\n.NXT21   ANOP\n         AIF   (NOT &ICVT).NXT22    Bypass if required\n         CVT      DSECT=YES,LIST=NO    CVT\n.NXT22   ANOP\n         AIF   (NOT &ITCB).NXT23    Bypass if required\n         IKJTCB\n.NXT23   ANOP\n         AIF   (NOT &IAFCD).NXT24   Bypass if required\n         DFHAFCD TYPE=DSECT\n.NXT24   ANOP\n         AIF   (NOT &ICSA).NXT25    Bypass if required\n         COPY DFHCSADS\n.NXT25   ANOP\n         AIF   (NOT &ITCA).NXT26    Bypass if required\n         DFHTCA CICSYST=YES\n.NXT26   ANOP\n         AIF   (NOT &ITCT).NXT27    Bypass if required\n         DFHTCTZE CICSYST=YES\n.NXT27   ANOP\n.*--------------------------------------------------------------------*\n         AGO   .MEXIT                       Exit macro\n*---------------------------------------------------------------------*\n.E000    MNOTE 12,'CICS@ - INVALID VERSION VALID - 3.1 or 3.3'\n         AGO   .MEXIT                       Exit macro\n.E001    MNOTE 12,'CICS@ - INVALID ADDRESS REQUESTED'\n         AGO   .MEXIT                       Exit macro\n.E002    MNOTE 12,'CICS@ REQUIRES A BASE REGISTER PARAMETER'\n         AGO   .MEXIT                       Exit macro\n.E003    MNOTE 12,'CICS@ INVALID ARRSESS REQUEST'\n         AGO   .MEXIT                       Exit macro\n.E004    MNOTE 12,'CANNOT RESTORE CSA@ AS IT IS NOT STORED'\n         AGO   .MEXIT                       EXIT MACRO\n.E005    MNOTE 12,'CANNOT RESTORE CWA@ AS IT IS NOT STORED'\n         AGO   .MEXIT                       EXIT MACRO\n.E006    MNOTE 12,'CANNOT RESTORE TCA@ AS IT IS NOT STORED'\n         AGO   .MEXIT                       EXIT MACRO\n.*--------------------------------------------------------------------*\n.MEXIT   ANOP\n         AIF   ('&LIST' NE 'N').A$ZZ\n         POP   PRINT\n.A$ZZ    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CLEARV": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00A\\x00\\x92\\x16\\x1f\\x00\\x93\\x11o\\x13\"\\x00r\\x00_\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "1992-06-09T00:00:00", "modifydate": "1993-04-26T13:22:41", "lines": 114, "newlines": 95, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    CLEARV &OUT,&LENGTH,&PAD=40,&MF=,&LIST=YES,&HELP=NO\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'CLEARV'  parameters    *\n* and it's use, pass parameter of 'HELP=Yes'.                         *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Move a particular pad character to any variable. The variable may *\n*   be > 256 characters.                                              *\n*                                                                     *\n*   For variable < 258: uses a ripple move.                           *\n*       variable > 257: uses the MVCL instruction.                    *\n*                                                                     *\n*   NOTE : - All registers are kept in tact by this macro.            *\n*                                                                     *\n*   PARAMETERS:                                                       *\n*     1. Destination variable's name.                                 *\n*     2. Length of the variable. To be supplied if the \"L'varname\"    *\n*        function will not return the required length.                *\n*     3. PAD=xx - HEX notation of the pad character. The default is   *\n*                 X'40' (ie. spaces).                                 *\n*     3. MF=E/L - Macro format. For re-entrant programs, MF=L is      *\n*                 required as the macro requires a register save area.*\n*                 It uses a common save area with other macros,       *\n*                 however, the first macro reserves the storage and it*\n*                 may be this one.                                    *\n*     4. HELP=YES/NO - to generate these comments.                    *\n*     5. LIST=YES/NO - to generate a list of commands generated.      *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         LCLC  &CLNAME\n         LCLA  &VLENGTH,&LT258L\n.*--------------------------------------------------------------------*\n         AIF   ('&MF' EQ 'L').A$YY\n         AIF   (T'&OUT EQ 'O').E1\n         AIF   (T'&LENGTH EQ 'O').NOLEN\n.A$YY    ANOP\n&VLENGTH SETA  &LENGTH\n         AGO   .CONT1\n.NOLEN   ANOP\n&VLENGTH SETA  L'&OUT\n.CONT1   ANOP\n         AIF   (&VLENGTH LT 258).A$RD\n.*--------------------------------------------------------------------*\n         AIF   ('&MF' EQ 'L').A$00\n.A$00    ANOP\n         GBLB  &CLFIRST\n         GBLC  &CLBYP1\n.*--------------------------------------------------------------------*\n         GBLC  &REGSAVR,&REGSMCR\n         GBLB  &REGSFLG,&REGDFLG\n         AIF   (&REGSFLG).A$RS\n&REGSAVR SETC  'GB'.'&SYSNDX'.'#'\n&REGSMCR SETC  'CLEARV'\n&REGSFLG SETB  1\n.A$RS    ANOP\n.*--------------------------------------------------------------------*\n         AIF   ('&MF' EQ 'E').A$88\n         AIF   (&CLFIRST).A$88\n&CLFIRST SETB  1\n&CLNAME  SETC  'CL'.'&SYSNDX'\n&CLBYP1  SETC  '&CLNAME'.'1'\n.*--------------------------------------------------------------------*\n.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *\n.*--------------------------------------------------------------------*\n         AIF   (&REGDFLG).A$RD\n&REGDFLG SETB  1\n         AIF   ('&MF' EQ 'L').A$77\n         B     &CLBYP1                 BRANCH AROUND REGISTER SAVEAREA\n.A$77    ANOP\n&REGSAVR DS    16F                     REGISTER SAVE AREA\n         AIF   ('&MF' EQ 'L').EXIT\n&CLBYP1  DS    0H\n.A$RD    ANOP\n         AIF   ('&MF' EQ 'L').EXIT\n.*--------------------------------------------------------------------*\n.A$88    ANOP\n         AIF   (&VLENGTH GT 257).A$99\n*  Ripple move                                                        *\n&LT258L  SETA  &VLENGTH-1\n         MVI   &OUT,X'&PAD'            MOVE PAD CHARACTER\n         MVC   &OUT+1(&LT258L),&OUT    RIPPLE MOVE TO REST OF VARIABLE\n         AGO   .EXIT\n.A$99    ANOP\n*  MVCL instruction move                                              *\n         STM   R14,R1,&REGSAVR         SAVE REGISTERS\n         LA    R0,&OUT                 LOAD ADDRESS OF VARIABLE\n         L     R1,=F'&VLENGTH'         LOAD LENGTH OF VARIABLE\n         XR    R14,R14                 CLEAR SOUREC ADDRESS\n         XR    R15,R15                 CLEAR SOURCE LENGTH\n         ICM   R15,B'1000',=X'&PAD'    MOVE PAD CHARACTER\n         MVCL  R0,R14                  SET AREA TO ALL SPACES\n         LM    R14,R1,&REGSAVR         RESTORE SAVED REGISTERS\n.*--------------------------------------------------------------------*\n.EXIT    ANOP\n         AGO   .MEXIT1\n.*--------------------------------------------------------------------*\n.E1      MNOTE 12,'CLEAR BIG REQUIRES A DESTINATION VARIABLE.'\n         AGO   .MEXIT1\n.E2      MNOTE 12,'CLEAR BIG LONG REQUIRES A LENGTH.'\n.MEXIT1  ANOP\n         AIF   ('&LIST'(1,1) EQ 'Y').A$ZZ\n         POP PRINT\n.A$ZZ    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CTRACE": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x18/\\x00\\x87\\x18/\\x18\\x15\\x00\\x0b\\x00\\r\\x00\\x00\\xc3\\xe2\\xc1\\xd3\\xc5\\xe7@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-07-01T00:00:00", "modifydate": "1987-07-01T18:15:00", "lines": 11, "newlines": 13, "modlines": 0, "user": "CSALEX"}, "text": "         MACRO\n&NAME    CTRACE &PL\n         AIF   (T'&PL EQ 'O').E1\n         LCLA  &PLL\n&PLL     SETA  K'&PL-2\n.MVX     MVC   TSLINE2(8),=C&PL\n         EXEC  CICS,WRITEQ,TS,QUEUE(TSLINE1),FROM(TSLINE2)             X\n            LENGTH(TSLEN)\n         MEXIT\n.E1      MNOTE 12,'TRACE REQUIRES A FUNCTION PARAMETER LIST'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DDSCAN": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x881o\\x00\\x881o\\x11\"\\x00\\'\\x00\\'\\x00\\x00\\xc3\\xe2\\xc1\\xd3\\xc5\\xe7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-11T00:00:00", "modifydate": "1988-11-11T11:22:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "CSALEX"}, "text": "         MACRO\n&LABEL   DDSCAN &DDOPER\n         LCLC  &GNAME\n&GNAME   SETC  'PAN'.'&SYSNDX'\n         LCLA  &WORK1\n         AIF   (T'&DDOPER EQ 'O').ERR1\n&WORK1   SETA  K'&DDOPER\n&LABEL   L     14,16\n         L     14,0(14)\n         L     14,4(14)\n         L     14,12(14)\n         LA    14,24(14)\n         SR    15,15\n&GNAME.L EQU   *\n         CLC   0(4,14),&GNAME.M\n         BZ    &GNAME.N\n         AIF   ('&DDOPER'(1,1) EQ '(' AND '&DDOPER'(&WORK1,1) EQ ')').AX\n               000\n         CLC   4(8,14),=CL8'&DDOPER'\n.CONT1   ANOP\n         BE    &GNAME.Y\n         IC    15,0(14)\n         AR    14,15\n         B     &GNAME.L\n         AGO   .NEXT\n.A000    ANOP\n         CLC   4(8,14),0(&DDOPER(1))\n         AGO   .CONT1\n.NEXT    ANOP\n&GNAME.M DC    XL4'00'\n&GNAME.N EQU   *\n         LA    15,4\n         B     *+6\n&GNAME.Y EQU   *\n         SR    15,15\n         MEXIT\n.ERR1    ANOP\n         MNOTE 8,'MISSING OPERAND'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DFHCSAD": {"ttr": 6401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x18\\x00\\x98&o\\x00\\x98&o\\x17B\\x04\\xf0\\x04\\xf0\\x00\\x00\\xe2\\xd7\\xc1\\xd3\\xd2@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-09-23T00:00:00", "modifydate": "1998-09-23T17:42:18", "lines": 1264, "newlines": 1264, "modlines": 0, "user": "SPALK"}, "text": "         MACRO                                                 @BBDA20X\n         DFHCSAD  &TYPE=DSECT,                                         *\n               &REG=13,            REGISTER FOR TYPE=LOCATE REQUEST    *\n               &TCTCA=0,           TERMINAL CONTROL TCA ADDRESS        *\n               &KCTCA=0,           TASK CONTROL TCA ADDRESS            *\n               &TCDCA=0,           TERMINAL CONTROL DCA ADDRESS        *\n               &SSP=0,             SNAPSHOT PROGRAM ADDRESS            *\n               &OPFL=0,            OPT. FEAT. LIST ADDRESS             *\n               &MXTDS=0,           CLASS MAX TASK FIELDS ADDRESS       *\n               &CSA=0,             CSA ADDRESS                         *\n               &QCA=0,             QCA ADDRESS                         *\n               &ABEND=0,           ABNORMAL TERMINATION ROUTINE ADDRESS*\n               &SRA=0,             SRA ADDRESS                         *\n               &PCA=0,             PCA ADDRESS                         *\n               &LFP=0,             LIFO PROLOGUE ADDRESS               *\n               &SECBL=0,           SECURITY CLASS BLOCK                *\n               &DUMMY=                                      @01281 @D7C\n.**********************************************************************\n.*                                                                    *\n.* MACRO NAME = DFHCSAD                                               *\n.*                                                                    *\n.* DESCRIPTIVE NAME = C.I.C.S./VS COMMON SYSTEM AREA GENERATOR        *\n.*                                                                    *\n.*   COPYRIGHT = 5665-403 (C) COPYRIGHT IBM CORP. 1975, 1982          *\n.*               THIS MODULE IS \"RESTRICTED MATERIALS OF IBM\"         *\n.*               LICENSED MATERIALS - PROPERTY OF IBM                 *\n.*               REFER TO COPYRIGHT INSTRUCTIONS                      *\n.*               FORM NUMBER G120-2083                                *\n.*                                                                    *\n.* STATUS = 2.1.0                                                     *\n.*                                                                    *\n.* FUNCTION = DFHCSAD GENERATES THE DSECT WHICH IS USED BY CICS/VS    *\n.*            TO REFERENCE ITS GLOBAL CONTROL BLOCK, THE COMMON       *\n.*            SYSTEM AREA.  IT IS ALSO USED BY THE MODULE DFHCSA TO   *\n.*            RESERVE STORAGE FOR THE COMMON SYSTEM AREA.             *\n.*                                                                    *\n.* NOTES :                                                            *\n.*  DEPENDENCIES = S/370                                              *\n.*  RESTRICTIONS = NONE                                               *\n.*  REGISTER CONVENTIONS = NOT APPLICABLE                             *\n.*  PATCH LABEL = NOT APPLICABLE                                      *\n.*  MODULE TYPE = MACRO                                               *\n.*  PROCESSOR = ASSEMBLER                                             *\n.*  MODULE SIZE = NOT APPLICABLE                                      *\n.*  ATTRIBUTES = NOT APPLICABLE                                       *\n.*                                                                    *\n.* MACROS :  DFHAFCD, DFHEJECT, DFHPRINT, DFHSYS                      *\n.*                                                                    *\n.* CHANGE ACTIVITY :                                                  *\n.*  $MAC(DFHCSAD),COMP(TASK),PROD(CICS/VS) :                          *\n.*                                                                    *\n.*   PN= REASON REL YYMMDD HDXIII : REMARKS                           *\n.*  $D1= I01185 160 8011   HDCPH  : AAA6 ALIGNED MAP DCR              *\n.*  $D2= I01267 160 8012   HDXDRP : AAE2 TYPE=LOCATE FUNCTION         *\n.*  $D3= I01208 160 810218 HDXDRP : AAG3 BMS SYSGEN SIMPLIFICATION    *\n.*  $D5= I01268 160 810120 HDXDRP : AAG0 DSECT GENERATION VARIABLE    *\n.*  $D6= I01270 160 810106 HDXDRP : AAHK ADDRESS OF DYNALLOC ROUTINE  *\n.*  $D7= I01281 160 810610 HDXDRP : AA7X INDIRECTION TO MAX TASK FLDS *\n.*  $D8= I01350 160 8108   HDREH  : AA9P RMI EXTERNALS                *\n.*  $D9= I01378 160 8110   HDCPH  : BMS FAST PATH                     *\n.*  $DA= I01296 160 8111   HDREH  : ABRP NEW MODULE 'DFHCICS'         *\n.*  $DB= I01251 160 820322 HD5LL  : KPP READ ONLY                     *\n.*  $DC= I01410 160 8203   HDPBGH : TASK FORCE PURGE                  *\n.*  $DD= I01435 161 8210   HD0QDMM: HPO INSTALLABILITY                *\n.*  $DE= I01534 170 8307   HDDRGC : DEFINE CSASPZNA (CABX)            *\n.*  $DF= I01567 170 830909 HDBKED : MOVE SPIE PARAMETER LIST TO SRP   *\n.*  $DG= I01553 170 830711 HDGRR  : MAKE CSAKCMTC BINARY              *\n.*  $DH= I01581 170 8404   HDBKED : ALL WTOS TO GO VIA SIP ROUTINE    *\n.*  $DI= I01680 170 840815 HDBKED : REMOVE SUPPORT FOR SNAP OPTION    *\n.*  $DJ= I01746 170 840820 HD1NIH : DART GLOBAL CONTROL BLOCK         *\n.*  $DK= I01506 170 8407   HDIVJH : FAQE TRAP ENHANCEMENTS            *\n.*  $DL= I01721 170 841010 HD1MA  : PRINTER COMPATIBILITY VIA RDO     *\n.*   DM  RESERVED FOR DCR                                             *\n.*   DN  RESERVED FOR DCR                                             *\n.*  $H1= 5E2    160 8009   HDCPH  : AAAL CICS/VS 1.6 PARTITION SUPPORT*\n.*  $H2= 5E4    160 8009   HDCPH  : AAAL CICS/VS 1.6 LU1 SCS SUPPORT  *\n.*   H3  RESERVED FOR HARDWARE SUPPORT                                *\n.*   H4  RESERVED FOR HARDWARE SUPPORT                                *\n.*   H5  RESERVED FOR HARDWARE SUPPORT                                *\n.*   H6  RESERVED FOR HARDWARE SUPPORT                                *\n.*  $L1= CB1    160 8009   HDDRGC : AAAG RMI RECOVERY                 *\n.*  $L2= 211    160 8011   HDQJDH : AABP CICS/VS 1.6 VOLUME MANAGER   *\n.*  $L3= U71    160 810224 HDXDRP : AAIJ CICS STATUS FIELDS           *\n.*  $L4= U71    160 810306 HDXDRP : AAIU REMOVE CSAPLNAC              *\n.*  $L5= A00    160 810317 HDXDRP : AAJY USE NEW DFHSSAD MACRO        *\n.*  $L6= I00    160 8107   HDUGM  : AA9P ADDRESSES FOR LU6.2 MODULES  *\n.*  $L7= U60    160 810731 HDZPFH : AA9Z ADD CSAPCCBL                 *\n.*  $L8= G00    160 811001 HDXDRP : ABIP EXTENDED STORAGE ANCHOR      *\n.*  $L9= IA5    160 8111   HDDRGC : ABSA LUC RECOVERY ADD CSAURDHW    *\n.*  $LA= E13    160 8112   HDSRPS : ABYK FIELDS FOR SPECIAL           *\n.*  $LB= A00    160 820402 HDXDRP : ACSR GENERAL IMPROVEMENTS         *\n.*  $LC= J42    161 820825 HDXDRP : BBAK ADD CSAXFXNA                 *\n.*  $LD= 220    161 820831 HD0WPFB: SUBTASKING EXTENSIONS             *\n.*  $LE= 131    161 8210   HDUGM  : CSATDSTA -> TD STATIC STORAGE     *\n.*  $LF= 131    161 8303   HDUGM  : CSATDNT HAS BECOME REDUNDANT      *\n.*  $LG= S00    170 830616 HDBKED : SECURITY CLASS FIELDS             *\n.*  $LH= XXX    170 831022 HD0ADB : SPACE FOR 170                     *\n.*  $LI= 970    170 830304 HD0TMB : SPECIAL FEATURES DEVELOPMENT      *\n.*  $LJ= 140    170 831110 HD0ADB : SUBTASK MANAGER                   *\n.*  $LK= FC6    170 831116 HD0FJTC: REPLACE ADDRESS OF FCD BY FCX     *\n.*  $LL= U74    170 831130 HDBKED : CATALOG CONTROL PROGRAM           *\n.*  $LM= U74    170 840126 HDBKED : RECOVERY CONTROL PROGRAM          *\n.*  $LN= 62A    170 8403   HDBKED : ECB FOR DL/I RESTART TASK         *\n.*  $LO= E23    170 8403   HDDRGC : V.SPECIAL SUPPORT (CA5Z,CBB7)     *\n.*  $LP= EA0    170 8404   HDSRPS : HLPI ENHANCEMENTS (CA77)          *\n.*  $LQ= U8C    170 840620 HD0HJC : RDO FOR TCT                       *\n.*  $LR= IA7    170 840614 HDFPSC : DATA ENCRYPTION STANDARD (DES)    *\n.*  $LS= 118    170 8407   HDPBGH : ADD EXTRA CMXT FIELDS IN CSAMXTDS *\n.*  $LT= U80    170 840907 HD0GPGR: DFHTON (NUCLEUS MODULE FOR DFHTOR)*\n.*  $LU  117    170 8505   HD1YBC : DOS MULTIPLE WAIT SUPPORT         *\n.*  $LV= A02    170 8411   HDGRR  : CB3M:SOME CSA COUNTERS BINARY     *\n.*  $LW= 119    170 8410   HDPBGH : ADD CSATCBTI (TCB TIME) IN OFL    *\n.*  $LX= 6B0    170 8410   HDIVJH : GLOBAL TRAP/TRACE EXIT            *\n.*  $LY= X11    175 850626 HD1NIH : XRF SURVEILLANCE/TRACKING         *\n.*  $LZ= X00    175 8507   HDUGM  : GENERAL CHANGES FOR XRF           *\n.*  $N1= X21    175 851113 HD0HJC : XRF SUPPORT (SESSION TRACKING)    *\n.*  $N2= 618    212 9001   HD9URB : FFS SUPPORT : DFHFFSP ADDRESS     *\n.*  $P1= M15229 160 8111   HDGRR  : PTM 15229                         *\n.*  $P2= M15744 160 820419 HDFPSC : PTM 15744                         *\n.*  $P3= M16793 160 820928 HD5LL  : JOURNAL OPEN/CLOSE LIST           *\n.*  $P4= M29486 170 8502   HDPBGH : CHANGES FOR DATA AREAS MANUAL     *\n.*  $P5= M30927 170 8507   HDGRR  : CEFH: EXTRA SETTING OF CSAXST1    *\n.*  $P6= M31748 170 8601   HD0DDGJ: CEZF: MAKE DFHEIQ.. MODULES NONRES*\n.*  $P7= M31943 170 8601   HDPBGH : CORRECT VARIOUS COMMENTS          *\n.*  $P8= M32154 170 8603   HDIVJH : DEFINE FLAGS IN CSATRMF1/2/3/4    *\n.*  $P9= M31677 170 8604   HDPBGH : APAR 48378, REMOVE MVS REL LEVELS *\n.*  $PA= M40317 170 8607   HDUGM  : UPDATE CSALOGFL                   *\n.*  $PB= M32897 170 8608   HDPBGH : REMOVE COMMENT FOR MELMAP         *\n.*  $PC= M40471 170 8610   HDUGM  : ESSENTIAL CHANGES FOR VERSION 2   *\n.*  $PD= M40698 175 861212 HDOPJL: DCB3 RUNAWAY NOT WORKING.          *\n.*  $PE= M41589 212 900831 HD6KRAH: DATA AREAS TIDY UP                *\n.*   PF  RESERVED FOR PTM                                             *\n.*  $01= A91493 160 8204   HDGRR  : REWORK MAKE JOURNAL FIELD BINARY  *\n.*   02  RESERVED FOR APAR                                            *\n.*   03  RESERVED FOR APAR                                            *\n.*                                                                    *\n.**********************************************************************\n         GBLB  &DFHCSAD            DSECT GENERATION FLAG    @01268 @D5A\n         DFHSYS                    SET SYSTEM INDICATORS       @BBDA20X\n.**********************************************************************\n         AIF   ('&TYPE' NE 'LOCATE').DSECT1                 @01267 @D2A\n         DFHAFCD  TYPE=LOCATE,     FIND THE ADDRESS         @01267 @D2A*\n               REG=&REG              OF THE AFCB            @01267 @D2A\n         L     &REG,AFCSA-DFHAFCB(,&REG)  ADDRESS THE CSA   @01267 @D2A\n         MEXIT                                              @01267 @D2A\n.*                                                                    *\n.DSECT1  ANOP                                               @01267 @D2A\n         AIF   ('&TYPE' NE 'DSECT').CSECT1                     @BBDA20X\n         AIF   (&DFHCSAD).DSECTBY  NO DSECT IF ALREADY GENERATED       F\n                                                            @01268 @D5A\n         DFHPRINT DSCT=SOMESTART                               @BBDB80J\n***********************************************************************\n*            C I C S   C O M M O N   S Y S T E M   A R E A            *\n***********************************************************************\nDFHCSADS DSECT             DUMMY SECTION - CSA                 @BB89999\n.CSECT1  ANOP                                                  @BBDA20X\n         USING *,13        USING REGISTER 13                   @BBDA20X\nDFHCSABA EQU   *           COMMON SYSTEM AREA BEGIN ADDRESS    @BBDA20X\n.*   DURING THE EARLY PART OF CICS/VS INITIALISATION A TEMPORARY      *\n.*   CSA IS USED.  DFHSIP ALLOCATES AND CLEARS THE STORAGE FOR IT.    *\n.*   IT IS USED BY DFHSIA1 AND BY DFHSIB1 UNTIL THE REAL CSA IS       *\n.*   LOADED.   DFHSIB1 THEN COPIES MOST FIELDS FROM THE TEMPORARY     *\n.*   CSA TO THE REAL ONE.  THE FIELDS WHICH ARE COPIED ARE            *\n.*   GENERATED BY THIS MACRO USING 'DS' INSTRUCTIONS.  THOSE          *\n.*   FIELDS WHICH ARE NOT COPIED AE GENERATED BY 'DC' INSTRUCTIONS.   *\n***********************************************************************\n* * *                   S T O R A G E                             * * *\n***********************************************************************\nCSAOSRSA DS    18F         CONTROL SYSTEM REGISTER AREA        @BBDA20X\nCSASOSI  DS    0B          SHORT ON STORAGE INDICATOR          @BBDA20X\nCSASSI1  DS    B           SYSTEM SIGNAL INDICATOR 1           @BBDA20X\nCSAFPURG EQU   X'80'       .. DFHKCP HAS USED FORCE PURGE   @01410 @DCA\nCSASOSON EQU   X'01'       .. SHORT ON STORAGE CONDITION       @BBDA20X\nCSAKCMI  DS    0B          MAXIMUM NUMBER OF TASKS IND         @BBDA20X\nCSASSI2  DS    B           SYSTEM SIGNAL INDICATOR 2           @BBDA20X\nCSATCPEV EQU   X'01'       .. TCP-KCP PENDING EVENT.           @BBDI80O\nCSAMXTON EQU   X'02'       .. MAXIMUM TASK INDICATOR ON        @BBDA20X\n*                            CONDITION                                *\nCSATQIM  EQU   X'04'       .. TRANSACTION QUIESCE INDICATOR    @BBDA20X\n*                            MASK                                     *\nCSATCPQM EQU   X'08'       .. TERMINAL CONTROL QUIESCE MASK    @BBDA20X\nCSAPLTPI EQU   X'10'       .. PLTPI PHASE HAS COMPLETED        @BB9684Q\nCSAFNLTM EQU   X'40'       .. FINAL TERMINATION PHASE POSTING  @BBDA20X\n*                            MASK                                     *\nCSASTIM  EQU   X'80'       .. SYSTEM TERMINATION INDICATOR     @BBDA20X\n*                            MASK                                     *\nCSAMXTOF EQU   X'FD'       .. MAXIMUM TASK INDICATOR OFF       @BBDA20X\n*                            CONDITION                                *\nCSAKCMT  DS    PL2         MAXIMUM NUMBER OF TASKS             @BBDA20X\n         DS    (X'4C'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSACDTA  DC    A(&TCTCA)   CURRENTLY DISPATCHED TASK ADDRESS   @BBDA20X\n         DS    (X'50'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSATODP  DS    PL4         TIME OF DAY.  A PACKED INTEGER OF   @BBDA20X\n*                            THE FORM HHMMSSTC WHERE HH IS            *\n*                            HOURS, MM IS MINUTES, SS IS              *\n*                            SECONDS, T IS TENTHS OF A SECOND         *\n*                            AND C IS A POSITIVE SIGN.                *\nCSAICEBA DS    A           INTERVAL CONTROL ELEMENT (ICE)      @BBDA20X\n*                            CHAIN BEGINNING ADDRESS                  *\nCSAICSIC DS    H           STALL TIME INTERVAL.  A BINARY      @BBDA20X\n*                            INTEGER OF WHICH THE LEAST               *\n*                            SIGNIFICANT BIT REPRESENTS ONE-          *\n*                            HUNDREDTH OF A SECOND.                   *\nCSADATFT DS    X           DATE FORMAT INDICATOR               @BBDA20X\nCSADATFM EQU   X'01'       .. FORMAT AS MMDDYY                 @BBDA20X\nCSADATFD EQU   X'02'       .. FORMAT AS DDMMYY                 @BBDA20X\nCSADATFY EQU   X'04'       .. FORMAT AS YYMMDD                 @BBDA20X\nCSAICIND DS    B           INTERVAL CONTROL INDICATOR          @BBDA20X\nCSAICIAJ EQU   X'01'       .. TIME-OF-DAY ADJUSTMENT MASK      @BBDA20X\nCSAICITP EQU   X'02'       ...ADJUSTMENT TASK PENDING MASK     @BBDA20X\nCSATADJT DS    F           TIME OF DAY ADJUSTMENT VALUE.  THE  @BBDA20X\n*                            DIFFERENCE BETWEEN THE OPERATING         *\n*                            SYSTEM TIME OF DAY AND THE               *\n*                            CICS/VS TIME OF DAY EXPRESSED IN         *\n*                            300THS OF A SECOND.                      *\nCSACTODB DS    0F          CURRENT TIME OF DAY.  A BINARY      @BBDA20X\n*                            INTEGER OF WHICH THE LEAST               *\n*                            SIGNIFICANT BIT REPRESENTS ONE           *\n*                            ONE-HUNDREDTH OF A SECOND.               *\nCSACSCC  DS    F           COMMON SYSTEM CONTROL CLOCK         @BBDA20X\nCSASBTI  DS    F           SYSTEM PARTITION/REGION EXIT TIMER  @BBDA20X\n*                            INTERVAL EXPRESSED IN 300THS OF A        *\n*                            SECOND (CICS/VS TIMER UNITS) IN          *\n*                            THE THREE HIGH-ORDER BYTES.              *\nCSATTECB DS    F           TERMINAL TIMER EVENT CONTROL BLOCK  @BBDA20X\nCSASITOD DS    0F          SYSTEM INITIALIZATION TIME OF DAY   @BBDA20X\n*                            IN BINARY SECONDS.                       *\n         DS    (X'6C'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSATODB  DS    F           TIME OF DAY BINARY                  @BBDA20X\nCSASCNB  DS    F           STORAGE CUSHION NUMBER OF BYTES     @BBDA20X\nCSAPLBA  DS    A           PARTITION LOWER BOUNDARY ADDRESS    @BBDA20X\nCSAPUBA  DS    A           PARTITION UPPER BOUNDARY ADDRESS    @BBDA20X\n         DS    (X'7C'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSAJYDP  DS    PL4         A PACKED INTEGER OF THE FORM        @BBDA20X\n*                            00YYDDDC WHERE YY IS YEARS, DDD          *\n*                            IS DAYS AND C IS A POSITIVE SIGN.        *\nCSATDTCA DC    A(&KCTCA)   TASK DISPATCHER TCA ADDRESS         @BBDA20X\n         DS    (X'84'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSATRMF1 DS    X           TRACE SYSTEM MASTER FLAGS           @BBDA20X\nCSATRMAS EQU   X'80'       .. TRACE MASTER FLAG; IF ON, TRACING        F\n                              OCCURS OF SYSTEM, USER, AND FE ENTRIES   F\n                              ACCORDING TO INDIVIDUAL FLAGS        @P8A\nCSATRSYS EQU   X'40'       .. SYSTEM MASTER FLAG; IF ON,               F\n                                SYSTEM ENTRIES ARE TRACED          @P8A\nCSATRUSE EQU   X'20'       .. USER MASTER FLAG; IF ON,                 F\n                                USER ENTRIES ARE TRACED            @P8A\nCSATRFE  EQU   X'10'       .. FE MASTER FLAG; IF ON,                   F\n                                FE ENTRIES ARE TRACED              @P8A\nCSATRAUX EQU   X'08'       .. AUXILIARY TRACE MASTER FLAG; IF TRACE    F\n                                MASTER FLAG ALSO ON, ENTRIES ARE       F\n                                WRITTEN TO AUXILIARY TRACE         @P8A\nCSAMNEXC EQU   X'04'       .. EXCEPTION CLASS MONITORING       @BBDU20N\nCSAMNPER EQU   X'02'       .. PERFORM CLASS MONITORING         @BBDU20N\nCSAMNACC EQU   X'01'       .. ACCOUNT CLASS MONITORING         @BBDU20N\n         DS    (X'85'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSATRMF2 DS    X           TRACE SYSTEM SELECTION FLAGS            @P8C\nCSATRMKC EQU   X'80'       .. TRACE TASK CONTROL                   @P8A\nCSATRMSC EQU   X'40'       .. TRACE STORAGE CONTROL                @P8A\nCSATRMPC EQU   X'20'       .. TRACE PROGRAM CONTROL                @P8A\nCSATRMIC EQU   X'10'       .. TRACE INTERVAL CONTROL               @P8A\nCSATRMDC EQU   X'08'       .. TRACE DUMP CONTROL                   @P8A\nCSATRMFC EQU   X'04'       .. TRACE FILE CONTROL AND DL/I          @P8A\nCSATRMTD EQU   X'02'       .. TRACE TRANSIENT DATA                 @P8A\nCSATRMTS EQU   X'01'       .. TRACE TEMPORARY STORAGE              @P8A\n         DS    (X'86'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSATRMF3 DS    X           TRACE SYSTEM SELECTION FLAGS            @P8C\nCSATRMRE EQU   X'80'       .. TRACE ALL RESPONSES (RESERVED)       @P8A\nCSATRMEI EQU   X'40'       .. TRACE EXEC INTERFACE                 @P8A\nCSATRMDI EQU   X'20'       .. TRACE DATA INTERCHANGE               @P8A\nCSATRMSP EQU   X'10'       .. TRACE SYNC POINT                     @P8A\nCSATRMTC EQU   X'08'       .. TRACE TERMINAL CONTROL               @P8A\nCSATRMBF EQU   X'04'       .. TRACE BUILT-IN FUNCTIONS             @P8A\nCSATRMBM EQU   X'02'       .. TRACE BASIC MAPPING SUPPORT          @P8A\nCSATRMJC EQU   X'01'       .. TRACE JOURNAL CONTROL                @P8A\nCSATRMF4 DS    X           TRACE SYSTEM SELECTION FLAGS            @P8C\nCSATRMIS EQU   X'80'       .. TRACE ISC                            @P8A\nCSATRMUE EQU   X'40'       .. TRACE USER EXIT INTERFACE            @P8A\nCSATRMS5 EQU   X'20'       .. RESERVED FOR SYSTEM COMPONENT        @P8A\nCSATRMS4 EQU   X'10'       .. RESERVED FOR SYSTEM COMPONENT        @P8A\nCSATRMS3 EQU   X'08'       .. RESERVED FOR SYSTEM COMPONENT        @P8A\nCSATRMS2 EQU   X'04'       .. RESERVED FOR SYSTEM COMPONENT        @P8A\nCSATRMS1 EQU   X'02'       .. RESERVED FOR SYSTEM COMPONENT        @P8A\nCSATRMLF EQU   X'01'       .. LIFO FLAG                            @P8A\nCSATRMF5 DS    X           TRACE SYSTEM FLAGS (RESERVED)           @DKC\nCSATRMF6 DS    X           TRACE SYSTEM FLAGS FOR                      F\n                             STORAGE VIOLATION TRAP                @DKC\nCSAFQCO  EQU   X'80'       .. FAQE - CONTROL SUBPOOL               @DKA\nCSAFQTP  EQU   X'40'       .. FAQE - TP SUBPOOL                    @DKA\nCSAFQSH  EQU   X'20'       .. FAQE - SHARED SUBPOOL                @DKA\nCSAFQRP  EQU   X'10'       .. FAQE - RPL SUBPOOL                   @DKA\nCSAFQTA  EQU   X'08'       .. FAQE - TASK SUBPOOL                  @DKA\nCSAFQAL  EQU   X'F8'       .. FAQE - ALL SUBPOOLS                  @DKA\nCSAUSTG  EQU   X'02'       .. TASKSTG                              @DKA\nCSATRMFQ EQU   X'01'       .. STORAGE VIOLATION TRAP IS ACTIVE         F\n                                (FAQE AND/OR TASKSTG FUNCTIONS)    @DKA\nCSATSDTI DS    H           TERMINAL SCAN DELAY INTERVAL IN     @BBDA20X\n*                            300THS OF A SECOND (CICS/VS              *\n*                            TIMER UNITS).                            *\nCSASITBA DS    A           SYSTEM INITIALIZATION TABLE (SIT)   @BBDA20X\n*                            ADDRESS                                  *\nCSAUNQID DS    F           UNIQUE IDENTIFICATION COUNTER       @BBDA20X\n*                            (BINARY FULLWORD COUNTER)                *\nCSAAIDBA DS    F           RESERVED AND MUST NOT BE USED.\n*                                                                     *\nCSAPAMA  DS    A           ADDRESS OF PAGE ALLOCATION MAP      @BBDA20X\n         SPACE 1                                            @EA00X @LBA\n***********************************************************************\n* *      OPERATING SYSTEM AND CICS/VS LEVEL INDICATORS              * *\n***********************************************************************\nCSAOPSYS DS    C           OPERATING SYSTEM                    @BBAL00X\nCSADOS   EQU   C'D'        .. DOS/VS                           @BBAL00X\nCSAVSE   EQU   C'E'        .. DOS/VSE                          @BBDA00X\nCSAVS1   EQU   C'1'        .. OS/VS1                           @BBAL00X\nCSASVS   EQU   C'S'        .. OS/SVS                           @BBAL00X\nCSAMVS   EQU   C'M'        .. OS/MVS                           @BBAL00X\nCSAMVX   EQU   C'X'        .. MVS/XA (INCLUDES MVS/ESA)        @BA24688\nCSAOPREL DS    C           OPERATING SYSTEM RELEASE            @BBAL00X\nCSAD34   EQU   X'34'       .. DOS/VS RELEASE 34                @BBAL00X\nCSAE11   EQU   X'11'       .. DOS/VSE RELEASE 1.1              @BBAL00X\nCSAE12   EQU   X'12'       .. DOS/VSE RELEASE 1.2              @BBAL00X\nCSAE13   EQU   X'13'       .. DOS/VSE RELEASE 1.3           @EA00X @L5A\nCSA160   EQU   X'60'       .. OS/VS1 RELEASE 6.0               @BBAL00X\nCSA170   EQU   X'70'       .. OS/VS1 RELEASE 7.0            @EA00X @L5A\nCSAM37   EQU   X'37'       .. OS/MVS RELEASE 3.7               @BBAL00X\nCSAM38   EQU   X'38'       .. OS/MVS RELEASE 3.8            @EA00X @L5A\nCSAX17   EQU   X'17'       .. MVS/XA RELEASE 2.1.7             @BA53012\nCSAX20   EQU   X'20'       .. MVS/XA RELEASE 2.2.0             @BA53012\nCSAX21   EQU   X'21'       .. MVS/XA RELEASE 2.2.1             @BA53012\nCSAE10   EQU   X'10'       .. MVS/ESA RELEASE 3.1.0            @BA53012\nCSAESA13 EQU   X'13'       .. MVS/ESA RELEASE 3.1.3            @BA00271\nCSAESA22 EQU   X'22'       .. MVS/ESA RELEASE 4.2.2            @BA24688\n* THE ABOVE EQUATES ARE NOT EXHAUSTIVE.  OTHER POSSIBLE        @BA24688\n* VALUES FOR OPREL ARE SIMILARLY CONSTRUCTED FROM THE          @BA24688\n* OFFICIAL PRODUCT NAME OF THE CONTROL PROGRAM.                @BA24688\nCSACICS  DS    C           CICS SYSTEM                             @PCC\nCSACIREL DS    X           CICS RELEASE                            @PCC\n*                          CICS/VS RELEASE                         @PCA\nCSAC14   EQU   X'14'       .. VERSION 1, RELEASE 4             @BBAL00X\nCSAC15   EQU   X'15'       .. VERSION 1, RELEASE 5             @BBDA00X\nCSAC16   EQU   X'16'       .. VERSION 1, RELEASE 6          @EA00X @L5A\nCSAC17   EQU   X'17'       .. VERSION 1, RELEASE 7                 @P4A\n*                          CICS/MVS RELEASE                        @PCA\nCSAC21   EQU   X'21'       .. VERSION 2, RELEASE 1                 @PCA\n         SPACE 1                                            @EA00X @LBA\n         DS    F           MUST BE ZERO - THE CSA CONTAINS A   @BB9HCDI\n*                            DUMMY SUSPENDED DCA IN WHICH             *\n*                            FIELD DCATRTO IS ZERO.                   *\nCSANXDCA DC    A(0)        NEXT AVAILABLE DISPATCH CONTROL     @BBDA20X\n*                            AREA (DCA)                               *\nCSASUSOF EQU   *-12        SUSPENDED TASK CHAIN OFFSET         @BBDA20X\nCSASUSFA DC    A(CSASUSOF) LOWEST PRIORITY SUSPENDED TASK DCA  @BBDA20X\nCSASUSBA DC    A(CSASUSOF) HIGHEST PRIORITY SUSPENDED TASK DCA @BBDA20X\nCSAACTOF EQU   *-12        ACTIVE TASK CHAIN OFFSET            @BBDA20X\nCSAACTFA DC    A(&TCDCA)   LOWEST PRIORITY ACTIVE TASK DCA     @BBDA20X\nCSAACTBA DC    A(&TCDCA)   HIGHEST PRIORITY ACTIVE TASK DCA    @BBDA20X\nCSATCTCA DC    A(&TCTCA)   TERMINAL CONTROL TASK CONTROL AREA  @BBDA20X\n*                            ADDRESS                                  *\n         DC    X'C5'       DUMMY DISPATCH CONTROL,             @BBDA20X\n         DC    X'00FF00'     PRIORITY, ETC                     @BBDA20X\nCSAMAXT  DS    H           MAXIMUM ACTIVE TASK VALUE           @BB610LC\nCSAMAXTC DS    H           MAXIMUM ACTIVE TASKS ACCUMULATED    @BB610LC\nCSACIMOD DS    C           CICS MODIFICATION LEVEL IN HEX      @BA50731\nCSAMOD00 EQU   X'00'       CICS modification level 0           @BA50731\nCSAMOD01 EQU   X'01'       CICS modification level 1           @BA50731\nCSAMOD02 EQU   X'02'       CICS modification level 2           @BA50731\nCSAMOD03 EQU   X'03'       CICS modification level 3           @BA50731\n         DS    C           RESERVED                            @BA50731\nCSAWAL   DC    Y(CSACSAEA-DFHCSABA)   LENGTH OF CSA + CWA\n         DS    (X'C8'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSAOPFLA DC    A(&OPFL)    CSA OPTIONAL FEATURES LIST ADDRESS  @BBDA20X\nCSAKPFRQ DS    H           ACTIVITY KEYPOINT FREQUENCY COUNTER @BBDA20X\nCSAKPACT DS    H           ACTIVITY KEYPOINT ATTACH COUNTER    @BBDA20X\nCSAKPCLK DS    D           ACTIVITY KEYPOINT STORE CLOCK       @BB6628D\nCSASTECB DS    0A          SUBTASKING ECB (OS ONLY)            @BA05383\nCSABTCCB DS    A           BTAM MASTER CCB ADDRESS (DOS ONLY)  @BBAA12Y\n***********************************************************************\n* * *                   C O N S T A N T S                         * * *\n***********************************************************************\n         DS    CL4'CNST'   MEMORY CONSTANT - CNST              @BB610EC\n***********************************************************************\n* *                       A D D R E S S   C O N S T A N T S         * *\n***********************************************************************\n*                           M O D U L E   E N T R Y   A D D R E S S   *\n***********************************************************************\n         DS    (X'E0'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSAKCNAC DS    A           TASK CONTROL ENTRY ADDRESS          @BBDA20X\n         DS    (X'E4'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSASCNAC DS    A           STORAGE CONTROL ENTRY ADDRESS       @BBDA20X\nCSASCPXM EQU   X'80'       .. STORAGE CONTROL PROGRAM CHECK    @BBDA20X\n*                            EXIT IS ACTIVE                           *\n         DS    (X'E8'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSAPCNAC DS    A           PROGRAM CONTROL ENTRY ADDRESS       @BBDA20X\nCSAPCPXM EQU   X'80'       .. PROGRAM CONTROL PROGRAM CHECK    @BA77756\n*                            EXIT IS ACTIVE                    @BA77756\n         DS    (X'EC'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSAICNAC DS    A           TIME CONTROL ENTRY ADDRESS          @BBDA20X\n         DS    (X'F0'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSADCNAC DS    A           DUMP CONTROL ENTRY ADDRESS          @BBDA20X\n         DS    (X'F4'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSATCNAC DS    A           TERMINAL CONTROL ENTRY ADDRESS      @BBDA20X\n         DS    (X'F8'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSAFCNAC DS    A           FILE CONTROL ENTRY ADDRESS          @BBDA20X\n         DS    (X'FC'-*+DFHCSABA)C CHECK COMMITTED OFFSET   @GBS1B @LHA\nCSATDNAC DS    A           TRANSIENT DATA CONTROL ENTRY        @BBDA20X\n*                            ADDRESS                                  *\n         DS    (X'100'-*+DFHCSABA)C CHECK COMMITTED OFFSET  @GBS1B @LHA\nCSATSNAC DS    A           TEMPORARY STORAGE CONTROL ENTRY     @BBDA20X\n*                            ADDRESS                                  *\nCSASANAC DS    A           PL/I STORAGE ALLOCATION PROGRAM     @BBDA20X\n*                            ADDRESS                                  *\n         DS    (X'108'-*+DFHCSABA)C CHECK COMMITTED OFFSET  @GBS1B @LHA\nCSATRNAC DS    A           TRACE/MONITOR ENTRY ADDRESS         @BBDU20X\n*--------------------------------------------------------------------*/\n* CSAPIPSW -> CSAAPIE, CSAAPISV, CSAASRPB, CSAASRPE.                 */\n*                                                                    */\n* CSAPIPSW POINTS TO FOUR WORDS:                                     */\n*                                                                    */\n* 1. CSAAPIE THE ADDRESS OF THE PIE, WHICH IS A PL/I INTERFACE.      */\n* 2. CSAAPISV THE ADDRESS OF DCP'S SAVE AREA FOR DUMPING REGS+PSW.   */\n* 3. CSAASRPB THE ADDRESS OF SRP'S BEGINNING.                        */\n* 4. CSAASRPE THE ADDRESS OF SRP'S END.                              */\n*                                                                    */\n* THE FIELDS ARE DEFINED AS EQUATES TO PERMIT CROSS-REFERENCING.     */\n*                                                                    */\n*--------------------------------------------------------------------*/\nCSAPIPSW DS    0A          PROGRAM INTERRUPT PSW SAVE AREA     @BBDA20X\n*                            ADDRESS                                  *\nCSAAPIE  EQU   0           @PIE                                    @PDA\nCSAAPISV EQU   4           @Save Area after Abend/Program Check.   @PDA\nCSAASRPB EQU   8                Beginning.                         @PDA\nCSAASRPE EQU   12               Ending.                            @PDA\nCSAPINAC DS    A           PROGRAM INTERRUPT ENTRY ADDRESS     @BBDA20X\n*                            (DURING SYSTEM INITIALIZATION            *\n*                            ONLY)                                    *\n*--------------------------------------------------------------------*/\nCSASNNAC DC    A(0)        RESERVED - NAME USED BY SIB1/TINAD      @DIC\n         DS    (X'114'-*+DFHCSABA)C CHECK COMMITTED OFFSET  @GBS1B @LHA\nCSASPNAC DS    A           SYNCH POINT PROGRAM ENTRY ADDRESS   @BBDA20X\n         DS    (X'118'-*+DFHCSABA)C CHECK COMMITTED OFFSET  @GBS1B @LHA\nCSATCRWE DS    A           TCP READ/WRITE REQUEST PROGRAM      @BB5021J\n*                            ENTRY ADDRESS                            *\n***********************************************************************\n*                           S Y S T E M   C O N T R O L   T A B L E   *\n*                           B E G I N N I N G   A D D R E S S         *\n***********************************************************************\n         DS    (X'11C'-*+DFHCSABA)C CHECK COMMITTED OFFSET  @GBS1B @LHA\nCSATRTBA DS    A           ADDRESS OF TRACE TABLE              @BBDA20X\nCSAPCTBA DS    A           ADDRESS OF PROGRAM CONTROL TABLE    @BBDA20X\n*                          (CLEARED BY DFHKCRP)                       *\nCSAPPTBA DS    A           ADDRESS OF PROCESSING PROGRAM TABLE @BBDA20X\n*                          (CLEARED BY DFHSII1)                       *\nCSATCTBA DS    A           ADDRESS OF TERMINAL CONTROL TABLE   @BBDA20X\nCSAFCTBA DS    A           ADDRESS OF FILE CONTROL TABLE       @BBDA20X\nCSADCTBA DS    A           ADDRESS OF DESTINATION CONTROL      @BBDA20X\n*                            TABLE                                    *\nCSATSATA DS    A           ADDRESS OF TEMPORARY STORAGE BIT    @BBDA20X\n*                            MAP                                      *\nCSATSMTA DS    A           ADDRESS OF FIRST TEMPORARY STORAGE  @BBDA20X\n*                            UNIT TABLE ENTRY                         *\nCSAQETBA DS    0A          ADDRESS OF QUEUE ELEMENT TABLE      @BBDA20X\n*                            (DOS ONLY)                               *\nCSAQCAA  DC    A(&QCA)     ADDRESS OF QUEUE CONTROL AREA       @BBAA12Y\n*                            (OS ONLY)                                *\n***********************************************************************\n*                           O P E N   &   C L O S E   L I S T         *\n***********************************************************************\nCSAPOLA  DS    A           PROGRAM DATA SET OPEN LIST ADDRESS  @BBDA20X\nCSADOLA  DS    A           DUMP DATA SET OPEN LIST ADDRESS     @BBDA20X\nCSATOLA  DS    A           TERMINAL DATA SET OPEN LIST ADDRESS @BBDA20X\nCSAFOLA  DS    A           FILE DATA SET OPEN LIST ADDRESS     @BBDA20X\nCSATDOLA DS    A           TRANSIENT DATA DATA SET OPEN LIST   @BBDA20X\n*                            ADDRESS                                  *\nCSATSOLA DS    A           TERMINAL STORAGE DATA SET OPEN LIST @BBDA20X\n*                            ADDRESS                                  *\nCSAJCOCL DS    A        ADDRESS OF JOURNAL OPEN CLOSE LIST  @17101 @P3C\n***************************************************************@BACOM02\n*        ANCHOR BLOCK FOR COMMAREA STORAGE EXTENDED PARM LIST  @BACOM02\n***************************************************************@BACOM02\nCSACOMXA DS    A         ANCHOR BLOCK FOR COMMAREA X PARM LIST @BACOM02\n***********************************************************************\n*        P R O G R A M   I N T E R R U P T   R T N   A D D R E S S    *\n***********************************************************************\nCSAPICA  DC    F'0'        .. PROGRAM INTERRUPT RTN ADDRESS        @DFC\n***************************************************************@BACOM02\n*        COMMAREA ABOVE THE LINE ENABLING FLAG AND BIT SWITCH  @BACOM02\n***************************************************************@BACOM02\nCSACOMXS DC    X'00'     COMMAREA ABOVE LINE ENABLING FLAG     @BACOM02\nCSACOMXE EQU   X'80'       .. COMMAREA ABOVE LINE SPE APPLIED  @BACOM02\n         DC    XL3'00'     .. RESERVED                         @BACOM02\n         DC    F'0'        .. RESERVED                         @BACOM02\n***********************************************************************\n*        S / 3 7 0   T I M E - O F - D A Y   C O N T R O L            *\n***********************************************************************\nCSABASCL DC    F'0'        BASE S/370 TIME-OF-DAY CLOCK VALUE  @BB1101J\n*                            (4.096 MILLISECONDS RESOLUTION)          *\nCSABASTU DC    F'0'        BASE TIMER UNITS VALUE EXPRESSED IN @BB1101J\n*                            300THS OF A SECOND RESOLUTION            *\n***********************************************************************\n*        C I C S / V S   E X E C U T I O N   S T A T U S              *\n***********************************************************************\nCSAXST   DS    0XL3      CICS EXECUTION STATUS FLAGS        @EU71X @LZC\nCSAXST1  DC    X'00'       CICS EXECUTION STATUS            @EU71X @L3A\nCSAXSI   EQU   X'01'       .. CICS INITIALIZATION           @EU71X @L3A\nCSAXSEX  EQU   X'02'       .. CICS EXECUTION                @EU71X @L3A\nCSAXSTM  EQU   X'04'       .. CICS TERMINATION              @EU71X @L3A\nCSAXSTMI EQU   X'24'       .. CICS TERMINATING IMMEDIATELY         @P5A\nCSAXSTMC EQU   X'44'       .. CICS TERMINATING CONTROLLED          @P5A\nCSAXST2  DC    X'00'       CICS EXECUTION STATUS            @EU71X @L3A\nCSAXSI1  EQU   X'01'       .. 1ST-STAGE INITIALIZATION      @EU71X @L3A\nCSAXSI2  EQU   X'02'       .. 2ND-STAGE INITIALIZATION      @EU71X @L3A\nCSAXSI3  EQU   X'04'       .. 3RD-STAGE INITIALIZATION      @EU71X @L3A\nCSAXSQ1  EQU   X'10'       .. 1ST-STAGE OF QUIESCE          @EU71X @L3A\nCSAXSQ2  EQU   X'20'       .. 2ND-STAGE OF QUIESCE          @EU71X @L3A\nCSAXST3  DC    X'00'       CICS EXECUTION STATUS                   @LZA\nCSAXSINC EQU   X'01'       .. CICS INITIALIZATION COMPLETE         @LZA\n*                                                                     *\n***********************************************************************\nCSAAKPFL DC    X'00'       ACTIVITY KEYPOINT FLAG              @BA39853\nCSAINAKP EQU   X'80'       'IN ACTIVITY KEYPOINT'              @BA39853\n***********************************************************************\n         DC    F'0'        ...RESERVED                      @EU71X @L3C\nCSAABPSW DC    F'0'        ABEND PSW SAVE AREA ADDRESS         @BA70513\n*                            (DOS ONLY)                               *\n         DC    3A(0)       ...RESERVED                         @BBDA20X\nCSAWTOAD DS    A           WRITE-TO-OPERATOR ROUTINE ADDRESS       @DHC\n         DC    2A(0)       ...RESERVED                         @BB5A01J\n         DS    A           RESERVED                         @01281 @P7C\n***********************************************************************\n*        T A S K   A B N O R M A L   T E R M I N . I N T E R F A C E  *\n***********************************************************************\nCSAICFNA DC    A(&ABEND)   ADDRESS OF ABEND ROUTINE            @BBDA20X\n         DS    (X'1A0'-*+DFHCSABA)C CHECK COMMITTED OFFSET  @GBS1B @LHA\nCSAICRNX BR    14          NOP/BRANCH FLUSH RETURN INTERFACE   @BBDA20X\n         L     15,CSAICFNA LOAD ABEND ROUTINE ENTRY ADDRESS    @BBDA20X\n         BR    15          ...GO TO ABEND TASK FLUSH ROUTINE   @BBDA20X\nCSAICRIN EQU   CSAICRNX+1  ABEND TASK INDICATOR BYTE           @BBDA20X\nCSAICRMN EQU   X'0E'       .. ABEND TASK INDICATOR MASK - ON   @BBDA20X\nCSAICRMF EQU   X'FE'       .. ABEND TASK INDICATOR MASK - OFF  @BBDA20X\n***********************************************************************\n*          T I M E   M A N A G E M E N T   S T O R A G E              *\n***********************************************************************\nCSATODTU DC    F'0'        BINARY TIME OF DAY IN 300THS OF A   @BBDA20X\n*                            SECOND                                   *\nCSATCNDT DC    F'0'        TERMINAL CONTROL'S NEXT DISPATCH    @BBDA20X\n*                            TIME OF DAY IN 300THS OF A               *\n*                            SECOND                                   *\nCSAICRIC DS    F           RUNAWAY TASK TIME INTERVAL IN       @BBDA20X\n*                            300THS OF A SECOND IN THREE HIGH-        *\n*                            ORDER BYTES                              *\nCSAICRUN DC    PL2'0'      NUMBER OF RUNAWAY TASKS FLUSHED     @BBDA20X\nCSARDATC DC    X'00'       RELATIVE DATE COUNTER (BINARY)      @BB1101J\n         DC    X'00'       ...RESERVED                         @BB1101J\n***********************************************************************\n* * *                   W O R K A R E A                           * * *\n***********************************************************************\n         DC    C'WORKAREA' MEMORY COMMENT - 'WORKAREA'         @BBDA20X\n***********************************************************************\n* *                       S Y S T E M   S T A T I S T I C S         * *\n***********************************************************************\n*                           T A S K   C O N T R O L                   *\n***********************************************************************\nCSAKCMTC DC    F'0'        NUMBER OF TIMES AT MAXIMUM TASKS @01553 @DGA\nCSAKPCNT DC    PL2'0'      ACTIVITY KEYPOINT COUNTER           @BBDA20X\nCSAIOCP  DS    H           I/O WAIT COUNT PERCENTAGE           @BB610BC\nCSAKCCT  DC    PL2'0'      CURRENT TASK ACCUMULATOR            @BBDA20X\nCSAKCMTA DC    PL2'0'      MAXIMUM NUMBER OF TASKS             @BBDA20X\n*                          ACCUMULATED                                *\nCSAKCTTA DC    PL3'0'      TASK ORIGINATED ACCUMULATOR - TOTAL @BBDA20X\n*                            NUMBER OF TASKS CICS/VS HAS              *\n*                            ORIGINATED                               *\n***********************************************************************\n*                           S T O R A G E   C O N T R O L             *\n***********************************************************************\nCSASCAR  DC    FL4'0'      NUMBER OF STORAGE CONTROL GETMAINS      @LVC\n*                            THAT HAVE BEEN REQUESTED                 *\nCSASCFI  DC    FL4'0'      NUMBER OF STORAGE CONTROL FREEMAINS     @LVC\n*                            THAT HAVE BEEN REQUESTED                 *\nCSASCCR  DC    HL2'0'      NUMBER OF TIMES THE STORAGE CUSHION     @LVC\n*                            HAS BEEN RELEASED                        *\nCSASCRQ  DC    HL2'0'      NUMBER OF STORAGE REQUESTS QUEUED       @LVC\n*                            BECAUSE STORAGE NOT AVAILABLE            *\nCSASCMQ  DC    HL2'0'      MAXIMUM NUMBER OF STORAGE REQUESTS      @LVC\n*                            QUEUED AT ANY ONE TIME BECAUSE           *\n*                            STORAGE NOT AVAILABLE                    *\nCSASCQZ  DC    HL2'0'      NUMBER OF TIMES THE STORAGE QUEUED      @LVC\n*                            CHAIN STARTED FORM ZERO                  *\n***********************************************************************\n*                           P R O G R A M   I N T E R R U P T         *\n***********************************************************************\nCSAPINI  DC    HL2'0'      NUMBER OF PROGRAM INTERRUPTS            @LVC\n***********************************************************************\n*                           D U M P   C O N T R O L                   *\n***********************************************************************\nCSADCND  DC    HL2'0'      NUMBER OF STORAGE DUMPS                 @LVC\n***********************************************************************\n*                           T E M P   S T O R A G E   C O N T R O L   *\n***********************************************************************\nCSATSMSA DC    PL3'0'      ...RESERVED...                      @BBDA20X\nCSATSASA DC    PL3'0'      ...RESERVED...                      @BBDA20X\n***********************************************************************\n*                           S E R V I C E   P R O G R A M S           *\n***********************************************************************\nCSASPA1  DC    PL2'0'      SERVICE PROGRAM ACCUMULATOR 1       @BBDA20X\n*                            (RESERVED)                               *\nCSASPA2  DC    PL2'0'      SERVICE PROGRAM ACCUMULATOR 2       @BBDA20X\n*                            (RESERVED)                               *\nCSASPA3  DC    PL3'0'      SERVICE PROGRAM ACCUMULATOR 3       @BBDA20X\n*                            (DUMP CONTROL WRITE ERROR COUNT)         *\nCSATDNT  DC    PL3'0'      RESERVED - NO LONGER USED        @E131U @LFC\n***********************************************************************\n*                           U S E R   T R A N S A C T I O N           *\n***********************************************************************\nCSAUTA1  DC    PL3'0'      USER TRANSACTION ACCUMULATOR 1      @BBDA20X\nCSAUTA2  DC    PL3'0'      USER TRANSACTION ACCUMULATOR 2      @BBDA20X\nCSAUTA3  DC    PL3'0'      USER TRANSACTION ACCUMULATOR 3      @BBDA20X\nCSAUTA4  DC    PL3'0'      USER TRANSACTION ACCUMULATOR 4      @BBDA20X\n***********************************************************************\n         DC    X'00'       DUMMY PROGRAM TYPE OF REQUEST SAVE AREA     *\n                             - USED BY DUMMY PROGRAMS AS FIELD         *\n                             CSATSTR                           @BB6A00C\nCSACSAEA EQU   *           END OF CSA\n         SPACE ,                                               @BBDA20X\n***********************************************************************\n* *            O P T I O N A L   F E A T U R E   L I S T            * *\n***********************************************************************\n         AIF   ('&TYPE' NE 'DSECT').CSECT2                     @BBDA20X\nCSAOPFL  DSECT             OPTIONAL FEATURE LIST DSECT         @BBDA20X\n.CSECT2  ANOP                                                  @BBDA20X\n         AIF   ('&TYPE' NE 'CSECT').DSECT2                     @BBDA20X\nCSAOPFL  DS    0D                                              @BBDA20X\n.DSECT2  ANOP                                                  @BBDA20X\n         DS    A           RESERVED - WAS USED BY ATP\nCSAATTCH DS    A           ATTACH LIST ADDRESS - O/S           @BBDA20X\nCSADLI   DS    A           DL/I INTERFACE CONTROL AREA ADDRESS @BBDA20X\n         DS    (X'C'-*+CSAOPFL)C CHECK COMMITTED OFFSET     @GBS1B @LHA\nCSABFNAC DS    A           ADDRESS OF BUILT-IN FUNCTIONS       @BBDA20X\n         DS    (X'10'-*+CSAOPFL)C CHECK COMMITTED OFFSET    @GBS1B @LHA\nCSABMS   DS    A           BASIC MAPPING SUPPORT CONTROL       @BBDA20X\n*                            PROGRAM ADDRESS                          *\nCSATMSVT DS    A           TERMINAL MONITOR SYSTEM (TMS)       @BBDA20X\n*                            VECTOR TABLE ADDRESS                     *\n         DS    (X'18'-*+CSAOPFL)C CHECK COMMITTED OFFSET    @GBS1B @LHA\nCSAJCNA1 DS    A           JOURNAL CONTROL MACRO ENTRY         @BBDA20X\n*                            POINTER 1                                *\n         DS    (X'1C'-*+CSAOPFL)C CHECK COMMITTED OFFSET    @GBS1B @LHA\nCSAJCNA2 DS    A           JOURNAL CONTROL MACRO ENTRY         @BBDA20X\n*                            POINTER 2                                *\nCSASRNAC DS    A           SYSTEM RECOVERY PROGRAM ENTRY       @BBDA20X\n*                            ADDRESS                                  *\nCSASRTBA DS    A           ADDRESS OF SYSTEM RECOVERY TABLE    @BBDA20X\nCSAKPNAC DS    A           KEY-POINT PROGRAM ENTRY ADDRESS     @BBDA20X\nCSAATMSP DS    A           A T M S CONTROL POINTER             @BBDA20X\nCSAXLTBA DS    A           ADDRESS OF SYSTEM TERMINATION       @BBDA20X\n*                            TRANSACTION LIST TABLE                   *\nCSAJCTBA DS    A           ADDRESS OF JOURNAL CONTROL TABLE    @BB6A00C\nCSATCFIP DS    A           RESERVED                            @BB6A00C\nCSATSTBA DS    A           ADDRESS OF TEMPORARY STORAGE TABLE  @BB6623D\nCSASTSP1 DS    0F          STATISTICS LOCKS                    @BB6A05C\nCSASTSRC DS    B           RETURN CODE                         @BB6A05C\nCSASTSLF DS    B           LOCK FLAG                           @BB6A05C\nCSASTSTD EQU   X'01'       .. NON-AUTO STATISTICS              @BB6A05C\nCSASTAUT EQU   X'02'       .. AUTO STATISTICS                  @BBDA20X\nCSASTCAN EQU   X'04'       .. ICE CANCEL FAILED INDICATOR      @BBDA20X\nCSAXCTKC EQU   X'08'       .. DFHSTSP TRANSFERRED CONTROL TO   @BBDA20X\n*                            DFHSTKC                                  *\nCSASTERM EQU   X'10'       .. TERMINATION REQUESTS CANCEL      @BBDA20X\nCSASTSIN DS    H           INTERVAL LENGTH                     @BBDA20X\nCSASTDST DS    F           AUTOMATIC STATISTICS DESTINATION    @BB6A05C\nCSAPDLIM DS    H           PRIMARY DESTINATION LIMIT           @BB6A05C\nCSAPDCNT DS    H           PRIMARY DESTINATION COUNT           @BB6A05C\nCSAADLIM DS    H           ALTERNATE DESTINATION LIMIT         @BB6A05C\nCSAADCNT DS    H           ALTERNATE DESTINATION COUNT         @BB6A05C\nCSAFDNAC DS    A           ADDRESS OF FORMATTED DUMP PROGRAM   @BBAI30O\nCSAPLISL DS    A           ADDRESS OF SHARED LIBRARY COMMON    @BB8E21Q\n*                            MODULES                                  *\nCSAPLISM DS    A           ADDRESS OF SHARED LIBRARY           @BB8E21Q\n*                            NON-TASK-ONLY MODULES                    *\nCSAOPF0E DS    0H                                              @BM11120\nCSASRAA  DC    A(&SRA)     ADDRESS OF SRB CONTROL AREA         @BC9HNDI\nCSAPCAA  DC    A(&PCA)     ADDRESS OF PAGING CONTROL AREA      @BC9HNDI\n*                                                                     *\nCSAOPF1S DS    0H                                              @BM11120\nCSADBDBL DS    H           DYNAMIC BUFFER LENGTH               @BB9683O\nCSADBPSF DS    CL2         DYNAMIC BACKOUT PROGRAM SUFFIX      @BB9683O\nCSASTTOD DS    F           CICS INIT. TOD BIT 0-31             @BA34773\n         DS    PL2         RESERVED                            @BA34773\nCSASVD   DS    AL1         NUMBER OF STORAGE VIOLATIONS TO BE  @BB9673Q\n*                            DUMPED                                   *\nCSAFEOPT DS    B           FERS OPTION BYTE                    @BDD677X\nCSAFEAUX EQU   X'04'       .. AUXILIARY TEMPORARY STORAGE      @BBD677X\nCSAFEWST EQU   X'02'       .. WARM START                       @BBD677X\nCSAFERST EQU   X'01'       .. EMERGENCY RESTART                @BBD677X\nCSADINAC DS    A           DATA INTERCHANGE MODULE ADDRESS     @BB9960I\nCSASTYDP DS    A           CICS/VS START-UP DATE IN THE FORM   @BDD676X\n*                            00YYDDDC WHERE YY IS THE YEAR, DDD       *\n*                            IS THE DAY AND C IS A POSITIVE SIGN      *\nCSAFCXAD DS    A           ADDRESS OF DFHFCX VSAM UPAD EXIT        @LKC\n         SPACE 1                                            @EA00X @LBA\nCSAOPF1E DS    0H                                              @BM10045\nCSACSAAD DC    A(&CSA)     ADDRESS OF CSA                      @BM10045\nCSALFNAC DC    A(&LFP)     STANDARD LIFO PROLOGUE ROUTINE      @BBAA12Y\n*                            ADDRESS                                  *\nCSAOPF2S DS    0H                                              @BM10045\nCSALONAC DS    A           LIFO STORAGE OVERFLOW ROUTINE       @BM10045\n*                            ADDRESS                                  *\nCSAMGNAC DS    A           ADDRESS OF DFHMGP MESSAGE PROGRAM   @BBAA12Y\nCSAMGTAC DS    A           ADDRESS OF MESSAGE TABLE            @BBAA12Y\n         DS    2A          RESERVED                         @EA00X @LBA\n         SPACE 2                                            @EA00X @LBA\n***********************************************************************\n* * *                                                             * * *\n* * *                M O D U L E   A D D R E S S E S              * * *\n* * *                                                             * * *\n***********************************************************************\n         SPACE 1                                            @EA00X @LBA\n***********************************************************************\n* *            ISC MODULE ADDRESSES                                 * *\n***********************************************************************\nCSAELRNA DS    A           ADDRESS OF EXEC LOCAL/REMOTE PROGRAM        *\n                                                               @BBAI00S\nCSAXFPNA DS    A           ADDRESS OF EXEC TRANSFORMER PROGRAM @BBAI00S\nCSAISPNA DS    A           ADDRESS OF EXEC INTERSYSTEM PROGRAM @BBAI00S\nCSAXTPNA DS    A           ADDRESS OF TERMINAL SHARING TRANSFORMER     *\n                             PROGRAM                           @BDDJ20B\n         SPACE 1                                            @EA00X @LBA\n***********************************************************************\n* *            EXEC INTERFACE MODULE ADDRESSES                      * *\n* *              (ORDERED BY FUNCTION GROUP CODE VALUE)             * *\n***********************************************************************\nCSAEINAC DS    A           ADDRESS OF EXEC NUCLEUS             @BBAC83M\nCSAEEINA DS    A           ADDRESS OF EXEC ONLY STUB           @BBAC83M\nCSAETCNA DS    A           ADDRESS OF TERMINAL CONTROL STUB    @BBAC83M\nCSAEFCNA DS    A           ADDRESS OF FILE CONTROL STUB        @BBAC83M\nCSAETDNA DS    A           ADDRESS OF TRANSIENT DATA STUB      @BBAC83M\nCSAETSNA DS    A           ADDRESS OF TEMPORARY STORAGE STUB   @BBAC83M\nCSAESCNA DS    A           ADDRESS OF STORAGE CONTROL STUB     @BBAC83M\nCSAEPCNA DS    A           ADDRESS OF PROGRAM CONTROL STUB     @BBAC83M\nCSAEICNA DS    A           ADDRESS OF INTERVAL CONTROL STUB    @BBAC83M\nCSAEKCNA DS    A           ADDRESS OF TASK CONTROL STUB        @BBAC83M\nCSAEJCNA DS    A           ADDRESS OF JOURNAL CONTROL STUB     @BBAC83M\nCSAESPNA DS    A           ADDRESS OF SYNC POINT STUB          @BBAC83M\nCSAEMSNA DS    A           ADDRESS OF BASIC MAPPING STUB       @BBAC83M\nCSAETRNA DS    A           ADDRESS OF TRACE CONTROL STUB       @BBAC83M\nCSAEDCNA DS    A           ADDRESS OF DUMP CONTROL STUB        @BBAC83M\nCSAEDINA DS    A           ADDRESS OF DATA INTERCHANGE STUB    @BBAC83M\nCSAEBFNA DS    A           ADDRESS OF BUILT-IN FUNCTION STUB   @BBAC83M\nCSAUEMNA DS    A           ADDRESS OF USER EXIT MANAGER        @BBDU50X\nCSAEGLNA DS    A           ADDRESS OF LU6.2 UNMAPPED STUB   @EI00U @L6A\n         DS    A           Spare                                   @LPC\nCSAEPLSA DS    A           ADDRESS OF ROUTINES VECTOR              @P7C\n*   FURTHER EXECUTION INTERFACE MODULE ADDRESSES                      *\nCSAERMNA DS    A           ADDRESS OF RESOURCE MANAGER I/F  @EI00U @D8A\nCSAETLNA DS    A           ADDRESS OF LU6.2 MAPPED STUB     @EI00U @L6A\nCSAEBUNA DS    A           ADDRESS OF FMH BUILDER              @BBDIA0X\nCSAEEXNA DS    A           ADDRESS OF FMH EXTRACTOR            @BBDIA0X\n         SPACE 1                                            @EA00X @LBA\n***********************************************************************\n* *            TERMINAL CONTROL MODULE ADDRESSES                    * *\n***********************************************************************\nCSATCNCA DS    A           ADDRESS OF DFHZCA                   @BBAL032\nCSATCNCB DS    A           ADDRESS OF DFHZCB                   @BBAL032\nCSATCNCC DS    A           ADDRESS OF DFHZCC                @EI00U @L6A\nCSATCNCP DS    A           ADDRESS OF DFHZCP                   @BBAL032\nCSATCNCW DS    A           ADDRESS OF DFHZCW                @EI00U @L6A\nCSATCNCX DS    A           ADDRESS OF DFHZCX                   @BBAL032\nCSATCNCY DS    A           ADDRESS OF DFHZCY                   @BBAL032\nCSATCNCZ DS    A           ADDRESS OF DFHZCZ                   @BBAL032\n         SPACE 1                                            @EA00X @LBA\n***********************************************************************\n* * *          BASIC MAPPING SUPPORT MODULE ENTRY ADDRESSES       * * *\n***********************************************************************\nCSARLREA DS    A           ADDRESS OF ROUTE LIST RESOLUTION PROGRAM    *\n                                                               @BBDA20X\nCSAPBPEA DS    A           ADDRESS OF PAGE BUILD PROGRAM       @BBDA20X\nCSAM32EA DS    A           ADDRESS OF 3270 MAPPING PROGRAM     @BBDA20X\nCSAMCXEA DS    A           ADDRESS OF BMS FAST PATH MODULE  @01378 @D9C\nCSATPPEA DS    A           ADDRESS OF TERMINAL PAGING PROGRAM  @BBDA20X\nCSAIIPEA DS    A           ADDRESS OF NON-3270 INPUT MAPPING PROGRAM   *\n                                                               @BBDA20X\nCSADWEXA DS    A           ADDRESS OF DWE PROCESSING EXIT      @BBDA20X\nCSADSBEA DS    A           ADDRESS OF DATA STREAM BUILD PROGRAM        *\n                                                               @BD5D01S\nCSAPHPEA DS    A           ADDRESS OF PARTITION HANDLING PROGRAM       *\n                                                            @E5E2C @H1A\nCSAML1EA DS    A           ADDRESS OF LU TYPE 1 MAPPING PROGRAM        *\n                                                            @E5E4C @H2A\n         SPACE 1                                            @EA00X @LBA\nCSAOPF2E DS    0F                                              @BBDCA0X\nCSAOPF3S DS    0F                                              @BBDCA0X\n         SPACE 1                                            @EA00X @LBA\n***********************************************************************\n* *            MISCELLANEOUS PROGRAM ADDRESSES                      * *\n***********************************************************************\nCSASCRNA DS    A           ADDRESS OF STORAGE RECOVERY PROGRAM @BBDJ31X\nCSAPCNNA DS    A           ADDRESS OF NON-WORKING SET PROGRAM CONTROL  *\n                             PROGRAM                           @BBAL01H\nCSADANAC DS    A           ADDRESS OF DYNAMIC ALLOCATION ROUTINE       *\n                             (MVS ONLY)                     @01270 @D6A\nCSAVSPNA DS    A           ADDRESS OF VSAM FILE CONTROL SUBTASK        *\n                             PROGRAM (MVS ONLY)                @BA05383\nCSATMPNA DS    A           ADDRESS OF TABLE MANAGER PROGRAM @EU71X @L3A\nCSATRPAC DS    A           ADDRESS OF TRACE PROGRAM            @BBDU20X\nCSAXSNAC DS    A           ADDRESS OF EXTERNAL SECURITY PROGRAM        *\n                                                               @BBDCA0X\nCSAALPNA DS    A           ADDRESS OF ALLOCATION PROGRAM       @BBDI80O\nCSAACPNA DS    A           ADDRESS OF ABNORMAL CONDITION PROGRAM       *\n                                                               @BBDI80O\nCSAIRPNA DS    A           ADDRESS OF INTER-REGION COMMUNICATION       *\n                             PROGRAM                           @BDA890X\nCSAUEHNA DS    A           ADDRESS OF USER EXIT HANDLER PROGRAM        *\n                                                               @BBDU50X\nCSAVCNAC DS    A           ADDRESS OF VOLUME MANAGER PROGRAM           *\n                                                            @E211Q @L2A\nCSAPCCBL DS    A           MACRO INTERFACE ENTRY IN DFHPCP  @EU60Z @L7C\nCSAXFXNA DS    A           ADDRESS OF FAST-PATH TRANSFORMER PROGRAM    *\n                                                            @FJ42X @LCA\nCSASPZNA DS    A           ADDRESS OF DFHSPZ (ISC SYNC PROTOCOL)   @DEA\nCSAPSNAC DS    A           SYSTEM SPOOLING INTERFACE CONTROL PROGRAM   F\n                             ENTRY POINT                           @LIC\nCSASKMNA DS    A           SUBTASK MANAGER                         @LJA\n*                            PROGRAM ENTRY POINT\nCSACCPNA DS    A           ADDRESS OF CATALOG CONTROL PROGRAM      @LLA\nCSARCPNA DS    A           ADDRESS OF RECOVERY CONTROL PROGRAM     @LMA\nCSAZBANA DS    A           ADDRESS OF ZC BIND ANALYSIS             @LQA\nCSATBSNA DS    A           ADDRESS OF TABLE BUILDER SERVICES       @LQA\nCSATBSSA DS    A           ADDRESS OF TBS DWE PROCESSOR (DFHTBSSP) @LQA\nCSAXQONA DS    A           ADDRESS of XRF tracking queue organiser @LZC\nCSADESNA DS    A           ADDRESS OF DATA ENCRYPTION STANDARD (DES)   *\n                                   MODULE..............            @LRA\nCSATONNA DS    A           ADDRESS OF TERMINAL OBJECT NUCLEUS MODULE   F\n                                                                   @LTC\n         SPACE 2                                            @EA00X @LBA\n***********************************************************************\n* * *                                                             * * *\n* * *        M I S C E L L A N E O U S   T A B L E   A N D        * * *\n* * *                                                             * * *\n* * *        C O N T R O L   B L O C K   A D D R E S S E S        * * *\n* * *                                                             * * *\n***********************************************************************\n         SPACE 1                                            @EA00X @LBA\nCSAOPF3E DS    0F                                              @BBDCA0X\n*   ADDRESSES OF CONTROL BLOCKS WITHIN MODULE DFHCSA.                 *\nCSASECBL DC    A(&SECBL)   ADDRESS OF SECURITY CLASS BLOCK     @BBDCA0X\nCSAMXTAD DC    A(&MXTDS)   ADDRESS OF MAX TASK FIELDS       @01281 @D7A\nCSAOPF4S DS    0F                                              @BBDCA0X\n         SPACE 1                                            @EA00X @LBA\n*   ADDRESSES OF CONTROL BLOCKS NOT WITHIN MODULE DFHCSA.             *\nCSASSA   DS    A           ADDRESS OF STATIC STORAGE AREA ADDRESS LIST *\n                                                               @BBDJ30X\nCSATCSEA DS    A           ADDRESS OF LOCAL TERMINAL CONTROL SYSTEM    *\n                             ENTRY                             @BBDI80X\nCSAUETBA DS    A           ADDRESS OF USER EXIT TABLE          @BBDU50X\n         SPACE 1                                            @ECB1D @L1A\nCSAMCTBA DS    A           ADDRESS OF MONITOR CONTROL TABLE    @BBDU20X\n         SPACE 1                                            @EA00X @LBA\nCSAPCTTA DS    A           ADDRESS OF PROGRAM CONTROL TABLE PREFIX     *\n                                                               @BBDIA0X\nCSASTRTA DS    A           ADDRESS OF PROGRAM CHECK / ABEND TRACE      *\n                             TABLE                             @BCAI30O\nCSACRBA  DS    A           ADDRESS OF CICS REGION BLOCK        @BCA890E\n         SPACE 1\nCSASDTA  DS    A           ADDRESS OF SERIES DEFINITION TABLE (WHEREBY *\n                             HANG ALL VOLUME MANAG'T DATA)  @E211Q @L2C\nCSAKPPVC DS    A           ADDRESS OF KEYPOINT ADDRESS VECTOR          *\n                                                            @E2105 @DBC\nCSAVSCAA DS    A           ADDRESS OF VSCA                         @LDA\nCSATDSTA DS    A           ADDRESS OF TD STATIC STORAGE     @E131U @LEA\nCSAPSCBA DS    A           ADDR OF SYSTEM SPOOLING INTERFACE GLOBAL    F\n                              CONTROL BLOCK                        @LIC\nCSADLECB DS    A           DLI RESTART TASK ECB                    @LNA\nCSADLPST EQU   X'40'       DLI RESTART TASK POST BIT               @LNA\nCSADLRRC DS    AL1         DLI RESTART TASK RETURN CODE            @LHC\nCSADLNRM EQU   0           .. NORMAL RESPONSE                      @LHA\nCSADLDER EQU   16          .. DISASTROUS ERROR                     @LHA\n         DS    CL3         RESERVED FOR DLI RESTART TASK           @LNA\n         DS    A                   RESERVED FOR 1.7                @LTC\nCSADART  DC    A(0)        DART GLOBAL CONTROL BLOCK ANCHOR        @DJC\n         DS    2A                  RESERVED FOR 1.7                @LTC\n         SPACE 1                                                   @LLA\n***********************************************************************\n*              CATALOG COMMUNICATION FLAG BYTE                        *\n***********************************************************************\nCSACATFL DC    X'00'       CICS CATALOG FLAG BYTE                  @LLA\nCSACATDF EQU   X'80'       .. CATALOG DEFINED                      @LLA\n         SPACE 1                                                   @LLA\n***********************************************************************\n*              SYSTEM LOG COMMUNICATION FLAG BYTE                     *\n***********************************************************************\nCSALOGFL DC    X'00'       CICS SYSTEM LOG FLAG BYTE               @LLA\nCSALOGDF EQU   X'80'       .. SYSTEM LOG DEFINED ..                @LLA\nCSALOGDI EQU   X'40'          .. ON DISK                           @PAA\nCSALOGTP EQU   X'20'          .. ON TAPE                           @PAA\n         SPACE 1                                                   @LLA\n***********************************************************************\n*              F.E. GLOBAL TRAP FLAG BYTE                             *\n***********************************************************************\nCSATRAFL DC    X'00'       CICS GLOBAL TRAP FLAG BYTE              @LXA\nCSATRADI EQU   X'80'       .. TRAP IS DISABLED                     @LXA\nCSATRAMU EQU   X'40'       .. TRAP MARKED UNUSABLE                 @LXA\nCSATRAUN EQU   X'20'       .. TRAP LOADED BUT NOT YET USED         @LXA\n         SPACE 1                                                   @LXA\n***********************************************************************\n         SPACE 1                                                   @LXA\nCSAALPFL DS    X           flag byte for DFHALP                @BA36028\nCSAALENS EQU   X'80'       ENABLE of XALTENF succeeded         @BA36028\nCSAALENF EQU   X'40'       ENABLE of XALTENF failed            @BA36028\n         SPACE 1                                                   @LXC\n***********************************************************************\n*              INTER-REGION COMMUNICATION FLAG BYTES                  *\n***********************************************************************\nCSACRFL1 DS    X           CICS REGION FLAG BYTE               @BCA890E\nCSACRNTC   EQU   X'80'     .. DFHTCP GENERATED WITHOUT IRC     @BCA890E\nCSACRNXF   EQU   X'40'     .. CICS INITIALISED WITHOUT DFHXFP  @BCA890E\nCSACRNAU   EQU   X'20'     .. DFHSIP IS NOT APF-AUTHORISED     @BCA890E\nCSACRSTF   EQU   X'10'     .. HIGH-LEVEL STAE FAILED           @BCA890E\nCSACRFL2 DS    X           CICS REGION FLAG BYTE 2             @BBDJ10X\nCSACRASS   EQU   X'80'     .. ASSOCIATE HAS BEEN ISSUED        @BBDJ10X\n         SPACE 1                                            @EA00X @LBA\n***********************************************************************\n* *            BASIC MAPPING SUPPORT FLAG BYTE                      * *\n***********************************************************************\nCSABMSFL DS    X           BMS FLAG BYTE                    @01185 @D1A\nCSACSPQI   EQU   X'80'     .. TRANSACTION CSPQ HAS BEEN INITIATED  @D1C\nCSAALIGN   EQU   X'40'     .. PRE 1.6 MAPS ARE ALIGNED      @01185 @D1A\nCSANDDS    EQU   X'20'     .. NO DEVICE DEPENDENT SUFFIXING @01208 @D3A\nCSANSKR    EQU   X'10'     .. NO SINGLE KEY RETRIEVAL       @01208 @D3A\nCSAEMSIC   EQU   X'08'     .. INDICATE DFHEMS IS IN CONTROL    @BA12206\n         DS    X           RESERVED                         @01185 @D1A\n         SPACE 1                                            @EA00X @LBA\n***********************************************************************\n* *            EXTERNAL SECURITY FIELDS                             * *\n***********************************************************************\nCSAXSFLG DS    X           EXTERNAL SECURITY FLAG              @BBDCA0X\nCSAXSCR    EQU   X'80'     .. EXTERNAL SECURITY REQUESTED      @BBDCA0X\nCSAXSCA    EQU   X'40'     .. EXTERNAL SECURITY ACTIVE         @BBDCA0X\nCSAXSCP    EQU   X'20'     .. USER PREFIX REQUIRED          @GBS1B @LGA\n         DS    3X          RESERVED                            @BBDCA0X\nCSAXSNM  DS    CL8         CICS/VS SYSTEM NAME                 @BBDCA0X\n         SPACE 1                                            @EA00X @LBA\n***********************************************************************\n*        EXECUTABLE SUPERVISOR CALL INSTRUCTIONS                      *\n***********************************************************************\n         DS    F                   RESERVED FOR FUTURE USE     @BM11151\n         SPACE 1                                            @EA00X @LBA\nCSASVSVC DS    0H          SERVICE SVC...                      @BM11151\n         DS    X           ...FROM CICSSVC                     @BM11151\nCSASVSNO DS    X           SERVICE SVC NUMBER                  @BM11151\n         SPACE 1                                            @EA00X @LBA\nCSASISVC DS    0H          SERVICE INITIATION SVC...           @BM11151\n         DS    X           ...FROM SRBSVC                      @BM11151\nCSASISNO DS    X           SERVICE INIT.SVC NUMBER             @BM11151\n         SPACE 1                                            @EA00X @LBA\n***********************************************************************\n* *            STATISTICS FIELDS                                    * *\n***********************************************************************\nCSACGFL  DS    H           NUMBER OF CONDITIONAL GETMAIN FAILURES      *\n                                                               @BBDI80O\nCSATBSDD DS    H           TBS DIAGNOSTIC DUMP REASON CODE (DFHBSMSG)  F\n                                                                   @LQA\nCSAKCTOF DS    F           STATISTICS - TASK COUNT OVERFLOW @15229 @P1C\nCSAXSTMA DS    A           XRF session tracking map anchor         @N1A\n         DS    2F          RESERVED                         @GBS1B @N1C\n         SPACE 1                                            @EA00X @LBA\n***********************************************************************\n* *            PROTECTED STORAGE ADDRESS LIMITS (OS ONLY)           * *\n***********************************************************************\nCSAPROTL DS    A           LOWER LIMIT OF PROTECTION (OS ONLY) @BI01182\nCSAPROTU DS    A           UPPER LIMIT OF PROTECTION (OS ONLY) @BI01182\n*                NOTA BENE - ABOVE 2 FIELDS MUST BE CONTIGUOUS        *\n         SPACE 1                                            @EA00X @LBA\n***********************************************************************\n* *            RESOURCE MANAGER INTERFACE RECOVERY FIELDS           * *\n***********************************************************************\nCSAERRT  DS    D           RECOVERY TOKEN AT EMERGENCY RESTART TIME    F\n                                                            @ECB1D @L1A\nCSACSRT  DS    D           RECOVERY TOKEN AT LAST COLD START           F\n                                                            @ECB1D @L1A\nCSAURDA  DS    A           ADDRESS OF FIRST IN URD CHAIN    @ECB1D @L1A\nCSAURDHW DS    F           URD NUMBER HIGH WATER MARK       @EIA5D @L9A\n         SPACE 1                                            @01296 @DAA\n***********************************************************************\n* *            CICS/VS SERVICE-LEVEL SUPPORT FIELD                  * *\n***********************************************************************\nCSACICNA DS    A           ADDRESS OF SERVICE-LEVEL ENTRYPT @EIA5D @L9A\n         SPACE 1                                            @EIA5D @L9A\n***********************************************************************\n* *            EXTENDED STORAGE ANCHOR ADDRESS                      * *\n***********************************************************************\nCSASCXCA DS    A           SHARED STORAGE ANCHOR            @EG00X @L8C\n         SPACE 1                                            @EA00X @LBA\n***********************************************************************\n* *            SPECIAL INTERFACE AREA                               * *\n***********************************************************************\nCSACOBIL DS    F           SPECIAL INTERFACE LEVEL\nCSACOBFG DS    XL4         FLAGS                            @EE13S @LAA\nCSACOBIN   EQU   X'80'     .. SPECIAL IN SYSTEM             @EE13S @LAA\nCSACOBPT DS    CL8         COBOL PARTITION TOKEN            @EE13S @LAA\nCSACOBRA DS    A           ADDRESS OF INTERFACE ROUTINE     @EE13S @LAA\n         SPACE 1                                            @EA00X @LBA\n***********************************************************************\n* *            CICS/VS SYSTEM DEFINITION USER COUNT                 * *\n***********************************************************************\nCSACSDCT DS    F           NUMBER OF CURRENT USERS OF CICS/VS SYSTEM   *\n                             DEFINITION                     @EU71X @L3A\n         SPACE 2                                            @EA00X @LBA\nCSADBLA  DS    F           DYNAMIC BACKOUT LOG ACCESS      @EAPARG @01C\nCSADBSA  DS    F           DYNAMIC BACKOUT SPILL ACCESS    @EAPARG @01A\n         SPACE 2\n***********************************************************************\n* *            V.SPECIAL INTERFACE AREA                             * *\n***********************************************************************\nCSAVSPIL DS    F           V.SPECIAL INTERFACE LEVEL               @LOA\nCSAVSPFG DS    XL4         FLAGS                                   @LOA\nCSAVSPIN EQU   X'80'       ..V.SPECIAL INITIALISED                 @LOA\nCSAVSPCH EQU   X'40'       ..=1 DURING 'DELIBERATE' PROG. CHK.     @LOA\nCSAVSPPT DS    CL8         V.SPECIAL PARTITION TOKEN               @LOA\nCSAVSPEP DS    A           ADDRESS OF INTERFACE ROUTINE            @LOA\nCSAVSPTL DS    F           LENGTH OF PREALLOCATED THREAD LOCAL STG @LOA\nCSAVSPRL DS    F           LENGTH OF PREALLOCATED RUNUNIT LOCAL STG.   F\n                                                                   @LOA\n         SPACE 1                                                   @LOA\n         DS    1F          ... RESERVED                            @LOC\nCSAOPF4E DS    0H                                              @BM10045\n         DC    2F'0'      ... RESERVED                      @16793 @P3A\n         SPACE 1                                            @EA00X @LBC\n***********************************************************************\n* * *                                                             * * *\n* * *          F U R T H E R   M I S C E L L A N E O U S          * * *\n* * *                                                             * * *\n* * *             P R O G R A M     A D D R E S S E S             * * *\n* * *                                                             * * *\n***********************************************************************\n         SPACE 1                                                   @LHA\nCSAOPF5S DS    0F          BLOCK 5 ADDRESSES TO RELOCATE IN SIB1D  @LHA\n***********************************************************************\n*        ENTRY POINTS OF SOME EXEC INTERFACE ROUTINES                 *\n*        THESE ENTRY POINTS ARE INDEXED BY EIP FUNCTION GROUP.        *\n*        THIS TABLE IS ADDRESSED FROM THE FIELD CSAEPLSA, BUT BY      *\n*        OFFSETS FROM CSAOPFL IN DFHSIB ONLY.                         *\n***********************************************************************\n*#########\n* THE INQUIRE/SET MODULES DFHEIQ.. BECOME NONRESIDENT.\n* THEIR SLOTS BELOW ARE NO LONGER TESTED OR SET BY DFHEIP, AND\n* ARE THEREFORE REDUNDANT.\n*#########\nCSAEPLS  DS    0A          START OF ENTRY POINTS                   @P7C\nCSAEIDTI DS    A    X'4A'  DFHEIDTI   DATE/TIME           (NUCL)\nCSAEIQDS DS    A    X'4C'  DFHEIQDS   INQUIRE/SET DATASET          @LPA\nCSAEIQSP DS    A    X'4E'  DFHEIQSP   INQUIRE/SET PROGRAM          @LPC\nCSAEIQSX DS    A    X'50'  DFHEIQSX   INQUIRE/SET TRANSACTION      @LPA\nCSAEIQST DS    A    X'52'  DFHEIQST   INQUIRE/SET TERMINAL         @LPC\nCSAEIQSA DS    A    X'54'  DFHEIQSA   INQUIRE/SET ATTRIBUTE        @LPA\nCSAEPSNA DS    A    X'56'  DFHEPS     SYS SPOOLING EXEC I/F   (NUCL)\nCSAEIQSC DS    A    X'58'  DFHEIQSC   INQUIRE/SET CONNECTION       @LPA\nCSAEIQSM DS    A    X'5A'  DFHEIQSM   INQUIRE/SET MODENAME\n         DS    2A          RESERVED FOR FUTURE USE\n***********************************************************************\n*        END OF ENTRY POINTS TO EXEC INTERFACE ROUTINES               *\n***********************************************************************\n         SPACE 1                                                   @LXA\nCSATRANA DS    A           ADDRESS OF F.E. GLOBAL TRAP PROGRAM     @LXA\nCSATRRNA DS    A           ADDRESS OF RECOVERY ROUTINE FOR GLOBAL TRAP F\n                             EXIT (SET ONLY WHILE EXIT IN USE)     @LXA\nCSASKBS  DS    A           GENERAL PURPOSE SUBTASK                     F\n                             SIP BOOTSTRAP ROUTINE ADDR (DOS ONLY) @LJC\nCSAFFSPA DS    A           ADDRESS OF FFS PROGRAM             @N2C @LHA\n         DS    A           RESERVED FOR FUTURE USE - #5            @LHA\n         DS    A           RESERVED FOR FUTURE USE - #6            @LHA\n         DS    A           RESERVED FOR FUTURE USE - #7            @LHA\n         DS    A           RESERVED FOR FUTURE USE - #8            @LHA\n         DS    A           RESERVED FOR FUTURE USE - #9            @LHA\n         DS    A           RESERVED FOR FUTURE USE - #10           @LHA\nCSAOPF5E DS    0H          END OF BLOCK 5 ADDRESSES                @LHA\n         SPACE 2                                            @EA00X @LHC\n***********************************************************************\n* * *                                                             * * *\n* * *          F U R T H E R   M I S C E L L A N E O U S          * * *\n* * *                                                             * * *\n* * *        C O N T R O L   B L O C K   A D D R E S S E S        * * *\n* * *                                                             * * *\n* * *                   A N D   F I E L D S                       * * *\n* * *                                                             * * *\n***********************************************************************\nCSAOPF6S DS    0F          BLOCK 6 ADDRESSES TO RELOCATE IN SIB1D  @LHA\n         DS    A           RESERVED FOR FUTURE USE - #1            @LHA\nCSATCBTI DS    D           CUMULATIVE TASK (TCB) TIME (MVS ONLY)   @LWA\n*                          BIT 51 = 1 MICROSECOND. UPDATED ONLY WHEN\n*                          MONITORING IS INTERESTED IN THE CONTENTS\n         DS    A           RESERVED FOR FUTURE USE - #4            @LHA\n         DS    A           RESERVED FOR FUTURE USE - #5            @LHA\n         DS    A           RESERVED FOR FUTURE USE - #6            @LHA\nCSACRNPA DS    A           Address of DFHCRNP                  @BA24686\n***********************************************************************\n*        START OF XRF SPECIFIC ADDRESSES                              *\n***********************************************************************\nCSAXRPNA DS    A           Address of DFHXRP                       @LZC\nCSAXRSNA DS    A           Address of DFHXRSP                      @LZC\n         DS    A           ... Reserved for XRF                    @LZC\nCSAXRFNT DS    A           Address of XRF entry table              @LYC\n***********************************************************************\n*        END OF XRF SPECIFIC ADDRESSES                                *\n***********************************************************************\nCSAOPF6E DS    0H          END OF BLOCK 6 ADDRESSES                @LHA\nCSAMXTBA DS    0D  RESERVED - FOR COMPATIBILITY ONLY - DO NOT MOVE @LHC\nCSAOPFLD EQU   *-CSAOPFL   OPTIONAL FEATURE LIST LENGTH     @EA00X @LBC\n         SPACE 2                                            @EA00X @LBA\n         DFHEJECT ,                                         @EA00X @LBA\n***********************************************************************\n* * *    MAXIMUM TASK IN CLASS DSECT                              * * *\n***********************************************************************\n         AIF   ('&TYPE' NE 'DSECT').CSECT4                  @01281 @D7A\nCSAMXTDS DSECT                     MAX TASK FIELD DSECT     @01281 @D7A\n.CSECT4  ANOP  ,                                            @01281 @D7A\n         AIF   ('&TYPE' NE 'CSECT').DSECT4                  @01281 @D7A\nCSAMXTDS DS    0D                                           @01281 @D7A\n.DSECT4  ANOP  ,                                            @01281 @D7A\n         SPACE 1                                            @01281 @D7P\n*                                                                     *\n*        DUMMY CLASS 0 USED IN ADDRESSING CLASS DATA                  *\n*                                  FIRST CLASS AREA - LENGTH          *\n*                                  OF EACH CLASS                      *\nCSAMXT0S DS    0C          START OF SET OF ENTRIES FOR DUMMY CLASS @LSA\n*\nCSAMXT0  DS    PL2         DUMMY MAXIMUM                       @BB9HCDI\nCSAMXT0C DS    PL3         DUMMY CURRENT ATTACHED                  @LSC\n*                                INCREMENTED AT ATTACH TIME\nCSAMXT0R DS    PL3         DUMMY MAXIMUM REACHED                   @LSC\nCSAMXT0M DS    PL3         DUMMY TIMES MAXIMUM REACHED             @LSC\nCSAMXT0A DS    PL2         DUMMY CURRENT ACTIVE                @BB9HCDI\n*                                INCREMENTED AT DISPATCH TIME\nCSAMXT01 DS    PL3         DUMMY NUMBER IN STATE 1 (IE NOT         @LSA\n*                          CONTRIBUTING TO THE MXT COUNT)\nCSAMXT02 DS    PL3         DUMMY NUMBER IN STATE 2 OR ACTIVE       @LSA\n*                          (IE CONTRIBUTING TO THE MXT COUNT)\n*\nCSAMXT0E DS    0C          END OF SET OF ENTRIES FOR DUMMY CLASS   @LSA\n*\n***********************************************************************\n         SPACE 1                                               @BBD10EX\nCSAMXT1  DS    PL2         CLASS 1 - MAXIMUM TASKS             @BB610EC\nCSAMXT1C DS    PL3         CLASS 1 - CURRENT TASKS                 @LSC\nCSAMXT1R DS    PL3         CLASS 1 - MAXIMUM TASKS REACHED         @LSC\nCSAMXT1M DS    PL3         CLASS 1 - NUMBER OF TIMES MAXIMUM       @LSC\n*                                    TASKS REACHED\nCSAMXT1A DS    PL2         CLASS 1 - ACTIVE TASK COUNT         @BB9HCDI\nCSAMXT11 DS    PL3                 - NUMBER IN STATE 1             @LSA\nCSAMXT12 DS    PL3                 - NUMBER IN STATE 2             @LSA\n*                                    OR ACTIVE\n         SPACE 1                                               @BBD10EX\nCSAMXT2  DS    PL2         CLASS 2 - MAXIMUM TASKS             @BB610EC\nCSAMXT2C DS    PL3         CLASS 2 - CURRENT TASKS                 @LSC\nCSAMXT2R DS    PL3         CLASS 2 - MAXIMUM TASKS REACHED         @LSC\nCSAMXT2M DS    PL3         CLASS 2 - NUMBER OF TIMES MAXIMUM       @LSC\n*                                    TASKS REACHED\nCSAMXT2A DS    PL2         CLASS 2 - ACTIVE TASK COUNT         @BB9HCDI\nCSAMXT21 DS    PL3                 - NUMBER IN STATE 1             @LSA\nCSAMXT22 DS    PL3                 - NUMBER IN STATE 2             @LSA\n*                                    OR ACTIVE\n         SPACE 1                                               @BBD10EX\nCSAMXT3  DS    PL2         CLASS 3 - MAXIMUM TASKS             @BB610EC\nCSAMXT3C DS    PL3         CLASS 3 - CURRENT TASKS                 @LSC\nCSAMXT3R DS    PL3         CLASS 3 - MAXIMUM TASKS REACHED         @LSC\nCSAMXT3M DS    PL3         CLASS 3 - NUMBER OF TIMES MAXIMUM       @LSC\n*                                    TASKS REACHED\nCSAMXT3A DS    PL2         CLASS 3 - ACTIVE TASK COUNT         @BB9HCDI\nCSAMXT31 DS    PL3                 - NUMBER IN STATE 1             @LSA\nCSAMXT32 DS    PL3                 - NUMBER IN STATE 2             @LSA\n*                                    OR ACTIVE\n         SPACE 1                                               @BBD10EX\nCSAMXT4  DS    PL2         CLASS 4 - MAXIMUM TASKS             @BB610EC\nCSAMXT4C DS    PL3         CLASS 4 - CURRENT TASKS                 @LSC\nCSAMXT4R DS    PL3         CLASS 4 - MAXIMUM TASKS REACHED         @LSC\nCSAMXT4M DS    PL3         CLASS 4 - NUMBER OF TIMES MAXIMUM       @LSC\n*                                    TASKS REACHED\nCSAMXT4A DS    PL2         CLASS 4 - ACTIVE TASK COUNT         @BB9HCDI\nCSAMXT41 DS    PL3                 - NUMBER IN STATE 1             @LSA\nCSAMXT42 DS    PL3                 - NUMBER IN STATE 2             @LSA\n*                                    OR ACTIVE\n         SPACE 1                                               @BBD10EX\nCSAMXT5  DS    PL2         CLASS 5 - MAXIMUM TASKS             @BB610EC\nCSAMXT5C DS    PL3         CLASS 5 - CURRENT TASKS                 @LSC\nCSAMXT5R DS    PL3         CLASS 5 - MAXIMUM TASKS REACHED         @LSC\nCSAMXT5M DS    PL3         CLASS 5 - NUMBER OF TIMES MAXIMUM       @LSC\n*                                    TASKS REACHED\nCSAMXT5A DS    PL2         CLASS 5 - ACTIVE TASK COUNT         @BB9HCDI\nCSAMXT51 DS    PL3                 - NUMBER IN STATE 1             @LSA\nCSAMXT52 DS    PL3                 - NUMBER IN STATE 2             @LSA\n*                                    OR ACTIVE\n         SPACE 1                                               @BBD10EX\nCSAMXT6  DS    PL2         CLASS 6 - MAXIMUM TASKS             @BB610EC\nCSAMXT6C DS    PL3         CLASS 6 - CURRENT TASKS                 @LSC\nCSAMXT6R DS    PL3         CLASS 6 - MAXIMUM TASKS REACHED         @LSC\nCSAMXT6M DS    PL3         CLASS 6 - NUMBER OF TIMES MAXIMUM       @LSC\n*                                    TASKS REACHED\nCSAMXT6A DS    PL2         CLASS 6 - ACTIVE TASK COUNT         @BB9HCDI\nCSAMXT61 DS    PL3                 - NUMBER IN STATE 1             @LSA\nCSAMXT62 DS    PL3                 - NUMBER IN STATE 2             @LSA\n*                                    OR ACTIVE\n         SPACE 1                                               @BBD10EX\nCSAMXT7  DS    PL2         CLASS 7 - MAXIMUM TASKS             @BB610EC\nCSAMXT7C DS    PL3         CLASS 7 - CURRENT TASKS                 @LSC\nCSAMXT7R DS    PL3         CLASS 7 - MAXIMUM TASKS REACHED         @LSC\nCSAMXT7M DS    PL3         CLASS 7 - NUMBER OF TIMES MAXIMUM       @LSC\n*                                    TASKS REACHED\nCSAMXT7A DS    PL2         CLASS 7 - ACTIVE TASK COUNT         @BB9HCDI\nCSAMXT71 DS    PL3                 - NUMBER IN STATE 1             @LSA\nCSAMXT72 DS    PL3                 - NUMBER IN STATE 2             @LSA\n*                                    OR ACTIVE\n         SPACE 1                                               @BBD10EX\nCSAMXT8  DS    PL2         CLASS 8 - MAXIMUM TASKS             @BB610EC\nCSAMXT8C DS    PL3         CLASS 8 - CURRENT TASKS                 @LSC\nCSAMXT8R DS    PL3         CLASS 8 - MAXIMUM TASKS REACHED         @LSC\nCSAMXT8M DS    PL3         CLASS 8 - NUMBER OF TIMES MAXIMUM       @LSC\n*                                    TASKS REACHED\nCSAMXT8A DS    PL2         CLASS 8 - ACTIVE TASK COUNT         @BB9HCDI\nCSAMXT81 DS    PL3                 - NUMBER IN STATE 1             @LSA\nCSAMXT82 DS    PL3                 - NUMBER IN STATE 2             @LSA\n*                                    OR ACTIVE\n         SPACE 1                                               @BBD10EX\nCSAMXT9  DS    PL2         CLASS 9 - MAXIMUM TASKS             @BB610EC\nCSAMXT9C DS    PL3         CLASS 9 - CURRENT TASKS                 @LSC\nCSAMXT9R DS    PL3         CLASS 9 - MAXIMUM TASKS REACHED         @LSC\nCSAMXT9M DS    PL3         CLASS 9 - NUMBER OF TIMES MAXIMUM       @LSC\n*                                    TASKS REACHED\nCSAMXT9A DS    PL2         CLASS 9 - ACTIVE TASK COUNT         @BB9HCDI\nCSAMXT91 DS    PL3                 - NUMBER IN STATE 1             @LSA\nCSAMXT92 DS    PL3                 - NUMBER IN STATE 2             @LSA\n*                                    OR ACTIVE\n         SPACE 1                                               @BBD10EX\nCSAMXTA  DS    PL2         CLASS 10 - MAXIMUM TASKS            @BB610EC\nCSAMXTAC DS    PL3         CLASS 10 - CURRENT TASKS                @LSC\nCSAMXTAR DS    PL3         CLASS 10 - MAXIMUM TASKS REACHED        @LSC\nCSAMXTAM DS    PL3         CLASS 10 - NUMBER OF TIMES MAXIMUM      @LSC\n*                                    TASKS REACHED\nCSAMXTAA DS    PL2         CLASS 10 - ACTIVE TASK COUNT        @BB9HCDI\nCSAMXTA1 DS    PL3                 - NUMBER IN STATE 1             @LSA\nCSAMXTA2 DS    PL3                 - NUMBER IN STATE 2             @LSA\n*                                    OR ACTIVE\n         SPACE 1                                               @BBD10EX\nCSAMXTND EQU   *           END OF MAXIMUM TASK AREA            @BB9HCDI\n         ORG   CSAMXTND                                        @BB9HCDI\nCSAMXTL  EQU   *-CSAMXT1   TOTAL LENGTH OF ALL CLASS ENTRIES       @LSC\nCSAMXTEL EQU   CSAMXT0E-CSAMXT0S   LENGTH OF SET OF ENTRIES        @LSA\n*                                  FOR ONE CLASS\nCSAMXTNE EQU   CSAMXTL/CSAMXTEL  NUMBER OF CLASSES                 @LSA\n***********************************************************************\n         SPACE 1                                               @BB6A00C\n         AIF   ('&TYPE' EQ 'CSECT').CSECT3                     @BBDA20X\n         DFHEJECT                                              @BBDCA0X\n         DFHSSAD TYPE=DSECT        GENERATE STATIC STORAGE ADDRESS     *\n                                     LIST                   @EA00X @L5A\n         DFHEJECT                                              @BBDJ30X\n***********************************************************************\n* *                       C O M M O N   W O R K   A R E A           * *\n***********************************************************************\nDFHCSADS DSECT             ...CONTINUE C S A DSECT             @BBDA20X\n         DS    (X'200'-*+DFHCSABA)C CHECK COMMITTED OFFSET  @GBS1B @LHA\nCSAWABA  DS    0D          WORK AREA BEGINNING ADDRESS         @BBDA20X\n***********************************************************************\n         DFHPRINT DSCT=SOMEEND     DSECT PRINTING CONTROL      @BC610VK\n&DFHCSAD SETB  1           INDICATE DSECT GENERATED         @01268 @D5A\n.DSECTBY ANOP      BYPASS IF DSECT ALREADY GENERATED        @01268 @D5A\n.CSECT3  ANOP                                                  @BBDA20X\n         MEND                                                  @BBDA20X\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFHEITUT": {"ttr": 6147, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*\n*    COPYRIGHT = 5665-403 (C) COPYRIGHT IBM CORP. 1975                *\n*                THIS MODULE IS \"RESTRICTED MATERIALS OF IBM\"         *\n*                LICENSED MATERIALS - PROPERTY OF IBM                 *\n*                REFER TO COPYRIGHT INSTRUCTIONS                      *\n*                FORM NUMBER G120-2083                                *\n*\n DFHTUTEN C=(02,02),K=ADDRESS\n DFHTUTEN C=(02,04),K=HANDLE-CONDITION\n DFHTUTEN C=(02,06),K=HANDLE-AID\n DFHTUTEN C=(02,08),K=ASSIGN\n DFHTUTEN C=(02,0A),K=IGNORE-CONDITION\n DFHTUTEN C=(02,0C),K=PUSH\n DFHTUTEN C=(02,0E),K=POP\n DFHTUTEN C=(02,10),K=ADDRESS-SET\n DFHTUTEN C=(04,02),K=RECEIVE-TC\n DFHTUTEN C=(04,04),K=SEND-TC\n DFHTUTEN C=(04,06),K=CONVERSE\n DFHTUTEN C=(04,08),K=ISSUE-EODS\n DFHTUTEN C=(04,0A),K=ISSUE-COPY\n DFHTUTEN C=(04,0C),K=WAIT-TERMINAL\n DFHTUTEN C=(04,0E),K=ISSUE-LOAD\n DFHTUTEN C=(04,10),K=WAIT-SIGNAL\n DFHTUTEN C=(04,12),K=ISSUE-RESET\n DFHTUTEN C=(04,14),K=ISSUE-DISCONNECT\n DFHTUTEN C=(04,16),K=ISSUE-ENDOUTPUT\n DFHTUTEN C=(04,18),K=ISSUE-ERASEAUP\n DFHTUTEN C=(04,1A),K=ISSUE-ENDFILE\n DFHTUTEN C=(04,1C),K=ISSUE-PRINT\n DFHTUTEN C=(04,1E),K=ISSUE-SIGNAL\n DFHTUTEN C=(04,20),K=ALLOCATE-TC\n DFHTUTEN C=(04,22),K=FREE-TC\n DFHTUTEN C=(04,24),K=POINT-TC\n DFHTUTEN C=(04,26),K=BUILD-ATTACH\n DFHTUTEN C=(04,28),K=EXTRACT-ATTACH\n DFHTUTEN C=(04,2A),K=EXTRACT-TCT\n DFHTUTEN C=(04,2C),K=WAIT-CONVID\n DFHTUTEN C=(04,2E),K=EXTRACT-PROCESS\n DFHTUTEN C=(04,30),K=ISSUE-ABEND\n DFHTUTEN C=(04,32),K=CONNECT-PROC\n DFHTUTEN C=(04,34),K=ISSUE-CONFIRM\n DFHTUTEN C=(04,36),K=ISSUE-ERROR\n DFHTUTEN C=(04,38),K=ISSUE-PREPARE\n DFHTUTEN C=(04,3A),K=ISSUE-PASS\n DFHTUTEN C=(04,3C),K=EXTRACT-LOGONMSG\n DFHTUTEN C=(06,02),K=READ\n DFHTUTEN C=(06,04),K=WRITE\n DFHTUTEN C=(06,06),K=REWRITE\n DFHTUTEN C=(06,08),K=DELETE\n DFHTUTEN C=(06,0A),K=UNLOCK\n DFHTUTEN C=(06,0C),K=STARTBR\n DFHTUTEN C=(06,0E),K=READNEXT\n DFHTUTEN C=(06,10),K=READPREV\n DFHTUTEN C=(06,12),K=ENDBR\n DFHTUTEN C=(06,14),K=RESETBR\n DFHTUTEN C=(08,02),K=WRITEQ-TD\n DFHTUTEN C=(08,04),K=READQ-TD\n DFHTUTEN C=(08,06),K=DELETEQ-TD\n DFHTUTEN C=(0A,02),K=WRITEQ-TS\n DFHTUTEN C=(0A,04),K=READQ-TS\n DFHTUTEN C=(0A,06),K=DELETEQ-TS\n DFHTUTEN C=(0C,02),K=GETMAIN\n DFHTUTEN C=(0C,04),K=FREEMAIN\n DFHTUTEN C=(0E,02),K=LINK\n DFHTUTEN C=(0E,04),K=XCTL\n DFHTUTEN C=(0E,06),K=LOAD\n DFHTUTEN C=(0E,08),K=RETURN\n DFHTUTEN C=(0E,0A),K=RELEASE\n DFHTUTEN C=(0E,0C),K=ABEND\n DFHTUTEN C=(0E,0E),K=HANDLE-ABEND\n DFHTUTEN C=(10,02),K=ASKTIME\n DFHTUTEN C=(10,04),K=DELAY\n DFHTUTEN C=(10,06),K=POST\n DFHTUTEN C=(10,08),K=START\n DFHTUTEN C=(10,0A),K=RETRIEVE\n DFHTUTEN C=(10,0C),K=CANCEL\n DFHTUTEN C=(12,02),K=WAIT-EVENT\n DFHTUTEN C=(12,04),K=ENQ\n DFHTUTEN C=(12,06),K=DEQ\n DFHTUTEN C=(12,08),K=SUSPEND\n DFHTUTEN C=(14,02),K=JOURNAL\n DFHTUTEN C=(14,04),K=WAIT-JOURNAL\n DFHTUTEN C=(16,02),K=SYNCPOINT\n DFHTUTEN C=(16,04),K=RESYNC\n DFHTUTEN C=(18,02),K=RECEIVE-MAP\n DFHTUTEN C=(18,04),K=SEND-MAP\n DFHTUTEN C=(18,06),K=SEND-TEXT\n DFHTUTEN C=(18,08),K=SEND-PAGE\n DFHTUTEN C=(18,0A),K=PURGE-MESSAGE\n DFHTUTEN C=(18,0C),K=ROUTE\n DFHTUTEN C=(18,0E),K=RECEIVE-PARTN\n DFHTUTEN C=(18,10),K=SEND-PARTNSET\n DFHTUTEN C=(18,12),K=SEND-CONTROL\n DFHTUTEN C=(1A,02),K=TRACE-ON/OFF\n DFHTUTEN C=(1A,04),K=ENTER\n DFHTUTEN C=(1C,02),K=DUMP\n DFHTUTEN C=(1E,02),K=ISSUE-ADD\n DFHTUTEN C=(1E,04),K=ISSUE-ERASE\n DFHTUTEN C=(1E,06),K=ISSUE-REPLACE\n DFHTUTEN C=(1E,08),K=ISSUE-ABORT\n DFHTUTEN C=(1E,0A),K=ISSUE-QUERY\n DFHTUTEN C=(1E,0C),K=ISSUE-END\n DFHTUTEN C=(1E,0E),K=ISSUE-RECEIVE\n DFHTUTEN C=(1E,10),K=ISSUE-NOTE\n DFHTUTEN C=(1E,12),K=ISSUE-WAIT\n DFHTUTEN C=(1E,14),K=ISSUE-SEND\n DFHTUTEN C=(20,02),K=DEEDIT\n DFHTUTEN C=(22,02),K=ENABLE\n DFHTUTEN C=(22,04),K=DISABLE\n DFHTUTEN C=(22,06),K=EXTRACT-EXIT\n DFHTUTEN C=(24,02),K=GDS-ALLOCATE\n DFHTUTEN C=(24,04),K=GDS-ASSIGN\n DFHTUTEN C=(24,06),K=GDS-EXTRACT-PROCESS\n DFHTUTEN C=(24,08),K=GDS-FREE\n DFHTUTEN C=(24,0A),K=GDS-ISSUE-ABEND\n DFHTUTEN C=(24,0C),K=GDS-CONNECT-PROC\n DFHTUTEN C=(24,0E),K=GDS-ISSUE-CONFIRM\n DFHTUTEN C=(24,10),K=GDS-ISSUE-ERROR\n DFHTUTEN C=(24,12),K=GDS-ISSUE-SIGNAL\n DFHTUTEN C=(24,14),K=GDS-RECEIVE\n DFHTUTEN C=(24,16),K=GDS-SEND\n DFHTUTEN C=(24,18),K=GDS-WAIT\n DFHTUTEN C=(24,1A),K=GDS-PREPARE\n DFHTUTEN C=(4A,02),K=ASKTIME-ABSTIME\n DFHTUTEN C=(4A,04),K=FORMATTIME\n DFHTUTEN C=(4C,02),K=INQUIRE-FILE\n DFHTUTEN C=(4C,04),K=SET-FILE\n DFHTUTEN C=(4E,02),K=INQUIRE-PROGRAM\n DFHTUTEN C=(4E,04),K=SET-PROGRAM\n DFHTUTEN C=(50,02),K=INQUIRE-TRANSACTION\n DFHTUTEN C=(50,04),K=SET-TRANSACTION\n DFHTUTEN C=(52,02),K=INQUIRE-TERMINAL\n DFHTUTEN C=(52,04),K=SET-TERMINAL\n DFHTUTEN C=(52,06),K=INQUIRE-NETNAME\n DFHTUTEN C=(54,02),K=INQUIRE-SYSTEM\n DFHTUTEN C=(54,04),K=SET-SYSTEM\n DFHTUTEN C=(56,02),K=SPOOLOPEN\n DFHTUTEN C=(56,04),K=SPOOLREAD\n DFHTUTEN C=(56,06),K=SPOOLWRITE\n DFHTUTEN C=(56,08),K=SPDUMMY08\n DFHTUTEN C=(56,0A),K=SPDUMMY0A\n DFHTUTEN C=(56,0C),K=SPDUMMY0C\n DFHTUTEN C=(56,0E),K=SPDUMMY0E\n DFHTUTEN C=(56,10),K=SPOOLCLOSE\n DFHTUTEN C=(56,12),K=SPDUMMY12\n DFHTUTEN C=(56,14),K=SPDUMMY14\n DFHTUTEN C=(56,16),K=SPDUMMY16\n DFHTUTEN C=(56,18),K=SPDUMMY18\n DFHTUTEN C=(56,1A),K=SPDUMMY1A\n DFHTUTEN C=(56,1C),K=SPDUMMY1C\n DFHTUTEN C=(56,1E),K=SPDUMMY1E\n DFHTUTEN C=(56,20),K=SPOOLOPEN-REPORT\n DFHTUTEN C=(56,22),K=SPOOLOPEN-MAPNAME\n DFHTUTEN C=(56,24),K=SPOOLOPEN-ESCAPE\n DFHTUTEN C=(56,26),K=SPOOLOPEN-RESUME\n DFHTUTEN C=(56,28),K=SPOOLWRITE-REPORT\n DFHTUTEN C=(56,2A),K=SPOOLWRITE-MAPNAME\n DFHTUTEN C=(56,2C),K=SPOOLCLOSE-REPORT\n DFHTUTEN C=(58,02),K=INQUIRE-CONNECTION\n DFHTUTEN C=(58,04),K=SET-CONNECTION\n DFHTUTEN C=(5A,02),K=INQUIRE-MODENAME\n DFHTUTEN C=(5A,04),K=SET-MODENAME\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFHTUREN": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x00\\x98$?\\x00\\x98$?\\x16\\x06\\x0f\\xf8\\x0f\\xf8\\x00\\x00\\xe2\\xd7\\xc1\\xd3\\xd2@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-08-31T00:00:00", "modifydate": "1998-08-31T16:06:35", "lines": 4088, "newlines": 4088, "modlines": 0, "user": "SPALK"}, "text": "***********************************************************************\n*                                                                     *\n*    COPYRIGHT = 5665-403 (C) COPYRIGHT IBM CORP. 1975                *\n*                THIS MODULE IS \"RESTRICTED MATERIALS OF IBM\"         *\n*                LICENSED MATERIALS - PROPERTY OF IBM                 *\n*                REFER TO COPYRIGHT INSTRUCTIONS                      *\n*                FORM NUMBER G120-2083                                *\n*                                                                     *\n*  CHANGE ACTIVITY :                                                  *\n*   $SEG(DFHTUREN),COMP(TRACE),PROD(CICS/VS)   :                      *\n*                                                                     *\n*    PN= REASON REL YYMMDD HDXIII : REMARKS                           *\n*   $D1= I01508 161 8211   HDPBGH : PURGE PERM'T MIRROR AT MXT LIMIT  *\n*   $D2= I01507 170 8410   HDIVJH : TCP TRACE ENTRIES (FE TYPE)       *\n*   $D3= I01870 170 8601   HD1MA  : BMS SECONDARY MODULE TRACE        *\n*    D4= RESERVED FOR DCR         :                                   *\n*    D5= RESERVED FOR DCR         :                                   *\n*    D6= RESERVED FOR DCR         :                                   *\n*    D7= RESERVED FOR DCR         :                                   *\n*   $H1= 5E2    160 8010   HDCPH  :  CICS/VS 1.6 PARTITION SUPPORT    *\n*   $H2= 5E5    160 8010   HDCPH  :  CICS/VS 1.6 MAGNETICS SUPPORT    *\n*   $H3= 963    160 8010   HDCPH  :  CICS/VS 1.6 DXAM SUPPORT         *\n*    H4= RESERVED FOR HARDWARE SUPPORT  :                             *\n*    H5= RESERVED FOR HARDWARE SUPPORT  :                             *\n*    H6= RESERVED FOR HARDWARE SUPPORT  :                             *\n*   $L1= CB0    160 811013 HDREH  : AB79,ABKS RMI TRACE ENTRIES       *\n*   $L2= U71    160 8103   HDTHSL : TABLE MANAGER TRACE ENTRY         *\n*                                 : PCP - PPT REPLACE TRACE ENTRY     *\n*   $L3= U71    160 8104   HDBKED : CHANGE TO CODES FOR KC ATTACH     *\n*                                 : CONDITIONAL XCTL                  *\n*                                 : PERMANENT STORAGE                 *\n*                                 : BROWSE PROFILES                   *\n*                                 : FC CTYPE=LOCATE,CTYPE=BROWSE      *\n*                                 : TD CTYPE=LOCATE,CTYPE=BROWSE      *\n*   $L4= U71    160 8104   HD0ADB : CHANGE TO CODES FOR AMP AND DMP   *\n*   $L5= G00    160 810519 HDXDRP : AAZT EXTENDED TRACE ENTRIES       *\n*                   820309 HD0LGP : FIX 2000 HRS PUMPKIN PROBLEM      *\n*   $L6= I00    160 8109   HDUGM  : NEW PROGRAMS FOR LU6.2            *\n*   $L7= 211    160 8108   HDQJDH : VOLUME MANAGER                    *\n*   $L8= I22    160 811103 HD6PRM : LUTYPE 6.2 FSMS                   *\n*   $L9= I22    160 820215 HD6PRM : LUTYPE 6.2 - DFHZERH ERROR TRACE  *\n*   $LA= I22    160 820312 HD6PRM : ZCP EXIT TRACE ANALYSIS           *\n*   $LB= J42    161 820908 HD0JADT: CHANGE TRANSFORMER TRACE ENTRY    *\n*   $LC= 131    161 8303   HDUGM  : TRANSIENT DATA MULTIPLE BUFFERS   *\n*   $LD= 121    161 8304   HDUGM  : TEMP STORAGE MULTIPLE BUFFERS     *\n*   $LE= 970    170 8308   HD0TMB : SPECIAL FEATURES DEVELOPMENT      *\n*   $LF= S00    170 830901 HD5LL  : XSP SECURITY TRACE ENTRY ANALYSIS *\n*   $LG= U8B    170 8311   HDFPSC : NEW RECORDS FOR ZLOC USING RDO    *\n*   $LH= U8C    170 8401   HD0HJC : ZCP TRACE ENTRIES FOR TC INSTALL  *\n*   $LI= 140    170 8402   HD0ADB : DFHSKP TRACE ENTRIES              *\n*   $LJ= U8B    170 8404   HD0ADB : DFHTMP TCTE/TCTN/TCTS TYPE CODES  *\n*   $LK= U80    170 8405   HDJIH  : DFHTOR TRACE ENTRIES              *\n*   $LL= U74    170 8405   HDBKED : DFHCCP, DFHRCP, WAITINIT ENTRIES  *\n*   $LM= A00    170 8405   HDIVJH : GENERAL CODE ENHANCEMENTS         *\n*   $LN= IA6    170 8408   HDFPSC : ZCP LU6.2 IMPROVEMENT             *\n*   $LO= 62B    170 8408   HDUGM  : FAST TD RESTART TRACE ENTRIES     *\n*   $LP= 118    170 8409   HDPBGH : KCP ATTACH TRACE ENTRIES          *\n*   $LQ= 119    170 8409   HDPBGH : KCP UPDATE TASKTIME TRACE ENTRY   *\n*   $LR= 6B0    170 8410   HDIVJH : TACP TRACE ENTRIES NOW STANDARD   *\n*   $LS= D33    170 8410   HD1MA  : TRACE ENTRIES FOR BMS QUERY       *\n*   $LT= U8D    170 8410   HD0NKBE: AUTOINSTALL TRACE ENTRIES         *\n*   $LU= FC2    170 8411   HDDRGC : FCP REVISED FILE STATES TRACE     *\n*   $LV= 6B0    170 8412   HDIVJH : FE TRACE ON BEHALF OF GLOBAL TRAP *\n*   $LW= X21    175 850913 HD0HJC : ZCP TRACE ENTRIES FOR XRF         *\n*   $LX= X13    175 851204 HD1NIH : XRF SUPPORT - DFHWMS              *\n*   $LY= 970    170 8509   HD1GRL : SPECIAL FEATURES DEVELOPMENT DOS  *\n*   $LZ= 971    170 8512   HDIVJH : TACP TRACE ENTRIES FOR SPOOLING   *\n*   $M1= 8D0    161 8205   HD8STC : NEW DL/I IWAIT TRACE              *\n*   $M2= X01    170 8603   HDUGM  : XRF SUPPORT - DFHXRP              *\n*   $M3= X01    170 8603   HDUGM  : XRF SUPPORT - DFHXRCP/DFHXRSP     *\n*   $M4= X22    170 8603   HD4GMW : XRF SUPPORT                       *\n*   $P1= M15544 160 820308 HD0LGP : UNPRINTABLE/UNDISPLAYABLE CHARS   *\n*   $P2= M17176 160 821201 HDPBGH : DFHKC FORCE PURGE TRACE ENTRY     *\n*   $P3= M17307 160 821220 HDPBGH : DFHKC ENTRIES                     *\n*   $P4= M27114 170 8408   HDIVJH : CORRECT LARGE TIME INTERVALS      *\n*   $P5= M29271 170 8503   HDQJDH : DECODE JCP EXIT TRACE RESPONSE    *\n*   $P6= M30576 170 8506   HD1YBC : CORRECT ICP '60' ENTRY            *\n*   $P7= M31030 170 850801 HDFPSC : CORRECT WAIT/NOWAIT FOR LOCATE    *\n*   $P8= M31445 170 8510   HDFPSC : IMPROVE TRACING FOR SYNCPOINT     *\n*                                   SEND RESP AND ZACT (SEE DCR 1893) *\n*   $P9= M32237 170 8602   HDFPSC : CORRECT ACTIVATE SCAN RECORDS     *\n*   $PA= M32632 170 8604   HDIVJH : TIDY UP PSP TRACE FOR DOS         *\n*   $PB= M32853 170 8607   HDIVJH : SPOOLOPEN/WRITE MAPNAME, NOT MAP  *\n*   $PC= M41352 212 900831 HD6KRAH: NEW TS TRACE                      *\n*    PD= RESERVED FOR PTM         :                                   *\n*   $01= A07929 160 820309 HD0LGP : TYPE EE FORMAT 6 RECORDS WRONG    *\n*   $02= A22830 170 8407   HDIVJH : DECODE ALP ALLOCATE TRACE ENTRY   *\n*   $03= A14048 170 8410   HDIVJH : FE TRACE ENTRIES (SEE DCR 1507)   *\n*   $04= A36667 170 8503   HDIVJH : DECODE ALP RELEASE_ABNORMAL       *\n*    05= RESERVED FOR APAR        :                                   *\n*    06= RESERVED FOR APAR        :                                   *\n*    07= RESERVED FOR APAR        :                                   *\n*    08= RESERVED FOR APAR        :                                   *\n*                                                                     *\n* @BA25007 : DUMMY CHANGE FOR PL25007                          @BA25007\n***********************************************************************\n*                                                                     *\n*  FUNCTION =                                                         *\n*        THIS ROUTINE DECODES ONE TRACE ENTRY                         *\n*        AND PLACES ITS OUTPUT IN PRINT LINE.                         *\n*                                                                     *\n*  INPUT =                                                            *\n*             REGISTER 15 = ENTRY POINT DFHTUREN                      *\n*             REGISTER 14 = RETURN ADDRESS                            *\n*             REGISTER  1 = 4 WORD PLIST                              *\n*             P 1ST WORD  =A(32 BYTE TRACE ENTRY TO DECODE)           *\n*             P 2ND WORD  =A(133 BYTE PRINT LINE FOR OUTPUT)          *\n*                           (ALREADY BLANKED WITH ASA CONTROL CHARS)  *\n*             P 3RD WORD  =LENGTH OF LINE                             *\n*                            LINE MUST BE AT LEAST 80 BYTES LONG      *\n*             P 4TH WORD  = STCK VALUE OF PREVIOUS TRACE ENTRY        *\n*                                                                     *\n*  OUTPUT =                                                           *\n*              PRINT LINE POINTED TO BY PLIST                         *\n*              DECODED TRACE ENTRY IN CHARACTER FORM                  *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nDFHTUREN CSECT                                                 @BD910JY\n         DFHEJECT ,                                            @BD910JY\n***********************************************************************\n* * *          R E G I S T E R   D E F I N I T I O N S            * * *\n***********************************************************************\n         SPACE 1\n         DFHREGS ,                 DEFINE GENERAL REGISTERS\n         SPACE 3\n***********************************************************************\n* * *          P R I V A T E   D A T A   A R E A S                * * *\n***********************************************************************\n*\n*\n*        FIRST LEVEL TABLE (MAJOR CODES)\n*\nTAB1DST  DSECT                                                 @BD910JY\nTAB1TABO DS    AL2                 OFFSET OF SECOND TABLE      @BD910JY\nTAB1TABR DS    AL2                 OFFSET OF RESPONSE TABLE    @BBAI20Y\n*AB1EX2A DS    AL2                 OFFSET OF EXIT IF ANY       @BD910JY\nTAB1LEN  DS    X                   CHARACTER NAME LENGTH       @BD910JY\nTAB1NAM  DS    C                   CHARACTER NAME(1-N)         @BD910JY\n*\n*        MINOR TABLE HEADER\n*\nTAB2IDST DSECT\nTAB2ITYP DS    AL1                 TYPE OF COMPARE\nTAB2IOFF DS    AL1                 OFFSET FIELD\nTAB2IEX1 DS    AL2                 EXIT OFFSET\nTAB2INX1 DS    AL2                 NEXT ADDRESS OFFSET\nTAB2IEND EQU   *-TAB2IDST          LENGTH\n*\n*        MINOR TABLE DSECT\n*\nTAB2DST  DSECT                                                 @BD910JY\nTAB2ID   DS    XL2                 COMPARE CHARACTER           @BD910JY\nTAB2TABO DS    AL2                 EXIT OFFSET                 @BD910JY\nTAB2LEN  DS    X                   LENGTH OF CHARACTER STRING  @BD910JY\nTAB2DATA DS    C                   ACTUAL DATA(1-N)            @BD910JY\n*\n*\n*        TRACE TABLE ENTRY FORMAT\n*\n         DFHTRACE  TYPE=DSECT\n*\n*        OUTPUT DSECT DESCRIPTION\n*        NOTE THAT START MAY NOT CORRESPOND TO BEGINNING\n*        OF PRINT LINE\nPRINTDST DSECT                                                 @BD910JY\nTURPRINT DC    0CL132' '           PRINT WORK AREA MAXIMUM  @EG00X @L5C\nTURPRITM DC    CL15' '             TIME-OF-DAY              @EG00X @L5A\n         DC    CL2' '                                       @EG00X @L5A\nTURPRIHX EQU   *                   HEX  TABLE POSITION      @EG00X @L5C\nTURPRIID DC    CL(2*L'ZTRID)' '    TRACE IDENTIFIER\n         DC    C' '\nTURPRIRE DC    CL(2*L'ZTRRETAD)' ' REGISTER 14\n         DC    C' '\nTURPRITR DC    CL(2*L'ZTRTR)' '    TYPE OF REQUEST\n         DC    C' '                                         @EG00X @L5A\nTURPRITI DC    CL(2*L'ZTRTCAID-1)' '  TASK IDENTIFIER       @EG00X @L5C\n         DC    C' '                                         @EG00X @L5A\nTURPRID1 DC    CL(2*L'ZTRDATA1)' ' DATA FIELD A (HEX)\n         DC    C' '\nTURPRID2 DC    CL(2*L'ZTRDATA2)' ' DATA FIELD B (HEX)\n         DC    C' '\nTURPRICH DC    CL8' '              FIELDS A & B (CHAR)      @EG00X @L5C\n         DC    C' '                                         @EG00X @L5A\nTURPRRSN DC    CL8' '              RESOURCE NAME            @EG00X @L5A\n         DC    CL2' '                                       @EG00X @L5A\nTURPRILT EQU   *                   MAJOR ID POSITION        @EG00X @L5C\n*\n*\n         DFHEJECT                                              @BD910JY\n***********************************************************************\n* * *    TRACE ENTRY PROCESSING                                   * * *\n***********************************************************************\nDFHTUREN CSECT                                                 @BD910JY\n         USING *,R15                                           @BD910JY\nDFHTURST DS    0H                  CONVERT TYPE ENTRY CODES    @BD910JY\n         STM   R14,R11,TUESAVRG+12 SAVE REGISTERS              @BD910JY\n         DROP  R15                                             @BD910JY\n         BALR  R11,0                                           @BD910JY\n         USING *,R11                                           @BD910JY\n         LM    R2,R3,00(R1)        GET POINTER  TO TRACE ENTRY @BD910JY\n         LR    R0,R3               GET START OF LINE           @BD910JY\n         A     R0,08(R1)           GET POINTER TO END LINE     @BD910JY\n         SH    R0,=Y(TURHED2L)     LEAVE SPACE FOR INTERVAL @EG00X @L5A\n*                                  R2 = ADDRESS OF PRINT AREA 133 IN LN\n         USING PRINTDST,R3         ADDRESSABILITY FOR PRINT AR @BD910JY\n         SPACE 2                                            @EG00X @L5A\n         LTR   R2,R2               IS THERE A TRACE ENTRY?  @EG00X @L5A\n         BNZ   TURSTART            ..YES, DECODE IT         @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n***********************************************************************\n* *                                                                 * *\n* *            FORMAT A HEADING FOR THE TRACE TABLE                 * *\n* *                                                                 * *\n***********************************************************************\n         SPACE 1                                            @EG00X @L5A\n         MVC   0(TURHED1L,R3),TURHED1  COPY PART ONE        @EG00X @L5A\n         LR    R3,R0                   ADDRESS INTERVAL     @EG00X @L5A\n         MVC   0(TURHED2L,R3),TURHED2  COPY PART TWO        @EG00X @L5A\n         LM    R14,R11,TUESAVRG+12     RETRIEVE REGISTERS   @EG00X @L5A\n         BR    R14                       AND RETURN         @EG00X @L5A\n         SPACE 2                                            @EG00X @L5A\nTURHED1  DC    CL80' '                                      @EG00X @L5A\n         ORG   TURPRITM-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C'   TIME OF DAY   '                         @EG00X @L5A\n         ORG   TURPRIID-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C'ID'                                        @EG00X @L5A\n         ORG   TURPRIRE-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C' REG 14 '                                  @EG00X @L5A\n         ORG   TURPRITR-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C'REQD'                                      @EG00X @L5A\n         ORG   TURPRITI-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C'TASK '                                     @EG00X @L5A\n         ORG   TURPRID1-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C' FIELD A'                                  @EG00X @L5A\n         ORG   TURPRID2-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C' FIELD B'                                  @EG00X @L5A\n         ORG   TURPRICH-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C' CHARS  '                                  @EG00X @L5A\n         ORG   TURPRRSN-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C'RESOURCE'                                  @EG00X @L5A\n         ORG   TURPRILT-TURPRINT+TURHED1                    @EG00X @L5A\n         DC    C'TRACE TYPE'                                @EG00X @L5A\nTURHED1L EQU   *-TURHED1           LENGTH OF FIRST HEADING  @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\nTURHED2  EQU   *                                            @EG00X @L5A\n         DC    C' INTERVAL '                                @EG00X @L5A\nTURHED2L EQU   *-TURHED2           LENGTH OF SECOND HEADING @EG00X @L5A\n         SPACE 5                                            @EG00X @L5A\nTURSTART DS    0H                                           @EG00X @L5A\n         USING ZTRENTRY,R2         ADDRESSABILITY FOR TR ENTRY @BD910JY\n         SPACE 2                                            @EG00X @L5A\n***********************************************************************\n* *                                                                 * *\n* *            FORMAT HEXADECIMAL OUTPUT FIELDS                     * *\n* *                                                                 * *\n***********************************************************************\n         SPACE 2                                            @EG00X @L5A\n*   FORMAT THE TRACE ID.                                              *\n         UNPK  TURPRIID(L'TURPRIID+1),ZTRID(L'ZTRID+1)      @EG00X @L5A\n         TR    TURPRIID(L'TURPRIID),TURTRT-C'0'             @EG00X @L5A\n         MVI   TURPRIID+L'TURPRIID,C' '                     @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n*   FORMAT THE TYPE OF REQUEST BYTES.                                 *\n         UNPK  TURPRITR(L'TURPRITR+1),ZTRTR(L'ZTRTR+1)      @EG00X @L5A\n         TR    TURPRITR(L'TURPRITR),TURTRT-C'0'             @EG00X @L5A\n         MVI   TURPRITR+L'TURPRITR,C' '                     @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n*   FORMAT THE RETURN ADDRESS.                                        *\n         UNPK  TURPRIRE(L'TURPRIRE+1),ZTRRETAD(L'ZTRRETAD+1)           *\n                                                            @EG00X @L5A\n         TR    TURPRIRE(L'TURPRIRE),TURTRT-C'0'             @EG00X @L5A\n         MVI   TURPRIRE+L'TURPRIRE,C' '                     @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n*   FORMAT THE FIRST DATA FIELD.                                      *\n         UNPK  TURPRID1(L'TURPRID1+1),ZTRDATA1(L'ZTRDATA1+1)           *\n                                                            @EG00X @L5A\n         TR    TURPRID1(L'TURPRID1),TURTRT-C'0'             @EG00X @L5A\n         MVI   TURPRID1+L'TURPRID1,C' '                     @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n*   FORMAT THE SECOND DATA FIELD.                                     *\n         UNPK  TURPRID2(L'TURPRID2+1),ZTRDATA2(L'ZTRDATA2+1)           *\n                                                            @EG00X @L5A\n         TR    TURPRID2(L'TURPRID2),TURTRT-C'0'             @EG00X @L5A\n         MVI   TURPRID2+L'TURPRID2,C' '                     @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n*   FORMAT THE TASK IDENTIFIER.                                       *\n         UNPK  TURPRITI(L'TURPRITI),ZTRTCAID(L'ZTRTCAID)    @EG00X @L5A\n         OI    TURPRITI+L'TURPRITI-1,C'0'                   @EG00X @L5A\n         SPACE 2                                            @EG00X @L5A\n***********************************************************************\n* *                                                                 * *\n* *            FORMAT CHARACTER OUTPUT FIELDS                       * *\n* *                                                                 * *\n***********************************************************************\n         SPACE 2\n*   CONVERT THE TASK IDENTIFIER TO CHARACTER IF IT'S ONE OF THE       *\n*   SPECIAL ONES.                                                     *\n         TM    ZTRTCAID,X'C0'        TEST FOR ALPHA\n         BNO   TUPNOSYN\n         MVC   TURPRITI(3),ZTRTCAID   COPY TASK IDENTIFIER  @EG00X @L5C\n         MVC   TURPRITI+3(2),=CL2'  ' SET REST TO BLANKS    @EG00X @L5C\nTUPNOSYN DS    0H\n         SPACE 1                                            @EG00X @L5A\n*   FORMAT THE RESOURCE NAME.                                         *\n         MVC   TURPRRSN,ZTRRESCE   COPY RESOURCE NAME       @EG00X @L5A\n         TR    TURPRRSN,TUETRANS   TRANSLATE TO PRINTABLE   @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n*   FORMAT THE FIRST AND SECOND DATA FIELDS IF THEY ARE PRINTABLE.    *\n         MVC   TURPRICH,ZTRDATA1   MOVE TRACE ENTRY         @EG00X @L5C\n         TR    TURPRICH,TUETRANS   TRANSLATE TO PRINTABLE      @BD910JY\n         SPACE 2                                            @EG00X @L5A\n***********************************************************************\n* *                                                                 * *\n* *            PREPARE TO INTERPRET THE TRACE TYPE AND TYPE         * *\n* *            OF REQUEST.                                          * *\n* *                                                                 * *\n***********************************************************************\n         SPACE 2                                            @EG00X @L5A\n         LA    R7,TURPRILT         SET IN PRINT POSITION       @BBAI20Y\n*                                                                     *\n*        NOW DECODE SUBTYPE OF TRACE ENTRY ..                         *\n*        AND PICK APPROPRIATE TABLE                                   *\n         IC    R4,ZTRTR+1          GET REQUEST TYPE         @EG00X @L5C\n         N     R4,=F'15'           ENSURE 0 -15                @BBAI20Y\n         STH   R4,TURNTYSV         SAVE REQUEST TYPE           @BBAI20Y\n         STC   R4,TURNREQD         SET IN REQUEST FIELD        @BBAI20Y\n*                                                              @BBDIA0Y\n         AR    R4,R4               *2                          @BBDIA0Y\n         LH    R4,TUTENTAB(R4)     GET INDEX FOR MAJOR TYPES   @BBDIA0Y\n         A     R4,=A(TUTI1SRT)     ADD BASE ADDRESS            @BBDIA0Y\n*                                                              @BBDIA0Y\n***********************************************************************\n*    CORRECT TABLE SELECTED                                    @BBDIA0Y\n*        DETERMINE TYPE OF TRACE ENTRY                         @BBDIA0Y\n*   R4 POINTS TO TABLE WITH                                    @BBDIA0Y\n*       OFFSET 00 = MINIMUM NUMBER                             @BBDIA0Y\n*       OFFSET 02 = START OF TABLE FROM MINIMUM ENTRY          @BBDIA0Y\n***********************************************************************\n         SPACE 2                                               @BD910JY\n         SR    R15,R15             CLEAR WORK REGISTER         @BD910JY\n         IC    R15,ZTRID           GET ID                   @EG00X @L5C\n         SH    R15,00(R4)          SUBTRACT STARTING ID        @BD910JY\n         BP    TUENOTUS            ..IF ABOVE BRANCH ROUND     @BD910JY\n*\n         SR    R15,R15             SET ZERO FOR USER ENTRY     @BD910JY\nTUENOTUS DS    0H                                              @BD910JY\n         AR    R15,R15             MULTIPLY BY TWO             @BD910JY\n         LH    R9,02(R4,R15)       GET ENTRY OFFSET            @BD910JY\n         A     R9,TUTB1STA         GET TABLE ENTRY ADDRESS     @BD910JY\n*\n         USING TAB1DST,R9                                      @BD910JY\n         LA    R14,TAB1LEN         SET AT LENGTH\n         SR    R4,R4                                           @BD910JY\n         IC    R4,TAB1LEN          GET LENGTH                  @BD910JY\n         BAL   R6,TURNVMDM         OUTPUT CONSTANT             @BD910JY\n*                                                                     *\n*     R9 = CURRENT ADDRESS IN THE MAJOR TABLE                         *\n*                                                                     *\n         SR    R4,R4               CLEAR R4                    @BBAI20Y\n         LH    R5,TAB1TABO         PICK UP MINOR DISPLACEMENT  @BBAI20Y\n*                                                              @BBAI20Y\n         CLI   TURNTYSV+1,05       RETURN ID ?                 @BM13334\n         BNE   TURREP2                                         @BM13334\n*    OUTPUT RETN CHARACTER STRING SINCE LIFO RETURN TYPE              *\n         LA    R14,RETNCHRL+2      SET AT LENGTH               @BM13334\n         SR    R4,R4                                           @BM13334\n         IC    R4,00(R14)          GET LENGTH                  @BM13334\n         BAL   R6,TURNVMDM         OUTPUT CONSTANT             @BM13334\n*                                                                     *\n         SR    R4,R4               CLEAR WORK REG              @BM13334\n         LH    R5,TAB1TABR         GET A(RETURN TABLE) OFFSET  @BM13334\n*                                                              @BBAI20Y\n*     R5 = CURRENT ADDRESS IN THE MINOR TABLE\n*                                                              @BBAI20Y\nTURREP2  DS    0H\n         A     R5,TUTB2STA         POINT TO ACTUAL TABLE ENTRY\n         USING TAB2IDST,R5\n         MVC   TURN2ISV,TAB2IDST   COPY TABLE ENTRY\n*                                                              @BBAI20Y\n         SR    R15,R15             CLEAR R15\n         IC    R15,TAB2IOFF        GET OFFSET\n         LA    R15,ZTRENTRY(R15)   GET ADDRESS IN TRACE TABLE\n         MVC   TURNREQD(4),00(R15) MOVE MINOR CODE             @BM10519\n*                                                              @BBAI20Y\n         LH    R6,TAB2IEX1         GET EXIT ADDRESS\n         BAL   R6,TUTE1SRT(R6)     GO TO EXIT\n*                                                              @BBAI20Y\n         SR    R15,R15\n         IC    R15,TAB2ITYP        GET COMPARE TYPE\n         LH    R15,TURBRT(R15)     GET POINTER TO SUBROUTINE\n         LA    R5,TAB2IEND(R5)\n         DROP  R5\n         BAL   R6,TURBRT(R15)      GO TO COMPARE SUBROUTINE\n*                                                                     *\n         LH    R5,TURN2ISV+(TAB2INX1-TAB2IDST) GET NEXT ADDR\n         LTR   R5,R5               ANY MORE DECODING\n         BNZ   TURREP2             YES GO AGAIN\n*\nTURETURN DS    0H                                              @BD910JY\n***********************************************************************\n* *      FORMAT THE TIME OF DAY INTO THE OUTPUT.                    * *\n***********************************************************************\n         SPACE 1                                            @EG00X @L5A\n         L     R1,TUESAVRG+24      RETRIEVE PARM ADDRESS    @EG00X @L5A\n         L     R5,ZTRTOD           GET ENTRY TIME           @EG00X @L5A\n*   THE CONSTANT APPEARING IN THE FOLLOWING INSTRUCTIONS IS EQUAL     *\n*   TO                                                                *\n*               24*60*60*(1000000/32) - 2**32 .                       *\n*                                                                     *\n*   IT IS USED IN THIS FORM TO GENERATE A FULLWORD CONTAINING AN      *\n*   UNSIGNED 32-BIT INTEGER REPRESENTING THE NUMBER OF                *\n*   32-MICROSECOND INTERVALS IN 24 HOURS.                             *\n         CL    R5,=F'-1594967296'  PAST NEXT MIDNIGHT?      @EG00X @L5A\n         BL    TURTMOK             ..NO, SKIP               @EG00X @L5A\n         SL    R5,=F'-1594967296'  ADJUST TIME-OF-DAY       @EG00X @L5A\nTURTMOK  EQU   *                                            @EG00X @L5A\n         XR    R4,R4               CONVERT TO MICROSECS    @EG000L @L5A\n         SLDL  R4,5                SHIFT 5 = MULT BY 32    @EG000L @L5A\n         D     R4,=F'1000000'      CONVERT TO SECONDS       @EG00X @L5A\n*   REGISTER 5 NOW CONTAINS THE TIME OF THIS TRACE ENTRY IN           *\n*   SECONDS SINCE MIDNIGHT AND REGISTER 4 CONTAINS THE REMAINDER      *\n*   IN MICROSECONDS.                                                  *\n         CVD   R4,TURNDWRD         CONVERT TO PRINTABLE     @EG00X @L5A\n         UNPK  TURPRITM+9(6),TURNDWRD CHARACTERS            @EG00X @L5A\n         OI    TURPRITM+14,C'0'    MAKE LAST CHAR PRINTABLE @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\n         XR    R4,R4               CLEAR FOR DIVIDE         @EG00X @L5A\n         D     R4,=F'60'           SEPARATE THE SECONDS     @EG00X @L5A\n*   REGISTER 5 NOW CONTAINS THE TIME OF THIS TRACE ENTRY IN MINUTES   *\n*   FROM MIDNIGHT AND REGISTER 4 CONTAINS THE REMAINDER IN SECONDS.   *\n         MH    R5,=H'100'          COLLECT THE MINUTES AND  @EG00X @L5A\n         AR    R5,R4                 SECONDS TOGETHER       @EG00X @L5A\n         XR    R4,R4               CLEAR FOR DIVIDE         @EG00X @L5A\n         D     R4,=F'6000'         SEPARATE THE HOURS       @EG00X @L5A\n*   REGISTER 5 NOW CONTAINS THE TIME OF THIS TRACE ENTRY IN HOURS     *\n*   FROM MIDNIGHT AND REGISTER 4 CONTAINS THE REMAINDER IN MINUTES    *\n*   AND SECONDS.                                                      *\n         MH    R5,=H'10000'        COLLECT THE HOURS AND    @EG00X @L5A\n         AR    R5,R4                 MINUTES TOGETHER       @EG00X @L5A\n         CVD   R5,TURNDWRD         CONVERT TO DECIMAL       @EG00X @L5A\n         UNPK  TURPRITM+2(6),TURNDWRD    UNPACK SIX DIGITS  @EG00X @L5A\n         MVC   TURPRITM(2),TURPRITM+2    MOVE THE HOURS     @EG00X @L5A\n         MVI   TURPRITM+2,C':'           ADD SEPARATOR      @EG00X @L5A\n         MVC   TURPRITM+3(2),TURPRITM+4  MOVE THE MINUTES   @EG00X @L5A\n         MVI   TURPRITM+5,C':'           ADD SEPARATOR      @EG00X @L5A\n         OI    TURPRITM+7,C'0'     MAKE LAST CHAR PRINTABLE @EG00X @L5A\n         MVI   TURPRITM+8,C'.'     INSERT DECIMAL POINT     @EG00X @L5A\n         SPACE 2                                            @EG00X @L5A\n***********************************************************************\n* *      FORMAT THE INTERVAL BETWEEN THIS ENTRY AND THE             * *\n* *      PREVIOUS ONE.                                              * *\n***********************************************************************\n         SPACE 1                                            @EG00X @L5A\n         CLC   12(4,R1),=F'-1'     ANY PREVIOUS ENTRY?             @P4M\n         BE    TURCSNPE            ..NO, SKIP INTERVAL CALC        @P4M\n         SPACE 1                                                   @P4A\n*   CALCULATE THE INTERVAL IN UNITS OF 32 MICROSECONDS.               *\n         L     R5,ZTRTOD           GET ENTRY TIME AGAIN     @EG00X @L5A\n         SL    R5,12(,R1)          SUBTRACT PREVIOUS TIME   @EG00X @L5A\n         CLC   ZTRTOD,12(R1)       CURRENT TIME < PREVIOUS TIME??  @P4A\n         BNL   TURCSNOK            ..NO, THAT'S FINE               @P4A\n         AL    R5,=F'-1594967296'  ADJUST INTERVAL BY 24 HOURS     @P4A\nTURCSNOK DS    0H                                                  @P4A\n         SPACE 1                                                   @P4A\n*   DETERMINE IF THE INTERVAL IS SIGNIFICANT.                         *\n         CL    R5,SIGTIME1         IS INTERVAL SIGNIFICANT?        @P4C\n         BL    TURCSNPX            .. NO THEN BRANCH ROUND  @EG00X @L5A\n         SPACE 1                                               @BM09140\n         LR    R7,R0               ADDRESS END OF LINE             @P4M\n         CL    R5,SIGTIME2         IS INTERVAL VERY SIGNIFICANT?   @P4C\n         BNH   TURCSNPT            ..NO, BRANCH ROUND              @P4C\n         SPACE 1                                               @BM09140\n         MVI   0(R7),C'*'          SET A FLAG               @EG00X @L5A\n         CL    R5,SIGTIME3         TOO HIGH TO PRINT?              @P4C\n         BL    TURCSNPT            ..NO, PRINT IT           @EG00X @L5A\n         MVC   1(9,R7),=C'*********'                        @EG00X @L5A\n         B     TURCSNTH                                     @EG00X @L5A\n         SPACE 1                                            @EG00X @L5A\nTURCSNPT DS    0H                                           @EG00X @L5A\n*   PRINT THE INTERVAL IN MICROSECONDS.                               *\n         MH    R5,=H'32'           CONVERT TO MICROSECONDS         @P4M\n         CVD   R5,TURNDWRD         CONVERT TO PACKED,       @EG00X @L5A\n         UNPK  2(8,R7),TURNDWRD      UNPACK AND MAKE        @EG00X @L5A\n         OI    9(R7),C'0'              LAST CHAR PRINTABLE  @EG00X @L5A\n         MVC   1(2,R7),2(R7)       SHIFT SECONDS            @EG00X @L5A\n         MVI   3(R7),C'.'          INSERT DECIMAL POINT     @EG00X @L5A\n         SPACE 1                                               @BM09140\nTURCSNTH DS    0H  INTERVAL TOO HIGH TO BE PRINTED          @EG00X @L5A\nTURCSNPX DS    0H                                           @EG00X @L5A\nTURCSNPE DS    0H                                           @EG00X @L5A\n         MVC   12(4,R1),ZTRTOD     SAVE CURRENT TIME        @EG00X @L5A\n         SPACE 2                                            @EG00X @L5A\n***********************************************************************\n* * *          RETURN TO THE CALLER                               * * *\n***********************************************************************\n         SPACE 1                                            @EG00X @L5A\n         LM    R14,R11,TUESAVRG+12 RESTORE REGS                @BD910JY\n         BR    R14                 RETURN                      @BD910JY\n*\nTURN2ISV DS    CL8                 SAVE AREA FOR MINOR HEADING\nTURBRT   DS    0H\n         DC    AL2(TURNVTM-TURBRT)  00\n         DC    AL2(TURNVCLI-TURBRT) 02\n         DC    AL2(TURNVCLC-TURBRT) 04\n         DC    AL2(TURNV2BN-TURBRT) 06                         @BM10519\n         DC    AL2(TURNV1BN-TURBRT) 08                         @BM10519\n         DC    AL2(TURNVRBN-TURBRT) 10                         @BM10519\n         DC    AL2(TURNVLBN-TURBRT) 12                         @BM10519\n         DC    AL2(TURNV3DE-TURBRT) 14                         @BM10519\n         DC    AL2(TURNV2DE-TURBRT) 16                         @BM10519\n         DC    AL2(TURNV1DE-TURBRT) 18                         @BM10519\n         DC    AL2(TURNVCLC-TURBRT) 20                         @BM10519\n         DC    AL2(TURNVCLC-TURBRT) 22                         @BM10519\n*\n         DFHEJECT ,                                            @BD910JY\n***********************************************************************\n*        SUBROUTINE TO FIND MINOR FLAGS\n*        USING COMPARE TYPE CLC\n*        INPUT\n*             R6 = RETURN ADDRESS\n*             R7 = PRINT POSITION\n*             R5 = ADDRESS OF TABLE ENTRY\n*             R0 = END OF PRINT POSITION\n*        WORK\n*             R4 = WORK REGISTER\n*        OUTPUT\n*             R6 = RETURN ADDRESS UNCHANGED\n*             R7 = PRINT POSITION (UPDATED IF MATCH FOUND)\n*             R5 = ADDRESS OF NEXT TABLE ENTRY\n*             R0 = END OF PRINT POSITION UNCHANGED\n***********************************************************************\nTURNVCLC DS    0H                  SEARCH MINOR TABLE          @BD910JY\n         USING TAB2DST,R5\n         CLC   TAB2ID(2),TURNVEND  END OF MINOR TABLE          @BD910JY\n         BER   R6                  ..YES, RETURN\n*\n         IC    R4,TAB2LEN          GET CONSTANTS LENGTH        @BD910JY\n         CLI   TAB2LEN,TUMAXLEN    ENSURE LOOKING AT A REASONABLE      *\n                                    LENGTH OF DUMMY.           @BD910JY\n         BH    TURNVMER            GET OUT NOW IF ERROR        @BD910JY\n*\n         CLC   TAB2ID(2),TURNREQD\n         BNE   TURNCLC1            ..NO, DON'T PRINT\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS\n         LA    R14,TAB2LEN         SET AT LENGTH BYTE\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS\n         LH    R14,TAB2TABO        GET EXIT ADDR\n         LTR   R14,R14             IS THERE ANY..\n         BZR   R6                  NO THEN LEAVE DEFAULT\n*\n         STH   R14,TURN2ISV+(TAB2INX1-TAB2IDST) GET NEXT ADDR\n         BR    R6\n*\nTURNCLC1 DS    0H\n         LA    R5,TAB2DATA+1(R4)   POINT TO NEXT ENTRY         @BD910JY\n         B     TURNVCLC            GO LOOK AT IT               @BD910JY\n          DFHEJECT                                             @BM10519\n***********************************************************************\n*        SUBROUTINE TO FIND MINOR FLAGS\n*        USING COMPARE TYPE CLI\n*        INPUT\n*             R6 = RETURN ADDRESS\n*             R7 = PRINT POSITION\n*             R5 = ADDRESS OF TABLE ENTRY\n*             R0 = END OF PRINT POSITION\n*        WORK\n*             R4 = WORK REGISTER\n*        OUTPUT\n*             R6 = RETURN ADDRESS UNCHANGED\n*             R7 = PRINT POSITION (UPDATED IF MATCH FOUND)\n*             R5 = ADDRESS OF NEXT TABLE ENTRY\n*             R0 = END OF PRINT POSITION UNCHANGED\n***********************************************************************\nTURNVCLI DS    0H                  SEARCH MINOR TABLE          @BD910JY\n         MVI   TURNREQD+1,00       ENSURE ZERO\n         USING TAB2DST,R5\n         CLC   TAB2ID(2),TURNVEND  END OF MINOR TABLE       @E211Q @L7C\n         BER   R6                  ..YES, RETURN\n*\n         IC    R4,TAB2LEN          GET CONSTANTS LENGTH     @E211Q @L7C\n         CLI   TAB2LEN,TUMAXLEN    ENSURE LOOKING AT A REASONABLE LEN  *\n                                   DUMMY\n         BH    TURNVMER            GET OUT NOW IF ERROR\n*\n         IC    R15,TAB2ID          GET COMPARE CHARACTER\n         EX    R15,CLIINSTR        MINOR CODE MATCH\n         BNE   TURNCLI1            ..NO, DON'T PRINT\n*\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS\n         LA    R14,TAB2LEN         SET AT LENGTH BYTE\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE\n*\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS\n         LH    R14,TAB2TABO        GET EXIT ADDR\n         LTR   R14,R14             IS THERE ANY..\n         BZR   R6                  NO THEN LEAVE DEFAULT\n*\n         STH   R14,TURN2ISV+(TAB2INX1-TAB2IDST) SET NEXT ADDR\n         BR    R6\n*\nTURNCLI1 DS    0H\n         LA    R5,TAB2DATA+1(R4)   POINT TO NEXT ENTRY         @BD910JY\n         B     TURNVCLI            GO LOOK AT IT               @BD910JY\n*\nCLIINSTR CLI   TURNREQD,00         MINOR CODE MATCH\n         DFHEJECT                                              @BM10519\n***********************************************************************\n*        SUBROUTINE TO FIND MINOR FLAGS\n*        USING COMPARE TYPE TM\n*        INPUT\n*             R6 = RETURN ADDRESS\n*             R7 = PRINT POSITION\n*             R5 = ADDRESS OF TABLE ENTRY\n*             R0 = END OF PRINT POSITION\n*        WORK\n*             R4 = WORK REGISTER\n*        OUTPUT\n*             R6 = RETURN ADDRESS UNCHANGED\n*             R7 = PRINT POSITION (UPDATED IF MATCH FOUND)\n*             R5 = ADDRESS OF NEXT TABLE ENTRY\n*             R0 = END OF PRINT POSITION UNCHANGED\n***********************************************************************\nTURNVTM  DS    0H                  SEARCH MINOR TABLE\n         USING TAB2DST,R5\n         CLC   TAB2ID(2),TURNVEND  END OF MINOR TABLE\n         BER   R6                  ..YES, RETURN\n*\n         IC    R4,TAB2LEN          GET CONSTANTS LENGTH\n         CLI   TAB2LEN,TUMAXLEN    ENSURE LOOKING AT A REASONABLE LEN  *\n                                   DUMMY\n         BH    TURNVMER            GET OUT NOW IF ERROR\n*\n         IC    R15,TAB2ID          GET COMPARE CHARACTER\n         EX    R15,TMINSTR         MINOR CODE MATCH\n         BNO   TURNTM1             ..NO, DON'T PRINT\n*\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS\n         LA    R14,TAB2LEN         SET AT LENGTH BYTE\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS\n*\nTURNTM1  DS    0H\n         LA    R5,TAB2DATA+1(R4)   POINT TO NEXT ENTRY\n         B     TURNVTM             GO LOOK AT IT\n*\nTMINSTR  TM    TURNREQD,00         MINOR CODE MATCH\n*\nTURNVMER DS    0H\n         LA    R5,TUTERR           SET ERROR ENTRY\n         IC    R4,TAB2LEN          GET CONSTANTS LENGTH\n         LA    R14,TAB2LEN         SET AT LENGTH BYTE\n         B     TURNVMDM            OUTPUT IT\n*                                                              @BM10519\nTURN2ISR DS    F                                               @BM10519\n          DFHEJECT                                             @BM10519\n***********************************************************************\n*        SUBROUTINE TO CONVERT A FIELD                         @BM10519\n*        USING INPUT FIELD OF 1 OR 2 BYTES                     @BM10519\n*        INPUT                                                 @BM10519\n*             R6 = RETURN ADDRESS                              @BM10519\n*             R7 = PRINT POSITION                              @BM10519\n*             R5 = ADDRESS OF TABLE ENTRY                      @BM10519\n*             R0 = END OF PRINT POSITION                       @BM10519\n*        WORK                                                  @BM10519\n*             R4 = WORK REGISTER                               @BM10519\n*        OUTPUT                                                @BM10519\n*             R6 = RETURN ADDRESS UNCHANGED                    @BM10519\n*             R7 = PRINT POSITION (UPDATED IF MATCH FOUND)     @BM10519\n*             R5 = ADDRESS OF NEXT TABLE ENTRY                 @BM10519\n*             R0 = END OF PRINT POSITION UNCHANGED             @BM10519\n***********************************************************************\nTURNV2BN DS    0H                  HALF WORD BINARY            @BM10519\n         LH    R15,TURNREQD                                    @BM10519\n         CVD   R15,TURNDWRD        CONVERT TO DECIMAL          @BM10519\n         UNPK  TURNOUTD(5),TURNDWRD+5(3) CONVERT TO CHAR       @BM10519\n         OI    TURNOUTD+4,C'0'     ENSURE PRINTABLE            @BM10519\n         MVI   TURNOUTL,04         SET UP LENGTH               @BM10519\n         IC    R4,TURNOUTL         GET CONSTANTS LENGTH        @BM10519\n*                                                              @BM10519\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS         @BM10519\n         LA    R14,TURNOUTL        SET AT LENGTH BYTE          @BM10519\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE      @BM10519\n*                                                              @BM10519\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS      @BM10519\n         BR    R6                                              @BM10519\n         DFHEJECT                                              @BM10519\n*                                                              @BM10519\n*       1 BYTE BINARY TO PRINTABLE CONVERSION                  @BM10519\nTURNV1BN DS    0H                  BYTE      BINARY            @BM10519\n         SR    R15,R15                                         @BM10519\n         IC    R15,TURNREQD        GET THE NUMBER              @BM10519\n         CVD   R15,TURNDWRD        CONVERT TO DECIMAL          @BM10519\n         UNPK  TURNOUTD(3),TURNDWRD+6(2) CONVERT TO CHAR       @BM10519\n         OI    TURNOUTD+2,C'0'     ENSURE PRINTABLE            @BM10519\n         MVI   TURNOUTL,02         SET UP LENGTH               @BM10519\n         IC    R4,TURNOUTL         GET CONSTANTS LENGTH        @BM10519\n*                                                              @BM10519\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS         @BM10519\n         LA    R14,TURNOUTL        SET AT LENGTH BYTE          @BM10519\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE      @BM10519\n*                                                              @BM10519\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS      @BM10519\n         BR    R6                                              @BM10519\n*                                                              @BM10519\n         DFHEJECT                                              @BM10519\n*    RIGHT HAND BYTE CONVERSION                                       *\n*                                                                     *\nTURNVRBN DS    0H                  HALF WORD BINARY            @BM10519\n         IC    R15,TURNREQD        GET BYTE                    @BM10519\n         N     R15,=F'15'          GET LOWER PART              @BM10519\n         CVD   R15,TURNDWRD        CONVERT TO DECIMAL          @BM10519\n         UNPK  TURNOUTD(3),TURNDWRD+6(2) CONVERT TO CHAR       @BM10519\n         OI    TURNOUTD+2,C'0'     ENSURE PRINTABLE            @BM10519\n         MVC   TURNOUTD(2),TURNOUTD+1 MOVE DOWN                @BM10519\n         MVI   TURNOUTL,04         SET UP LENGTH               @BM10519\n         IC    R4,TURNOUTL         GET CONSTANTS LENGTH        @BM10519\n*                                                              @BM10519\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS         @BM10519\n         LA    R14,TURNOUTL        SET AT LENGTH BYTE          @BM10519\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE      @BM10519\n*                                                              @BM10519\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS      @BM10519\n         BR    R6                                              @BM10519\n*                                                              @BM10519\n*                                                              @BM10519\n         DFHEJECT                                              @BM10519\n*      LEFT HAND CONVERSION ONE BYTE                                  *\n*                                                                     *\nTURNVLBN DS    0H                  HALF WORD BINARY            @BM10519\n         IC    R15,TURNREQD        GET BYTE                    @BM10519\n         N     R15,=F'15'          GET LOWER PART              @BM10519\n         CVD   R15,TURNDWRD        CONVERT TO DECIMAL          @BM10519\n         UNPK  TURNOUTD(3),TURNDWRD+6(2) CONVERT TO CHAR       @BM10519\n         OI    TURNOUTD+2,C'0'     ENSURE PRINTABLE            @BM10519\n         MVC   TURNOUTD(2),TURNOUTD+1 MOVE DOWN                @BM10519\n         MVI   TURNOUTL,04         SET UP LENGTH               @BM10519\n         IC    R4,TURNOUTL         GET CONSTANTS LENGTH        @BM10519\n*                                                              @BM10519\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS         @BM10519\n         LA    R14,TURNOUTL        SET AT LENGTH BYTE          @BM10519\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE      @BM10519\n*                                                              @BM10519\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS      @BM10519\n         BR    R6                                              @BM10519\n*                                                              @BM10519\n         DFHEJECT                                              @BM10519\n*   PACKED DECIMAL 3 CONVERSION                                @BM10519\n*                                                              @BM10519\nTURNV3DE DS    0H                  PACKED DECIMAL 3            @BM10519\n         UNPK  TURNOUTD(5),TURNREQD(3)                         @BM10519\n         OI    TURNOUTD+4,C'0'     ENSURE PRINTABLE            @BM10519\n         MVI   TURNOUTL,04         SET UP LENGTH               @BM10519\n         IC    R4,TURNOUTL         GET CONSTANTS LENGTH        @BM10519\n*                                                              @BM10519\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS         @BM10519\n         LA    R14,TURNOUTL        SET AT LENGTH BYTE          @BM10519\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE      @BM10519\n*                                                              @BM10519\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS      @BM10519\n         BR    R6                                              @BM10519\n*                                                              @BM10519\n         DFHEJECT                                              @BM10519\n*     PACKED DEC 2 CONVERSION                                  @BM10519\n*                                                              @BM10519\nTURNV2DE DS    0H                  PACKED DECIMAL 3            @BM10519\n         UNPK  TURNOUTD(3),TURNREQD(2)                         @BM10519\n         OI    TURNOUTD+2,C'0'     ENSURE PRINTABLE            @BM10519\n         MVI   TURNOUTL,02         SET UP LENGTH               @BM10519\n         IC    R4,TURNOUTL         GET CONSTANTS LENGTH        @BM10519\n*                                                              @BM10519\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS         @BM10519\n         LA    R14,TURNOUTL        SET AT LENGTH BYTE          @BM10519\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE      @BM10519\n*                                                              @BM10519\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS      @BM10519\n         BR    R6                                              @BM10519\n*                                                              @BM10519\n         DFHEJECT                                              @BM10519\n*   PACKED DEC 1 CONVERSION                                    @BM10519\n*                                                              @BM10519\nTURNV1DE DS    0H                  PACKED DECIMAL 1            @BM10519\n         UNPK  TURNOUTD(1),TURNREQD(1)                         @BM10519\n         OI    TURNOUTD+0,C'0'     ENSURE PRINTABLE            @BM10519\n         MVI   TURNOUTL,00         SET UP LENGTH               @BM10519\n         IC    R4,TURNOUTL         GET CONSTANTS LENGTH        @BM10519\n*                                                              @BM10519\n         ST    R6,TURN2ISR         SAVE RETURN ADDRESS         @BM10519\n         LA    R14,TURNOUTL        SET AT LENGTH BYTE          @BM10519\n         BAL   R6,TURNVMDM         GO TO PRINT SUBROUTINE      @BM10519\n*                                                              @BM10519\n         L     R6,TURN2ISR         RESTORE RETURN ADDRESS      @BM10519\n         BR    R6                                              @BM10519\n*                                                              @BM10519\n         DFHEJECT                                              @BM10519\n***********************************************************************\n*        SUBROUTINE TO OUTPUT LITERAL                          @BM10519\n*        FOR APPROPRIATE MINOR                                 @BM10519\n*        INPUT                                                 @BM10519\n*             R6 = RETURN ADDRESS                              @BM10519\n*             R7 = PRINT POSITION                              @BM10519\n*             R4 = CONSTANTS LENGTH                            @BM10519\n*             R0 = END OF PRINT POSITION\n*             R14= A(ONE BYTE LENGTH),CHAR STRING\n*        OUTPUT\n*             R6 = RETURN ADDRESS UNCHANGED\n*             R7 = UPDATED PRINT POSITION\n*             R4 = CONSTANTS LENGTH\n*             R0 = END OF PRINT POSITION UNCHANGED\n***********************************************************************\nTURNVMDM DS    0H                  FOUND MINOR CODE            @BD910JY\n         LA    R1,02(R4,R7)        BUMP TO NEXT PRINT POSITION @BD910JY\n         CR    R1,R0               HIGHER THAN MAX             @BD910JY\n         BNL   TURNVMRT            NO THEN EXIT NOW            @BD910JY\n         LTR   R4,R4               IS IT LENGTH ONE?           @BBAA12Y\n         BNZ   TURNVM02            .. NO BRANCH                @BBAA12Y\n         CLI   01(R14),C' '        IS IT REALLY NULL ?         @BBAA12Y\n         BE    TURNVMRT            .. YES THEN LEAVE MOVE      @BBAA12Y\nTURNVM02 DS    0H                                              @BBAA12Y\n         EX    R4,EXPRMVC          MOVE MINOR LITERAL TO PRT   @BD910JY\n         LA    R7,02(R4,R7)        BUMP TO NEXT PRINT POSITION @BD910JY\n*                                  (OVER LITERAL + 1 BLANK)\n*\nTURNVMRT DS    0H                                              @BD910JY\n         BR    R6                  RETURN                      @BD910JY\n*\n*\n*\nEXPRMVC  MVC   00(*-*,R7),01(R14)  EXECUTED MOVE LITERAL       @BD910JY\nTUTERR   DS    0H                                              @BD910JY\n         DFHTUTEN C=(00,00),K='*'                              @BD910JY\n*\n         DFHEJECT ,                                            @BD910JY\n***********************************************************************\n*        EXIT ROUTINES HERE\n*        EACH ROUTINE FORMAT THE REQUEST BYTES READY\n*        FOR INTERPRETATION BY THE BYTE COMPARE TABLES.\n*\n***********************************************************************\nTUTE1SRT DS    0H                  DEFAULT EXIT                @BD910JY\nTUTE1DFT DS    0H                                              @BD910JY\n         BR    R6                  JUST RETURN                 @BD910JY\n*\n*\nTUTE1EXC DS    0H                  FE EXIT                     @BD910JY\nTUTE1SYC DS    0H                  SYSTEM EXIT                 @BD910JY\nTUTE1USC DS    0H                  USER EXIT                   @BD910JY\n         SR    R4,R4               CLEAR R4                    @BD910JY\n         IC    R4,ZTRID            GET ID                   @EG00X @L5C\n         CVD   R4,TURNDWRD         CONVERT TO DECIMAL          @BD910JY\n         OI    TURNDWRD+7,X'0F'    ENSURE PRINTABLE            @BD910JY\n         UNPK  00(03,R7),TURNDWRD+6(2) SET INTO PRINT          @BD910JY\n         LA    R7,04(R7)           BUMP PRINT POINTER\n         BR    R6                  RETURN TO CALLER            @BD910JY\n*                                                              @BBAI20Y\n*        IRC TRACE EXIT                                               *\n*                                                              @BBAI20Y\nTUTE1DD2 DS    0H                  IRC TRACE EXIT              @BBAI20Y\n         NI    TURNREQD,X'F0'      CLEAR OUT UNWANTED BITS     @BBAI20Y\n         LA    R14,X'40'           SET RQE1                    @BBDIA0Y\n         TM    TURNREQD,X'90'      RQD1 + EXC = RQE1           @BBDIA0Y\n         BO    TUTDD010                                        @BBDIA0Y\n         LA    R14,X'10'           SET RQE2                    @BBDIA0Y\n         TM    TURNREQD,X'30'      RQD2 + EXC = RQE1           @BBDIA0Y\n         BO    TUTDD010                                        @BBDIA0Y\n         LA    R14,X'80'           SET RQD1 ONLY               @BBDIA0Y\n         TM    TURNREQD,X'80'      RQD1                        @BBDIA0Y\n         BO    TUTDD010                                        @BBDIA0Y\n         LA    R14,X'20'           RQD2                        @BBDIA0Y\n         TM    TURNREQD,X'20'      RQD2 ONLY                   @BBDIA0Y\n         BO    TUTDD010                                        @BBDIA0Y\n         SR    R14,R14             PUT NONE                    @BBDIA0Y\nTUTDD010 DS    0H                                              @BBDIA0Y\n         STC   R14,TURNREQD        SET UP REQUEST              @BM13334\n         BR    R6                  RETURN                      @BM13334\n*                                                              @BM13334\n*        VIO TRACE EXIT                                               *\n*                                                              @BM13334\nTUTE1EEA DS    0H                  VIO TRACE EXIT              @BM13334\n         LA    R14,X'00'           SET NONE                    @BM13334\n         TM    TURNREQD,X'03'      NEITHER DR1 OR DR2 ?        @BM13334\n         BZ    TUTEEA30            .. YES GET OUT              @BM13334\n         BO    TUTEEA10            .. RQ*3 - CONTINUE       @EI226 @L9A\n*                                                              @BM13334\n         TM    TURNREQD,X'04'      RQE OR RQD ?                @BM13334\n         BO    TUTEEA20            .. BRANCH IF RQE            @BM13334\n         LA    R14,X'80'           SET RQD1 ONLY               @BM13334\n         TM    TURNREQD,X'02'      RQD1                        @BM13334\n         BO    TUTEEA30            .. YES EXIT                 @BM13334\n         LA    R14,X'40'           RQD2                        @BM13334\n         B     TUTEEA30            ALL DONE NOW                @BM13334\n*                                                              @BM13334\nTUTEEA10 DS    0H                                           @EI226 @L9C\n         LA    R14,X'08'           SET RQE3 AT FIRST        @EI226 @L9A\n         TM    TURNREQD,X'04'      RQE OR RQD ?             @EI226 @L9P\n         BO    TUTEEA30            .. BRANCH IF RQE         @EI226 @L9A\n         LA    R14,X'04'           SET RQD3 ONLY            @EI226 @L9A\n         B     TUTEEA30            ALL DONE NOW             @EI226 @L9P\n*                                                              @BM13334\nTUTEEA20 DS    0H                                           @EI226 @L9P\n         LA    R14,X'20'           SET RQE1 ONLY               @BM13334\n         TM    TURNREQD,X'02'      RQE1                        @BM13334\n         BO    TUTEEA30            .. YES EXIT                 @BM13334\n         LA    R14,X'10'           RQE2                        @BM13334\n         B     TUTEEA30            ALL DONE NOW                @BM13334\n*    RETURN WITH ANSWER                                        @BM13334\nTUTEEA30 DS    0H                                              @BM13334\n         STC   R14,TURNREQD        SET UP REQUEST              @BM13334\n         BR    R6                  RETURN                      @BM13334\n*                                                              @BM13334\n*        EIP TRACE EXIT                                               *\n*                                                              @BBAI20Y\nTUTE1E1C DS    0H                  EIP TRACE EXIT              @BBAI20Y\n         NI    TURNREQD,X'F4'      CLEAR OUT UNWANTED BITS     @BBAI20Y\n         BR    R6                  RETURN                      @BBAI20Y\n*                                                              @BBAI20Y\n*                                                              @BBDIA0Y\nTUTE1F1C DS    0H                  STORAGE CONTROL EXIT        @BD910JY\n         NI    TURNREQD,X'E0'      CLEAR OUT UNWANTED BITS     @BD910JY\n         BR    R6                  RETURN                      @BD910JY\n*                                                              @BBDIA0Y\nTUTE1F2C DS    0H                  PROGRAM CONTROL EXIT        @BD910JY\n         NI    TURNREQD+1,X'F0'     TURN OFF TYPE BIT          @BBDIA0Y\n         BR    R6                   RETURN                     @BD910JY\n*                                                              @BBDIA0Y\nTUTE1F3C DS    0H                   INTERVAL CONTROL EXIT      @BD910JY\n         NI    TURNREQD,X'F0'       USE ONLY FIRST HALF        @BD910JY\n         BR    R6                   RETURN                     @BD910JY\n*\nTUTE1F4C DS    0H                  DUMP CONTROL\n         MVC   TURNREQD+1(1),ZTRDATA1 COPY TOP BYTE\n         BR    R6                  AND RETURN\n*\nTUTE1F7C DS    0H                  TEMPORARY STORAGE           @BD910JY\n         NI    TURNREQD,X'E7'      GET RID OF UNWANTED BITS    @BD910JY\n         BR    R6                  RETURN                      @BD910JY\n*                                                                     *\n*    REPEAT ENTRY                                                     *\n*                                                                     *\nTUTE1FD1 DS    0H                  REPEAT ENTRY                @BM10700\n         LA    R1,11(R7)           GET SPACE POSITION          @BM10700\n         CR    R1,R0               ENOUGH SPARE?               @BM10700\n         BNLR  R6                  .. NO GET OUT               @BM10700\n*                                                              @BM10700\n         UNPK  00(05,R7),ZTRRETAD  SET IN REPEAT NUMBER     @EG00X @L5C\n         OI    04(R7),C'0'           FIX LAST DIGIT         @EG00X @L5A\n         MVC   06(05,R7),=C'TIMES'  SET NUMBER                 @BM10700\n         LA    R7,12(R7)           BUMP COUNT                  @BM10700\n         BR    R6                  RETURN                      @BM10700\n         SPACE 2\n        DFHEJECT ,                                             @BD910JY\n***********************************************************************\n* * *        C O N S T A N T S                                    * * *\n***********************************************************************\n         DC    C'CONSTANTS'                                    @BD910JY\nSIGTIME1 DC    A(0)                SIGNIFICANT DIFFERENCE WORTH        *\n                                   PRINTING - CHANGE FOR REAL USE  @P4C\nSIGTIME2 DC    A(12800/32)         VERY SIGNIFICANT DIFFERENCE         *\n                                   - ALTER TO MEET CIRCUMSTANCES   @P4C\nSIGTIME3 DC    A(100*1000000/32)   100 SECONDS (UNITS OF 32 MICROSECS) *\n                                   - UPPER LIMIT FOR PRINTING      @P4C\nTUTB1STA DC    A(DFHTUTB1)         ADDRESS OF TABLE 1...       @BD910JY\nTUTB2STA DC    A(DFHTUTB2)         ADDRESS OF TABLE 2...       @BD910JY\nTURNVEND DC    X'FFFF'             END OF MAJOR LITERAL TABLE  @BD910JY\nTURTRT   DC    C'0123456789ABCDEF' TRANSLATE TABLE             @BD910JY\n*\n***********************************************************************\n         LTORG                                                 @BD910JY\n         DS    0D                                              @BD910JY\nTUMAXLEN EQU   32                  MAXIMUM LITERAL LENGTH      @BD910JY\n         DFHEJECT                                              @BBDIA0Y\n*  TRANSLATE TABLE                                                    *\nTUETRANS DS    0CL256                                       @15544 @P1C\n*                             48 CHARACTER SET\n         DC    C'................'           00-0F          @15544 @P1C\n         DC    C'................'           10-1F          @15544 @P1C\n         DC    C'................'           20-2F          @15544 @P1C\n         DC    C'................'           30-3F          @15544 @P1C\n         DC    C' ............(+.'           40-4F          @15544 @P1C\n         DC    C'&&..........$*)..'          50-5F          @15544 @P1C\n         DC    C'-/.........,....'           60-6F          @15544 @P1C\n         DC    C'.............''=.'          70-7F          @15544 @P1C\n         DC    C'................'           80-8F          @15544 @P1C\n         DC    C'................'           90-9F          @15544 @P1C\n         DC    C'................'           A0-AF          @15544 @P1C\n         DC    C'................'           B0-BF          @15544 @P1C\n         DC    C'.ABCDEFGHI......'           C0-CF          @15544 @P1C\n         DC    C'.JKLMNOPQR......'           D0-DF          @15544 @P1C\n         DC    C'..STUVWXYZ......'           E0-EF          @15544 @P1C\n         DC    C'0123456789......'           F0-FF          @15544 @P1C\n*\n         ORG   ,                                               @BD910JY\n         DFHEJECT ,                                            @BD910JY\n*\n*        WORK AREAS\n*\n         DC    C'WORKAREA'                                     @BD910JY\n         DS    0D                                              @BD910JY\nTUESAVRG DC    18F'0'              SYSTEM REGISTER SAVE AREA   @BD910JY\nTURNREQD DC    XL16'00'            WORK AREA REQUEST CODES     @BD910JY\nTURNTYSV DC    H'0'                REQUEST TYPE                @BBAI20Y\n*\n*\nTURNDWRD DC    D'0'                                            @BM10519\nTURNOUTL DC    X'0'                LENGTH BYTE                 @BM10519\nTURNOUTD DC    XL16'00'            DATA AREA                   @BM10519\n***********************************************************************\n         DFHEJECT ,                                            @BM10700\n*                                                                     *\n*       TYPE  OF ENTRY TABLE                                          *\n*                                                                     *\nTUTENTAB DS    0H                                              @BBAI20Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  00 RESERVED             @BBDIA0Y\n         DC    AL2(TUTI11FE-TUTI1SRT)  01 FE                   @BBDIA0Y\n         DC    AL2(TUTI11US-TUTI1SRT)  02 USER                 @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  03 LIFO ENTRY           @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  04 SYSTEM               @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  05 LIFO RETURN          @BBDIA0Y\n         DC    AL2(TUTI11XC-TUTI1SRT)  06 EXCEPTION            @BM13334\n         DC    AL2(TUTI11PF-TUTI1SRT)  07 PERFORMANCE          @BM13334\n         DC    AL2(TUTI11PP-TUTI1SRT)  08 RESERVED             @BM13334\n         DC    AL2(TUTI11SY-TUTI1SRT)  09 RESERVED             @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  0A RESERVED             @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  0B RESERVED             @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  0C RESERVED             @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  0D TRACE ON/OFF         @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  0E AUX TRACING          @BBDIA0Y\n         DC    AL2(TUTI11SY-TUTI1SRT)  0F REPEAT ENTRY         @BBDIA0Y\n*                                                              @BBDIA0Y\nRETNCHRL DS    0H                                              @BM13334\n         DFHTUTEN C=(00,00),K='RETN'                           @BM13334\n         DFHEJECT ,                                            @BBAI20Y\n***********************************************************************\n*    INDEX CSECT TO ADDRESS CORRECT MAIN TABLE                        *\n***********************************************************************\nDFHTUTI1 CSECT                                                 @BBDIA0Y\nTUTI1SRT DS    0H                                              @BBDIA0Y\n         SPACE 4                                               @BM13334\n*                                                                     *\n*       OFFSET TABLE FOR 'USER ENTRIES '  TYPE 02                     *\n*                                                                     *\n         DS    0H                                              @BM13334\nTUTI11US DC    AL2(255)            LOWEST ID IN TABLE          @BM13334\n*                                                              @BM13334\n*        OFFSETS TO FIRST LEVEL TABLE                          @BM13334\n*        MUST FOLLOW TUTI11US                                  @BM13334\n         DC    AL2(TUTB1VUS-TUTB1SRT)  X'00'-X'FF' USER        @BM13334\n         DFHEJECT ,                                            @BM13334\n*                                                                     *\n*       OFFSET TABLE FOR 'EXCEPTION ENTRIES  TYPE 06                  *\n*                                                                     *\n         DS    0H                                              @BBAI20Y\nTUTI11XC DC    AL2(255)            LOWEST ID IN TABLE          @BM13334\n*                                                              @BM13334\n*        OFFSETS TO FIRST LEVEL TABLE                          @BM13334\n*        MUST FOLLOW TUTI11US                                  @BM13334\n         DC    AL2(TUTB1VXC-TUTB1SRT)  X'00'-X'FF' EXCEPTION   @BM13334\n         DFHEJECT ,                                            @BM13334\n*                                                                     *\n*       OFFSET TABLE FOR PERFORMANCE ENTRIES TYPE 07                  *\n*                                                                     *\n         DS    0H                                              @BM13334\nTUTI11PF DC    AL2(255)            LOWEST ID IN TABLE          @BM13334\n*                                                              @BM13334\n*        OFFSETS TO FIRST LEVEL TABLE                          @BM13334\n*        MUST FOLLOW TUTI11US                                  @BM13334\n         DC    AL2(TUTB1VPF-TUTB1SRT)  X'00'-X'FF' PERFORMANCE @BM13334\n         DFHEJECT ,                                            @BM13334\n*                                                                     *\n*       OFFSET TABLE FOR 'EXCEPTION ENTRIES  TYPE 08                  *\n*                                                                     *\n         DS    0H                                              @BM13334\nTUTI11PP DC    AL2(255)            LOWEST ID IN TABLE          @BM13334\n*                                                              @BM13334\n*        OFFSETS TO FIRST LEVEL TABLE                          @BM13334\n*        MUST FOLLOW TUTI11US                                  @BM13334\n         DC    AL2(TUTB1VPP-TUTB1SRT)  X'00'-X'FF' PPS         @BM13334\n         DFHEJECT ,                                            @BM13334\n*                                                                     *\n*       OFFSET TABLE FOR 'FE     ENTRIES '  TYPE 01                   *\n*                                                                     *\n         DS    0H                                              @BM13334\nTUTI11FE DC    AL2(16*14)     X'E0'LOWEST ID IN TABLE          @BM13334\n*                                                              @BM13334\n*        OFFSETS TO FIRST LEVEL TABLE                          @BM13334\n*        MUST FOLLOW TUTI11FE                                  @BM13334\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'00'-X'E0' FE          @BM13334\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E1' FE                @BM13334\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E2' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E3' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E4' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E5' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFO-TUTB1SRT)  X'E6' TCP (FE)              @D2C\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E7' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E8' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'E9' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'EA' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'EB' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'EC' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'ED' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'EE' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'EF' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F0' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F1' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F2' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F3' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F4' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F5' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F6' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFQ-TUTB1SRT)  X'F7' TSP (FE)          @BA26864\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F8' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'F9' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'FA' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'FB' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'FC' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFP-TUTB1SRT)  X'FD' TRP (FE)              @LVC\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'FE' FE                @BBDIA0Y\n         DC    AL2(TUTB1VFN-TUTB1SRT)  X'FF' FE                @BBDIA0Y\n         DFHEJECT ,                                            @BBAI20Y\n*                                                                     *\n*       OFFSET TABLE FOR 'SYSTEM ENTRIES '                            *\n*                                                                     *\n         DS    0H                                              @BBAI20Y\nTUTI11SY DC    AL2(16*12)    X'C0' LOWEST ID IN TABLE          @BBAI20Y\n*                                                              @BBAI20Y\n*        OFFSETS TO FIRST LEVEL TABLE                          @BBAI20Y\n*        MUST FOLLOW TUTI11SY                                  @BBAI20Y\n         DC    AL2(TUTB1VSY-TUTB1SRT)  X'00'-X'C0' SYSTEM      @BBDIA0Y\n         DC    AL2(TUTB1VSY-TUTB1SRT)  X'C1' = ****            @BBDIA0Y\n         DC    AL2(TUTB1VC2-TUTB1SRT)  X'C2' = FE 2ND LEVEL 194@BA55868\n         DC    AL2(TUTB1VC3-TUTB1SRT)  X'C3' = CCNV            @BA37427\n         DC    AL2(TUTB1VC4-TUTB1SRT)  X'C4' = WMS     196         @LXC\n         DC    AL2(TUTB1VC5-TUTB1SRT)  X'C5' = XRCP    197         @M3C\n         DC    AL2(TUTB1VC6-TUTB1SRT)  X'C6' = XRSP    198         @M3C\n         DC    AL2(TUTB1VC7-TUTB1SRT)  X'C7' = XRP     199         @M2C\n         DC    AL2(TUTB1VC8-TUTB1SRT)  X'C8' = SC      200     @BBDIA0Y\n         DC    AL2(TUTB1VC9-TUTB1SRT)  X'C9' = SC      201     @BD910JY\n         DC    AL2(TUTB1VCA-TUTB1SRT)  X'CA' = SC      202     @BD910JY\n         DC    AL2(TUTB1VCB-TUTB1SRT)  X'CB' = DBP     203         @LMC\n         DC    AL2(TUTB1VCC-TUTB1SRT)  X'CC' = CCP     204         @LLC\n         DC    AL2(TUTB1VCD-TUTB1SRT)  X'CD' = BMS     205         @LMC\n         DC    AL2(TUTB1VCE-TUTB1SRT)  X'CE' = RCP     206         @LLC\n         DC    AL2(TUTB1VCF-TUTB1SRT)  X'CF' = BMS     207     @BD910JY\n         DC    AL2(TUTB1VD0-TUTB1SRT)  X'D0' = KC AUX  208         @LMC\n         DC    AL2(TUTB1VSY-TUTB1SRT)  X'D1' = RESERVED209     @BD910JY\n         DC    AL2(TUTB1VD2-TUTB1SRT)  X'D2' = VOLUME  210  @E211Q @L7C\n         DC    AL2(TUTB1VD3-TUTB1SRT)  X'D3' = LUP     211  @EI00U @L6A\n         DC    AL2(TUTB1VSY-TUTB1SRT)  X'D4' = RESERVED212     @BD910JY\n         DC    AL2(TUTB1VD5-TUTB1SRT)  X'D5' = UE      213     @BD910JY\n         DC    AL2(TUTB1VD6-TUTB1SRT)  X'D6' = AL      214     @BBDI80O\n         DC    AL2(TUTB1VD7-TUTB1SRT)  X'D7' = DI      215     @BD910JY\n         DC    AL2(TUTB1VD8-TUTB1SRT)  X'D8' = SP      216     @BD910JY\n         DC    AL2(TUTB1VD9-TUTB1SRT)  X'D9' = XFP     217     @BD910JY\n         DC    AL2(TUTB1VDA-TUTB1SRT)  X'DA' = STATS   218     @BD910JY\n         DC    AL2(TUTB1VDB-TUTB1SRT)  X'DB' = XTP     219     @BBDJ20B\n         DC    AL2(TUTB1VDC-TUTB1SRT)  X'DC' = ACP **  220     @BD910JY\n         DC    AL2(TUTB1VDD-TUTB1SRT)  X'DD' = IRC     221     @BD910JY\n         DC    AL2(TUTB1VDE-TUTB1SRT)  X'DE' = SKP     222         @LIC\n         DC    AL2(TUTB1VDF-TUTB1SRT)  X'DF' = ISP     223     @BD910JY\n         DC    AL2(TUTB1VE0-TUTB1SRT)  X'E0' = MGP     224     @BD910JY\n         DC    AL2(TUTB1VE1-TUTB1SRT)  X'E1' = HLL     225     @BD910JY\n         DC    AL2(TUTB1VE2-TUTB1SRT)  X'E2' = SNP     226     @BD910JY\n         DC    AL2(TUTB1VE3-TUTB1SRT)  X'E3' = PSP     227         @LEC\n         DC    AL2(TUTB1VE4-TUTB1SRT)  X'E4' = MTP     228     @BD910JY\n         DC    AL2(TUTB1VE5-TUTB1SRT)  X'E5' = XSP     229     @BD910JY\n         DC    AL2(TUTB1VE6-TUTB1SRT)  X'E6' = TACP    230         @LRC\n         DC    AL2(TUTB1VE7-TUTB1SRT)  X'E7' = EDLI    231     @BD910JY\n         DC    AL2(TUTB1VE8-TUTB1SRT)  X'E8' = ****    232     @BD910JY\n         DC    AL2(TUTB1VE9-TUTB1SRT)  X'E9' = ****    233     @BD910JY\n         DC    AL2(TUTB1VEA-TUTB1SRT)  X'EA' = TMP     234  @EU71T @L2C\n         DC    AL2(TUTB1VEB-TUTB1SRT)  X'EB' = AMP     235  @EU71J @L4C\n         DC    AL2(TUTB1VEC-TUTB1SRT)  X'EC' = DMP     236  @EU71J @L4C\n         DC    AL2(TUTB1VED-TUTB1SRT)  X'ED' = LFO     237     @BBDIA0Y\n         DC    AL2(TUTB1VEE-TUTB1SRT)  X'EE' = VIO     238     @BBDIA0Y\n         DC    AL2(TUTB1VEF-TUTB1SRT)  X'EF' = TOR     239         @LKC\n*        SYSTEM MACRO ENTRIES                                  @BBDIA0Y\n         DC    AL2(TUTB1VF0-TUTB1SRT)  X'F0' = KC      240     @BD910JY\n         DC    AL2(TUTB1VF1-TUTB1SRT)  X'F1' = SC      241     @BD910JY\n         DC    AL2(TUTB1VF2-TUTB1SRT)  X'F2' = PC      242     @BD910JY\n         DC    AL2(TUTB1VF3-TUTB1SRT)  X'F3' = IC      243     @BD910JY\n         DC    AL2(TUTB1VF4-TUTB1SRT)  X'F4' = DC      244     @BD910JY\n         DC    AL2(TUTB1VF5-TUTB1SRT)  X'F5' = FC      245     @BD910JY\n         DC    AL2(TUTB1VF6-TUTB1SRT)  X'F6' = TD      246     @BD910JY\n         DC    AL2(TUTB1VF7-TUTB1SRT)  X'F7' = TS      247     @BD910JY\n         DC    AL2(TUTB1VF8-TUTB1SRT)  X'F8' = DL/I    248     @BD910JY\n         DC    AL2(TUTB1VF9-TUTB1SRT)  X'F9' = JC      249     @BD910JY\n         DC    AL2(TUTB1VFA-TUTB1SRT)  X'FA' = BMS     250     @BD910JY\n         DC    AL2(TUTB1VFB-TUTB1SRT)  X'FB' = BIF     251     @BD910JY\n         DC    AL2(TUTB1VFC-TUTB1SRT)  X'FC' = ZCP     252     @BD910JY\n         DC    AL2(TUTB1VFD-TUTB1SRT)  X'FD' = TRACE INT 253   @BM10700\n         DC    AL2(TUTB1VFE-TUTB1SRT)  X'FE' = TRACE ON  254   @BD910JY\n         DC    AL2(TUTB1VFF-TUTB1SRT)  X'FF' = TRACE OFF 255   @BD910JY\n*                                                              @BBDIA0Y\n         DFHEJECT ,                                            @BBDIA0Y\n************************************************************** @BBDIA0Y\n*      THIS IS THE MAJOR TABLE CONSISTING OF :                 @BBDIA0Y\n*        ONE BYTE ID FOR COMPARE                               @BBDIA0Y\n*        3   BYTE CHAR ID NAME                                 @BBDIA0Y\n*        2 BYTE OFFSET TO COMPARE REQD TABLE                   @BBDIA0Y\n*        2 BYTE OFFSET TO EXIT ROUTINE TO FORMAT REQUEST       @BBDIA0Y\n***********************************************************************\nDFHTUTB1 CSECT                                                 @BD910JY\nTUTB1SRT DS    0H                  START OF TABLE ENTRIES      @BD910JY\n*                                                              @BM13334\n*        SPECIAL ENTRIES                                       @BM13334\n*                                                              @BM13334\n*        USER ENTRY                                                   *\nTUTB1VUS DFHTUTEN T=1,TB=USD,             TABLE OFFSET                 *\n               E=DFT,                                                  *\n               K='USER'                                        @BM13334\n         SPACE 4                                               @BM13334\n*                                                              @BM13334\n*        SPECIAL ENTRIES                                       @BM13334\n*                                                              @BM13334\n*        EXCEPTION                                                    *\nTUTB1VXC DFHTUTEN T=1,TB=USD,             TABLE OFFSET                 *\n               E=DFT,                                                  *\n               K='**EX**'                                      @BM13334\n*                                                              @BM13334\n*        SPECIAL ENTRIES                                       @BM13334\n*                                                              @BM13334\n*        PERFORMANCE                                                  *\nTUTB1VPF DFHTUTEN T=1,TB=USD,             TABLE OFFSET                 *\n               E=DFT,                                                  *\n               K='PERFORM'                                     @BM13334\n*                                                              @BM13334\n*        SPECIAL ENTRIES                                       @BM13334\n*                                                              @BM13334\n*        PP   ENTRY                                                   *\nTUTB1VPP DFHTUTEN T=1,TB=USD,             TABLE OFFSET                 *\n               E=DFT,                                                  *\n               K='PP'                                          @BM13334\n*                                                              @BM13334\n*        SPECIAL ENTRIES                                       @BM13334\n*                                                              @BM13334\n*        FE  ENTRY  (GENERAL)                                         *\nTUTB1VFN DFHTUTEN  T=1,TB=EXD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='FE'                                          @BM13334\n*                                                              @BM13334\n*                                                              @BM13334\n*        FE  ENTRY  (TCP  -  NON-VTAM TERMINALS ONLY)                 *\nTUTB1VFO DFHTUTEN  T=1,TB=E6D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='TCP (FE)'      SAME TRACE ID / TABLE AS TACP     @D2C\n*                                                                     *\n*                                                                     *\n*        FE  ENTRY  (TRP  -  TRACE INTERNAL)                          *\nTUTB1VFP DFHTUTEN  T=1,TB=FDD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='TRP (FE)'                                        @LVA\n*                                                              @BA26864\n*                                                              @BA26864\n*        FE  ENTRY  (TSP - AUXILLARY STORAGE ONLY)             @BA26864\nTUTB1VFQ DFHTUTEN  T=1,TB=F7H,             TABLE OFFSET        @BA26864*\n               E=DFT,                                          @BA26864*\n               K='TSP (FE)'                                    @BA26864\n*                                                              @BM13334\n         DFHEJECT ,                                            @BM13334\n*                                                              @BM13334\n*        DEFAULT ENTRY                                                *\n*        SYSTEM ENTRY  DEFAULT                                        *\n*                                                                     *\nTUTB1VSY DFHTUTEN  T=1,TB=SYD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='SYSTEM'                                      @BD910JY\n*                                                              @BBDIA0Y\n*        GENERAL SYSTEM ENTRIES                                       *\nTUTB1VC2 DFHTUTEN  T=1,TB=C2D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='L2 '                                         @BA55868\n*        NEXT ENTRY                                            @BA55868\nTUTB1VC3 DFHTUTEN  T=1,TB=C3E,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='CCNV'                                        @BA37427\n*        NEXT ENTRY                                            @BA37427\nTUTB1VC4 DFHTUTEN  T=1,TB=C4E,             TABLE OFFSET                *\n               TBR=C4R,                                                *\n               E=DFT,                                                  *\n               K='WMS'                                             @LXA\n*        NEXT ENTRY                                                   *\nTUTB1VC5 DFHTUTEN  T=1,TB=C5E,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='XRCP'                                            @M3A\n*        NEXT ENTRY                                                   *\nTUTB1VC6 DFHTUTEN  T=1,TB=C6E,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='XRSP'                                            @M3A\n*        NEXT ENTRY                                                   *\nTUTB1VC7 DFHTUTEN  T=1,TB=C7E,             TABLE OFFSET                *\n               TBR=C7R,                                                *\n               E=DFT,                                                  *\n               K='XRP'                                             @M2A\n*        NEXT ENTRY                                                   *\nTUTB1VC8 DFHTUTEN  T=1,TB=C8D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='SCP ACQUIRED'                                @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VC9 DFHTUTEN  T=1,TB=C9D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='SCP RELEASED' IDENT                          @BD910JY\n*        NEXT ENTRY                                                  *\nTUTB1VCA DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='SCP STORAGE VIOLATION '                      @BD910JY\n*        NEXT ENTRY                                                  *\nTUTB1VCB DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='DBP DYN BACKOUT'                             @BM13334\n*        NEXT ENTRY                                                   *\nTUTB1VCC DFHTUTEN  T=1,TB=CCD,             TABLE OFFSET                *\n               TBR=CCR,                                                *\n               E=DFT,                                                  *\n               K='CCP'                                             @LLA\n*        NEXT ENTRY                                                  *\nTUTB1VCD DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='BMS TS IDERROR'                              @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VCE DFHTUTEN  T=1,TB=CED,             TABLE OFFSET                *\n               TBR=CER,                                                *\n               E=DFT,                                                  *\n               K='RCP'                                             @LLA\n*        NEXT ENTRY                                                  *\nTUTB1VCF DFHTUTEN  T=1,TB=CFD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='BMS RESPONSE'                                @BD910JY\n*        NEXT ENTRY                                                  *\nTUTB1VD0 DFHTUTEN  T=1,TB=D0D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='KCP'                                         @BD910JY\n*        NEXT ENTRY                                                  *\nTUTB1VD2 DFHTUTEN  T=1,TB=D2D,             TABLE OFFSET FOR CALLS      *\n               TBR=D2R,            TABLE OFFSET FOR RETURNS            *\n               E=DFT,              NO EXIT                             *\n               K='VCP'                                      @E211Q @L7C\n*        NEXT ENTRY                                                  *\nTUTB1VD3 DFHTUTEN  T=1,TB=D3D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='LUP'                                      @EI00U @L6A\n*        NEXT ENTRY                                                   *\nTUTB1VD5 DFHTUTEN  T=1,TB=D5D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='UEH'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VD6 DFHTUTEN  T=1,TB=D6D,             TABLE OFFSET                *\n               TBR=D6R,                                                *\n               E=DFT,                                                  *\n               K='ALP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VD7 DFHTUTEN  T=1,TB=D7D,             TABLE OFFSET                *\n               TBR=D7R,                                                *\n               E=DFT,                                                  *\n               K='DIP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VD8 DFHTUTEN  T=1,TB=D8D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='SPP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VD9 DFHTUTEN  T=1,TB=E1D,             USE E1 TABLE AS D9D         *\n               E=DFT,                                                  *\n               K='XF '                                     @FJ420J @LBC\n*        NEXT ENTRY                                                   *\nTUTB1VDA DFHTUTEN  T=1,TB=DAD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='STATISTICS'                                  @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VDB DFHTUTEN  T=1,TB=DBD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='XTP'                                         @BBDJ20B\n*        NEXT ENTRY                                                   *\nTUTB1VDC DFHTUTEN  T=1,TB=DCD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='ACP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VDD DFHTUTEN  T=1,TB=DDD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='IRC'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VDE DFHTUTEN  T=1,TB=DED,             TABLE OFFSET                *\n               TBR=DER,                                                *\n               E=DFT,                                                  *\n               K='SKP'                                             @LIC\n*        NEXT ENTRY                                                   *\nTUTB1VDF DFHTUTEN  T=1,TB=DFD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='ISP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VE0 DFHTUTEN  T=1,TB=E0D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='MGP DFH'                                     @BM10519\nTUTB1VE1 DFHTUTEN  T=1,TB=E1D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='EIP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VE2 DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='SNP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VE3 DFHTUTEN  T=1,TB=E3D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='PSP'                                             @LEC\n*        NEXT ENTRY                                                   *\nTUTB1VE4 DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='MTP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\n*     XSP TRACE ENTRY E5                                              *\nTUTB1VE5 DFHTUTEN  T=1,TB=E5D,             TABLE OFFSET                *\n               TBR=NUL,            NULL EXIT TRACE                     *\n               E=DFT,                                                  *\n               K='XSP'                                         @BA78016\n*        NEXT ENTRY                                                   *\n*     TACP TRACE ENTRY E6                                             *\nTUTB1VE6 DFHTUTEN  T=1,TB=E6D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='TACP'                                            @LRC\n*        NEXT ENTRY                                                   *\n*    EDLI TRACE ENTRY E7                                              *\nTUTB1VE7 DFHTUTEN  T=1,TB=E7D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='ERM'                                      @ECB0R @L1C\n*        NEXT ENTRY                                                   *\n*     XXX TRACE ENTRY E8                                              *\nTUTB1VE8 DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='***'                                         @BD910JY\n*        NEXT ENTRY                                                   *\n*     XXX TRACE ENTRY E9                                              *\nTUTB1VE9 DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='***'                                         @BD910JY\n*        NEXT ENTRY                                                   *\n*     XXX TRACE ENTRY EA                                              *\nTUTB1VEA DFHTUTEN  T=1,TB=EAD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               TBR=EAR,                    RESPONSE TABLE              *\n               K='TMP'                                      @EU71T @L2C\n*        NEXT ENTRY                                                   *\n*     XXX TRACE ENTRY EB                                              *\nTUTB1VEB DFHTUTEN  T=1,TB=EBD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='AMP'                                      @EU71J @L4C\n*        NEXT ENTRY                                                   *\n*     XXX TRACE ENTRY EC                                              *\nTUTB1VEC DFHTUTEN  T=1,TB=ECD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='DMP'                                      @EU71J @L4C\n*        NEXT ENTRY                                                   *\n*    LFO  TRACE ENTRY ED                                              *\nTUTB1VED DFHTUTEN  T=1,TB=EDD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='LFO'                                         @BBDIA0Y\n*        NEXT ENTRY                                                   *\n*    VTAM TRACE ENTRY EE                                              *\nTUTB1VEE DFHTUTEN  T=1,TB=EED,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='VIO'                                         @BBDIA0Y\n*        NEXT ENTRY                                                   *\n*    TOR  TRACE ENTRY EF                                              *\nTUTB1VEF DFHTUTEN  T=1,TB=EFD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='TOR'                                             @LKC\n*        NEXT ENTRY                                                   *\n*        SYSTEM MACRO ENTRIES                                         *\nTUTB1VF0 DFHTUTEN  T=1,TB=F0D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='KCP'                                         @BBDIA0Y\n*        NEXT ENTRY                                                   *\nTUTB1VF1 DFHTUTEN  T=1,TB=F1D,             TABLE OFFSET                *\n               E=F1C,                                                  *\n               K='SCP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VF2 DFHTUTEN  T=1,TB=F2D,             TABLE OFFSET                *\n               E=F2C,                                                  *\n               K='PCP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VF3 DFHTUTEN  T=1,TB=F3D,             TABLE OFFSET                *\n               E=F3C,                                                  *\n               TBR=F3E,                    RESPONSE TABLE      @BM11003*\n               K='ICP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VF4 DFHTUTEN  T=1,TB=F4D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='DCP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VF5 DFHTUTEN  T=1,TB=F5D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               TBR=F5E,                                                *\n               K='FCP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VF6 DFHTUTEN  T=1,TB=F6D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               TBR=F6E,                    RESPONSE TABLE      @BM11003*\n               K='TDP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VF7 DFHTUTEN  T=1,TB=F7D,             TABLE OFFSET                *\n               TBR=F7E,                    RESPONSE TABLE      @BM11003*\n               E=F7C,                                                  *\n               K='TSP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VF8 DFHTUTEN  T=1,TB=F8D,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='DLI'                                      @E8D08 @M1C\n*        NEXT ENTRY                                                   *\nTUTB1VF9 DFHTUTEN  T=1,TB=F9D,             TABLE OFFSET                *\n               TBR=F9E,                                                *\n               E=DFT,                                                  *\n               K='JCP'                                             @P5C\n*        NEXT ENTRY                                                   *\nTUTB1VFA DFHTUTEN  T=1,TB=FAD,             TABLE OFFSET                *\n               TBR=CFD,                                                *\n               E=DFT,                                                  *\n               K='BMS'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VFB DFHTUTEN  T=1,TB=FBD,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='BIF'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VFC DFHTUTEN  T=1,TB=FCD,             TABLE OFFSET                *\n               TBR=FCE,                                                *\n               E=DFT,                                                  *\n               K='ZCP'                                         @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VFD DFHTUTEN  T=1,TB=FDD,             TABLE OFFSET                *\n               E=DFT,                      SYSTEM ENTRY                *\n               K=' '                                           @BM10416\n*        NEXT ENTRY                                                   *\nTUTB1VFE DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='TRP TRACE ON'                                @BD910JY\n*        NEXT ENTRY                                                   *\nTUTB1VFF DFHTUTEN  T=1,TB=NUL,             TABLE OFFSET                *\n               E=DFT,                                                  *\n               K='TRP TRACE OFF'                               @BD910JY\n***********************************************************************\n         DFHEJECT ,                                            @BD910JY\n***********************************************************************\n*        THE FOLLOWING ARE TABLES IN THE FORMAT :\n*              1 BYTE COMPARE VALUE\n*              1 BYTE LENGTH OF LITERAL MINUS ONE\n*              N BYTE LITERAL\n*\n*    IF AN EQUAL COMPARE OCCURS THEN LITERAL IS MOVED TO PRINT\n*       FIELD.\n***********************************************************************\nDFHTUTB2 CSECT                                                 @BD910JY\nTUTB2SRT DS    0H                     DUMMY                    @BD910JY\nTUTB2NUL EQU   *                      NULL EXIT                @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT\n  DFHTUTEN     C=(FF,FF),K=' '     END MARKER                  @BD910JY\n*                                                                     *\nTUTB2EXD EQU   *              GENERAL EXIT    FE               @BD910JY\nTUTB2USD EQU   *              GENERAL EXIT    USER             @BD910JY\nTUTB2SYD EQU   *              GENERAL EXIT    SYSTEM           @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=EXC,NX=SRT\n  DFHTUTEN     C=(FF,FF),K=' '     END MARKER                  @BD910JY\n*                                                                     *\nTUTB2GND EQU   *              GENERAL EXIT                     @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT\n  DFHTUTEN     C=(00,00),K='RESPONSE'                          @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n         PRINT NOGEN                                           @BD910JY\n*                                                                     *\nTUTB2C2D EQU   *   SECOND LEVEL TRACE                          @BA55868\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BA55868\n  DFHTUTEN     C=(01),K='EIP FREEMAIN'                         @BA55868\n  DFHTUTEN     C=(02),K='EIP GETMAIN SHARED'                   @BA55868\n  DFHTUTEN     C=(03),K='EIP GETMAIN TERM'                     @BA55868\n  DFHTUTEN     C=(04),K='EIP GETMAIN TD'                       @BA55868\n  DFHTUTEN     C=(05),K='EIP GETMAIN TS'                       @BA55868\n  DFHTUTEN     C=(06),K='EIP GETMAIN USER'                     @BA55868\n  DFHTUTEN     C=(07),K='EIP FREEMAIN TERM'                    @BA55868\n  DFHTUTEN     C=(0F),K='EIP EXIT GET/FREE'                    @BA55868\n*                                                              @BA55868\nTUTB2C3E EQU   *                                               @BA37427\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BA37427\n  DFHTUTEN     C=(01,00),K='TS'                                @BA37427\n  DFHTUTEN     C=(02,00),K='TS TEMPLATE'                       @BA37427\n  DFHTUTEN     C=(03,00),K='TD'                                @BA37427\n  DFHTUTEN     C=(04,00),K='TD TEMPLATE'                       @BA37427\n  DFHTUTEN     C=(05,00),K='FC DATA'                           @BA37427\n  DFHTUTEN     C=(06,00),K='FC DATA TEMPLATE'                  @BA37427\n  DFHTUTEN     C=(07,00),K='FC KEY'                            @BA37427\n  DFHTUTEN     C=(08,00),K='FC KEY TEMPLATE'                   @BA37427\n  DFHTUTEN     C=(09,00),K='IC'                                @BA37427\n  DFHTUTEN     C=(0A,00),K='IC TEMPLATE'                       @BA37427\n  DFHTUTEN     C=(0B,00),K='EXIT'                              @BA37427\n  DFHTUTEN     C=(0C,00),K='ENTRY'                             @BA37427\n  DFHTUTEN     C=(0D,00),K='PC'                                @BA60729\n  DFHTUTEN     C=(0E,00),K='PC TEMPLATE'                       @BA60729\n  DFHTUTEN     C=(FF,FF),K=                                    @BA37427\n*                                                              @BA37427\nTUTB2C4E EQU   *                                                   @LXA\n  DFHTUTEN     T=(2,I),CP=CLC,OFF=A2,E=DFT,NX=SRT                  @LXA\n  DFHTUTEN     C=(00,01),K='PUTMSG'                                @LXA\n  DFHTUTEN     C=(00,02),K='GETMSG'                                @LXA\n  DFHTUTEN     C=(00,03),K='PUTREQ'                                @LXA\n  DFHTUTEN     C=(00,04),K='PUTRSP'                                @LXA\n  DFHTUTEN     C=(FF,FF),K=                                        @LXA\nTUTB2C4R EQU   *                                                   @LXA\n  DFHTUTEN     T=(2,I),CP=CLC,OFF=A2,E=DFT,NX=SRT                  @LXA\n  DFHTUTEN     C=(00,00),K='NORMAL'                                @LXA\n  DFHTUTEN     C=(04,01),K='XRF NOT ACTIVE'                        @LXA\n  DFHTUTEN     C=(04,02),K='END OF DATA'                           @LXA\n  DFHTUTEN     C=(04,03),K='SIGNED OFF'                            @LXA\n  DFHTUTEN     C=(08,01),K='INVALID REQUEST'                       @LXA\n  DFHTUTEN     C=(08,02),K='SERVICE CLOSED'                        @LXA\n  DFHTUTEN     C=(08,03),K='TASK CANCELLED'                        @LXA\n  DFHTUTEN     C=(08,04),K='LENGTH ERROR'                          @LXA\n  DFHTUTEN     C=(08,05),K='OVERLAP'                               @LXA\n  DFHTUTEN     C=(08,06),K='NO DESTINATION'                        @LXA\n  DFHTUTEN     C=(08,07),K='QUEUE BUSY'                            @LXA\n  DFHTUTEN     C=(08,08),K='PROGRAM CHECK'                         @LXA\n  DFHTUTEN     C=(08,09),K='ABEND'                                 @LXA\n  DFHTUTEN     C=(08,0A),K='I/O ERROR'                             @LXA\n  DFHTUTEN     C=(08,0B),K='FORMAT ERROR'                          @LXA\n  DFHTUTEN     C=(08,0C),K='SEQUENCE ERROR'                        @LXA\n  DFHTUTEN     C=(FF,FF),K=                                        @LXA\n*                                                                     *\nTUTB2C5E EQU   *                   XRCP                            @M3A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT                  @M3A\n  DFHTUTEN     C=(00,00),K='ENTER'                                 @M3A\n  DFHTUTEN     C=(01,00),K='RETURN'                                @M3A\n  DFHTUTEN     C=(02,00),K='RESUME'                                @M3A\n  DFHTUTEN     C=(03,00),K='SUSPEND'                               @M3A\n  DFHTUTEN     C=(04,00),K='CIB PREFIX'                            @M3A\n  DFHTUTEN     C=(05,00),K='CIB DATA'                              @M3A\n  DFHTUTEN     C=(06,00),K='CIB DATA - CONT 1'                     @M3A\n  DFHTUTEN     C=(07,00),K='CIB DATA - CONT 2'                     @M3A\n  DFHTUTEN     C=(FF,FF),K=                                        @M3A\n*                                                                     *\nTUTB2C6E EQU   *                   XRSP                            @M3A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT                  @M3A\n  DFHTUTEN     C=(00,00),K='ENTER'                                 @M3A\n  DFHTUTEN     C=(01,00),K='RETURN'                                @M3A\n  DFHTUTEN     C=(02,00),K='RESUME'                                @M3A\n  DFHTUTEN     C=(03,00),K='SUSPEND'                               @M3A\n  DFHTUTEN     C=(04,00),K='WORK ELEMENT',NX=C6F                   @M3A\n  DFHTUTEN     C=(05,00),K='WORK ELEMENT - CONT 1'                 @M3A\n  DFHTUTEN     C=(06,00),K='WORK ELEMENT - CONT 2'                 @M3A\n  DFHTUTEN     C=(07,00),K='ABEND'                                 @M3A\n  DFHTUTEN     C=(FF,FF),K=                                        @M3A\n*                                                                     *\nTUTB2C6F EQU   *                   XRSP - WORK ELEMENT ID          @M3A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT                  @M3A\n  DFHTUTEN     C=(01,00),K='SIGNON',NX=C6G                         @M3A\n  DFHTUTEN     C=(02,00),K='SIGNOFF NORMAL',NX=C6G                 @M3A\n  DFHTUTEN     C=(03,00),K='SIGNOFF ABNORMAL'                      @M3A\n  DFHTUTEN     C=(07,00),K='CLOCK DIFFERENCE CHANGED'              @M3A\n  DFHTUTEN     C=(08,00),K='HEALTH DATA CHANGED'                   @M3A\n  DFHTUTEN     C=(09,00),K='HEARTBEAT OVERDUE'                     @M3A\n  DFHTUTEN     C=(0A,00),K='HEARTBEAT RESUMED'                     @M3A\n  DFHTUTEN     C=(0F,00),K='TAKEOVER REQUESTED',NX=C6H             @M3A\n  DFHTUTEN     C=(10,00),K='POST IA ECB'                           @M3A\n  DFHTUTEN     C=(11,00),K='POST TC ECB'                           @M3A\n  DFHTUTEN     C=(12,00),K='POST SS ECB'                           @M3A\n  DFHTUTEN     C=(13,00),K='POST ST ECB'                           @M3A\n  DFHTUTEN     C=(18,00),K='CAVM FAILED'                           @M3A\n  DFHTUTEN     C=(19,00),K='INVALIDATED'                           @M3A\n  DFHTUTEN     C=(FF,FF),K=                                        @M3A\nTUTB2C6G EQU  *                    XRSP - ID MODIFIER              @M3A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT                   @M3A\n  DFHTUTEN     C=(80),K='IMPLICIT'                                 @M3A\n  DFHTUTEN     C=(FF,FF),K=                                        @M3A\nTUTB2C6H EQU  *                    XRSP - ID MODIFIER              @M3A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT                   @M3A\n  DFHTUTEN     C=(40),K='DUMP=YES'                                 @M3A\n  DFHTUTEN     C=(FF,FF),K=                                        @M3A\n*                                                                     *\nTUTB2C7E EQU   *                   XRP                             @M2A\n  DFHTUTEN     T=(2,I),CP=CLC,OFF=A0,E=DFT,NX=SRT                  @M2A\n  DFHTUTEN     C=(01,00),K='INITIALIZE'                            @M2A\n  DFHTUTEN     C=(02,00),K='TERMINATE'                             @M2A\n  DFHTUTEN     C=(03,00),K='SIGNON'                                @M2A\n  DFHTUTEN     C=(04,00),K='SIGNOFF'                               @M2A\n  DFHTUTEN     C=(05,00),K='QUERY-TAKEOVER-INIT'                   @M2A\n  DFHTUTEN     C=(06,00),K='SET-TAKEOVER-INIT'                     @M2A\n  DFHTUTEN     C=(07,00),K='WAIT-TAKEOVER-INIT'                    @M2A\n  DFHTUTEN     C=(08,00),K='QUERY-TAKEOVER-COMP'                   @M2A\n  DFHTUTEN     C=(09,00),K='SET-TAKEOVER-COMP'                     @M2A\n  DFHTUTEN     C=(0A,00),K='WAIT-TAKEOVER-COMP'                    @M2A\n  DFHTUTEN     C=(0B,00),K='QUERY-RSD-AVAIL'                       @M2A\n  DFHTUTEN     C=(0C,00),K='SET-RSD-AVAIL'                         @M2A\n  DFHTUTEN     C=(0D,00),K='WAIT-RSD-AVAIL'                        @M2A\n  DFHTUTEN     C=(0E,00),K='QUERY-SYNC-SIGNOFF'                    @M2A\n  DFHTUTEN     C=(0F,00),K='SET-SYNC-SIGNOFF'                      @M2A\n  DFHTUTEN     C=(10,00),K='WAIT-SYNC-SIGNOFF'                     @M2A\n  DFHTUTEN     C=(11,00),K='QUERY-SYNC-TERM'                       @M2A\n  DFHTUTEN     C=(12,00),K='SET-SYNC-TERM'                         @M2A\n  DFHTUTEN     C=(13,00),K='WAIT-SYNC-TERM'                        @M2A\n  DFHTUTEN     C=(18,00),K='INIT-SURVEILLANCE'                     @M2A\n  DFHTUTEN     C=(19,00),K='TERM-SURVEILLANCE'                     @M2A\n  DFHTUTEN     C=(1A,00),K='INIT-CONSOLE-COMM'                     @M2A\n  DFHTUTEN     C=(1B,00),K='TERM-CONSOLE-COMM'                     @M2A\n  DFHTUTEN     C=(1C,00),K='SET-HEALTH-DATA'                       @M2A\n  DFHTUTEN     C=(FF,FF),K=                                        @M2A\n*                                                                     *\nTUTB2C7R EQU   *                   XRP RETURN - I                  @M2A\n  DFHTUTEN     T=(2,I),CP=CLC,OFF=A0,E=DFT,NX=C7S                  @M2A\n  DFHTUTEN     C=(01,00),K='INITIALIZE'                            @M2A\n  DFHTUTEN     C=(02,00),K='TERMINATE'                             @M2A\n  DFHTUTEN     C=(03,00),K='SIGNON'                                @M2A\n  DFHTUTEN     C=(04,00),K='SIGNOFF'                               @M2A\n  DFHTUTEN     C=(05,00),K='QUERY-TAKEOVER-INIT'                   @M2A\n  DFHTUTEN     C=(06,00),K='SET-TAKEOVER-INIT'                     @M2A\n  DFHTUTEN     C=(07,00),K='WAIT-TAKEOVER-INIT'                    @M2A\n  DFHTUTEN     C=(08,00),K='QUERY-TAKEOVER-COMP'                   @M2A\n  DFHTUTEN     C=(09,00),K='SET-TAKEOVER-COMP'                     @M2A\n  DFHTUTEN     C=(0A,00),K='WAIT-TAKEOVER-COMP'                    @M2A\n  DFHTUTEN     C=(0B,00),K='QUERY-RSD-AVAIL'                       @M2A\n  DFHTUTEN     C=(0C,00),K='SET-RSD-AVAIL'                         @M2A\n  DFHTUTEN     C=(0D,00),K='WAIT-RSD-AVAIL'                        @M2A\n  DFHTUTEN     C=(0E,00),K='QUERY-SYNC-SIGNOFF'                    @M2A\n  DFHTUTEN     C=(0F,00),K='SET-SYNC-SIGNOFF'                      @M2A\n  DFHTUTEN     C=(10,00),K='WAIT-SYNC-SIGNOFF'                     @M2A\n  DFHTUTEN     C=(11,00),K='QUERY-SYNC-TERM'                       @M2A\n  DFHTUTEN     C=(12,00),K='SET-SYNC-TERM'                         @M2A\n  DFHTUTEN     C=(13,00),K='WAIT-SYNC-TERM'                        @M2A\n  DFHTUTEN     C=(18,00),K='INIT-SURVEILLANCE'                     @M2A\n  DFHTUTEN     C=(19,00),K='TERM-SURVEILLANCE'                     @M2A\n  DFHTUTEN     C=(1A,00),K='INIT-CONSOLE-COMM'                     @M2A\n  DFHTUTEN     C=(1B,00),K='TERM-CONSOLE-COMM'                     @M2A\n  DFHTUTEN     C=(1C,00),K='SET-HEALTH-DATA'                       @M2A\n  DFHTUTEN     C=(FF,FF),K=                                        @M2A\n*                                                                     *\nTUTB2C7S EQU   *                   XRP RETURN - II                 @M2A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A3,E=DFT,NX=SRT                  @M2A\n  DFHTUTEN     C=(00,00),K='NORMAL'                                @M2A\n  DFHTUTEN     C=(08,00),K='INVALID REQUEST'                       @M2A\n  DFHTUTEN     C=(14,00),K='FAILED RETRY POSSIBLE'                 @M2A\n  DFHTUTEN     C=(1C,00),K='REJECTED BY CAVM'                      @M2A\n  DFHTUTEN     C=(24,00),K='DUMP=YES SPECIFIED'                    @M2A\n  DFHTUTEN     C=(2C,00),K='REJECTED BY CAVM'                      @M2A\n  DFHTUTEN     C=(34,00),K='TAKEOVER IN PROGRESS'                  @M2A\n  DFHTUTEN     C=(35,00),K='SHUTDOWN IN PROGRESS'                  @M2A\n  DFHTUTEN     C=(3C,00),K='REJECTED BY CAVM'                      @M2A\n  DFHTUTEN     C=(44,00),K='RSD NOT AVAILABLE'                     @M2A\n  DFHTUTEN     C=(FF,FF),K=                                        @M2A\n*                                                                     *\nTUTB2C8D EQU   *                                               @BD910JY\n*                                                              @BA55868\nTUTB2C9D EQU   *                                               @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=B0,E=DFT,NX=C9F\n  DFHTUTEN     C=(80,00),K='1WD'                               @BD910JY\n  DFHTUTEN     C=(81,00),K='DCA'                               @BD910JY\n  DFHTUTEN     C=(82,00),K='QEA'                               @BD910JY\n  DFHTUTEN     C=(83,00),K='TQA'                               @BD910JY\n  DFHTUTEN     C=(84,00),K='LINE'                              @BD910JY\n  DFHTUTEN     C=(85,00),K='TERMINAL'                          @BD910JY\n  DFHTUTEN     C=(86,00),K='ICE'                               @BD910JY\n  DFHTUTEN     C=(87,00),K='AID'                               @BD910JY\n  DFHTUTEN     C=(88,00),K='PGM'                               @BD910JY\n  DFHTUTEN     C=(89,00),K='RSA'                               @BD910JY\n  DFHTUTEN     C=(8A,00),K='TCA'                               @BD910JY\n  DFHTUTEN     C=(8B,00),K='LLA'                               @BD910JY\n  DFHTUTEN     C=(8C,00),K='USER'                              @BD910JY\n  DFHTUTEN     C=(8D,00),K='TRANSDATA'                         @BD910JY\n  DFHTUTEN     C=(8E,00),K='TEMPSTRG'                          @BD910JY\n  DFHTUTEN     C=(8F,00),K='FILE'                              @BD910JY\n  DFHTUTEN     C=(90,00),K='RPL'                               @BD910JY\n  DFHTUTEN     C=(91,00),K='COMMAREA'                          @BACOM01\n  DFHTUTEN     C=(92,00),K='BCA'                               @BD910JY\n  DFHTUTEN     C=(93,00),K='SHARED'                            @BD910JY\n  DFHTUTEN     C=(94,00),K='CONTROL'                           @BD910JY\n  DFHTUTEN     C=(95,00),K='??'                                @BD910JY\n  DFHTUTEN     C=(96,00),K='TACLE'                             @BD910JY\n  DFHTUTEN     C=(97,00),K='TSMAIN'                            @BD910JY\n  DFHTUTEN     C=(98,00),K='TSTABLE'                           @BD910JY\n  DFHTUTEN     C=(99,00),K='MAP'                               @BD910JY\n  DFHTUTEN     C=(9A,00),K='PERMANENT'                      @EU71B @L3C\n  DFHTUTEN     C=(9B,00),K='JCA'                               @BD910JY\n  DFHTUTEN     C=(9C,00),K='EXTENDED'                       @EG01X @L5C\n  DFHTUTEN     C=(9D,00),K='DWE'                               @BD910JY\n  DFHTUTEN     C=(9E,00),K='MAPCOPY'                           @BD910JY\n  DFHTUTEN     C=(9F,00),K='DL/I'                              @BD910JY\n  DFHTUTEN     C=(00,00),K='** REQUEST FAILED **'              @BM10378\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\nTUTB2C9F EQU   *\n  DFHTUTEN     T=(2,I),CP=TM,OFF=B0,E=DFT,NX=SRT\n  DFHTUTEN     C=(80,00),K='STORAGE'\n  DFHTUTEN     C=(FF,FF),K=\n*                                                                     *\nTUTB2CCD EQU   *                   CCP                             @LLA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT                  @LLP\n  DFHTUTEN     C=(01,00),K='OPEN'                                  @LLA\n  DFHTUTEN     C=(02,00),K='CLOSE'                                 @LLA\n  DFHTUTEN     C=(03,00),K='CONNECT'                               @LLA\n  DFHTUTEN     C=(04,00),K='DISCONNECT'                            @LLA\n  DFHTUTEN     C=(05,00),K='STARTBROWSE'                           @LLA\n  DFHTUTEN     C=(06,00),K='ENDBROWSE'                             @LLA\n  DFHTUTEN     C=(07,00),K='GETNEXT'                               @LLA\n  DFHTUTEN     C=(08,00),K='WRITE'                                 @LLA\n  DFHTUTEN     C=(09,00),K='READ'                                  @LLA\n  DFHTUTEN     C=(0A,00),K='DELETE'                                @LLA\n  DFHTUTEN     C=(0B,00),K='PURGE'                                 @LLA\n  DFHTUTEN     C=(FF,FF),K=                                        @LLP\n*                                                                     *\nTUTB2CCR EQU   *                   CCP RETURN                      @LLA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A3,E=DFT,NX=SRT                  @LLP\n  DFHTUTEN     C=(00),K='NORMAL'                                   @LLP\n  DFHTUTEN     C=(04),K='NOT FOUND'                                @LLA\n  DFHTUTEN     C=(06),K='LENGTH ERROR'                             @LLA\n  DFHTUTEN     C=(08),K='DUPLICATE'                                @LLA\n  DFHTUTEN     C=(0C),K='INVALID REQUEST'                          @LLA\n  DFHTUTEN     C=(10),K='DISASTER'                                 @LLA\n  DFHTUTEN     C=(FF,FF),K=                                        @LLP\n*                                                                     *\nTUTB2CED EQU   *                   RCP                             @LLA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT                  @LLP\n  DFHTUTEN     C=(01,00),K='OPEN'                                  @LLA\n  DFHTUTEN     C=(02,00),K='CLOSE'                                 @LLA\n  DFHTUTEN     C=(03,00),K='CONNECT'                               @LLA\n  DFHTUTEN     C=(04,00),K='DISCONNECT'                            @LLA\n  DFHTUTEN     C=(05,00),K='STARTBROWSE'                           @LLA\n  DFHTUTEN     C=(06,00),K='ENDBROWSE'                             @LLA\n  DFHTUTEN     C=(07,00),K='GETNEXT'                               @LLA\n  DFHTUTEN     C=(08,00),K='WRITE'                                 @LLA\n  DFHTUTEN     C=(09,00),K='READ'                                  @LLA\n  DFHTUTEN     C=(0A,00),K='DELETE'                                @LLA\n  DFHTUTEN     C=(0B,00),K='PURGE'                                 @LLA\n  DFHTUTEN     C=(0C,00),K='LOG'                                   @LLA\n  DFHTUTEN     C=(0D,00),K='INITIALIZE'                            @LLA\n  DFHTUTEN     C=(0E,00),K='WAITINIT'                              @LLA\n  DFHTUTEN     C=(0F,00),K='RESTART'                               @LLA\n  DFHTUTEN     C=(FF,FF),K=                                        @LLP\n*                                                                     *\nTUTB2CER EQU   *                   RCP RETURN                      @LLA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A3,E=DFT,NX=SRT                  @LLP\n  DFHTUTEN     C=(00),K='NORMAL'                                   @LLP\n  DFHTUTEN     C=(04),K='NOT FOUND'                                @LLA\n  DFHTUTEN     C=(06),K='LENGTH ERROR'                             @LLA\n  DFHTUTEN     C=(08),K='DUPLICATE'                                @LLA\n  DFHTUTEN     C=(0C),K='INVALID REQUEST'                          @LLA\n  DFHTUTEN     C=(0E),K='WARNING ISSUED'                           @LLA\n  DFHTUTEN     C=(10),K='DISASTER'                                 @LLA\n  DFHTUTEN     C=(FF,FF),K=                                        @LLP\n*                                                                     *\nTUTB2CFD EQU   *                   BMS RESPONSE\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=CFE\n  DFHTUTEN     C=(80,00),K='ROUTE FAILED'\n  DFHTUTEN     C=(40,00),K='ROUTE WORKED FOR SOME'\n  DFHTUTEN     C=(20,00),K='INVALID ERROR TERMINAL'\n* DFHTUTEN     C=(10,00),K='STORAGE'\n  DFHTUTEN     C=(08,00),K='MAP TOO LARGE'\n  DFHTUTEN     C=(04,00),K='CANNOT MAP I/O AREA'\n  DFHTUTEN     C=(02,00),K='PAGE RETURNED'\n  DFHTUTEN     C=(01,00),K='INVALID REQUEST'\n  DFHTUTEN     C=(FF,FF),K=\nTUTB2CFE EQU   *\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=CFF\n  DFHTUTEN     C=(80,00),K='TEMPORARY STORAGE I/O ERROR'\n  DFHTUTEN     C=(20,00),K='UNEXPECTED DIP INPUT RCVD'\n  DFHTUTEN     C=(10,00),K='INVALID LDC MNEMONIC'\n  DFHTUTEN     C=(08,00),K='INVALID PARTITION SET'          @E5E2C @H1C\n  DFHTUTEN     C=(04,00),K='INVALID PARTITION'              @E5E2C @H1C\n  DFHTUTEN     C=(02,00),K='PARTITION FAIL'                 @E5E2C @H1C\n  DFHTUTEN     C=(FF,FF),K=\nTUTB2CFF EQU   *\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT\n  DFHTUTEN     C=(10,00),K='SPECIFIED REQID IGNORED'\n  DFHTUTEN     C=(08,00),K='END OF CHAIN'\n  DFHTUTEN     C=(04,00),K='END OF DATA SET'\n  DFHTUTEN     C=(02,00),K='INBOUND FMH'                       @BM10771\n  DFHTUTEN     C=(01,00),K='PAGEBLD OVERFLOW'\n  DFHTUTEN     C=(FF,FF),K=\n*                                                                     *\nTUTB2D0D EQU   *                   KCP AUX                     @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT\n  DFHTUTEN     C=(05,00),K='DISPATCH '                         @BD910JY\n  DFHTUTEN     C=(06,00),K='CREATE'                            @BD910JY\n  DFHTUTEN     C=(07,00),K='TERMINATE'                         @BD910JY\n  DFHTUTEN     C=(08,00),K='SYSTEM WAIT'                       @BD910JY\n  DFHTUTEN     C=(09,00),K='SYSTEM RESUME'                     @BBDIA0Y\n  DFHTUTEN     C=(0A,00),K='SUSPEND'                           @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2D2D EQU   *                   VCP                      @E211Q @L7A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT           @E211Q @L7P\n  DFHTUTEN     C=(00),K='LOCATE VOLUME'                     @E211Q @L7A\n  DFHTUTEN     C=(01),K='CREATE TABLES'                     @E211Q @L7A\n  DFHTUTEN     C=(02),K='INSERT SERIES'                     @E211Q @L7A\n  DFHTUTEN     C=(03),K='LOCATE SERIES'                     @E211Q @L7A\n  DFHTUTEN     C=(04),K='READ KEYPOINT RECDS'               @E211Q @L7A\n  DFHTUTEN     C=(05),K='BUILD KEYPOINT RECDS'              @E211Q @L7A\n  DFHTUTEN     C=(07),K='READ USERLABEL'                    @E211Q @L7A\n  DFHTUTEN     C=(08),K='BUILD USERLABEL'                   @E211Q @L7A\n  DFHTUTEN     C=(09),K='TALLY'                             @E211Q @L7A\n  DFHTUTEN     C=(0A),K='WARN'                              @E211Q @L7A\n  DFHTUTEN     C=(0B),K='WRITE DESCRIPTOR'                  @E211Q @L7A\n  DFHTUTEN     C=(0C),K='DELETE DESCRIPTOR'                 @E211Q @L7A\n  DFHTUTEN     C=(0D),K='ADD VOLUME'                        @E211Q @L7C\n  DFHTUTEN     C=(0E),K='ADD VOLUME, LIFO'                  @E211Q @L7A\n  DFHTUTEN     C=(11),K='SET CLOSE FAILURE'                 @E211Q @L7A\n  DFHTUTEN     C=(12),K='SET OPEN FAILURE'                  @E211Q @L7A\n  DFHTUTEN     C=(13),K='SET INPUT FAILURE'                 @E211Q @L7A\n  DFHTUTEN     C=(14),K='SET OUTPUT FAILURE'                @E211Q @L7A\n  DFHTUTEN     C=(15),K='SET READ-ONLY'                     @E211Q @L7A\n  DFHTUTEN     C=(17),K='SET GOOD'                          @E211Q @L7A\n  DFHTUTEN     C=(1D),K='SET CLOSED'                        @E211Q @L7A\n  DFHTUTEN     C=(1E),K='SET PENDING'                       @E211Q @L7A\n  DFHTUTEN     C=(1F),K='SET OPEN'                          @E211Q @L7A\n  DFHTUTEN     C=(20),K='PRIME A JFCB'                      @E211Q @L7A\n  DFHTUTEN     C=(21),K='VOLID FROM JFCB'                   @E211Q @L7A\n  DFHTUTEN     C=(22),K='BUILD NOTE'                        @E211Q @L7A\n  DFHTUTEN     C=(3E),K='FILL JFCB && SET PENDING'  OCCURS IN DFHJCO   F\n                                                            @E211Q @L7C\n  DFHTUTEN     C=(40),K='MAKE CURRENT'                      @E211Q @L7A\n  DFHTUTEN     C=(5F),K='SET CURRENT+OPEN' IN DFHJCO ONLY.  @E211Q @L7C\n  DFHTUTEN     C=(FF,FF),K=                                        @LMC\n*                                                                     *\nTUTB2D2R EQU   *                   VCP RETURN               @E211Q @L7A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT           @E211Q @L7A\n  DFHTUTEN     C=(00),K='NORMAL'                            @E211Q @L7A\n  DFHTUTEN     C=(20),K='SERIES IS SHORT'                   @E211Q @L7A\n  DFHTUTEN     C=(21),K='DONE PARTLY'                       @E211Q @L7A\n  DFHTUTEN     C=(22),K='NO OPERATOR REPLY'                 @E211Q @L7A\n  DFHTUTEN     C=(40),K='CONFLICT'                          @E211Q @L7A\n  DFHTUTEN     C=(41),K='SERIES NOT FOUND'                  @E211Q @L7A\n  DFHTUTEN     C=(43),K='VOLUME NOT FOUND'                  @E211Q @L7A\n  DFHTUTEN     C=(45),K='VOLUME IS REUSED'                  @E211Q @L7A\n  DFHTUTEN     C=(46),K='BAD DATA'                          @E211Q @L7A\n  DFHTUTEN     C=(80),K='INVALID REQ'                       @E211Q @L7A\n  DFHTUTEN     C=(FF,FF),K=                                 @E211Q @L7A\n*                                                                     *\nTUTB2D3D EQU   *                   LUP                      @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT           @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2D5D EQU   *                   UEH                         @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBDIA0Y\n  DFHTUTEN     C=(01,FF),K='BEFORE'                            @BBDIA0Y\n  DFHTUTEN     C=(02,FF),K='AFTER'                             @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2D6D EQU   *                   ALP                         @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBDIA0Y\n  DFHTUTEN     C=(01,00),K='UNCHAIN'                           @BBDIA0Y\n  DFHTUTEN     C=(02,00),K='TPQ CALL 2'                        @BBDI80O\n  DFHTUTEN     C=(03,00),K='LOCATE'                                @LMC\n  DFHTUTEN     C=(04,00),K='DELETE_AIDS'                       @BA29217\n  DFHTUTEN     C=(05,00),K='TPR CALL 2'                        @BBDI80O\n  DFHTUTEN     C=(06,00),K='CRS CALL 1'                        @BBDI80O\n  DFHTUTEN     C=(07,00),K='CRS CALL 2'                        @BBDI80O\n  DFHTUTEN     C=(08,00),K='ICP CALL 1'                        @BBDI80O\n  DFHTUTEN     C=(09,00),K='ICP CALL 2'                        @BBDI80O\n  DFHTUTEN     C=(0A,00),K='TPQ CALL 1'                            @LMC\n  DFHTUTEN     C=(0C,00),K='TPQ CALL 3'                            @LMA\n  DFHTUTEN     C=(0D,00),K='TPR CALL 1'                            @LMA\n  DFHTUTEN     C=(0E,00),K='CRQ CALL 1'                            @LMA\n  DFHTUTEN     C=(12,00),K='SCHEDULE'                          @BBDI80O\n  DFHTUTEN     C=(14,00),K='AVAIL'                             @BBDI80O\n  DFHTUTEN     C=(15,00),K='UNAVAIL'                           @BBDI80O\n  DFHTUTEN     C=(16,00),K='RELEASE'                           @BBDI80O\n  DFHTUTEN     C=(17,00),K='ALLOCATE'                              @02A\n  DFHTUTEN     C=(18,00),K='RELEASE_ABNORMAL'                      @04A\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDI80O\n*                                                                     *\nTUTB2D6R EQU   *                   ALP RETURN                  @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBDIA0Y\n  DFHTUTEN     C=(00,00),K='NORMAL'                            @BM13334\n  DFHTUTEN     C=(04,00),K='ERROR'                             @BM13334\n  DFHTUTEN     C=(0C,00),K='ERROR'                             @BM13334\n  DFHTUTEN     C=(31,00),K='ERROR'                             @BM13334\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2D7D EQU   *                   DIP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BM10857\n  DFHTUTEN     C=(01,00),K='ADD',NX=D7F                        @BM10857\n  DFHTUTEN     C=(02,00),K='ERASE',NX=D7F                      @BM10857\n  DFHTUTEN     C=(03,00),K='REPLACE',NX=D7F                    @BM10857\n  DFHTUTEN     C=(04,00),K='ABORT',NX=D7F                      @BM10857\n  DFHTUTEN     C=(05,00),K='QUERY',NX=D7F                      @BM10857\n  DFHTUTEN     C=(06,00),K='END',NX=D7F                        @BM10857\n  DFHTUTEN     C=(07,00),K='RECEIVE',NX=D7F                    @BM10857\n  DFHTUTEN     C=(08,00),K='NOTE',NX=D7F                       @BM10857\n  DFHTUTEN     C=(09,00),K='DETACH',NX=D7F                     @BM10857\n  DFHTUTEN     C=(0A,00),K='ATTACH',NX=D7F                     @BM10857\n  DFHTUTEN     C=(0B,00),K='SEND',NX=D7F                       @BM10857\n  DFHTUTEN     C=(0C,00),K='WAIT',NX=SRT                       @BM10857\n  DFHTUTEN     C=(FF,00),K='RESPONSE',NX=SRT                   @BM10857\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\nTUTB2D7F EQU   *\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=SRT\n  DFHTUTEN     C=(80),K='DEFRESP'\n  DFHTUTEN     C=(40),K='SAVE'\n  DFHTUTEN     C=(20),K='KEYADDR'\n  DFHTUTEN     C=(10),K='RRNADDR'\n  DFHTUTEN     C=(08),K='KEYNUMB'                           @E963C @H3C\n  DFHTUTEN     C=(01),K='WAIT'\n  DFHTUTEN     C=(FF,FF),K=\n*                                                                     *\nTUTB2D7R EQU   *                   DIP RETURN                  @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=SRT              @BM10857\n  DFHTUTEN     C=(00,00),K='NORMAL'                            @BBCI70Y\n  DFHTUTEN     C=(01,00),K='BEGIN'                             @BBCI70Y\n  DFHTUTEN     C=(02,00),K='RESUME'                            @BBCI70Y\n  DFHTUTEN     C=(11,00),K='END'                               @BBCI70Y\n  DFHTUTEN     C=(12,00),K='SUSPEND'                           @BBCI70Y\n  DFHTUTEN     C=(13,00),K='ABORT'                             @BBCI70Y\n  DFHTUTEN     C=(14,00),K='ABORT'                             @BBCI70Y\n  DFHTUTEN     C=(15,00),K=' '                                 @BBCI70Y\n  DFHTUTEN     C=(21,00),K='INVALID'                           @BBCI70Y\n  DFHTUTEN     C=(22,00),K='RECLEN'                            @BBCI70Y\n  DFHTUTEN     C=(23,00),K='DS FULL'                           @BBCI70Y\n  DFHTUTEN     C=(24,00),K='INVALID KEY/REC'                   @BBCI70Y\n  DFHTUTEN     C=(25,00),K='NOT AVAILABLE'                     @BBCI70Y\n  DFHTUTEN     C=(26,00),K='INVALID NUMREC'                    @BBCI70Y\n  DFHTUTEN     C=(28,00),K='INSUFFICIENT RES'                  @BBCI70Y\n  DFHTUTEN     C=(29,00),K='DS NOT FOUND'                      @BBCI70Y\n  DFHTUTEN     C=(2A,00),K='DS EXISTS'                         @BBCI70Y\n  DFHTUTEN     C=(2B,00),K='IGREQCD ERR'                       @BBC5G0L\n  DFHTUTEN     C=(2C,00),K='LUSTAT NO DATA'                    @BBCI70Y\n  DFHTUTEN     C=(41,00),K='NO DEST'                           @BBCI70Y\n  DFHTUTEN     C=(42,00),K='DEST BUSY'                         @BBCI70Y\n  DFHTUTEN     C=(43,00),K='MEDIA NOT SUPPORTED'               @BBCI70Y\n  DFHTUTEN     C=(44,00),K='INVALID DEST NAME'                 @BBCI70Y\n  DFHTUTEN     C=(45,00),K='INVALID VOLUME'                    @BBCI70Y\n  DFHTUTEN     C=(46,00),K='VOLUME LEN ERR'                    @BBCI70Y\n  DFHTUTEN     C=(47,00),K='TRANSMIT DS ACTIVE'                @BBCI70Y\n  DFHTUTEN     C=(48,00),K='DS ACTIVE'                         @BBCI70Y\n  DFHTUTEN     C=(60,00),K='TD ERROR'                          @BBCI70Y\n  DFHTUTEN     C=(F1,00),K='UNEXP SENSE'                       @BBCI70Y\n  DFHTUTEN     C=(F2,00),K='UNEXP FMH'                         @BBCI70Y\n  DFHTUTEN     C=(F3,00),K='UNSUP INPUT'                       @BBCI70Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2D8D EQU   *                   SPP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT                  @P8C\n  DFHTUTEN     C=(01,00),K='USER'                              @BD910JY\n  DFHTUTEN     C=(02,00),K='SYSTEM'                            @BD910JY\n  DFHTUTEN     C=(09,00),K='ROLLBACK'                          @BBAI20Y\n  DFHTUTEN     C=(10,00),K='RESYNC REQUEST'                        @P8A\n  DFHTUTEN     C=(20,00),K='LUC',NX=D8Z                            @P8A\n  DFHTUTEN     C=(60,00),K='LUC SEND-PREPARE'                      @P8A\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\nTUTB2D8Z EQU   *                                                   @P8A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=SRT                  @P8A\n  DFHTUTEN     C=(01,00),K='BIS (INBOUND)'                         @P8A\n  DFHTUTEN     C=(02,00),K='UNBIND'                                @P8A\n  DFHTUTEN     C=(04,00),K='RESYNC'                                @P8A\n  DFHTUTEN     C=(08,00),K='EXCHANGE LOG NAMES RECEIVED'           @P8A\n  DFHTUTEN     C=(10,00),K='CONTACT'                               @P8A\n  DFHTUTEN     C=(20,00),K='QPEND'                                 @P8A\n  DFHTUTEN     C=(40,00),K='CLPEND'                                @P8A\n  DFHTUTEN     C=(FF,FF),K=                                        @P8A\n*                                                                     *\n*TUTB2D9D EQU   TUTB2E1D      XFP SAME AS EIP                  @BD910JY\n*    COPY EIP TRACE                                            @BBAI20Y\n*                                                                     *\nTUTB2DAD EQU   *                   STATS                       @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAA12Y\n* DFHTUTEN     C=(01,00),K='USER'                              @BD910JY\n* DFHTUTEN     C=(02,00),K='SYSTEM'                            @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2DBD EQU   *                   XTP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BBDJ20B\n  DFHTUTEN     C=(00,00),K='XFORM1'                            @BBDJ20B\n  DFHTUTEN     C=(02,00),K='XFORM2'                            @BBDJ20B\n  DFHTUTEN     C=(04,00),K='XFORM3'                            @BBDJ20B\n  DFHTUTEN     C=(06,00),K='XFORM4'                            @BBDJ20B\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDJ20B\n*                                                                     *\nTUTB2DCD EQU   *                   ACP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAA12Y\n* DFHTUTEN     C=(01,00),K='USER'                              @BD910JY\n* DFHTUTEN     C=(02,00),K='SYSTEM'                            @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2DDD EQU   *                   IRC                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBDIA0Y\n  DFHTUTEN     C=(00),K='RESUME'                               @BBDIA0Y\n  DFHTUTEN     C=(01),K='CONNECT'                              @BBDIA0Y\n  DFHTUTEN     C=(02),K='IN',NX=DD0                            @BBCIA0Y\n  DFHTUTEN     C=(03),K='INBOUND DATA'                         @BBDIA0Y\n  DFHTUTEN     C=(04),K='OUTB',NX=DD0                          @BBDIA0Y\n  DFHTUTEN     C=(05),K='OUTBOUND DATA'                        @BBDIA0Y\n  DFHTUTEN     C=(06),K='BATCH NAME'                           @BBDIA0Y\n  DFHTUTEN     C=(07),K='NAME CONTINUED'                       @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*  FIELD A0 - A1 SEQ NUMBER                                           *\nTUTB2DD0 EQU   *                                               @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=DD1               @BBDIA0Y\n  DFHTUTEN     C=(80),K='RESP'                                 @BBDIA0Y\n  DFHTUTEN     C=(40),K=' '                                    @BBDIA0Y\n  DFHTUTEN     C=(20),K=' '                                    @BBDIA0Y\n***   DFHTUTEN     C=(10),K='FMH'              DELETED BY APAR @BA47382\n  DFHTUTEN     C=(08),K='FMH'                                  @BA47382\n  DFHTUTEN     C=(04),K='SENSE'                                @BBDIA0Y\n  DFHTUTEN     C=(02),K='BC'                                   @BBDIA0Y\n  DFHTUTEN     C=(01),K='EC'                                   @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\nTUTB2DD1 EQU   *                                               @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DD2,NX=DD2               @BBDIA0Y\n  DFHTUTEN     C=(80),K='RQD1'                                 @BBDIA0Y\n  DFHTUTEN     C=(40),K='RQE1'                                 @BBDIA0Y\n  DFHTUTEN     C=(20),K='RQD2'                                 @BBDIA0Y\n  DFHTUTEN     C=(10),K='RQE2'                                 @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\nTUTB2DD2 EQU   *                                               @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=B0,E=DFT,NX=SRT               @BBDIA0Y\n  DFHTUTEN     C=(80),K='BB'                                   @BBDIA0Y\n  DFHTUTEN     C=(40),K='EB'                                   @BBDIA0Y\n  DFHTUTEN     C=(20),K='CD'                                   @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2DED EQU   *                   SKP                             @LIA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT                  @LIA\n  DFHTUTEN     C=(01,00),K='PERFORM'                               @LIA\n  DFHTUTEN     C=(02,00),K='WAIT'                                  @LIA\n  DFHTUTEN     C=(03,00),K='RETURN'                                @LIA\n  DFHTUTEN     C=(04,00),K='TERMINATE'                             @LIA\n  DFHTUTEN     C=(05,00),K='DWE PROCESS'                           @LIA\n  DFHTUTEN     C=(FF,FF),K=                                        @LIA\n*                                                                     *\nTUTB2DER EQU   *                   SKP RETURN                      @LIA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A3,E=DFT,NX=SRT                  @LIA\n  DFHTUTEN     C=(00),K='NORMAL'                                   @LIA\n  DFHTUTEN     C=(04),K='USER CODE FAILED'                         @LIA\n  DFHTUTEN     C=(08),K='SUBTASK CODE FAILED'                      @LIA\n  DFHTUTEN     C=(0C),K='UNABLE TO PERFORM REQUEST'                @LIA\n  DFHTUTEN     C=(10),K='REQUEST NEVER COMPLETED'                  @LIA\n  DFHTUTEN     C=(14),K='INVALID REQUEST'                          @LIA\n  DFHTUTEN     C=(18),K='INVALID ECB ADDRESS'                      @LIA\n  DFHTUTEN     C=(1C),K='USER TASK WAS CANCELLED'                  @LIA\n  DFHTUTEN     C=(FF,FF),K=                                        @LIA\n*                                                                     *\nTUTB2DFD EQU   *                   ISP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(01,00),K='RECEIVE'                           @BBAI20Y\n  DFHTUTEN     C=(02,00),K='ATTACH'                            @BBAI20Y\n  DFHTUTEN     C=(03,00),K='SHUTDOWN'                          @BBAI20Y\n  DFHTUTEN     C=(04,00),K='CONVERSE',NX=DFF                   @BBAI20Y\n  DFHTUTEN     C=(05,00),K='I/O REQ',NX=DFF                    @BBAI20Y\n  DFHTUTEN     C=(06,00),K='INITIALIZE'                            @LMC\n  DFHTUTEN     C=(07,00),K='ABEND'                             @BBAI20Y\n  DFHTUTEN     C=(08,00),K='IRC STOP'                          @BBAI20Y\n  DFHTUTEN     C=(09,00),K='IRC STOP IMMED'                    @BBAI20Y\n  DFHTUTEN     C=(0A,00),K='IRC LOGOFF'                        @BBAI20Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\nTUTB2DFF EQU   *                                               @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT               @BBAI20Y\n  DFHTUTEN     C=(80,00),K='WRITE'                             @BBAI20Y\n  DFHTUTEN     C=(40,00),K='WAIT'                              @BBAI20Y\n  DFHTUTEN     C=(20,00),K='READ'                              @BBAI20Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\n*                                                                     *\nTUTB2E0D EQU   *                   MGP                         @BM10519\n  DFHTUTEN     T=(2,I),CP=2BIN,OFF=A2,E=DFT,NX=E0F             @BM10519\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10519\nTUTB2E0F EQU   *                                               @BM10519\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT               @BM10519\n  DFHTUTEN     C=(80),K='CSMT'                                 @BM10519\n  DFHTUTEN     C=(40),K='CSTL'                                 @BBDIA0Y\n  DFHTUTEN     C=(20),K='TERM'                                 @BBDIA0Y\n  DFHTUTEN     C=(10),K='CONSOLE'                              @BBDIA0Y\n  DFHTUTEN     C=(08),K='RETTIOA'                              @BM13334\n  DFHTUTEN     C=(04),K='NONUM'                                @BBDIA0Y\n  DFHTUTEN     C=(02),K='TIOA'                                 @BBDIA0Y\n  DFHTUTEN     C=(01),K='CSCS'                                 @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2E1D EQU   *                   EIP                         @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLC,OFF=B2,E=DFT,NX=E1E              @BBAI20Y\n         COPY  DFHEITUT            COPY HLL TABLE              @BBAI20Y\n  DFHTUTEN     C=(40,02),K='DL/I SCHEDULE'                     @BBAI20Y\n  DFHTUTEN     C=(40,04),K='DL/I SCHEDULE REPLY'               @BBAI20Y\n  DFHTUTEN     C=(40,06),K='DL/I REPLACE'                      @BBAI20Y\n  DFHTUTEN     C=(40,08),K='DL/I INSERT'                       @BBAI20Y\n  DFHTUTEN     C=(40,0A),K='DL/I DELETE'                       @BBAI20Y\n  DFHTUTEN     C=(40,10),K='DL/I GET UNIQUE'                   @BBAI20Y\n  DFHTUTEN     C=(40,12),K='DL/I GET UNIQUE HOLD'              @BBAI20Y\n  DFHTUTEN     C=(40,14),K='DL/I GET NEXT'                     @BBAI20Y\n  DFHTUTEN     C=(40,16),K='DL/I GET NEXT HOLD'                @BBAI20Y\n  DFHTUTEN     C=(40,18),K='DL/I GET NEXT PARENT'              @BBAI20Y\n  DFHTUTEN     C=(40,1A),K='DL/I GET NEXT PARENT HOLD'         @BBAI20Y\n  DFHTUTEN     C=(40,1C),K='DL/I REPLY WITH DATA'              @BM10416\n  DFHTUTEN     C=(40,1E),K='DL/I REPLY NO DATA'                @BM10416\n  DFHTUTEN     C=(40,20),K='DL/I DEQ'                          @BBAI20Y\n  DFHTUTEN     C=(40,22),K='DL/I DEQ REPLY'                    @BM10416\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\nTUTB2E1E EQU   *                                               @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R1,E=E1C,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(04),K='ENTRY'                                @BBDIA0Y\n  DFHTUTEN     C=(F4),K='RESPONSE'                             @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\n*                                                                     *\nTUTB2E3D EQU   *                   PSP                             @LEA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT                  @LEA\n*  STANDARD SYSTEM ENTRIES ********************************************\n  DFHTUTEN     C=(A0),K='ENTRY'                                    @LEA\n  DFHTUTEN     C=(A1),K='RESPONSE'                                 @LEA\n  DFHTUTEN     C=(A2),K='UNSUPPORTED FUNCTION'                     @LEA\n*  SYSTEM ENTRIES PRODUCED ONLY IF SPECIAL FE OPTION ON ***************\n*  OR IF AN ABNORMAL RESPONSE IS GIVEN ********************************\n  DFHTUTEN     C=(B0),K='DFHPSPCK ENTRY'                           @LEA\n  DFHTUTEN     C=(B1),K='DFHPSPCK INVALID REQUEST'                 @LEA\n  DFHTUTEN     C=(B2),K='DFHPSPCK INTERFACE HALTING'               @LEA\n  DFHTUTEN     C=(B3),K='DFHPSPCK INTERFACE DISABLE'               @LEA\n  DFHTUTEN     C=(B4),K='DFHPSPCK INTERFACE TERMINATE'             @LEA\n  DFHTUTEN     C=(88),K='DFHEPS SPOOLOPEN STANDARD'                @LEA\n  DFHTUTEN     C=(42),K='DFHEPS SPOOLOPEN INPUT'                   @LEA\n  DFHTUTEN     C=(41),K='DFHEPS SPOOLOPEN OUTPUT'                  @LEA\n  DFHTUTEN     C=(40),K='DFHEPS SPOOLOPEN RESPONSE'                @LEA\n  DFHTUTEN     C=(28),K='DFHEPS SPOOLWRITE STANDARD'               @LEA\n  DFHTUTEN     C=(22),K='DFHEPS SPOOLWRITE RESPONSE'               @LEA\n  DFHTUTEN     C=(21),K='DFHEPS SPOOLREAD STANDARD'                @LEA\n  DFHTUTEN     C=(20),K='DFHEPS SPOOLREAD RESPONSE'                @LEA\n  DFHTUTEN     C=(14),K='DFHEPS SPOOLCLOSE PRINT'                  @LEA\n  DFHTUTEN     C=(11),K='DFHEPS SPOOLCLOSE DELETE'                 @LEA\n  DFHTUTEN     C=(10),K='DFHEPS SPOOLCLOSE RESPONSE'               @LEA\n  DFHTUTEN     C=(E0),K='DFHPSPST ENTRY'                           @LEA\n  DFHTUTEN     C=(E1),K='DFHPSPST OPEN INPUT RESPONSE'             @LEA\n  DFHTUTEN     C=(E2),K='DFHPSPST OPEN OUTPUT RESPONSE'            @LEA\n  DFHTUTEN     C=(E3),K='DFHPSPST READ RESPONSE'                   @LEA\n  DFHTUTEN     C=(E4),K='DFHPSPST WRITE RESPONSE'                  @LEA\n  DFHTUTEN     C=(E5),K='DFHPSPST CLOSE RESPONSE'                  @LEA\n  DFHTUTEN     C=(E6),K='DFHPSPST INTERFACE HALTING'               @LEA\n  DFHTUTEN     C=(E7),K='DFHPSPST INVALID REQUEST'                 @LEA\n  DFHTUTEN     C=(E8),K='DFHPSPST INVALID OPEN REQUEST'            @LEA\n  DFHTUTEN     C=(E9),K='DFHPSPST INVALID READ REQUEST'            @LEA\n  DFHTUTEN     C=(EA),K='DFHPSPST INVALID WRITE REQUEST'           @LEA\n  DFHTUTEN     C=(EB),K='DFHPSPST INVALID CLOSE REQUEST'           @LEA\n***********************************************************************\n  DFHTUTEN     C=(FF,FF),K=                                        @LEA\n*                                                                     *\nTUTB2E5D EQU   *                   XSP                         @BM13334\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BM13334\n  DFHTUTEN     C=(00),K='SECURITY INITIAL'                     @BA78016\n  DFHTUTEN     C=(04),K='SECURITY SIGNON + PASSWORD'           @BA78016\n  DFHTUTEN     C=(08),K='SECURITY SIGNON - PASSWORD'           @BA78016\n  DFHTUTEN     C=(0C),K='SECURITY CHECK'                       @BA78016\n  DFHTUTEN     C=(10),K='SECURITY SIGN-OFF'                    @BA78016\n  DFHTUTEN     C=(14),K='SECURITY TIMEOUT VALUE'               @BA78016\n  DFHTUTEN     C=(18),K='SECURITY USERID'                      @BA78016\n  DFHTUTEN     C=(1C),K='SECURITY WAITINIT'                    @BA78016\n  DFHTUTEN     C=(20),K='SECURITY MIN TIME'                    @BA78016\n  DFHTUTEN     C=(24),K='SECURITY BUILD SNTTE'                 @BA78016\n  DFHTUTEN     C=(28),K='SECURITY DELETE SNTTE'                @BA78016\n  DFHTUTEN     C=(2C),K='SECURITY REBUILD'                     @BA78016\n  DFHTUTEN     C=(30),K='SECURITY RESTART TASK'                @BA78016\n  DFHTUTEN     C=(40),K='SHARED SIGNON -',NX=E5E               @BA78016\n  DFHTUTEN     C=(44),K='SHARED SIGNOFF -',NX=E5E              @BA78016\n  DFHTUTEN     C=(48),K='SECURITY ZUTM SIGNON'                 @BA78016\n  DFHTUTEN     C=(4C),K='SECURITY ZUTM SIGNOFF'                @BA78016\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\n*                                                                     *\nTUTB2E5E EQU   *                   XSP TCTTE FIELD             @BA78016\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=B0,E=DFT,NX=SRT              @BA78016\n  DFHTUTEN     C=(01),K='TCTTESNT'                             @BA78016\n  DFHTUTEN     C=(02),K='TCTEIRSN'                             @BA78016\n  DFHTUTEN     C=(03),K='TCTELSNT'                             @BA78016\n  DFHTUTEN     C=(FF,FF),K=                                    @BA78016\n*                                                              @BA78016\nTUTB2E6D EQU   *                   TCP/TACP (BTAM)                 @LRC\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT                  @D2A\n*  FE TRACE ENTRIES FROM TCP ******************************************\n  DFHTUTEN     C=(01),K='LINE SCAN PART 1'                         @D2A\n  DFHTUTEN     C=(02),K='LINE SCAN PART 2'                         @D2A\n  DFHTUTEN     C=(03),K='I/O INITIATION PART 1'                    @D2A\n  DFHTUTEN     C=(04),K='I/O INITIATION PART 2'                    @D2A\n  DFHTUTEN     C=(05),K='EVENT TERMINATION PART 1'                 @D2A\n  DFHTUTEN     C=(06),K='EVENT TERMINATION PART 2'                 @D2A\n  DFHTUTEN     C=(07),K='AUTOPOLL CHANGE'                          @D2A\n  DFHTUTEN     C=(08),K='LOPEN REQUEST PART 1'                 @BA55877\n  DFHTUTEN     C=(09),K='LOPEN REQUEST PART 2'                 @BA55877\n*  SYSTEM TRACE ENTRIES FROM TACP *************************************\n  DFHTUTEN     C=(10),K='LINK TO TEP'                              @LRA\n  DFHTUTEN     C=(20),K='RETURN FROM TEP'                          @LRA\n*              ********************************************************\n  DFHTUTEN     C=(FF,FF),K=                                        @D2A\n*                                                                     *\nTUTB2E7D EQU   *                   EDLI                     @ECB0R @L1A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=B3,E=DFT,NX=SRT           @ECB0R @L1A\n  DFHTUTEN     C=(00,00),K='ENTRY'                          @ECB0R @L1A\n  DFHTUTEN     C=(09,00),K='(RM UNAVAILABLE)'               @ECB0R @L1A\n  DFHTUTEN     C=(0F,00),K='PASSING CONTROL TO RM'          @ECB0R @L1A\n  DFHTUTEN     C=(F0,00),K='REGAINING CONTROL FROM RM'      @ECB0R @L1A\n  DFHTUTEN     C=(FF,00),K='RESPONSE'                       @ECB0R @L1A\n  DFHTUTEN     C=(FF,FF),K=                                 @ECB0R @L1A\n*                                                                     *\nTUTB2EAD EQU   *                   TMP                      @EU71T @L2C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A2,E=DFT,NX=EAE           @EU71T @L2C\n  DFHTUTEN     C=(01),K='PCT'                               @EU71T @L2C\n  DFHTUTEN     C=(02),K='PCTR'                              @EU71T @L2C\n  DFHTUTEN     C=(03),K='PPT'                               @EU71T @L2C\n  DFHTUTEN     C=(04),K='PFT'                               @EU71T @L2C\n  DFHTUTEN     C=(05),K='FCT'                               @EU71T @L2C\n  DFHTUTEN     C=(06),K='DCT'                               @EU71T @L2C\n  DFHTUTEN     C=(07),K='TCTE'                                     @LJA\n  DFHTUTEN     C=(08),K='TCTN'                                     @LJA\n  DFHTUTEN     C=(09),K='TCTS'                                     @LJA\n  DFHTUTEN     C=(FF,FF),K=                                        @LJA\nTUTB2EAE EQU   *                                            @EU71J @L4C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT           @EU71T @L2C\n  DFHTUTEN     C=(01),K='LOCATE'                            @EU71T @L2C\n  DFHTUTEN     C=(02),K='GETNEXT'                           @EU71T @L2C\n  DFHTUTEN     C=(03),K='GETALIAS'                          @EU71T @L2C\n  DFHTUTEN     C=(04),K='ADD'                               @EU71T @L2C\n  DFHTUTEN     C=(05),K='DELETE'                            @EU71T @L2C\n  DFHTUTEN     C=(06),K='ALIAS'                             @EU71T @L2C\n  DFHTUTEN     C=(07),K='LOCK'                              @EU71T @L2C\n  DFHTUTEN     C=(08),K='UNLOCK'                            @EU71T @L2C\n  DFHTUTEN     C=(09),K='CREATE'                            @EU71T @L2C\n  DFHTUTEN     C=(0A),K='INDEX'                             @EU71T @L2C\n  DFHTUTEN     C=(0B),K='QUIESCE'                           @EU71T @L2C\n  DFHTUTEN     C=(0C),K='TRANSFER'                          @EU71T @L2C\n  DFHTUTEN     C=(0D),K='DWE'                               @EU71T @L2C\n  DFHTUTEN     C=(0E),K='RESET'                             @EU71T @L2C\n  DFHTUTEN     C=(FF,FF),K=                                 @EU71T @L2C\n*                                                                     *\nTUTB2EAR EQU   *                   TMP RETURN               @EU71T @L2C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A3,E=DFT,NX=SRT           @EU71T @L2C\n  DFHTUTEN     C=(00),K='NORMAL'                            @EU71T @L2C\n  DFHTUTEN     C=(04),K='NOT FOUND'                         @EU71T @L2C\n  DFHTUTEN     C=(08),K='DUPLICATE'                         @EU71T @L2C\n  DFHTUTEN     C=(0C),K='INVREQ'                            @EU71T @L2C\n  DFHTUTEN     C=(10),K='ENTRY BUSY'                        @EU71T @L2C\n  DFHTUTEN     C=(14),K='PROTECTED'                         @EU71T @L2C\n  DFHTUTEN     C=(18),K='LOCK HELD'                         @EU71T @L2C\n  DFHTUTEN     C=(1C),K='LOCK NOTED'                        @EU71T @L2C\n  DFHTUTEN     C=(FF,FF),K=                                 @EU71T @L2C\n*                                                                     *\nTUTB2EBD EQU   *                   AMP                      @EU71J @L4C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT           @EU71J @L4C\n  DFHTUTEN     C=(01),K='ROUTER'                           @EU710A @L4C\n  DFHTUTEN     C=(FF,FF),K=                                 @EU71J @L4C\n*                                                                     *\nTUTB2ECD EQU   *                   DMP                      @EU71J @L4C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT           @EU71J @L4C\n  DFHTUTEN     C=(00),K='ROUTER'                            @EU71J @L4C\n  DFHTUTEN     C=(01),K='CONNECT'                           @EU71J @L4C\n  DFHTUTEN     C=(02),K='DISCONNECT'                        @EU71J @L4C\n  DFHTUTEN     C=(03),K='WRITE'                             @EU71J @L4C\n  DFHTUTEN     C=(04),K='READ'                              @EU71J @L4C\n  DFHTUTEN     C=(05),K='DELETE'                            @EU71J @L4C\n  DFHTUTEN     C=(06),K='(UN)LOCK'                          @EU71J @L4C\n  DFHTUTEN     C=(08),K='START BROWSE'                      @EU71J @L4C\n  DFHTUTEN     C=(09),K='GET NEXT'                          @EU71J @L4C\n  DFHTUTEN     C=(0A),K='END BROWSE'                        @EU71J @L4C\n  DFHTUTEN     C=(0B),K='CREATE SET'                        @EU71J @L4C\n  DFHTUTEN     C=(0D),K='QUERY SET'                         @EU71J @L4C\n  DFHTUTEN     C=(0F),K='ACCESS PRIMARY CTRL REC'           @EU71J @L4C\n  DFHTUTEN     C=(10),K='BUILD KWA'                         @EU71J @L4C\n  DFHTUTEN     C=(11),K='RELEASE KWA'                       @EU71J @L4C\n  DFHTUTEN     C=(12),K='TOKENISE KEY'                      @EU71J @L4C\n  DFHTUTEN     C=(13),K='FREE TOKEN(S)'                     @EU71J @L4C\n  DFHTUTEN     C=(15),K='GENERIC QUALIFY'                   @EU71J @L4C\n  DFHTUTEN     C=(16),K='SEQUENCE ORDERED SET'              @EU71J @L4C\n  DFHTUTEN     C=(17),K='VERIFY KWA'                        @EU71J @L4C\n  DFHTUTEN     C=(63),K='ADAPTOR'                           @EU71J @L4A\n  DFHTUTEN     C=(FF,FF),K=                                 @EU71J @L4C\n*                                                                     *\nTUTB2EDD EQU   *                   LFO NULL                    @BM13334\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT               @BM13334\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\n*                                                                     *\nTUTB2EED EQU   *                   VIO                         @BM13793\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R1,E=DFT,NX=SRT              @BM13793\n  DFHTUTEN     C=(14),K=' ',NX=EE0                             @BM13793\n  DFHTUTEN     C=(24),K='DATA',NX=SRT                          @BM13793\n  DFHTUTEN     C=(34),K='NEGATIVE RESP CODE',NX=SRT            @BM13793\n  DFHTUTEN     C=(44),K='LUSTAT CODE',NX=SRT                   @BM13793\n  DFHTUTEN     C=(54),K='SIGNAL CODE',NX=SRT                   @BM13793\n  DFHTUTEN     C=(64),K=' ',NX=EEE                        @EAPAR0L @01C\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\nTUTB2EEE EQU   *                                          @EAPAR0L @01A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT         @EAPAR0L @01C\n  DFHTUTEN     C=(01),K='STSN'                            @EAPAR0L @01A\n  DFHTUTEN     C=(02),K='CLEAR'                           @EAPAR0L @01A\n  DFHTUTEN     C=(03),K='SDT'                             @EAPAR0L @01A\n  DFHTUTEN     C=(04),K='BIND'                            @EAPAR0L @01A\n  DFHTUTEN     C=(05),K='SWITCH'                                   @M4C\n  DFHTUTEN     C=(FF,FF),K=                               @EAPAR0L @01A\n*  FIELD A0 - A1 SEQ NUMBER                                           *\nTUTB2EE0 EQU   *                                               @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BM13334\n  DFHTUTEN     C=(11),K='WRITE'                                @BBDIA0Y\n  DFHTUTEN     C=(12),K='RESET'                                @BBDIA0Y\n  DFHTUTEN     C=(13),K='DO'                                   @BBDIA0Y\n  DFHTUTEN     C=(16),K='SIMLOGON'                             @BBDIA0Y\n  DFHTUTEN     C=(17),K='OPNDST'                               @BBDIA0Y\n  DFHTUTEN     C=(19),K='CHANGE'                               @BBDIA0Y\n  DFHTUTEN     C=(1A),K='INQUIRE'                              @BBDIA0Y\n  DFHTUTEN     C=(1F),K='CLSDST'                               @BBDIA0Y\n  DFHTUTEN     C=(21),K='CLOSE ACB'                            @BBDIA0Y\n  DFHTUTEN     C=(22),K='SEND',NX=EE1                          @BM13334\n  DFHTUTEN     C=(23),K='RECEIVE',NX=EE1                       @BM13334\n  DFHTUTEN     C=(24),K='RESETSR'                              @BBDIA0Y\n  DFHTUTEN     C=(25),K='SESSIONC'                             @BBDIA0Y\n  DFHTUTEN     C=(27),K='SENDCMD'                              @BBDIA0Y\n  DFHTUTEN     C=(28),K='RCVCMD'                               @BBDIA0Y\n  DFHTUTEN     C=(29),K='REQSESS'                              @BBDIA0Y\n  DFHTUTEN     C=(2A),K='OPNSEC'                               @BBDIA0Y\n  DFHTUTEN     C=(2C),K='TERMSESS'                             @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\nTUTB2EE1 EQU   *                                               @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=EE2               @BBDIA0Y\n  DFHTUTEN     C=(80),K='BB'                                   @BBDIA0Y\n  DFHTUTEN     C=(40),K='EB'                                   @BBDIA0Y\n  DFHTUTEN     C=(20),K='CD'                                   @BBDIA0Y\n  DFHTUTEN     C=(10),K='FMH'                                  @BBDIA0Y\n  DFHTUTEN     C=(08),K='BC'                                   @BM13334\n  DFHTUTEN     C=(04),K='MC'                                   @BM13334\n  DFHTUTEN     C=(02),K='EC'                                   @BM13334\n  DFHTUTEN     C=(01),K='OIC'                                  @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\nTUTB2EE2 EQU   *                                               @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DFT,NX=EE3               @BM13334\n  DFHTUTEN     C=(40),K='RESP'                                 @BM13334\n  DFHTUTEN     C=(20),K='DATA'                                 @BM13334\n  DFHTUTEN     C=(10),K='CMD'                                  @BM13334\n**DFHTUTEN     C=(80),K=           INBOUND                     @BBCIA0Y\n  DFHTUTEN     C=(08),K='-'                                    @BM13334\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\nTUTB2EE3 EQU   *                                               @BM13334\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=EEA,NX=EE4               @BM13334\n  DFHTUTEN     C=(80),K='RQD1'                                 @BM13334\n  DFHTUTEN     C=(40),K='RQD2'                                 @BM13334\n  DFHTUTEN     C=(20),K='RQE1'                                 @BM13334\n  DFHTUTEN     C=(10),K='RQE2'                                 @BM13334\n  DFHTUTEN     C=(08),K='RQE3'                              @EI226 @L9A\n  DFHTUTEN     C=(04),K='RQD3'                              @EI226 @L9A\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\nTUTB2EE4 EQU   *                                               @BM13334\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=B0,E=DFT,NX=SRT              @BBDIA0Y\n**DFHTUTEN     C=(01),K='DATA'                                 @BM13334\n  DFHTUTEN     C=(04),K='LUSTAT'                               @BBDIA0Y\n  DFHTUTEN     C=(05),K='RTR'                                  @BBDIA0Y\n  DFHTUTEN     C=(05),K='LSA'                                  @BBDIA0Y\n  DFHTUTEN     C=(31),K='BIND'                                 @BBDIA0Y\n  DFHTUTEN     C=(32),K='UNBIND'                               @BBDIA0Y\n  DFHTUTEN     C=(70),K='BIS'                                  @BBDIA0Y\n  DFHTUTEN     C=(71),K='SBI'                                  @BBDIA0Y\n  DFHTUTEN     C=(80),K='QEC'                                  @BBDIA0Y\n  DFHTUTEN     C=(81),K='QC'                                   @BBDIA0Y\n  DFHTUTEN     C=(82),K='RELQ'                                 @BBDIA0Y\n  DFHTUTEN     C=(83),K='CANCEL'                               @BBDIA0Y\n  DFHTUTEN     C=(84),K='CHASE'                                @BBDIA0Y\n  DFHTUTEN     C=(A0),K='SDT'                                  @BBDIA0Y\n  DFHTUTEN     C=(A1),K='CLEAR'                                @BBDIA0Y\n  DFHTUTEN     C=(A2),K='STSN'                                 @BBDIA0Y\n  DFHTUTEN     C=(A3),K='RQR'                                  @BBDIA0Y\n  DFHTUTEN     C=(C0),K='SHUTD'                                @BBDIA0Y\n  DFHTUTEN     C=(C1),K='SHUTC'                                @BBDIA0Y\n  DFHTUTEN     C=(C2),K='RSHUTD'                               @BBDIA0Y\n  DFHTUTEN     C=(C8),K='BID'                                  @BBDIA0Y\n  DFHTUTEN     C=(C9),K='SIGNAL'                               @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2EFD EQU   *                   TOR                             @LKA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT                  @LKA\n  DFHTUTEN     C=(01),K='MAIN PROGRAM'                             @LKA\n  DFHTUTEN     C=(02),K='ADD (NON POOLED) TERM - TOATM'            @LKC\n  DFHTUTEN     C=(03),K='ADD (POOLED) TERMINAL - TOAPT'            @LKC\n  DFHTUTEN     C=(04),K='ADD TYPETERM - TOATY'                     @LKC\n  DFHTUTEN     C=(05),K='ADD CONNECTION - TOACN'                   @LKC\n  DFHTUTEN     C=(06),K='ADD SESSIONS - TOASE'                     @LKC\n  DFHTUTEN     C=(07),K='END GROUP - TOLCR'                        @LKC\n  DFHTUTEN     C=(08),K='END GROUP - TOLUI'                        @LKC\n  DFHTUTEN     C=(09),K='DWE COMMIT PROCESS - TOCMT'               @LKC\n  DFHTUTEN     C=(0A),K='DWE CANCEL PROCESS - TOCAN'               @LKC\n  DFHTUTEN     C=(0B),K='UTILITY - TOUT1'                          @LKC\n  DFHTUTEN     C=(0C),K='UTILITY - TOUT2'                          @LKC\n  DFHTUTEN     C=(10),K='MODEL RETRIEVAL'                          @LKA\n  DFHTUTEN     C=(11),K='CREATE TERMINAL BPS - TOBPS'              @LKA\n  DFHTUTEN     C=(12),K='RECOVERY PROGRAM - TORP'                  @LKA\n  DFHTUTEN     C=(FF,FF),K=                                        @LKA\n*                                                                     *\nTUTB2F0D EQU   *                   KCP                         @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAA12Y\n  DFHTUTEN     C=(01,00),K='ENQUEUE'                           @BD910JY\n  DFHTUTEN     C=(02,00),K='DEQUEUE'                           @BD910JY\n  DFHTUTEN     C=(03,00),K='DEQALL'                            @BD910JY\n  DFHTUTEN     C=(04,00),K='SUSPEND',NX=F0E                 @17307 @P3C\n  DFHTUTEN     C=(05,00),K='ENQUEUE-CONDITIONAL'               @BBDIA0Y\n  DFHTUTEN     C=(06,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(07,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(08,00),K='RESUME'                            @BD910JY\n  DFHTUTEN     C=(09,00),K='UPDATE TASKTIME'                       @LQA\n  DFHTUTEN     C=(0A,00),K='CHANGE MXT VALUE'               @01508 @D1A\n  DFHTUTEN     C=(0B,00),K='REDISPATCH'                     @01508 @D1A\n  DFHTUTEN     C=(0C,00),K='ENTER SRB MODE'                    @BD910JY\n  DFHTUTEN     C=(0D,00),K='ATTACH HTA'                        @BD910JY\n  DFHTUTEN     C=(0E,00),K='(NON FORCE) CANCEL TASK'        @17176 @P2C\n  DFHTUTEN     C=(0F,00),K='FORCE CANCEL TASK'              @17176 @P2A\n  DFHTUTEN     C=(10,00),K='ATTACH'                            @BD910JY\n  DFHTUTEN     C=(11,00),K='ATTACH-CONDITIONAL'                @BD910JY\n  DFHTUTEN     C=(12,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(13,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(14,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(15,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(16,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(17,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(18,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(19,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(1A,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(1B,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(1C,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(1D,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(1E,00),K='ATTACH'                         @EU71B @L3A\n  DFHTUTEN     C=(1F,00),K='ATTACH-CONDITIONAL'             @EU71B @L3A\n  DFHTUTEN     C=(20,00),K='CHAP'                              @BD910JY\n  DFHTUTEN     C=(28,00),K='LOCATE'                         @EU71T @L2A\n  DFHTUTEN     C=(29,00),K='LOCATE-REGION'                  @EU71T @L2A\n  DFHTUTEN     C=(2A,00),K='BROWSE'                         @EU71T @L2A\n  DFHTUTEN     C=(2B,00),K='BROWSE-UNLOCK'                  @EU71T @L2A\n  DFHTUTEN     C=(2C,00),K='LOCATE-PROFILE'                 @EU71T @L2A\n  DFHTUTEN     C=(2D,00),K='BROWSE-PROFILE'                 @EU71B @L3A\n  DFHTUTEN     C=(2E,00),K='BROWSE-PROFILE-UNLOCK'          @EU71B @L3A\n  DFHTUTEN     C=(2F,00),K='CTYPE',NX=F0C                   @EU71B @LLC\n  DFHTUTEN     C=(32,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(33,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(36,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(37,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(3A,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(3B,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(3E,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(3F,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(40,00),K='WAIT',NX=F0F                       @BM10700\n  DFHTUTEN     C=(56,00),K='ATTACH'                            @BA67170\n  DFHTUTEN     C=(57,00),K='ATTACH-CONDITIONAL'                @BA67170\n  DFHTUTEN     C=(80,00),K='DETACH'                            @BD910JY\n  DFHTUTEN     C=(84,00),K='SUSPEND+CANCADDR',NX=F0E        @01508 @D1C\n  DFHTUTEN     C=(92,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(93,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(9A,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(9B,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(B2,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(B3,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(BA,00),K='ATTACH'                                @LPA\n  DFHTUTEN     C=(BB,00),K='ATTACH-CONDITIONAL'                    @LPA\n  DFHTUTEN     C=(C0,00),K='WAIT+CANCADDR',NX=F0F           @01508 @D1C\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\nTUTB2F0F EQU   *                                               @BM10700\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BM10700\n  DFHTUTEN     C=(10,00),K='DCI=NON-DISP'                      @BM13311\n  DFHTUTEN     C=(13,00),K='DCI=TERMINAL'                      @BM13311\n  DFHTUTEN     C=(20,00),K='DCI=DISP'                          @BM10700\n  DFHTUTEN     C=(40,00),K='DCI=LIST'                          @BM10700\n  DFHTUTEN     C=(43,00),K='DCI=IOEVENT'                    @17307 @P3A\n  DFHTUTEN     C=(44,00),K='DCI=TCP'                        @17307 @P3A\n  DFHTUTEN     C=(80,00),K='DCI=SINGLE'                        @BM10700\n  DFHTUTEN     C=(88,00),K='DCI=CICS'                          @BM10700\n  DFHTUTEN     C=(89,00),K='DCI=FAM'                           @BM10700\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10700\nTUTB2F0E EQU   *                                            @17307 @P3A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT           @17307 @P3A\n  DFHTUTEN     C=(10,00),K='NON-DISPATCHABLE'               @17307 @P3A\n  DFHTUTEN     C=(13,00),K='TERMINAL WAIT'                  @17307 @P3A\n  DFHTUTEN     C=(16,00),K='ICP RETRIEVE WAIT'              @17307 @P3A\n  DFHTUTEN     C=(18,00),K='STORAGE CONTROL'                @17307 @P3A\n  DFHTUTEN     C=(19,00),K='ICP DELAY'                      @17307 @P3A\n  DFHTUTEN     C=(1C,00),K='TEMPORARY STORAGE'              @17307 @P3A\n  DFHTUTEN     C=(FF,FF),K=                                 @17307 @P3A\nTUTB2F0C EQU   *                                                   @LLA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT                  @LLA\n  DFHTUTEN     C=(01,00),K='REPLACE'                               @LLA\n  DFHTUTEN     C=(02,00),K='INITIALIZE'                            @LLA\n  DFHTUTEN     C=(03,00),K='WAITINIT'                              @LLA\n  DFHTUTEN     C=(04,00),K='RESTART TASK'                          @LLA\n  DFHTUTEN     C=(FF,FF),K=                                        @LLA\n*                                                                     *\nTUTB2F1D EQU   *                   SCP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=F1C,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(00,00),K=' ',NX=F10                       @EG00X @L2A\n  DFHTUTEN     C=(20,00),K='CUSHION CHANGE'                    @BD910JY\n  DFHTUTEN     C=(40,00),K='FREEMAIN'                          @BD910JY\n  DFHTUTEN     C=(60,00),K='FREEMAIN ALL'                      @BD910JY\n  DFHTUTEN     C=(80,00),K='GETMAIN'                           @BD910JY\n  DFHTUTEN     C=(A0,00),K='GETMAIN CONDITIONAL'               @BD910JY\n  DFHTUTEN     C=(C0,00),K='GETMAIN INITIMG'                   @BD910JY\n  DFHTUTEN     C=(E0,00),K='GETMAIN CONDITIONAL INITIMG'       @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\nTUTB2F10 EQU   *                                            @EG00X @L2A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,NX=SRT                 @EG00X @L2A\n  DFHTUTEN     C=(20,00),K='CUSHION CHANGE'                 @EG00X @L2A\n  DFHTUTEN     C=(40,00),K='FREEMAIN'                       @EG00X @L2A\n  DFHTUTEN     C=(60,00),K='FREEMAIN ALL'                   @EG00X @L2A\n  DFHTUTEN     C=(80,00),K='GETMAIN'                        @EG00X @L2A\n  DFHTUTEN     C=(90,00),K='GETMAIN ANY'                    @EG00X @L2A\n  DFHTUTEN     C=(A0,00),K='GETMAIN CONDITIONAL'            @EG00X @L2A\n  DFHTUTEN     C=(B0,00),K='GETMAIN CONDITIONAL ANY'        @EG00X @L2A\n  DFHTUTEN     C=(C0,00),K='GETMAIN INITIMG'                @EG00X @L2A\n  DFHTUTEN     C=(D0,00),K='GETMAIN INITIMG ANY'            @EG00X @L2A\n  DFHTUTEN     C=(E0,00),K='GETMAIN CONDITIONAL INITIMG'    @EG00X @L2A\n  DFHTUTEN     C=(F0,00),K='GETMAIN CONDITIONAL INITIMG ANY'       @L2A\n  DFHTUTEN     C=(FF,FF),K=                                 @EG00X @L2A\n*                                                                     *\nTUTB2F2D EQU   *                   PCP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLC,OFF=R0,E=F2C,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(01,00),K='LINK'                              @BD910JY\n  DFHTUTEN     C=(02,00),K='XCTL'                              @BD910JY\n  DFHTUTEN     C=(03,00),K='CTYPE LOCATE'                   @EU71T @L2A\n  DFHTUTEN     C=(03,10),K='CTYPE BROWSE'                   @EU71T @L2A\n  DFHTUTEN     C=(03,20),K='CTYPE LOCATE NOWAIT'            @EU71T @L2A\n  DFHTUTEN     C=(03,50),K='CTYPE BROWSE UNLOCK'            @EU71T @L2A\n  DFHTUTEN     C=(04,00),K='LOAD'                              @BD910JY\n  DFHTUTEN     C=(05,10),K='CTYPE REPLACE'                  @EU71T @L2A\n  DFHTUTEN     C=(05,20),K='CTYPE INITIALIZE'                      @LLA\n  DFHTUTEN     C=(05,30),K='CTYPE WAITINIT'                        @LLA\n  DFHTUTEN     C=(08,00),K='DELETE'                            @BD910JY\n  DFHTUTEN     C=(10,00),K='RETURN'                            @BD910JY\n  DFHTUTEN     C=(12,00),K='RETRY'                             @BBAI20Y\n  DFHTUTEN     C=(20,00),K='SETXIT,CANCEL'                     @BD910JY\n  DFHTUTEN     C=(20,10),K='SETXIT,PROGRAM'                    @BD910JY\n  DFHTUTEN     C=(20,20),K='SETXIT,ROUTINE'                    @BD910JY\n  DFHTUTEN     C=(20,40),K='BLDL'                              @BD910JY\n  DFHTUTEN     C=(20,80),K='RESETXIT'                          @BD910JY\n  DFHTUTEN     C=(24,00),K='LOAD,LOADLST=NO'                       @LMC\n  DFHTUTEN     C=(40,00),K='ABEND'                             @BD910JY\n  DFHTUTEN     C=(41,00),K='ABEND,CANCEL=YES'                  @BD910JY\n  DFHTUTEN     C=(44,00),K='LOAD RMODE(ANY)'                @EG00X @L2A\n  DFHTUTEN     C=(60,00),K='ABEND'                             @BD910JY\n  DFHTUTEN     C=(61,00),K='ABEND,CANCEL=YES'                  @BD910JY\n  DFHTUTEN     C=(64,00),K='LOAD,LOADLST=NO RMODE(ANY)'            @LMA\n  DFHTUTEN     C=(81,00),K='LINK-CONDITIONAL'                  @BD910JY\n  DFHTUTEN     C=(82,00),K='LOCATE'                            @BD910JY\n  DFHTUTEN     C=(84,00),K='LOAD-CONDITIONAL'                  @BD910JY\n  DFHTUTEN     C=(88,00),K='XCTL-CONDITIONAL'               @EU71B @L3A\n  DFHTUTEN     C=(A4,00),K='LOAD-CONDNL,LOADLST=NO'                @LMC\n  DFHTUTEN     C=(C4,00),K='LOAD-CONDNL RMODE(ANY)'                @LMA\n  DFHTUTEN     C=(E4,00),K='LOAD-CONDNL,LOADLST=NO RMODE(ANY)'     @LMA\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2F3D EQU   *                   ICP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=F3C,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(10,00),K='GETIME'                            @BD910JY\n* DFHTUTEN     C=(10,01),K='GETIME PACKED'                     @BD910JY\n* DFHTUTEN     C=(10,02),K='GETIME USER BINARY'                @BD910JY\n* DFHTUTEN     C=(10,03),K='GETIME USER PACKED'                @BD910JY\n  DFHTUTEN     C=(20,00),K='WAIT'                              @BD910JY\n  DFHTUTEN     C=(30,00),K='POST'                              @BD910JY\n  DFHTUTEN     C=(40,00),K='INITIATE'                          @BD910JY\n  DFHTUTEN     C=(50,00),K='PUT'                               @BD910JY\n  DFHTUTEN     C=(60,00),K='INITIATE'                              @P6C\n  DFHTUTEN     C=(70,00),K='PUT HEADER'                        @BBCI70Y\n  DFHTUTEN     C=(80,00),K='GET'                               @BD910JY\n  DFHTUTEN     C=(90,00),K='RETRY'                             @BD910JY\n  DFHTUTEN     C=(A0,00),K='RESET'                             @BD910JY\n  DFHTUTEN     C=(B0,00),K='SCHEDULE'                          @BM13793\n  DFHTUTEN     C=(C0,00),K='ICE EXPIRY ANALYSIS'                   @LMA\n  DFHTUTEN     C=(D0,00),K='RECOVERY'                          @BM13793\n  DFHTUTEN     C=(F0,00),K='CANCEL'                            @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2F3E EQU   *                   ICP RETURN                  @BBCI70Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBCI70Y\n  DFHTUTEN     C=(00,00),K='NORMAL'                            @BBCI70Y\n  DFHTUTEN     C=(01,00),K='ENDDATA'                           @BBCI70Y\n  DFHTUTEN     C=(04,00),K='IOERROR'                           @BBCI70Y\n  DFHTUTEN     C=(11,00),K='TRNIDER'                           @BBCI70Y\n  DFHTUTEN     C=(12,00),K='TRMIDER'                           @BBCI70Y\n  DFHTUTEN     C=(14,00),K='TSINVLD'                           @BBCI70Y\n  DFHTUTEN     C=(20,00),K='EXPIRD'                            @BBCI70Y\n  DFHTUTEN     C=(81,00),K='NOTFND'                            @BBCI70Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBCI70Y\n*                                                                     *\nTUTB2F4D EQU   *                   DCP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLC,OFF=R0,E=F4C,NX=F4F              @BBAI20Y\n  DFHTUTEN     C=(00,FF),K='CICS'                              @BBAA12Y\n  DFHTUTEN     C=(FE,FF),K='COMPLETE'                          @BM10631\n  DFHTUTEN     C=(FE,00),K='TRANSACTION'                       @BM10631\n* DFHTUTEN     C=(10,00),K='SUPTRACE'                          @BBAA12Y\n* DFHTUTEN     C=(30,00),K='SUPTCA'                            @BBAA12Y\n* DFHTUTEN     C=(40,00),K='SUPCSA'                            @BBAA12Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\nTUTB2F4F EQU   *                                               @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=SRT               @BD910JY\n  DFHTUTEN     C=(01),K='PRTDCT'                               @BD910JY\n  DFHTUTEN     C=(02),K='PRTFCT'                               @BM10989\n  DFHTUTEN     C=(04),K='PRTTCT'                               @BD910JY\n  DFHTUTEN     C=(08),K='PRTPCT'                               @BD910JY\n  DFHTUTEN     C=(20),K='PRTPPT'                               @BD910JY\n  DFHTUTEN     C=(40),K='PRTSIT'                               @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\n*                                                                     *\nTUTB2F5D EQU   *                   FCP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(00,00),K='DWE PROCESSOR'                     @BM10519\n  DFHTUTEN     C=(01,00),K='DELETE'                            @BD910JY\n  DFHTUTEN     C=(02,00),K='CTYPE OPEN'                            @LUA\n  DFHTUTEN     C=(03,00),K='CTYPE IMPLICIT OPEN'                   @LUA\n  DFHTUTEN     C=(04,00),K='CTYPE MAKE USER'                       @LUA\n  DFHTUTEN     C=(05,00),K='CTYPE CLOSE'                           @LUA\n  DFHTUTEN     C=(06,00),K='CTYPE CLOSE'                           @LUA\n  DFHTUTEN     C=(07,00),K='CTYPE CLOSE'                           @LUA\n  DFHTUTEN     C=(08,00),K='CTYPE CLOSE'                           @LUA\n  DFHTUTEN     C=(09,00),K='CTYPE ENABLE'                          @LUA\n  DFHTUTEN     C=(0A,00),K='CTYPE DISABLE'                         @LUA\n  DFHTUTEN     C=(0B,00),K='CTYPE TEST USER'                       @LUA\n  DFHTUTEN     C=(0C,00),K='DFHFCM OPEN'                           @LUA\n  DFHTUTEN     C=(0D,00),K='DFHFCM CLOSE'                          @LUA\n  DFHTUTEN     C=(0E,00),K='DFHFCN OPEN'                           @LUA\n  DFHTUTEN     C=(0F,00),K='DFHFCN CLOSE'                          @LUA\n  DFHTUTEN     C=(10,00),K='RELEASE'                           @BD910JY\n  DFHTUTEN     C=(11,00),K='ESETL'                             @BD910JY\n  DFHTUTEN     C=(20,00),K='GETAREA'                               @LUA\n  DFHTUTEN     C=(24,00),K='GETAREA MASS INSERT'                   @LUA\n  DFHTUTEN     C=(28,00),K='GETAREA INIT'                          @LUC\n  DFHTUTEN     C=(2C,00),K='GETAREA MASS INSERT INIT'              @LUC\n  DFHTUTEN     C=(40,00),K='PUT'                               @BD910JY\n  DFHTUTEN     C=(41,00),K='PUT-DELETE'                        @BD910JY\n  DFHTUTEN     C=(44,00),K='PUT-NEW'                           @BD910JY\n  DFHTUTEN     C=(50,00),K='DATA TABLE REQUEST'                @BA37518\n  DFHTUTEN     C=(51,00),K='DATA TABLE NORMAL RSP'             @BA37518\n  DFHTUTEN     C=(52,00),K='DATA TABLE EXCEPTION RSP'          @BA37518\n  DFHTUTEN     C=(53,00),K='DATA TABLE INVALID RSP'            @BA37518\n  DFHTUTEN     C=(80,00),K='GET'                               @BD910JY\n  DFHTUTEN     C=(81,00),K='GET'                               @BD910JY\n  DFHTUTEN     C=(84,00),K='GET-UPDATE'                        @BD910JY\n  DFHTUTEN     C=(85,00),K='GET-UPDATE'                            @LMC\n  DFHTUTEN     C=(A0,00),K='SETL'                              @BD910JY\n  DFHTUTEN     C=(A1,00),K='SETL'                                  @LUA\n  DFHTUTEN     C=(A4,00),K='RESETL'                            @BD910JY\n  DFHTUTEN     C=(B0,00),K='GETNEXT'                           @BM10771\n  DFHTUTEN     C=(B4,00),K='GETPREV'                           @BM10771\n  DFHTUTEN     C=(F0,00),K='CTYPE SET'                             @LUC\n  DFHTUTEN     C=(F1,00),K='CTYPE LOCATE'                   @EU71B @L3A\n  DFHTUTEN     C=(F4,00),K='CTYPE BROWSE'                          @LMC\n  DFHTUTEN     C=(F5,00),K='CTYPE INITIALIZE'                      @LUA\n  DFHTUTEN     C=(F6,00),K='CTYPE WAITINIT'                        @LUA\n  DFHTUTEN     C=(F7,00),K='CTYPE RESTART'                         @LUA\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2F5E EQU   *                   FCP RETURN                  @BBCI70Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBCI70Y\n  DFHTUTEN     C=(00,00),K='NORMAL'                            @BBCI70Y\n  DFHTUTEN     C=(01,00),K='DSIDER'                            @BBCI70Y\n  DFHTUTEN     C=(02,00),K='ILLOGIC'                           @BBCI70Y\n  DFHTUTEN     C=(08,00),K='INVREQ'                            @BBCI70Y\n  DFHTUTEN     C=(0C,00),K='NOTOPEN'                           @BBCI70Y\n  DFHTUTEN     C=(0F,00),K='ENDFILE'                           @BBCI70Y\n  DFHTUTEN     C=(20,00),K='ERROR'                                 @LUA\n  DFHTUTEN     C=(40,00),K='DFHFCN NORMAL'                         @LUC\n  DFHTUTEN     C=(41,00),K='DFHFCN WARNING'                        @LUC\n  DFHTUTEN     C=(42,00),K='DFHFCN ERROR'                          @LUC\n  DFHTUTEN     C=(80,00),K='IOERROR'                           @BBCI70Y\n  DFHTUTEN     C=(81,00),K='NOTFND'                            @BBCI70Y\n  DFHTUTEN     C=(82,00),K='DUPREC'                            @BBCI70Y\n  DFHTUTEN     C=(83,00),K='NOSPACE'                           @BBCI70Y\n  DFHTUTEN     C=(84,00),K='DUPKEY'                            @BBCI70Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBCI70Y\n*                                                                     *\nTUTB2F6D EQU   *                   TDP                         @BBCI70Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R1,E=DFT,NX=SRT           @E131U @LCA\n  DFHTUTEN     C=(03,00),K='APPL REQ',NX=F6B                @E131U @LCA\n  DFHTUTEN     C=(13,00),K='START CANCEL LOGIC'             @E131U @LCA\n  DFHTUTEN     C=(23,00),K='START I/O ERROR LOGIC'          @E131U @LCA\n  DFHTUTEN     C=(33,00),K='START INIT PHASE 2 LOGIC'              @LOC\n  DFHTUTEN     C=(43,00),K='START INIT PHASE 1 LOGIC'              @LOA\n  DFHTUTEN     C=(FF,FF),K=                                 @E131U @LCA\nTUTB2F6B EQU   *                                            @E131U @LCA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(04,00),K='PURGE'                          @E131U @LCA\n  DFHTUTEN     C=(0C,00),K='PURGE ADDR=YES'                 @E131U @LCA\n  DFHTUTEN     C=(10,00),K='LOCATE'                         @E131U @LCA\n  DFHTUTEN     C=(20,00),K='FEOV'                           @E131U @LCA\n  DFHTUTEN     C=(28,00),K='FEOV ADDR=YES'                  @E131U @LCA\n  DFHTUTEN     C=(40,00),K='PUT'                            @E131U @LCA\n  DFHTUTEN     C=(48,00),K='PUT ADDR=YES'                   @E131U @LCA\n  DFHTUTEN     C=(80,00),K='GET'                            @E131U @LCA\n  DFHTUTEN     C=(88,00),K='GET ADDR=YES'                   @E131U @LCA\n  DFHTUTEN     C=(C0,00),K='GET CONDITIONAL'                @E131U @LCA\n  DFHTUTEN     C=(C8,00),K='GET CONDITIONAL ADDR=YES'       @E131U @LCA\n  DFHTUTEN     C=(E1,00),K='CTYPE LOCATE'                   @EU71B @L3A\n  DFHTUTEN     C=(E4,00),K='CTYPE BROWSE'                   @EU71B @L3A\n  DFHTUTEN     C=(F0,00),K='CTYPE INITIALIZE'                      @LOA\n  DFHTUTEN     C=(F1,00),K='CTYPE WAITINIT'                        @LOA\n  DFHTUTEN     C=(F2,00),K='CTYPE FLUSH'                           @LOA\n  DFHTUTEN     C=(F3,00),K='CTYPE PROCESS-DWE'                     @LOC\n  DFHTUTEN     C=(F4,00),K='CTYPE RECOVER'                         @LOA\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2F6E EQU   *                   TDP RETURN                  @BBCI70Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R1,E=DFT,NX=SRT           @E131U @LCA\n  DFHTUTEN     C=(05,00),K='APPL RESP',NX=F6C               @E131U @LCA\n  DFHTUTEN     C=(15,00),K='END CANCEL LOGIC'               @E131U @LCA\n  DFHTUTEN     C=(25,00),K='END I/O ERROR LOGIC'            @E131U @LCA\n  DFHTUTEN     C=(35,00),K='END INIT PHASE 2 LOGIC'                @LOC\n  DFHTUTEN     C=(45,00),K='END INIT PHASE 1 LOGIC'                @LOA\n  DFHTUTEN     C=(FF,FF),K=                                 @E131U @LCA\nTUTB2F6C EQU   *                                            @E131U @LCA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBCI70Y\n  DFHTUTEN     C=(00,00),K='NORMAL'                            @BBCI70Y\n  DFHTUTEN     C=(01,00),K='QUEZERO'                           @BBCI70Y\n  DFHTUTEN     C=(02,00),K='IDERROR'                           @BBCI70Y\n  DFHTUTEN     C=(04,00),K='IOERROR'                           @BBCI70Y\n  DFHTUTEN     C=(08,00),K='NOTOPEN'                           @BBCI70Y\n  DFHTUTEN     C=(10,00),K='NOSPACE'                           @BBCI70Y\n  DFHTUTEN     C=(20,00),K='INIT FAILED'                           @LOA\n  DFHTUTEN     C=(40,00),K='INVALID CHAIN'                  @E131U @LCA\n  DFHTUTEN     C=(C0,00),K='QUEBUSY'                        @E131U @LCA\n  DFHTUTEN     C=(FF,FF),K=                                    @BBCI70Y\n*                                                                     *\nTUTB2F7D EQU   *                   TSP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R1,E=F7C,NX=SRT           @E121U @LDA\n  DFHTUTEN     C=(03,00),K='APPL REQ',NX=F7F                @E121U @LDA\n  DFHTUTEN     C=(13,00),K='START DWE LOGIC'                @E121U @PCA\n  DFHTUTEN     C=(23,00),K='START CANCEL LOGIC'             @E121U @LDA\n  DFHTUTEN     C=(44,00),K='AUX PROC USAGE'                        @PCC\n  DFHTUTEN     C=(FF,FF),K=                                 @E121U @LDA\nTUTB2F7F EQU   *                                            @E121U @LDA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=F7C,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(02,00),K='FLUSH'                             @BD910JY\n  DFHTUTEN     C=(20,00),K='RELEASE'                           @BD910JY\n  DFHTUTEN     C=(21,00),K='PURGEQ'                            @BD910JY\n  DFHTUTEN     C=(22,00),K='RELEASE-FLUSH'                     @BD910JY\n  DFHTUTEN     C=(23,00),K='PURGE-FLUSH'                       @BD910JY\n  DFHTUTEN     C=(40,00),K='PUT'                               @BD910JY\n  DFHTUTEN     C=(41,00),K='PUTQ'                              @BD910JY\n  DFHTUTEN     C=(42,00),K='PUT SYSTEM'                        @BM10857\n  DFHTUTEN     C=(43,00),K='PUTQ SYSTEM'                       @BBAI20Y\n  DFHTUTEN     C=(44,00),K='PUT-REPLACE'                       @BD910JY\n  DFHTUTEN     C=(45,00),K='PUTQ-REPLACE'                      @BD910JY\n  DFHTUTEN     C=(46,00),K='PUT-REPLACE SYS'                   @BD910JY\n  DFHTUTEN     C=(47,00),K='PUTQ-REPLACE-SYS'                  @BD910JY\n  DFHTUTEN     C=(80,00),K='GET'                               @BD910JY\n  DFHTUTEN     C=(81,00),K='GETQ'                              @BBAI20Y\n  DFHTUTEN     C=(82,00),K='GET STORCLS=TERM'                  @BBAI20Y\n  DFHTUTEN     C=(83,00),K='GETQ STORCLS=TERM'                 @BBAI20Y\n  DFHTUTEN     C=(84,00),K='GET EXCLUSIVE'                     @BBAI20Y\n  DFHTUTEN     C=(85,00),K='GETQ EXCLUSIVE'                    @BBAI20Y\n  DFHTUTEN     C=(86,00),K='GETQ EXCLUSIVE'                    @BBAI20Y\n  DFHTUTEN     C=(87,00),K='GETQ EXCLUSIVE STORCLS=TERM'       @BBAI20Y\n  DFHTUTEN     C=(A0,00),K='GET-RELEASE'                       @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2F7E EQU   *                   TSP RETURN                  @BBCI70Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R1,E=DFT,NX=SRT           @E121U @LDA\n  DFHTUTEN     C=(05,00),K='APPL RESP',NX=F7G               @E121U @LDA\n  DFHTUTEN     C=(15,00),K='END DWE LOGIC'                  @E131U @LCA\n  DFHTUTEN     C=(25,00),K='END CANCEL LOGIC'               @E131U @LCA\n  DFHTUTEN     C=(FF,FF),K=                                 @E121U @LDA\nTUTB2F7G EQU   *                                            @E121U @LDA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBCI70Y\n  DFHTUTEN     C=(00,00),K='NORMAL'                            @BBCI70Y\n  DFHTUTEN     C=(02,00),K='IDERROR'                           @BBCI70Y\n  DFHTUTEN     C=(04,00),K='IOERROR'                           @BBCI70Y\n  DFHTUTEN     C=(20,00),K='INVREQ'                            @BBCI70Y\n  DFHTUTEN     C=(01,00),K='ENTRY ERROR'                       @BM12042\n  DFHTUTEN     C=(08,00),K='NOSPACE'                           @BBCI70Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBCI70Y\n*                                                              @BA26864\nTUTB2F7H EQU   *                   TSP FE                      @BA26864\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BA26864\n  DFHTUTEN     C=(01),K='COMPRESS CI'                          @BA26864\n  DFHTUTEN     C=(02),K='READ CI'                              @BA26864\n  DFHTUTEN     C=(03),K='WRITE CI'                             @BA26864\n  DFHTUTEN     C=(04),K='BUFFER INFORMATION'                   @BA26864\n  DFHTUTEN     C=(FF,FF),K=                                    @BA26864\n*                                                                     *\nTUTB2F8D EQU   *                   DL/I                     @E8D08 @M1A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT           @E8D08 @M1A\n  DFHTUTEN     C=(01),K='IWAIT'                             @E8D08 @M1A\n  DFHTUTEN     C=(FF,FF),K=                                 @E8D08 @M1A\n*                                                                     *\nTUTB2F8E EQU   *                   DL/I RETURN                 @BBCI70Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBCI70Y\n  DFHTUTEN     C=(01,00),K='PSB NOTFND'                        @BBCI70Y\n  DFHTUTEN     C=(02,00),K='TASKNA'                            @BBCI70Y\n  DFHTUTEN     C=(03,00),K='PSBSCH'                            @BBCI70Y\n  DFHTUTEN     C=(04,00),K='LANGCON'                           @BBCI70Y\n  DFHTUTEN     C=(05,00),K='PSBFAIL'                           @BBCI70Y\n  DFHTUTEN     C=(06,00),K='PSBNA'                             @BBCI70Y\n  DFHTUTEN     C=(07,00),K='TERMNS'                            @BBCI70Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBCI70Y\n*                                                                     *\nTUTB2F9D EQU   *                   JCP                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(01,00),K='WRITE'                             @BD910JY\n  DFHTUTEN     C=(02,00),K='WAIT'                              @BD910JY\n  DFHTUTEN     C=(03,00),K='PUT'                               @BD910JY\n  DFHTUTEN     C=(04,00),K='OPEN'                              @BD910JY\n  DFHTUTEN     C=(08,00),K='CLOSE'                             @BD910JY\n  DFHTUTEN     C=(10,00),K='NOTE'                              @BD910JY\n  DFHTUTEN     C=(20,00),K='POINT'                             @BD910JY\n  DFHTUTEN     C=(40,00),K='GETF'                              @BD910JY\n  DFHTUTEN     C=(80,00),K='GETB'                              @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\nTUTB2F9E EQU   *                   JCP RETURN                      @P5A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT                  @P5C\n  DFHTUTEN     C=(00,00),K='NORMAL'                                @P5A\n  DFHTUTEN     C=(01,00),K='IDERROR'                               @P5A\n  DFHTUTEN     C=(02,00),K='INVREQ'                                @P5A\n  DFHTUTEN     C=(03,00),K='STATERR'                               @P5A\n  DFHTUTEN     C=(04,00),K='VOLERR'   IN CG, NOT APRM              @P5A\n  DFHTUTEN     C=(05,00),K='NOTOPEN'                               @P5A\n  DFHTUTEN     C=(06,00),K='LERROR'                                @P5A\n  DFHTUTEN     C=(07,00),K='IOERROR'                               @P5A\n  DFHTUTEN     C=(08,00),K='END OF DATA SET'                       @P5A\n  DFHTUTEN     C=(09,00),K='INSUFFICIENT BUFFER SPACE'  NOJBUFSP   @P5A\n  DFHTUTEN     C=(0A,00),K='DYNAMIC LOG ERROR'                     @P5A\n  DFHTUTEN     C=(FF,FF),K=                                        @P5A\n*                                                                     *\nTUTB2FAD EQU   *                   BMS                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT                  @D3C\n  DFHTUTEN     C=(00),K=' ',NX=FAX                                 @LSA\n*  BMS SECONDARY MODULE ENTRIES                                       *\n  DFHTUTEN     C=(01),K='RLR ENTRY'                                @D3A\n  DFHTUTEN     C=(02),K='PBP ENTRY'                                @D3A\n  DFHTUTEN     C=(03),K='M32 ENTRY'                                @D3A\n  DFHTUTEN     C=(04),K='ML1 ENTRY'                                @D3A\n  DFHTUTEN     C=(05),K='DSB ENTRY'                                @D3A\n  DFHTUTEN     C=(06),K='TPP ENTRY'                                @D3A\n  DFHTUTEN     C=(07),K='IIP ENTRY'                                @D3A\n  DFHTUTEN     C=(41),K='RLR EXIT'                                 @D3A\n  DFHTUTEN     C=(42),K='PBP EXIT'                                 @D3A\n  DFHTUTEN     C=(43),K='M32 EXIT'                                 @D3A\n  DFHTUTEN     C=(44),K='ML1 EXIT'                                 @D3A\n  DFHTUTEN     C=(45),K='DSB EXIT'                                 @D3A\n  DFHTUTEN     C=(46),K='TPP EXIT'                                 @D3A\n  DFHTUTEN     C=(47),K='IIP EXIT'                                 @D3A\n*  SPECIAL CASE FOR QUERY ENTRIES                                     *\n  DFHTUTEN     C=(81),K='QUERY'                                    @LSC\n  DFHTUTEN     C=(82),K='QUERY CONTINUED'                          @LSC\n  DFHTUTEN     C=(FF,FF),K=                                        @LSA\nTUTB2FAX EQU  *    NORMAL BMS ENTRIES                              @LSA\n  DFHTUTEN     T=(2,I),CP=TM,OFF=B0,E=DFT,NX=FAZ               @BM10519\n  DFHTUTEN     C=(80),K='PAGEBLD'                              @BM10519\n  DFHTUTEN     C=(40),K='OFLOW'                                @BM10519\n  DFHTUTEN     C=(20),K='ERASEAUP'                             @BM10519\n  DFHTUTEN     C=(04),K='SEND-OUT'                             @BM10519\n  DFHTUTEN     C=(02),K='STORE'                                @BM10519\n  DFHTUTEN     C=(01),K='RETURN'                               @BM10519\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10519\nTUTB2FAZ EQU   *                                               @BM10519\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=FAY               @BM10519\n  DFHTUTEN     C=(80),K='ROUTE'                                @BBAI20Y\n  DFHTUTEN     C=(10),K='INTERVAL'                             @BBAI20Y\n  DFHTUTEN     C=(08),K='TIME'                                 @BBAI20Y\n  DFHTUTEN     C=(04),K='LIST=ALL'                             @BM10519\n  DFHTUTEN     C=(02),K='LIST'                                 @BBAI20Y\n  DFHTUTEN     C=(01),K='OPCLASS'                              @BBAI20Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\nTUTB2FAY EQU   *                                               @BM10519\n  DFHTUTEN     T=(2,I),CP=TM,OFF=B1,E=DFT,NX=FAG               @BM10519\n  DFHTUTEN     C=(80),K='PAGEOUT'                              @BM10519\n  DFHTUTEN     C=(40),K='AUTOPAGE'                             @BM10519\n  DFHTUTEN     C=(20),K='PAGE'                                 @BM10519\n  DFHTUTEN     C=(10),K='RETAIN'                               @BM10519\n  DFHTUTEN     C=(08),K='RELEASE'                              @BM10519\n  DFHTUTEN     C=(01),K='EODPURG'                              @BM10519\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10519\nTUTB2FAG EQU   *                                               @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FAH               @BBAI20Y\n  DFHTUTEN     C=(80),K='TITLE'                                @BM10519\n  DFHTUTEN     C=(20),K='REQID'                                @BM10519\n  DFHTUTEN     C=(01),K='PURGE'                                @BM10519\n  DFHTUTEN     C=(40),K='PROPT'                                @BM10771\n  DFHTUTEN     C=(10),K='LDC'                                  @BM10771\n  DFHTUTEN     C=(04),K='SEND-PARTNSET'                     @E5E2C @H1C\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\nTUTB2FAH EQU   *                                               @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=FAI               @BBAI20Y\n  DFHTUTEN     C=(80),K='LAST'                                 @BM10519\n  DFHTUTEN     C=(40),K='RECEIVE-PARTN'                     @E5E2C @H1C\n  DFHTUTEN     C=(20),K='TEXT'                                 @BM10519\n  DFHTUTEN     C=(10),K='CURSOR'                               @BM10519\n  DFHTUTEN     C=(08),K='CTRL'                                 @BBAI20Y\n  DFHTUTEN     C=(04),K='MAP'                                  @BBAI20Y\n  DFHTUTEN     C=(02),K='MSETADR'                              @BBAI20Y\n  DFHTUTEN     C=(01),K='MAPSET'                               @BBAI20Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\nTUTB2FAI EQU   *                                               @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DFT,NX=FAL               @BM10519\n  DFHTUTEN     C=(20),K='SAVE'                                 @BBAI20Y\n  DFHTUTEN     C=(10),K='MAPADDR'                              @BM10519\n  DFHTUTEN     C=(08),K='WAIT'                                 @BBAI20Y\n  DFHTUTEN     C=(04),K='MAP-FROM'                             @BBAI20Y\n  DFHTUTEN     C=(02),K='ERASE'                                @BBAI20Y\n  DFHTUTEN     C=(01),K='IN'                                   @BBAI20Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\nTUTB2FAL EQU   *                                               @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=B2,E=DFT,NX=FAM                   @LMC\n  DFHTUTEN     C=(80),K='TXTBLD'                               @BBAI20Y\n  DFHTUTEN     C=(40),K='HEADER'                               @BBAI20Y\n  DFHTUTEN     C=(20),K='TRAILER'                              @BBAI20Y\n  DFHTUTEN     C=(10),K='JUSTIFY'                              @BBAI20Y\n  DFHTUTEN     C=(08),K='OUTPARTN'                          @E5E2C @H1C\n  DFHTUTEN     C=(04),K='ACTPARTN'                          @E5E2C @H1C\n  DFHTUTEN     C=(01),K='NOEDIT'                               @BBAI20Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10519\nTUTB2FAM EQU   *                                                   @LMC\n  DFHTUTEN     T=(2,I),CP=TM,OFF=B3,E=DFT,NX=SRT            @E5E2C @H1C\n  DFHTUTEN     C=(80),K='INPARTN'                           @E5E2C @H1C\n  DFHTUTEN     C=(40),K='MSR'                               @E5E5C @H2C\n  DFHTUTEN     C=(01),K='CONTROL'                           @E5E5C @H2C\n  DFHTUTEN     C=(FF,FF),K=                                 @E5E2C @H1C\n*                                                                     *\nTUTB2FBD EQU   *                   BIF                         @BD910JY\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(01,00),K='BITEST'                            @BD910JY\n  DFHTUTEN     C=(02,00),K='DEEDIT'                            @BD910JY\n  DFHTUTEN     C=(03,00),K='INFORMAT'                          @BD910JY\n  DFHTUTEN     C=(04,00),K='PHONETIC'                          @BD910JY\n  DFHTUTEN     C=(05,00),K='CHECK'                             @BD910JY\n  DFHTUTEN     C=(06,00),K='TSEARCH'                           @BM10771\n  DFHTUTEN     C=(07,00),K='WTRETST'                           @BD910JY\n  DFHTUTEN     C=(08,00),K='WTRTPARM'                          @BD910JY\n  DFHTUTEN     C=(09,00),K='WTRETGET'                          @BD910JY\n  DFHTUTEN     C=(0A,00),K='WTRETREL'                          @BD910JY\n  DFHTUTEN     C=(FF,FF),K=                                    @BD910JY\n*                                                                     *\n*        ZCP ENTRY TABLE                                              *\nTUTB2FCD EQU   *                   ZCP                         @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(EE,00),K='EXIT TRACE',NX=FZA              @EI226 @LAC\n  DFHTUTEN     C=(01,00),K='ZARQ APPL REQ',NX=FCB              @BBAI20Y\n  DFHTUTEN     C=(02,00),K='ZLOC',NX=FCR                       @BBAI20Y\n  DFHTUTEN     C=(03,00),K='ZDET DETACH'                       @BBAI20Y\n  DFHTUTEN     C=(05,00),K='ZSUP START UP TASK'                @BBAI20Y\n  DFHTUTEN     C=(06,00),K='ZCRQ COMMAND REQS'                 @BBAI20Y\n**DFHTUTEN     C=(07,00),K='LENGTH NOT USED'                   @BBDIA0Y\n  DFHTUTEN     C=(08,00),K='ZSTU STATUS',NX=FCI                @BBDIA0Y\n  DFHTUTEN     C=(09,00),K='ZTSP TERMINAL SHARING',NX=FCT      @BBDJ20B\n  DFHTUTEN     C=(0A,00),K='RPL EXECUTOR'                      @BBAI20Y\n  DFHTUTEN     C=(0B,00),K='ZISP ISC',NX=FCL                   @BBAI20Y\n  DFHTUTEN     C=(0C,00),K='ZIS1 ISC',NX=FCM                   @BBAI20Y\n  DFHTUTEN     C=(0D,00),K='ZIS2 IRC',NX=FCN                   @BBAI20Y\n  DFHTUTEN     C=(0E,00),K='ZABD ABEND '                       @BBAI20Y\n* DFHTUTEN     C=(0F,00),K='Z*** RESERVED'                     @BBDIA0Y\n  DFHTUTEN     C=(10,00),K='ZATI A.T.I'                        @BBAI20Y\n  DFHTUTEN     C=(11,00),K='ZATT ATTACH'                       @BBAI20Y\n  DFHTUTEN     C=(12,00),K='ZFRE FREEMAIN'                     @BBAI20Y\n  DFHTUTEN     C=(13,00),K='ZGET GETMAIN'                      @BBAI20Y\n  DFHTUTEN     C=(14,00),K='ZRAC RECEIVE ANY '                 @BM10218\n  DFHTUTEN     C=(15,00),K='ZRST RESETSR'                      @BBAI20Y\n  DFHTUTEN     C=(16,00),K='ZRVS RECEIVE SPECIFIC'             @BBAI20Y\n  DFHTUTEN     C=(17,00),K='ZRVX RECEIVE EXIT'                 @BBAI20Y\n  DFHTUTEN     C=(18,00),K='ZSDS SEND'                         @BBAI20Y\n  DFHTUTEN     C=(19,00),K='ZSDX SEND DATA EXIT'               @BBAI20Y\n  DFHTUTEN     C=(1A,00),K='ZUCT TRANSLATE'                    @BBAI20Y\n  DFHTUTEN     C=(1B,00),K='ZUIX USER EXIT'                    @BBAI20Y\n  DFHTUTEN     C=(1C,00),K='ZACT ACTIVATE SCAN',NX=FZV         @BM13334\n  DFHTUTEN     C=(1D,00),K='ZSDR SEND RESPONSE'                @BBAI20Y\n  DFHTUTEN     C=(20,00),K='ZAIT ATTACH INIT'                  @BBAI20Y\n  DFHTUTEN     C=(21,00),K='ZASX ASYNC COM EXIT'               @BBAI20Y\n  DFHTUTEN     C=(22,00),K='ZCLS CLSDST'                       @BBAI20Y\n  DFHTUTEN     C=(23,00),K='ZCLX CLSDST EXIT'                  @BBAI20Y\n  DFHTUTEN     C=(24,00),K='ZDWE DWE PROCESS'                  @BBAI20Y\n  DFHTUTEN     C=(25,00),K='ZLEX LERAD EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(26,00),K='ZLGX LOGON EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(27,00),K='ZLRP LOGICAL REC PRES'             @BM10218\n  DFHTUTEN     C=(28,00),K='ZLTX LOSTERM EXIT'                 @BBAI20Y\n  DFHTUTEN     C=(29,00),K='ZOPN OPNDST'                       @BBAI20Y\n  DFHTUTEN     C=(2A,00),K='ZOPX OPNDST EXIT'                  @BBAI20Y\n  DFHTUTEN     C=(2B,00),K='ZRAQ READAHEAD QUEUING'            @BBAI20Y\n  DFHTUTEN     C=(2C,00),K='ZRAR READAHEAD RETRIEVAL'          @BM10378\n  DFHTUTEN     C=(2D,00),K='ZRPX RESPONSE EXIT *** DELETED' @EI226 @LAA\n  DFHTUTEN     C=(2E,00),K='ZRRX RELEASE REQ EXIT'             @BBAI20Y\n  DFHTUTEN     C=(2F,00),K='ZNSP NETWORK SERVICE EXIT'         @BBAI20Y\n  DFHTUTEN     C=(30,00),K='ZRSY RESYNC'                       @BBAI20Y\n  DFHTUTEN     C=(31,00),K='ZSAX SEND ASYNC EXIT'              @BBAI20Y\n  DFHTUTEN     C=(32,00),K='ZSCX SCIP EXIT'                    @BBAI20Y\n  DFHTUTEN     C=(33,00),K='ZSDA SEND ASYNC COMMAND'           @BBAI20Y\n  DFHTUTEN     C=(34,00),K='ZSKR SEND COMMAND RESPONSE'        @BBAI20Y\n  DFHTUTEN     C=(35,00),K='ZSES SESSIONC'                     @BBAI20Y\n  DFHTUTEN     C=(36,00),K='ZSEX SESSIONC EXIT'                @BBAI20Y\n  DFHTUTEN     C=(37,00),K='ZSIM SIMLOGON'                     @BBAI20Y\n  DFHTUTEN     C=(38,00),K='ZSIX SIMLOGON EXIT'                @BBAI20Y\n  DFHTUTEN     C=(39,00),K='ZSLS SETLOGON START'               @BBAI20Y\n  DFHTUTEN     C=(3A,00),K='ZSSX SEND COMMAND EXIT'            @BBAI20Y\n  DFHTUTEN     C=(3B,00),K='ZSYX SYNAD EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(3C,00),K='ZTAX TURNAROUND EXIT'              @BBAI20Y\n  DFHTUTEN     C=(3D,00),K='ZTPX TPEND EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(3E,00),K='ZOPA VTAM OPEN ACB'                @BBAI20Y\n  DFHTUTEN     C=(3F,00),K='ZSHU SHUTDOWN',NX=FCS              @BBDIA0Y\n  DFHTUTEN     C=(40,00),K='ZQUE QUEUEING'                     @BBDIA0Y\n  DFHTUTEN     C=(41,00),K='ZEMW ERROR MSG WRITER',NX=FZE      @BM13334\n  DFHTUTEN     C=(42,00),K='ZSYN SYNCPOINT',NX=FC1             @BM13334\n**DFHTUTEN     C=(43,00),K='ZTRA RPL TRACE'                    @BBDIA0Y\n  DFHTUTEN     C=(44,00),K='ZAND PC ABEND'                     @BBDIA0Y\n  DFHTUTEN     C=(45,00),K='ZCNA CONSOLE'                      @BBCIA0Y\n  DFHTUTEN     C=(46,00),K='ZCNR CONSOLE REQ'                  @BBCIA0Y\n  DFHTUTEN     C=(47,00),K='ZCNC CONSOLE ERR'                  @BBCIA0Y\n  DFHTUTEN     C=(48,00),K=' '                                 @BBDIA0Y\n  DFHTUTEN     C=(49,00),K=' '\n  DFHTUTEN     C=(4A,00),K='ZARL APPL REQ',NX=FCW           @EI00U @L6A\n  DFHTUTEN     C=(4B,00),K='ZARM MIGR REQ',NX=FCY           @EI00U @L6A\n  DFHTUTEN     C=(4C,00),K='ZRVL RECEIVE SPECIFIC'          @EI226 @LAA\n  DFHTUTEN     C=(4D,00),K='ZRLX RECEIVE EXIT'              @EI226 @LAA\n  DFHTUTEN     C=(4E,00),K='ZSDL SEND',NX=FSM               @EI00U @L6A\n  DFHTUTEN     C=(4F,00),K='ZSLX SEND EXIT'                 @EI00U @L6A\n  DFHTUTEN     C=(50,00),K='ZERH APPL ERP'                  @EI00U @L6A\n  DFHTUTEN     C=(51,00),K='ZLUS LU SERVICES',NX=FCZ        @EI00U @L6A\n  DFHTUTEN     C=(52,00),K='ZBKT',NX=FSG                    @EI226 @L8C\n  DFHTUTEN     C=(53,00),K='ZCNT',NX=FSD                    @EI226 @L8A\n  DFHTUTEN     C=(54,00),K='ZCHS',NX=FSJ                    @EI226 @L8C\n* DFHTUTEN     C=(55,00),K='Z*** RESERVED'\n  DFHTUTEN     C=(56,00),K='ZUSR',NX=FSA                    @EI226 @L8C\n* DFHTUTEN     C=(57,00),K='Z*** RESERVED'\n  DFHTUTEN     C=(58,00),K='ZEV1 ENCRYPTION VALIDATION 1'          @LNC\n  DFHTUTEN     C=(59,00),K='ZEV2 ENCRYPTION VALIDATION 2'          @LNC\n  DFHTUTEN     C=(5A,00),K='ZATD INSTALL ENTRY'                    @LTC\n  DFHTUTEN     C=(5B,00),K='ZATD INSTALL EXIT'                     @LTC\n  DFHTUTEN     C=(5C,00),K='ZATD DELETE ENTRY'                     @LTA\n  DFHTUTEN     C=(5D,00),K='ZATD DELETE EXIT'                      @LTA\n  DFHTUTEN     C=(5E,00),K='ZXRC XRF RECOVERY'                     @M4C\n  DFHTUTEN     C=(60,00),K='ZATD USER EXIT INSTALL'            @BA19267\n  DFHTUTEN     C=(61,00),K='ZATD USER EXIT INSTALL RETN'       @BA19267\n  DFHTUTEN     C=(62,00),K='ZATD USER EXIT DELETE'             @BA19267\n  DFHTUTEN     C=(63,00),K='ZATD USER EXIT DELETE RETN'        @BA19267\n*              ************************************************@BA18385\n  DFHTUTEN     C=(67,00),K='ZATS INSTALL ENTRY'                @BA18385\n  DFHTUTEN     C=(68,00),K='ZATS EXIT'                         @BA18385\n  DFHTUTEN     C=(69,00),K='ZATS DELETE ENTRY'                 @BA18385\n  DFHTUTEN     C=(6A,00),K='ZATS MASS FLAG ENTRY'              @BA18385\n  DFHTUTEN     C=(6B,00),K='ZATS MASS DELETE ENTRY'            @BA18385\n*              ********************************************************\n  DFHTUTEN     C=(81,00),K='ZNAC 1ST'                          @BM10771\n  DFHTUTEN     C=(82,00),K='ZNEP NEP'                          @BBAI20Y\n  DFHTUTEN     C=(83,00),K='ZNAC 2ND',NX=FC2                   @BM10771\n  DFHTUTEN     C=(84,00),K='ZRLG RESYNC SYSTEM TASK'           @BBAI20Y\n  DFHTUTEN     C=(85,00),K=' '                                 @BBAI20Y\n  DFHTUTEN     C=(86,00),K='ZGMM GOOD MORNING MSG'             @BM10771\n  DFHTUTEN     C=(87,00),K='ZRAC SEND RESPONSE RACE HANG'      @BA47100\n*              ********************************************************\n* DFHZCQ                                                              *\n  DFHTUTEN     C=(C0,00),K='DFHZCQ REQUEST ROUTER'                 @LHA\n  DFHTUTEN     C=(C1,00),K='ZCQIN INITIALIZE'                      @LHA\n  DFHTUTEN     C=(C2,00),K='ZBAN BIND ANALYSIS'                    @LHA\n  DFHTUTEN     C=(C3,00),K='ZCQCH CATALOG'                         @LHC\n  DFHTUTEN     C=(C4,00),K='ZCQDL DELETE'                          @LHA\n  DFHTUTEN     C=(C5,00),K='ZCQIT INSTALL TCTTE'                   @LHA\n  DFHTUTEN     C=(C6,00),K='ZCQRC RECOVER'                         @LHA\n  DFHTUTEN     C=(C7,00),K='ZCQRS RESTORE'                         @LHA\n  DFHTUTEN     C=(C8,00),K='ZCQIQ INQUIRE'                         @LHA\n  DFHTUTEN     C=(C9,00),K='ZCQIS INSTALL'                         @LHA\n* DFHTRZXP                                                            *\n  DFHTUTEN     C=(CA,00),K='TRZCP BUILD TERMINAL BPS'              @LHA\n  DFHTUTEN     C=(CB,00),K='TRZXP BUILD CONNECTION BPS'            @LHA\n  DFHTUTEN     C=(CC,00),K='TRZIP BUILD SESSIONS BPS'              @LHA\n  DFHTUTEN     C=(CD,00),K='TRZYP BUILD TYPE BPS'                  @LHA\n  DFHTUTEN     C=(CE,00),K='TRZPP BUILD POOL BPS'                  @LHA\n  DFHTUTEN     C=(CF,00),K='TRZZP MERGE TERMINAL AND TYPE BPS'     @LHA\n*              ********************************************************\n  DFHTUTEN     C=(D4,00),K='TCTTE NOT QUIESCENT YET'           @BA18977\n  DFHTUTEN     C=(D5,00),K='TCRPS EXECUTE STATUS ACTION'       @BA18977\n  DFHTUTEN     C=(D6,00),K='TCRPC EXECUTE CONTENTS ACTION'     @BA18977\n  DFHTUTEN     C=(D7,00),K='ZXRE XRF RECONNECTION PROGRAM'         @LWA\n  DFHTUTEN     C=(D8,00),K='ZXQO TRACKING QUEUE ORGANISER'         @LWA\n  DFHTUTEN     C=(D9,00),K='ZXST SESSION-STATE TRACKING'           @LWA\n  DFHTUTEN     C=(DA,00),K='ZXTR PUT/GET HEADER'                   @LWA\n  DFHTUTEN     C=(DB,00),K='ZXTR PUT/GET KEY'                      @LWC\n  DFHTUTEN     C=(DC,00),K='ZXTR PUT/GET DATA'                     @LWC\n  DFHTUTEN     C=(DD,00),K='ZXQO DIAGNOSTIC'                       @LWC\n  DFHTUTEN     C=(DE,00),K='ZXCU SESSION-STATE START'              @LWA\n  DFHTUTEN     C=(DF,00),K='ZXCU SESSION-STATE END'                @LWA\n*              ********************************************************\n* DFHTBS                                                              *\n  DFHTUTEN     C=(E1,00),K='TBSB(P) BUILD'                         @LHA\n  DFHTUTEN     C=(E2,00),K='TBSSP SYNCPOINT PROCESSOR'             @LHA\n  DFHTUTEN     C=(E3,00),K='TBSD(P) DESTROY'                       @LHA\n  DFHTUTEN     C=(E4,00),K='TBSR(P) RECOVER'                       @LHA\n  DFHTUTEN     C=(E5,00),K='TBSC(P) CHANGE'                        @LHA\n  DFHTUTEN     C=(E6,00),K='TBSM MESSAGE'                          @LHC\n  DFHTUTEN     C=(E7,00),K='TBSQ(P) INQUIRE'                       @LHA\n  DFHTUTEN     C=(E8,00),K='TBSL(P) CATALOG'                       @LHA\n*              ********************************************************\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\n*                                                                     *\n*        ZCP EXIT TABLE                                               *\nTUTB2FCE EQU   *                   ZCP RETURN                  @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(EE,00),K='EXIT TRACE',NX=FZA              @EI226 @LAA\n  DFHTUTEN     C=(01,00),K='ZARQ APPL REQ',NX=FCB              @BBAI20Y\n  DFHTUTEN     C=(02,00),K='ZLOC',NX=FZK                           @LGC\n  DFHTUTEN     C=(03,00),K='ZDET DETACH'                       @BBAI20Y\n  DFHTUTEN     C=(05,00),K='ZSUP START UP TASK'                @BBAI20Y\n  DFHTUTEN     C=(06,00),K='ZCRQ COMMAND REQS'                 @BBAI20Y\n**DFHTUTEN     C=(07,00),K='LENGTH NOT USED'                   @BBDIA0Y\n  DFHTUTEN     C=(08,00),K='ZSTU STATUS',NX=FCI                @BBDIA0Y\n  DFHTUTEN     C=(09,00),K='ZTSP TERMINAL SHARING',NX=FCT      @BBDJ20B\n  DFHTUTEN     C=(0A,00),K='RPL EXECUTOR'                      @BBAI20Y\n  DFHTUTEN     C=(0B,00),K='ZISP ISC',NX=FCL                   @BBAI20Y\n  DFHTUTEN     C=(0C,00),K='ZIS1 ISC',NX=FCM                   @BBAI20Y\n  DFHTUTEN     C=(0D,00),K='ZIS2 IRC',NX=FCN                   @BBAI20Y\n  DFHTUTEN     C=(0E,00),K='ZABD ABEND '                       @BBAI20Y\n* DFHTUTEN     C=(0F,00),K='Z*** RESERVED'                     @BBDIA0Y\n  DFHTUTEN     C=(10,00),K='ZATI A.T.I'                        @BBAI20Y\n  DFHTUTEN     C=(11,00),K='ZATT ATTACH'                       @BBAI20Y\n  DFHTUTEN     C=(12,00),K='ZFRE FREEMAIN'                     @BBAI20Y\n  DFHTUTEN     C=(13,00),K='ZGET GETMAIN'                      @BBAI20Y\n  DFHTUTEN     C=(14,00),K='ZRAC RECEIVE ANY '                 @BM10218\n  DFHTUTEN     C=(15,00),K='ZRST RESETSR'                      @BBAI20Y\n  DFHTUTEN     C=(16,00),K='ZRVS RECEIVE SPECIFIC'             @BBAI20Y\n  DFHTUTEN     C=(17,00),K='ZRVX RECEIVE EXIT'                 @BBAI20Y\n  DFHTUTEN     C=(18,00),K='ZSDS SEND'                         @BBAI20Y\n  DFHTUTEN     C=(19,00),K='ZSDX SEND DATA EXIT'               @BBAI20Y\n  DFHTUTEN     C=(1A,00),K='ZUCT TRANSLATE'                    @BBAI20Y\n  DFHTUTEN     C=(1B,00),K='ZUIX USER EXIT'                    @BBAI20Y\n  DFHTUTEN     C=(1C,00),K='ZACT ACTIVATE SCAN',NX=FZV         @BM13334\n  DFHTUTEN     C=(1D,00),K='ZSDR SEND RESPONSE'                @BBAI20Y\n  DFHTUTEN     C=(20,00),K='ZAIT ATTACH INIT'                  @BBAI20Y\n  DFHTUTEN     C=(21,00),K='ZASX ASYNC COM EXIT'               @BBAI20Y\n  DFHTUTEN     C=(22,00),K='ZCLS CLSDST'                       @BBAI20Y\n  DFHTUTEN     C=(23,00),K='ZCLX CLSDST EXIT'                  @BBAI20Y\n  DFHTUTEN     C=(24,00),K='ZDWE DWE PROCESS'                  @BBAI20Y\n  DFHTUTEN     C=(25,00),K='ZLEX LERAD EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(26,00),K='ZLGX LOGON EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(27,00),K='ZLRP LOGICAL REC PRES'             @BM10218\n  DFHTUTEN     C=(28,00),K='ZLTX LOSTERM EXIT'                 @BBAI20Y\n  DFHTUTEN     C=(29,00),K='ZOPN OPNDST'                       @BBAI20Y\n  DFHTUTEN     C=(2A,00),K='ZOPX OPNDST EXIT'                  @BBAI20Y\n  DFHTUTEN     C=(2B,00),K='ZRAQ READAHEAD QUEUING'            @BBAI20Y\n  DFHTUTEN     C=(2C,00),K='ZRAR READAHEAD RETRIEVAL'          @BM10378\n  DFHTUTEN     C=(2D,00),K='ZRPX RESPONSE EXIT *** DELETED' @EI226 @LAC\n  DFHTUTEN     C=(2E,00),K='ZRRX RELEASE REQ EXIT'             @BBAI20Y\n  DFHTUTEN     C=(2F,00),K='ZNSP NETWORK SERVICE EXIT'         @BBAI20Y\n  DFHTUTEN     C=(30,00),K='ZRSY RESYNC'                       @BBAI20Y\n  DFHTUTEN     C=(31,00),K='ZSAX SEND ASYNC EXIT'              @BBAI20Y\n  DFHTUTEN     C=(32,00),K='ZSCX SCIP EXIT'                    @BBAI20Y\n  DFHTUTEN     C=(33,00),K='ZSDA SEND ASYNC COMMAND'           @BBAI20Y\n  DFHTUTEN     C=(34,00),K='ZSKR SEND COMMAND RESPONSE'        @BBAI20Y\n  DFHTUTEN     C=(35,00),K='ZSES SESSIONC'                     @BBAI20Y\n  DFHTUTEN     C=(36,00),K='ZSEX SESSIONC EXIT'                @BBAI20Y\n  DFHTUTEN     C=(37,00),K='ZSIM SIMLOGON'                     @BBAI20Y\n  DFHTUTEN     C=(38,00),K='ZSIX SIMLOGON EXIT'                @BBAI20Y\n  DFHTUTEN     C=(39,00),K='ZSLS SETLOGON START'               @BBAI20Y\n  DFHTUTEN     C=(3A,00),K='ZSSX SEND COMMAND EXIT'            @BBAI20Y\n  DFHTUTEN     C=(3B,00),K='ZSYX SYNAD EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(3C,00),K='ZTAX TURNAROUND EXIT'              @BBAI20Y\n  DFHTUTEN     C=(3D,00),K='ZTPX TPEND EXIT'                   @BBAI20Y\n  DFHTUTEN     C=(3E,00),K='ZOPA VTAM OPEN ACB'                @BBAI20Y\n  DFHTUTEN     C=(3F,00),K='ZSHU SHUTDOWN',NX=FCS              @BBDIA0Y\n  DFHTUTEN     C=(40,00),K='ZQUE QUEUEING'                     @BBDIA0Y\n  DFHTUTEN     C=(41,00),K='ZEMW ERROR MSG WRITER',NX=FZE      @BM13334\n  DFHTUTEN     C=(42,00),K='ZSYN SYNCPOINT',NX=FC1             @BM13334\n**DFHTUTEN     C=(43,00),K='ZTRA RPL TRACE'                    @BBDIA0Y\n  DFHTUTEN     C=(44,00),K='ZAND PC ABEND'                     @BBDIA0Y\n  DFHTUTEN     C=(45,00),K='ZCNA CONSOLE'                      @BBCIA0Y\n  DFHTUTEN     C=(46,00),K='ZCNR CONSOLE REQ'                  @BBCIA0Y\n  DFHTUTEN     C=(47,00),K='ZCNC CONSOLE ERR'                  @BBCIA0Y\n  DFHTUTEN     C=(48,00),K=' '                                 @BBDIA0Y\n  DFHTUTEN     C=(49,00),K=' '\n  DFHTUTEN     C=(4A,00),K='ZARL APPL REQ',NX=FCX           @EI00U @L6A\n  DFHTUTEN     C=(4B,00),K='ZARM MIGR REQ',NX=FCY           @EI00U @L6A\n  DFHTUTEN     C=(4C,00),K='ZRVL RECEIVE SPECIFIC',NX=FSS   @EI226 @LAC\n  DFHTUTEN     C=(4D,00),K='ZRLX RECEIVE EXIT'              @EI226 @LAC\n  DFHTUTEN     C=(4E,00),K='ZSDL SEND'                      @EI00U @L6A\n  DFHTUTEN     C=(4F,00),K='ZSLX SEND EXIT'                 @EI00U @L6A\n  DFHTUTEN     C=(50,00),K='ZERH APPL ERP'                  @EI00U @L6A\n  DFHTUTEN     C=(51,00),K='ZLUS LU SERVICES',NX=FCZ        @EI00U @L6A\n  DFHTUTEN     C=(52,00),K='ZBKT',NX=FSG                    @EI226 @L8C\n  DFHTUTEN     C=(53,00),K='ZCNT',NX=FSD                    @EI226 @L8A\n  DFHTUTEN     C=(54,00),K='ZCHS',NX=FSJ                    @EI226 @L8C\n* DFHTUTEN     C=(55,00),K='Z*** RESERVED'\n  DFHTUTEN     C=(56,00),K='ZUSR',NX=FSA                    @EI226 @L8C\n* DFHTUTEN     C=(57,00),K='Z*** RESERVED'\n* DFHTUTEN     C=(58,00),K='ZEV1 ENCRYPTION VALIDATION 1'          @LNC\n* DFHTUTEN     C=(59,00),K='ZEV2 ENCRYPTION VALIDATION 2'          @LNC\n* DFHTUTEN     C=(5A,00),K='ZATD INSTALL ENTRY'                    @LTC\n* DFHTUTEN     C=(5B,00),K='ZATD INSTALL EXIT'                     @LTC\n* DFHTUTEN     C=(5C,00),K='ZATD DELETE ENTRY'                     @LTA\n* DFHTUTEN     C=(5D,00),K='ZATD DELETE EXIT'                      @LTA\n  DFHTUTEN     C=(5E,00),K='ZXRC XRF RECOVERY'                     @M4C\n*              ********************************************************\n  DFHTUTEN     C=(81,00),K='ZNAC 1ST'                          @BM10771\n  DFHTUTEN     C=(82,00),K='ZNEP NEP'                          @BBAI20Y\n  DFHTUTEN     C=(83,00),K='ZNAC 2ND',NX=FC2                   @BM10771\n  DFHTUTEN     C=(84,00),K='ZRLG RESYNC SYSTEM TASK'           @BBAI20Y\n  DFHTUTEN     C=(85,00),K=' '                                 @BBAI20Y\n  DFHTUTEN     C=(86,00),K='ZGMM GOOD MORNING MSG'             @BM10771\n*              ********************************************************\n* DFHZCQ                                                              *\n  DFHTUTEN     C=(C0,00),K='DFHZCQ REQUEST ROUTER'                 @LHA\n  DFHTUTEN     C=(C1,00),K='ZCQIN INITIALIZE'                      @LHA\n  DFHTUTEN     C=(C2,00),K='ZBAN BIND ANALYSIS'                    @LHA\n  DFHTUTEN     C=(C3,00),K='ZCQCH CATALOG'                         @LHC\n  DFHTUTEN     C=(C4,00),K='ZCQDL DELETE'                          @LHA\n  DFHTUTEN     C=(C5,00),K='ZCQIT INSTALL TCTTE'                   @LHA\n  DFHTUTEN     C=(C6,00),K='ZCQRC RECOVER'                         @LHA\n  DFHTUTEN     C=(C7,00),K='ZCQRS RESTORE'                         @LHA\n  DFHTUTEN     C=(C8,00),K='ZCQIQ INQUIRE'                         @LHA\n  DFHTUTEN     C=(C9,00),K='ZCQIS INSTALL'                         @LHA\n* DFHTRZXP                                                            *\n  DFHTUTEN     C=(CA,00),K='TRZCP BUILD TERMINAL BPS'              @LHA\n  DFHTUTEN     C=(CB,00),K='TRZXP BUILD CONNECTION BPS'            @LHA\n  DFHTUTEN     C=(CC,00),K='TRZIP BUILD SESSIONS BPS'              @LHA\n  DFHTUTEN     C=(CD,00),K='TRZYP BUILD TYPE BPS'                  @LHA\n  DFHTUTEN     C=(CE,00),K='TRZPP BUILD POOL BPS'                  @LHA\n  DFHTUTEN     C=(CF,00),K='TRZZP MERGE TERMINAL AND TYPE BPS'     @LHA\n*              ************************************************@BA18977\n  DFHTUTEN     C=(D4,00),K='TCTTE NOT QUIESCENT YET'           @BA18977\n  DFHTUTEN     C=(D5,00),K='TCRPS EXECUTE STATUS ACTION'       @BA18977\n  DFHTUTEN     C=(D6,00),K='TCRPC EXECUTE CONTENTS ACTION'     @BA18977\n  DFHTUTEN     C=(D7,00),K='ZXRE XRF RECONNECTION PROGRAM'         @LWA\n  DFHTUTEN     C=(D8,00),K='ZXQO TRACKING QUEUE ORGANISER'         @LWA\n  DFHTUTEN     C=(D9,00),K='ZXST SESSION-STATE TRACKING'           @LWA\n* DFHTUTEN     C=(DA,00),K='ZXTR PUT/GET HEADER'                   @LWA\n* DFHTUTEN     C=(DB,00),K='ZXTR PUT/GET KEY'                      @LWC\n* DFHTUTEN     C=(DC,00),K='ZXTR PUT/GET DATA'                     @LWC\n* DFHTUTEN     C=(DD,00),K='ZXQO DIAGNOSTIC'\n* DFHTUTEN     C=(DE,00),K='ZXCU SESSION-STATE START'\n* DFHTUTEN     C=(DF,00),K='ZXCU SESSION-STATE END'\n*              ********************************************************\n* DFHTBS                                                              *\n  DFHTUTEN     C=(E1,00),K='TBSB(P) BUILD'                         @LHA\n  DFHTUTEN     C=(E2,00),K='TBSSP SYNCPOINT PROCESSOR'             @LHA\n  DFHTUTEN     C=(E3,00),K='TBSD(P) DESTROY'                       @LHA\n  DFHTUTEN     C=(E4,00),K='TBSR(P) RECOVER'                       @LHA\n  DFHTUTEN     C=(E5,00),K='TBSC(P) CHANGE'                        @LHA\n  DFHTUTEN     C=(E6,00),K='TBSM MESSAGE'                          @LHC\n  DFHTUTEN     C=(E7,00),K='TBSQ(P) INQUIRE'                       @LHA\n  DFHTUTEN     C=(E8,00),K='TBSL(P) CATALOG'                       @LHA\n*              ********************************************************\n  DFHTUTEN     C=(FF,FF),K=                                    @BBAI20Y\n*                                                                     *\nTUTB2FZA EQU   *              ZCP EXIT TRACE ENTRY          @EI226 @LAA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FZB           @EI226 @LAA\n  DFHTUTEN     C=(17),K='ZRVX'                              @EI226 @LAA\n  DFHTUTEN     C=(19),K='ZSDX'                              @EI226 @LAA\n  DFHTUTEN     C=(21),K='ZASX'                              @EI226 @LAA\n  DFHTUTEN     C=(23),K='ZCLX'                              @EI226 @LAA\n  DFHTUTEN     C=(25),K='ZLEX'                              @EI226 @LAA\n  DFHTUTEN     C=(26),K='ZLGX'                              @EI226 @LAA\n  DFHTUTEN     C=(28),K='ZLTX'                              @EI226 @LAA\n  DFHTUTEN     C=(2A),K='ZOPX'                              @EI226 @LAA\n  DFHTUTEN     C=(2E),K='ZRRX'                              @EI226 @LAA\n  DFHTUTEN     C=(2F),K='ZNSP'                              @EI226 @LAA\n  DFHTUTEN     C=(31),K='ZSAX'                              @EI226 @LAA\n  DFHTUTEN     C=(32),K='ZSCX'                              @EI226 @LAA\n  DFHTUTEN     C=(36),K='ZSEX'                              @EI226 @LAA\n  DFHTUTEN     C=(38),K='ZSIX'                              @EI226 @LAA\n  DFHTUTEN     C=(3A),K='ZSSX'                              @EI226 @LAA\n  DFHTUTEN     C=(3B),K='ZSYX'                              @EI226 @LAA\n  DFHTUTEN     C=(3C),K='ZTAX'                              @EI226 @LAA\n  DFHTUTEN     C=(3D),K='ZTPX'                              @EI226 @LAA\n  DFHTUTEN     C=(4D),K='ZRLX'                              @EI226 @LAA\n  DFHTUTEN     C=(4F),K='ZSLX'                              @EI226 @LAA\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @LAP\n*                                                                     *\nTUTB2FZB EQU   *              ZCP EXIT TRACE ENTRY          @EI226 @LAA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=FZC           @EI226 @LAA\n  DFHTUTEN     C=(17),K='ZRVX'                              @EI226 @LAA\n  DFHTUTEN     C=(19),K='ZSDX'                              @EI226 @LAA\n  DFHTUTEN     C=(21),K='ZASX'                              @EI226 @LAA\n  DFHTUTEN     C=(23),K='ZCLX'                              @EI226 @LAA\n  DFHTUTEN     C=(25),K='ZLEX'                              @EI226 @LAA\n  DFHTUTEN     C=(26),K='ZLGX'                              @EI226 @LAA\n  DFHTUTEN     C=(28),K='ZLTX'                              @EI226 @LAA\n  DFHTUTEN     C=(2A),K='ZOPX'                              @EI226 @LAA\n  DFHTUTEN     C=(2E),K='ZRRX'                              @EI226 @LAA\n  DFHTUTEN     C=(2F),K='ZNSP'                              @EI226 @LAA\n  DFHTUTEN     C=(31),K='ZSAX'                              @EI226 @LAA\n  DFHTUTEN     C=(32),K='ZSCX'                              @EI226 @LAA\n  DFHTUTEN     C=(36),K='ZSEX'                              @EI226 @LAA\n  DFHTUTEN     C=(38),K='ZSIX'                              @EI226 @LAA\n  DFHTUTEN     C=(3A),K='ZSSX'                              @EI226 @LAA\n  DFHTUTEN     C=(3B),K='ZSYX'                              @EI226 @LAA\n  DFHTUTEN     C=(3C),K='ZTAX'                              @EI226 @LAA\n  DFHTUTEN     C=(3D),K='ZTPX'                              @EI226 @LAA\n  DFHTUTEN     C=(4D),K='ZRLX'                              @EI226 @LAA\n  DFHTUTEN     C=(4F),K='ZSLX'                              @EI226 @LAA\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @LAP\n*                                                                     *\nTUTB2FZC EQU   *              ZCP EXIT TRACE ENTRY          @EI226 @LAA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A2,E=DFT,NX=FZD           @EI226 @LAA\n  DFHTUTEN     C=(17),K='ZRVX'                              @EI226 @LAA\n  DFHTUTEN     C=(19),K='ZSDX'                              @EI226 @LAA\n  DFHTUTEN     C=(21),K='ZASX'                              @EI226 @LAA\n  DFHTUTEN     C=(23),K='ZCLX'                              @EI226 @LAA\n  DFHTUTEN     C=(25),K='ZLEX'                              @EI226 @LAA\n  DFHTUTEN     C=(26),K='ZLGX'                              @EI226 @LAA\n  DFHTUTEN     C=(28),K='ZLTX'                              @EI226 @LAA\n  DFHTUTEN     C=(2A),K='ZOPX'                              @EI226 @LAA\n  DFHTUTEN     C=(2E),K='ZRRX'                              @EI226 @LAA\n  DFHTUTEN     C=(2F),K='ZNSP'                              @EI226 @LAA\n  DFHTUTEN     C=(31),K='ZSAX'                              @EI226 @LAA\n  DFHTUTEN     C=(32),K='ZSCX'                              @EI226 @LAA\n  DFHTUTEN     C=(36),K='ZSEX'                              @EI226 @LAA\n  DFHTUTEN     C=(38),K='ZSIX'                              @EI226 @LAA\n  DFHTUTEN     C=(3A),K='ZSSX'                              @EI226 @LAA\n  DFHTUTEN     C=(3B),K='ZSYX'                              @EI226 @LAA\n  DFHTUTEN     C=(3C),K='ZTAX'                              @EI226 @LAA\n  DFHTUTEN     C=(3D),K='ZTPX'                              @EI226 @LAA\n  DFHTUTEN     C=(4D),K='ZRLX'                              @EI226 @LAA\n  DFHTUTEN     C=(4F),K='ZSLX'                              @EI226 @LAA\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @LAP\n*                                                                     *\nTUTB2FZD EQU   *              ZCP EXIT TRACE ENTRY          @EI226 @LAA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A3,E=DFT,NX=SRT           @EI226 @LAA\n  DFHTUTEN     C=(17),K='ZRVX'                              @EI226 @LAA\n  DFHTUTEN     C=(19),K='ZSDX'                              @EI226 @LAA\n  DFHTUTEN     C=(21),K='ZASX'                              @EI226 @LAA\n  DFHTUTEN     C=(23),K='ZCLX'                              @EI226 @LAA\n  DFHTUTEN     C=(25),K='ZLEX'                              @EI226 @LAA\n  DFHTUTEN     C=(26),K='ZLGX'                              @EI226 @LAA\n  DFHTUTEN     C=(28),K='ZLTX'                              @EI226 @LAA\n  DFHTUTEN     C=(2A),K='ZOPX'                              @EI226 @LAA\n  DFHTUTEN     C=(2E),K='ZRRX'                              @EI226 @LAA\n  DFHTUTEN     C=(2F),K='ZNSP'                              @EI226 @LAA\n  DFHTUTEN     C=(31),K='ZSAX'                              @EI226 @LAA\n  DFHTUTEN     C=(32),K='ZSCX'                              @EI226 @LAA\n  DFHTUTEN     C=(36),K='ZSEX'                              @EI226 @LAA\n  DFHTUTEN     C=(38),K='ZSIX'                              @EI226 @LAA\n  DFHTUTEN     C=(3A),K='ZSSX'                              @EI226 @LAA\n  DFHTUTEN     C=(3B),K='ZSYX'                              @EI226 @LAA\n  DFHTUTEN     C=(3C),K='ZTAX'                              @EI226 @LAA\n  DFHTUTEN     C=(3D),K='ZTPX'                              @EI226 @LAA\n  DFHTUTEN     C=(4D),K='ZRLX'                              @EI226 @LAA\n  DFHTUTEN     C=(4F),K='ZSLX'                              @EI226 @LAA\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @LAP\n*                                                                     *\nTUTB2FZK EQU   *              ZLOC EXIT TRACE                      @LGA\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A3,E=DFT,NX=SRT                  @LGA\n  DFHTUTEN     C=(00),K='NORMAL'                                   @LGA\n  DFHTUTEN     C=(F0),K='LAST ENTRY'                               @LGA\n  DFHTUTEN     C=(F1),K='INVALID REQUEST'                          @LGA\n  DFHTUTEN     C=(F2),K='INVALID ID'                               @LGA\n  DFHTUTEN     C=(F3),K='INVALID ADDRESS'                          @LGA\n  DFHTUTEN     C=(F9),K='NOT LU6.2'                                @LGA\n  DFHTUTEN     C=(FA),K='BUSY'                                     @LGA\n  DFHTUTEN     C=(FF,FF),K=                                        @LGA\n*                                                                     *\nTUTB2FCB EQU   *              ZARQ PLIST                       @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BBAI20Y\n  DFHTUTEN     C=(00,00),K=' ',NX=FCF                          @BBAI20Y\n  DFHTUTEN     C=(01,00),K='SIGNAL'                            @BM13399\n  DFHTUTEN     C=(02,00),K='WRITE',NX=FCF                      @BM13399\n  DFHTUTEN     C=(03,00),K='CONVERSE',NX=FCF                   @BM13399\n  DFHTUTEN     C=(04,00),K='READ',NX=FCF                       @BM13399\n  DFHTUTEN     C=(05,00),K='FLUSH',NX=FCF                      @BM13399\n  DFHTUTEN     C=(06,00),K='CANCEL',NX=FCF                     @BM13399\n  DFHTUTEN     C=(20,00),K='CLSDST PASS'                           @LNA\n  DFHTUTEN     C=(40,00),K='PROGRAM REQ'                       @BM13399\n  DFHTUTEN     C=(80,00),K='EOD REQ'                           @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\nTUTB2FCF EQU   *                                               @BM13399\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FCG               @BBAI20Y\n  DFHTUTEN     C=(02),K='CONVERSE'                             @BBDIA0Y\n  DFHTUTEN     C=(80),K='ERASE'                                @BBDIA0Y\n  DFHTUTEN     C=(01),K='WRITE'                                @BBAI20Y\n  DFHTUTEN     C=(10),K='READ'                                 @BM10519\n  DFHTUTEN     C=(04),K='WAIT'                                 @BM10519\n  DFHTUTEN     C=(40),K='SAVE'                                 @BM10519\n  DFHTUTEN     C=(20),K='LINEADDR'                             @BBAI20Y\n  DFHTUTEN     C=(08),K='DISC'                                 @BM10519\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\nTUTB2FCG EQU   *                                               @BM13334\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=FZG               @BM13334\n**DFHTUTEN     C=(80),K='CCOMPL=NO'                            @BM13334\n**DFHTUTEN     C=(40),K='TCTTEADDR'                            @BM13334\n  DFHTUTEN     C=(04),K='DEFER'                                @BM13334\n  DFHTUTEN     C=(20),K='COND'                                 @BM13334\n  DFHTUTEN     C=(02),K='INVITE'                               @BM13334\n  DFHTUTEN     C=(10),K='STRFIELD'                             @BM13334\n**DFHTUTEN     C=(08),K='TRANSPARENT TIOA'                     @BM13334\n**DFHTUTEN     C=(01),K=' '        RESERVED                    @BM13334\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\nTUTB2FZG EQU   *                                               @BM13334\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DFT,NX=FCQ               @BM10519\n  DFHTUTEN     C=(08),K='COPY'                                 @BM10519\n  DFHTUTEN     C=(04),K='PRINT'                                @BM10519\n  DFHTUTEN     C=(80),K='READBUF'                              @BM10519\n  DFHTUTEN     C=(40),K='ERASEUNPRO'                           @BM10519\n  DFHTUTEN     C=(01),K='PSEUDO'                               @BM10519\n  DFHTUTEN     C=(02),K='TRANSPARENT'                          @BM10519\n  DFHTUTEN     C=(10),K='READLOCK'                             @BM10519\n  DFHTUTEN     C=(20),K='WRITELOCK'                            @BM10519\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10218\n*  ALSO BRANCHED TO FROM ZIS1 DECODING                                *\nTUTB2FCQ EQU   *                                               @BM10218\n  DFHTUTEN     T=(2,I),CP=TM,OFF=B0,E=DFT,NX=SRT               @BM10218\n  DFHTUTEN     C=(08),K='LAST'                                 @BM10218\n  DFHTUTEN     C=(10),K='FMH'                                  @BM10218\n  DFHTUTEN     C=(20),K='LDC'                                  @BM10218\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10218\n*                                                                     *\nTUTB2FCR EQU   *              ZLOC PLIST                       @BBAI20Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FCH              @BM13334\n  DFHTUTEN     C=(01,00),K='LOC REQ',NX=FZH                    @BM13311\n  DFHTUTEN     C=(02,00),K='ATI REQ',NX=FCH                    @BM13311\n  DFHTUTEN     C=(04,00),K='STATUS REQ',NX=FCH                 @BM13311\n  DFHTUTEN     C=(08,00),K='LDC REQ',NX=FCH                    @BM13311\n  DFHTUTEN     C=(09,00),K='LDC REQ',NX=FCH                    @BM13311\n  DFHTUTEN     C=(10,00),K='LOCNETN',NX=FCH                    @BM13311\n  DFHTUTEN     C=(20,00),K='SYNC POINT REQ',NX=SRT             @BM13311\n  DFHTUTEN     C=(21,00),K='RECOVER REQ',NX=SRT                @BM13311\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13311\nTUTB2FZH EQU   *                   LOCATE REQUESTS                 @LGC\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=FCK                  @LGC\n  DFHTUTEN     C=(00),K='ADDR LOCAL'                           @BM13311\n  DFHTUTEN     C=(01),K='ID LOCAL'                             @BM13311\n  DFHTUTEN     C=(02),K='NEXT LOCAL'                           @BM13311\n  DFHTUTEN     C=(04),K='FIRST LOCAL'                          @BM13311\n  DFHTUTEN     C=(05),K='NETNAME LOCAL'                        @BM13311\n  DFHTUTEN     C=(08),K='ADDR SYSTEM'                              @LGC\n  DFHTUTEN     C=(09),K='ID SYSTEM'                                @LGC\n  DFHTUTEN     C=(0A),K='NEXT SYSTEM'                              @LGC\n  DFHTUTEN     C=(0C),K='FIRST SYSTEM'                             @LGC\n  DFHTUTEN     C=(10),K='ADDR REMOTE'                          @BM13311\n  DFHTUTEN     C=(11),K='ID REMOTE'                            @BM13311\n  DFHTUTEN     C=(12),K='NEXT REMOTE'                          @BM13311\n  DFHTUTEN     C=(13),K='UNIQUE REMOTE'                        @BM13311\n  DFHTUTEN     C=(14),K='FIRST REMOTE'                         @BM13311\n  DFHTUTEN     C=(18),K='ADDR GLOBAL'                          @BM13311\n  DFHTUTEN     C=(19),K='ID GLOBAL'                            @BM13311\n  DFHTUTEN     C=(1A),K='NEXT GLOBAL'                          @BM13311\n  DFHTUTEN     C=(1B),K='UNIQUE GLOBAL'                        @BM13311\n  DFHTUTEN     C=(1C),K='FIRST GLOBAL'                         @BM13311\n  DFHTUTEN     C=(22),K='NEXT NETNAME'                         @BM13311\n  DFHTUTEN     C=(24),K='FIRST NETNAME'                        @BM13311\n  DFHTUTEN     C=(25),K='NETNAME'                              @BM13311\n  DFHTUTEN     C=(2A),K='NEXT SESSION'                         @BM13311\n  DFHTUTEN     C=(2C),K='FIRST SESSION'                        @BM13311\n  DFHTUTEN     C=(32),K='NEXT LUCSESS'                             @LGA\n  DFHTUTEN     C=(34),K='FIRST LUCSESS'                            @LGA\n  DFHTUTEN     C=(3A),K='NEXT LUCMODE'                             @LGA\n  DFHTUTEN     C=(3C),K='FIRST LUCMODE'                            @LGA\n  DFHTUTEN     C=(41),K='ID LUC'                                   @LGA\n  DFHTUTEN     C=(46),K='SID'                                      @LGA\n  DFHTUTEN     C=(4A),K='NEXT POOL'                                @LGA\n  DFHTUTEN     C=(4C),K='FIRST POOL'                               @LGA\n  DFHTUTEN     C=(52),K='NEXT IRC'                                 @LGA\n  DFHTUTEN     C=(54),K='FIRST IRC'                                @LGA\n  DFHTUTEN     C=(5A),K='NEXT SURRG'                               @LGA\n  DFHTUTEN     C=(5C),K='FIRST SURRG'                              @LGA\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13311\nTUTB2FCK EQU   *                                                   @LGA\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT                   @LGA\n  DFHTUTEN     C=(08),K='NOWAIT'                                   @P7C\n  DFHTUTEN     C=(FF,FF),K=                                        @LGA\n*                                                                     *\nTUTB2FCH EQU   *                   ATI REQUESTS                    @LGC\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT               @BM13311\n**DFHTUTEN     C=(00),K='ADDR'                                 @BM13311\n  DFHTUTEN     C=(01),K='IDREQ'                                @BM13311\n  DFHTUTEN     C=(02),K='NEXT'                                 @BM13311\n  DFHTUTEN     C=(C0),K='GLOBAL'                               @BM13311\n  DFHTUTEN     C=(80),K='REMOTE'                               @BM13311\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13311\nTUTB2FCI EQU   *                   STATUS REQUESTS             @BM13311\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DFT,NX=FCJ               @BM13311\n  DFHTUTEN     C=(01),K='ACQUIRE'                              @BM13311\n  DFHTUTEN     C=(02),K='COLD'                                 @BM13311\n  DFHTUTEN     C=(04),K='RELEASE'                              @BM13311\n  DFHTUTEN     C=(08),K='PURGE'                                @BA25243\n  DFHTUTEN     C=(10),K='FORCE-PURGE'                          @BA25243\n  DFHTUTEN     C=(20),K='NOINTLOG'                             @BA25243\n  DFHTUTEN     C=(40),K='INTLOG'                               @BA25243\n  DFHTUTEN     C=(80),K='LUCOUT'                               @BA25243\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13311\nTUTB2FCJ EQU   *                                               @BM13311\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT               @BM13311\n  DFHTUTEN     C=(01),K='OUTSRV'                               @BM13311\n  DFHTUTEN     C=(02),K='INSRV'                                @BM13311\n  DFHTUTEN     C=(04),K='TRANS'                                @BM13311\n  DFHTUTEN     C=(08),K='TRANSCEIVE'                           @BM13311\n  DFHTUTEN     C=(10),K='RCV NOPOLL'                           @BM13311\n  DFHTUTEN     C=(20),K='INPUT AUTOPAGE'                       @BM13311\n  DFHTUTEN     C=(40),K='AUTOPAGE'                             @BM13311\n  DFHTUTEN     C=(80),K='PAGE'                                 @BM13311\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13311\nTUTB2FCL EQU   *                   ISP ENTRY                   @BM13311\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BM13311\n  DFHTUTEN     C=(01),K='ALLOCATE',NX=FZL                      @BM13311\n  DFHTUTEN     C=(02),K='POINT'                                @BM13311\n  DFHTUTEN     C=(03),K='FREE'                                 @BM13311\n  DFHTUTEN     C=(04),K='FREE DETACH'                          @BM13399\n  DFHTUTEN     C=(05),K='FREE ALL'                             @BM13399\n  DFHTUTEN     C=(06),K='LU6.2 ALLOCATE'                    @EI00U @L6A\n  DFHTUTEN     C=(07),K='LU6.2 FREE'                        @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\n*                                                                     *\nTUTB2FZL EQU   *                   ISP ENTRY                   @BM13334\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT               @BM13334\n  DFHTUTEN     C=(80),K='FREESYNC'                             @BM13334\n  DFHTUTEN     C=(40),K='FREEDET'                              @BM13334\n  DFHTUTEN     C=(20),K='FREEREST'                             @BM13334\n  DFHTUTEN     C=(10),K='UNPROT'                               @BM13334\n  DFHTUTEN     C=(08),K='Q'                                    @BM13334\n  DFHTUTEN     C=(01),K='ID'                                   @BM13334\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\n*                                                                     *\nTUTB2FCM EQU   *                   IS1 ENTRY                   @BM13334\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FCQ              @BM13334\n  DFHTUTEN     C=(01),K='PREPARE'                              @BM10700\n  DFHTUTEN     C=(02),K='SPR REQUEST'                          @BM10700\n  DFHTUTEN     C=(03),K='COMMIT'                               @BM10700\n  DFHTUTEN     C=(04),K='ABORT'                                @BM10700\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10700\n*                                                                     *\nTUTB2FC1 EQU   *                   ZSYN EXIT                   @BM13334\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BM13334\n**DFHTUTEN     C=(20),K='SYNCPOINT'                            @BM13334\n  DFHTUTEN     C=(21),K='RECOVER'                              @BM13334\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13334\n*                                                                     *\nTUTB2FC2 EQU   *                   ZNAC SECOND                 @BM10700\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=FC3               @BM13334\n  DFHTUTEN     C=(80),K='INTLOG'                               @BM13334\n  DFHTUTEN     C=(40),K='NOINTLOG'                             @BM13334\n  DFHTUTEN     C=(10),K='CLSDST NORM'                          @BBDIA0Y\n  DFHTUTEN     C=(08),K='CLSDST SOFT'                          @BBDIA0Y\n  DFHTUTEN     C=(04),K='NEG RESP'                             @BBDIA0Y\n  DFHTUTEN     C=(02),K='OUTSERV'   OUT OF SERVICE             @BBDIA0Y\n  DFHTUTEN     C=(01),K='CLSDST ABNORM'                        @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2FC3 EQU   *                   ZNAC SECOND CONTINUED       @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FC4               @BBDIA0Y\n  DFHTUTEN     C=(20),K='ABTASK'                               @BM13334\n  DFHTUTEN     C=(80),K='ABSEND'                               @BM13334\n  DFHTUTEN     C=(40),K='ABRECV'                               @BM13334\n  DFHTUTEN     C=(08),K='GMM'                                  @BBDIA0Y\n  DFHTUTEN     C=(02),K='SIMLOG'                               @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2FC4 EQU   *                   ZNAC SECOND CONTINUED       @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=SRT               @BBDIA0Y\n  DFHTUTEN     C=(80),K='PRTACT'                               @BBDIA0Y\n  DFHTUTEN     C=(40),K='PRTRPL'                               @BBDIA0Y\n  DFHTUTEN     C=(20),K='PRTTCT'                               @BBDIA0Y\n  DFHTUTEN     C=(10),K='PRTTIOA'                              @BBDIA0Y\n  DFHTUTEN     C=(08),K='PRTBIND'                              @BBDIA0Y\n  DFHTUTEN     C=(04),K=' '                                    @BBDIA0Y\n  DFHTUTEN     C=(02),K=' '                                    @BBDIA0Y\n  DFHTUTEN     C=(01),K=' '                                    @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2FCN EQU   *                   IS2 ENTRY                   @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R1,E=DFT,NX=SRT              @BBDIA0Y\n  DFHTUTEN     C=(03),K=' ',NX=FCO  TYPE =LIFO ENTRY           @BBDIA0Y\n  DFHTUTEN     C=(05),K=' ',NX=FCP  TYPE =LIFO ENTRY           @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\nTUTB2FCO EQU   *                   IS2 ENTRY                   @BBDIA0Y\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BBDIA0Y\n  DFHTUTEN     C=(01),K='RECEIVE'                              @BBDIA0Y\n  DFHTUTEN     C=(02),K='DISC'                                 @BBDIA0Y\n  DFHTUTEN     C=(05),K='IOR',NX=FI2                           @BBDIA0Y\n  DFHTUTEN     C=(08),K='NORMAL STOP'                          @BBDIA0Y\n  DFHTUTEN     C=(09),K='IMMED STOP'                           @BBDIA0Y\n  DFHTUTEN     C=(0A),K='LOGOFF'                               @BBDIA0Y\n  DFHTUTEN     C=(10),K='GETDATA'                              @BBDIA0Y\n  DFHTUTEN     C=(11),K='ENABLE'                               @BBDIA0Y\n  DFHTUTEN     C=(12),K='RECV ABORT'                           @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BM10700\n*                                                                     *\nTUTB2FCP EQU   *                   IS2 EXIT                    @BM13538\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=B0,E=DFT,NX=SRT              @BM13538\n  DFHTUTEN     C=(00),K='NORMAL'                               @BBDIA0Y\n  DFHTUTEN     C=(FF,FF),K=                                    @BBDIA0Y\n*                                                                     *\nTUTB2FCS EQU   *                   SHUTDOWN DECODE             @BBCI70Y\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=SRT               @BM12069\n  DFHTUTEN     C=(01),K='ORDERLY'                              @BBCI70Y\n  DFHTUTEN     C=(02),K='IMMED'                                @BBCI70Y\n  DFHTUTEN     C=(04),K='ABEND'                                @BBCI70Y\n  DFHTUTEN     C=(08),K='VTAM QUIESCE'                         @BM13399\n  DFHTUTEN     C=(80),K='TPEND'                                @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*                                                                     *\nTUTB2FI2 EQU   *         CONTINUE  IS2 ENTRY                   @BM13399\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT               @BM10700\n  DFHTUTEN     C=(80),K='WRITE'                                @BM13399\n  DFHTUTEN     C=(40),K='WAIT'                                 @BM13399\n  DFHTUTEN     C=(20),K='READ'                                 @BM13399\n  DFHTUTEN     C=(10),K='LAST'                                 @BM13399\n  DFHTUTEN     C=(08),K='RESET'                                @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*                                                                     *\nTUTB2FCT EQU   *                   TERMINAL SHARING            @BM13399\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT              @BM13399\n  DFHTUTEN     C=(0B),K='ATTACH'                               @BM13399\n  DFHTUTEN     C=(0C),K='APPL REQ'                             @BM13399\n  DFHTUTEN     C=(0D),K='DETACH'                               @BM13399\n  DFHTUTEN     C=(0E),K='FLUSH'                                @BM13399\n  DFHTUTEN     C=(0F),K='ROUTE'                                @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*                                                                     *\nTUTB2FZE EQU   *                   ZEMW TRACE ENTRY            @BM13399\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=SRT              @BM13399\n  DFHTUTEN     C=(40),K='MSG'                                  @BM13399\n  DFHTUTEN     C=(20),K='NEG RESP'                             @BM13399\n  DFHTUTEN     C=(02),K='EMW ACTIVE'                           @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*   ACTIVATE SCAN REQUEST                                             *\nTUTB2FZV EQU   *                   ZACT TRACE ENTRY            @BM13399\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=FZX               @BM13334\n  DFHTUTEN     C=(80),K='ZGET'                                 @BM13399\n  DFHTUTEN     C=(40),K='ZFRE'                                 @BM13399\n  DFHTUTEN     C=(20),K='ZATT'                                 @BM13399\n  DFHTUTEN     C=(10),K='ASYN'                                 @BM13399\n  DFHTUTEN     C=(08),K='RESUME'                               @BM13399\n  DFHTUTEN     C=(04),K='ZRVS'                                 @BM13399\n  DFHTUTEN     C=(02),K='COMQ'                                 @BM13399\n  DFHTUTEN     C=(01),K='LOGRESP'                              @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*   ACTIVATE SCAN REQUEST                                             *\nTUTB2FZX EQU   *                   ZACT TRACE ENTRY            @BM13399\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FZY               @BM13399\n  DFHTUTEN     C=(80),K='ZSDS'                                 @BM13399\n  DFHTUTEN     C=(40),K='ZSDA'                                 @BM13399\n  DFHTUTEN     C=(20),K='ZSES'                                 @BM13399\n  DFHTUTEN     C=(10),K='ZSDR'                                     @P9C\n  DFHTUTEN     C=(08),K='ZRST'                                 @BM13399\n  DFHTUTEN     C=(04),K='DELAY'                                @BM13399\n  DFHTUTEN     C=(02),K='EXIT ADDED'                           @BM13399\n  DFHTUTEN     C=(01),K='ZDET'                                 @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*   ACTIVATE SCAN REQUEST                                             *\nTUTB2FZY EQU   *                   ZACT TRACE ENTRY            @BM13399\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=FZZ                   @P9C\n  DFHTUTEN     C=(80),K='ZOPN'                                 @BM13399\n  DFHTUTEN     C=(40),K='ZCLS'                                 @BM13399\n  DFHTUTEN     C=(20),K='ZATI'                                 @BM13399\n  DFHTUTEN     C=(10),K='ZSIM'                                 @BM13399\n  DFHTUTEN     C=(08),K='ZRSY'                                 @BM13399\n  DFHTUTEN     C=(04),K='ZNAC'                                 @BM13399\n  DFHTUTEN     C=(02),K='ZATD'                                     @P9A\n  DFHTUTEN     C=(01),K='ZSKR'                                     @P9A\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*   ACTIVATE SCAN REQUEST                                             *\nTUTB2FZZ EQU   *                   ZACT TRACE ENTRY            @BM13399\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DFT,NX=SRT                   @P9C\n  DFHTUTEN     C=(80),K='ZTRA'                                 @BM13399\n  DFHTUTEN     C=(40),K='ZSDL'                                     @P8A\n  DFHTUTEN     C=(20),K='ZRVL'                                     @P8A\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n*                                                                     *\nTUTB2FCW EQU   *                   ZARL ENTRY TRACE ENTRY   @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT           @EI00U @L6A\n  DFHTUTEN     C=(01),K='ALLOCATE',NX=FCV                   @EI00U @L6A\n* DFHTUTEN     C=(02),K='RESERVED'\n  DFHTUTEN     C=(03),K='EXTRACT PROCESS'                   @EI00U @L6A\n* DFHTUTEN     C=(04),K='RESERVED'\n  DFHTUTEN     C=(05),K='FREE'                              @EI00U @L6A\n  DFHTUTEN     C=(06),K='ISSUE ABEND'                       @EI00U @L6A\n  DFHTUTEN     C=(07),K='ISSUE ATTACH'                      @EI00U @L6A\n  DFHTUTEN     C=(08),K='ISSUE CONFIRMATION'                @EI00U @L6A\n  DFHTUTEN     C=(09),K='ISSUE ERROR'                       @EI00U @L6A\n  DFHTUTEN     C=(0A),K='ISSUE SIGNAL'                      @EI00U @L6A\n  DFHTUTEN     C=(0B),K='RECEIVE',NX=FC7                    @EI00U @L6A\n  DFHTUTEN     C=(0C),K='SEND',NX=FC5                       @EI00U @L6A\n  DFHTUTEN     C=(0D),K='WAIT'                              @EI00U @L6A\n* DFHTUTEN     C=(0E),K='RESERVED'\n* DFHTUTEN     C=(0F),K='RESERVED'\n  DFHTUTEN     C=(10),K='FREE STORAGE'                      @EI00U @L6A\n  DFHTUTEN     C=(11),K='INITIAL CALL'                      @EI00U @L6A\n  DFHTUTEN     C=(12),K='ALLOCATE PRIV',NX=FCV              @EI00U @L6A\n  DFHTUTEN     C=(13),K='SYNC PREPARE'                      @EI00U @L6A\n  DFHTUTEN     C=(14),K='SYNC REQ COMMIT'                   @EI00U @L6A\n  DFHTUTEN     C=(15),K='SYNC COMMITED'                     @EI00U @L6A\n  DFHTUTEN     C=(16),K='SYNC FORGET'                       @EI00U @L6A\n  DFHTUTEN     C=(17),K='ABORT'                             @EI00U @L6A\n  DFHTUTEN     C=(18),K='GET MY LUNAME'                     @EI00U @L6A\n  DFHTUTEN     C=(19),K='SYNC ROLLBACK'                     @EI00U @L6A\n  DFHTUTEN     C=(1A),K='SEND FMH'                          @EI00U @L6A\n  DFHTUTEN     C=(1B),K='RECEIVE FMH'                       @EI00U @L6A\n* DFHTUTEN     C=(1C),K='RESERVED'\n* DFHTUTEN     C=(1D),K='RESERVED'\n* DFHTUTEN     C=(1E),K='RESERVED'\n* DFHTUTEN     C=(1F),K='RESERVED'\n  DFHTUTEN     C=(20),K='ERP FMH RECEIVED'                  @EI00U @L6A\n  DFHTUTEN     C=(21),K='NEG RESP RECEIVED'                 @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FCV EQU   *                   ZARL ALLOC TRACE ENTRY   @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FCC            @EI00U @L6A\n  DFHTUTEN     C=(80),K='NOQUEUE'                           @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FCC EQU   *                   ZARL ALLOC TRACE ENTRY   @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(80),K='MODENAME'                          @EI00U @L6A\n  DFHTUTEN     C=(40),K='ATI'                               @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FC5 EQU   *                   ZARL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FC6            @EI00U @L6A\n  DFHTUTEN     C=(80),K='FROM'                              @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FC6 EQU   *                   ZARL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(80),K='INVITE'                            @EI00U @L6A\n  DFHTUTEN     C=(40),K='LAST'                              @EI00U @L6A\n  DFHTUTEN     C=(20),K='CONFIRM'                           @EI00U @L6A\n  DFHTUTEN     C=(10),K='WAIT'                              @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FC7 EQU   *                   ZARL RECEIVE TRACE ENTRY @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FC8            @EI00U @L6A\n  DFHTUTEN     C=(80),K='SET'                               @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FC8 EQU   *                   ZARL RECEIVE TRACE ENTRY @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(80),K='LLID'                              @EI00U @L6A\n  DFHTUTEN     C=(40),K='BUFFER'                            @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FCX EQU   *                   ZARL EXIT TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT           @EI00U @L6A\n  DFHTUTEN     C=(00),K='NORMAL'                            @EI00U @L6A\n  DFHTUTEN     C=(01),K='SYSIDERR'                          @EI00U @L6A\n  DFHTUTEN     C=(02),K='SYSBUSY'                           @EI00U @L6A\n  DFHTUTEN     C=(03),K='INVREQ',NX=FCU                     @EI00U @L6A\n  DFHTUTEN     C=(04),K='NOTALLOC'                          @EI00U @L6A\n  DFHTUTEN     C=(05),K='LENGERR'                           @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FCU EQU   *                   ZARL INVREQ TRACE ENTRY  @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=SRT           @EI00U @L6A\n  DFHTUTEN     C=(08),K='STATE'                             @EI00U @L6A\n  DFHTUTEN     C=(0C),K='SYNCLEVEL'                         @EI00U @L6A\n  DFHTUTEN     C=(10),K='LLCOUNT'                           @EI00U @L6A\n  DFHTUTEN     C=(18),K='TPNCHECK'                          @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSM EQU   *                   ZSDL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DFT,NX=FSQ            @EI00U @L6A\n  DFHTUTEN     C=(40),K='DATA',NX=FSN                       @EI00U @L6A\n  DFHTUTEN     C=(20),K='COMMAND',NX=SRT                    @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSN EQU   *                   ZSDL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FSO            @EI00U @L6A\n  DFHTUTEN     C=(01),K='IMPLICIT'                          @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSO EQU   *                   ZSDL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=FSP            @EI00U @L6A\n  DFHTUTEN     C=(80),K='FMH'                               @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSP EQU   *                   ZSDL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(10),K='CD'                                @EI00U @L6A\n  DFHTUTEN     C=(40),K='CEB'                               @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSQ EQU   *                   ZSDL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A0,E=DFT,NX=FSR            @EI00U @L6A\n  DFHTUTEN     C=(04),K='DR2 RESPONSE'                      @EI00U @L6A\n  DFHTUTEN     C=(02),K='DR1 RESPONSE'                      @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSR EQU   *                   ZSDL SEND TRACE ENTRY    @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A2,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(01),K='ER1 RESPONSE'                      @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSS EQU   *                   ZRVL RECEIVE TRACE ENTRY @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A3,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(40),K='DATA',NX=FST                       @EI00U @L6A\n  DFHTUTEN     C=(80),K='RESPONSE'                          @EI00U @L6A\n  DFHTUTEN     C=(10),K='SINGLE_RU'                         @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FST EQU   *                   ZRVL RECEIVE TRACE ENTRY @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(08),K='BUFFER'                            @EI00U @L6A\n  DFHTUTEN     C=(04),K='RECALL'                            @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FCY EQU   *                   ZARM TRACE ENTRY         @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=SRT           @EI00U @L6A\n  DFHTUTEN     C=(01),K='SEND'                              @EI00U @L6A\n  DFHTUTEN     C=(02),K='WAIT'                              @EI00U @L6A\n  DFHTUTEN     C=(03),K='RECEIVE'                           @EI00U @L6A\n  DFHTUTEN     C=(04),K='SIGNAL'                            @EI00U @L6A\n  DFHTUTEN     C=(05),K='FLUSH',NX=FC0                      @EI00U @L6A\n  DFHTUTEN     C=(06),K='FREE'                              @EI00U @L6A\n  DFHTUTEN     C=(07),K='INVALID GDS ID'                    @EI00U @L6A\n  DFHTUTEN     C=(08),K='RESET'                             @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FC0 EQU   *                   ZARM FLUSH TRACE ENTRY   @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(80),K='AT SYNCPT'                         @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FCZ EQU   *                   ZLUS TRACE ENTRY         @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FC9           @EI00U @L6A\n  DFHTUTEN     C=(01),K='INIT CHANGE SESS'                  @EI00U @L6A\n  DFHTUTEN     C=(02),K='CHANGE SESS'                       @EI00U @L6A\n  DFHTUTEN     C=(03),K='RECV CHANGE SESS'                  @EI00U @L6A\n  DFHTUTEN     C=(04),K='SHUT DOWN'                         @EI00U @L6A\n  DFHTUTEN     C=(05),K='RESYNC'                            @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FC9 EQU   *                   ZLUS TRACE ENTRY         @EI00U @L6A\n  DFHTUTEN     T=(2,I),CP=TM,OFF=A1,E=DFT,NX=SRT            @EI00U @L6A\n  DFHTUTEN     C=(80),K='ACQUIRED'                          @EI00U @L6A\n  DFHTUTEN     C=(40),K='RELEASED'                          @EI00U @L6A\n  DFHTUTEN     C=(20),K='IMMEDIATE'                         @EI00U @L6A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI00U @L6A\n*                                                                     *\nTUTB2FSA EQU   *                   ZUSRM TRACE ENTRY TYPE   @EI226 @L8A\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FSB           @EI226 @L8C\n  DFHTUTEN     C=(80),K='CHECK'                             @EI226 @L8A\n  DFHTUTEN     C=(00),K='SET'                               @EI226 @L8A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8A\n*                                                                     *\nTUTB2FSB EQU   *                   ZUSRM TRACE ENTRY RQUEST @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=FSC           @EI226 @L8C\n  DFHTUTEN     C=(01),K='ALLOCATE'                          @EI226 @L8C\n  DFHTUTEN     C=(02),K='CONNECT'                           @EI226 @L8C\n  DFHTUTEN     C=(03),K='SEND_DATA'                         @EI226 @L8C\n  DFHTUTEN     C=(04),K='SEND_INV'                          @EI226 @L8C\n  DFHTUTEN     C=(05),K='SEND_LAST'                         @EI226 @L8C\n  DFHTUTEN     C=(06),K='WAIT'                              @EI226 @L8C\n  DFHTUTEN     C=(07),K='ATTCH_INB'                         @EI226 @L8C\n  DFHTUTEN     C=(08),K='RCV_DATA'                          @EI226 @L8C\n  DFHTUTEN     C=(09),K='INV_RCVD'                          @EI226 @L8C\n  DFHTUTEN     C=(0A),K='FREE_RCVD'                         @EI226 @L8C\n  DFHTUTEN     C=(0B),K='FREE'                              @EI226 @L8C\n  DFHTUTEN     C=(0C),K='SYST_FREE'                         @EI226 @L8C\n  DFHTUTEN     C=(0D),K='SEND_SIG'                          @EI226 @L8C\n  DFHTUTEN     C=(0E),K='ISSUE_ERR'                         @EI226 @L8C\n  DFHTUTEN     C=(0F),K='ISSUE_ABD'                         @EI226 @L8C\n  DFHTUTEN     C=(10),K='ERR_RCVD'                          @EI226 @L8C\n  DFHTUTEN     C=(11),K='ABD_RCVD'                          @EI226 @L8C\n  DFHTUTEN     C=(12),K='SEND_CONF'                         @EI226 @L8C\n  DFHTUTEN     C=(13),K='SEND_CNFM'                         @EI226 @L8C\n  DFHTUTEN     C=(14),K='REC_CONF'                          @EI226 @L8C\n  DFHTUTEN     C=(15),K='REC_CNFM'                          @EI226 @L8C\n  DFHTUTEN     C=(16),K='SEND_PREP'                         @EI226 @L8C\n  DFHTUTEN     C=(17),K='SEND_SPR'                          @EI226 @L8C\n  DFHTUTEN     C=(18),K='SEND_CMIT'                         @EI226 @L8C\n  DFHTUTEN     C=(19),K='SEND_FRGT'                         @EI226 @L8C\n  DFHTUTEN     C=(1A),K='REC_PREP'                          @EI226 @L8C\n  DFHTUTEN     C=(1B),K='REC_SPR'                           @EI226 @L8C\n  DFHTUTEN     C=(1C),K='REC_CMIT'                          @EI226 @L8C\n  DFHTUTEN     C=(1D),K='REC_FRGT'                          @EI226 @L8C\n  DFHTUTEN     C=(1E),K='SEND_BCKT'                         @EI226 @L8C\n  DFHTUTEN     C=(1F),K='REC_BCKT'                          @EI226 @L8C\n  DFHTUTEN     C=(20),K='CONV_FAIL'                         @EI226 @L8C\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSC EQU   *                   ZUSRM TRACE ENTRY STATE  @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A2,E=DFT,NX=SRT           @EI226 @L8C\n  DFHTUTEN     C=(01),K='NOT_ALLOC'                         @EI226 @L8C\n  DFHTUTEN     C=(02),K='ALLOC_IN_PROG'                     @EI226 @L8C\n  DFHTUTEN     C=(03),K='ALLOC_SEND'                        @EI226 @L8C\n  DFHTUTEN     C=(04),K='ALLOC_RCV_PND'                     @EI226 @L8C\n  DFHTUTEN     C=(05),K='ALLOC_RCV'                         @EI226 @L8C\n  DFHTUTEN     C=(06),K='FREE_PND_SEND'                     @EI226 @L8C\n  DFHTUTEN     C=(07),K='FREE_RQD'                          @EI226 @L8C\n  DFHTUTEN     C=(08),K='IN_SP_SEND_1PH'                    @EI226 @L8C\n  DFHTUTEN     C=(09),K='IN_SP_RECV_1PH'                    @EI226 @L8C\n  DFHTUTEN     C=(0A),K='IN_SP_SEND_2PH'                    @EI226 @L8A\n  DFHTUTEN     C=(0B),K='IN_SP_RECV_2PH'                    @EI226 @L8A\n  DFHTUTEN     C=(0C),K='IN_SP_BCKT_SEND'                   @EI226 @L8A\n  DFHTUTEN     C=(0D),K='IN_SP_BCKT_REC'                    @EI226 @L8A\n  DFHTUTEN     C=(0E),K='ALLOC_CONF_SEND'                   @EI226 @L8A\n  DFHTUTEN     C=(0F),K='ALLOC_CONF_REC'                    @EI226 @L8A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSD EQU   *                   ZCNT TRACE ENTRY TYPE    @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FSE           @EI226 @L8C\n  DFHTUTEN     C=(80),K='CHECK'                             @EI226 @L8C\n  DFHTUTEN     C=(00),K='SET'                               @EI226 @L8C\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSE EQU   *                   ZCNT TRACE ENTRY REQUEST @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=FSF           @EI226 @L8C\n  DFHTUTEN     C=(01),K='LUS_CONWIN'                        @EI226 @L8C\n  DFHTUTEN     C=(02),K='LUS_CONLOSE'                       @EI226 @L8C\n  DFHTUTEN     C=(03),K='LUS_CON_RESET'                     @EI226 @L8C\n  DFHTUTEN     C=(04),K='BIND_CONWIN'                       @EI226 @L8C\n  DFHTUTEN     C=(05),K='BIND_CONLOSE'                      @EI226 @L8C\n  DFHTUTEN     C=(06),K='UNBIND'                            @EI226 @L8C\n  DFHTUTEN     C=(07),K='LOCAL_ALLOC'                       @EI226 @L8C\n  DFHTUTEN     C=(08),K='DETACH'                            @EI226 @L8C\n  DFHTUTEN     C=(09),K='BB_RCV_+RSP'                       @EI226 @L8C\n  DFHTUTEN     C=(0A),K='BB_RCV_-R(0814)'                   @EI226 @L8C\n  DFHTUTEN     C=(0B),K='BB_RCV_-R(0813)'                   @EI226 @L8C\n  DFHTUTEN     C=(0C),K='-R(0819,RTR)_RCV'                  @EI226 @L8C\n  DFHTUTEN     C=(0D),K='-R(0882,RTR)_RCV'                  @EI226 @L8C\n  DFHTUTEN     C=(0E),K='+RSP(RTR)_RCV'                     @EI226 @L8C\n  DFHTUTEN     C=(0F),K='+RSP(BB)_RCV'                      @EI226 @L8C\n  DFHTUTEN     C=(10),K='RTR_RCV'                           @EI226 @L8C\n  DFHTUTEN     C=(11),K='-R(BB,0814)_RCV'                   @EI226 @L8C\n  DFHTUTEN     C=(12),K='-R(BB,0813)_RCV'                   @EI226 @L8C\n  DFHTUTEN     C=(13),K='RTR_RCV_-R(0819)'                  @EI226 @L8C\n  DFHTUTEN     C=(14),K='-R(BB,088B)_RCV'                   @EI226 @L8A\n  DFHTUTEN     C=(15),K='DATA_INBND'                        @EI226 @L8A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSF EQU   *                   ZCNT TRACE ENTRY STATE   @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A2,E=DFT,NX=SRT           @EI226 @L8C\n  DFHTUTEN     C=(01),K='NOT_BND'                           @EI226 @L8C\n  DFHTUTEN     C=(02),K='NOT_BND_CONWIN'                    @EI226 @L8C\n  DFHTUTEN     C=(03),K='NOT_BND_CONLOSE'                   @EI226 @L8C\n  DFHTUTEN     C=(04),K='BND_CONWIN'                        @EI226 @L8C\n  DFHTUTEN     C=(05),K='CONWIN_ALLOC'                      @EI226 @L8C\n  DFHTUTEN     C=(06),K='CONWIN_RTR_SENT'                   @EI226 @L8C\n  DFHTUTEN     C=(07),K='CONWIN_RTR_PND'                    @EI226 @L8C\n  DFHTUTEN     C=(08),K='BND_CONLOSE'                       @EI226 @L8C\n  DFHTUTEN     C=(09),K='CONLOSE_ALLOC'                     @EI226 @L8C\n  DFHTUTEN     C=(0A),K='CONLOSE_BIDDING'                   @EI226 @L8C\n  DFHTUTEN     C=(0B),K='CONLOSE_BB_CROSS'                  @EI226 @L8C\n  DFHTUTEN     C=(0C),K='CONLOSE_RTR_PND'                   @EI226 @L8C\n  DFHTUTEN     C=(0D),K='CONLOSE_REBID_PND'                 @EI226 @L8C\n  DFHTUTEN     C=(0E),K='CONLOSE_AWAIT_BKT'                 @EI226 @L8C\n  DFHTUTEN     C=(0F),K='BID_ACCEPTED'                      @EI226 @L8A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSG EQU   *                   ZBKT TRACE ENTRY TYPE    @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FSH           @EI226 @L8C\n  DFHTUTEN     C=(80),K='CHECK'                             @EI226 @L8C\n  DFHTUTEN     C=(00),K='SET'                               @EI226 @L8C\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSH EQU   *                   ZBKT TRACE ENTRY REQUEST @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=FSI           @EI226 @L8C\n  DFHTUTEN     C=(01),K='BB_SEND'                           @EI226 @L8C\n  DFHTUTEN     C=(02),K='CEB,RQ*1_SEND'                     @EI226 @L8C\n  DFHTUTEN     C=(03),K='CEB,RQD2_SEND'                     @EI226 @L8C\n  DFHTUTEN     C=(04),K='DR2_RCV'                           @EI226 @L8C\n  DFHTUTEN     C=(05),K='-RSP_RCV'                          @EI226 @L8C\n  DFHTUTEN     C=(06),K='BB_RCV'                            @EI226 @L8C\n  DFHTUTEN     C=(07),K='CEB,RQ*1_RCV'                      @EI226 @L8C\n  DFHTUTEN     C=(08),K='CEB,RQD2_RCV'                      @EI226 @L8C\n  DFHTUTEN     C=(09),K='DR2_SEND'                          @EI226 @L8C\n  DFHTUTEN     C=(0A),K='-RSP_SEND'                         @EI226 @L8C\n  DFHTUTEN     C=(0B),K='SESS_CLOSE'                        @EI226 @L8A\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSI EQU   *                   ZBKT TRACE ENTRY STATE   @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A2,E=DFT,NX=SRT           @EI226 @L8C\n  DFHTUTEN     C=(01),K='BET_BRKTS'                         @EI226 @L8C\n  DFHTUTEN     C=(02),K='IN_BKT'                            @EI226 @L8C\n  DFHTUTEN     C=(03),K='IN_BKT_TERM_SEND'                  @EI226 @L8C\n  DFHTUTEN     C=(04),K='IN_BKT_TERM_RCV'                   @EI226 @L8C\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSJ EQU   *                   ZCHS TRACE ENTRY TYPE    @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A0,E=DFT,NX=FSK           @EI226 @L8C\n  DFHTUTEN     C=(80),K='CHECK'                             @EI226 @L8C\n  DFHTUTEN     C=(00),K='SET'                               @EI226 @L8C\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSK EQU   *                   ZCHS TRACE ENTRY REQUEST @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A1,E=DFT,NX=FSL           @EI226 @L8C\n  DFHTUTEN     C=(01),K='BC_SEND'                           @EI226 @L8C\n  DFHTUTEN     C=(02),K='EC_SEND_RQD'                       @EI226 @L8C\n  DFHTUTEN     C=(03),K='EC_SEND_RQE,CD'                    @EI226 @L8C\n  DFHTUTEN     C=(04),K='EC_SEND_RQD,CD'                    @EI226 @L8C\n  DFHTUTEN     C=(05),K='EC_SEND_RQE,CEB'                   @EI226 @L8C\n  DFHTUTEN     C=(06),K='+R(FMD|LUS)_RCV'                   @EI226 @L8C\n  DFHTUTEN     C=(07),K='-R(FMD|LUS)_RCV'                   @EI226 @L8C\n  DFHTUTEN     C=(08),K='BC_RCV'                            @EI226 @L8C\n  DFHTUTEN     C=(09),K='EC_RCV_RQD'                        @EI226 @L8C\n  DFHTUTEN     C=(0A),K='EC_RCV_RQE,CD'                     @EI226 @L8C\n  DFHTUTEN     C=(0B),K='EC_RCV_RQD,CD'                     @EI226 @L8C\n  DFHTUTEN     C=(0C),K='EC_RCV_RQE,CEB'                    @EI226 @L8C\n  DFHTUTEN     C=(0D),K='+R(FMD|LUS)_SND'                   @EI226 @L8C\n  DFHTUTEN     C=(0E),K='-R(FMD|LUS)_SND'                   @EI226 @L8C\n  DFHTUTEN     C=(0F),K='BB_SND_COMPLETE'                   @EI226 @L8C\n  DFHTUTEN     C=(10),K='BB_ACCEPTED'                       @EI226 @L8C\n  DFHTUTEN     C=(11),K='BKT_ENDED'                         @EI226 @L8C\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\nTUTB2FSL EQU   *                   ZCHS TRACE ENTRY STATE   @EI226 @L8C\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=A2,E=DFT,NX=SRT           @EI226 @L8C\n  DFHTUTEN     C=(01),K='BET_CHNS_SEND'                     @EI226 @L8C\n  DFHTUTEN     C=(02),K='IN_CHN_SEND'                       @EI226 @L8C\n  DFHTUTEN     C=(03),K='AWAIT_RSP_SEND'                    @EI226 @L8C\n  DFHTUTEN     C=(04),K='PND_RSP_SEND'                      @EI226 @L8C\n  DFHTUTEN     C=(05),K='NEG_RSP_RCVD'                      @EI226 @L8C\n  DFHTUTEN     C=(06),K='BET_CHNS_RCV'                      @EI226 @L8C\n  DFHTUTEN     C=(07),K='IN_CHAIN_RCV'                      @EI226 @L8C\n  DFHTUTEN     C=(08),K='PND_RSP_RCV'                       @EI226 @L8C\n  DFHTUTEN     C=(09),K='AWAIT_RSP_RCV'                     @EI226 @L8C\n  DFHTUTEN     C=(0A),K='NEG_RSP_SENT'                      @EI226 @L8C\n  DFHTUTEN     C=(FF,FF),K=                                 @EI226 @L8C\n*                                                                     *\n*   TRACE INTERNAL                                                    *\nTUTB2FDD EQU   *                   TRP - TRACE INTERNAL            @LVC\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=R0,E=DFT,NX=SRT              @BM13399\n*  SYSTEM REPEAT TRACE ENTRY ******************************************\n  DFHTUTEN     C=(01),K='... REPEAT',NX=FDE                    @BM13399\n*  FE TRACE ENTRY *****************************************************\n  DFHTUTEN     C=(99),K='GLOBAL TRAP EXIT'                         @LVA\n*              ********************************************************\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\nTUTB2FDE EQU   *                   REPEAT ENTRY                @BM13399\n  DFHTUTEN     T=(2,I),CP=CLI,OFF=ADDR,E=FD1,NX=SRT            @BM13399\n  DFHTUTEN     C=(FF,FF),K=                                    @BM13399\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFHTUTEN": {"ttr": 6145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x14\\x00\\x98$?\\x00\\x98$?\\x16\\x08\\x00\\xbc\\x00\\xbc\\x00\\x00\\xe2\\xd7\\xc1\\xd3\\xd2@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-08-31T00:00:00", "modifydate": "1998-08-31T16:08:14", "lines": 188, "newlines": 188, "modlines": 0, "user": "SPALK"}, "text": "         MACRO                                                 @BD910JY\n&NAME    DFHTUTEN &C=,             COMPARE CODE      FOR T=2           *\n               &T=(2,E),           TYPE OF OPERATION FOR T=1           *\n               &CP=CLC,                                                *\n               &OFF=,                                                  *\n               &TB=,               TABLE TYPE        FOR T=2           *\n               &TBR=,              TABLE RETURN TYPE FOR T=1           *\n               &K=,                OUTPUT KEYWORD    FOR BOTH          *\n               &E=,                EXIT              FOR BOTH          *\n               &NX=SRT,                                                *\n               &DUMMY=\n.**********************************************************************\n.*   COPYRIGHT = 5665-403 (C) COPYRIGHT IBM CORP. 1974                *\n.*               THIS MODULE IS \"RESTRICTED MATERIALS OF IBM\"         *\n.*               LICENSED MATERIALS - PROPERTY OF IBM                 *\n.*               REFER TO COPYRIGHT INSTRUCTIONS                      *\n.*               FORM NUMBER G120-2083                                *\n.**********************************************************************\n.*  $MAC(DFHTUTEN),COMP(TRACE),PROD(CICS/VS) :                        *\n.*  $L1=G00    160 810918 HDXDRP : ABGV CHANGE FIELD OFFSETS          *\n         GBLB  &GENEXIT            GLOBAL FOR EXITS\n.*                                                                    *\n.*       BUILD TRACE ENTRY IN TABLE                                   *\n.*                                                                    *\n         LCLA  &A1                                          @EG00X @L1A\n         LCLC  &C1,&C2,&C4,&C5                                 @BD910JY\n         LCLC  &E1,&E2             EXIT ADDRESSES              @BD910JY\n         LCLC  &TBD                TABLE RETURN ID             @BBAI20Y\n.*\n&C1      SETC  '&C(1)'            SET IST ENTRY                @BD910JY\n&C2      SETC  '00'                                            @BD910JY\n         AIF   (N'&C LT 2).TUEN010                             @BD910JY\n         AIF   ('&C(2)' EQ '').TUEN010                         @BD910JY\n&C2      SETC  '&C(2)'                                         @BD910JY\n.TUEN010 ANOP                                                  @BD910JY\n.*\n&E1      SETC  'SRT' SET DEFAULTS                              @BD910JY\n&E2      SETC  'SRT' SET DEFAULTS                              @BD910JY\n         AIF   ('&E' EQ '').TUEN020                            @BD910JY\n&E1      SETC  '&E(1)'             SET EXIT 1 OFFSET           @BD910JY\n         AIF   (N'&E LT 2).TUEN020                             @BD910JY\n&E2      SETC  '&E(2)'             SET EXIT 2 OFFSET           @BD910JY\n.TUEN020 ANOP                                                  @BD910JY\n.*\n.*       LEVEL TWO TABLE TO PRODUCE NOW\n.*\n         AIF   ('&T' EQ '1').TUEN200 IF TABLE 1 BRANCH         @BD910JY\n         AIF   ('&T(2)' EQ 'I').TUENI10\n&NAME    DC    X'&C1'              CODE BYTE ONE               @BD910JY\n         DC    X'&C2'              CODE BYTE TWO               @BD910JY\n         AIF   (NOT &GENEXIT).TUENG10 IF NO GEN\n         DC    AL2(TUTB2&NX-TUTB2SRT) GEN NEXT ENTRY\n.TUENG10 ANOP\n.*\n         AGO   .TUEN500            GO OUTPUT KEYWORD           @BD910JY\n.TUENI10 ANOP\n&GENEXIT SETB  1                   SET NO EXIT REQ\n&C4      SETC  '00'\n         AIF   ('&CP' EQ 'TM').TUENI25\n&C4      SETC  '02'\n         AIF   ('&CP' EQ 'CLI').TUENI20\n&C4      SETC  '04'                                            @BM10519\n         AIF   ('&CP' EQ 'CLC').TUENI20                        @BM10519\n.*                                                             @BM10519\n&C4      SETC  '06'                                            @BM10519\n         AIF   ('&CP' EQ '2BIN').TUENI20                       @BM10519\n&C4      SETC  '08'                                            @BM10519\n         AIF   ('&CP' EQ '1BIN').TUENI20                       @BM10519\n&C4      SETC  '10'                                            @BM10519\n         AIF   ('&CP' EQ 'RBIN').TUENI20                       @BM10519\n&C4      SETC  '12'                                            @BM10519\n         AIF   ('&CP' EQ 'LBIN').TUENI20                       @BM10519\n&C4      SETC  '14'                                            @BM10519\n         AIF   ('&CP' EQ '1DEC').TUENI20                       @BM10519\n&C4      SETC  '16'                                            @BM10519\n         AIF   ('&CP' EQ '2DEC').TUENI20                       @BM10519\n&C4      SETC  '18'                                            @BM10519\n         AIF   ('&CP' EQ '3DEC').TUENI20                       @BM10519\n.*                                                             @BM10519\n         MNOTE 12,'WRONG CP OPERAND'\n.TUENI20 ANOP\n&GENEXIT SETB  1                   SET EXIT REQUIRED\n.TUENI25 ANOP\n&C5      SETC  'ID'                                         @EG00X @L1C\n         AIF   ('&OFF' EQ 'ID').TUENI30                        @BM10519\n&C5      SETC  'RETAD'                                      @EG00X @L1C\n         AIF   ('&OFF' EQ 'ADDR').TUENI30                      @BM10519\n&C5      SETC  'TR'                                         @EG00X @L1C\n         AIF   ('&OFF' EQ 'R0').TUENI30\n&C5      SETC  'TR+1'                                       @EG00X @L1C\n         AIF   ('&OFF' EQ 'R1').TUENI30\n&C5      SETC  'TCAID'                                      @EG00X @L1C\n         AIF   ('&OFF' EQ 'TASKNO').TUENI30                    @BM10519\n&C5      SETC  'DATA1'                                      @EG00X @L1C\n         AIF   ('&OFF' EQ 'A0').TUENI30\n&C5      SETC  'DATA1+1'                                    @EG00X @L1C\n         AIF   ('&OFF' EQ 'A1').TUENI30\n&C5      SETC  'DATA1+2'                                    @EG00X @L1C\n         AIF   ('&OFF' EQ 'A2').TUENI30\n&C5      SETC  'DATA1+3'                                    @EG00X @L1C\n         AIF   ('&OFF' EQ 'A3').TUENI30\n&C5      SETC  'DATA2'                                      @EG00X @L1C\n         AIF   ('&OFF' EQ 'B0').TUENI30\n&C5      SETC  'DATA2+1'                                    @EG00X @L1C\n         AIF   ('&OFF' EQ 'B1').TUENI30\n&C5      SETC  'DATA2+2'                                    @EG00X @L1C\n         AIF   ('&OFF' EQ 'B2').TUENI30\n&C5      SETC  'DATA2+3'                                    @EG00X @L1C\n         AIF   ('&OFF' EQ 'B3').TUENI30\n         MNOTE 12,'WRONG OFF COMAND'\n.TUENI30 ANOP\n         DC    AL1(&C4)            OPERATION TYPE              @BM10519\n.*\n         DC    AL1(ZTR&C5-ZTRENTRY)   FIELD OFFSET          @EG00X @L1C\n         DC    AL2(TUTE1&E1-TUTE1SRT) EXIT OFFSET\n         DC    AL2(TUTB2&NX-TUTB2SRT) NEXT OFFSET\n         AGO   .TUEN550\n.*        LEVEL ONE TABLE TO PRODUCE NOW\n.*\n.TUEN200 ANOP                                                  @BD910JY\n&TBD     SETC  '&TB'               SET TO DEFAULT              @BBAI20Y\n         AIF   ('&TBR' EQ '').TUEN210                          @BBAI20Y\n&TBD     SETC  '&TBR'              SET TO REAL                 @BBAI20Y\n.TUEN210 ANOP                                                  @BBAI20Y\n.* GENERATE TABLE ENTRY                                        @BBAI20Y\n&NAME    DC  AL2(TUTB2&TB-TUTB2SRT) TABLE OFFSET               @BD910JY\n         DC  AL2(TUTB2&TBD-TUTB2SRT) TABLE OFFSET FOR RETURN   @BBAI20Y\n.*       DC  AL2(TUTE1&E2-TUTE1SRT) EXIT 2 OFFSET\n.TUEN500 ANOP                                                  @BD910JY\n         AIF   ('&K' NE '').TUEN520 IF NOT NULL BRANCH         @BD910JY\n         DC    AL1(0),C' '         NULL STRING                 @BD910JY\n         AGO   .TUEN550                                        @BD910JY\n.TUEN520 ANOP                                                  @BD910JY\n&A1      SETA  K'&K                                         @EG00X @L1C\n         AIF   ('&K'(1,1) EQ '''').TUEN540                     @BD910JY\n         DC    AL1(&A1-1),CL&A1'&K'                         @EG00X @L1C\n         AGO   .TUEN550                                        @BD910JY\n.TUEN540 ANOP                                                  @BD910JY\n&A1      SETA  &A1-2                                        @EG00X @L1A\n         DC    AL1(&A1-1),CL&A1&K                           @EG00X @L1C\n.TUEN550 ANOP                                                  @BD910JY\n         MEXIT                                                 @BD910JY\n.*       TRACE TABLE SETUP MACRO.\n.*\n.*       STATUS CHANGE LEVEL 00.\n.*\n.*       FUNCTION.\n.*           TO PROVIDE TABLES FOR DECODING THE TRACE TABLE.\n.*           TWO TYPES OF TABLE ARE SETUP.\n.*           TYPE 1 (T=1) LEVEL ONE TABLE CONTAINING\n.*           OFFSET OF EXIT\n.*           OFFSET OF LEVEL TWO TABLE\n.*           CHARACTER STRING TO OUTPUT\n.*\n.*           TYPE 2 (T=2) LEVEL TWO TABLE CONTAINING\n.*           CHAR TO COMPARE 1\n.*           CHAR TO COMPARE 2\n.*           CHAR STRING TO OUTPUT IF COMPARES ARE TRUE.\n.*       OUTPUT.\n.*           FOR EACH INVOCATION OF THE MACRO ONE ENTRY IS OUTPUT.\n.*           T=1\n.*             E=EXIT REQUIRED\n.*             TB=TABLE TWO REQUIRED\n.*             K=CHAR STING TO OUTPUT\n.*           T=(2,E)\n.*             C=HEX (2,2) DIGITS TO COMPARE\n.*             K=CHAR STRING TO OUTPUT\n.*                INTERNAL USE BY TRACE ROUTINES ONLY\n.*           T=(2,I)\n.*             CP=COMPARE TYPE\n.*             OFF=OFFSET IN MINOR TABLE\n.*             K=CHAR STRING TO OUTPUT\n.*             E=EXIT REQUIRED\n.*\n.*       METHOD\n.*          THIS MACRO FIRST SETS LOCAL VALUES FOR THE OPTIONS\n.*          AND THEN OUTPUTS THE ENTRY.\n.*       EXTERNAL FIELDS\n.*          NONE\n.*\n.*       ERROR MSGS\n.*           NONE\n.*\n.*       NOTES\n.*          NONE.\n.*\n.*\n         MEND                                                  @BD910JY\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FBA": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x17\\x00\\x88\\x05?\\x00\\x925/\\x169\\x00b\\x00E\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "1988-02-22T00:00:00", "modifydate": "1992-12-17T16:39:17", "lines": 98, "newlines": 69, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    FBA   &SBA,&ADR,&LIST=YES,&HELP=NO\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'FBA' parameter         *\n* and use pass parameter 'HELP=Yes'.                                  *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n* Find Buffer Address. Returns the row/col as two two byte variables  *\n* from a three byte \"SBA\" address variable.                           *\n*                                                                     *\n*   Parameters:                                                       *\n*       1. 3270 buffer address where the first two bytes are:         *\n*          b. \"row\" = X'rr'                                           *\n*          c. \"col\" = X'cc'                                           *\n*          This adrees may be passed in a register                    *\n*       2. Return address of variable where the first two halfwords:  *\n*          a. \"row\" = X'00rr'                                         *\n*          b. \"col\" = X'00cc'                                         *\n*          If this parameter is missing, the \"row\" and \"col\" values   *\n*          will be returned in registers R0 and R1 respectively.      *\n*          this adrees may be passed in a register                    *\n*       3. LIST=Yes/No, generate macro expansion statements.          *\n*       4. HELP=Yes/No, generate help details.                        *\n*                                                                     *\n*   Processing logic:                                                 *\n*       The 6 low order bits of the two bytes are joined to provide   *\n*       a 12-bit address. This address is divided by the col length   *\n*       to give a relative (to 0) row and col address. 1 is added to  *\n*       each to give actual value.                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         AIF   (T'&SBA EQ 'O').E1\n         AIF   (T'&NAME EQ 'O').A$00\n&NAME    DS    0H\n.A$00    ANOP\n         LCLC  &VTYPE,&#SBA1,&#SBA2,&#ADR1,&#ADR2\n         LCLB  &FBAFST1\n&FBANM   SETC  'FBA'.'&SYSNDX'         SET \"INDEX\"\n         AIF   ('&SBA'(1,1) EQ '(').A$01\n&#SBA1   SETC  '&SBA'\n&#SBA2   SETC  '&SBA+1'\n         AGO   .A$02\n.A$01    ANOP\n&#SBA1   SETC  '0(&SBA(1))'\n&#SBA2   SETC  '1(&SBA(1))'\n.A$02    ANOP\n         AIF   (T'&ADR EQ 'O').A$04\n         AIF   ('&ADR'(1,1) EQ '(').A$03\n&#ADR1   SETC  '&ADR'\n&#ADR2   SETC  '&ADR+2'\n         AGO   .A$04\n.A$03    ANOP\n&#ADR1   SETC  '0(&ADR(1))'\n&#ADR2   SETC  '2(&ADR(1))'\n.A$04    ANOP\n.*--------------------------------------------------------------------*\n         XR    R14,R14           CLEAR WORK REG\n         XR    R15,R15           CLEAR WORK REG\n         AIF   ('&SBA'(1,4) EQ '(R14').A$06\n         AIF   ('&SBA'(1,3) EQ '(14').A$06\n.A$05    ANOP\n         IC    R14,&#SBA1        GET FIRST BYTE OF CSR ADDRESS\n         IC    R15,&#SBA2        GET SECOND BYTE OF CSR ADDRESS\n         AGO   .A$07\n.A$06    ANOP\n         IC    R15,&#SBA2        GET SECOND BYTE OF CSR ADDRESS\n         IC    R14,&#SBA1        GET FIRST BYTE OF CSR ADDRESS\n.A$07    ANOP\n         SLL   R14,26            CHOP OFF TOP 26 BITS\n         SRL   R14,26            LEAVE ONLY LOW SIX BITS\n         SLL   R15,26            CHOP OFF TOP 26 BITS\n         SLDL  R14,6             PUT LOW SIX BITS OF EACH BYTE TOGETHER\n         SRDL  R14,32            SET UP FOR DIVIDE\n         LA    R1,80             SET THE DIVISOR\n         D     R14,=F'80'        DIVIDE CSR POSITION BY LINE LENGTH\n         LA    R14,1(R14)        MAKE COL REL TO 1 NOT ZERO\n         LA    R15,1(R15)        MAKE ROW REL TO 1 NOT ZERO\n         AIF   (T'&ADR EQ 'O').A$88\n         STH   R15,&#ADR1        STORE ROW POINTER\n         STH   R14,&#ADR2        STORE COLUMN POINTER\n         AGO   .MEXIT\n.A$88    ANOP\n         LR    R0,R15            RETURN ROW IN R0\n         LR    R1,R14            RETURN COL IN R1\n.*--------------------------------------------------------------------*\n.MEXIT   ANOP\n         POP   PRINT\n         MEXIT\n.E1      MNOTE 8,'\"FBA\" REQUIRES A SOURCE ADDRESS.'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GBA": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87 \\x1f\\x00\\x89\\x05/\\x19%\\x004\\x000\\x00\\x00\\xc1\\xd3\\xd2@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-07-20T00:00:00", "modifydate": "1989-02-21T19:25:00", "lines": 52, "newlines": 48, "modlines": 0, "user": "ALK"}, "text": "         MACRO\n&NAME    GBA   &REG,&ROW,&COL\n*---------------------------------------------------------------------*\n* MACRO TO DETERMINE IF THE FIRST TWO BYTES OF A VARIABLE (POINTED TO *\n* BY A REGISTER) ARE EQUAL TO \"ROW\" AND \"COL\" ARGUMENTS PASSED.       *\n*                                                                     *\n*   PARAMETERS:                                                       *\n*       1. REGISTER POINTING TO AN INPUT VARIABLE                     *\n*       2. ROW NUMBER (DECIMAL)                                       *\n*       3. COL NUMBER (DECIMAL)                                       *\n*                                                                     *\n*   FORMULAE:  ((R-1)*80+(C-1))/64   QOUTIENT  => ROW DISP IN TABLE   *\n*                                    REMAINDER => COL DISP IN TABLE   *\n*---------------------------------------------------------------------*\n         LCLC  &C1,&C2,&C3,&C4,&TABLE,&CROW,&CCOL,&CFAB\n         LCLC  &CCURSOR\n         LCLA  &AROW,&ACOL,&AREM,&A1,&A2,&DISP,&LEN,&CSFE\n         AIF   (T'&REG EQ 'O').E1                 ROW NOT ENTERED\n         AIF   (T'&ROW EQ 'O').E2                 ROW NOT ENTERED\n         AIF   (T'&COL EQ 'O').E3                 COL NOT ENTERED\n.CALSDA  ANOP\n&AROW    SETA  &ROW\n&ACOL    SETA  &COL\n         AIF   (&AROW GT 43).E4\n         AIF   (&AROW LT 1).E4\n         AIF   (&ACOL GT 80).E5\n         AIF   (&ACOL LT 1).E5\n&C1      SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'  1 TO 16 ( 1-33)\n&C2      SETC  '50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F' 17 TO 32 (34-65)\n&C3      SETC  '6061E2E3E4E5E6E7E8E96A6B6C6D6E6F' 33 TO 48 (66-97)\n&C4      SETC  'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F' 49 TO 64 (98-129)\n&TABLE   SETC  '&C1&C2&C3&C4'\n&DISP    SETA  &AROW-1\n&DISP    SETA  &DISP*80                 DECREMENT ROW # BY 1\n&DISP    SETA  &DISP+&ACOL-1\n&AROW    SETA  &DISP/64\n&ACOL    SETA  &AROW*64\n&ACOL    SETA  &DISP-&ACOL\n&ACOL    SETA  &ACOL*2\n&ACOL    SETA  &ACOL+1\n&AROW    SETA  &AROW*2\n&AROW    SETA  &AROW+1\n&CROW    SETC  '&TABLE'(&AROW,2)\n&CCOL    SETC  '&TABLE'(&ACOL,2)\n&NAME    CLC   =XL3'11&CROW&CCOL',0(&REG)\n         MEXIT\n.E1      MNOTE 12,'GBA REQUIRES A REGISTER POINTING TO A VARIABLE.'\n.E2      MNOTE 12,'GBA REQUIRES A LINE NUMBER.'\n.E3      MNOTE 12,'GBA REQUIRES A COLUMN NUMBER.'\n.E4      MNOTE 12,'GBA REQUIRES LINE IN RANGE 1 TO 43.'\n.E5      MNOTE 12,'GBA REQUIRES COLUMN RANGE 1 TO 80.'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HALATTCH": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x00\\x903\\x1f\\x00\\x91\\x05\\x8f\\x12\\x02\\x00\\x9d\\x00\\x01\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xc1\\xd2@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1990-11-27T00:00:00", "modifydate": "1991-02-27T12:02:00", "lines": 157, "newlines": 1, "modlines": 0, "user": "TECHAK"}, "text": "         MACRO\n&NAME    HALATTCH &ENTRY,&ECB,&ERROR,&RSAVER,&MF=,&LIST=YES\n         PUSH  PRINT\n         AIF   ('&LIST' NE 'NO').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n*---------------------------------------------------------------------*\n* MACRO TO CONVERT HEX DATA TO CHARACTER DISPLAYABLE DATA.            *\n*                                                                     *\n*  PARAMETERS:                                                        *\n*      1. ENTRY POINT NAME (VSE VARIABLE NAME OF ENTRY ADDRESS)       *\n*      2. ECB NAME                                                    *\n*      3. ERROR ROUTINE ON RETURN                                     *\n*      4. MACRO FORMAT FOR RE-ENTRANT PROGRAMS MF=E OR MF=L           *\n*      5. OPTION TO GENERATE MACRO EXPANSION OR NOT LIST=YES/NO       *\n*  NOTE:                                                              *\n*      PARAMETERS MAY BE PASSED IN REGISTERS USING THE (RN)           *\n*      NOTATION (NOTE CANNOT HAVE DIGITS).                            *\n*---------------------------------------------------------------------*\n         GBLC  &SYSTEM\n         GBLC  &ALABEL,&AVSEST,&AVSEPR,&AVSES1,&AVSES2\n         GBLB  &AT1STE,&AT1STL,&AT1NAME\n         LCLC  &DNAM,&REM,&ERR\n         LCLC  &#ENTRY,&#ECB,&#ERROR\n         LCLA  &NAML\n.*--------------------------------------------------------------------*\n&NAML    SETA  K'&NAME\n&ERR     SETC  'BNZ'                          SET ERROR BRANCH COMMAND\n&DNAM    SETC  '&NAME'\n.*--------------------------------------------------------------------*\n         AIF   ('&ENTRY'(1,1) NE '(').NOREGEN\n&#ENTRY  SETC  '0&ENTRY'                      TRUNCATE NAME TO 7 CHARS\n         AGO   .TREGEC                        GO TEST REG FORMAT ECB\n.NOREGEN ANOP\n&#ENTRY  SETC  '&ENTRY'\n.TREGEC  ANOP\n.*--------------------------------------------------------------------*\n         AIF   ('&ECB'(1,1) NE '(').NOREGEC\n&#ECB    SETC  '0&ECB'                        TRUNCATE TO REGISTER\n         AGO   .TREGER                        GO TEST REG FORMAT ECB\n.NOREGEC ANOP\n&#ECB    SETC  '&ECB'\n.TREGER  ANOP\n.*--------------------------------------------------------------------*\n         AIF   ('&ERROR'(1,1) NE '(').NOREGER\n&#ERROR  SETC  '&ERROR(1)'                    TRUNCATE TO REGISTER\n&ERR     SETC  'BNZR'                         SET ERROR BRANCH COMMAND\n         AGO   .A$01                          GO TEST REG FORMAT ECB\n.NOREGER ANOP\n&#ERROR  SETC  '&ERROR'\n.*--------------------------------------------------------------------*\n.*--------------------------------------------------------------------*\n.A$01    ANOP\n         AIF   (&NAML LT 8).NOTR\n&DNAM    SETC  '&NAME'(1,7)                   TRUNCATE NAME TO 7 CHARS\n         MNOTE 4,'&NAME TRUNCATED TO &DNAM'\n.NOTR    ANOP\n         AIF   (&AT1NAME).A$00\n&ATNAM   SETC  'AT'.'&SYSNDX'\n&ALABEL1 SETC  '&ATNAM'.'10'\n&ALABEL2 SETC  '&ATNAM'.'20'\n&ALABEL4 SETC  '&ATNAM'.'30'\n&ALABEL5 SETC  '&ATNAM'.'40'\n&AVSEPR  SETC  '&ATNAM'.'50'\n&AVSES1  SETC  '&ATNAM'.'60'\n&AVSES2  SETC  '&ATNAM'.'70'\n&AVSEEC  SETC  '&ATNAM'.'80'\n&AVSEDL  SETC  '&ATNAM'.'90'\n&AT1NAME SETB  1\n.*--------------------------------------------------------------------*\n.A$00    ANOP\n         AIF   (T'&MF EQ 'O').E5       IF PARM 4 NOT PASSED ERROR\n         AIF   ('&MF' EQ 'L').LIST1    IF MF=L PARAMETER PASSED BYPASS\n         AIF   (T'&ENTRY EQ 'O').E1    IF PARM 1 NOT PASSED ERROR\n         AIF   (T'&RSAVER EQ 'O').E3   IF PARM 1 NOT PASSED ERROR\n         AIF   (T'&ERROR EQ 'O').E4    IF PARM 4 NOT PASSED ERROR\n         AIF   ('&SYSTEM' NE 'VSE').TESTVME\n.*------------------------- VSE MF=E ---------------------------------*\n.VSEMFE  ANOP\n         STM   R2,R14,&RSAVER          STORE REGISTERS\n         LA    R0,&AVSEDL              LENGTH OF GETVIS AREA FOR VSE\n         GETVIS ADDRESS=11             GETMAIN AREA\n         USING &DNAM.L,R11             ADDRESABILITY TO GETMAINED DSECT\n         L     R1,&#ENTRY              LOAD POINTER TO PROGRAM ENTRY\n         LA    R3,&AVSEEC              ADDRESS OF ECB\n         LA    R4,&AVSES1              ADDRESS OF DYNAMIC SAVE 1\n         LA    R5,&AVSES2              ADDRESS OF DYNAMIC SAVE 2\n&DNAM.E  ATTACHX (R1),ECB=(R3),SAVE=(R4),ABSAVE=(R5),MFG=(R11)\n         LM    R2,R14,&RSAVER          RESTORE REGISTERS\n         LTR   R1,R1                   Q. ZERO RETURN CODE\n         &ERR  &#ERROR                    N. GO TO ERROR ADDRESS\n         AGO   .EXIT                   EXIT MACRO\n.*--------------------------------------------------------------------*\n.TESTVME ANOP\n         AIF   (T'&ECB EQ 'O').E2      IF PARM 2 NOT PASSED ERROR\n         AIF   ('&SYSTEM' NE 'VM').MVSMFE\n.*-------------------------- VM MF=E ---------------------------------*\n.VMMFE   ANOP\n         LA    R1,&#ECB                ADDRESS OF ECB\n         LA    R14,&DNAM.L             ADDRESS OF DYNAMIC SAVE 1\n&DNAM.E  ATTACHX EP=&ENTRY,ECB=(R1),SZERO=YES,JSTCB=YES,SF=(E,(R14))\n         LTR   R15,R15                 Q. ZERO RETURN CODE\n         &ERR  &#ERROR                    N. GO TO ERROR ADDRESS\n         AGO   .EXIT                   EXIT MACRO\n.*------------------------- MVS MF=E ---------------------------------*\n.MVSMFE  ANOP\n         LA    R1,&#ECB                ADDRESS OF ECB\n         LA    R14,&DNAM.L             ADDRESS OF DYNAMIC SAVE 1\n&DNAM.E  ATTACHX EP=&ENTRY,ECB=(R1),SF=(E,(R14))\n         LTR   R15,R15                 Q. ZERO RETURN CODE\n         &ERR  &#ERROR                    N. GO TO ERROR ADDRESS\n         AGO   .EXIT                   EXIT MACRO\n.*--------------------------------------------------------------------*\n.LIST1   ANOP\n         AIF   ('&SYSTEM' NE 'VSE').TESTVML\n.*------------------------- VSE MF=L ---------------------------------*\n.VSEMFL  ANOP\n&DNAM.L  DSECT\n&AVSEPR  DS    CL64\n&AVSES1  DS    CL128\n&AVSES2  DS    CL72\n&AVSEEC  DS    F\n&AVSEDL  EQU   *-&DNAM.L\n         AGO   .EXIT                   EXIT MACRO\n.*--------------------------------------------------------------------*\n.TESTVML ANOP\n         AIF   (T'&ENTRY EQ 'O').E1    IF PARM 1 NOT PASSED ERROR\n         AIF   ('&SYSTEM' NE 'VSE').MVSMFL\n.*-------------------------- VM MF=L ---------------------------------*\n.VMMFL   ANOP\n&DNAM.L  ATTACHX EP=&ENTRY,SZERO=YES,JSTCB=YES,SM=SUPV,SF=L\n         AGO   .EXIT                   EXIT MACRO\n.*------------------------- MVS MF=L ---------------------------------*\n.MVSMFL  ANOP\n&DNAM.L  ATTACHX EP=&ENTRY,SZERO=YES,SVAREA=YES,SF=L\n&DNAM.L  ATTACHX EP=&ENTRY,SZERO=YES,SVAREA=YES,SF=L\n         AGO   .EXIT                   EXIT MACRO\n.*--------------------------------------------------------------------*\n.EXIT    ANOP\n         POP   PRINT\n         MEXIT\n.*--------------------------------------------------------------------*\n.*       ERROR MESSAGES                                               *\n.*--------------------------------------------------------------------*\n.E1      MNOTE 8,'PROGRAM ENTRY NAME/REGISTER NOT PASSED'\n         MEXIT\n.*--------------------------------------------------------------------*\n.E2      MNOTE 8,'ECB NAME/REGISTER NOT PASSED'\n         MEXIT\n.*--------------------------------------------------------------------*\n.E3      MNOTE 8,'REGISTER SAVE AREA NOT PASSED'\n         MEXIT\n.*--------------------------------------------------------------------*\n.E4      MNOTE 8,'ERROR ROUTINE ADDRESS/REGISTER NOT PASSED'\n         MEXIT\n.*--------------------------------------------------------------------*\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEXCHMAC": {"ttr": 9985, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1c\\x00Q\\x00\\x90\\x16_\\x01\\x01\\x16/\\x02D\\x00\\xf8\\x00K\\x00\\x00\\xd7\\xe2\\xc1\\xe9\\xd2@@@@@'", "ispf": {"version": "01.28", "flags": 0, "createdate": "1990-06-14T00:00:00", "modifydate": "2001-06-11T02:44:51", "lines": 248, "newlines": 75, "modlines": 0, "user": "PSAZK"}, "text": "         MACRO\n&NAME    HEXCHMAC &SOURCE,&TARGET,&LENGTH,&MF=,&LIST=NO,&LABEL=YES,    +\n               &HELP=NO,&INIT=NO,&DSECT=NO\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'HEXCHMAC' parameter    *\n* and it's use, pass parameter 'HELP=Yes'.                            *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* CONVERT HEX TO CHARACTERS.                                          *\n* --------------------------                                          *\n*           N O T E - N O T E - N O T E - N O T E - N O T E           *\n*                                                                     *\n*   This routine saves and uses general registers 1, 14 & 15.         *\n*   14 will be altered on return from the macro.                      *\n*   Do NOT use registers 14 or 15 as addresses for passed parameters. *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Parameters:-                                                      *\n*       1. Source                                                     *\n*       2. Target (the target needs 2 times the length of source)     *\n*       3. Length                                                     *\n*       4. MF=E/L -  Macro format for re-entrant programs             *\n*       5. LABEL=YES/NO - Generate data labels. Used for re-entrant   *\n*                         programs with MF=L and you wish to move the *\n*                         constant value from the CSECT over the      *\n*                         the GETMAIN'ed DSECT.                       *\n*                         The default is 'YES'. The parameter can be  *\n*                         ignored if NOTE 2 option is observed.       *\n*       6. LIST=YES/NO - Option to generate macro expansion or not    *\n*       7. HELP=YES/NO - Option to print these help details. Default  *\n*                        is 'YES'.                                    *\n*       8. INIT=YES/NO - Initialise MF=E macro to repeat common code  *\n*                        for multi-DSECT programs. 'NO' is the        *\n*                        default.                                     *\n*       9. DSECT=Y/N   - If DSECT=Y, the translate table is defided   *\n*                        as storage (DS) not constant (DC).           *\n*                        Should be used with MF=L.                    *\n*                                                                     *\n*   NOTE:-                                                            *\n*       1. Parameters may be passed in registers using the (Rn)       *\n*          notation (Note cannot have digits).                        *\n*       2. For execute form of the macro (MF=E) the first occurence of*\n*          the macro must be the first one executed. If a branch      *\n*          causes a initial loop around it, insert a dummy macro to   *\n*          perform a conversion into work areas or use the LABEL=NO   *\n*          parameter.                                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PUSH  PRINT\n         PRINT NOGEN\n.A$XX    ANOP\n&NAME    DS    0H\n         LCLC  &#LENGTH,&#SOURCE,&#TARGET\n         LCLA  &LEN\n         GBLC  &XNAME,&XCBAL,&XCBYPAS,&XCLOOP\n         GBLC  &XCBYTES,&XCBYTE1,&XCBYTE2,&XCTABLE,&XCRETAD\n         GBLB  &XC1ST,&XC1NAME\n.*--------------------------------------------------------------------*\n         GBLC  &REGSAVR,&REGSMCR\n         GBLB  &REGSFLG,&REGDFLG\n         AIF   ('&INIT'(1,1) NE 'Y').A$YY  BYPASS IF NOT INITIALISE\n&XC1ST   SETB  0\n&XNAME   SETC  'XC'.'&SYSNDX'\n&XCBAL   SETC  '&XNAME'.'06'\n&XCLOOP  SETC  '&XNAME'.'07'\n&XCBYPAS SETC  '&XNAME'.'08'\n&XCRETRN SETC  '&XNAME'.'EX'\n.A$YY    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (&REGSFLG).A$RS\n&REGSAVR SETC  'GB'.'&SYSNDX'.'#'\n&REGSMCR SETC  'HEXCHMAC'\n&REGSFLG SETB  1\n.A$RS    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (&XC1NAME).A$$0\n&XNAME   SETC  'XC'.'&SYSNDX'\n&XCRETAD SETC  '&XNAME'.'01'\n&XCTABLE SETC  '&XNAME'.'02'\n&XCBYTES SETC  '&XNAME'.'03'\n&XCBYTE1 SETC  '&XNAME'.'04'\n&XCBYTE2 SETC  '&XNAME'.'05'\n&XCBAL   SETC  '&XNAME'.'06'\n&XCLOOP  SETC  '&XNAME'.'07'\n&XCBYPAS SETC  '&XNAME'.'08'\n&XCRETRN SETC  '&XNAME'.'EX'\n&XC1NAME SETB  1\n         AGO   .A$$0\n.*--------------------------------------------------------------------*\n.A$$0    ANOP\n&XCRETRN SETC  'XC'.'&SYSNDX'.'EX'\n.A$$1    ANOP\n         AIF   ('&MF' EQ 'L').RENT1    IF MF=L PARAMETER PASSED BYPASS\n         AIF   (T'&SOURCE EQ 'O').E1   IF PARM 1 NOT PASSED ERROR\n         AIF   (T'&TARGET EQ 'O').E2   IF PARM 2 NOT PASSED ERROR\n         AIF   (T'&LENGTH EQ 'O').E3   IF PARM 3 NOT PASSED ERROR\n         AIF   ('&SOURCE'(1,1) EQ '(').A$01\n&#SOURCE SETC  '&SOURCE'\n         AGO   .A$02\n.A$01    ANOP\n&#SOURCE SETC  '0(&SOURCE(1))'\n.A$02    ANOP\n         AIF   ('&TARGET'(1,1) EQ '(').A$03\n&#TARGET SETC  '&TARGET'\n         AGO   .A$04\n.A$03    ANOP\n&#TARGET SETC  '0(&TARGET(1))'\n.A$04    ANOP\n         AIF   (&XC1ST).A$11           IF NOT 1ST. TIME THRU\n         AIF   (T'&MF EQ 'O').NONR1    IF NON-RE PROGRAM BYPASS\n*  EXEC FORM OF MACRO 'HEXCHMAC'                                      *\n*---------------------------------------------------------------------*\n.*       MVC   &XCTABLE.(16),=C'0123456789ABCDEF'\n         B     &XCBYPAS                BYPASS COMMON CODE\n         AGO   .RENT2                  BYPASS NON-RE PROCESS\n.NONR1   ANOP\n*  NORMAL FORM OF MACRO 'HEXCHMAC'                                    *\n*---------------------------------------------------------------------*\n         B     &XCBYPAS                BYPASS DATA + COMMON CODE\n*---------------------------------------------------------------------*\n         AGO   .NONR2                  BYPASS RE-ENT PROCESS\n.RENT1   ANOP\n*---------------------------------------------------------------------*\n*  List form of macro 'HEXCHMAC'                                      *\n*---------------------------------------------------------------------*\n.NONR2   ANOP\n         AIF   (T'&MF EQ 'O').LABON1\n         AIF   ('&LABEL'(1,1) EQ 'Y').LABON1\n         DS    0F                      WORD ALIGN\n         DS    F                       RETURNN ADDRESS SAVE AREA\n         AIF   (T'&DSECT EQ 'O').DCTT1\n         AIF   ('&DSECT'(1,1) EQ 'N').DCTT1\n         DS    CL16                    TRANSLATE TABLE\n         AGO   .DCTT1D\n.DCTT1   ANOP\n         DC    C'0123456789ABCDEF'     TRANSLATE TABLE\n.DCTT1D  ANOP\n         DS    0CL2                    BYTE SAVE AREA\n         DS    CL1                     1ST. BYTE\n         DS    CL1                     2ND. BYTE\n         AGO   .LABDONE\n.LABON1  ANOP\n         DS    0F                      WORD ALIGN\n&XCRETAD DS    F                       RETURNN ADDRESS SAVE AREA\n         AIF   (T'&DSECT EQ 'O').DCTT2\n         AIF   ('&DSECT'(1,1) EQ 'N').DCTT2\n&XCTABLE DS    CL16                    TRANSLATE TABLE\n         AGO   .DCTT2D\n.DCTT2   ANOP\n&XCTABLE DC    C'0123456789ABCDEF'     TRANSLATE TABLE\n.DCTT2D  ANOP\n&XCBYTES DS    0CL2                    BYTE SAVE AREA\n&XCBYTE1 DS    CL1                     1ST. BYTE\n&XCBYTE2 DS    CL1                     2ND. BYTE\n.LABDONE ANOP\n.*--------------------------------------------------------------------*\n.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *\n.*--------------------------------------------------------------------*\n         AIF   (&REGDFLG).A$RD\n         AIF   ('&LABEL'(1,1) EQ 'Y').LABON2 BYPASS IF LABEL REQUIRED\n         AIF   ('&REGSMCR' NE 'HEXCHMAC').A$RD\n         DS    0F                      WORD ALIGN\n         DS    16F                     REGISTER SAVE AREA\n         AGO   .A$RD                   DO NOT SET FLAG IF LABEL REQD\n.LABON2  ANOP\n&REGDFLG SETB  1\n         DS    0F                      WORD ALIGN\n&REGSAVR DS    16F                     REGISTER SAVE AREA\n.A$RD    ANOP\n.*--------------------------------------------------------------------*\n.RENT2   ANOP\n*---------------------------------------------------------------------*\n         AIF   ('&MF' EQ 'L').EXIT\n*                                                                     *\n*        Convert HEX to characters.                                   *\n*                                                                     *\n*         R1=source, R14=target, R15=length                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n&XCBAL   DS    0H\n         XR    0,0                     INITIALISE REGISTER\n         AIF   (T'&MF EQ 'O').NONR3    IF NON-RE PROGRAM BYPASS\n         MVC   &XCTABLE.(16),=C'0123456789ABCDEF'\n.NONR3   ANOP\n&XCLOOP  DS    0H\n         IC    0,0(1)                  INSERT CHARACTER FOR TRANS'TN\n         SRL   0,4                     GET RID OF RIGHT NIBBLE\n         STC   0,&XCBYTE1              STORE LEFT NIBBLE\n         TR    &XCBYTE1,&XCTABLE       TRANSLATE NIBBLE TO CHATACTER\n         MVC   0(1,14),&XCBYTE1        MOVE TO DESTINATION\n         MVC   &XCBYTE1,0(1)           MOVE CHARACTER TO WORK AREA\n         NI    &XCBYTE1,15             AND WITH X'0F' REMOVE LEFT NIB\n         TR    &XCBYTE1,&XCTABLE       TRANSLATE TO CHARACTER\n         MVC   1(1,14),&XCBYTE1        MOVE CHAR TO DESTINATION\n         LA    1,1(1)                  UP SOURCE BY 1\n         LA    14,2(14)                UP DESTINATION BY 2\n         BCT   15,&XCLOOP              BRANCH TILL END\n         L     14,&XCRETAD             LOAD RETURN ADDRESS\n         BR    14                      RETURN TO CALLER\n&XCBYPAS DS    0H\n.A$11    ANOP\n         STM   14,12,&REGSAVR          SAVE REGISTERS\n         LA    14,&XCRETRN             LOAD RETURN ADDRESS\n         ST    14,&XCRETAD             STORE RETURN ADDRESS\n         LA    14,&#TARGET             SET UP DESTINATION ADDRESS\n         AIF   ('&LENGTH'(1,1) NE '(').ACTLEN\n&LEN     SETA  K'&LENGTH-2\n&#LENGTH SETC  '&LENGTH'(2,&LEN)       REGISTER\n         LR    15,&#LENGTH             LENGTH TO BE CONVERTED\n         AGO   .FINLMV  ANOP           PASS AROUND\n.ACTLEN  ANOP\n         LA    15,&LENGTH              LENGTH TO BE CONVERTED\n.FINLMV  ANOP\n         LA    1,&#SOURCE              SET UP TO SOURCE ADDRESS\n         B     &XCBAL                  GO TO HEX => CHAR ROUTINE\n&XCRETRN DS    0H\n         LM    14,12,&REGSAVR          RESTORE REGISTERS\n*---------------------------------------------------------------------*\n&XC1ST   SETB  1\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.*       ERROR MESSAGES                                               *\n.*--------------------------------------------------------------------*\n.E1      MNOTE 8,'HEXCHMAC requires a SOURCE field'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E2      MNOTE 8,'HEXCHMAC requires a TARGET field'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E3      MNOTE 8,'HEXCHMAC requires a LENGTH'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E4      MNOTE 8,'Invalid \"MF\" parameter passed'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.EXIT    ANOP\n         AIF   ('&LIST'(1,1) NE 'N').EXIT9\n         POP   PRINT\n.EXIT9   ANOP\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ICDC": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00@\\x00\\x87 \\x1f\\x00\\x925?\\x11C\\x00<\\x00.\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-07-20T00:00:00", "modifydate": "1992-12-18T11:43:40", "lines": 60, "newlines": 46, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    ICDC  &ROW,&COL,&LIST=YES,&HELP=NO\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n.*--------------------------------------------------------------------*\n         GBLB  &ICDC1ST\n         AIF   (&ICDC1ST).A$HELPE      IF NOT 1ST. TIME THRU\n&ICDC1ST SETB  1\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'ICDC' parameter and    *\n* it's use, pass parameter 'HELP=Yes'.                                *\n.*--------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*   Parameters:                                                       *\n*       1. row number                                                 *\n*       2. collumn                                                    *\n*   Formulae:  ((R-1)*80+(C-1))/64   qoutient  => row disp in table   *\n*                                    remainder => col disp in table   *\n.A$HELPE ANOP\n         LCLC  &C1,&C2,&C3,&C4,&TABLE,&CROW,&CCOL,&CFAB\n         LCLA  &AROW,&ACOL,&AREM,&A1,&A2,&DISP,&LEN,&CSFE\n         AIF   (T'&ROW EQ 'O').E2                 ROW NOT ENTERED\n         AIF   (T'&COL EQ 'O').E3                 COL NOT ENTERED\n.CALSDA  ANOP\n&AROW    SETA  &ROW\n&ACOL    SETA  &COL\n         AIF   (&AROW GT 43).E4\n         AIF   (&AROW LT 1).E4\n         AIF   (&ACOL GT 80).E5\n         AIF   (&ACOL LT 1).E5\n&C1      SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'  1 TO 16 ( 1-33)\n&C2      SETC  '50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F' 17 TO 32 (34-65)\n&C3      SETC  '6061E2E3E4E5E6E7E8E96A6B6C6D6E6F' 33 TO 48 (66-97)\n&C4      SETC  'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F' 49 TO 64 (98-129)\n&TABLE   SETC  '&C1&C2&C3&C4'\n&DISP    SETA  &AROW-1\n&DISP    SETA  &DISP*80                 DECREMENT ROW # BY 1\n&DISP    SETA  &DISP+&ACOL-1\n&AROW    SETA  &DISP/64\n&ACOL    SETA  &AROW*64\n&ACOL    SETA  &DISP-&ACOL\n&ACOL    SETA  &ACOL*2\n&ACOL    SETA  &ACOL+1\n&AROW    SETA  &AROW*2\n&AROW    SETA  &AROW+1\n&CROW    SETC  '&TABLE'(&AROW,2)\n&CCOL    SETC  '&TABLE'(&ACOL,2)\n*---------------------------------------------------------------------*\n&NAME    DC    X'11&CROW&CCOL.13'\n         MEXIT\n.E2      MNOTE 12,'SBA REQUIRES A LINE NUMBER.'\n.E3      MNOTE 12,'SBA REQUIRES A COLUMN NUMBER.'\n.E4      MNOTE 12,'SBA REQUIRES LINE IN RANGE 1 TO 43.'\n.E5      MNOTE 12,'SBA REQUIRES COLUMN RANGE 1 TO 80.'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INCLUDE": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x87 ?\\x00\\x87 ?\\x18#\\x00\\x0c\\x00\\x0b\\x00\\x00\\xc3\\xe2\\xc1\\xd3\\xc5\\xe7@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1987-07-22T00:00:00", "modifydate": "1987-07-22T18:23:00", "lines": 12, "newlines": 11, "modlines": 0, "user": "CSALEX"}, "text": "         MACRO\n&NAME    INCLUDE &MEMBER=,&DSECT=NO,&BASER=R10\n         AIF   (T'&MEMBER EQ 'O').E1\n         AIF   ('&DSECT' EQ 'NO').A$99\n         DSECT\n         USING *,&BASER\n.A$99    ANOP\n         DC   C'&MEMBER'\n         COPY &MEMBER\n         MEXIT\n.E1      MNOTE 8,'INCLUDE NEEDS A MEMBER.'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISPBRIF": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x91\\x12/\\x00\\x91\\x12/\\x13E\\x00\\xa9\\x00\\xa1\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xc1\\xd2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-05-02T00:00:00", "modifydate": "1991-05-02T13:45:00", "lines": 169, "newlines": 161, "modlines": 0, "user": "TECHAK"}, "text": "         MACRO\n&NAME    ISPBRIF &PARM1,&PARM2,&PARM3,&PARM4,&PARM5,&PARM6,            X\n               &LIST=YES,&MF=,&HELP=NO\n         PUSH  PRINT\n         AIF   ('&LIST' NE 'NO').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   ('&HELP' EQ 'YES').A$HELP\n*---------------------------------------------------------------------*\n* FOR A MORE COMPREHENSIVE DESCRIPTION OF THE 'ISPBRIF' PARAMETER     *\n* AND USE PASS PARAMETER 'HELP=YES'.                                  *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* This macro is used to define addressability between a program and   *\n* ISPF variables.                                                     *\n*                                                                     *\n* In the normal form:                                                 *\n*   It is designed to create common variables the first time thru and *\n*   re-use them everytime the macro is invoked.                       *\n* In re-entrant form:                                                 *\n*   Use the MF=L and MF=E options.                                    *\n*                                                                     *\n* Parameters are pointers to the following data areas:                *\n*   1. PARM1     - data-set-name         (max length 54 bytes, no     *\n*                  imbedded blanks.                                   *\n*   2. PARM2     - rec-format (2 bytes: 'F ', 'FA', 'FM', 'V ', 'VA', *\n*                  'VM' or 'U'.                                       *\n*   3. PARM3     - rec-length: fullword initialised to max reclen     *\n*                  (you can \"hide\" data by specifying length less     *\n*                  than actual length.)                               *\n*   4. PARM4     - read-routine:                                      *\n*   5. PARM5     - command-routine:                                   *\n*   6. PARM5     - dialog-data: used to reestablish addresability     *\n*                  when control is given to I/O routine. (Usually the *\n*                  base register address or pointer to the base reg   *\n*                  address(es).                                       *\n*   6. PARM6     - panel-name: your own BROWSE display panel.         *\n*   7. PARM7     - format-name: the name of the format to be used to  *\n*                  reformat the dsata.                                *\n*   8. PARM8     - 'YES'/'no': spacifies whether the data is to be    *\n*                  treated in mixed mode DBCS data.                   *\n*   9. MF=...... - Macro format. Omit for non re-entrant programs.    *\n*                  For re-entrant programs:                           *\n*                    E - EXEC format of macro                         *\n*                    L - LIST format of macro.                        *\n*  10. LIST=..... - Generate or suppress macro expansion, (YES/NO).   *\n*  11. HELP=..... - Displat these comments (YES/NO) default is \"NO\"   *\n*                                                                     *\n* Example of input:                                                   *\n*      ISPBRIF NAM=(ISPFname),VAR=int.name,FORMAT=CHAR,LEN=20         *\n*          - OR -                                                     *\n*      EXEC format:                                                   *\n*        ISPBRIF NAM=(ISPFname),VAR=int.name,FORMAT=CHAR,LEN=20,MF=E *\n*      LIST format:                                                   *\n*        ISPBRIF MF=L                                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n&NAME    DS    0H\n         GBLC  &BNAME\n         GBLB  &BDFX1ST,&BMFE1ST,&BNMF1ST\n         LCLA  &LL,&BLL\n&LL      SETA  K'&LEN\n&BLL     SETA  K'&BAR\n         AIF   (&BDFX1ST).A$00         IF NOT 1ST. BYPASS\n&BDFX1ST SETB  1                       SET 1ST. TIME THRU FLAG\n&BNAME   SETC  'IVD'.'&SYSNDX'         SET \"INDEX\"\n.A$00    ANOP\n         AIF   ('&MF' EQ 'L').A$11     BYPASS IF RE-ENT\n         AIF   ('&MF' EQ 'E').A$33     BYPASS IF RE-ENT\n         AIF   (T'&MF NE 'O').E1       INVALID FORMAT OF MF PARM\n         AIF   (&BNMF1ST).A$55         BYPASS IF NOT 1ST NON-R\n&BNMF1ST SETB  1                       SET 1ST. TIME THRU FLAG\n         B     &BNAME.L                BYPASS DATA DEFS AFTER 1ST. THRU\n         AGO  .A$111\n.A$11    ANOP\n*---------------------------------------------------------------------*\n*    LIST form of macro 'ISPBRIF'                                     *\n*---------------------------------------------------------------------*\n.A$111   ANOP\n&BNAME.1 DS    F                       VDEFINE\n         DS    F                       ISPF NAME\n         DS    F                       INTERNAL NAME\n         DS    F                       VAR TYPE\n         DS    F                       VAR LENGTH\n         DS    F                       OPTION\n&BNAME.2 DC    C'VDEFINE '             VDEF LITERAL\n&BNAME.3 DC    CL10'          '        ISPF DEST (ALLOW FOR \"()\")\n         DC    C' '                    SPACER\n&BNAME.4 DC    C'CHAR    '             VDEF FORMAT TYPE\n         DC    C' '                    SPACER\n&BNAME.5 DS    CL2                     LENGTH SOURCE PRIOR CONVERSION\n         DC    C' '                    SPACER\n&BNAME.6 DS    F                       R2 SAVEAREA FOR LEN CONVERSION\n&BNAME.7 DS    D                       DBL WD LEN CONVERSION WK FLD\n&BNAME.8 DS    F                       LENGTH CONVERTED TO FULL WD BIN\n&BNAME.9 DC    C'&OPT    '             OPTIONS (NOT USED BY THIS RTN)\n&BNAME.V DS    F                       INTERNAL NAME ADDRESS STORE\n*-----------------------------------------------------------------*\n         AIF   ('&MF' NE 'L').A$22     BYPASS IF NOT MF=L\n         POP   PRINT\n         MEXIT                         EXIT IF MF=L\n.A$22    ANOP\n&BNAME.L DS    0H\n         AIF   (T'&MF EQ 'O').A$44     BYPASS IF RE-ENT\n.A$33    ANOP\n*---------------------------------------------------------------------*\n*    EXEC form of macro 'ISPBRIF'                                     *\n*---------------------------------------------------------------------*\n.EXMFE   ANOP\n         AIF   (&BMFE1ST).A$55          IF NOT 1ST. BYPASS\n&BMFE1ST SETB  1                        SET 1ST. TIME THRU FLAG\n*    Unique code                                                      *\n*---------------------------------------------------------------------*\n         MVI   &BNAME.2,C' '            SPACE FILL DATA\n         MVC   &BNAME.2+1(55),&BNAME.2  USING RIPPLE MOVE\n         MVC   &BNAME.2(7),=C'VDEFINE'  MOVE LITERAL\n         AGO   .A$441\n.A$44    ANOP\n*    Unique code                                                      *\n*---------------------------------------------------------------------*\n.A$441   ANOP\n         ST    R2,&BNAME.6             SAVE REG2\n         LA    R2,&BNAME.1             R1 DEST VALUE FOR \"CALL\"\n         LA    R1,&BNAME.2             ADDRESS OF PARAMETER\n         ST    R1,0(R2)                STORE ADDRESS\n         LA    R2,4(R2)                POINT TO NEXT ADDRESS POS\n         LA    R1,&BNAME.3             ETC...\n         ST    R1,0(R2)                    \"\n         LA    R2,4(R2)                    \"\n         LA    R2,4(R2)                    \"\n         LA    R1,&BNAME.4                 \"\n         ST    R1,0(R2)                    \"\n         LA    R2,4(R2)                    \"\n         LA    R1,&BNAME.8                 \"\n         ST    R1,0(R2)                    \"\n         LA    R2,4(R2)                    \"\n         LA    R1,&BNAME.9                 \"\n         ST    R1,0(R2)                    \"\n         MVI   0(R2),X'80'                 \"\n         L     R2,&BNAME.6                RESET R2\n.A$55    ANOP\n*-----------------------------------------------------------------*\n*    Common code                                                      *\n*---------------------------------------------------------------------*\n         AIF   (T'&MF EQ 'O').A$66\n         MVC   &BNAME.4(8),=CL8'&FORMAT' SET UP \"(ISPF-FORM)\" VALUE\n.A$66    ANOP\n         MVC   &BNAME.3(10),=CL10'&NAM'   SET UP \"(ISPF-NAME)\" VALUE\n         MVC   &BNAME.5(&LL),=CL&LL'&LEN' SET UP LENGTH\n         PACK  &BNAME.7,&BNAME.5(&LL)     PACK LENGTH FOR CONVERSION\n         CVB   R1,&BNAME.7                CONV LEN TO FULL WD BIN\n         ST    R1,&BNAME.8                SAVE CONVERTED  LENGTH\n         LA    R1,&BAR                    ADDRESS OF INTERNAL NAME\n         ST    R1,&BNAME.1+8              SAVE\n         LA    R1,&BNAME.1                LOAD PARAMETER LIST ADDRESS\n         L     15,ISPLINK                 LOAD \"ISPLINK\" ADDRESS\n.*       L     15,=V(ISPLINK)             LOAD \"ISPLINK\" ADDRESS\n         BALR  14,15                      BRANCH AND LINK\n         POP   PRINT\n         MEXIT\n.*--------------------------------------------------------------------*\n.E1      MNOTE 8,'INVALID \"MF\" PARAMETER PASSED'\n.*--------------------------------------------------------------------*\n         POP   PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPEXEC": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x018\\x00(\\x00\\x96\\x03\\x0f\\x00\\x97(\\x8f\\x14\\x18\\x00\\xba\\x00\\xad\\x00\\x00\\xc3\\xf8\\xf3\\xf8\\xf7\\xf0\\xf4@@@'", "ispf": {"version": "01.56", "flags": 0, "createdate": "1996-01-30T00:00:00", "modifydate": "1997-10-15T14:18:28", "lines": 186, "newlines": 173, "modlines": 0, "user": "C838704"}, "text": "         MACRO\n&NAME    ISPEXEC &XTEXT,&XLENG,&LIST=NO,&HELP=NO,&LONG=NO,&INIT=NO,    +\n               &MF=,&TYPE=VAR\n         PUSH  PRINT\n         AIF   ('&LIST' NE 'NO').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   ('&HELP' EQ 'YES').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'ISPEXEC' parameter and *\n* it's use, pass parameter 'HELP=Yes'.                                *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* Macro to initialise an \"ISPF\" environment and set up variables to   *\n*   facilitate executing ISPEXEC commands.                            *\n*                                                                     *\n* Format:                                                             *\n*   1. ISPEXEC no.parameter/INIT=Y          (Required on first        *\n*                                            execution. Requires both *\n*                                            MF=L and MF=E for re-    *\n*                                            entrant programs.        *\n*   2. ISPEXEC 'normal CLIST type text'                               *\n*   3. ISPEXEC int.var.name,int.var.length                            *\n*                                                                     *\n* Parameters:                                                         *\n*   1. XTEXT     - a) Quoted literal (follows the normal CLIST syntax *\n*                     after the ISPEXEC command).                     *\n*                            - OR -                                   *\n*                  b) Variable name that contains the normal CLIST    *\n*                     syntax following the ISPEXEC command.           *\n*   2. XLENG     - Length of the variable if Format '2' used for the  *\n*                  'XTEXT' parameter.                                 *\n*   3. LONG=.... - Specify long move (MVCL) if Format '2' used.       *\n*   4. LIST=.... - Generate or suppress macro expansion, (YES/NO).    *\n*   5. INIT=.... - Force initial invocation, (YES/NO).                *\n*   6. TYPE=.... - VARiable/CONstant for MF=L. For re-entrant programs*\n*                  to copy constant into GETMAINed variable.          *\n*   7. MF=....   - Macro format. Only required for re-entrant         *\n*                  programs and then ONLY ON the initialisation       *\n*                  invocation.                                        *\n*                  For re-entrant programs:                           *\n*                    E - EXEC format of macro on INIT invocation.     *\n*                    L - LIST format of macro.                        *\n*                                                                     *\n* NOTE:                                                               *\n*      1. The first execution must be of the macro WITHOUT the XTEXT  *\n*         parameter or WITH the INIT=Y parameter.                     *\n*      2. Does not cover \"VDEF\", \"VCOPY\", \"VDELETE\", \"VRESET\" or      *\n*         \"VREPLACE\".                                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         AIF   (T'&NAME EQ 'O').NONAME1    Bypass if NAME missing\n&NAME    DS    0H\n.NONAME1 ANOP\n         GBLB  &ISPI1ST\n         GBLC  &ISPNAME,&ISPTYP,&ISPEXEP,&ISPBUFA,&ISPBUFL,&ISPBUFR\n         LCLC  &ISPLABB\n         AIF   (&ISPI1ST).A$00\n&ISPI1ST SETB  1\n&ISPNAME SETC  'INI'.'&SYSNDX'\n.A$00    ANOP\n         AIF   ('&INIT'(1,1) EQ 'Y').INITIL\n         AIF   (T'&XTEXT NE 'O').SETEXEC    Bypass if INIT=N + param\n.*--------------------------------------------------------------------*\n.*   Initialisation form of macro                                     *\n.*--------------------------------------------------------------------*\n.INITIL  ANOP\n&ISPTYP  SETC  'LOAD'\n&ISPEXEP SETC  '&ISPNAME'.'1'\n&ISPBUFA SETC  '&ISPNAME'.'2'\n&ISPBUFL SETC  '&ISPNAME'.'3'\n&ISPBUFR SETC  '&ISPNAME'.'4'\n&ISPLABB SETC  '&ISPNAME'.'X'\n         AIF   (T'&MF NE 'O').A$11   RE-ENTRANT BYPASS\n         B     &ISPLABB                PYPASS DATA\n.A$11    ANOP\n         AIF   ('&MF' EQ 'E').A$22   RE-ENTRANT LIST EXIT\n*---------------------------------------------------------------------*\n*    LIST form of macro 'ISPEXEC' initialisation                      *\n*---------------------------------------------------------------------*\n         DS    0F                      FULLWORD ALLIGNMENT\n         AIF   ('&TYPE'(1,1) NE 'C').A$12\n         DS    A                       A(ISPF LINK INTERFACE)\n         DS    A                       A(ISPF EXEC INTERFACE)\n         DC    A(0)                    A(COMMAND LENGTH)\n         DC    A(0)                    A(COMMAND BUFFER)\n         DC    F'0'                    COMMAND LENGTH\n         DS    0CL300                  COMMAND BUFFER\n         AGO   .A$13\n.A$12    ANOP\nISPLINK  DS    A                       A(ISPF LINK INTERFACE)\nISPEXEC  DS    A                       A(ISPF EXEC INTERFACE)\n&ISPEXEP DC    A(&ISPBUFL)             A(COMMAND LENGTH)\n&ISPBUFA DC    A(&ISPBUFR)             A(COMMAND BUFFER)\n&ISPBUFL DC    F'0'                    COMMAND LENGTH\n&ISPBUFR DS    0CL300                  COMMAND BUFFER\n.A$13    ANOP\n         DC    CL250' ',CL50' '        INITIALISED TO SPACES\n         AIF   ('&MF' EQ 'L').MEXIT  Re-entrant list, Exit\n&ISPLABB DS    0H\n.*       AIF   (T'&MF EQ 'O').A$33   Non RE-ENTRANT BYPASS\n.A$22    ANOP\n*---------------------------------------------------------------------*\n*    EXEC form of macro 'ISPEXEC' initialisation                      *\n*---------------------------------------------------------------------*\n         LA    R1,&ISPBUFL             LOAD ADDRESS OF COMMAND LENGTH\n         ST    R1,&ISPEXEP             STORE COMMAND LENGTH ADDRESS\n         LA    R1,&ISPBUFR             LOAD ADDRESS OF COMMAND BUFFER\n         ST    R1,&ISPBUFA             STORE COMMAND BUFFER ADDRESS\n         OI    &ISPBUFA,X'80'          MOVE LAST PARM INDICATOR\n*\n.A$33    ANOP\n*        LOAD  EP=ISPLINK              FETCH ISPF LINK INTERFACE\n         LOAD  EP=ISPLINK              FETCH ISPF LINK INTERFACE\n         ST    R0,ISPLINK              SAVE ITS ADDRESS\n*        LOAD  EP=ISPEXEC              FETCH ISPF EXEC INTERFACE\n         LOAD  EP=ISPEXEC              FETCH ISPF EXEC INTERFACE\n         ST    R0,ISPEXEC              SAVE ITS ADDRESS\n.A$99    ANOP\n*---------------------------------------------------------------------*\n         AIF   (T'&XTEXT EQ 'O').MEXIT      Exit if no parameter\n.*-------------------------------------------------------------------*\n.SETEXEC ANOP\n         AIF   (T'&XLENG NE 'O').MVX2\n         AIF   ('&XTEXT'(1,1) NE '''').E3\n.*-------------------------------------------------------------------*\n         LCLC  &CHAR,&AMPER\n         LCLA  &LC,&QC,&AC\n&AMPER   SETC  '&&'\n&LC      SETA  K'&XTEXT                     LOOP COUNTER\n&QC      SETA  0                            QUOTES COUNTER\n&AC      SETA  0                            AMPERSAND COUNTER\n&CP      SETA  0                            CHARACTER POINTER\n.LOOP1   ANOP\n&CP      SETA  &CP+1                        INCREMENT CHARACTER PTR\n&CHAR    SETC  '&XTEXT'(&CP,1)\n.TQUOT   ANOP\n         AIF   ('&CHAR' NE '''').TAMPR\n&QC      SETA  &QC+1\n         AGO   .NXTCH\n.TAMPR   ANOP\n         AIF   ('&CHAR.&CHAR' NE '&AMPER').NXTCH\n&AC      SETA  &AC+1\n.NXTCH   ANOP\n         AIF   (&CP LT &LC).LOOP1           LOOP TILL END\n&LC      SETA  &LC-2-(((&QC-2)/2)+(&AC/2))\n         MVC   &ISPBUFR.(&LC),=C&XTEXT\n.*-------------------------------------------------------------------*\n         LA    1,&LC                   LOAD LENGTH\n         AGO   .LA\n.MVX2    ANOP\n         AIF   ('&XTEXT'(1,1) EQ '''').E2\n         AIF   ('&LONG'(1,1) EQ 'N').MVX4\n.MVX3    ANOP\n         LA    R0,&ISPBUFR             LOAD ADDRESS OF DESTINATION\n         LA    R1,&XLENG               LOAD LENGTH OF MOVE\n         LA    R14,&XTEXT              LOAD SOURCE ADDRESS\n         LA    R15,&XLENG              LOAD LENGTH OF MOVE\n         ICM   R15,B'1000',=C'         '            MOVE PAD CHARACTER\n         MVCL  R0,R14                  SET AREA TO ALL SPACES\n         AGO   .MVX5\n.MVX4    ANOP\n         MVC   &ISPBUFR.(&XLENG),&XTEXT\n.MVX5    ANOP\n         LA    1,&XLENG                LOAD LENGTH\n.LA      ANOP\n         ST    1,&ISPBUFL              STORE LENGTH\n         LA    1,&ISPEXEP              LOAD PARAMETER LIST POINTER\n         L     15,ISPEXEC              LOAD 'ISPEXEC' MODULE ADDR\n         BALR  14,15                   CALL 'ISPEXEC'\n         AGO   .MEXIT                       Exit macro\n*---------------------------------------------------------------------*\n.E1      MNOTE 12,'ISPEXEC REQUIRES A FUNCTION PARAMETER LIST'\n         AGO   .MEXIT                       Exit macro\n.E2      MNOTE 12,'VARIABLE NAME MUST NOT BE QUOTED'\n         AGO   .MEXIT                       Exit macro\n.E3      MNOTE 12,'VARIABLE NAME REQUIRES A LENGTH'\n         AGO   .MEXIT                       Exit macro\n.*--------------------------------------------------------------------*\n.MEXIT   ANOP\n         POP   PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPINIT": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\"\\x00G\\x00\\x87\\x13\\x9f\\x00\\x952_\\x12\\x10\\x00\\r\\x00\\x0f\\x00\\x00\\xe4\\xe3\\xd4\\xd7\\xf5\\xf4\\xf3@@@'", "ispf": {"version": "01.34", "flags": 0, "createdate": "1987-05-19T00:00:00", "modifydate": "1995-11-21T12:10:47", "lines": 13, "newlines": 15, "modlines": 0, "user": "UTMP543"}, "text": "         MACRO\n&NAME    ISPINIT &MF=,&LIST=NO,&HELP=NO\n*---------------------------------------------------------------------*\n* Obsolete macro. Replace as follows:                                 *\n*    1. Non re-entrant programs;                                      *\n*         ISPEXEC INIT=Y                                              *\n*    2. Re-entrant programs;                                          *\n*         ISPEXEC INIT=Y,MF=E         Execute format                  *\n*         ISPEXEC INIT=Y,MF=L         List format                     *\n*---------------------------------------------------------------------*\n.E1      MNOTE 12,'REPLACE ''ISPINIT'' WITH ''ISPEXEC'' AS SPECIFIED'\n.*--------------------------------------------------------------------*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISPVDEFX": {"ttr": 13572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01@\\x00\\x00\\x00\\x90\\x16_\\x01\\x07\\x08\\x8f\\x016\\x00\\xcc\\x00\\xa0\\x00\\x00\\xc1\\xd3\\xd2\\xf2\\xf5\\xf6\\xf7@@@'", "ispf": {"version": "01.64", "flags": 0, "createdate": "1990-06-14T00:00:00", "modifydate": "2007-03-29T01:36:00", "lines": 204, "newlines": 160, "modlines": 0, "user": "ALK2567"}, "text": "         MACRO\n&NAME    ISPVDEFX &INM=,&ANM=,&FORMAT=,&LEN=,&OPT=,&MF=,&LIST=NO,      x\n               &TYPE=VAR,&HELP=NO\n         PUSH  PRINT\n         AIF   ('&LIST' NE 'NO').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   ('&HELP' EQ 'YES').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'ISPVDEFX' parameter    *\n* and it's use, pass parameter 'HELP=Yes'.                            *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* This macro is used to define addressability between a program and   *\n* ISPF variables.                                                     *\n*                                                                     *\n* In the normal form:                                                 *\n*   It is designed to create common variables the first time thru and *\n*   re-use them everytime the macro is invoked.                       *\n* In re-entrant form:                                                 *\n*   Use the MF=L and MF=E options.                                    *\n*                                                                     *\n* Parameters (for further details, refer to ISPF DMS manuals):        *\n*   1. INM=..... - ISPF variable name, enclosed in brackets ().       *\n*   2. ANM=..... - Internal (assembler) varaiable name.               *\n*   3. FORMAT=.. - Variable format, valid values are:                 *\n*                        CHAR FIXED BIT HEX DBCS USER                 *\n*   4. LEN=..... - Length of the variable in numeric bytes or         *\n*                  register (2) - (13). If register is used, the      *\n*                  length must be loaded ito the register.            *\n*   5. OPT=..... - Options, valid values are:                         *\n*                        COPY NOBSCAN LIST                            *\n*   6. MF=...... - Macro format. Omit for non re-entrant programs.    *\n*                  For re-entrant programs:                           *\n*                    E - EXEC format of macro                         *\n*                    L - LIST format of macro.                        *\n*   7. TYPE=.... - VARiable/CONstant for MF=L. For re-entrant programs*\n*                  to copy constant into GETMAINed variable.          *\n*   8. LIST=..... - Generate or suppress macro expansion, (YES/NO).   *\n*                                                                     *\n* Example of input:                                                   *\n*      ISPVDEFX INM=(ISPFname),ANM=int.name,FORMAT=CHAR,LEN=20        *\n*          - OR -                                                     *\n*      EXEC format:                                                   *\n*        ISPVDEFX INM=(ISPFname),ANM=int.name,FORMAT=CHAR,LEN=20,MF=E *\n*      LIST format:                                                   *\n*        ISPVDEFX MF=L           (default ,TYPE=VAR)                  *\n*          - or -                                                     *\n*        ISPVDEFX MF=L,TYPE=CONS (and move CONS to VAR)               *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n&NAME    DS    0H\n         GBLC  &VNAME\n         GBLB  &VDFX1ST,&VMFE1ST,&VNMF1ST\n         LCLA  &LL,&VLL\n         LCLC  &REGL\n&LL      SETA  K'&LEN\n&VLL     SETA  K'&ANM\n         AIF   (&VDFX1ST).A$00         IF NOT 1ST. BYPASS\n&VDFX1ST SETB  1                       SET 1ST. TIME THRU FLAG\n&VNAME   SETC  'IVD'.'&SYSNDX'         SET \"INDEX\"\n.A$00    ANOP\n         AIF   ('&MF' EQ 'L').A$11     BYPASS IF RE-ENT\n         AIF   ('&MF' EQ 'E').A$33     BYPASS IF RE-ENT\n         AIF   (T'&MF NE 'O').E1       INVALID FORMAT OF MF PARM\n         AIF   (&VNMF1ST).A$55         BYPASS IF NOT 1ST NON-R\n&VNMF1ST SETB  1                       SET 1ST. TIME THRU FLAG\n         B     &VNAME.L                BYPASS DATA DEFS AFTER 1ST. THRU\n         AGO  .A$111\n.A$11    ANOP\n.*--------------------------------------------------------------------*\n.*   LIST form of macro 'ISPVDEFX'                                    *\n.*--------------------------------------------------------------------*\n.A$111   ANOP\n*---------------------------------------------------------------------*\n*    LIST form of macro 'ISPVDEFX' (constant).                        *\n*---------------------------------------------------------------------*\n         AIF   ('&TYPE'(1,1) NE 'C').A$112\n         DS    F                       VDEFINE\n         DS    F                       ISPF NAME\n         DS    F                       INTERNAL NAME\n         DS    F                       VAR TYPE\n         DS    F                       VAR LENGTH\n         DS    F                       OPTION\n         DC    C'VDEFINE '             VDEF LITERAL\n         DC    CL10'          '        ISPF DEST (ALLOW FOR \"()\")\n         DC    C' '                    SPACER\n         DC    C'CHAR    '             VDEF FORMAT TYPE\n         DC    C' '                    SPACER\n         DS    CL2                     LENGTH SOURCE PRIOR CONVERSION\n         DC    C' '                    SPACER\n         DS    F                       R2 SAVEAREA FOR LEN CONVERSION\n         DS    D                       DBL WD LEN CONVERSION WK FLD\n         DS    F                       LENGTH CONVERTED TO FULL WD BIN\n         DC    C'&OPT    '             OPTIONS (NOT USED BY THIS RTN)\n         DS    F                       INTERNAL NAME ADDRESS STORE\n         AGO   .A$113\n.*--------------------------------------------------------------------*\n.A$112   ANOP\n*---------------------------------------------------------------------*\n*    LIST form of macro 'ISPVDEFX' (modifiable).                      *\n*---------------------------------------------------------------------*\n&VNAME.1 DS    F                       VDEFINE\n         DS    F                       ISPF NAME\n         DS    F                       INTERNAL NAME\n         DS    F                       VAR TYPE\n         DS    F                       VAR LENGTH\n         DS    F                       OPTION\n&VNAME.2 DC    C'VDEFINE '             VDEF LITERAL\n&VNAME.3 DC    CL10'          '        ISPF DEST (ALLOW FOR \"()\")\n         DC    C' '                    SPACER\n&VNAME.4 DC    C'CHAR    '             VDEF FORMAT TYPE\n         DC    C' '                    SPACER\n&VNAME.5 DS    CL2                     LENGTH SOURCE PRIOR CONVERSION\n         DC    C' '                    SPACER\n&VNAME.6 DS    F                       R2 SAVEAREA FOR LEN CONVERSION\n&VNAME.7 DS    D                       DBL WD LEN CONVERSION WK FLD\n&VNAME.8 DS    F                       LENGTH CONVERTED TO FULL WD BIN\n&VNAME.9 DC    C'&OPT    '             OPTIONS (NOT USED BY THIS RTN)\n&VNAME.V DS    F                       INTERNAL NAME ADDRESS STORE\n.A$113   ANOP\n*-----------------------------------------------------------------*\n         AIF   ('&MF' NE 'L').A$22     BYPASS IF NOT MF=L\n         POP   PRINT\n         MEXIT                         EXIT IF MF=L\n.A$22    ANOP\n&VNAME.L DS    0H\n         AIF   (T'&MF EQ 'O').A$44     BYPASS IF RE-ENT\n.A$33    ANOP\n*---------------------------------------------------------------------*\n*    EXEC form of macro 'ISPVDEFX'                                    *\n*---------------------------------------------------------------------*\n.EXMFE   ANOP\n         AIF   (&VMFE1ST).A$55          IF NOT 1ST. BYPASS\n&VMFE1ST SETB  1                        SET 1ST. TIME THRU FLAG\n*    Unique code                                                      *\n*---------------------------------------------------------------------*\n         MVI   &VNAME.2,C' '            SPACE FILL DATA\n         MVC   &VNAME.2+1(55),&VNAME.2  USING RIPPLE MOVE\n         MVC   &VNAME.2(7),=C'VDEFINE'  MOVE LITERAL\n         AGO   .A$441\n.A$44    ANOP\n*    Unique code                                                      *\n*---------------------------------------------------------------------*\n.A$441   ANOP\n         ST    R2,&VNAME.6             SAVE REG2\n         LA    R2,&VNAME.1             R1 DEST VALUE FOR \"CALL\"\n         LA    R1,&VNAME.2             ADDRESS OF PARAMETER\n         ST    R1,0(R2)                STORE ADDRESS\n         LA    R2,4(R2)                POINT TO NEXT ADDRESS POS\n         LA    R1,&VNAME.3             ETC...\n         ST    R1,0(R2)                    \"\n         LA    R2,4(R2)                    \"\n         LA    R2,4(R2)                <-- \" (ALLOW FOR 'INT NAME @')\n         LA    R1,&VNAME.4                 \"\n         ST    R1,0(R2)                    \"\n         LA    R2,4(R2)                    \"\n         LA    R1,&VNAME.8                 \"\n         ST    R1,0(R2)                    \"\n         LA    R2,4(R2)                    \"\n         LA    R1,&VNAME.9                 \"\n         ST    R1,0(R2)                    \"\n         MVI   0(R2),X'80'                 \"\n         L     R2,&VNAME.6                RESET R2\n.A$55    ANOP\n*-----------------------------------------------------------------*\n*    Common code                                                      *\n*---------------------------------------------------------------------*\n         AIF   (T'&MF EQ 'O').A$66\n         MVC   &VNAME.4(8),=CL8'&FORMAT' SET UP \"(ISPF-FORM)\" VALUE\n.A$66    ANOP\n         MVC   &VNAME.3(10),=CL10'&INM'   SET UP \"(ISPF-NAME)\" VALUE\n.*--------------------------------------------------------------------*\n.* Test if length is supplied in a register\n.*--------------------------------------------------------------------*\n         AIF ('&LEN'(1,1) NE '(').NREGL\n&PL      SETA  K'&LEN\n&REGL    SETC  '&LEN'(2,&PL-2)            EXTRACT REGISTER\n         ST    &REGL.,&VNAME.8            SAVE REGISTER PASSED LENGTH\n         AGO   .FINLEN                    .BYPASS NUMERIC LENGTH\n.NREGL   ANOP\n         MVC   &VNAME.5(&LL),=CL&LL'&LEN' SET UP LENGTH\n         PACK  &VNAME.7,&VNAME.5(&LL)     PACK LENGTH FOR CONVERSION\n         CVB   R1,&VNAME.7                CONV LEN TO FULL WD BIN\n         ST    R1,&VNAME.8                SAVE CONVERTED  LENGTH\n.FINLEN  ANOP\n.*--------------------------------------------------------------------*\n         LA    R1,&ANM                    ADDRESS OF INTERNAL NAME\n         ST    R1,&VNAME.1+8              SAVE INT NAME @\n         LA    R1,&VNAME.1                LOAD PARAMETER LIST ADDRESS\n         L     15,ISPLINK                 LOAD \"ISPLINK\" ADDRESS\n.*       L     15,=V(ISPLINK)             LOAD \"ISPLINK\" ADDRESS\n         BALR  14,15                      BRANCH AND LINK\n         POP   PRINT\n         MEXIT\n.*--------------------------------------------------------------------*\n.E1      MNOTE 8,'INVALID \"MF\" PARAMETER PASSED'\n.*--------------------------------------------------------------------*\n         POP   PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KICKOFF": {"ttr": 8708, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00B\\x00\\x87 ?\\x00\\x99 /\\x12S\\x01*\\x00L\\x00\\x00\\xe3\\xe2\\xc7\\xc1\\xd2\\xf2@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "1987-07-22T00:00:00", "modifydate": "1999-07-21T12:53:42", "lines": 298, "newlines": 76, "modlines": 0, "user": "TSGAK2"}, "text": "         MACRO\n&NAME    KICKOFF &BASE,&GETMAINS,&GETMAINL,&LIST=NO,&HELP=NO,&DREG=,   X\n               &AMODE=31,&RMODE=ANY,&SAVE=,&LOC=\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'KICKOFF' parameters    *\n* and it's use, pass parameter of 'HELP=Yes'.                         *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n* Macro to generate all the house keeping etc.. at start of a program,*\n* either re-entrant or not.                                           *\n* This macro works in conjunction with the 'RACKOFF' macro.           *\n*                                                                     *\n* PARAMETERS:\n* 1. Base register(s) - Format \"(Rx,Ry,Rz)\" or \"Rx\". May have up to   *\n*                       3 base registers specified. R13 may not be    *\n*                       used for re-entrant programs (refer 2 below). *\n*                       For non re-entrant programs, if R13 is used   *\n*                       as one of the base registers, it will be used *\n*                       as the first base regardless of it's position *\n*                       in the parameter string, and the initial base *\n*                       will be the conventional register save area   *\n*                       NOT the start of the program.                 *\n*                       Default is \"(R11,R12)\".                       *\n* 2. First variable,s name in the DSECT of a GETMAINEd area.  This    *\n*    parameter is optional, however, if it used (eg. re-entrant       *\n*    programs), R13 may not be used as a base register and the first  *\n*    18 full words must be used for register save and linkage         *\n*    conventions.                                                     *\n* 3. Length of the GETMAINEd area (must be an \"EQU\" variable) and must*\n*    be supplied if variable name parameter is supplied.              *\n* 4. AMODE=..  - Addressing mode '24/31' (default = 31)               *\n* 5. DREG=Rn   - Additional DSECT register on GETMAINEd area. (Use    *\n*                only if you have addressability problems on the      *\n*                GETMAINE'd DSECT. Do not enclose in brackets.)       *\n* 6. HELP=...  - Display help comments. 'YES/NO' (default = NO).      *\n* 7. LIST=...  - Display code generated. 'YES/NO' (default = YES).    *\n* 8. LOC=....  - Optional loaction for the GETMAINed area if that     *\n*                option is used. It must be a valid parameter as      *\n*                defined by the IBM GETMAIN macro.                    *\n* 9. RMODE=..  - Load  mode '24/ANY' (default = ANY)                  *\n*10. SAVE=...  - Variable name of register save area if you wish to   *\n*                control it's name. (useful if specialised exit       *\n*                in-lieu of 'RACKOFF'.                                *\n*                                                                     *\n* GENERATES:                                                          *\n* 1. Inserts a \"program_date_time\" stamp at start of module.          *\n* 2. Sets up all the register equates.                                *\n* 3. Saves callers registers R14 thru R12.                            *\n* 4. Points R13 to the programs savearea.                             *\n* 5. Establishes addresability thru supplied register(s) or default   *\n*     base registers R11 + R12.                                       *\n* 6. Workarea is GETMAINEd and the conventional linkage pointers,     *\n*     registers saved and R13 pointed to the start of the work area.  *\n* 7. As R0 + R1 are used as work registers at start, they are restored*\n*     from callers savearea.                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PUSH  PRINT\n         PRINT NOGEN\n.A$XX    ANOP\n         GBLB  &KO1STR1\n         GBLC  &R,&GETMADR,&GETMADL,&SAVREGS\n         LCLC  &E,&BASE1,&BASE2,&BASE3,&BASE#,&#DREG,&#GMM\n         LCLA  &A,&#BASES,&GETMLEN\n         AIF   (T'&GETMAINS EQ 'O').NRENT\n         AIF   (T'&GETMAINL EQ 'O').ERR2\n.NRENT   ANOP\n&GETMADR SETC  '&GETMAINS'\n&GETMADL SETC  '&GETMAINL'\n.*--------------------------------------------------------------------*\n         AIF   (T'&SAVE EQ 'O').DEFSRG      BYPASS IF DEFAULT SAVE NAME\n&SAVREGS SETC  '&SAVE'\n         AGO   .A$$XX                       BYPASS DEFAULT NAME\n.DEFSRG  ANOP\n&SAVREGS SETC  '$SAV'.'&SYSNDX'\n.A$$XX   ANOP\n.*--------------------------------------------------------------------*\n         LCLC  &TNAME\n         AIF   (T'&BASE EQ 'O').DEFAULT\n&BASE1   SETC  '&SYSLIST(1,1)'\n&BASE2   SETC  '&SYSLIST(1,2)'\n&BASE3   SETC  '&SYSLIST(1,3)'\n&#BASES  SETA  N'&SYSLIST(1)\n         AIF   (T'&GETMAINS EQ 'O').A$00    NON-R BYPASS\n         AIF   ('&BASE1' EQ 'R13').ERRR13\n         AIF   ('&BASE2' EQ 'R13').ERRR13\n         AIF   ('&BASE3' EQ 'R13').ERRR13\n         AIF   ('&BASE1' EQ '13').ERRR13\n         AIF   ('&BASE2' EQ '13').ERRR13\n         AIF   ('&BASE3' EQ '13').ERRR13\n.A$00    ANOP\n         AIF   ('&BASE2' EQ 'R13').BASE213\n         AIF   ('&BASE2' EQ '13').BASE213\n         AIF   ('&BASE3' EQ 'R13').BASE313\n         AIF   ('&BASE3' EQ '13').BASE313\n         AGO   .CONT1\n.BASE213 ANOP\n&BASE#   SETC  '&BASE1'\n&BASE1   SETC  '&BASE2'\n&BASE2   SETC  '&BASE#'\n         AGO   .CONT1\n.BASE313 ANOP\n&BASE#   SETC  '&BASE1'\n&BASE1   SETC  '&BASE3'\n&BASE3   SETC  '&BASE#'\n         AGO   .CONT1\n.DEFAULT ANOP\n&#BASES  SETA  2\n&BASE1   SETC  'R11'\n&BASE2   SETC  'R12'\n.CONT1   ANOP\n         AIF   (T'&GETMAINS EQ 'O').NONR0   NON-R BYPASS\n         AIF   (T'&DREG EQ 'O').NONR0       NO 2ND.DSECT REG, BYPASS\n         AIF   ('&DREG' EQ '&BASE1').ERDREG IF SAME AS BASE 1, ERROR\n         AIF   ('&DREG' EQ '&BASE2').ERDREG IF SAME AS BASE 2, ERROR\n         AIF   ('&DREG' EQ '&BASE3').ERDREG IF SAME AS BASE 3, ERROR\n         AIF   ('&DREG' EQ 'R13').ERDREG    IF R13, ERROR\n         AIF   ('&DREG' EQ '13').ERDREG     IF R13, ERROR\n         AIF   ('&DREG' EQ 'RD').ERDREG     IF R13, ERROR\n&#DREG   SETC  ',&DREG'                     SET SECONDARY DSECT REG\n.NONR0   ANOP\n.*--------------------------------------------------------------------*\n         AIF      ('&NAME' EQ '').NONAME\n&E       SETC     '&NAME'\n         AGO      .A\n.NONAME  ANOP\n&E       SETC    'NULL&SYSNDX'\n.A       ANOP\n&E       CSECT\n.TAMODE  ANOP\n         AIF ('&AMODE' NE '31').AM24$\n&E       AMODE  31                          AMODE OF 31\n         AGO    .TRMODE                     Continue\n.AM24$   ANOP\n&E       AMODE  24                          AMODE OF 24 REQUESTED\n&E       RMODE  24                          RMODE OF 24 FORCED\n         AGO    .BYP#10                     Continue\n.TRMODE  ANOP\n         AIF ('&RMODE' NE 'ANY').RM24$$\n&E       RMODE  ANY                         RMODE OF ANY\n         AGO    .BYP#10                     Continue\n.RM24$$  ANOP\n&E       RMODE  24                          RMODE OF 24 REQUESTED\n.BYP#10  ANOP\n&R       SETC     'R'\n         AIF ('&BASE1' EQ 'R13').SAVANCH\n         AIF ('&BASE1' NE '13').TEST1ST\n.SAVANCH ANOP\n&E       SETC     '&SAVREGS'                SET REGISTER SAVE AREA BASE\n.*--------------------------------------------------------------------*\n.TEST1ST ANOP\n         AIF   (&KO1STR1).C                 FIRST TIME THRU\n&KO1STR1 SETB 1\nR0       EQU    0\nR1       EQU    1\nR2       EQU    2\nR3       EQU    3\nR4       EQU    4\nR5       EQU    5\nR6       EQU    6\nR7       EQU    7\nR8       EQU    8\nR9       EQU    9\nR10      EQU   10\nRA       EQU   10\nR11      EQU   11\nRB       EQU   11\nR12      EQU   12\nRC       EQU   12\nR13      EQU   13\nRD       EQU   13\nR14      EQU   14\nRE       EQU   14\nR15      EQU   15\nRF       EQU   15\n*---------------------------------------------------------------------*\n.C       ANOP\n         B     30(&R.15)                    BRANCH AROUND P/D/T STAMP\n         DC    CL8'&NAME'                   PROGRAM STAMP\n         DC    C'_'                         DELIMITER\n         DC    CL8'&SYSDATE'                DATE STAMP\n         DC    C'_'                         DELIMITER\n         DC    CL8'&SYSTIME'                TIME STAMP\n         STM   &R.14,&R.12,12(&R.13)        SAVE REGISTERS\n         AIF   (T'&GETMAINS EQ 'O').NONR1   NON-R BYPASS\n.*--------------------------------------------------------------------*\n.*      RE-ENTRANT PROG                                               *\n.*--------------------------------------------------------------------*\n         LR    2,15                         LOAD R2 WITH START OF PR\n         USING &NAME,2                      USE R2 AS TEMPORARY BASE\n.*--------------------------------------------------------------------*\n         AIF (T'&LOC EQ 'O').NOGMLOC\n*        GETMAIN R,LV=&GETMAINL,&LOC        GETMAIN AREA\n         GETMAIN R,LV=&GETMAINL,&LOC        GETMAIN AREA\n         AGO   .A$$000\n.NOGMLOC ANOP\n*        GETMAIN R,LV=&GETMAINL             GETMAIN AREA\n         GETMAIN R,LV=&GETMAINL             GETMAIN AREA\n.A$$000  ANOP\n.*--------------------------------------------------------------------*\n         ST    &R.13,4(&R.1)                BACKWARD CHAIN\n         ST    &R.1,8(&R.13)                FORWARD CHAIN\n.*--------------------------------------------------------------------*\n.* The next line does horrible things with 31 bit addressing.         *\n.*       NI    12(&R.13),X'00'              CLEAR TRACE BITS\n.*--------------------------------------------------------------------*\n         LR    &R.13,&R.1                   SAVE AREA @\n         AIF   (T'&DREG EQ 'O').NDREG1      NO 2ND.DSECT REG, BYPASS\n         LA    &DREG,4095(&R.13)            POINT 2ND. REG 1K PAST\n         LA    &DREG,1(&DREG)                 1ST. DSECT BASE\n.NDREG1  ANOP\n         USING &GETMADR,&R.13&#DREG         ADDRESABILITY TO GETMAIN\n         LR    &BASE1,&R.2                  &BASE1 IS 1ST. BASE REG\n         DROP  &R.2                         DROP REGISTER 15 AS BASE\n         AIF      (&#BASES GT 1).TWOBASE\n         USING &E,&BASE1                    USING ONE BASE REGISTER\n         AGO      .RESTR0R2\n.NONR1   ANOP\n.*--------------------------------------------------------------------*\n.*      NON RE-ENTRANT PROG                                           *\n.*--------------------------------------------------------------------*\n         USING &NAME,15                     USE R15 AS TEMPORARY BASE\n         ST    &R.13,&SAVREGS.+4            BACKWARD CHAIN\n         LA    &R.0,&SAVREGS                OUR SAVEAREA ADDRESS\n         ST    &R.0,8(&R.13)                FORWARD CHAIN\n.*--------------------------------------------------------------------*\n.* The next line does horrible things with 31 bit addressing.         *\n.*       NI    12(&R.13),X'00'              CLEAR TRACE BITS\n.*--------------------------------------------------------------------*\n         LR    13,0                         R13 POINT TO OUR SAVEAREA\n         AIF ('&E' EQ '&SAVREGS').NOLOAD1   BUPASS BASE LOAD\n         LR    &BASE1,15                    &BASE1 IS 1ST. BASE REG\n.NOLOAD1 ANOP\n         AIF      (&#BASES GT 1).TWOBASE\n         DROP  15                           RELINQUISH ADDRESSABILITY\n         USING &E,&BASE1                    USING ONE BASE REGISTER\n         AGO      .ADROK\n.TWOBASE ANOP\n         LA    &BASE2,4095(&BASE1)          POINT 2ND. REG 1K PAST\n         LA    &BASE2,1(&BASE2)               1ST. BASE\n         AIF      (&#BASES GT 2).THRBASE\n         DROP  15                           RELINQUISH ADDRESSABILITY\n         USING &E,&BASE1,&BASE2             USING TWO BASE REGISTERS\n         AGO      .ADROK\n.THRBASE ANOP\n         LA    &BASE3,4095(&BASE2)          POINT 3RD. REG 1K PAST\n         LA    &BASE3,1(&BASE3)               2ND. BASE\n         DROP  15                           RELINQUISH ADDRESSABILITY\n         USING &E,&BASE1,&BASE2,&BASE3      USING THREE BASE REGISTERS\n.*       AGO      .ADROK\n.ADROK   ANOP\n         AIF   (T'&GETMAINS NE 'O').RESTR0R2 RE-ENT PROCESSING\n         LA    1,&E                         ADDRESS OF CSECT\n         LA    0,&SAVREGS                   NEW BASE ADDRESS\n         SR    1,0                          SUBTRACT THE DIFFERENCE\n         STH   1,KOFFCOMP                   STORE UNDER @ COMPENSATOR\n         B     &SAVREGS.+74                 BRANCH AROUND SAVE AREA\n&SAVREGS DS    18F\nKOFFCOMP DS    H                            KICKOFF BASE @ COMPENSATOR\n         XR    &R.0,&R.0                    ZERO REGISTER 0\n         ST    &R.0,&SAVREGS.+8             CLEAR FORWARD CHAIN\n         L     &R.1,4(&R.13)                LOAD CALLERS SAVEAREA @\n         LM    &R.0,&R.1,20(&R.1)           RESTORE PARM REGISTERS\n         AGO   .MEXIT1\n.*--------------------------------------------------------------------*\n.RESTR0R2 ANOP\n.*--------------------------------------------------------------------*\n.*      RE-ENTRANT PROG                                               *\n.*--------------------------------------------------------------------*\n         XR    &R.0,&R.0                    ZERO REGISTER 0\n         ST    &R.0,8(&R.13)                CLEAR FORWARD CHAIN\n         L     &R.1,4(&R.13)                LOAD CALLERS SAVEAREA @\n         LM    &R.0,&R.2,20(&R.1)           RESTORE PARM REGISTERS\n         AGO   .MEXIT1\n.*--------------------------------------------------------------------*\n.ERR     MNOTE 8,'MUST SUPPLY WORK-AREA DSECT FOR GETMAIN.'\n         AGO   .MEXIT1\n.ERR2    MNOTE 8,'MUST SUPPLY WORK-AREA DSECT LENGTH FOR GETMAIN.'\n         AGO   .MEXIT1\n.ERR3    MNOTE 8,'NO MATCHING RACKOFF FOR PREVIOUS KICKOFF.'\n         AGO   .MEXIT1\n.ERRR13  MNOTE 8,'R13 CANNOT BE USED AS BASE FOR RE-ENTRANT MACRO.'\n         AGO   .MEXIT1\n.ERDREG  MNOTE 8,'XTRA DSECT REGISTER MUST NOT BE A BASE OR R13.'\n         AGO   .MEXIT1\n.MEXIT1  ANOP\n         AIF   ('&LIST'(1,1) NE 'N').MEXIT9\n         POP PRINT\n.MEXIT9  ANOP\n*---------------------------------------------------------------------*\n         MEXIT\n.*--------------------------------------------------------------------*\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACT1": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x08\\x00\\x93$/\\x00\\x93$/\\x16Y\\x00\\x07\\x00\\x06\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-08-30T00:00:00", "modifydate": "1993-08-30T16:59:08", "lines": 7, "newlines": 6, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    MACT1 &SOURCE\n         LCLA  &PLL\n&PLL     SETA  K'&SOURCE\n         DC    C'&PLL'\n         LA    R1,&SOURCE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NCRACEGE": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00C\\x00\\x96%\\x7f\\x00\\x96%\\x7f\\x12P\\x00\\x9c\\x00\\x9c\\x00\\x00\\xe3\\xf6\\xf6\\xd2\\xd2\\xd2@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1996-09-13T00:00:00", "modifydate": "1996-09-13T12:50:43", "lines": 156, "newlines": 156, "modlines": 0, "user": "T66KKK"}, "text": "         MACRO\n&NAME    $TRACEGE &TYPE,           Macro type, START/FAIL              X\n               &FORMAT=CWATERM,    Test format                         X\n               &FAIL=,             Label if miss                       X\n               &CWA=CWA+X'130',    CWA+X'130' access                   X\n               &TCTTETI=TCTTETI,   Term id    access                   X\n               &TCTTECIA=TCTTECIA, Term user area access               X\n               &LIST=Y,&HELP=N\n.*\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the '$TRACEGE' parameters   *\n* and it's use, pass parameter of 'HELP=Yes'.                         *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n* Macro to generate code to test for trace condition based on the     *\n* format supplied.                                                    *\n*                                                                     *\n* PARAMETERS:                                                         *\n* 1. Type             - Type of macro. It can be either a START or    *\n*                       FAIL. The should be paired and should not be  *\n*                       mixed unless the FAIL= option is used. The    *\n*                       default is FAIL as only a label is generated. *\n* 2. FAIL=nnnn        - Number suffix used to control generation of   *\n*                       the miss match                                *\n*                       labels. Without this parameter, the internal  *\n*                       index is used.                                *\n* 3. FORMAT=cccccccc  - The format of the test to be used.            *\n*                       The following options are available.          *\n*                       a) CWATERM - test for termid matching any non *\n*                                    X'00' at X'130' offset from the  *\n*                                    CWA. Up to 30 terminals can be   *\n*                                    defined and use LZAP to ZAP the  *\n*                                    CWA. This is the default.        *\n*                                    Requires addressability to       *\n*                                     . CWA                           *\n*                                     . TCTTE                         *\n*                                    or you may specify your own      *\n*                                    access to                        *\n*    CWA=expression   - any expression to access CWA+X'130' (default) *\n*                       eg. CWAX130 where the CWA is ORG'd            *\n*    TCTTETI=expr     - any expression to access the TCTTETI,         *\n*                       eg. TCTTETI-DFHTCTTE(5) where R5 -> TCTTE     *\n*                       b) CWAUSER - test for userid extracted from   *\n*                                    the TCTUA matching any non       *\n*                                    X'00' at X'130' offset from the  *\n*                                    CWA. Up to 10 users can be       *\n*                                    defined and use LZAP to ZAP the  *\n*                                    CWA. Each userid should be 8     *\n*                                    bytes long with trailing spaces. *\n*                                    Requires addressability to       *\n*                                     . CWA                           *\n*                                     . TCTTE                         *\n*                                    or you may specify your own      *\n*                                    access to                        *\n*    CWA=expression   - any expression to access CWA+X'130' (default) *\n*                       eg. CWAX130 where the CWA is ORG'd            *\n*    TCTTECIA=expr    - any expression to access the TCTTECIA,        *\n*                       eg. TCTTECIA-DFHTCTTE(5) where R5 -> TCTTE    *\n*                                    Requires the following DSECTs    *\n*                                     . TCTUA (KPW0908)               *\n*                                                                     *\n* NOTES - Registers 14 and 15 will be changed.                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         GBLC  &T$MISS\n         LCLC  &T$NAME,&T$LOOP,&T$HIT\n         LCLA  &PL\n.*\n         AIF   (T'&FAIL EQ 'O').NAMES      Use defults\n&T$MISS  SETC  '&FAIL'\n.*\n.NAMES   ANOP\n         AIF   (T'&TYPE EQ 'O').ENDTR      FAIL by default\n         AIF   ('&TYPE'(1,1) NE 'S').ENDTR FAIL specified\n&T$NAME  SETC  'T$'.'&SYSNDX'\n&T$LOOP  SETC  '&T$NAME'.'01'\n&T$HIT   SETC  '&T$NAME'.'02'\n&T$SAVE  SETC  '&T$NAME'.'03'\n         AIF   (T'&FAIL NE 'O').STARTTR    Use supplied label\n&T$MISS  SETC  '&T$NAME'.'09'\n.*--------------------------------------------------------------------*\n.* Start Trace condition testing                                      *\n.*--------------------------------------------------------------------*\n.STARTTR ANOP\n         AIF   (T'&FORMAT EQ 'O').CWATERM  'CWATERM' by default\n         AIF   ('&FORMAT' EQ 'CWATERM').CWATERM  'CWATERM'\n         AIF   ('&FORMAT' EQ 'CWAUSER').CWAUSER  'CWAUSER'\n         AGO   .ERR1\n.CWATERM ANOP\n         L     15,X'21C'(,0)           OLD TCB POINTER (FROM PSA)\n         L     15,X'D0'(,15)           TCB EXTENTION\n         L     15,X'14'(,15)           AFCB\n         L     15,X'08'(,15)           CSA 3.3 OR HIGHER\n         L     14,X'4C'(,15)           TCA (USER)\n         L     14,X'08'(,14)           TCTTE@\n         MVC   &T$SAVE(4),0(14)        MOVE TERMID\n         L     15,X'E4'(,15)           CWA\n         LA    15,X'130'(15)           POINT TO CWA FILLER ZAPED\n         LA    14,30                   LOOP LIMIT\n         B     &T$LOOP                 BYPASS SAVE AREA\n&T$SAVE  DC    CL4'                    '               DATA SAVE AREA\n&T$LOOP  DS    0H\n         CLC   =X'00000000',0(15)      ZAPPED\n         BE    &T$MISS                 NO, BYPASS TRACING\n         CLC   0(4,15),&T$SAVE         MATCH TERMID\n         BE    &T$HIT                  REGISTER\n         LA    15,4(15)                NEXT FIELD\n         BCT   14,&T$LOOP              LOOP TILL END\n         B     &T$MISS                 REACHED LOOP LIMIT\n&T$HIT   DS    0H\n         AGO   .MEXIT1\n.*\n.*--------------------------------------------------------------------*\n.CWAUSER ANOP\n         B     &T$SAVE+L'&T$SAVE       BYPASS SAVE AREA\n         DS    0H                      HALF WORD ALINGMENT\n&T$SAVE  DC    CL8' '                  DATA SAVE AREA\n         L     15,&TCTTECIA            TERMINAL USER AREA\n         MVC   &T$SAVE.(7),TUASIGN-TCTUA(15) SAVE USERID (KPW0908)\n         LA    15,&CWA                 POINT TO CWA FILLER ZAPED\n         LA    14,10                   LOOP LIMIT\n&T$LOOP  DS    0H\n         CLC   =X'00000000',0(15)      ZAPPED\n         BE    &T$MISS                 NO, BYPASS TRACING\n         CLC   0(7,15),&T$SAVE         MATCH USERID\n         BE    &T$HIT                  REGISTER\n         LA    15,8(15)                NEXT FIELD\n         BCT   14,&T$LOOP              LOOP TILL END\n         B     &T$MISS                 REACHED LOOP LIMIT\n&T$HIT   DS    0H\n         AGO   .MEXIT1\n.*\n.*--------------------------------------------------------------------*\n.*\n.*--------------------------------------------------------------------*\n.*\n.ENDTR   ANOP\n&T$MISS  DS    0H\n         AGO   .MEXIT1\n.*--------------------------------------------------------------------*\n.ERR1    MNOTE 8,'FORMAT &FORMAT NOT VALID'\n         AGO   .MEXIT1\n.*--------------------------------------------------------------------*\n.MEXIT1  ANOP\n*---------------------------------------------------------------------*\n         POP PRINT\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDUMP": {"ttr": 2817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01%\\x00E\\x00\\x96\\x16_\\x00\\x96%\\x0f\\x12Y\\x01\\xcd\\x01`\\x00\\x00\\xe3\\xf6\\xf6\\xd2\\xd2\\xd2@@@@'", "ispf": {"version": "01.37", "flags": 0, "createdate": "1996-06-13T00:00:00", "modifydate": "1996-09-06T12:59:45", "lines": 461, "newlines": 352, "modlines": 0, "user": "T66KKK"}, "text": "         MACRO\n&NAME    PDUMP &START,&LEN,                                            X\n               &MSG=,                                                  X\n               &QUIT=,                                                 X\n               &REGS=YES,                                              X\n               &LOAD@=,                                                X\n               &DUMK@=,                                                X\n               &CICS=NO,                                               X\n               &ISPR=YES,                                              X\n               &ALTSAVE=,                                              X\n               &TRACE=,                                                X\n               &VTAML=,                                                X\n               &AUTH=NO,                                               X\n               &HELP=NO,                                               X\n               &LIST=NO,                                               X\n               &MF=\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'PDUMP' parameter and   *\n* it's use, pass parameter 'HELP=Yes'.\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*  Macro to provide a formatted screen display of either the program  *\n*    or selected data area.                                           *\n*                                                                     *\n*  PARAMETERS:                                                        *\n*    1. Display address. This may be any A-type address or register   *\n*       (2) - (13).                                                   *\n*    2. Length of data to be displayed. Without this parameter you    *\n*       may scroll down untill an addressing exception (0C4) occurs,  *\n*       (which will be trapped with an appropriate message).          *\n*    3. LIST=No / Yes\n*             Default is 'NO'                                         *\n*    4. TRACE=address\n*             Trace supervisor address. Pointer to a flag indicating  *\n*             trace status. 'N' indicates off, Any-Other-value implies*\n*             on.                                                     *\n*             This flag is turned off by the 'TRACE OFF' command or   *\n*             explicitly setting it to 'N' within the program logic   *\n*             between executions of the macro.                        *\n*             Flag is turned on by a PDUMP macro without the flag or  *\n*             using PDUMP with a diferent parameter address.          *\n*    5. VTAML=.....                                                   *\n*             Reserved for 'HALKEY' VTAM debuging                     *\n*    5. LOAD@=.....                                                   *\n*             Variable or register supplying the load address of      *\n*             PROGDUMP thereby bypassing the LOAD.                    *\n*    5. DUMK@=.....                                                   *\n*             Variable or register supplying the load address of      *\n*             PROGDUMK thereby bypassing the LOAD.                    *\n*    6. AUTH=Y / N                                                    *\n*             Authorised request. Permit authorised zapping of        *\n*             normally unaccessible addresses. The calling program    *\n*             must be authorised.                                     *\n*    7. CICS=Y / N                                                    *\n*             If inviked from CICS, will need to issue an             *\n*             'EXEC CICS SEND / RECEIVE' rather than TPUT / TGET.     *\n*             If flag set, will invoke dedicated drivers.             *\n*    8. QUIT=address                                                  *\n*             Adress to branch to if PROGDUMP is terminated using the *\n*             'QUIT' command rather than END / PF3.                   *\n*    9. MSG='text' / variable(len) / disp(len,reg)                    *\n*             Initial message to be displayed. Either a quoted text   *\n*             or a variable with the length of message to display in  *\n*             brackets. You may use register base displacement, eg.   *\n*                MSG='MESSAGE'  or MSG=DATA(8)  or MSG=2(6,R9)        *\n*   10. ISPR=No / Yes                                                 *\n*             Issue \"ISPEXEC 'CONTROL DISPLAY REFRESH'\" if using ISPF *\n*             interface. If macro 'ISPFINIT' has been executed, the   *\n*             refresh command will be automatically executed unless   *\n*             explicitly NOT requested by this parameter.             *\n*   11. MF=E / L                                                      *\n*             For re-entrant programs.                                *\n*   12. REGS=Yes / No; parameter value of NO will suppress the initial*\n*             registers display screen on entry into the debugger.    *\n*   13. ALTSAVE=@  ; Alternative register save area to be used for    *\n*             diplaying registers. If this option is used, the        *\n*             register or data area must contain registers 0-15 (in   *\n*             that order). On exit registers 1, 14 and 15 have been   *\n*             used and will not be restored.                          *\n*             Alternatively you may use a parameter of (C,r) where    *\n*             the literal 'C' indicates normal register conventions   *\n*             and 'r' is the pointer to the register save area that   *\n*             follow conventions (ie. prev R13 is stored at 4(r) ).   *\n*                                                                     *\n*  If no parameter is supplied, the start is the start of the program *\n*    (assuming normal linkage procedures. This called routine assumes *\n*    that R15 in the SAVEAREA of the program that called the program  *\n*    calling this routine points to the start address of the program  *\n*    that called this routine. <It does make sence if you read it a   *\n*    couple of times>)                                                *\n*    The end of display is reached on the first storage violation.    *\n*                                                                     *\n*  Parameters passed to PROGDUMP from this macro:                     *\n*    The following parameter list is pointed to by R1:                *\n*    1.  0(4,Rx) - Full(X'00000000') / part('DATA') display indicator *\n*    2.  4(4,Rx) - Starting display address                           *\n*    3.  8(4,Rx) - Length of display data                             *\n*    4. 12(4,Rx) - Return address to branch to if 'QUIT' used         *\n*    5. 16(4,Rx) - VTAM address, (reserved for HALKEY)                *\n*    6. 20(1,Rx) - Display registers flag                             *\n*       21(1,Rx) - Authorised request flag                            *\n*       22(1,Rx) - CICS indicator flag (Y / N)                        *\n*       23(1,Rx) - *** Spare ***                                      *\n*    7. 24(4,Rx) - Trace supervisor flag's address                    *\n*    8. 28(4,Rx) - PROGDUMK address if pre-loaded (CICS usage)        *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         AIF   ('&LIST'(1,1) EQ 'Y').A$XX\n         PUSH  PRINT\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   (T'&NAME EQ 'O').A$00     BYPASS IF NO LABEL PASSED\n&NAME    DS    0H\n.A$00    ANOP\n         LCLC  &#START,&#LEN,&LENO,&#VTAML,&#VLT,&#MSGL,&#MSG\n         LCLC  &REGSV,&REGSV15,&LOADN,&REST15,&DUMKN,&ALTSAV#,&ALTBLD\n         GBLC  &DMPNAME\n         GBLB  &DMPFST1,&DMPFST2\n*---------------------------------------------------------------------*\n         GBLB  &INIT1ST                  USED WITH ISPF VARIABLE TO\n*                                        REFRESH IF ACTIVE\n*---------------------------------------------------------------------*\n         LCLA  &MSGL,&PL,&PC\n         AIF   (&DMPFST1).A$01\n&DMPNAME SETC  'DMP'.'&SYSNDX'\n&DMPFST1 SETB  1\n.A$01    ANOP\n&#SAVER  SETC  '&DMPNAME'.'1'\n&REGSV   SETC  '&DMPNAME'.'2'\n&REGSV15 SETC  '&DMPNAME'.'3'\n&MESL    SETC  '&DMPNAME'.'4'\n&MESS    SETC  '&DMPNAME'.'5'\n&DMPNAM  SETC  'DMP'.'&SYSNDX'\n&#RETPT  SETC  '&DMPNAM'.'6'\n         AIF   (T'&MSG EQ 'O').A$011    BYPASS IF NO MSG PASSED\n&MSGL    SETA  K'&MSG-2\n         AIF   ('&MSG'(1,1) EQ '''').A$011 BYPASS IF NO MSG QUOTED\n.*--------------------------------------------------------------------*\n.* ESTABLISH LENGTH OF VARIABLE AND MOVE LENGTH                       *\n.*--------------------------------------------------------------------*\n         LCLA  &APOST\n&MSGL    SETA  K'&MSG\n         AIF   ('&MSG'(&MSGL,1) NE ')').E3\n&MSGL1   SETA  &MSGL-1\n&APOST   SETA  0\n.LOOP1   ANOP\n         AIF   (&MSGL1 EQ  0).E4\n         AIF   ('&MSG'(&MSGL1,1) EQ ',').LOOP1E\n         AIF   ('&MSG'(&MSGL1,1) EQ '(').LOOP2E\n&MSGL1   SETA  &MSGL1-1\n         AGO   .LOOP1\n.LOOP1E  ANOP\n&APOST   SETA  &MSGL1\n&MSGL1   SETA  &MSGL1-1\n.LOOP2   ANOP\n         AIF   (&MSGL1 EQ 0).E4\n         AIF   ('&MSG'(&MSGL1,1) EQ '(').LOOP2E\n&MSGL1   SETA  &MSGL1-1\n         AGO   .LOOP2\n.LOOP2E  ANOP\n         AIF   (&APOST EQ 0).VARMSG    <======\n&MSGL3   SETC  '&MSG'(&MSGL1+1,&APOST-(&MSGL1+1))\n&MSGNW   SETC  '&MSG'(1,&MSGL1).'&MSG'(&APOST+1,&MSGL-&APOST)\n         AGO   .MSGDTOK\n.VARMSG  ANOP\n&MSGL3   SETC  '&MSG'(&MSGL1+1,&MSGL-(&MSGL1+1))\n&MSGNW   SETC  '&MSG'(1,&MSGL1-1)\n.MSGDTOK ANOP\n.*--------------------------------------------------------------------*\n.A$011   ANOP\n         AIF   ('&MF' NE 'L').A$02     PROCESS LIST FORM (RE-ENT)\n&#SAVER  DS    8F                      PARAMETER LIST AREA\n&REGSV   DS    15F                     REGISTER SAVE AREA (R0-R14)\n&REGSV15 DS    F                       REGISTER SAVE AREA (R15)\n&MESL    DS    H                       MESSAGE LENGTH\n&MESS    DS    CL79                    MESSAGE\n         AGO   .MEXIT\n.A$02    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&VTAML EQ 'O').A$029     NO VTAMLIST ADDRESS\n         AIF   ('&VTAML'(1,1) EQ '(').A$023\n&#VTAML  SETC   '&VTAML'\n&#VLT    SETC   'L'\n         AGO   .A$029\n.A$023   ANOP\n         AIF   ('&VTAML'(1,3) EQ '(1)').E2\n         AIF   ('&VTAML'(1,4) EQ '(14)').E2\n         AIF   ('&VTAML'(1,4) EQ '(15)').E2\n         AIF   ('&VTAML'(1,4) EQ '(R1)').E2\n         AIF   ('&VTAML'(1,5) EQ '(R14)').E2\n         AIF   ('&VTAML'(1,5) EQ '(R15)').E2\n&#VTAML  SETC   '0(&VTAML(1))'\n&#VLT    SETC   'LA'\n.A$029   ANOP\n.*--------------------------------------------------------------------*\n.* Establish alternate register save area                             *\n.*--------------------------------------------------------------------*\n.C0      ANOP\n         AIF   (T'&ALTSAVE EQ 'O').C09 Bypass if alternate area missing\n&P1      SETC  'NC'                    Set to non-conventional\n&ALTSAV# SETC  '&ALTSAVE'              Set as passed\n         AIF   ('&ALTSAV#'(1,1) NE '(').C09 Bypass if not brack reg\n&PL      SETA  K'&ALTSAVE                   Length\n         AIF   (&PL LE 4).C08          Bypass if too short\n         AIF   (&PL GT 6).C08          Bypass if too short\n&PC      SETA  3\n.PCLOP1  ANOP\n         AIF ('&ALTSAVE'(&PC,1) EQ ',').PCLOP1E\n&PC      SETA  &PC+1\n         AIF (&PC GT &PL).C08\n         AGO   .PCLOP1  ANOP\n.PCLOP1E ANOP\n&P1      SETC  '&ALTSAVE'(2,&PC-2)\n&P2      SETC  '&ALTSAVE'(&PC+1,&PL-(&PC+1))\n.C08     ANOP\n&ALTSAV# SETC  '0'.'&ALTSAVE'          Put in leading zero\n.C09     ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&START EQ 'O').C2    NO STARTING POINT DISPLAY START\n         AIF   ('&START'(1,1) EQ '(').A$03\n&#START  SETC   '&START'\n         AGO   .A$04\n.A$03    ANOP\n         AIF   ('&START'(1,3) EQ '(1)').E2\n         AIF   ('&START'(1,4) EQ '(14)').E2\n         AIF   ('&START'(1,4) EQ '(14)').E2\n         AIF   ('&START'(1,4) EQ '(R1)').E2\n         AIF   ('&START'(1,5) EQ '(R14)').E2\n         AIF   ('&START'(1,5) EQ '(R15)').E2\n&#START  SETC   '0(&START(1))'\n.A$04    ANOP\n&LENO    SETC  'L'                     SET LENGTH OPERATOR TO LOAD\n         AIF   (T'&LEN EQ 'O').A$07    HAVE LENGTH, BYPASS\n         AIF   ('&LEN'(1,1) LT '0').A$05\n&#LEN    SETC  '=A(&LEN)'\n         AGO   .C1\n.A$05    ANOP\n&LENO    SETC  'LA'                    SET LENGTH OPERATOR TO LOAD @\n         AIF   ('&LEN'(1,1) EQ '(').A$06\n&#LEN    SETC   '&LEN'\n         AGO   .C1\n.A$06    ANOP\n         AIF   ('&LEN'(1,3) EQ '(1)').E2\n         AIF   ('&LEN'(1,4) EQ '(14)').E2\n         AIF   ('&LEN'(1,4) EQ '(15)').E2\n         AIF   ('&LEN'(1,4) EQ '(R1)').E2\n         AIF   ('&LEN'(1,5) EQ '(R14)').E2\n         AIF   ('&LEN'(1,5) EQ '(R15)').E2\n&#LEN    SETC   '0(&LEN(1))'\n&LENO    SETC  'LA'                    SET LENGTH OPERATOR TO LOAD @\n         AGO   .C1\n.A$07    ANOP\n&#LEN    SETC  '=X''7FFFFFFF'''        SET MAXIMUM LENGTH\n&LENO    SETC  'LA'                    SET LENGTH OPERATOR TO LOAD @\n.C1      ANOP\n         AIF   (T'&LOAD@ NE 'O').C11   Bypass if present\n         AIF   (T'&CICS EQ 'O').C11    Bypass if not CICS\n         AIF   ('&CICS'(1,1) EQ 'Y').E5  LOAD@ required for CICS use\n.C11     ANOP\n         AIF   (T'&LOAD@ EQ 'O').C13   Bypass if missing\n         AIF   ('&LOAD@'(1,1) EQ '(').C12\n&LOADN SETC    '&LOAD@'                Set load address from variable\n         AGO   .C13\n.C12     ANOP\n&LOADN SETC    '0(&LOAD@(1))'          Set load address from register\n.C13     ANOP\n         AIF   (T'&DUMK@ NE 'O').C21   Bypass if present\n         AIF   (T'&CICS EQ 'O').C21    Bypass if not CICS\n         AIF   ('&CICS'(1,1) EQ 'Y').E6  DUMK@ required for CICS use\n.C21     ANOP\n         AIF   (T'&DUMK@ EQ 'O').C23   Bypass if missing\n         AIF   ('&DUMK@'(1,1) EQ '(').C22\n&DUMKN SETC    '&DUMK@'                Set load address from variable\n         AGO   .C23\n.C22     ANOP\n&DUMKN SETC    '0(&DUMK@(1))'          Set load address from register\n.C23     ANOP\n.*\n.*--------------------------------------------------------------------*\n         AIF   (T'&ALTSAV# EQ 'O').NRSAV1Y Normal save if no alternate\n         AIF   ('&P1' EQ 'C').NRSAV1X  Conventional restore\n         MVC   &REGSV.(64),&ALTSAV#    STORE REGISTERS\n         AGO   .NRSAV1Z                Bypass\n.NRSAV1X ANOP\n         L     1,4(&P2)                     LOAD PREV SAVE AREA\n         MVC   &REGSV.(52),20(1)            MOVE REGS 0-12\n         ST    1,&REGSV.+52                 SAVE 13 POINTER\n         MVC   &REGSV.+56(8),12(1)          MOVE REGS 14-15\n         AGO   .NRSAV1Z                Bypass\n.NRSAV1Y ANOP\n         STM   0,15,&REGSV             STORE REGISTERS\n.NRSAV1Z ANOP\n.*--------------------------------------------------------------------*\n.*\n         AIF   (T'&LOADN EQ 'O').LOADHD1\n         LA    15,&LOADN               LOAD ENTRY POINT OF PROGRAM\n         AGO   .LOADED1                Bypass auto load\n.LOADHD1 ANOP\n         LOAD  EP=PROGDUMP             LOAD PROGRAM DUMP\n         LR    15,0                    LOAD ENTRY POINT OF PROGRAM\n.LOADED1 ANOP\n         LA    1,&#SAVER               POINT 1 TO SAVE AREA\n         MVC   0(4,1),=C'DATA'         DATA INDICATOR\n         LA    14,&#START              START OF DUMP\n         ST    14,4(1)                 STORE START ADDRESS\n         &LENO 14,&#LEN                LOAD LENGTH\n         ST    14,8(1)                 STORE LENGTH OF PROGRAM\n         AGO   .LOAD                   GO LOAD/CALL PROGDUMP\n.*--------------------------------------------------------------------*\n.C2      ANOP\n.*\n.*--------------------------------------------------------------------*\n         AIF   (T'&ALTSAV# EQ 'O').NRSAV2Y Normal save if no alternate\n         AIF   ('&P1' EQ 'C').NRSAV2X  Conventional restore\n         MVC   &REGSV.(64),&ALTSAV#    STORE REGISTERS\n         AGO   .NRSAV2Z                Bypass\n.NRSAV2X ANOP\n         L     1,4(&P2)                     LOAD PREV SAVE AREA\n         MVC   &REGSV.(52),20(1)            MOVE REGS 0-12\n         ST    1,&REGSV.+52                 SAVE 13 POINTER\n         MVC   &REGSV.+56(8),12(1)          MOVE REGS 14-15\n         AGO   .NRSAV2Z                Bypass\n.NRSAV2Y ANOP\n         STM   0,15,&REGSV             STORE REGISTERS\n.NRSAV2Z ANOP\n.*--------------------------------------------------------------------*\n.*\n         AIF   (T'&LOADN EQ 'O').LOADHD2\n         LA    15,&LOADN               LOAD ENTRY POINT OF PROGRAM\n         AGO   .LOADED2                Bypass auto load\n.LOADHD2 ANOP\n         LOAD  EP=PROGDUMP             LOAD PROGRAM DUMP\n         LR    15,0                    LOAD ENTRY POINT OF PROGRAM\n.LOADED2 ANOP\n         LA    1,&#SAVER               POINT 1 TO SAVE AREA\n         XC    0(4,1),0(1)             CLEAR DATA INDICATOR\n.LOAD    ANOP\n         LA    14,&#RETPT              RETURN @ FROM PROGRAM DUMP\n         ST    14,12(1)                STORE RETURN ADDRESS\n         AIF   (T'&VTAML EQ 'O').NOVTL1   BYPASS IF NO VTAMLIST\n         &#VLT 14,&#VTAML              LOAD LENGTH\n         ST    14,16(1)                STORE VTAMLIST ADDRESS\n.*--------------------------------------------------------------------*\n.NOVTL1  ANOP\n         XC    &MESL.(2),&MESL         INITIALISE MESSAGE LENGTH\n         AIF   (T'&MSG EQ 'O').NOMESSG  BYPASS IF NO VTAMLIST\n         AIF   ('&MSG'(1,1) EQ '''').MSGLIT1 BYPASS IF LIT SUPPLIED\n         MVC   &MESL.(2),=H'&MSGL3'    MOVE MESSAGE LENGTH\n         MVC   &MESS.(&MSGL3),&MSGNW   MOVE VARIABLE MESSAGE\n         AGO   .NOMESSG\n.*--------------------------------------------------------------------*\n.MSGLIT1 ANOP\n         MVC   &MESL.(2),=H'&MSGL'     MOVE MESSAGE LENGTH\n         MVC   &MESS.(&MSGL),=C&MSG\n.NOMESSG ANOP\n.*--------------------------------------------------------------------*\n         AIF ('&REGS'(1,1) EQ 'Y').REGSDY\n         MVI   20(1),C'N'              DISPLAY/NOT REGS\n         AGO   .REGSDON\n.REGSDY  ANOP\n         MVI   20(1),C'Y'              DISPLAY/NOT REGS\n.REGSDON ANOP\n.*--------------------------------------------------------------------*\n         AIF ('&AUTH'(1,1) EQ 'Y').AUTHDY\n         MVI   21(1),C'N'              AUTHORISATION NOT REQUESTED\n         AGO   .AUTHDON\n.AUTHDY  ANOP\n         MVI   21(1),C'Y'              AUTHORISATION REQUESTED\n.AUTHDON ANOP\n.*--------------------------------------------------------------------*\n         AIF ('&CICS'(1,1) EQ 'Y').CICSEY\n         MVI   22(1),C'N'              NOT CICS ENVIRONMENT\n         AGO   .CICSEON\n.CICSEY  ANOP\n         MVI   22(1),C'Y'              IS CICS ENVIRONMENT\n.CICSEON ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&TRACE NE 'O').TRACADR\n         XC    24(4,1),24(1)           SET TRACE SUPERVISOR N/A\n         AGO   .TSTDUMK\n.TRACADR ANOP\n         AIF ('&TRACE'(1,1) EQ '(').TRACREG\n         LA    14,&TRACE               LOAD TRACE SUPERVISOR ADDRESS\n         AGO   .TRACST1\n.TRACREG ANOP\n         LA    14,0(&TRACE)            LOAD TRACE SUPERVISOR ADDRESS\n.TRACST1 ANOP\n         ST    14,24(1)                SAVE TRACE SUPERVISOR ADDRESS\n.*--------------------------------------------------------------------*\n.TSTDUMK ANOP\n         AIF   (T'&DUMKN EQ 'O').INIDUMK\n         LA    14,&DUMKN               LOAD ENTRY POINT OF PROGDUMK\n         ST    14,28(1)                STORE ENTRY POINT OF PROGDUMK\n         AGO   .CALLDMP                Bypass initialise\n.INIDUMK ANOP\n         XC    28(4,1),28(1)           SET DUMK@ NOT AVAILABLE\n.CALLDMP ANOP\n         BALR  14,15                   CALL 'PROGDUMP'\n&REST15  SETC  'N'                     Restore R15 required flag\n         AIF   (T'&LOADN NE 'O').DELETD1\n&REST15  SETC  'Y'                     Restore R15 required\n         ST    15,&REGSV15             SAVE RETURN REGISTER\n         DELETE EP=PROGDUMP            REMOVE PROGRAM DUMP\n.DELETD1 ANOP\n.*--------------------------------------------------------------------*\n         AIF   (&INIT1ST EQ 0).NOISPF1 BYPASS IF INITISPF NOT RUN\n         AIF   ('&ISPR'(1,1) EQ 'N').NOISPF1 BYPASS IF EXPLICITLY REQ'D\n         AIF   ('&REST15' EQ 'Y').BPS151 Bypass if R15 already saved\n&REST15  SETC  'Y'                     Restore R15 required\n         ST    15,&REGSV15             SAVE RETURN REGISTER\n.BPS151  ANOP\n*        ISPEXEC 'CONTROL DISPLAY REFRESH'\n         ISPEXEC 'CONTROL DISPLAY REFRESH'\n.NOISPF1 ANOP\n.*--------------------------------------------------------------------*\n         AIF   ('&REST15' EQ 'N').BPR151 Bypass if R15 not saved\n         L     15,&REGSV15             RESTORE RETURN REGISTER\n.BPR151  ANOP\n         AIF   (T'&ALTSAV# NE 'O').NRSAV3X BYpass restore if alt used\n         LM    0,14,&REGSV             RESTORE REGISTERS\n.NRSAV3X ANOP\n         AIF   (&DMPFST2).A$66\n&DMPFST2 SETB  1\n         AIF   ('&MF' EQ 'E').A$66     BYPASS IF EXEC FORM OF MACRO\n         B     &#RETPT                 BYPASS PARM-LIST AREA\n&#SAVER  DS    8F                      PARAMETER LIST AREA\n&REGSV   DS    15F                     REGISTER SAVE AREA (R0-R14)\n&REGSV15 DS    F                       REGISTER SAVE AREA (R15)\n&MESL    DS    H                       MESSAGE LENGTH\n&MESS    DS    CL79                    MESSAGE\n.A$66    ANOP\n&#RETPT  DS    0H\n         AIF (T'&QUIT EQ 'O').MEXIT\n         LTR   15,15                   Q. ZERO RETURN CODE\n         BNZ   &QUIT                      N. GO TO QUIT ADDRESS\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.E0      MNOTE 12,'''PDUMP'' REQUIRES A 3 FULLWORD SAVE AREA'\n         AGO   .MEXIT\n.E1      MNOTE 12,'''PDUMP'' REQUIRES A DATA AREA AND A LENGTH'\n         AGO   .MEXIT\n.E2      MNOTE 12,'DO NOT USE REGS 1, 14 OR 15 FOR PARAMETERS'\n         AGO   .MEXIT\n.E3      MNOTE 12,'INVALID VARIABLE MESSAGE FORMAT. S/B \"VARNAME(LEN)\"'\n         AGO   .MEXIT\n.E4      MNOTE 12,'MESSAGE LENGTH MUST BE LE 79 CHARACTERS'\n         AGO   .MEXIT\n.E5      MNOTE 12,'LOAD@ MUST BE SUPPLIED FOR CICS USAGE'\n         AGO   .MEXIT\n.E6      MNOTE 12,'DUMK@ MUST BE SUPPLIED FOR CICS USAGE'\n.*--------------------------------------------------------------------*\n.MEXIT   ANOP\n         AIF   ('&LIST'(1,1) EQ 'Y').MEXIT9\n         POP   PRINT\n.MEXIT9  ANOP\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDUMP$": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00R\\x00\\x94$\\x9f\\x00\\x94%\\x0f\\x10S\\x01)\\x01&\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1994-09-06T00:00:00", "modifydate": "1994-09-07T10:53:52", "lines": 297, "newlines": 294, "modlines": 0, "user": "ZTSALK"}, "text": ".*--------------------------------------------------------------------*\n.* Macro used to debug PROGDUMP. Uses program PROGDUM$.               *\n.*--------------------------------------------------------------------*\n         MACRO\n&NAME    PDUMP$ &START,&LEN,&MF=,&LIST=NO,&VTAML=,&MSG=,&REGS=YES,     X\n               &TRACE=,&AUTH=NO,&QUIT=,&HELP=NO,&ISPR=YES\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'PDUMP' parameter and   *\n* it's use, pass parameter 'HELP=Yes'.\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*  Macro to provide a formatted screen display of either the program  *\n*    or selected data area.                                           *\n*                                                                     *\n*  PARAMETERS:                                                        *\n*    1. Display address. This may be any A-type address or register   *\n*       (2) - (13).                                                   *\n*    2. Length of data to be displayed. Without this parameter you    *\n*       may scroll down untill an addressing exception (0C4) occurs,  *\n*       (which will be trapped with an appropriate message).          *\n*    3. LIST=No/Yes\n*             Default is 'NO'                                         *\n*    4. TRACE=address\n*             Trace supervisor address. Pointer to a flag indicating  *\n*             trace status. 'N' indicates off, Any-Other-value implies*\n*             on.                                                     *\n*             This flag is turned off by the 'TRACE OFF' command or   *\n*             explicitly setting it to 'N' within the program logic   *\n*             between executions of the macro.                        *\n*             Flag is turned on by a PDUMP macro without the flag or  *\n*             using PDUMP with a diferent parameter address.          *\n*    5. VTAML=.....                                                   *\n*             Reserved for 'HALKEY' VTAM debuging                     *\n*    6. AUTH=Y/N                                                      *\n*             Authorised request. Permit authorised zapping of        *\n*             normally unaccessible addresses. The calling program    *\n*             must be authorised.                                     *\n*    7. QUIT=address                                                  *\n*             Adress to branch to if PROGDUM$ is terminated using the *\n*             'QUIT' command rather than END/PF3.                     *\n*    8. MSG='text'/variable(len)                                      *\n*             Initial message to be displayed. Either a quoted text   *\n*             or a variable with the length of message to display in  *\n*             brackets. You may use register base displacement, eg.   *\n*                MSG='MESSAGE'  or MSG=DATA(8)  or MSG=2(R9)(6)       *\n*             do not use MSG=2(6,R9)                                  *\n*    9. ISPR=No/Yes                                                   *\n*             Issue \"ISPEXEC 'CONTROL DISPLAY REFRESH'\" if using ISPF *\n*             interface. If macro 'ISPFINIT' has been executed, the   *\n*             refresh command will be automatically executed unless   *\n*             explicitly NOT requested by this parameter.             *\n*   10. MF=E/L                                                        *\n*             For re-entrant programs.                                *\n*   11. REGS=Yes/No; parameter value of NO will suppress the initial  *\n*             registers display screen on entry into the debugger.    *\n*                                                                     *\n*  If no parameter is supplied, the start is the start of the program *\n*    (assuming normal linkage procedures. This called routine assumes *\n*    that R15 in the SAVEAREA of the program that called the program  *\n*    calling this routine points to the start address of the program  *\n*    that called this routine. <It does make sence if you read it a   *\n*    couple of times>)                                                *\n*    The end of display is reached on the first storage violation.    *\n*                                                                     *\n*  Parameters passed to PROGDUM$ from this macro:                     *\n*    The following parameter list is pointed to by R1:                *\n*    1.  0(4,Rx) - Full(X'00000000')/part('DATA') display indicator   *\n*    2.  4(4,Rx) - Starting display address                           *\n*    3.  8(4,Rx) - Length of display data                             *\n*    4. 12(4,Rx) - Return address to branch to if 'QUIT' used         *\n*    5. 16(4,Rx) - VTAM address, (reserved for HALKEY)                *\n*    6. 20(1,Rx) - Display registers flag                             *\n*       21(1,Rx) - Authorised request flag                            *\n*    7. 24(4,Rx) - Trace supervisor flag's address                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) EQ 'Y').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   (T'&NAME EQ 'O').A$00     BYPASS IF NO LABEL PASSED\n&NAME    DS    0H\n.A$00    ANOP\n         LCLC  &#START,&#LEN,&LENO,&#VTAML,&#VLT,&#MSGL,&#MSG\n         LCLC  &REGSV,&REGSV15\n         GBLC  &DMPNAME\n         GBLB  &DMPFST1,&DMPFST2\n*---------------------------------------------------------------------*\n         GBLB  &INIT1ST                  USED WITH ISPF VARIABLE TO\n*                                        REFRESH IF ACTIVE\n*---------------------------------------------------------------------*\n         LCLA  &MSGL\n         AIF   (&DMPFST1).A$01\n&DMPNAME SETC  'DMP'.'&SYSNDX'\n&DMPFST1 SETB  1\n.A$01    ANOP\n&#SAVER  SETC  '&DMPNAME'.'1'\n&REGSV   SETC  '&DMPNAME'.'2'\n&REGSV15 SETC  '&DMPNAME'.'3'\n&MESL    SETC  '&DMPNAME'.'4'\n&MESS    SETC  '&DMPNAME'.'5'\n&DMPNAM  SETC  'DMP'.'&SYSNDX'\n&#RETPT  SETC  '&DMPNAM'.'6'\n         AIF   (T'&MSG EQ 'O').A$011    BYPASS IF NO MSG PASSED\n&MSGL    SETA  K'&MSG-2\n         AIF   ('&MSG'(1,1) EQ '''').A$011 BYPASS IF NO MSG QUOTED\n.*--------------------------------------------------------------------*\n.* ESTABLISH LENGTH OF VARIABLE AND MOVE LENGTH                       *\n.*--------------------------------------------------------------------*\n&MSGL    SETA  K'&MSG                  MESSAGE LENGTH\n         AIF   ('&MSG'(&MSGL,1) NE ')').E3 INVALID MESSAGE FORMAT\n&MSGL1   SETA  K'&MSG-2                LEFT BRACKET\n         AIF   ('&MSG'(&MSGL1,1) NE '(').MSGL2 TEST MESSAGE LENGTH 2\n&MSGL2   SETA  1                       MESSAGE MOVE LENGTH'S LENGTH\n         AGO   .MSGVAR1\n.MSGL2   ANOP\n&MSGL1   SETA  K'&MSG-3\n         AIF   ('&MSG'(&MSGL1,1) NE '(').E4 INVALID MESSAGE FORMAT\n&MSGL2   SETA  2                       MESSAGE MOVE LENGTH'S LENGTH\n.MSGVAR1 ANOP\n&MSGL3   SETC  '&MSG'(&MSGL-&MSGL2,&MSGL2)\n&MSGNW   SETC  '&MSG'(1,&MSGL-(&MSGL2+2))\n         AIF   (&MSGL3 GT 79).E4\n.*--------------------------------------------------------------------*\n.A$011   ANOP\n         AIF   ('&MF' NE 'L').A$02     PROCESS LIST FORM (RE-ENT)\n&#SAVER  DS    7F                      PARAMETER LIST AREA\n&REGSV   DS    15F                     REGISTER SAVE AREA (R0-R14)\n&REGSV15 DS    F                       REGISTER SAVE AREA (R15)\n&MESL    DS    H                       MESSAGE LENGTH\n&MESS    DS    CL79                    MESSAGE\n         AGO   .MEXIT\n.A$02    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&VTAML EQ 'O').A$029     NO VTAMLIST ADDRESS\n         AIF   ('&VTAML'(1,1) EQ '(').A$023\n&#VTAML  SETC   '&VTAML'\n&#VLT    SETC   'L'\n         AGO   .A$029\n.A$023   ANOP\n         AIF   ('&VTAML'(1,3) EQ '(1)').E2\n         AIF   ('&VTAML'(1,4) EQ '(14)').E2\n         AIF   ('&VTAML'(1,4) EQ '(15)').E2\n         AIF   ('&VTAML'(1,4) EQ '(R1)').E2\n         AIF   ('&VTAML'(1,5) EQ '(R14)').E2\n         AIF   ('&VTAML'(1,5) EQ '(R15)').E2\n&#VTAML  SETC   '0(&VTAML(1))'\n&#VLT    SETC   'LA'\n.A$029   ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&START EQ 'O').C2    NO STARTING POINT DISPLAY START\n         AIF   ('&START'(1,1) EQ '(').A$03\n&#START  SETC   '&START'\n         AGO   .A$04\n.A$03    ANOP\n         AIF   ('&START'(1,3) EQ '(1)').E2\n         AIF   ('&START'(1,4) EQ '(14)').E2\n         AIF   ('&START'(1,4) EQ '(14)').E2\n         AIF   ('&START'(1,4) EQ '(R1)').E2\n         AIF   ('&START'(1,5) EQ '(R14)').E2\n         AIF   ('&START'(1,5) EQ '(R15)').E2\n&#START  SETC   '0(&START(1))'\n.A$04    ANOP\n&LENO    SETC  'L'                     SET LENGTH OPERATOR TO LOAD\n         AIF   (T'&LEN EQ 'O').A$07    HAVE LENGTH, BYPASS\n         AIF   ('&LEN'(1,1) LT '0').A$05\n&#LEN    SETC  '=A(&LEN)'\n         AGO   .C1\n.A$05    ANOP\n&LENO    SETC  'LA'                    SET LENGTH OPERATOR TO LOAD @\n         AIF   ('&LEN'(1,1) EQ '(').A$06\n&#LEN    SETC   '&LEN'\n         AGO   .C1\n.A$06    ANOP\n         AIF   ('&LEN'(1,3) EQ '(1)').E2\n         AIF   ('&LEN'(1,4) EQ '(14)').E2\n         AIF   ('&LEN'(1,4) EQ '(15)').E2\n         AIF   ('&LEN'(1,4) EQ '(R1)').E2\n         AIF   ('&LEN'(1,5) EQ '(R14)').E2\n         AIF   ('&LEN'(1,5) EQ '(R15)').E2\n&#LEN    SETC   '0(&LEN(1))'\n&LENO    SETC  'LA'                    SET LENGTH OPERATOR TO LOAD @\n         AGO   .C1\n.A$07    ANOP\n&#LEN    SETC  '=X''7FFFFFFF'''        SET MAXIMUM LENGTH\n&LENO    SETC  'LA'                    SET LENGTH OPERATOR TO LOAD @\n.C1      ANOP\n         STM   R0,R15,&REGSV           STORE REGISTERS\n         LOAD  EP=PROGDUM$             LOAD PROGRAM DUMP\n         LR    R15,R0                  LOAD ENTRY POINT OF PROGRAM\n         LA    R1,&#SAVER              POINT R1 TO SAVE AREA\n         MVC   0(4,R1),=C'DATA'        DATA INDICATOR\n         LA    R14,&#START             START OF DUMP\n         ST    R14,4(R1)               STORE START ADDRESS\n         &LENO R14,&#LEN               LOAD LENGTH\n         ST    R14,8(R1)               STORE LENGTH OF PROGRAM\n         AGO   .LOAD                   GO LOAD/CALL PROGDUMP\n.*--------------------------------------------------------------------*\n.C2      ANOP\n         STM   R0,R15,&REGSV           STORE REGISTERS\n         LOAD  EP=PROGDUM$             LOAD PROGRAM DUMP\n         LR    R15,R0                  LOAD ENTRY POINT OF PROGRAM\n         LA    R1,&#SAVER              POINT R1 TO SAVE AREA\n         XC    0(4,R1),0(R1)           CLEAR DATA INDICATOR\n.LOAD    ANOP\n         LA    R14,&#RETPT             RETURN @ FROM PROGRAM DUMP\n         ST    R14,12(R1)              STORE RETURN ADDRESS\n         AIF   (T'&VTAML EQ 'O').NOVTL1   BYPASS IF NO VTAMLIST\n         &#VLT R14,&#VTAML             LOAD LENGTH\n         ST    R14,16(R1)              STORE VTAMLIST ADDRESS\n.*--------------------------------------------------------------------*\n.NOVTL1  ANOP\n         XC    &MESL.(2),&MESL         INITIALISE MESSAGE LENGTH\n         AIF   (T'&MSG EQ 'O').NOMESSG  BYPASS IF NO VTAMLIST\n         AIF   ('&MSG'(1,1) EQ '''').MSGLIT1 BYPASS IF LIT SUPPLIED\n         MVC   &MESL.(2),=H'&MSGL3'    MOVE MESSAGE LENGTH\n         MVC   &MESS.(&MSGL3),&MSGNW   MOVE VARIABLE MESSAGE\n         AGO   .NOMESSG\n.*--------------------------------------------------------------------*\n.MSGLIT1 ANOP\n         MVC   &MESL.(2),=H'&MSGL'     MOVE MESSAGE LENGTH\n         MVC   &MESS.(&MSGL),=C&MSG\n.NOMESSG ANOP\n.*--------------------------------------------------------------------*\n         AIF ('&REGS'(1,1) EQ 'Y').REGSDY\n         MVI   20(R1),C'N'             DISPLAY/NOT REGS\n         AGO   .REGSDON\n.REGSDY  ANOP\n         MVI   20(R1),C'Y'             DISPLAY/NOT REGS\n.REGSDON ANOP\n.*--------------------------------------------------------------------*\n         AIF ('&AUTH'(1,1) EQ 'Y').AUTHDY\n         MVI   21(R1),C'N'             AUTHORISATION NOT REQUESTED\n         AGO   .AUTHDON\n.AUTHDY  ANOP\n         MVI   21(R1),C'Y'             AUTHORISATION REQUESTED\n.AUTHDON ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&TRACE NE 'O').TRACADR\n         XC    24(4,R1),24(R1)         SET TRACE SUPERVISOR N/A\n         AGO   .CALLDMP\n.TRACADR ANOP\n         AIF ('&TRACE'(1,1) EQ '(').TRACREG\n         LA    R14,&TRACE              LOAD TRACE SUPERVISOR ADDRESS\n         AGO   .TRACST1\n.TRACREG ANOP\n         LA    R14,0(&TRACE)           LOAD TRACE SUPERVISOR ADDRESS\n.TRACST1 ANOP\n         ST    R14,24(R1)              SAVE TRACE SUPERVISOR ADDRESS\n.*--------------------------------------------------------------------*\n.CALLDMP ANOP\n         BALR  R14,R15                 CALL 'PROGDUMP'\n         ST    R15,&REGSV15            SAVE RETURN REGISTER\n         DELETE EP=PROGDUM$            REMOVE PROGRAM DUMP\n.*--------------------------------------------------------------------*\n         AIF   (&INIT1ST EQ 0).NOISPF1 BYPASS IF INITISPF NOT RUN\n         AIF   ('&ISPR'(1,1) EQ 'N').NOISPF1 BYPASS IF EXPLICITLY REQ'D\n*        ISPEXEC 'CONTROL DISPLAY REFRESH'\n         ISPEXEC 'CONTROL DISPLAY REFRESH'\n.NOISPF1 ANOP\n.*--------------------------------------------------------------------*\n         L     R15,&REGSV15            RESTore RETURN REGISTER\n         LM    R0,R14,&#SAVER+28       RESTORE REGISTERS\n         AIF   (&DMPFST2).A$66\n&DMPFST2 SETB  1\n         AIF   ('&MF' EQ 'E').A$66     BYPASS IF EXEC FORM OF MACRO\n         B     &#RETPT                 BYPASS PARM-LIST AREA\n&#SAVER  DS    7F                      PARAMETER LIST AREA\n&REGSV   DS    15F                     REGISTER SAVE AREA (R0-R14)\n&REGSV15 DS    F                       REGISTER SAVE AREA (R15)\n&MESL    DS    H                       MESSAGE LENGTH\n&MESS    DS    CL79                    MESSAGE\n.A$66    ANOP\n&#RETPT  DS    0H\n         AIF (T'&QUIT EQ 'O').MEXIT\n         LTR   R15,R15                 Q. ZERO RETURN CODE\n         BNZ   &QUIT                      N. GO TO QUIT ADDRESS\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.E0      MNOTE 12,'''PDUMP$'' REQUIRES A 3 FULLWORD SAVE AREA'\n         AGO   .MEXIT\n.E1      MNOTE 12,'''PDUMP$'' REQUIRES A DATA AREA AND A LENGTH'\n         AGO   .MEXIT\n.E2      MNOTE 12,'DO NOT USE REGS 1, 14 OR 15 FOR PARAMETERS'\n         AGO   .MEXIT\n.E3      MNOTE 12,'INVALID VARIABLE MESSAGE FORMAT. S/B \"VARNAME(LEN)\"'\n         AGO   .MEXIT\n.E4      MNOTE 12,'MESSAGE LENGTH MUST BE LE 79 CHARACTERS'\n.*--------------------------------------------------------------------*\n.MEXIT   ANOP\n         POP   PRINT\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDUMPR": {"ttr": 13569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01c\\x00'\\x01\\x011\\x9f\\x01\\x050\\x9f\\x02\\x03\\x01\\xb9\\x01\\x97\\x00\\x00\\xc1\\xd3\\xc5\\xe7@@@@@@\"", "ispf": {"version": "01.99", "flags": 0, "createdate": "2001-11-15T00:00:00", "modifydate": "2005-11-05T02:03:27", "lines": 441, "newlines": 407, "modlines": 0, "user": "ALEX"}, "text": "         MACRO\n&NAME    PDUMPR &ADDR,          Address to display                     X\n               &REGP=YES,       Ser REGP= parameter                    X\n               &TYPE=VAR,       CONstant/VARiable type for MF=L        X\n               &ISPI=YES,       Invoke ISPEXEC INIT=Y explicitly       X\n               &X2CE=NO,        HEXCHMAC MF=E required ?               X\n               &X2CL=NO,        HEXCHMAC MF=L required ?               X\n               &REXX=SHOWSTOR,  REXX EXEC                              X\n               &HELP=NO,        Help in expansion                      X\n               &MSG=,           Message area for GC009                 X\n               &LIST=NO,        List expansion                         X\n               &DISPLAY=ASIS,   Process SHOWSTOR display               X\n               &DISP=ASIS,      Alias for DISPLAY                      X\n               &QUIT=,          R15 set to 'QUIT' branch               X\n               &MF=             EXEC/LIST format\n.*\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP   Go full help\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'PDUMPR' parameter and  *\n* it's use, pass parameter 'HELP=Yes'.                                *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE                         Bypass full help\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* This facility is used to display memory from within a program using *\n* the SHOWSTOR memory mapper written in REXX, using ISPF services.    *\n*                                                                     *\n* All parameters are keyword parameters except the first which is the *\n* only positional parameter for the address to be displayed. The      *\n* format is as follows:                                               *\n*                                                                     *\n*   PDUMPR addr,kw1=..,kw2=..,kwn=...                                 *\n*                                                                     *\n* The following are permissable parameters:                           *\n*   addr          - Address to be displayed. May be any relocatable   *\n*                   address, a register in parentheses or a displace- *\n*                   memt and register in parentheses.                 *\n*   ISPI=Yes/No   o Invoke the ISPEXEC macro with the INIT option in  *\n*                   it. Default is Yes. Set to No if you explicitly   *\n*                   use the ISPEXEC macro in your program.            *\n*   X2CE=Yes/No   o Invoke the HEXCHMAC macro MF=E format. This is    *\n*                   only used if the HEXCHMAC with MF=E is explicitly *\n*                   used in the same program and will prevent         *\n*                   duplicate variable names. If PDUMPR is invoked    *\n*                   with MF=E then this feature is automatically      *\n*                   enabled. The default is NO.                       *\n*   X2CL=Yes/No   o Invoke the HEXCHMAC macro MF=L format. Similar to *\n*                   X2CE parameter. Default is No.                    *\n*   MSG='....'    - MEssage to display on entering SHOWSTOR. Literal  *\n*      =label()     padded/truncated to 256 bytes or a label where    *\n*                   256 bytes or length of variable subscripted is    *\n*                   moved, eg. MSG=MSGSRCE(80).                       *\n*   QUIT=label    - Label of the instruction where control is to be   *\n*                   passed if SHOWSTOR is terminated using the 'QUIT' *\n*                   feature. Refer to SHOWSTOR documentation for      *\n*                   further details.                                  *\n*   REGP=Yes/No   - Set REGP= parameter on entry. this will enable    *\n*                   the use of the /REGS* command. (Refer to SHOWSTOR *\n*                   documentation.) Default is Yes and you would be   *\n*                   a fool to suppress this handy feature.            *\n*   REXX=SHOWSTOR - REXX EXEC to be executed from the macro. This     *\n*                   should not be changed.                            *\n*   TYPE=Var/Con  - Constatnt/Variable type for MF=L format. VAR is   *\n*                   the default.                                      *\n*   DISPLAY=Yes/No/Asis                                               *\n*                 - Activate or bypass SHOWSTOR displays. Used to     *\n*                   control SHOWSTOR displays during looping. Any     *\n*                   value other than 'N' or 'Y' will default to 'A'.  *\n*                   Use this parameter without an Address to set the  *\n*                   condition without a display.                      *\n*   HELP=No/Yes   - Help in expansion of this macro.                  *\n*   LIST=No/Yes   - List expansion.                                   *\n*   MF=           - Exec/List format.                                 *\n*                                                                     *\n* To use this feature you will also need access to macros ISPEXEC and *\n* HEXCHMAC.                                                           *\n* Parameters with an 'o' seperator are parameters whose values are    *\n* dependant on the requirements of the ISPEXEC or HEXCHMAC macros.    *\n* Refer to the actual macros for further details.                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* Known GOTCHAs:                                                      *\n* - This facility cannot be invoked from an authorised program        *\n*   because of ISPF's limitations with authorised programs.           *\n* - Because the macros used are designed in subroutine format, ensure *\n*   that the first physical occurance of this macro (or it's related  *\n*   counterparts of ISPEXEC and HEXCHMAC) are the ones actually       *\n*   executed first to ensure all variables/settings are initialised.  *\n*   This can be a problem in programs with a lot of branching logic.  *\n*   To safeguard against this, invoke the macro as early as possible  *\n*   in your program without an \"addr\" parameter to force              *\n*   initialisation of all 3 macros (PDUMPR, ISPEXEC and HEXCHMAC).    *\n* - Take care when explicitly using ISPEXEC and HEXCHMAC macros       *\n*   outside this macro. You may need to fine tune the ISPI= and the   *\n*   X2CE= and X2CL= parameters to prevent duplicate names.            *\n*                                                                     *\n*---------------------------------------------------------------------*\n.*\n.A$HELPE ANOP\n.*\n         AIF   ('&LIST'(1,1) EQ 'Y').A$XXX\n         PUSH  PRINT\n         PRINT NOGEN\n.A$XXX   ANOP\n.*\n         LCLC  &SMXVAR,&L,&#DISP,&#ADR\n         GBLB  &SMXFST1,&SMXEXE1,&SMXLST1\n         GBLC  &SMXFXD\n         GBLB  &XC1ST\n.*\n.*--------------------------------------------------------------------*\n.* Evaluate and set Display requirements                              *\n.*--------------------------------------------------------------------*\n         AIF   (T'&DISPLAY EQ 'O').A$001 Test for 'alias'\n&#DISP   SETC  '&DISPLAY'                Set to parameter\n         AGO   .A$002                    GoAround alternate process\n.A$001   ANOP\n         AIF   (T'&DISP EQ 'O').A$002    Bypass\n&#DISP   SETC  '&DISP'                   Set to 'alias' parameter\n.A$002   ANOP\n.*\n.*--------------------------------------------------------------------*\n.* Evaluate address if passed as (reg)....                            *\n.*--------------------------------------------------------------------*\n&#ADR    SETC  '&ADDR'                Set to parameter\n         AIF   (T'&#ADR EQ 'O').A$003 Bypass processing\n         AIF   ('&#ADR'(1,1) NE '(').A$003 Bypass if 1st char not '('\n&#ADR    SETC  '0&#ADR.'              Set to Offset zero\n.A$003   ANOP\n.*--------------------------------------------------------------------*\n.*\n         AIF   (&SMXFST1).A$010\n.*--------------------------------------------------------------------*\n.* Global variables on initial invocation\n.*--------------------------------------------------------------------*\n&SMXFST1 SETB  1                       Set 1st. time thru  flag\n&SMXFXD  SETC  'SMX'.'&SYSNDX'         Set fixed index value\n&#DISP   SETC  'YES'                   Force display 1st. time thru\n.A$010   ANOP\n.*--------------------------------------------------------------------*\n.* Local variables on each invocation\n.*--------------------------------------------------------------------*\n&SMXVAR  SETC  'SMX'.'&SYSNDX'         Set variable index value\n.*--------------------------------------------------------------------*\n.* Global variables on each invocation\n.*--------------------------------------------------------------------*\n&SMXLB0  SETC  '&SMXVAR'.'0'           Set variables (Full word branch)\n&SMXLB1  SETC  '&SMXFXD'.'1'           Set variables\n&SMXLB2  SETC  '&SMXVAR'.'2'           Set variables\n&SMXLB3  SETC  '&SMXVAR'.'3'           Set variables\n&SMXLB4  SETC  '&SMXFXD'.'4'           Set variables\n&SMXLB5  SETC  '&SMXFXD'.'5'           Set variables\n&SMXLB6  SETC  '&SMXVAR'.'6'           SPARE - NOT USED\n&SMXLB7  SETC  '&SMXVAR'.'Z'           Set variable (PDUMPR terminator)\n&SMXLB8  SETC  '&SMXVAR'.'X'           Set variable (PDUMPR start)\n&SMXWK1  SETC  '&SMXFXD'.'8'           Set variables\n&SMXWK2  SETC  '&SMXFXD'.'9'           Set variables\n&SMXWK3  SETC  '&SMXFXD'.'A'           Set variables\n&SMXWK4  SETC  '&SMXFXD'.'B'           Set variables\n&SMXWK5  SETC  '&SMXFXD'.'C'           Set variables\n&SMXWK6  SETC  '&SMXFXD'.'D'           Set variables\n&SMXWK7  SETC  '&SMXFXD'.'E'           Set variables\n&SMXWK8  SETC  '&SMXFXD'.'F'           Set variables\n&SMXWK9  SETC  '&SMXFXD'.'G'           Set variables\n&SMXWK10 SETC  '&SMXFXD'.'H'           Set variables\n&SMXWK11 SETC  '&SMXFXD'.'I'           Set variables\n&SMXWK12 SETC  '&SMXFXD'.'J'           Set variables\n.*--------------------------------------------------------------------*\n&L       SETC  '&LIST'\n         AIF   (T'&NAME EQ 'O').A$YYY  Bypass if label passed\n&SMXLB0  SETC  '&NAME'                 Use invocation name fro label\n.A$YYY   ANOP\n.*\n         AIF   ('&MF' EQ 'L').A$200    Process list form of macro\n.*\n&SMXLB8  DS    0H                      START ANCHOR\n         B     &SMXLB0                 ENSURE FULL WORD BRANCH\n         AIF   (T'&MF EQ 'O').A$200    Process list form of macro\n.A$020   ANOP\n&SMXLB0  DS    0F                      ENSURE FULL WORD ALLIGNMENT\n.*\n         AIF   (&SMXEXE1).A$050        Bypass if not 1st. MF=E\n&SMXEXE1 SETB  1\n         STM   R0,R15,&SMXWK9          SAVE ALL REGISTERS\n         AIF   ('&ISPI'(1,1) NE 'Y').A$022A Bypass if ISPEXEC not req\n         AIF   ('&LIST'(1,1) EQ 'Y').A$021  Process list form yes\n         ISPEXEC INIT=Y,MF=E           INITIALISE ISPF ENVIRONMENT\n         AGO   .A$022\n.A$021   ANOP\n         ISPEXEC INIT=Y,MF=E,LIST=&L   INITIALISE ISPF ENVIRONMENT\n.A$022   ANOP\n         LM    R0,R15,&SMXWK9          RESTORE REGISTERS\n.A$022A  ANOP\n         B     &SMXLB2                 BRANCH AROUND CODE\n&SMXLB1  DS    0H\n         ST    R1,&SMXWK8              STORE FOR CONVERSION\n         AIF   ('&X2CE'(1,1) EQ 'Y').X2C012 Process MF=E format\n         AIF   ('&MF' EQ 'E').X2C011   Process MF=E format\n.X2C010  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK2,4,LIST=&L HEX TO CHARACTER\n         AGO   .X2C012                 Bypass MF=E format\n.X2C011  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK2,4,LIST=&L,MF=E HEX TO CHARACTER\n.X2C012  ANOP\n.*\n         CLI   &SMXWK7,C'Y'            Q. SETUP REGISTERS\n         BE    &SMXLB4                    Y. GO DO IT\n         MVI   &SMXWK3,C' '            BLANK FILL (RIPPLE)\n         MVC   &SMXWK3.+1(L'&SMXWK3.+L'&SMXWK4.-1),&SMXWK3\n         B     &SMXLB5                 BYPASS SETUP REGISTER\n&SMXLB4  DS    0H\n         MVC   &SMXWK3.(06),=C' REGP=' SET REGISTER\n         LA    R1,&SMXWK9              LOAD ADDRESS REGISTER SAVE AREA\n         ST    R1,&SMXWK8              STORE FOR CONVERSION\n         AIF   ('&X2CE'(1,1) EQ 'Y').X2C022 Process MF=E format\n         AIF   ('&MF' EQ 'E').X2C021   Process MF=E format\n.X2C020  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK4,4,LIST=&L HEX TO CHARACTER\n         AGO   .X2C022                 Bypass MF=E format\n.X2C021  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK4,4,LIST=&L,MF=E HEX TO CHARACTER\n.X2C022  ANOP\n*---------------------------------------------------------------------*\n&SMXLB5  DS    0H\n         AIF   ('&LIST'(1,1) EQ 'Y').A$041 Process list form Yes\n         ISPEXEC &SMXWK1,&SMXWK6       CALL 'SHOSTOR' REXX EXEC\n         AGO   .A$042\n.A$041   ANOP\n         ISPEXEC &SMXWK1,&SMXWK6.,LIST=&L CALL 'SHOSTOR' REXX EXEC\n.A$042   ANOP\n         L     R14,&SMXWK8.+4          LOAD RETURN ADDRESS\n         BR    R14                     RETURN TO CALLER\n&SMXLB2  DS    0H\n.*\n.A$050   ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&#DISP EQ 'O').A$058 Do not set, just test\n         AIF   ('&#DISP'(1,1) EQ 'Y').A$057 Use passed value\n         AIF   ('&#DISP'(1,1) NE 'N').A$058 Bypass value setting\n.A$057   ANOP\n&#DISP   SETC  '&#DISP'(1,1)          Use 1st. byte\n         MVI   &SMXWK11,C'&#DISP'      SET DISPLAY REQUIREMENT\n         AIF   (T'&#ADR EQ 'O').SETEXT Continue if have an address\n         AIF   ('&#DISP'(1,1) EQ 'Y').A$059 Bypass test if set 2 'Y'\n         AIF   ('&#DISP'(1,1) EQ 'N').A$090 Bypass all if 'N' req'd\n.A$058   ANOP\n         AIF   (T'&#ADR EQ 'O').SETEXT Continue if have an address\n         CLI   &SMXWK11,C'N'           Q. DISPLAY REQUIRED\n         BE    &SMXLB7                    N. BYPASS\n.A$059   ANOP\n.*--------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n* Set up PDUMPR start and end addresses for potential anchor points.  *\n*---------------------------------------------------------------------*\n         MVC   &SMXWK12.(21),=C'RR=......../........ '\n         LA    R1,&SMXLB8              START PDUMPR ADDRESS\n         ST    R1,&SMXWK8              STORE FOR CONVERSION\n         AIF   ('&X2CE'(1,1) EQ 'Y').X2C032 Process MF=E format\n         AIF   ('&MF' EQ 'E').X2C031   Process MF=E format\n.X2C030  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK12+3,4,LIST=&L HEX TO CHARACTER\n         AGO   .X2C032                 Bypass MF=E format\n.X2C031  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK12+3,4,LIST=&L,MF=E HEX TO CHARACTER\n.X2C032  ANOP\n.*--------------------------------------------------------------------*\n         LA    R1,&SMXLB7              END PDUMPR ADDRESS\n         ST    R1,&SMXWK8              STORE FOR CONVERSION\n         AIF   ('&X2CE'(1,1) EQ 'Y').X2C042 Process MF=E format\n         AIF   ('&MF' EQ 'E').X2C041   Process MF=E format\n.X2C040  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK12+12,4,LIST=&L HEX TO CHARACTER\n         AGO   .X2C042                 Bypass MF=E format\n.X2C041  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK12+12,4,LIST=&L,MF=E HEX TO CHARACTER\n.X2C042  ANOP\n.*--------------------------------------------------------------------*\n         STM   R0,R15,&SMXWK9          SAVE ALL REGISTERS\n         LA    R0,&SMXLB3              LOAD RETURN ADDRESS\n         ST    R0,&SMXWK8.+4           SAVE RETURN ADDRESS\n         AIF   ('&REGP'(1,1) EQ 'N').A$060  Bypass if REGP=No\n         MVI   &SMXWK7,C'Y'            SETUP REGISTERS REQUEST\n         AGO   .A$065                  Branch around negative set\n.A$060   ANOP\n         MVI   &SMXWK7,C'N'            REGISTERS NOT REQUIRED\n.A$065   ANOP\n         AIF   (T'&MSG EQ 'O').A$075  Bypass if deliberate omission\n         MVI   &SMXWK10,C' '           INITIALISE OUTPUT MESSAGE USING\n         MVC   &SMXWK10.+1(L'&SMXWK10.-1),&SMXWK10 ..RIPPLE MOVE\n&MSGNW   SETC  '&MSG'                 Set message to move from label\n         AIF   ('&MSG'(1,1) EQ '''').A$072 Go process literal message\n.*--------------------------------------------------------------------*\n.* Establish length of literal and move length                        *\n.*--------------------------------------------------------------------*\n         LCLA  &APOST\n&MSGL    SETA  K'&MSG                     Set length of message\n         AIF   ('&MSG'(&MSGL,1) EQ ')').A$071\n         MVC   &SMXWK10,&MSGNW         MOVE MESSAGE TO OUTPUT\n         AGO   .A$075                       Leave process\n.A$071   ANOP\n&MSGL1   SETA  &MSGL-1\n&APOST   SETA  0\n.LOOP1   ANOP\n         AIF   (&MSGL1 EQ  0).E4\n         AIF   ('&MSG'(&MSGL1,1) EQ ',').LOOP1E\n         AIF   ('&MSG'(&MSGL1,1) EQ '(').LOOP2E\n&MSGL1   SETA  &MSGL1-1\n         AGO   .LOOP1\n.LOOP1E  ANOP\n&APOST   SETA  &MSGL1\n&MSGL1   SETA  &MSGL1-1\n.LOOP2   ANOP\n         AIF   (&MSGL1 EQ 0).E4\n         AIF   ('&MSG'(&MSGL1,1) EQ '(').LOOP2E\n&MSGL1   SETA  &MSGL1-1\n         AGO   .LOOP2\n.LOOP2E  ANOP\n         AIF   (&APOST EQ 0).VARMSG\n&MSGL3   SETC  '&MSG'(&MSGL1+1,&APOST-(&MSGL1+1))\n&MSGNW   SETC  '&MSG'(1,&MSGL1).'&MSG'(&APOST+1,&MSGL-&APOST)\n         AGO   .MSGDTOK\n.VARMSG  ANOP\n&MSGL3   SETC  '&MSG'(&MSGL1+1,&MSGL-(&MSGL1+1))\n&MSGNW   SETC  '&MSG'(1,&MSGL1-1)\n.MSGDTOK ANOP\n         MVC   &SMXWK10.(&MSGL3),&MSGNW MOVE MESSAGE TO OUTPUT\n         AGO   .A$075                       Leave process\n.*-------------------------------------------------------------------*\n.* Establish length of variable and move length                      *\n.*-------------------------------------------------------------------*\n.A$072   ANOP\n         LCLC  &CHAR,&AMPER\n         LCLA  &LC,&QC,&AC\n&AMPER   SETC  '&&'\n&MSGL    SETA  K'&MSG                       Loop counter (message len)\n&QC      SETA  0                            Quotes counter\n&AC      SETA  0                            Ampersand counter\n&CP      SETA  0                            Character pointer\n.LOOP3   ANOP\n&CP      SETA  &CP+1                        Iincrement char pointer\n&CHAR    SETC  '&MSG'(&CP,1)                Set character value\n.TQUOT   ANOP\n         AIF   ('&CHAR' NE '''').TAMPR      Bypass if char not \"'\"\n&QC      SETA  &QC+1                        Bump quotes counter\n         AGO   .NXTCH                       Get nest char\n.TAMPR   ANOP\n         AIF   ('&CHAR.&CHAR' NE '&AMPER').NXTCH Bypass if not \"&\"\n&AC      SETA  &AC+1                        Bump amper counter\n.NXTCH   ANOP\n         AIF   (&CP LT &MSGL).LOOP3         Loop till end\n&MSGL    SETA  &MSGL-2-(((&QC-2)/2)+(&AC/2)) Get actual length\n         MVC   &SMXWK10.(&MSGL),=CL(&MSGL)&MSG\n.A$075   ANOP\n.*--------------------------------------------------------------------*\n         LA    R1,&#ADR                LOAD ADDRESS OF ADDRESS\n         B     &SMXLB1                 BRANCH TO COMMON CODE\n&SMXLB3  DS    0H\n         LM    R0,R15,&SMXWK9          RESTORE ALL REGISTERS\n         AIF   (T'&QUIT EQ 'O').A$080  Bypass if no QUIT\n         C     R15,=C'QUIT'            Q. QUIT REQUESTED\n         BE    &QUIT                      Y. GO TO LABEL\n.A$080   ANOP\n         C     R15,=C'DOFF'            Q. DISPLAY OFF REQUESTED\n         BNE   &SMXLB7                    N. BYPASS\n         MVI   &SMXWK11,C'N'           SET DISPLAY OFF\n&SMXLB7  DS    0H                      EXIT ANCHOR\n.A$090   ANOP\n         AGO   .MEXIT                  Exit macro\n.*\n.A$200   ANOP\n         AIF   (T'&MF NE 'O').A$205    Bypass if MF is set\n         AIF   (&SMXEXE1).A$020        Return if previously executed\n.A$205   ANOP\n         AIF   ('&TYPE'(1,1) NE 'C').A$210  Bypass if not constant\n&SMXWK1  SETC  ''\n&SMXWK2  SETC  ''\n&SMXWK3  SETC  ''\n&SMXWK4  SETC  ''\n&SMXWK5  SETC  ''\n&SMXWK6  SETC  ''\n&SMXWK7  SETC  ''\n&SMXWK8  SETC  ''\n&SMXWK9  SETC  ''\n&SMXWK10 SETC  ''\n&SMXWK11 SETC  ''\n&SMXWK12 SETC  ''\n.*\n.A$210   ANOP\n.*\n         AIF   ('&ISPI'(1,1) NE 'Y').A$224 Bypass if ISPEXEC not req'd\n         AIF   ('&LIST'(1,1) EQ 'Y').A$221 Process list form Yes\n         ISPEXEC  MF=L,INIT=Y,TYPE=&TYPE INIT ISPF ENVIRONMENT\n         AGO   .A$224\n.A$221   ANOP\n         AIF   ('&ISPI'(1,1) EQ 'N').A$224 Bypass if INIT=No\n.A$222   ANOP\n         ISPEXEC  MF=L,INIT=Y,LIST=&L,TYPE=&TYPE INIT ISPF ENVIRONMENT\n.A$224   ANOP\n         DS    0F                      WORD ALLIGN\n&SMXWK8  DS    2F                      WORK AREA\n&SMXWK9  DS    16F                     REGISTER SAVE AREA FRO MACRO\n&SMXWK1  DC    C'SELECT CMD(%SHOWSTOR ' WHAT WE WANT TO EXECUTE\n&SMXWK2  DC    C'        '             ADDRESS WE WANT TO DISPLAY\n&SMXWK3  DC    C' REGP='               REGISTER EQUATE LITERAL\n&SMXWK4  DC    C'        '             ADDRESS WE WANT TO DISPLAY\n         DC    C' '                    FILLER\n&SMXWK12 DC    CL21'RR=......../........ ' Start and finish\n.*-------------------------------------------------------------------*\n.*   NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE    *\n.*-------------------------------------------------------------------*\n.* Modify the length of the next field to ensure the value (length)  *\n.* of variable &SMXWK6 does not exceed 256 as &SMXWK1 and &SMXWK6    *\n.* are used in a MVC instruction.                                    *\n.*-------------------------------------------------------------------*\n&SMXWK10 DC    CL190' '                MESSAGE AREA\n.*-------------------------------------------------------------------*\n&SMXWK5  DC    C')'                    WHAT WE WANT TO EXECUTE\n         AIF   ('&TYPE'(1,1) EQ 'C').A$223  Bypass if constant\n&SMXWK6  EQU   *-&SMXWK1               ISPF COMMAND LENGTH\n.A$223   ANOP\n&SMXWK7  DC    C'Y'                    REGISTER GENERATE FLAG\n&SMXWK11 DC    C'Y'                    DISPLAY ON\n         AIF   ('&X2CL'(1,1) NE 'Y').X2C090 BYpass MF=L for HEXCHMAC\n         HEXCHMAC MF=L\n.X2C090  ANOP\n         AIF   (T'&MF EQ 'O').A$020    Return\n         AGO   .MEXIT                  Exit\n.*--------------------------------------------------------------------*\n.E0      MNOTE 12,'No Errors at this stage'\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.SETEXT  ANOP\n&SMXLB7  DS    0H                      EXIT ANCHOR\n.MEXIT   ANOP\n         AIF   ('&LIST'(1,1) EQ 'Y').MEXIT9\n         POP   PRINT\n.MEXIT9  ANOP\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDUMPR$": {"ttr": 12289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00D\\x01\\x050\\x9f\\x01\\x050\\x9f\\x02\\x01\\x01\\xb8\\x01\\xb8\\x00\\x00\\xc1\\xd3\\xc5\\xe7@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2005-11-05T00:00:00", "modifydate": "2005-11-05T02:01:44", "lines": 440, "newlines": 440, "modlines": 0, "user": "ALEX"}, "text": "         MACRO\n&NAME    PDUMPR &ADDR,          Address to display                     X\n               &REGP=YES,       Ser REGP= parameter                    X\n               &TYPE=VAR,       CONstant/VARiable type for MF=L        X\n               &ISPI=YES,       Invoke ISPEXEC INIT=Y explicitly       X\n               &X2CE=NO,        HEXCHMAC MF=E required ?               X\n               &X2CL=NO,        HEXCHMAC MF=L required ?               X\n               &REXX=SHOWSTOR,  REXX EXEC                              X\n               &HELP=NO,        Help in expansion                      X\n               &MSG=,           Message area for GC009                 X\n               &LIST=NO,        List expansion                         X\n               &DISPLAY=ASIS,   Process SHOWSTOR display               X\n               &DISP=ASIS,      Alias for DISPLAY                      X\n               &QUIT=,          R15 set to 'QUIT' branch               X\n               &MF=             EXEC/LIST format\n.*\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP   Go full help\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'PDUMPR' parameter and  *\n* it's use, pass parameter 'HELP=Yes'.                                *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE                         Bypass full help\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* This facility is used to display memory from within a program using *\n* the SHOWSTOR memory mapper written in REXX, using ISPF services.    *\n*                                                                     *\n* All parameters are keyword parameters except the first which is the *\n* only positional parameter for the address to be displayed. The      *\n* format is as follows:                                               *\n*                                                                     *\n*   PDUMPR addr,kw1=..,kw2=..,kwn=...                                 *\n*                                                                     *\n* The following are permissable parameters:                           *\n*   addr          - Address to be displayed. May be any relocatable   *\n*                   address, a register in parentheses or a displace- *\n*                   memt and register in parentheses.                 *\n*   ISPI=Yes/No   o Invoke the ISPEXEC macro with the INIT option in  *\n*                   it. Default is Yes. Set to No if you explicitly   *\n*                   use the ISPEXEC macro in your program.            *\n*   X2CE=Yes/No   o Invoke the HEXCHMAC macro MF=E format. This is    *\n*                   only used if the HEXCHMAC with MF=E is explicitly *\n*                   used in the same program and will prevent         *\n*                   duplicate variable names. If PDUMPR is invoked    *\n*                   with MF=E then this feature is automatically      *\n*                   enabled. The default is NO.                       *\n*   X2CL=Yes/No   o Invoke the HEXCHMAC macro MF=L format. Similar to *\n*                   X2CE parameter. Default is No.                    *\n*   MSG='....'    - MEssage to display on entering SHOWSTOR. Literal  *\n*      =label()     padded/truncated to 256 bytes or a label where    *\n*                   256 bytes or length of variable subscripted is    *\n*                   moved, eg. MSG=MSGSRCE(80).                       *\n*   QUIT=label    - Label of the instruction where control is to be   *\n*                   passed if SHOWSTOR is terminated using the 'QUIT' *\n*                   feature. Refer to SHOWSTOR documentation for      *\n*                   further details.                                  *\n*   REGP=Yes/No   - Set REGP= parameter on entry. this will enable    *\n*                   the use of the /REGS* command. (Refer to SHOWSTOR *\n*                   documentation.) Default is Yes and you would be   *\n*                   a fool to suppress this handy feature.            *\n*   REXX=SHOWSTOR - REXX EXEC to be executed from the macro. This     *\n*                   should not be changed.                            *\n*   TYPE=Var/Con  - Constatnt/Variable type for MF=L format. VAR is   *\n*                   the default.                                      *\n*   DISPLAY=Yes/No/Asis                                               *\n*                 - Activate or bypass SHOWSTOR displays. Used to     *\n*                   control SHOWSTOR displays during looping. Any     *\n*                   value other than 'N' or 'Y' will default to 'A'.  *\n*                   Use this parameter without an Address to set the  *\n*                   condition without a display.                      *\n*   HELP=No/Yes   - Help in expansion of this macro.                  *\n*   LIST=No/Yes   - List expansion.                                   *\n*   MF=           - Exec/List format.                                 *\n*                                                                     *\n* To use this feature you will also need access to macros ISPEXEC and *\n* HEXCHMAC.                                                           *\n* Parameters with an 'o' seperator are parameters whose values are    *\n* dependant on the requirements of the ISPEXEC or HEXCHMAC macros.    *\n* Refer to the actual macros for further details.                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* Known GOTCHAs:                                                      *\n* - This facility cannot be invoked from an authorised program        *\n*   because of ISPF's limitations with authorised programs.           *\n* - Because the macros used are designed in subroutine format, ensure *\n*   that the first physical occurance of this macro (or it's related  *\n*   counterparts of ISPEXEC and HEXCHMAC) are the ones actually       *\n*   executed first to ensure all variables/settings are initialised.  *\n*   This can be a problem in programs with a lot of branching logic.  *\n*   To safeguard against this, invoke the macro as early as possible  *\n*   in your program without an \"addr\" parameter to force              *\n*   initialisation of all 3 macros (PDUMPR, ISPEXEC and HEXCHMAC).    *\n* - Take care when explicitly using ISPEXEC and HEXCHMAC macros       *\n*   outside this macro. You may need to fine tune the ISPI= and the   *\n*   X2CE= and X2CL= parameters to prevent duplicate names.            *\n*                                                                     *\n*---------------------------------------------------------------------*\n.*\n.A$HELPE ANOP\n.*\n         AIF   ('&LIST'(1,1) EQ 'Y').A$XXX\n         PUSH  PRINT\n         PRINT NOGEN\n.A$XXX   ANOP\n.*\n         LCLC  &SMXVAR,&L,&#DISP,&#ADR\n         GBLB  &SMXFST1,&SMXEXE1,&SMXLST1\n         GBLC  &SMXFXD\n         GBLB  &XC1ST\n.*\n.*--------------------------------------------------------------------*\n.* Evaluate and set Display requirements                              *\n.*--------------------------------------------------------------------*\n         AIF   (T'&DISPLAY EQ 'O').A$001 Test for 'alias'\n&#DISP   SETC  '&DISPLAY'                Set to parameter\n         AGO   .A$002                    GoAround alternate process\n.A$001   ANOP\n         AIF   (T'&DISP EQ 'O').A$002    Bypass\n&#DISP   SETC  '&DISP'                   Set to 'alias' parameter\n.A$002   ANOP\n.*\n.*--------------------------------------------------------------------*\n.* Evaluate address if passed as (reg)....                            *\n.*--------------------------------------------------------------------*\n&#ADR    SETC  '&ADDR'                Set to parameter\n         AIF   (T'&#ADR EQ 'O').A$003 Bypass processing\n         AIF   ('&#ADR'(1,1) NE '(').A$003 Bypass if 1st char not '('\n&#ADR    SETC  '0&#ADR.'              Set to Offset zero\n.A$003   ANOP\n.*--------------------------------------------------------------------*\n.*\n         AIF   (&SMXFST1).A$010\n.*--------------------------------------------------------------------*\n.* Global variables on initial invocation\n.*--------------------------------------------------------------------*\n&SMXFST1 SETB  1                       Set 1st. time thru  flag\n&SMXFXD  SETC  'SMX'.'&SYSNDX'         Set fixed index value\n&#DISP   SETC  'YES'                   Force display 1st. time thru\n.A$010   ANOP\n.*--------------------------------------------------------------------*\n.* Local variables on each invocation\n.*--------------------------------------------------------------------*\n&SMXVAR  SETC  'SMX'.'&SYSNDX'         Set variable index value\n.*--------------------------------------------------------------------*\n.* Global variables on each invocation\n.*--------------------------------------------------------------------*\n&SMXLB0  SETC  '&SMXVAR'.'0'           Set variables (Full word branch)\n&SMXLB1  SETC  '&SMXFXD'.'1'           Set variables\n&SMXLB2  SETC  '&SMXVAR'.'2'           Set variables\n&SMXLB3  SETC  '&SMXVAR'.'3'           Set variables\n&SMXLB4  SETC  '&SMXFXD'.'4'           Set variables\n&SMXLB5  SETC  '&SMXFXD'.'5'           Set variables\n&SMXLB6  SETC  '&SMXVAR'.'6'           SPARE - NOT USED\n&SMXLB7  SETC  '&SMXVAR'.'Z'           Set variable (PDUMPR terminator)\n&SMXLB8  SETC  '&SMXVAR'.'X'           Set variable (PDUMPR start)\n&SMXWK1  SETC  '&SMXFXD'.'8'           Set variables\n&SMXWK2  SETC  '&SMXFXD'.'9'           Set variables\n&SMXWK3  SETC  '&SMXFXD'.'A'           Set variables\n&SMXWK4  SETC  '&SMXFXD'.'B'           Set variables\n&SMXWK5  SETC  '&SMXFXD'.'C'           Set variables\n&SMXWK6  SETC  '&SMXFXD'.'D'           Set variables\n&SMXWK7  SETC  '&SMXFXD'.'E'           Set variables\n&SMXWK8  SETC  '&SMXFXD'.'F'           Set variables\n&SMXWK9  SETC  '&SMXFXD'.'G'           Set variables\n&SMXWK10 SETC  '&SMXFXD'.'H'           Set variables\n&SMXWK11 SETC  '&SMXFXD'.'I'           Set variables\n&SMXWK12 SETC  '&SMXFXD'.'J'           Set variables\n.*--------------------------------------------------------------------*\n&L       SETC  '&LIST'\n         AIF   (T'&NAME EQ 'O').A$YYY  Bypass if label passed\n&SMXLB0  SETC  '&NAME'                 Use invocation name fro label\n.A$YYY   ANOP\n.*\n         AIF   ('&MF' EQ 'L').A$200    Process list form of macro\n.*\n&SMXLB8  DS    0H                      START ANCHOR\n         B     &SMXLB0                 ENSURE FULL WORD BRANCH\n         AIF   (T'&MF EQ 'O').A$200    Process list form of macro\n.A$020   ANOP\n&SMXLB0  DS    0F                      ENSURE FULL WORD ALLIGNMENT\n.*\n         AIF   (&SMXEXE1).A$050        Bypass if not 1st. MF=E\n&SMXEXE1 SETB  1\n         STM   R0,R15,&SMXWK9          SAVE ALL REGISTERS\n         AIF   ('&ISPI'(1,1) NE 'Y').A$022A Bypass if ISPEXEC not req\n         AIF   ('&LIST'(1,1) EQ 'Y').A$021  Process list form yes\n         ISPEXEC INIT=Y,MF=E           INITIALISE ISPF ENVIRONMENT\n         AGO   .A$022\n.A$021   ANOP\n         ISPEXEC INIT=Y,MF=E,LIST=&L   INITIALISE ISPF ENVIRONMENT\n.A$022   ANOP\n         LM    R0,R15,&SMXWK9          RESTORE REGISTERS\n.A$022A  ANOP\n         B     &SMXLB2                 BRANCH AROUND CODE\n&SMXLB1  DS    0H\n         ST    R1,&SMXWK8              STORE FOR CONVERSION\n         AIF   ('&X2CE'(1,1) EQ 'Y').X2C012 Process MF=E format\n         AIF   ('&MF' EQ 'E').X2C011   Process MF=E format\n.X2C010  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK2,4,LIST=&L HEX TO CHARACTER\n         AGO   .X2C012                 Bypass MF=E format\n.X2C011  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK2,4,LIST=&L,MF=E HEX TO CHARACTER\n.X2C012  ANOP\n.*\n         CLI   &SMXWK7,C'Y'            Q. SETUP REGISTERS\n         BE    &SMXLB4                    Y. GO DO IT\n         MVI   &SMXWK3,C' '            BLANK FILL (RIPPLE)\n         MVC   &SMXWK3.+1(L'&SMXWK3.+L'&SMXWK4.-1),&SMXWK3\n         B     &SMXLB5                 BYPASS SETUP REGISTER\n&SMXLB4  DS    0H\n         MVC   &SMXWK3.(06),=C' REGP=' SET REGISTER\n         LA    R1,&SMXWK9              LOAD ADDRESS REGISTER SAVE AREA\n         ST    R1,&SMXWK8              STORE FOR CONVERSION\n         AIF   ('&X2CE'(1,1) EQ 'Y').X2C022 Process MF=E format\n         AIF   ('&MF' EQ 'E').X2C021   Process MF=E format\n.X2C020  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK4,4,LIST=&L HEX TO CHARACTER\n         AGO   .X2C022                 Bypass MF=E format\n.X2C021  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK4,4,LIST=&L,MF=E HEX TO CHARACTER\n.X2C022  ANOP\n*---------------------------------------------------------------------*\n* Set up PDUMPR start and end addresses for potential anchor points.  *\n*---------------------------------------------------------------------*\n         MVC   &SMXWK12.(21),=C'RR=......../........ '\n         LA    R1,&SMXLB8              START PDUMPR ADDRESS\n         ST    R1,&SMXWK8              STORE FOR CONVERSION\n         AIF   ('&X2CE'(1,1) EQ 'Y').X2C032 Process MF=E format\n         AIF   ('&MF' EQ 'E').X2C031   Process MF=E format\n.X2C030  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK12+3,4,LIST=&L HEX TO CHARACTER\n         AGO   .X2C032                 Bypass MF=E format\n.X2C031  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK12+3,4,LIST=&L,MF=E HEX TO CHARACTER\n.X2C032  ANOP\n.*--------------------------------------------------------------------*\n         LA    R1,&SMXLB7              END PDUMPR ADDRESS\n         ST    R1,&SMXWK8              STORE FOR CONVERSION\n         AIF   ('&X2CE'(1,1) EQ 'Y').X2C042 Process MF=E format\n         AIF   ('&MF' EQ 'E').X2C041   Process MF=E format\n.X2C040  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK12+12,4,LIST=&L HEX TO CHARACTER\n         AGO   .X2C042                 Bypass MF=E format\n.X2C041  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK12+12,4,LIST=&L,MF=E HEX TO CHARACTER\n.X2C042  ANOP\n.*--------------------------------------------------------------------*\n&SMXLB5  DS    0H\n         AIF   ('&LIST'(1,1) EQ 'Y').A$041 Process list form Yes\n         ISPEXEC &SMXWK1,&SMXWK6       CALL 'SHOSTOR' REXX EXEC\n         AGO   .A$042\n.A$041   ANOP\n         ISPEXEC &SMXWK1,&SMXWK6.,LIST=&L CALL 'SHOSTOR' REXX EXEC\n.A$042   ANOP\n         L     R14,&SMXWK8.+4          LOAD RETURN ADDRESS\n         BR    R14                     RETURN TO CALLER\n&SMXLB2  DS    0H\n.*\n.A$050   ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&#DISP EQ 'O').A$058 Do not set, just test\n         AIF   ('&#DISP'(1,1) EQ 'Y').A$057 Use passed value\n         AIF   ('&#DISP'(1,1) NE 'N').A$058 Bypass value setting\n.A$057   ANOP\n&#DISP   SETC  '&#DISP'(1,1)          Use 1st. byte\n         MVI   &SMXWK11,C'&#DISP'      SET DISPLAY REQUIREMENT\n         AIF   (T'&#ADR EQ 'O').SETEXT Continue if have an address\n         AIF   ('&#DISP'(1,1) EQ 'Y').A$059 Bypass test if set 2 'Y'\n         AIF   ('&#DISP'(1,1) EQ 'N').A$090 Bypass all if 'N' req'd\n.A$058   ANOP\n         AIF   (T'&#ADR EQ 'O').SETEXT Continue if have an address\n         CLI   &SMXWK11,C'N'           Q. DISPLAY REQUIRED\n         BE    &SMXLB7                    N. BYPASS\n.A$059   ANOP\n.*--------------------------------------------------------------------*\n         STM   R0,R15,&SMXWK9          SAVE ALL REGISTERS\n         LA    R0,&SMXLB3              LOAD RETURN ADDRESS\n         ST    R0,&SMXWK8.+4           SAVE RETURN ADDRESS\n         AIF   ('&REGP'(1,1) EQ 'N').A$060  Bypass if REGP=No\n         MVI   &SMXWK7,C'Y'            SETUP REGISTERS REQUEST\n         AGO   .A$065                  Branch around negative set\n.A$060   ANOP\n         MVI   &SMXWK7,C'N'            REGISTERS NOT REQUIRED\n.A$065   ANOP\n         AIF   (T'&MSG EQ 'O').A$075  Bypass if deliberate omission\n         MVI   &SMXWK10,C' '           INITIALISE OUTPUT MESSAGE USING\n         MVC   &SMXWK10.+1(L'&SMXWK10.-1),&SMXWK10 ..RIPPLE MOVE\n&MSGNW   SETC  '&MSG'                 Set message to move from label\n         AIF   ('&MSG'(1,1) EQ '''').A$072 Go process literal message\n.*--------------------------------------------------------------------*\n.* Establish length of literal and move length                        *\n.*--------------------------------------------------------------------*\n         LCLA  &APOST\n&MSGL    SETA  K'&MSG                     Set length of message\n         AIF   ('&MSG'(&MSGL,1) EQ ')').A$071\n         MVC   &SMXWK10,&MSGNW         MOVE MESSAGE TO OUTPUT\n         AGO   .A$075                       Leave process\n.A$071   ANOP\n&MSGL1   SETA  &MSGL-1\n&APOST   SETA  0\n.LOOP1   ANOP\n         AIF   (&MSGL1 EQ  0).E4\n         AIF   ('&MSG'(&MSGL1,1) EQ ',').LOOP1E\n         AIF   ('&MSG'(&MSGL1,1) EQ '(').LOOP2E\n&MSGL1   SETA  &MSGL1-1\n         AGO   .LOOP1\n.LOOP1E  ANOP\n&APOST   SETA  &MSGL1\n&MSGL1   SETA  &MSGL1-1\n.LOOP2   ANOP\n         AIF   (&MSGL1 EQ 0).E4\n         AIF   ('&MSG'(&MSGL1,1) EQ '(').LOOP2E\n&MSGL1   SETA  &MSGL1-1\n         AGO   .LOOP2\n.LOOP2E  ANOP\n         AIF   (&APOST EQ 0).VARMSG\n&MSGL3   SETC  '&MSG'(&MSGL1+1,&APOST-(&MSGL1+1))\n&MSGNW   SETC  '&MSG'(1,&MSGL1).'&MSG'(&APOST+1,&MSGL-&APOST)\n         AGO   .MSGDTOK\n.VARMSG  ANOP\n&MSGL3   SETC  '&MSG'(&MSGL1+1,&MSGL-(&MSGL1+1))\n&MSGNW   SETC  '&MSG'(1,&MSGL1-1)\n.MSGDTOK ANOP\n         MVC   &SMXWK10.(&MSGL3),&MSGNW MOVE MESSAGE TO OUTPUT\n         AGO   .A$075                       Leave process\n.*-------------------------------------------------------------------*\n.* Establish length of variable and move length                      *\n.*-------------------------------------------------------------------*\n.A$072   ANOP\n         LCLC  &CHAR,&AMPER\n         LCLA  &LC,&QC,&AC\n&AMPER   SETC  '&&'\n&MSGL    SETA  K'&MSG                       Loop counter (message len)\n&QC      SETA  0                            Quotes counter\n&AC      SETA  0                            Ampersand counter\n&CP      SETA  0                            Character pointer\n.LOOP3   ANOP\n&CP      SETA  &CP+1                        Iincrement char pointer\n&CHAR    SETC  '&MSG'(&CP,1)                Set character value\n.TQUOT   ANOP\n         AIF   ('&CHAR' NE '''').TAMPR      Bypass if char not \"'\"\n&QC      SETA  &QC+1                        Bump quotes counter\n         AGO   .NXTCH                       Get nest char\n.TAMPR   ANOP\n         AIF   ('&CHAR.&CHAR' NE '&AMPER').NXTCH Bypass if not \"&\"\n&AC      SETA  &AC+1                        Bump amper counter\n.NXTCH   ANOP\n         AIF   (&CP LT &MSGL).LOOP3         Loop till end\n&MSGL    SETA  &MSGL-2-(((&QC-2)/2)+(&AC/2)) Get actual length\n         MVC   &SMXWK10.(&MSGL),=CL(&MSGL)&MSG\n.A$075   ANOP\n.*--------------------------------------------------------------------*\n         LA    R1,&#ADR                LOAD ADDRESS OF ADDRESS\n         B     &SMXLB1                 BRANCH TO COMMON CODE\n&SMXLB3  DS    0H\n         LM    R0,R15,&SMXWK9          RESTORE ALL REGISTERS\n         AIF   (T'&QUIT EQ 'O').A$080  Bypass if no QUIT\n         C     R15,=C'QUIT'            Q. QUIT REQUESTED\n         BE    &QUIT                      Y. GO TO LABEL\n.A$080   ANOP\n         C     R15,=C'DOFF'            Q. DISPLAY OFF REQUESTED\n         BNE   &SMXLB7                    N. BYPASS\n         MVI   &SMXWK11,C'N'           SET DISPLAY OFF\n&SMXLB7  DS    0H                      EXIT ANCHOR\n.A$090   ANOP\n         AGO   .MEXIT                  Exit macro\n.*\n.A$200   ANOP\n         AIF   (T'&MF NE 'O').A$205    Bypass if MF is set\n         AIF   (&SMXEXE1).A$020        Return if previously executed\n.A$205   ANOP\n         AIF   ('&TYPE'(1,1) NE 'C').A$210  Bypass if not constant\n&SMXWK1  SETC  ''\n&SMXWK2  SETC  ''\n&SMXWK3  SETC  ''\n&SMXWK4  SETC  ''\n&SMXWK5  SETC  ''\n&SMXWK6  SETC  ''\n&SMXWK7  SETC  ''\n&SMXWK8  SETC  ''\n&SMXWK9  SETC  ''\n&SMXWK10 SETC  ''\n&SMXWK11 SETC  ''\n&SMXWK12 SETC  ''\n.*\n.A$210   ANOP\n.*\n         AIF   ('&ISPI'(1,1) NE 'Y').A$224 Bypass if ISPEXEC not req'd\n         AIF   ('&LIST'(1,1) EQ 'Y').A$221 Process list form Yes\n         ISPEXEC  MF=L,INIT=Y,TYPE=&TYPE INIT ISPF ENVIRONMENT\n         AGO   .A$224\n.A$221   ANOP\n         AIF   ('&ISPI'(1,1) EQ 'N').A$224 Bypass if INIT=No\n.A$222   ANOP\n         ISPEXEC  MF=L,INIT=Y,LIST=&L,TYPE=&TYPE INIT ISPF ENVIRONMENT\n.A$224   ANOP\n         DS    0F                      WORD ALLIGN\n&SMXWK8  DS    2F                      WORK AREA\n&SMXWK9  DS    16F                     REGISTER SAVE AREA FRO MACRO\n&SMXWK1  DC    C'SELECT CMD(%SHOWSTOR ' WHAT WE WANT TO EXECUTE\n&SMXWK2  DC    C'        '             ADDRESS WE WANT TO DISPLAY\n&SMXWK3  DC    C' REGP='               REGISTER EQUATE LITERAL\n&SMXWK4  DC    C'        '             ADDRESS WE WANT TO DISPLAY\n         DC    C' '                    FILLER\n&SMXWK12 DC    CL21'RR=......../........ ' Start and finish\n.*-------------------------------------------------------------------*\n.*   NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE    *\n.*-------------------------------------------------------------------*\n.* Modify the length of the next field to ensure the value (length)  *\n.* of variable &SMXWK6 does not exceed 256 as &SMXWK1 and &SMXWK6    *\n.* are used in a MVC instruction.                                    *\n.*-------------------------------------------------------------------*\n&SMXWK10 DC    CL190' '                MESSAGE AREA\n.*-------------------------------------------------------------------*\n&SMXWK5  DC    C')'                    WHAT WE WANT TO EXECUTE\n         AIF   ('&TYPE'(1,1) EQ 'C').A$223  Bypass if constant\n&SMXWK6  EQU   *-&SMXWK1               ISPF COMMAND LENGTH\n.A$223   ANOP\n&SMXWK7  DC    C'Y'                    REGISTER GENERATE FLAG\n&SMXWK11 DC    C'Y'                    DISPLAY ON\n         AIF   ('&X2CL'(1,1) NE 'Y').X2C090 BYpass MF=L for HEXCHMAC\n         HEXCHMAC MF=L\n.X2C090  ANOP\n         AIF   (T'&MF EQ 'O').A$020    Return\n         AGO   .MEXIT                  Exit\n.*--------------------------------------------------------------------*\n.E0      MNOTE 12,'No Errors at this stage'\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.SETEXT  ANOP\n&SMXLB7  DS    0H                      EXIT ANCHOR\n.MEXIT   ANOP\n         AIF   ('&LIST'(1,1) EQ 'Y').MEXIT9\n         POP   PRINT\n.MEXIT9  ANOP\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDUMPR#": {"ttr": 10753, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x01\\x01\\x050\\x8f\\x01\\x050\\x8f\"$\\x01\\x97\\x01\\x97\\x00\\x00\\xc1\\xd3\\xc5\\xe7@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2005-11-04T00:00:00", "modifydate": "2005-11-04T22:24:01", "lines": 407, "newlines": 407, "modlines": 0, "user": "ALEX"}, "text": "         MACRO\n&NAME    PDUMPR &ADDR,          Address to display                     X\n               &REGP=YES,       Ser REGP= parameter                    X\n               &TYPE=VAR,       CONstant/VARiable type for MF=L        X\n               &ISPI=YES,       Invoke ISPEXEC INIT=Y explicitly       X\n               &X2CE=NO,        HEXCHMAC MF=E required ?               X\n               &X2CL=NO,        HEXCHMAC MF=L required ?               X\n               &REXX=SHOWSTOR,  REXX EXEC                              X\n               &HELP=NO,        Help in expansion                      X\n               &MSG=,           Message area for GC009                 X\n               &LIST=NO,        List expansion                         X\n               &DISPLAY=ASIS,   Process SHOWSTOR display               X\n               &DISP=ASIS,      Alias for DISPLAY                      X\n               &QUIT=,          R15 set to 'QUIT' branch               X\n               &MF=             EXEC/LIST format\n.*\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP   Go full help\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'PDUMPR' parameter and  *\n* it's use, pass parameter 'HELP=Yes'.                                *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE                         Bypass full help\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* This facility is used to display memory from within a program using *\n* the SHOWSTOR memory mapper written in REXX, using ISPF services.    *\n*                                                                     *\n* All parameters are keyword parameters except the first which is the *\n* only positional parameter for the address to be displayed. The      *\n* format is as follows:                                               *\n*                                                                     *\n*   PDUMPR addr,kw1=..,kw2=..,kwn=...                                 *\n*                                                                     *\n* The following are permissable parameters:                           *\n*   addr          - Address to be displayed. May be any relocatable   *\n*                   address, a register in parentheses or a displace- *\n*                   memt and register in parentheses.                 *\n*   ISPI=Yes/No   o Invoke the ISPEXEC macro with the INIT option in  *\n*                   it. Default is Yes. Set to No if you explicitly   *\n*                   use the ISPEXEC macro in your program.            *\n*   X2CE=Yes/No   o Invoke the HEXCHMAC macro MF=E format. This is    *\n*                   only used if the HEXCHMAC with MF=E is explicitly *\n*                   used in the same program and will prevent         *\n*                   duplicate variable names. If PDUMPR is invoked    *\n*                   with MF=E then this feature is automatically      *\n*                   enabled. The default is NO.                       *\n*   X2CL=Yes/No   o Invoke the HEXCHMAC macro MF=L format. Similar to *\n*                   X2CE parameter. Default is No.                    *\n*   MSG='....'    - MEssage to display on entering SHOWSTOR. Literal  *\n*      =label()     padded/truncated to 256 bytes or a label where    *\n*                   256 bytes or length of variable subscripted is    *\n*                   moved, eg. MSG=MSGSRCE(80).                       *\n*   QUIT=label    - Label of the instruction where control is to be   *\n*                   passed if SHOWSTOR is terminated using the 'QUIT' *\n*                   feature. Refer to SHOWSTOR documentation for      *\n*                   further details.                                  *\n*   REGP=Yes/No   - Set REGP= parameter on entry. this will enable    *\n*                   the use of the /REGS* command. (Refer to SHOWSTOR *\n*                   documentation.) Default is Yes and you would be   *\n*                   a fool to suppress this handy feature.            *\n*   REXX=SHOWSTOR - REXX EXEC to be executed from the macro. This     *\n*                   should not be changed.                            *\n*   TYPE=Var/Con  - Constatnt/Variable type for MF=L format. VAR is   *\n*                   the default.                                      *\n*   DISPLAY=Yes/No/Asis                                               *\n*                 - Activate or bypass SHOWSTOR displays. Used to     *\n*                   control SHOWSTOR displays during looping. Any     *\n*                   value other than 'N' or 'Y' will default to 'A'.  *\n*                   Use this parameter without an Address to set the  *\n*                   condition without a display.                      *\n*   HELP=No/Yes   - Help in expansion of this macro.                  *\n*   LIST=No/Yes   - List expansion.                                   *\n*   MF=           - Exec/List format.                                 *\n*                                                                     *\n* To use this feature you will also need access to macros ISPEXEC and *\n* HEXCHMAC.                                                           *\n* Parameters with an 'o' seperator are parameters whose values are    *\n* dependant on the requirements of the ISPEXEC or HEXCHMAC macros.    *\n* Refer to the actual macros for further details.                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* Known GOTCHAs:                                                      *\n* - This facility cannot be invoked from an authorised program        *\n*   because of ISPF's limitations with authorised programs.           *\n* - Because the macros used are designed in subroutine format, ensure *\n*   that the first physical occurance of this macro (or it's related  *\n*   counterparts of ISPEXEC and HEXCHMAC) are the ones actually       *\n*   executed first to ensure all variables/settings are initialised.  *\n*   This can be a problem in programs with a lot of branching logic.  *\n*   To safeguard against this, invoke the macro as early as possible  *\n*   in your program without an \"addr\" parameter to force              *\n*   initialisation of all 3 macros (PDUMPR, ISPEXEC and HEXCHMAC).    *\n* - Take care when explicitly using ISPEXEC and HEXCHMAC macros       *\n*   outside this macro. You may need to fine tune the ISPI= and the   *\n*   X2CE= and X2CL= parameters to prevent duplicate names.            *\n*                                                                     *\n*---------------------------------------------------------------------*\n.*\n.A$HELPE ANOP\n.*\n         AIF   ('&LIST'(1,1) EQ 'Y').A$XXX\n         PUSH  PRINT\n         PRINT NOGEN\n.A$XXX   ANOP\n.*\n         LCLC  &SMXVAR,&L,&#DISP,&#ADR\n         GBLB  &SMXFST1,&SMXEXE1,&SMXLST1\n         GBLC  &SMXFXD\n         GBLB  &XC1ST\n.*\n.*--------------------------------------------------------------------*\n.* Evaluate and set Display requirements                              *\n.*--------------------------------------------------------------------*\n         AIF   (T'&DISPLAY EQ 'O').A$001 Test for 'alias'\n&#DISP   SETC  '&DISPLAY'                Set to parameter\n         AGO   .A$002                    GoAround alternate process\n.A$001   ANOP\n         AIF   (T'&DISP EQ 'O').A$002    Bypass\n&#DISP   SETC  '&DISP'                   Set to 'alias' parameter\n.A$002   ANOP\n.*\n.*--------------------------------------------------------------------*\n.* Evaluate address if passed as (reg)....                            *\n.*--------------------------------------------------------------------*\n&#ADR    SETC  '&ADDR'                Set to parameter\n         AIF   (T'&#ADR EQ 'O').A$003 Bypass processing\n         AIF   ('&#ADR'(1,1) NE '(').A$003 Bypass if 1st char not '('\n&#ADR    SETC  '0&#ADR.'              Set to Offset zero\n.A$003   ANOP\n.*--------------------------------------------------------------------*\n.*\n         AIF   (&SMXFST1).A$010\n.*--------------------------------------------------------------------*\n.* Global variables on initial invocation\n.*--------------------------------------------------------------------*\n&SMXFST1 SETB  1                       Set 1st. time thru  flag\n&SMXFXD  SETC  'SMX'.'&SYSNDX'         Set fixed index value\n&#DISP   SETC  'YES'                   Force display 1st. time thru\n.A$010   ANOP\n.*--------------------------------------------------------------------*\n.* Local variables on each invocation\n.*--------------------------------------------------------------------*\n&SMXVAR  SETC  'SMX'.'&SYSNDX'         Set variable index value\n.*--------------------------------------------------------------------*\n.* Global variables on each invocation\n.*--------------------------------------------------------------------*\n&SMXLB0  SETC  '&SMXVAR'.'0'           Set variables\n&SMXLB1  SETC  '&SMXFXD'.'1'           Set variables\n&SMXLB2  SETC  '&SMXVAR'.'2'           Set variables\n&SMXLB3  SETC  '&SMXVAR'.'3'           Set variables\n&SMXLB4  SETC  '&SMXFXD'.'4'           Set variables\n&SMXLB5  SETC  '&SMXFXD'.'5'           Set variables\n&SMXLB6  SETC  '&SMXVAR'.'6'           SPARE - NOT USED\n&SMXLB7  SETC  '&SMXVAR'.'7'           Set variable\n&SMXWK1  SETC  '&SMXFXD'.'8'           Set variables\n&SMXWK2  SETC  '&SMXFXD'.'9'           Set variables\n&SMXWK3  SETC  '&SMXFXD'.'A'           Set variables\n&SMXWK4  SETC  '&SMXFXD'.'B'           Set variables\n&SMXWK5  SETC  '&SMXFXD'.'C'           Set variables\n&SMXWK6  SETC  '&SMXFXD'.'D'           Set variables\n&SMXWK7  SETC  '&SMXFXD'.'E'           Set variables\n&SMXWK8  SETC  '&SMXFXD'.'F'           Set variables\n&SMXWK9  SETC  '&SMXFXD'.'G'           Set variables\n&SMXWK10 SETC  '&SMXFXD'.'H'           Set variables\n&SMXWK11 SETC  '&SMXFXD'.'I'           Set variables\n.*--------------------------------------------------------------------*\n&L       SETC  '&LIST'\n         AIF   (T'&NAME EQ 'O').A$YYY  Bypass if label passed\n&SMXLB0  SETC  '&NAME'                 Use invocation name fro label\n.A$YYY   ANOP\n.*\n         AIF   ('&MF' EQ 'L').A$200    Process list form of macro\n.*\n         B     &SMXLB0                 ENSURE FULL WORD BRANCH\n         AIF   (T'&MF EQ 'O').A$200    Process list form of macro\n.A$020   ANOP\n&SMXLB0  DS    0F                      ENSURE FULL WORD ALLIGNMENT\n.*\n         AIF   (&SMXEXE1).A$050        Bypass if not 1st. MF=E\n&SMXEXE1 SETB  1\n         STM   R0,R15,&SMXWK9          SAVE ALL REGISTERS\n         AIF   ('&ISPI'(1,1) NE 'Y').A$022A Bypass if ISPEXEC not req\n         AIF   ('&LIST'(1,1) EQ 'Y').A$021  Process list form yes\n         ISPEXEC INIT=Y,MF=E           INITIALISE ISPF ENVIRONMENT\n         AGO   .A$022\n.A$021   ANOP\n         ISPEXEC INIT=Y,MF=E,LIST=&L   INITIALISE ISPF ENVIRONMENT\n.A$022   ANOP\n         LM    R0,R15,&SMXWK9          RESTORE REGISTERS\n.A$022A  ANOP\n         B     &SMXLB2                 BRANCH AROUND CODE\n&SMXLB1  DS    0H\n         ST    R1,&SMXWK8              STORE FOR CONVERSION\n         AIF   ('&X2CE'(1,1) EQ 'Y').X2C012 Process MF=E format\n         AIF   ('&MF' EQ 'E').X2C011   Process MF=E format\n.X2C010  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK2,4,LIST=&L HEX TO CHARACTER\n         AGO   .X2C012                 Bypass MF=E format\n.X2C011  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK2,4,LIST=&L,MF=E HEX TO CHARACTER\n.X2C012  ANOP\n.*\n         CLI   &SMXWK7,C'Y'            Q. SETUP REGISTERS\n         BE    &SMXLB4                    Y. GO DO IT\n         MVI   &SMXWK3,C' '            BLANK FILL (RIPPLE)\n         MVC   &SMXWK3.+1(L'&SMXWK3.+L'&SMXWK4.-1),&SMXWK3\n         B     &SMXLB5                 BYPASS SETUP REGISTER\n&SMXLB4  DS    0H\n         MVC   &SMXWK3.(06),=C' REGP=' SET REGISTER\n         LA    R1,&SMXWK9              LOAD ADDRESS REGISTER SAVE AREA\n         ST    R1,&SMXWK8              STORE FOR CONVERSION\n         AIF   ('&X2CE'(1,1) EQ 'Y').X2C022 Process MF=E format\n         AIF   ('&MF' EQ 'E').X2C021   Process MF=E format\n.X2C020  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK4,4,LIST=&L HEX TO CHARACTER\n         AGO   .X2C022                 Bypass MF=E format\n.X2C021  ANOP\n         HEXCHMAC &SMXWK8,&SMXWK4,4,LIST=&L,MF=E HEX TO CHARACTER\n.X2C022  ANOP\n&SMXLB5  DS    0H\n         AIF   ('&LIST'(1,1) EQ 'Y').A$041 Process list form Yes\n         ISPEXEC &SMXWK1,&SMXWK6       CALL 'SHOSTOR' REXX EXEC\n         AGO   .A$042\n.A$041   ANOP\n         ISPEXEC &SMXWK1,&SMXWK6.,LIST=&L CALL 'SHOSTOR' REXX EXEC\n.A$042   ANOP\n         L     R14,&SMXWK8.+4          LOAD RETURN ADDRESS\n         BR    R14                     RETURN TO CALLER\n&SMXLB2  DS    0H\n.*\n.A$050   ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&#DISP EQ 'O').A$058 Do not set, just test\n         AIF   ('&#DISP'(1,1) EQ 'Y').A$057 Use passed value\n         AIF   ('&#DISP'(1,1) NE 'N').A$058 Bypass value setting\n.A$057   ANOP\n&#DISP   SETC  '&#DISP'(1,1)          Use 1st. byte\n         MVI   &SMXWK11,C'&#DISP'      SET DISPLAY REQUIREMENT\n         AIF   (T'&#ADR EQ 'O').MEXIT Continue if have an address\n         AIF   ('&#DISP'(1,1) EQ 'Y').A$059 Bypass test if set 2 'Y'\n         AIF   ('&#DISP'(1,1) EQ 'N').A$090 Bypass all if 'N' req'd\n.A$058   ANOP\n         AIF   (T'&#ADR EQ 'O').MEXIT Continue if have an address\n         CLI   &SMXWK11,C'N'           Q. DISPLAY REQUIRED\n         BE    &SMXLB7                    N. BYPASS\n.A$059   ANOP\n.*--------------------------------------------------------------------*\n         STM   R0,R15,&SMXWK9          SAVE ALL REGISTERS\n         LA    R0,&SMXLB3              LOAD RETURN ADDRESS\n         ST    R0,&SMXWK8.+4           SAVE RETURN ADDRESS\n         AIF   ('&REGP'(1,1) EQ 'N').A$060  Bypass if REGP=No\n         MVI   &SMXWK7,C'Y'            SETUP REGISTERS REQUEST\n         AGO   .A$065                  Branch around negative set\n.A$060   ANOP\n         MVI   &SMXWK7,C'N'            REGISTERS NOT REQUIRED\n.A$065   ANOP\n         AIF   (T'&MSG EQ 'O').A$075  Bypass if deliberate omission\n         MVI   &SMXWK10,C' '           INITIALISE OUTPUT MESSAGE USING\n         MVC   &SMXWK10.+1(L'&SMXWK10.-1),&SMXWK10 ..RIPPLE MOVE\n&MSGNW   SETC  '&MSG'                 Set message to move from label\n         AIF   ('&MSG'(1,1) EQ '''').A$072 Go process literal message\n.*--------------------------------------------------------------------*\n.* Establish length of literal and move length                        *\n.*--------------------------------------------------------------------*\n         LCLA  &APOST\n&MSGL    SETA  K'&MSG                     Set length of message\n         AIF   ('&MSG'(&MSGL,1) EQ ')').A$071\n         MVC   &SMXWK10,&MSGNW         MOVE MESSAGE TO OUTPUT\n         AGO   .A$075                       Leave process\n.A$071   ANOP\n&MSGL1   SETA  &MSGL-1\n&APOST   SETA  0\n.LOOP1   ANOP\n         AIF   (&MSGL1 EQ  0).E4\n         AIF   ('&MSG'(&MSGL1,1) EQ ',').LOOP1E\n         AIF   ('&MSG'(&MSGL1,1) EQ '(').LOOP2E\n&MSGL1   SETA  &MSGL1-1\n         AGO   .LOOP1\n.LOOP1E  ANOP\n&APOST   SETA  &MSGL1\n&MSGL1   SETA  &MSGL1-1\n.LOOP2   ANOP\n         AIF   (&MSGL1 EQ 0).E4\n         AIF   ('&MSG'(&MSGL1,1) EQ '(').LOOP2E\n&MSGL1   SETA  &MSGL1-1\n         AGO   .LOOP2\n.LOOP2E  ANOP\n         AIF   (&APOST EQ 0).VARMSG\n&MSGL3   SETC  '&MSG'(&MSGL1+1,&APOST-(&MSGL1+1))\n&MSGNW   SETC  '&MSG'(1,&MSGL1).'&MSG'(&APOST+1,&MSGL-&APOST)\n         AGO   .MSGDTOK\n.VARMSG  ANOP\n&MSGL3   SETC  '&MSG'(&MSGL1+1,&MSGL-(&MSGL1+1))\n&MSGNW   SETC  '&MSG'(1,&MSGL1-1)\n.MSGDTOK ANOP\n         MVC   &SMXWK10.(&MSGL3),&MSGNW MOVE MESSAGE TO OUTPUT\n         AGO   .A$075                       Leave process\n.*-------------------------------------------------------------------*\n.* Establish length of variable and move length                      *\n.*-------------------------------------------------------------------*\n.A$072   ANOP\n         LCLC  &CHAR,&AMPER\n         LCLA  &LC,&QC,&AC\n&AMPER   SETC  '&&'\n&MSGL    SETA  K'&MSG                       Loop counter (message len)\n&QC      SETA  0                            Quotes counter\n&AC      SETA  0                            Ampersand counter\n&CP      SETA  0                            Character pointer\n.LOOP3   ANOP\n&CP      SETA  &CP+1                        Iincrement char pointer\n&CHAR    SETC  '&MSG'(&CP,1)                Set character value\n.TQUOT   ANOP\n         AIF   ('&CHAR' NE '''').TAMPR      Bypass if char not \"'\"\n&QC      SETA  &QC+1                        Bump quotes counter\n         AGO   .NXTCH                       Get nest char\n.TAMPR   ANOP\n         AIF   ('&CHAR.&CHAR' NE '&AMPER').NXTCH Bypass if not \"&\"\n&AC      SETA  &AC+1                        Bump amper counter\n.NXTCH   ANOP\n         AIF   (&CP LT &MSGL).LOOP3         Loop till end\n&MSGL    SETA  &MSGL-2-(((&QC-2)/2)+(&AC/2)) Get actual length\n         MVC   &SMXWK10.(&MSGL),=CL(&MSGL)&MSG\n.A$075   ANOP\n.*--------------------------------------------------------------------*\n         LA    R1,&#ADR                LOAD ADDRESS OF ADDRESS\n         B     &SMXLB1                 BRANCH TO COMMON CODE\n&SMXLB3  DS    0H\n         LM    R0,R15,&SMXWK9          RESTORE ALL REGISTERS\n         AIF   (T'&QUIT EQ 'O').A$080  Bypass if no QUIT\n         C     R15,=C'QUIT'            Q. QUIT REQUESTED\n         BE    &QUIT                      Y. GO TO LABEL\n.A$080   ANOP\n         C     R15,=C'DOFF'            Q. DISPLAY OFF REQUESTED\n         BNE   &SMXLB7                    N. BYPASS\n         MVI   &SMXWK11,C'N'           SET DISPLAY OFF\n&SMXLB7  DS    0H\n.A$090   ANOP\n         AGO   .MEXIT                  Exit macro\n.*\n.A$200   ANOP\n         AIF   (T'&MF NE 'O').A$205    Bypass if MF is set\n         AIF   (&SMXEXE1).A$020        Return if previously executed\n.A$205   ANOP\n         AIF   ('&TYPE'(1,1) NE 'C').A$210  Bypass if not constant\n&SMXWK1  SETC  ''\n&SMXWK2  SETC  ''\n&SMXWK3  SETC  ''\n&SMXWK4  SETC  ''\n&SMXWK5  SETC  ''\n&SMXWK6  SETC  ''\n&SMXWK7  SETC  ''\n&SMXWK8  SETC  ''\n&SMXWK9  SETC  ''\n&SMXWK10 SETC  ''\n&SMXWK11 SETC  ''\n.*\n.A$210   ANOP\n.*\n         AIF   ('&ISPI'(1,1) NE 'Y').A$224 Bypass if ISPEXEC not req'd\n         AIF   ('&LIST'(1,1) EQ 'Y').A$221 Process list form Yes\n         ISPEXEC  MF=L,INIT=Y,TYPE=&TYPE INIT ISPF ENVIRONMENT\n         AGO   .A$224\n.A$221   ANOP\n         AIF   ('&ISPI'(1,1) EQ 'N').A$224 Bypass if INIT=No\n.A$222   ANOP\n         ISPEXEC  MF=L,INIT=Y,LIST=&L,TYPE=&TYPE INIT ISPF ENVIRONMENT\n.A$224   ANOP\n         DS    0F                      WORD ALLIGN\n&SMXWK8  DS    2F                      WORK AREA\n&SMXWK9  DS    16F                     REGISTER SAVE AREA FRO MACRO\n&SMXWK1  DC    C'SELECT CMD(%SHOWSTOR ' WHAT WE WANT TO EXECUTE\n&SMXWK2  DC    C'        '             ADDRESS WE WANT TO DISPLAY\n&SMXWK3  DC    C' REGP='               REGISTER EQUATE LITERAL\n&SMXWK4  DC    C'        '             ADDRESS WE WANT TO DISPLAY\n         DC    C' '                    FILLER\n.*-------------------------------------------------------------------*\n.*   NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE - NOTE    *\n.*-------------------------------------------------------------------*\n.* Modify the length of the next field to ensure the value (length)  *\n.* of variable &SMXWK6 does not exceed 256 as &SMXWK1 and &SMXWK6    *\n.* are used in a MVC instruction.                                    *\n.*-------------------------------------------------------------------*\n&SMXWK10 DC    CL211' '                MESSAGE AREA\n.*-------------------------------------------------------------------*\n&SMXWK5  DC    C')'                    WHAT WE WANT TO EXECUTE\n         AIF   ('&TYPE'(1,1) EQ 'C').A$223  Bypass if constant\n&SMXWK6  EQU   *-&SMXWK1               ISPF COMMAND LENGTH\n.A$223   ANOP\n&SMXWK7  DC    C'Y'                    REGISTER GENERATE FLAG\n&SMXWK11 DC    C'Y'                    DISPLAY ON\n         AIF   ('&X2CL'(1,1) NE 'Y').X2C030 BYpass MF=L for HEXCHMAC\n         HEXCHMAC MF=L\n.X2C030  ANOP\n         AIF   (T'&MF EQ 'O').A$020    Return\n         AGO   .MEXIT                  Exit\n.*--------------------------------------------------------------------*\n.E0      MNOTE 12,'No Errors at this stage'\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.MEXIT   ANOP\n         AIF   ('&LIST'(1,1) EQ 'Y').MEXIT9\n         POP   PRINT\n.MEXIT9  ANOP\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLOAD": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00@\\x00\\x94%\\x8f\\x00\\x94%\\x8f\\x17\\x17\\x00J\\x00@\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1994-09-15T00:00:00", "modifydate": "1994-09-15T17:17:40", "lines": 74, "newlines": 64, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    PLOAD &PROG,&LIST=NO,&HELP=NO,&R15=\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'PLOAD' parameter and   *\n* it's use, pass parameter 'HELP=Yes'.\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*  Macro to load an external program, execute it and then delete it.  *\n*                                                                     *\n*  PARAMETERS:                                                        *\n*    1. Program name.                                                 *\n*       This may be any literal program name (unquoted) or a register *\n*       pointing to an 8 byte variable containing the program name.   *\n*    2. R15=... Where to store return code from PLOAD program.        *\n*       This may be a variable name or a register pointing to a 4     *\n*        byte variable.                                               *\n*    3. LIST=No/Yes. Used to generate macro expansion code.           *\n*             Default is 'NO'                                         *\n*    4. HELP=No/Yes. Used to display this help box.                   *\n*             Default is 'NO'                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) EQ 'Y').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   (T'&NAME EQ 'O').A$00   BYPASS IF NO LABEL PASSED\n&NAME    DS    0H\n.A$00    ANOP\n         AIF (T'&PROG EQ 'O').E0       ERROR IF PROGNAME OMITTED\n.*--------------------------------------------------------------------*\n         LCLC  &REGSV15,&LTYPE\n         LCLA  &PL\n         AIF (T'&R15 EQ 'O').LOAD      BYPASS IF OMITTED\n         AIF   ('&R15'(1,1) EQ '(').A$03\n&REGSV15 SETC   '&R15'\n         AGO   .LOAD\n.A$03    ANOP\n&PL      SETA  K'&R15-2                     PARAMETER LENGTH\n&REGSV15 SETC   '&R15'(2,&PL)\n&REGSV15 SETC   '0(&REGSV15)'\n.*--------------------------------------------------------------------*\n.LOAD    ANOP\n         AIF   ('&PROG'(1,1) EQ '(').LOAD1 LEAVE LTYPE IF PROG \u00ac= REG\n         LOAD  EP=&PROG                LOAD PROGRAM DUMP\n         AGO   .LOADX\n.LOAD1   ANOP\n         LOAD  EPLOC=&PROG             LOAD PROGRAM DUMP\n.LOADX   ANOP\n         LR    R15,R0                  LOAD ENTRY POINT OF PROGRAM\n         BALR  R14,R15                 CALL 'PROGDUMP'\n         AIF (T'&R15 EQ 'O').DELT      BYPASS IF OMITTED\n         ST    R15,&REGSV15            SAVE RETURN CODE\n.DELT    ANOP\n         AIF   ('&PROG'(1,1) EQ '(').DELT1 LEAVE LTYPE IF PROG \u00ac= REG\n         DELETE EP=&PROG               LOAD PROGRAM DUMP\n         AGO   .DELTX\n.DELT1   ANOP\n         DELETE EPLOC=&PROG            LOAD PROGRAM DUMP\n.DELTX   ANOP\n.*--------------------------------------------------------------------*\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.E0      MNOTE 12,'''PLOAD'' REQUIRES A PROGRAM NAME OR POINTER'\n         AGO   .MEXIT\n.*--------------------------------------------------------------------*\n.MEXIT   ANOP\n         POP   PRINT\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PUTL": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01L\\x00)\\x00\\x93#\\x8f\\x00\\x94'\\x1f\\t3\\x01l\\x00c\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@\"", "ispf": {"version": "01.76", "flags": 0, "createdate": "1993-08-26T00:00:00", "modifydate": "1994-09-28T09:33:29", "lines": 364, "newlines": 99, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    PUTL  &SOURCE,&LTYPE=STD,&MF=,&LIST=NO,&HELP=NO,&CPPL=\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'PUTL' parameter and    *\n* it's use, pass parameter 'HELP=Yes'.                                *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* PUTL                                                                *\n* ----                                                                *\n* The macro will establish all the required linkages, parameter lists *\n* etc... and issue a PUTLINE macro.                                   *\n* This is preferable to issuing a TPUT macro as a PUTLINE macro can   *\n* be intercepted using SYSOUTTRAP for CLISTs and OUTTRAP for REXX.    *\n*                                                                     *\n*   Format (with defaults):                                           *\n*      PUTL source,TL=,MF=,LTYPE=STD,CPPL=,LIST=NO,HELP=NO            *\n*                                                                     *\n*      Minimun requirement for standard format:                       *\n*        Processing section -                                         *\n*            PUTL source                                              *\n*        DSECTS -                                                     *\n*            PUTL MF=L,LTYPE=IBM                                      *\n*                                                                     *\n*   Parameters:-                                                      *\n*       1. SOURCE      - Parameter pointer. This may be a quoted text *\n*                        literal or a RX-type address or register.    *\n*                                                                     *\n*                        If it is text, it cannot be longer than 79   *\n*                        bytes. If there are imbedded quotes or       *\n*                        ampersands.                                  *\n*                                                                     *\n*                        If it is a RX-type address or register, it   *\n*                        must point to storage where the first half   *\n*                        word is the length of the message following. *\n*                        The length must be in the range of 1-79      *\n*                        bytes. If the length is invalid, it will be  *\n*                        set to 79.  The length must be followed by   *\n*                        the message text.                            *\n*                        NOTE - The length should be the length of    *\n*                               the actual text. The PUTL macro will  *\n*                               add 4 extra bytes (for the length and *\n*                               offset components) requred by the     *\n*                               PUTLINE command.                      *\n*                                                                     *\n*                        This parameter may be ommitted on first      *\n*                        invocation and will be used just to generate *\n*                        the common code.                             *\n*                                                                     *\n*       2. LTYPE=      - LIST type of macro.                          *\n*                        The following are permitted values:          *\n*                          STD - Default for standard form of the     *\n*                                 macro.                              *\n*                          CON - Constant value (for re-entrant progs *\n*                                in data area).                       *\n*                          VAR - Variable value (for re-entrant progs *\n*                                in DSECT area).                      *\n*                          IBM - IBM macros required. Without this    *\n*                                format of the macro, you must code   *\n*                                the following IBM DSECTS             *\n*                                      IKJCPPL                        *\n*                                      IKJIOPL                        *\n*                                                                     *\n*                        For MF=L without this parameter or LTYPE=STD *\n*                        format, both CON and VAR formats will be     *\n*                        included. However, LTYPE=IBM must still be   *\n*                        coded on a seperate statement.               *\n*                                                                     *\n*       3. CPPL=       - CPPL address. Must be provided if you do not *\n*                        invoke PUTL on entry and R1 no longer points *\n*                        to the CPPL (eg. R1 is used as 'SOURCE'      *\n*                        pointer). May be a RX-type address or        *\n*                        register.                                    *\n*                                                                     *\n*       4. MF=E/L      - Macro format for re-entrant programs         *\n*                                                                     *\n*       5. LIST=YES/NO - Option to generate macro expansion or not.   *\n*                        Default is 'No'.                             *\n*                                                                     *\n*       6. HELP=YES/NO - Option to print these help details. Default  *\n*                        is 'No.'                                     *\n*                                                                     *\n* NOTES:                                                              *\n* -----                                                               *\n* 1. This macro (PUTLINE command) can only be issued from within a    *\n*    command processor and will cause an abend if issued from a       *\n*    called program as no CPPL is established..                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n&NAME    DS    0H\n         GBLC  &PUTL\n         GBLB  &PLL1ST,&PLL1PR,&PLL1DA\n         LCLB  &#PLSVR1\n         LCLC  &PLINIT,&PLLMOV,&PLMDLPB,&PLLEP,&PLECB,&PLSAVR1\n         LCLC  &PLIOPL,&PLPTPB,&PLLEN1,&PLMESS,&#PLSRCE,&#PLCPPL\n         LCLC  &PLLOAD,&PLLOADX,&PLVARB,&PLINVL,&PLCOMM,&PLLNOK\n         LCLC  &PLPSET,&PLUNIQ@\n.*--------------------------------------------------------------------*\n         GBLC  &REGSAVR,&REGSMCR\n         GBLB  &REGSFLG,&REGDFLG\n         AIF   (&REGSFLG).A$RS\n&REGSAVR SETC  'GB'.'&SYSNDX'.'#'\n&REGSMCR SETC  'PTL'\n&REGSFLG SETB  1\n.A$RS    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (&PLL1ST).A$$00\n&PUTL    SETC  'PL'.'&SYSNDX'\n&PLL1ST  SETB  1\n.*--------------------------------------------------------------------*\n.A$$00    ANOP\n&PLSAVR1 SETC   '&PUTL'.'00'\n&PLMDLPB SETC   '&PUTL'.'01'\n&PLLMOV  SETC   '&PUTL'.'02'\n&PLLEP   SETC   '&PUTL'.'03'\n&PLECB   SETC   '&PUTL'.'04'\n&PLIOPL  SETC   '&PUTL'.'05'\n&PLPTPB  SETC   '&PUTL'.'06'\n&PLLEN1  SETC   '&PUTL'.'07'\n&PLMESS  SETC   '&PUTL'.'08'\n&PLINIT  SETC   '&PUTL'.'09'\n&PLLOAD  SETC   '&PUTL'.'10'\n&PLLOADX SETC   '&PUTL'.'11'\n&PLCOMM  SETC   '&PUTL'.'12'\n&PLINVL  SETC   '&PUTL'.'13'\n&PLLNOK  SETC   '&PUTL'.'14'\n&PLPSET  SETC   '&PUTL'.'15'\n&PLVARB  SETC   '&PUTL'.'16'\n         AIF   ('&LTYPE'(1,1) EQ 'I').LIBM1 PROCESS IBM LIST FORMAT\n         AIF   ('&LTYPE'(1,1) EQ 'V').LVAR1 PROCESS VAR LIST FORMAT\n         AIF   ('&LTYPE'(1,1) EQ 'C').LCON1 PROCESS CON LIST FORMAT\n.*\n         AIF   (T'&MF EQ 'O').EXEC1    PROCESS LIST FORMAT\n         AIF   ('&MF' EQ 'E').EXEC2    PROCESS EXEC FORMAT\n.*\n.*--- LTYPE=CON,MF=L OR STANDARD FORMAT ------------------------------*\n.*\n         AIF   ('&MF' EQ 'L').LCON1    BYPASS FOR LIST FORMAT\n.EXEC1   ANOP\n.*--------------------------------------------------------------------*\n         AIF   (&PLL1PR).A$$80         BYPASS IF PROCESS ALREADY SET\n.*--------------------------------------------------------------------*\n         B     &PLINIT                 BYPASS INSTREAM DATA\n.LCON1   ANOP\n         AIF   (&PLL1DA).A$$15         BYPASS IF DATA FLAG ALREADY SET\n&PLL1DA  SETB  1\n*---------------------------------------------------------------------*\n*  PUTL - Constants                                                   *\n*---------------------------------------------------------------------*\n&PLMDLPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          +\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n&PLLMOV  MVC   &PLMESS.(0),2(R1)       MOVE DATA TO MESSAGE AREA\n*\n         AIF   (T'&MF EQ 'O').LVAR1    CONT IF MF= NOT SPECIFIED\n         AIF   ('&MF' EQ 'E').EXIT     EXIT IF TYPE=CON REQUESTED\n         AIF   ('&LTYPE'(1,1) EQ 'C').EXIT EXIT IF CONSTANT LIST FORM\n.*\n.*--- LTYPE=VAR,MF=L OR STANDARD FORMAT ------------------------------*\n.*\n.LVAR1   ANOP\n*---------------------------------------------------------------------*\n*  PUTL - Variables                                                   *\n*---------------------------------------------------------------------*\n&PLLEP   DC    F'0'                    PUTLINE ROUTINE ENTRY ADDRESS\n&PLECB   DC    F'0'                    ECB ADDRESS\n&PLIOPL  DC    4F'0'                   IOPL MAPPING\n&PLPTPB  DC    3F'0'                   PARAMETER BLOCK @\n&PLLEN1  DC    2H'0'                   MESSAGE LENGTH + 4\n&PLMESS  DC    CL79' '                 GENERAL MESSAGE LINE\n         AIF   (&REGDFLG).A$RD\n&REGDFLG SETB  1\n&REGSAVR DS    16F                     REGISTER SAVE AREA\n.A$RD    ANOP\n*\n.A$$15   ANOP\n         AIF   (T'&MF EQ 'O').EXEC2    PROCESS EXEC IF MF= OMMITTED\n         AIF   ('&MF' EQ 'L').EXIT     EXIT IF MF=L\n.*\n.*--- MF=E OR STANDARD FORMAT ----------------------------------------*\n.*\n.EXEC2   ANOP\n         AIF   (&PLL1PR).A$$80         BYPASS IF PROCESS ALREADY SET\n&PLL1PR  SETB  1                       SET PROCESS S FLAG\n*---------------------------------------------------------------------*\n&PLINIT DS     0H\n         ST    R14,&REGSAVR.+4         SAVE RETURN ADDRESS\n.*--------------------------------------------------------------------*\n.* TEST IF ON FIRST INVOCATION, SOURCE IS POINTED TO BY R1.           *\n.* BYPASS IF NOT, ELSE SAVE AND RESTORE AFTER INITIALISATION          *\n.*--------------------------------------------------------------------*\n         AIF   (T'&SOURCE EQ 'O').A$$49 BYPASS IF NO MESSAGE SOURCE\n         AIF   ('&SOURCE'(1,1) NE '(').A$$49 BYPASS IF NOT REG FORMAT\n&PLSAVR1 SETC  '&SYSLIST(1,1)'         SET TO 1ST PARAMETER\n         AIF   ('&PLSAVR1' EQ 'R01').A$$41 PROCESS IF R1\n         AIF   ('&PLSAVR1' EQ 'R1').A$$41  PROCESS IF R1\n         AIF   ('&PLSAVR1' EQ '01').A$$41  PROCESS IF R1\n         AIF   ('&PLSAVR1' EQ '1').A$$41   PROCESS IF R1\n         AGO   .A$$49                  BYPASS IF NOT R1\n.A$$41   ANOP\n&#PLSVR1 SETB  1\n         ST    R1,&REGSAVR             SAVE R1 AS R1 WILL BE USED\n.A$$49   ANOP\n.*--------------------------------------------------------------------*\n         AIF   (T'&CPPL EQ 'O').CPPLDEF PROCESS CPPL POINTER AS R1\n         AIF   ('&CPPL'(1,1) EQ '(').A$$50 PROCESS REGISTER TYPE\n         L     R14,&CPPL               LOAD CPPL ADDR\n         AGO   .CPPLSET\n.A$$50   ANOP\n         LR    R14,&CPPL(1)            LOAD CPPL ADDR\n         AGO   .CPPLSET\n.CPPLDEF ANOP\n         LR    R14,R1                  LOAD CPPL ADDR\n.CPPLSET ANOP\n         USING CPPL,R14                ADDRESABILITY TO CPPL\n*---------------------------------------------------------------------*\n*  Set up 'IOPL' for PUTLINE 1st time through                         *\n*---------------------------------------------------------------------*\n         LA    R15,&PLIOPL             LOAD ADDRESS TO IOPL\n         USING IOPL,R15                ESTABLISH ADDRESABILITY\n         MVC   IOPLUPT(4),CPPLUPT      MOVE ADDRESS OF UPT TO IOPL\n         MVC   IOPLECT(4),CPPLECT      MOVE ADDRESS OF ECT TO IOPL\n         LA    R0,&PLECB               LOAD ADDRESS OF MY ECB\n         ST    R0,IOPLECB              STORE ADDRESS IN IOPL\n         XC    &PLECB,&PLECB           CLEAR ECB ADDRESS\n         LA    R0,&PLPTPB              LOAD @ OF PUTLINE PARM BLOCK\n         ST    R0,IOPLIOPB             STORE IT IN IOPL\n         DROP  R14                     BREAK ADDRESABILITY\n         DROP  R15                     LELINQUISH ADDRESABILITY\n         L     R15,16                  CVT ADDRESS\n         L     R15,0(R15)              POINT TO CVT\n         TM    444(R15),X'80'          Q. IS PUTLINE LOADED? (MVS)\n         BNO   &PLLOAD                    N. BRANCH TO LOAD\n         L     R15,444(,R15)           USE CVTPTL\n         B     &PLLOADX                BRANCH AROUND LOAD\n&PLLOAD  DS    0H\n         LA    R0,=CL8'IKJPUTL'        LOAD PROGRAM NAME\n         LOAD  EPLOC=(0)               LOAD PROGRAM\n         LR    R15,R0                  GET ENTRY ADDRESS\n         LA    R15,0(,R15)             CLEAR HI BYTE FOR DELETE ROUTINE\n&PLLOADX DS    0H\n         ST    R15,&PLLEP              SAVE PUTLINE ENTRY ADDRESS\n         AIF   (&#PLSVR1 NE 1).A$$60 BYPASS IF FLAG NOT SET\n         L     R1,&REGSAVR             RESTORE R1\n.A$$60   ANOP\n         L     R14,&REGSAVR.+4         LOAD RETURN ADDRESS\n         B     &PLVARB                 BYPASS COMMON CODE\n*---------------------------------------------------------------------*\n*  PUTL - End 'IOPL' setup                                            *\n*---------------------------------------------------------------------*\n*  PUTL - Common processing section                                   *\n*---------------------------------------------------------------------*\n&PLCOMM  DS    0H\n         ST    R14,&REGSAVR.+8         SAVE RETURN ADDRESS\n         LTR   R1,R1                   Q. DETAILS ALREADY SET\n         BZ    &PLPSET                    Y. BYPASS PROCESSING\n         LH    R14,0(R1)               LOAD PARAMETER LENGTH\n         CH    R14,=H'1'               Q. PARAMETER LENGTH > 0\n         BL    &PLINVL                    N. SET DEFAULT\n         CH    R14,=H'79'              Q. PARAMETER LENGTH > 79\n         BNH   &PLLNOK                    N. PROCESS LENGTH\n&PLINVL  DS    0H\n*        LENGTH > 79 CHARACTERS. HAS BEEN SET TO 79\n         LA    R14,79                  LOAD DEFAULT LENGTH\n&PLLNOK DS     0H\n         BCTR  R14,0                   -1 FOR 'EX' MOVE\n         EX    R14,&PLLMOV             EXECUTE MOVE DATA\n         LA    R14,1(R14)              RESTORE ACTUAL LENGTH\n*---------------------------------------------------------------------*\n*  PUTLINE routine                                                    *\n*---------------------------------------------------------------------*\n         LA    R14,4(,R14)             ADD 4\n         STH   R14,&PLLEN1             STORE LENGTH\n&PLPSET  DS    0H\n         XC    &PLLEN1.+2(2),&PLLEN1+2 INITIALISE 2ND HALF OF LENGTH\n         MVC   &PLPTPB.(12),&PLMDLPB   MOVE IN MODEL FROM CONSTANT\n         L     R15,&PLLEP              LOAD PUTLINE ENTRY ADDRESS\n         PUTLINE PARM=&PLPTPB,OUTPUT=(&PLLEN1,DATA),MF=(E,&PLIOPL),    +\n               ENTRY=(15)\n         L     R14,&REGSAVR.+8         LOAD RETURN ADDRESS\n         BR    R14                     RETURN TO CALLER\n*---------------------------------------------------------------------*\n*\n&PLVARB  DS    0H\n         AIF   (T'&SOURCE EQ 'O').EXIT EXIT IF INIT INVOKE W/O SOURCE\n.A$$80   ANOP\n         AIF   (T'&SOURCE EQ 'O').ERR0 ERROR IF SOURCE OMITTED\n         AIF   ('&SOURCE'(1,1) NE '''').A$$95 BYPASS IF NOT QUOTED\n.*--------------------------------------------------------------------*\n.* Establish length of the literal passed, eliminating duplicate      *\n.* quotes and ampersands.                                             *\n.*--------------------------------------------------------------------*\n         LCLC  &CHAR,&AMPER\n         LCLA  &LC,&QC,&AC\n&AMPER   SETC  '&&'\n&LC      SETA  K'&SOURCE                    LOOP COUNTER\n&QC      SETA  0                            QUOTES COUNTER\n&AC      SETA  0                            AMPERSAND COUNTER\n&CP      SETA  0                            CHARACTER POINTER\n.LOOP1   ANOP\n&CP      SETA  &CP+1                        INCREMENT CHARACTER PTR\n&CHAR    SETC  '&SOURCE'(&CP,1)\n.TQUOT   ANOP\n         AIF   ('&CHAR' NE '''').TAMPR\n&QC      SETA  &QC+1\n         AGO   .NXTCH\n.TAMPR   ANOP\n         AIF   ('&CHAR.&CHAR' NE '&AMPER').NXTCH\n&AC      SETA  &AC+1\n.NXTCH   ANOP\n         AIF   (&CP LT &LC).LOOP1           LOOP TILL END\n&LC      SETA  &LC-2-(((&QC-2)/2)+(&AC/2))\n.*--------------------------------------------------------------------*\n.A$$91   ANOP\n         AIF   (&LC LE 79).A$$92       CONTINE IF LENGTH \u00ac> 79\n&LC      SETA  79                      SET TEXT LENGTH\n*        LENGTH > 79 CHARACTERS. HAS BEEN SET TO 79\n.A$$92   ANOP\n         MVC   &PLMESS.(&LC),=C&SOURCE MOVE DATA TO MESSAGE AREA\n         LA    R1,&LC+4                LOAD LENGTH OF TEXT + 4\n         STH   R1,&PLLEN1              STORE LENGTH\n         XR    R1,R1                   CLEAR PARMLIST POINTER\n         AGO   .A$$99\n.A$$95   ANOP\n         AIF   ('&SOURCE'(1,1) EQ '(').A$$96 PROCESS REGISTER TYPE\n&#PLSRCE SETC  '&SOURCE'\n         AGO   .A$$98\n.A$$96   ANOP\n&#PLSRCE SETC  '0(&SOURCE(1))'\n.A$$98   ANOP\n         LA    R1,&#PLSRCE             LOAD PARMLIST POINTER\n.A$$99   ANOP\n         BAL   R14,&PLCOMM             CALL COMMON ROUTINE\n.*       L     R14,&REGSAVR            LOAD RETURN ADDRESS\n*\n         AGO   .EXIT\n.*\n.*--- LTYPE=IBM,MF=L -------------------------------------------------*\n.*\n.LIBM1   ANOP\n*---------------------------------------------------------------------*\n*  PUTL - IBM supplied DSECTS                                         *\n*---------------------------------------------------------------------*\n         IKJCPPL COMMAND               PROCESSOR PARAMETER LIST\n         IKJIOPL                       I/O SERVICE ROUTINE PARM LIST\n*---------------------------------------------------------------------*\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.*       ERROR MESSAGES                                               *\n.*--------------------------------------------------------------------*\n.ERR0    MNOTE 8,'Missing parameter address'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.EXIT    ANOP\n         POP   PRINT\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PUTLNOTE": {"ttr": 3332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01H\\x00\\x05\\x00\\x93#\\x8f\\x00\\x94'\\x0f\\x10\\x19\\x00V\\x00c\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@\"", "ispf": {"version": "01.72", "flags": 0, "createdate": "1993-08-26T00:00:00", "modifydate": "1994-09-27T10:19:05", "lines": 86, "newlines": 99, "modlines": 0, "user": "ZTSALK"}, "text": "     *---------------------------------------------------------------------*\n     *                                                                     *\n     * PUTL                                                                *\n     * ----                                                                *\n     * The macro will establish all the required linkages, parameter lists *\n     * etc... and issue a PUTLINE macro.                                   *\n     * This is preferable to issuing a TPUT macro as a PUTLINE macro can   *\n     * be intercepted using SYSOUTTRAP for CLISTs and OUTTRAP for REXX.    *\n     *                                                                     *\n     *   Format (with defaults):                                           *\n     *      PUTL source,TL=,MF=,LTYPE=STD,CPPL=,LIST=NO,HELP=NO            *\n     *                                                                     *\n     *      Minimun requirement for standard format:                       *\n     *        Processing section -                                         *\n     *            PUTL source                                              *\n     *        DSECTS -                                                     *\n     *            PUTL MF=L,LTYPE=IBM                                      *\n     *                                                                     *\n     *   Parameters:-                                                      *\n     *       1. SOURCE      - Parameter pointer. This may be a quoted text *\n     *                        literal or a RX-type address or register.    *\n     *                                                                     *\n     *                        If it is text, it cannot be longer than 79   *\n     *                        bytes. If there are imbedded quotes or       *\n     *                        ampersands, the TL= parameter must be passed *\n     *                        as the macro cannot establish actual length. *\n     *                                                                     *\n     *                        If it is a RX-type address or regoster, it   *\n     *                        must point to storage where the first half   *\n     *                        word is the length of the message following. *\n     *                        The length must be in the range of 1-79      *\n     *                        bytes. If the length is invalid, it will be  *\n     *                        set to 79.  The length must be followed by   *\n     *                        the message text.                            *\n     *                                                                     *\n     *                        This parameter may be ommitted on first      *\n     *                        invocation and will be used just to generate *\n     *                        the common code.                             *\n     *                                                                     *\n     *       2. TL=         - Text length. Specify the actual length of the*\n     *                        source if it is a text literal containing    *\n     *                        imbedded quotes and/or ampersands as these   *\n     *                        characters must be doubled up in a text and  *\n     *                        this macro cannot identify their presence to *\n     *                        evaliate length. (Limit 79 bytes).           *\n     *                                                                     *\n     *       3. LTYPE=      - LIST type of macro.                          *\n     *                        The following are permitted values:          *\n     *                          STD - Default for standard form of the     *\n     *                                 macro.                              *\n     *                          CON - Constant value (for re-entrant progs *\n     *                                in data area).                       *\n     *                          VAR - Variable value (for re-entrant progs *\n     *                                in DSECT area).                      *\n     *                          IBM - IBM macros required. Without this    *\n     *                                format of the macro, you must code   *\n     *                                the following IBM DSECTS             *\n     *                                      IKJCPPL                        *\n     *                                      IKJIOPL                        *\n     *                                                                     *\n     *                        For MF=L without this parameter and standard *\n     *                        format, both CON and IBM formats will be     *\n     *                        included. However, LTYPE=IBM must still be   *\n     *                        coded.                                       *\n     *                                                                     *\n     *       4. CPPL=       - CPPL address. Must be provided if you do not *\n     *                        invoke PUTL on entry and R1 no longer points *\n     *                        to the CPPL (eg. R1 is used as 'SOURCE'      *\n     *                        pointer). May be a RX-type address or        *\n     *                        register.                                    *\n     *                                                                     *\n     *       5. MF=E/L      - Macro format for re-entrant programs         *\n     *                                                                     *\n     *       6. LIST=YES/NO - Option to generate macro expansion or not.   *\n     *                        Default is 'No'.                             *\n     *                                                                     *\n     *       7. HELP=YES/NO - Option to print these help details. Default  *\n     *                        is 'No.'                                     *\n     *                                                                     *\n     * NOTES:                                                              *\n     * -----                                                               *\n     * 1. This macro (PUTLINE command) can only be issued from within a    *\n     *    command processor and will cause an abend if issued from a       *\n     *    called program as no CPPL is established..                       *\n     *                                                                     *\n     *---------------------------------------------------------------------*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RACKOFF": {"ttr": 3334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01(\\x00A\\x00\\x88)?\\x00\\x935\\x0f\\x16'\\x00Z\\x00\\x0e\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@\"", "ispf": {"version": "01.40", "flags": 0, "createdate": "1988-10-19T00:00:00", "modifydate": "1993-12-16T16:27:41", "lines": 90, "newlines": 14, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO                                                          RAC00010\n&NAME    RACKOFF &RC=0,&LIST=NO,&R1=,&HELP=NO                           RAC00020\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'RACKOFF' parameter     *\n* and it's use, pass parameter 'HELP=Yes'.                            *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n* Parameters:                                                         *\n*                                                                     *\n*        RC=n       - Numeric return code (default = 0)               *\n*                             - or -                                  *\n*                     RC=(R15) if R15 contains the return code        *\n*        LIST=Y/N   - Generate code from macro expansion (def = NO)   *\n*        HELP=Y/N   - Display this help box (def = Yes)               *\n*        R1=PASS    - 'PASS' infers that R1 contains return parameter *\n*                     value to the caller and is to remain as is. Any *\n*                     other value will include R1 in the register     *\n*                     restoration command 'LM  R14,R12,....'          *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   (T'&NAME EQ 'O').NONAME\n&NAME    DS    0H                                                       RAC00020\n.NONAME  ANOP\n         GBLC  &R,&GETMADR,&GETMADL,&SAVREGS\n&KO1STR  SETB 0                             TURN 1ST TIME THRU OFF\n         AIF   (T'&GETMADL EQ 'O').A$10     NON-R BYPASS\n         AIF   (T'&R1 EQ 'O').A$00          DO NOT PASS R1\n         AIF   ('&R1' NE 'PASS').A$00       IF R1\u00ac=PASS DO NOT PASS R1\n         LR    &R.3,&R.1                    SAVE REGISTER 1 IN CASE\n.A$00    ANOP\n         LR    &R.1,&R.13                   LOAD GETMAINED AREA ADDRESS\n         LR    &R.2,&R.15                   SAVE REGISTER 15 IN CASE\n.A$10    ANOP\n         L     &R.13,4(&R.13)               LOAD CALLERS SAVEAREA @     RAC00040\n         AIF   (T'&GETMADL EQ 'O').A$20     NON-R BYPASS\n*        FREEMAIN R,LV=&GETMADL,A=(1)\n         FREEMAIN R,LV=&GETMADL,A=(1)\n.A$20    ANOP\n         AIF   (T'&R1 EQ 'O').A$21          DO NOT PASS R1\n         AIF   ('&R1' NE 'PASS').A$21       IF R1\u00ac=PASS DO NOT PASS R1\n         LR    &R.1,&R.3                    RESTORE R1\n.A$21    ANOP\n         AIF   ('&RC' EQ '(R15)').SPEC      R15 CONTAINS RC             RAC00050\n         AIF   ('&RC' EQ '(15)').SPEC R15 CONTAINS RC                   RAC00060\n         AIF   (T'&R1 EQ 'O').A$22          DO NOT PASS R1\n         AIF   ('&R1' NE 'PASS').A$22       IF R1\u00ac=PASS DO NOT PASS R1\n         LM    &R.14,&R.0,12(&R.13)         RESTORE REGISTERS 14-0      RAC00070\n*                                           LEAVE R1 AS IS\n         LM    &R.2,&R.12,28(&R.13)         RESTORE REGISTERS 2-12      RAC00070\n         AGO   .A$23                                                    RAC00090\n.A$22    ANOP\n         LM    &R.14,&R.12,12(&R.13)        RESTORE REGISTERS 14-12     RAC00070\n.A$23    ANOP\n         LA    &R.15,&RC                    SET RETURN CODE             RAC00080\n         AGO   .RET1                                                    RAC00090\n.SPEC    ANOP                                                           RAC00100\n         AIF   (T'&GETMADL EQ 'O').A$30     NON-R BYPASS\n         LR    &R.15,&R.2                   RESTORE R15 FROM ABOVE SAVE RAC00100\n.A$30    ANOP\n         L     &R.14,12(&R.13)              RESTORE R14                 RAC00100\n         AIF   (T'&R1 EQ 'O').A$32          DO NOT PASS R1\n         AIF   ('&R1' NE 'PASS').A$32       IF R1\u00ac=PASS DO NOT PASS R1\n         L     &R.0,20(&R.13)               RESTORE REGISTER 0          RAC00110\n*                                           LEAVE R1 AS IS\n         LM    &R.2,&R.12,28(&R.13)         RESTORE REGISTERS 2-12      RAC00110\n         AGO   .RET1                                                    RAC00090\n.A$32    ANOP\n         LM    &R.0,&R.12,20(&R.13)         RESTORE REGISTERS 0-12      RAC00110\n.RET1    ANOP                                                           RAC00120\n.*--------------------------------------------------------------------*\n.* The next line does horrible things with 31 bit addressing.         *\n.*       MVI   12(&R.13),X'FF'              SET TRACE BITS ON           RAC00120\n.*--------------------------------------------------------------------*\n         BR    &R.14                        RETURN                      RAC00130\n         POP   PRINT\n*---------------------------------------------------------------------*\n         MEXIT\n.*--------------------------------------------------------------------*\n.E1      POP   PRINT\n         MNOTE 8,'MACRO KICKOFF MUST BE USED WITH THIS MACRO.'\n         MEXIT\n.*--------------------------------------------------------------------*\n         MEND                                                           KIC00710\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RADC": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01J\\x00\\x02\\x00\\x87 \\x1f\\x00\\x925\\x7f\\x16H\\x01\\x10\\x00\\xb3\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.74", "flags": 0, "createdate": "1987-07-20T00:00:00", "modifydate": "1992-12-22T16:48:02", "lines": 272, "newlines": 179, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    RADC  &SROW,&SCOL,&FA,&SCOLOR,&HILITE,&EROW,&ECOL,&RC,&CONT,  +\n               &HELP=NO,&LIST=YES,&DEF=YES\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n.*--------------------------------------------------------------------*\n         GBLB  &RADC1ST\n         AIF   (&RADC1ST).A$HELPE      IF NOT 1ST. TIME THRU\n&RADC1ST SETB  1\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'RADC' parameter and    *\n* it's use, pass parameter 'HELP=Yes'.                                *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*   Repeat to Address ==> Define Constant (RADC)                      *\n*                                                                     *\n*   Parameters: (for more details refer to \"SBADC\" macro)             *\n*       1. Starting row                                               *\n*       2. Starting col                                               *\n*       3. Field attribute (prot(P/U).intens(H/L).MDT(Y/N)            *\n*       4. Color  ('M' = monochrome, 'C' = color)                     *\n*       5. Hilite (default 'O' = \"off\")                               *\n*       6. End row                                                    *\n*       7. End col                                                    *\n*       8. Fill character                                             *\n*       9. Continuation identifier from a prev SBA. ie.               *\n*          CONTINUE FROM WHERE IT LEFT OFF (FOR BUFFISPF)             *\n*      10. DEF=...    - Use default parameters indicator. Valid values*\n*                       are YES/NO with YES as the default.           *\n*                       If this parameter is set to NO, default       *\n*                       settings are omitted.                         *\n*                       You may need to issue a stand alone CADC      *\n*                       macro to restore default attributes if you    *\n*                       find they are behaving strangely after using  *\n*                       DEF=NO and not passing parameter #3.          *\n*      11. HELP=...   - Display this help description. Valid values   *\n*                       are YES/NO with NO as the default.            *\n*      12. LIST=...   - List macro expansion. Valid values are YES/NO *\n*                       with YES as the default.                      *\n*                                                                     *\n*   Formulae:  ((R-1)*80+(C-1))/64   qoutient  => row disp in table   *\n*                                    remainder => col disp in table   *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         LCLC  &C1,&C2,&C3,&C4,&TABLE,&CSROW,&CSCOL,&CFAB\n         LCLC  &CSCOLOR,&CHILITE,&CEROW,&CECOL,&CRC\n         LCLA  &ASROW,&ASCOL,&AEROW,&AECOL,&RCL\n         LCLA  &AREM,&A1,&A2,&DISP,&LEN,&CSFE\n         GBLC  &COL#MON                           COLOR INDICATOR\n         AIF   (T'&COL#MON  NE 'O').A$COLD        BYPASS IF COLOR DEFD\n&COL#MON SETC  'COLOR'                            DEFAULT COLOR\n.A$COLD  ANOP\n         AIF   (T'&SROW EQ 'O').E21              START ROW NOT ENTERED\n         AIF   (T'&SCOL EQ 'O').E31              START COL NOT ENTERED\n         AIF   (T'&EROW EQ 'O').E22              END   ROW NOT ENTERED\n         AIF   (T'&ECOL EQ 'O').E32              END   COL NOT ENTERED\n         AIF   (T'&RC EQ 'O').RSPACE             REPEAT CHAR OMITTED\n&RCL     SETA  K'&RC\n&AMPER   SETC  '&&'\n         AIF   ('&RC'(2,2) EQ '&AMPER').RAMPER\n         AIF   ('&RC'(2,1) EQ '''').RQUOTE\n         AIF   (&RCL NE 3).E1\n&CRC     SETC  '&RC'(2,1)\n         AGO   .RANOK\n.RSPACE  ANOP\n&CRC     SETC  ' '                               SET TO SPACE\n         AGO   .RANOK\n.RAMPER  ANOP\n&CRC     SETC  '&&'                              SET TO AMPERSAND\n         AGO   .RANOK\n.RQUOTE  ANOP\n&CRC     SETC  ''''''                            SET TO QUOTE\n         AGO   .RANOK\n.RANOK   ANOP\n&CSFE    SETA  1\n         AIF   (T'&FA EQ 'O').FADEF               FA OMITTED PLN DEF'T\n&LEN     SETA  K'&FA                              FA LENGTH\n         AIF   (&LEN NE 3).E6                     NOT 3 FA\n         AIF   ('&FA' EQ 'UHY').FAUHY\n         AIF   ('&FA' EQ 'UHN').FAUHN\n         AIF   ('&FA' EQ 'ULY').FAULY\n         AIF   ('&FA' EQ 'ULN').FAULN\n         AIF   ('&FA' EQ 'PHY').FAPHY\n         AIF   ('&FA' EQ 'PHN').FAPHN\n         AIF   ('&FA' EQ 'PLY').FAPLY\n         AIF   ('&FA' EQ 'PLN').FAPLN\n         AGO   .E7\n.FADEF   ANOP\n         AIF   (T'&DEF EQ 'O').DEFCOL\n         AIF   ('&DEF'(1,1) EQ 'N').DEFCOL\n&CFAB    SETC  '60'\n         AGO   .DEFCOL\n.FAUHY   ANOP\n&CFAB    SETC  'C9'\n         AGO   .DEFCOL\n.FAUHN   ANOP\n&CFAB    SETC  'C8'\n         AGO   .DEFCOL\n.FAULY   ANOP\n&CFAB    SETC  'D5'\n         AGO   .DEFCOL\n.FAULN   ANOP\n&CFAB    SETC  'D4'\n         AGO   .DEFCOL\n.FAPHY   ANOP\n&CFAB    SETC  'F9'\n         AGO   .DEFCOL\n.FAPHN   ANOP\n&CFAB    SETC  'F8'\n         AGO   .DEFCOL\n.FAPLY   ANOP\n&CFAB    SETC  'F5'\n         AGO   .DEFCOL\n.FAPLN   ANOP\n&CFAB    SETC  'F4'\n.DEFCOL  ANOP\n         AIF   (T'&SCOLOR EQ 'O').DEFHILI            FA OMITTED\n&CSFE    SETA  &CSFE+1\n         AIF   ('&COL#MON'(1,1) EQ 'M').CALSDA\n         AIF   ('&SCOLOR'(1,1) EQ 'B').COLORB\n         AIF   ('&SCOLOR'(1,1) EQ 'R').COLORR\n         AIF   ('&SCOLOR'(1,1) EQ 'P').COLORP\n         AIF   ('&SCOLOR'(1,1) EQ 'G').COLORG\n         AIF   ('&SCOLOR'(1,1) EQ 'T').COLORT\n         AIF   ('&SCOLOR'(1,1) EQ 'Y').COLORY\n         AIF   ('&SCOLOR'(1,1) EQ 'W').COLORW\n         AGO   .E8\n.COLORB  ANOP\n&CSCOLOR SETC  '42F1'\n         AGO   .DEFHILI\n.COLORR  ANOP\n&CSCOLOR SETC  '42F2'\n         AGO   .DEFHILI\n.COLORP  ANOP\n&CSCOLOR SETC  '42F3'\n         AGO   .DEFHILI\n.COLORG  ANOP\n&CSCOLOR SETC  '42F4'\n         AGO   .DEFHILI\n.COLORT  ANOP\n&CSCOLOR SETC  '42F5'\n         AGO   .DEFHILI\n.COLORY  ANOP\n&CSCOLOR SETC  '42F6'\n         AGO   .DEFHILI\n.COLORW  ANOP\n&CSCOLOR SETC  '42F7'\n.DEFHILI ANOP\n         AIF   (T'&HILITE EQ 'O').CALSDA\n         AIF   ('&HILITE'(1,1) EQ 'O').CALSDA\n&CSFE    SETA  &CSFE+1\n         AIF   ('&HILITE'(1,1) EQ 'B').HILITEB\n         AIF   ('&HILITE'(1,1) EQ 'R').HILITER\n         AIF   ('&HILITE'(1,1) EQ 'U').HILITEU\n         AGO   .E9\n.HILITEB ANOP\n&CHILITE SETC  '41F1'\n         AGO   .CALSDA\n.HILITER ANOP\n&CHILITE SETC  '41F2'\n         AGO   .CALSDA\n.HILITEU ANOP\n&CHILITE SETC  '41F4'\n.CALSDA  ANOP\n&ASROW   SETA  &SROW\n&ASCOL   SETA  &SCOL\n&AEROW   SETA  &EROW\n&AECOL   SETA  &ECOL\n         AIF   (&AEROW LT 44).CONT1      IS LINE < 44 OK\n         AIF   (&AEROW GT 44).E42        CANNOT BE GREATER THAN 44\n         AIF   (&AECOL GT 1).E42         IF 25, COLUMN MUST BE 1\n.CONT1   ANOP\n         AIF   (&ASROW GT 43).E41\n         AIF   (&ASROW LT 1).E41\n         AIF   (&ASCOL GT 80).E51\n         AIF   (&ASCOL LT 1).E51\n         AIF   (&AEROW LT 1).E42\n         AIF   (&AECOL GT 80).E52\n         AIF   (&AECOL LT 1).E52\n&C1      SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'  1 TO 16 ( 1-33)\n&C2      SETC  '50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F' 17 TO 32 (34-65)\n&C3      SETC  '6061E2E3E4E5E6E7E8E96A6B6C6D6E6F' 33 TO 48 (66-97)\n&C4      SETC  'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F' 49 TO 64 (98-129)\n&TABLE   SETC  '&C1&C2&C3&C4'\n&DISP    SETA  &ASROW-1\n&DISP    SETA  &DISP*80                 DECREMENT ROW # BY 1\n&DISP    SETA  &DISP+&ASCOL-1\n&ASROW   SETA  &DISP/64\n&ASCOL   SETA  &ASROW*64\n&ASCOL   SETA  &DISP-&ASCOL\n&ASCOL   SETA  &ASCOL*2\n&ASCOL   SETA  &ASCOL+1\n&ASROW   SETA  &ASROW*2\n&ASROW   SETA  &ASROW+1\n&CSROW   SETC  '&TABLE'(&ASROW,2)\n&CSCOL   SETC  '&TABLE'(&ASCOL,2)\n&DISP    SETA  &AEROW-1\n&DISP    SETA  &DISP*80                 DECREMENT ROW # BY 1\n&DISP    SETA  &DISP+&AECOL-1\n&AEROW   SETA  &DISP/64\n&AECOL   SETA  &AEROW*64\n&AECOL   SETA  &DISP-&AECOL\n&AECOL   SETA  &AECOL*2\n&AECOL   SETA  &AECOL+1\n&AEROW   SETA  &AEROW*2\n&AEROW   SETA  &AEROW+1\n&CEROW   SETC  '&TABLE'(&AEROW,2)\n&CECOL   SETC  '&TABLE'(&AECOL,2)\n         AIF   ('&COL#MON'(1,1) EQ 'M').MONOCHR\n         AIF   (T'&CONT EQ 'O').PRADC1C\n** \"RADC\" ENTRY OMMITTED. IMMEDIATE FOLLOW-ON FROM PREVIOUS VALUE. **\n         AGO   .PRADC3M\n.PRADC1C ANOP\n         AIF   (T'&CFAB EQ 'O').PRADC2C\n&NAME    DC    X'11&CSROW&CSCOL.290&CSFE.C0&CFAB&CSCOLOR&CHILITE'\n         AGO   .PRADC3M\n.PRADC2C ANOP\n         AIF   (T'&CSCOLOR EQ 'O').DEFHIL9\n&CSCOLOR SETC  '28&CSCOLOR'\n.DEFHIL9 ANOP\n         AIF   (T'&CHILITE EQ 'O').PUTIT9\n&CHILITE SETC  '28&CHILITE'\n.PUTIT9  ANOP\n&NAME    DC    X'11&CSROW&CSCOL.&CSCOLOR.&CHILITE'\n         AGO   .PRADC3M\n.MONOCHR ANOP\n         AIF   (T'&CONT EQ 'O').PRADC1M\n** \"RADC\" ENTRY OMMITTED. IMMEDIATE FOLLOW-ON FROM PREVIOUS VALUE. **\n         AGO   .PRADC3M\n.PRADC1M ANOP\n         AIF   (T'&CFAB EQ 'O').PRADC2M\n&NAME    DC    X'11&CSROW&CSCOL.1D&CFAB'\n         AGO   .PRADC3M\n.PRADC2M ANOP\n&NAME    DC    X'11&CSROW&CSCOL'\n.PRADC3M ANOP\n         DC    X'3C&CEROW&CECOL'\n         DC    C'&CRC'\n         MEXIT\n.E1      MNOTE 12,'RADC REPEAT CHARACTER MUST BE ''1'' CHAR (QUOTED).'\n         MEXIT\n.E20     MNOTE 12,'RADC REQUIRES A REPEAT CHARACTER.'\n         MEXIT\n.E21     MNOTE 12,'RADC REQUIRES A START LINE NUMBER.'\n         MEXIT\n.E31     MNOTE 12,'RADC REQUIRES A START COLUMN NUMBER.'\n         MEXIT\n.E41     MNOTE 12,'RADC REQUIRES START LINE IN RANGE 1 TO 23.'\n         MEXIT\n.E51     MNOTE 12,'RADC REQUIRES START COLUMN RANGE 1 TO 80.'\n         MEXIT\n.E22     MNOTE 12,'RADC REQUIRES END A LINE NUMBER.'\n         MEXIT\n.E32     MNOTE 12,'RADC REQUIRES END A COLUMN NUMBER.'\n         MEXIT\n.E42     MNOTE 12,'RADC REQUIRES END LINE IN RANGE 1 TO 23.'\n         MEXIT\n.E52     MNOTE 12,'RADC REQUIRES END COLUMN RANGE 1 TO 80.'\n         MEXIT\n.E6      MNOTE 12,'FA PASSED MUST BE THREE CHARS (PROT+INTENS+MTD).'\n         MEXIT\n.E7      MNOTE 12,'INVALID 3 CHAR FA PASSED.'\n         MEXIT\n.E8      MNOTE 12,'INVALID COLOR PASSED.'\n         MEXIT\n.E9      MNOTE 12,'INVALID HILITE PASSED.'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SBA": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1d\\x00\\x07\\x00\\x87\\x19O\\x00\\x925/\\x166\\x00\\xa8\\x00H\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.29", "flags": 0, "createdate": "1987-07-13T00:00:00", "modifydate": "1992-12-17T16:36:07", "lines": 168, "newlines": 72, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    SBA   &OUT,&ROW,&COL,&MF=,&LIST=YES,&HELP=NO\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'SBA' parameter         *\n* and use pass parameter 'HELP=Yes'.                                  *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n* Macro to set the first 3 bytes of a variable to \"SBA\" and the HEX   *\n* address of row and column from the decimal row/col values.          *\n*                                                                     *\n* Returns X'11RRCC' where x'RR' x'CC' are the screen addresses.       *\n*                                                                     *\n*   Parameters:                                                       *\n*     Format (A) -                                                    *\n*       1. Destination address                                        *\n*       2. Source parameter:                                          *\n*          a. Format 1:                                               *\n*              i) col number (digits rr)                              *\n*             ii) row number (digits cc)                              *\n*          b. format 2:                                               *\n*              i) variable name where the row is contained in the     *\n*                 first half-word and the col in the second           *\n*                 (x'00rr00cc'). may use register for addressing      *\n*       3. Col number                                                 *\n*       4. MF=L/E for re-entrant programs.                            *\n*       5. LIST=..  Generate macro statements (Yes/No, YES the        *\n*                   default).                                         *\n*       6. HELP=..  Generate this help detail (Yes/No, YES the        *\n*                   default).                                         *\n*                                                                     *\n*     Format (b) - Ascertained from missing parameter # 3.            *\n*       1. Destination variable.                                      *\n*       2. Source variable with 2 contiguous halfwords containing     *\n*          row number and column number.                              *\n*       3. MF=L/E for re-entrant programs.                            *\n*       4. LIST=..  Generate macro statements (Yes/No, YES the        *\n*                   default).                                         *\n*       5. HELP=..  Generate this help detail (Yes/No, YES the        *\n*                   default).                                         *\n*                                                                     *\n* NOTE:                                                               *\n*       For re-entrant programs, MF=L, only the 'MF' parameter is     *\n*       required.                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n&NAME    DS    0H\n         GBLC  &SBANAME\n         GBLB  &SBAFST1,&SBAFST2\n         LCLC  &#OUT,&#ROW\n         LCLC  &TRDATA,&TRROW,&TRCOL,&TRBAL,&TRBYPAS\n.*--------------------------------------------------------------------*\n         GBLC  &REGSAVR,&REGSMCR\n         GBLB  &REGSFLG,&REGDFLG\n         AIF   (&REGSFLG).A$RS\n&REGSAVR SETC  'GB'.'&SYSNDX'.'#'\n&REGSMCR SETC  'SBA'\n&REGSFLG SETB  1\n.A$RS    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (&SBAFST1).A$00\n&SBANAME SETC  'SBA'.'&SYSNDX'\n&SBAFST1 SETB  1\n.*--------------------------------------------------------------------*\n.A$00    ANOP\n         AIF   ('&MF' EQ 'L').A$04\n         AIF   (T'&OUT EQ 'O').E1\n         AIF   (T'&ROW EQ 'O').E2\n         AIF   ('&OUT'(1,1) EQ '(').A$01\n&#OUT1   SETC  '&OUT'\n         AGO   .A$02\n.A$01    ANOP\n&#OUT1   SETC  '0(&OUT(1))'\n.A$02    ANOP\n         AIF   (T'&ROW EQ 'O').A$04\n         AIF   ('&ROW'(1,1) EQ '(').A$03\n&#ROW1   SETC  '&ROW'\n&#ROW2   SETC  '&ROW+2'\n         AGO   .A$04\n.A$03    ANOP\n&#ROW1   SETC  '0(&ROW(1))'\n&#ROW2   SETC  '2(&ROW(1))'\n.A$04    ANOP\n.*--------------------------------------------------------------------*\n&TRDATA  SETC  '&SBANAME'.'1'\n&TRROW   SETC  '&SBANAME'.'2'\n&TRCOL   SETC  '&SBANAME'.'3'\n&TRBAL   SETC  '&SBANAME'.'4'\n&TRBYPAS SETC  '&SBANAME'.'5'\n         AIF   ('&MF' EQ 'L').RENT2\n         AIF   (&SBAFST2).A$99\n&SBAFST2 SETB  1\n         B     &TRBYPAS\n&TRDATA  DC    X'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'  1 TO 16\n         DC    X'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F' 17 TO 32\n         DC    X'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F' 33 TO 48\n         DC    X'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F' 49 TO 64\n         AIF   ('&MF' EQ 'E').RENT3\n.*--------------------------------------------------------------------*\n.*  RE-ENTRANT FORM                                                   *\n.*--------------------------------------------------------------------*\n.RENT2   ANOP\n.*--------------------------------------------------------------------*\n.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *\n.*--------------------------------------------------------------------*\n         AIF   (&REGDFLG).A$RD\n&REGDFLG SETB  1\n&REGSAVR DS    16F                     REGISTER SAVE AREA\n.A$RD    ANOP\n.*--------------------------------------------------------------------*\n&TRROW   DS    H\n&TRCOL   DS    H\n         AIF   ('&MF' EQ 'L').MEND1\n.RENT3   ANOP\n&TRBAL   DS    0H\n         LH    R3,&TRROW                LOAD R3 WITH ROW #\n         BCTR  R3,0                     DECREMENT ROW # BY 1\n         LH    R4,&TRCOL                LOAD R4 WITH COLUMN #\n         BCTR  R4,0                     DECREMENT COLUMN # BY 1\n         MH    R3,=H'80'                MULTIPLY ROWS BY COLUMN LIMIT\n         AR    R3,R4                    RESULT IN R3\n         LH    R5,=H'64'                LOAD TABLE LENGTH\n         XR    R2,R2                    CLEAR R2\n         DR    R2,R5                    DIVIDE RELATIVE DISP BY 64\n         LA    R5,&TRDATA               START OF TABLE\n         AR    R5,R3                    R3 ROW DISPALCEMENT IN TABLE\n         LA    R6,&TRDATA\n         AR    R6,R2                    R2 COL DIPLACEMENT IN TABLE\n         BR    R14                      RETURN\n&TRBYPAS DS    0H\n.A$99    ANOP\n         STM   R14,R12,&REGSAVR         SAVE REGISTERS\n         AIF   (T'&COL EQ 'O').VART1    SUPPLIED 3RD. PARAMETER\n         MVC   &TRROW.(2),=H'&ROW'      STORE ROW POINTER\n         MVC   &TRCOL.(2),=H'&COL'      STORE COLUMN POINTER\n         AGO   .CONT1\n.VART1   ANOP                           MISSING 3RD PARM - VAR ADDR\n         MVC   &TRROW.(2),&#ROW1        STORE ROW POINTER\n         MVC   &TRCOL.(2),&#ROW2        STORE COLUMN POINTER\n.CONT1   ANOP\n         BAL   R14,&TRBAL               BRANCH AND LINK TO ROUTINE\n         MVC   &OUT.(1),0(R5)           SET ROW ADDRESS\n         MVC   &OUT.+1(1),0(R6)         SET COLUMN ADDRESS\n         LM    R14,R12,&REGSAVR         RESTORE REGISTERS\n         AGO   .MEND1\n.*--------------------------------------------------------------------*\n.E1      MNOTE 12,'SBA REQUIRES AN OUT DATASET'\n         AGO   .MEND1\n.E2      MNOTE 12,'SBA REQUIRES A LINE NUMBER'\n         AGO   .MEND1\n.E3      MNOTE 12,'SBA REQUIRES A COLUMN NUMBER'\n         AGO   .MEND1\n.E4      MNOTE 12,'SBA REQUIRES LINE IN RANGE 1 TO 24'\n         AGO   .MEND1\n.E5      MNOTE 12,'SBA REQUIRES COLUMN RANGE 1 TO 80'\n         AGO   .MEND1\n.*--------------------------------------------------------------------*\n.MEND1   ANOP\n         POP PRINT\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SBADC": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x016\\x005\\x00\\x87\\x19_\\x00\\x925\\x7f\\x16F\\x00\\xf0\\x00-\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.54", "flags": 0, "createdate": "1987-07-14T00:00:00", "modifydate": "1992-12-22T16:46:35", "lines": 240, "newlines": 45, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    SBADC &ROW,&COL,&FA,&COLOR,&HILITE,&CONT,&LIST=YES,&HELP=NO,  +\n               &DEF=YES\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n.*--------------------------------------------------------------------*\n         GBLB  &SBADC1ST\n         AIF   (&SBADC1ST).A$HELPE     IF NOT 1ST. TIME THRU\n&SBADC1ST SETB 1\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'SBADC' parameter and   *\n* it's use, pass parameter 'HELP=Yes'.                                *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n* Macro to generate the \"define constant\" (\"DC\") code for SBA and     *\n* related attribute bytes.                                            *\n* The first 3 bytes are \"SBA\" ID and the HEX address of the row and   *\n* column from the decimal row/col values. The following bytes are the *\n* extended attruibute byte (X'29') followed by the pairings.          *\n* (Generally 11 bytes are returned).                                  *\n*                                                                     *\n*   Input parameters:                                                 *\n*       1. Row number                                                 *\n*       2. Collumn                                                    *\n*       3. 3 character Attribute Character Description:               *\n*          1st. char : Protection  - U(nprotected), P(rotected)       *\n*                                    (for protected fields, autoskip  *\n*                                    is turned on.)                   *\n*          2nd. char : Intensity   - H(igh), L(ow), N(on)             *\n*          3nd. char : MDT on flag - Y(es), N(o)                      *\n*          All character positions must be supplied or none.          *\n*       4. 1st. byte of color - W(hite), P(ink), T(urquoise), R(ed),  *\n*                               B(lue), Y(ellow), G(reen)             *\n*                               M(monochrome - no extended attributes)*\n*       5. 1st. byte of hilite- U(nderscore), R(everse), B(link)      *\n*                               O(off , same as  blank)               *\n*       6. non blank text     - Indicates that literal will follow on *\n*                               immediately. No need to set new buffer*\n*                               address.                              *\n*       7. DEF=...    - Use default parameters indicator. Valid values*\n*                       are YES/NO with YES as the default.           *\n*                       If this parameter is set to NO, default       *\n*                       settings are omitted.                         *\n*                       You may need to issue a stand alone CADC      *\n*                       macro to restore default attributes if you    *\n*                       find they are behaving strangely after using  *\n*                       DEF=NO and not passing parameter #3.          *\n*       8. HELP=...   - Display this help description. Valid values   *\n*                       are YES/NO with NO as the default.            *\n*       9. LIST=...   - List macro expansion. Valid values are YES/NO *\n*                       with YES as the default.                      *\n*                                                                     *\n*   Formulae:  ((R-1)*80+(C-1))/64   quotient  => row disp in table   *\n*                                    remainder => col disp in table   *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         LCLC  &C1,&C2,&C3,&C4,&TABLE,&CROW,&CCOL,&CFAB\n         LCLC  &CCOLOR,&CHILITE\n         LCLA  &AROW,&ACOL,&AREM,&A1,&A2,&DISP,&LEN,&CSFE\n         GBLC  &COL#MON                           COLOR INDICATOR\n         AIF   (T'&COL#MON  NE 'O').A$COLD        BYPASS IF COLOR DEFD\n&COL#MON SETC  'COLOR'                            DEFAULT COLOR\n.A$COLD  ANOP\n         AIF   (T'&ROW EQ 'O').E2                 ROW NOT ENTERED\n         AIF   (T'&COL EQ 'O').E3                 COL NOT ENTERED\n&CSFE    SETA  1\n         AIF   (T'&FA EQ 'O').FADEF               FA OMITTED\n&LEN     SETA  K'&FA                              FA LENGTH\n         AIF   (&LEN NE 3).E6                     NOT 3 FA\n         AIF   ('&FA' EQ 'UHY').FAUHY\n         AIF   ('&FA' EQ 'UHN').FAUHN\n         AIF   ('&FA' EQ 'ULY').FAULY\n         AIF   ('&FA' EQ 'UNN').FAUNN\n         AIF   ('&FA' EQ 'UNY').FAUNY\n         AIF   ('&FA' EQ 'ULN').FAULN\n         AIF   ('&FA' EQ 'PHY').FAPHY\n         AIF   ('&FA' EQ 'PHN').FAPHN\n         AIF   ('&FA' EQ 'PLY').FAPLY\n         AIF   ('&FA' EQ 'PLN').FAPLN\n         AGO   .E7\n.FADEF   ANOP\n         AIF   (T'&DEF EQ 'O').DEFCOL\n         AIF   ('&DEF'(1,1) EQ 'N').DEFCOL\n&CFAB    SETC  '60'\n         AGO   .DEFCOL\n.FAUHY   ANOP\n&CFAB    SETC  'C9'\n         AGO   .DEFCOL\n.FAUHN   ANOP\n&CFAB    SETC  'C8'\n         AGO   .DEFCOL\n.FAULY   ANOP\n&CFAB    SETC  'C5'\n         AGO   .DEFCOL\n.FAULN   ANOP\n&CFAB    SETC  'C4'\n         AGO   .DEFCOL\n.FAUNY   ANOP\n&CFAB    SETC  '4D'\n         AGO   .DEFCOL\n.FAUNN   ANOP\n&CFAB    SETC  '4C'\n         AGO   .DEFCOL\n.FAPHY   ANOP\n&CFAB    SETC  'F9'\n         AGO   .DEFCOL\n.FAPHN   ANOP\n&CFAB    SETC  'F8'\n         AGO   .DEFCOL\n.FAPLY   ANOP\n&CFAB    SETC  'F5'\n         AGO   .DEFCOL\n.FAPLN   ANOP\n&CFAB    SETC  'F4'\n.DEFCOL  ANOP\n         AIF   (T'&COLOR EQ 'O').DEFHILI             FA OMITTED\n&CSFE    SETA  &CSFE+1\n         AIF   ('&COL#MON'(1,1) EQ 'M').CALSDA\n         AIF   ('&COLOR'(1,1) EQ 'B').COLORB\n         AIF   ('&COLOR'(1,1) EQ 'R').COLORR\n         AIF   ('&COLOR'(1,1) EQ 'P').COLORP\n         AIF   ('&COLOR'(1,1) EQ 'G').COLORG\n         AIF   ('&COLOR'(1,1) EQ 'T').COLORT\n         AIF   ('&COLOR'(1,1) EQ 'Y').COLORY\n         AIF   ('&COLOR'(1,1) EQ 'W').COLORW\n         AGO   .E8\n.COLORB  ANOP\n&CCOLOR  SETC  '42F1'\n         AGO   .DEFHILI\n.COLORR  ANOP\n&CCOLOR  SETC  '42F2'\n         AGO   .DEFHILI\n.COLORP  ANOP\n&CCOLOR  SETC  '42F3'\n         AGO   .DEFHILI\n.COLORG  ANOP\n&CCOLOR  SETC  '42F4'\n         AGO   .DEFHILI\n.COLORT  ANOP\n&CCOLOR  SETC  '42F5'\n         AGO   .DEFHILI\n.COLORY  ANOP\n&CCOLOR  SETC  '42F6'\n         AGO   .DEFHILI\n.COLORW  ANOP\n&CCOLOR  SETC  '42F7'\n.DEFHILI ANOP\n         AIF   (T'&HILITE EQ 'O').CALSDA\n         AIF   ('&HILITE'(1,1) EQ 'O').CALSDA\n&CSFE    SETA  &CSFE+1\n         AIF   ('&HILITE'(1,1) EQ 'B').HILITEB\n         AIF   ('&HILITE'(1,1) EQ 'R').HILITER\n         AIF   ('&HILITE'(1,1) EQ 'U').HILITEU\n         AGO   .E9\n.HILITEB ANOP\n&CHILITE SETC  '41F1'\n         AGO   .CALSDA\n.HILITER ANOP\n&CHILITE SETC  '41F2'\n         AGO   .CALSDA\n.HILITEU ANOP\n&CHILITE SETC  '41F4'\n.CALSDA  ANOP\n&AROW    SETA  &ROW\n&ACOL    SETA  &COL\n         AIF   (&AROW GT 43).E4\n         AIF   (&AROW LT 1).E4\n         AIF   (&ACOL GT 80).E5\n         AIF   (&ACOL LT 1).E5\n&C1      SETC  '40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'  1 TO 16 ( 1-33)\n&C2      SETC  '50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F' 17 TO 32 (34-65)\n&C3      SETC  '6061E2E3E4E5E6E7E8E96A6B6C6D6E6F' 33 TO 48 (66-97)\n&C4      SETC  'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F' 49 TO 64 (98-129)\n&TABLE   SETC  '&C1&C2&C3&C4'\n&DISP    SETA  &AROW-1\n&DISP    SETA  &DISP*80                 DECREMENT ROW # BY 1\n&DISP    SETA  &DISP+&ACOL-1\n&AROW    SETA  &DISP/64\n&ACOL    SETA  &AROW*64\n&ACOL    SETA  &DISP-&ACOL\n&ACOL    SETA  &ACOL*2\n&ACOL    SETA  &ACOL+1\n&AROW    SETA  &AROW*2\n&AROW    SETA  &AROW+1\n&CROW    SETC  '&TABLE'(&AROW,2)\n&CCOL    SETC  '&TABLE'(&ACOL,2)\n         AIF   ('&COL#MON'(1,1) EQ 'M').MONOCHR\n         AIF   (T'&CONT EQ 'O').PRADC1C\n** \"SBADC\" ENTRY OMITTED. IMMEDIATE FOLLOW-ON FROM PREVIOUS VALUE. **\n         AGO   .PRADC3C\n.PRADC1C ANOP\n         AIF   (T'&CFAB EQ 'O').PRADC2C\n&NAME    DC    X'11&CROW&CCOL.290&CSFE.C0&CFAB&CCOLOR&CHILITE'\n         AGO   .PRADC3C\n.PRADC2C ANOP\n         AIF   (T'&CCOLOR EQ 'O').DEFHIL9\n&CCOLOR  SETC  '28&CCOLOR'\n.DEFHIL9 ANOP\n         AIF   (T'&CHILITE EQ 'O').PUTIT9\n&CHILITE SETC  '28&CHILITE'\n.PUTIT9  ANOP\n&NAME    DC    X'11&CROW&CCOL.&CCOLOR.&CHILITE'\n.PRADC3C ANOP\n         AGO .MEXIT\n.MONOCHR ANOP\n         AIF   (T'&CONT EQ 'O').PRADC1M\n** \"SBADC\" ENTRY OMITTED. IMMEDIATE FOLLOW-ON FROM PREVIOUS VALUE. **\n         AGO   .PRADC3M\n.PRADC1M ANOP\n         AIF   (T'&CFAB EQ 'O').PRADC2M\n&NAME    DC    X'11&CROW&CCOL.1D&CFAB'\n         AGO   .PRADC3M\n.PRADC2M ANOP\n&NAME    DC    X'11&CROW&CCOL'\n.PRADC3M ANOP\n         AGO .MEXIT\n.E2      MNOTE 12,'SBA REQUIRES A LINE NUMBER.'\n         AGO .MEXIT\n.E3      MNOTE 12,'SBA REQUIRES A COLUMN NUMBER.'\n         AGO .MEXIT\n.E4      MNOTE 12,'SBA REQUIRES LINE IN RANGE 1 TO 43.'\n         AGO .MEXIT\n.E5      MNOTE 12,'SBA REQUIRES COLUMN RANGE 1 TO 80.'\n         AGO .MEXIT\n.E6      MNOTE 12,'FA PASSED MUST BE THREE CHARS (PROT+INTENS+MTD).'\n         AGO .MEXIT\n.E7      MNOTE 12,'INVALID 3 CHAR FA PASSED.'\n         AGO .MEXIT\n.E8      MNOTE 12,'INVALID COLOR PASSED.'\n         AGO .MEXIT\n.E9      MNOTE 12,'INVALID HILITE PASSED.'\n.MEXIT   ANOP\n         POP   PRINT\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCREEND": {"ttr": 3843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x87)?\\x00\\x872\\x9f\\x12H\\x00-\\x00 \\x00\\x00\\xc3\\xe2\\xc1\\xd3\\xc5\\xe7@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1987-10-20T00:00:00", "modifydate": "1987-11-25T12:48:00", "lines": 45, "newlines": 32, "modlines": 0, "user": "CSALEX"}, "text": "         MACRO\n&NAME    SCREEND &PL,&FL\n         AIF   (T'&PL EQ 'O').E2\n         LCLA  &PLL\n         GBLB  &SDFIRST\n         GBLC  &SDNAM\n&PLL     SETA  L'&PL\n         AIF   (T'&FL EQ 'O').E0\n&PLL     SETA  &FL\n.E0      GBLB  &SDFIRST\n.E1      GBLC  &SDNAM\n         AIF   (&SDFIRST).A$99\n&SDFIRST SETB  1\n&SDNAM   SETC  'SC'.'&SYSNDX'\n         B     &SDNAM.4\n&SDNAM.1 EQU   *\n         WCCDC W\n         DC    X'11D9C22902C0E442F6'\n         DC    XL5'115A501DE8'\n         DC    CL79'---------------------------------------------------X\n               ----------------------------'\n         DC    XL5'115B601DE8'\n         DC    CL1'\u00a6'\n         DC    X'115BE22903C0E842F541F2'\n&SDNAM.2 DS    CL75\n         DC    XL5'115C6E1DE8'\n         DC    CL1'\u00a6'\n         DC    XL5'115CF01DE8'\n         DC    CL79'---------------------------------------------------X\n               ----------------------------'\n&SDNAM.3 EQU   *-&SDNAM.1\n* &SDNAM.5 DS    18F\n&SDNAM.4 DS    0H\n.A$99    ANOP\n*        STM   R0,R15,&SDNAM.5\n         MVI   &SDNAM.2,X'40'\n         MVC   &SDNAM.2+1(74),&SDNAM.2\n         MVC   &SDNAM.2(&PLL),&PL\n         TPUT  &SDNAM.1,&SDNAM.3,NOEDIT,WAIT,,BREAKIN,HIGHP  <----*\n         TGET  &SDNAM.2,10,ASIS,WAIT\n*        LM    R0,R15,&SDNAM.5\n         MEXIT\n.E2      MNOTE 12,'\"SCREEND\" REQUIRES AN INPUT VARIABLE.'\n.E3      MNOTE 12,'\"SCREEND\" REQUIRES AN LENGTH VARIABLE.'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCREENL": {"ttr": 3845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87)?\\x00\\x872\\x9f\\x12R\\x00*\\x00\\x1e\\x00\\x00\\xc3\\xe2\\xc1\\xd3\\xc5\\xe7@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-10-20T00:00:00", "modifydate": "1987-11-25T12:52:00", "lines": 42, "newlines": 30, "modlines": 0, "user": "CSALEX"}, "text": "         MACRO\n&NAME    SCREENL &PL\n         AIF   (T'&PL EQ ' ').E1\n         LCLA  &PLL\n         GBLB  &SLFIRST\n         GBLC  &SLNAM\n&PLL     SETA  K'&PL-2\n         AIF   (&SLFIRST).A$99\n&SLFIRST SETB  1\n&SLNAM   SETC  'SL'.'&SYSNDX'\n         B     &SLNAM.4\n&SLNAM.1 EQU   *\n         WCCDC W\n         DC    X'11D9C22902C0E442F6'\n         DC    XL5'11D9D31DE8'\n         DC    C'\u00a6'\n         DC    XL5'115A501DE8'\n         DC    CL79'---------------------------------------------------X\n               ----------------------------'\n         DC    XL5'115B601DE8'\n         DC    CL1'\u00a6'\n         DC    X'115BE22903C0E842F541F2'\n&SLNAM.2 DS    CL75\n         DC    XL5'115C6E1DE8'\n         DC    CL1'\u00a6'\n         DC    XL5'115CF01DE8'\n         DC    CL79'---------------------------------------------------X\n               ----------------------------'\n&SLNAM.3 EQU   *-&SLNAM.1\n&SLNAM.5 DS    18F\n&SLNAM.4 DS    0H\n.A$99    ANOP\n         STM   R0,R15,&SLNAM.5\n         MVI   &SLNAM.2,X'40'\n         MVC   &SLNAM.2+1(74),&SLNAM.2\n         MVC   &SLNAM.2(&PLL),=C&PL\n         TPUT  &SLNAM.1,&SLNAM.3,NOEDIT,WAIT,,BREAKIN,HIGHP  <----*\n         TGET  &SLNAM.1,10,ASIS,WAIT\n         LM    R0,R15,&SLNAM.5\n         MEXIT\n.E1      MNOTE 12,'SCREENL RQUIRES A LITERAL STRING'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHOWREGS": {"ttr": 3847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88 \\x9f\\x00\\x88 \\x9f\\x16H\\x00*\\x00*\\x00\\x00\\xc3\\xe2\\xc1\\xd3\\xc5\\xe7@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-07-27T00:00:00", "modifydate": "1988-07-27T16:48:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "CSALEX"}, "text": "         MACRO\n&NAME    SHOWREGS &BASE\n*---------------------------------------------------------------------*\n* MACRO TO SET THE FIRST 3 BYTES OF A VARIABLE TO \"SBA\" AND THE HEX   *\n* ADDRESS OF ROW AND COLUMN FROM THE DECIMAL ROW/COL VALUES.          *\n*                                                                     *\n*   PARAMETERS:                                                       *\n*     FORMAT (A) -                                                    *\n*       1. DESTINATION ADDRESS                                        *\n*       2. ROW NUMBER                                                 *\n*       3. COL NUMBER                                                 *\n*                                                                     *\n*     FORMAT (B) - ASCERTAINED FROM MISSING PARAMETER NO 3.           *\n*       1. DESTINATION VARIABLE.                                      *\n*       2. SOURCE VARIABLE WITH 2 CONTIGUOUS HALFWORDS CONTAINING     *\n*          ROW NUMBER AND COLUMN NUMBER.                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         GBLC  &REGSAVE\n         GBLC  &BASEREG\n         GBLB  &REGSFST\n         AIF   (&REGSFST).A$99\n&REGSFST SETB  1\n         LCLC  &TNAME\n&TNAME   SETC  'SR'.'&SYSNDX'\n&REGSAVE SETC  '&TNAME'.'1'\n&BASEREG SETC  '&TNAME'.'2'\n&SRBYPAS SETC  '&TNAME'.'3'\n         B     &SRBYPAS\n&REGSAVE DS    16F\n&BASEREG DS    C\n&SRBYPAS DS    0H\n.A$99    ANOP\n         STM   R0,R15,&REGSAVE          SAVE REGISTERS\n         MVI   &BASEREG,C' '            CLEAR BASE REGISTER\n         AIF   (T'&BASE EQ 'O').SETPARM\n         LA    R0,&BASE                 LOAD BASE REG\n         ST    R0,&BASEREG              SAVE BASE REGISTER\n.SETPARM ANOP                           MISSING 3RD PARM - VAR ADDR\n         LA    R1,&REGSAVE              LOAD REGISTERSAVE\n         CALL  SHOWREGS                 CALL SHOW REGISTER ROUTINE\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SVC235": {"ttr": 3849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x003\\x00\\x94'\\x1f\\x00\\x94'/\\x15\\x04\\x005\\x004\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-09-28T00:00:00", "modifydate": "1994-09-29T15:04:33", "lines": 53, "newlines": 52, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&LABEL   SVC235 &ACTION,&LIST=Y,&HELP=NO\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'SVC235' parameter and  *\n* it's use, pass parameter 'HELP=Yes'.                                *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* SVC235                                                              *\n* -----                                                               *\n* The macro will set the registers as required to invoke SVC 235.     *\n* etc... and issue a SVC235INE macro.                                 *\n* This is preferable to issuing a TPUT macro as a SVC235INE macro can *\n* be intercepted using SYSOUTTRAP for CLISTs and OUTTRAP for REXX.    *\n*                                                                     *\n*   Format (with defaults):                                           *\n*      SVC235 action,LIST=Y,HELP=N                                    *\n*                                                                     *\n*   Parameters:-                                                      *\n*       1. ACTION      - ON, set authorisation code on.               *\n*                        OFF, Set authorisation code off (default).   *\n*                                                                     *\n*       2. LIST=YES/NO - Option to generate macro expansion or not.   *\n*                        Default is 'No'.                             *\n*                                                                     *\n*       3. HELP=YES/NO - Option to print these help details. Default  *\n*                        is 'No.'                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n&LABEL   DS    0H\n         AIF   (T'&ACTION EQ 'O').SVCOFF   TREAT AS OFF REQUEST\n         AIF   ('&ACTION' NE 'ON').SVCOFF  TREAT AS OFF REQUEST\n.SVCON   ANOP\n         LA    R0,1                    SET AUTH 'ON'\n         AGO   .REST\n.SVCOFF  ANOP\n         XR    R0,R0                   SET AUTH 'OFF'\n.REST    ANOP\n         ICM   R1,B'1111',=C'AUTH'     SET AUTH CODE\n         SVC   235                     SET AUTH USING SVC 235\n.*--------------------------------------------------------------------*\n.EXIT    ANOP\n         POP   PRINT\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SVLNK": {"ttr": 3851, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x00\\x94\\x01?\\x00\\x94\\x01?\\x17\\x07\\x00e\\x00e\\x00\\x00\\xc2\\xd3\\xc1\\xd5\\xd2@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-01-13T00:00:00", "modifydate": "1994-01-13T17:07:40", "lines": 101, "newlines": 101, "modlines": 0, "user": "BLANK"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TESTMAC": {"ttr": 3853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00!\\x00\\x932o\\x00\\x932o\\x11 \\x00!\\x00\\x13\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1993-11-22T00:00:00", "modifydate": "1993-11-22T11:20:21", "lines": 33, "newlines": 19, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    TESTMAC &START\n         GBLB  &DMPFST1\n.A$00    ANOP\n&DMPFST1 SETB  1\n         AIF   (&DMPFST1 EQ 0).A$01\nFRED00   DC    C'EQ 1'\n.A$01    ANOP\n         AIF   (&DMPFST1 EQ 1).A$10\nFRED01   DC    C'EQ 0'\n.A$10    ANOP\n&DMPFST1 SETB  0\n         AIF   (&DMPFST1 EQ 0).A$11\nFRED10   DC    C'EQ 1'\n.A$11   ANOP\n         AIF   (&DMPFST1 EQ 1).A$20\nFRED11   DC    C'EQ 0'\n.A$20    ANOP\n&DMPFST1 SETB  1\n         AIF   (&DMPFST1 EQ 0).A$21\nFRED20   DC    C'EQ 1'\n.A$21   ANOP\n         AIF   (&DMPFST1 EQ 1).A$30\nFRED21   DC    C'EQ 0'\n.A$30    ANOP\n&DMPFST1 SETB  0\n         AIF   (&DMPFST1 EQ 0).A$31\nFRED30   DC    C'EQ 1'\n.A$31   ANOP\n         AIF   (&DMPFST1 EQ 1).A$40\nFRED31   DC    C'EQ 0'\n.A$40    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TODAY": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00F\\x00\\x90\\x08o\\x00\\x925\\x7f\\x16T\\x00\\x98\\x00t\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1990-03-27T00:00:00", "modifydate": "1992-12-22T16:54:46", "lines": 152, "newlines": 116, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    TODAY &OUT,&LIST=YES,&HELP=NO\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n.*--------------------------------------------------------------------*\n         GBLB  &TODY1ST\n         AIF   (&TODY1ST).A$HELPE      IF NOT 1ST. TIME THRU\n&TODY1ST SETB  1\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'TODAY' parameter and   *\n* it's use, pass parameter 'HELP=Yes'.                                *\n.*--------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*   Returns todays date                                               *\n*                                                                     *\n*   Parameters:                                                       *\n*       1. Destination fiels. Will output date in format DD/MM/YY so  *\n*          ensure dest is at least 8 bytes long.                      *\n*       2. LIST=    - List the macro expansion. Default is NO.        *\n*       3. HELP=    - Provide this help listing. Default is NO.       *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         AIF   (T'&OUT EQ 'O').E1\n.E0      GBLC  &TDBAL\n.*--------------------------------------------------------------------*\n         GBLC  &REGSAVR,&REGSMCR\n         GBLB  &REGSFLG,&REGDFLG\n         AIF   (&REGSFLG).A$RS\n&REGSAVR SETC  'GB'.'&SYSNDX'.'#'\n&REGSMCR SETC  'TODAY'\n&REGSFLG SETB  1\n.A$RS    ANOP\n.*--------------------------------------------------------------------*\n         GBLB  &TDFIRST\n         AIF   (&TDFIRST).A$99\n&TDFIRST SETB  1\n         LCLC  &TNAME\n&TNAME   SETC  'XC'.'&SYSNDX'\n&TDBAL   SETC  '&TNAME'.'1'\n&TDBYPAS SETC  '&TNAME'.'2'\n&TDLOOP1 SETC  '&TNAME'.'3'\n&TDLAB1  SETC  '&TNAME'.'4'\n&TDXLOP1 SETC  '&TNAME'.'5'\n&TDWORK  SETC  '&TNAME'.'A'\n&TDDAY   SETC  '&TNAME'.'B'\n&TDDAYR  SETC  '&TNAME'.'C'\n&TDIDATE SETC  '&TNAME'.'D'\n&TDRM    SETC  '&TNAME'.'E'\n&TDYEAR  SETC  '&TNAME'.'F'\n&TDYEARR SETC  '&TNAME'.'G'\n&TDMMM   SETC  '&TNAME'.'H'\n&TDMM    SETC  '&TNAME'.'I'\n&TDDDD   SETC  '&TNAME'.'J'\n&TDD     SETC  '&TNAME'.'K'\n&TDYY    SETC  '&TNAME'.'L'\n&TDDATE1 SETC  '&TNAME'.'M'\n&TDTABLE SETC  '&TNAME'.'N'\n         B     &TDBYPAS\n.*--------------------------------------------------------------------*\n.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *\n.*--------------------------------------------------------------------*\n         AIF   (&REGDFLG).A$RD\n&REGDFLG SETB  1\n&REGSAVR DS    16F                     REGISTER SAVE AREA\n.A$RD    ANOP\n.*--------------------------------------------------------------------*\n&TDWORK  DS    PL8\n&TDDAY   DC    PL2'0'\n&TDDAYR  DC    PL2'0'\n&TDIDATE DC    CL5' '\n&TDRM    DC    CL1' '\n&TDYEAR  DS    0CL3\n         DS    CL2\n&TDYEARR DS    CL1\n&TDMMM   DS    0CL3\n         DS    CL1\n&TDMM    DS    CL2\n&TDDDD   DS    0CL3\n         DS    CL1\n&TDD     DS    CL2\n&TDYY    DS    CL2\n&TDDATE1 DS    0CL8\n         DS    CL2\n         DC    CL1'/'\n         DS    CL2\n         DC    CL1'/'\n         DS    CL2\n&TDTABLE DS    0CL24              DAYS OF MONTH IN YEAR TABLE\n         DC    P'31'              J\n         DC    P'28'              F\n         DC    P'31'              M\n         DC    P'30'              A\n         DC    P'31'              M\n         DC    P'30'              J\n         DC    P'31'              J\n         DC    P'31'              A\n         DC    P'30'              S\n         DC    P'31'              O\n         DC    P'30'              N\n         DC    P'31'              D\n*---------------------------------------------------------------------*\n&TDBAL   DS    0H\n         TIME\n         ST    R1,&TDWORK+4\n         UNPK  &TDIDATE.(5),&TDWORK+5(3)  UNPACK DATE\n         PACK  &TDYEAR,&TDIDATE.(2)       GET YEAR\n         MVC   &TDDATE1+6(2),&TDIDATE    SET UP YEAR\n         DP    &TDYEAR,=P'4'             DIVIDE YEAR BY 4\n         CP    &TDYEARR,=P'0'            Q. REMAINDER 0\n         BNE   &TDLAB1                      N. NOT LEAP YEAR\n         MVC   &TDTABLE+2(2),=X'029C'       Y. FEB = 29 DAYS\n&TDLAB1  DS     0H\n         LA    R9,1(R0)                  SET MONTH COUNTER TO 1\n         LA    R8,&TDTABLE               SET REG 8 AS MONTH POINTER\n         PACK  &TDDAYR.(2),&TDIDATE+2(3) PACK DAYS INTO DAYS REMAING\n&TDLOOP1 DS    0H\n         MVC   &TDDAY.(2),&TDDAYR        SAVE DAYS REMAINING\n         SP    &TDDAYR.(2),0(2,R8)       SUB DAY IN MONTH FROM DAYS\n         CP    &TDDAYR.(2),=P'0'         Q. COMPARE IF NEGATIVE\n         BL    &TDXLOP1                     Y. EXIT LOOP\n         CP    &TDDAYR.(2),=P'0'         Q. COMPARE IF ZERO\n         BZ    &TDXLOP1                     Y. EXIT LOOP\n         LA    R8,2(R8)                  POINT TO NEXT MONTH\n         LA    R9,1(R9)                  INCREMENT MONTH COUNTER\n         B     &TDLOOP1                  RECALCULATE\n&TDXLOP1 DS    0H\n         UNPK  &TDDDD.(3),&TDDAY.(2)     SAVE CURRENT DAYS\n         OI    &TDD+1,X'F0'              CHANGE SIGN OF LAST DEC BYTE\n         MVC   &TDDATE1.(2),&TDD         MOVE 2 BYTES OF DAY TO OUT FLD\n         CVD   R9,&TDWORK                CONVERT MONTH TO DEC/PACKED\n         UNPK  &TDMMM.(3),&TDWORK+6(2)   UNPACK MONTH\n         OI    &TDMM+1,X'F0'             CHG SIGN OF LAST BYTE OF MTH\n         MVC   &TDDATE1+3(2),&TDMM       MOVE MONTH TO OUT FIELD\n         MVC   &OUT.(8),&TDDATE1         MOVE TO DESTINATION\n         BR    R14                       RETURN\n*=====================================================================*\n*---------------------------------------------------------------------*\n&TDBYPAS DS    0H\n.A$99    ANOP\n         STM   R14,R12,&REGSAVR         SAVE REGISTERS\n         BAL   R14,&TDBAL               GO TO GET DATE ROUTINE\n         LM    R14,R12,&REGSAVR         RESTORE REGISTERS\n         AGO   .MEXIT\n.E1      MNOTE 8,'TODAY REQUIRES AN OUTPUT FIELD'\n.MEXIT   ANOP\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TRACE#D": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x89\\x18o\\x00\\x89\\x18o\\x13D\\x00%\\x00%\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xc1\\xd2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1989-07-05T00:00:00", "modifydate": "1989-07-05T13:44:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "TECHAK"}, "text": "         MACRO\n&NAME    TRACE#D &OUT,&PL,&FL\n         AIF   (T'&OUT EQ 'O').E1\n         AIF   (T'&PL EQ 'O').E2\n         LCLA  &PLL\n&PLL     SETA  L'&PL\n         AIF   (T'&FL EQ 'O').E0\n&PLL     SETA  &FL\n.E0      GBLC  &TRDATA\n         GBLC  &TR0SAV\n         GBLB  &TDFIRST\n         AIF   (&TDFIRST).A$99\n&TDFIRST SETB  1\n         LCLC  &TNAME\n&TNAME   SETC  'TR'.'&SYSNDX'\n&TRDATA  SETC  '&TNAME'.'1'\n&TR0SAV  SETC  '&TNAME'.'2'\n         B     &TNAME.3\n&TNAME.1 DS    CL133\n&TNAME.2 DS    18F\n&OUT     DCB   DDNAME=PRINTER1,                                        X\n               DSORG=PS,                                               X\n               MACRF=(PM)\n&TNAME.3 DS    0H\n         OPEN  (&OUT,(OUTPUT))          OPEN PRINT OF PANEL TRANSLATION\n&TNAME.4 DS    0H\n.A$99    ANOP\n         STM   R14,R12,&TR0SAV\n         MVI   &TRDATA,X'40'\n         MVC   &TRDATA+1(132),&TRDATA\n         MVC   &TRDATA+1(&PLL),&PL\n         PUT   &OUT,&TRDATA\n         LM    R14,R12,&TR0SAV\n         MEXIT\n.E1      MNOTE 12,'TRACE REQUIRES AN OUT DATASET'\n.E2      MNOTE 12,'TRACE REQUIRES A FUNCTION PARAMETER LIST'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRACE#L": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x89\\x18o\\x00\\x89\\x18o\\x13D\\x00#\\x00#\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xc1\\xd2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1989-07-05T00:00:00", "modifydate": "1989-07-05T13:44:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "TECHAK"}, "text": "         MACRO\n&NAME    TRACE#L &OUT,&PL\n         AIF   (T'&OUT EQ ' ').E1\n         AIF   (T'&PL EQ ' ').E2\n         LCLA  &PLL\n&PLL     SETA  K'&PL-2\n         GBLC  &TRDATA\n         GBLC  &TR0SAV\n         GBLB  &TLFIRST\n         AIF   (&TLFIRST).A$99\n&TLFIRST SETB  1\n         LCLC  &TNAME\n&TNAME   SETC  'TR'.'&SYSNDX'\n&TRDATA  SETC  '&TNAME'.'1'\n&TR0SAV  SETC  '&TNAME'.'2'\n         B     &TNAME.3\n&TNAME.1 DS    CL133\n&TNAME.2 DS    18F\n&OUT     DCB   DDNAME=PRINTER1,                                        X\n               DSORG=PS,                                               X\n               MACRF=(PM)\n&TNAME.3 DS    0H\n         OPEN  (&OUT,(OUTPUT))          OPEN PRINT OF PANEL TRANSLATION\n&TNAME.4 DS    0H\n.A$99    ANOP\n         STM   R0,R15,&TR0SAV\n         MVI   &TRDATA,X'40'\n         MVC   &TRDATA+1(132),&TRDATA\n         MVC   &TRDATA+1(&PLL),=C&PL\n         PUT   &OUT,&TRDATA\n         LM    R0,R15,&TR0SAV\n         MEXIT\n.E1      MNOTE 12,'TRACE REQUIRES AN OUT DATASET'\n.E2      MNOTE 12,'TRACE REQUIRES A FUNCTION PARAMETER LIST'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRACED": {"ttr": 4103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00G\\x00\\x87\\x18\\x9f\\x00\\x92 _\\x14W\\x006\\x00\\x1e\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1987-07-08T00:00:00", "modifydate": "1992-07-23T14:57:47", "lines": 54, "newlines": 30, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    TRACED &OUT,&PL,&FL\n         AIF   (T'&OUT EQ 'O').E1\n         AIF   (T'&PL EQ 'O').E2\n         LCLA  &PLL\n&PLL     SETA  L'&PL\n         AIF   (T'&FL EQ 'O').E0\n&PLL     SETA  &FL\n.E0      GBLC  &TRDATA\n         GBLB  &TDFIRST\n         LCLC  &#PL\n.*--------------------------------------------------------------------*\n         AIF   ('&PL'(1,1) EQ '(').A$01\n&#PL     SETC  '&PL'\n         AGO   .A$02\n.A$01    ANOP\n&#PL     SETC  '0(&PL(1))'\n.A$02    ANOP\n.*--------------------------------------------------------------------*\n         GBLC  &REGSAVR,&REGSMCR\n         GBLB  &REGSFLG,&REGDFLG\n         AIF   (&REGSFLG).A$RS\n&REGSAVR SETC  'GB'.'&SYSNDX'.'#'\n&REGSMCR SETC  'TRACED'\n&REGSFLG SETB  1\n.A$RS    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (&TDFIRST).A$99\n&TDFIRST SETB  1\n         LCLC  &TNAME\n&TNAME   SETC  'TR'.'&SYSNDX'\n&TRDATA  SETC  '&TNAME'.'1'\n         B     &TNAME.2\n&TNAME.1 DS    CL133\n.*--------------------------------------------------------------------*\n.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *\n.*--------------------------------------------------------------------*\n         AIF   (&REGDFLG).A$RD\n&REGDFLG SETB  1\n&REGSAVR DS    16F                     REGISTER SAVE AREA\n.A$RD    ANOP\n.*--------------------------------------------------------------------*\n&TNAME.2 DS    0H\n.A$99    ANOP\n         STM   R14,R12,&REGSAVR\n         MVI   &TRDATA,X'40'\n         MVC   &TRDATA+1(132),&TRDATA\n         MVC   &TRDATA+1(&PLL),&#PL\n         PUT   &OUT,&TRDATA\n         LM    R14,R12,&REGSAVR\n         MEXIT\n.E1      MNOTE 12,'TRACE REQUIRES AN OUT DATASET'\n.E2      MNOTE 12,'TRACE REQUIRES A FUNCTION PARAMETER LIST'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRACEDA": {"ttr": 4105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x02_\\x00\\x90\\x02_\\x12\\x13\\x00\"\\x00\"\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xc1\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-25T00:00:00", "modifydate": "1990-01-25T12:13:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "TECHAK"}, "text": "         MACRO\n&NAME    TRACEDA &OUT,&PL,&FL\n         AIF   (T'&OUT EQ 'O').E1\n         AIF   (T'&PL EQ 'O').E2\n         LCLA  &PLL\n&PLL     SETA  L'&PL\n         AIF   (T'&FL EQ 'O').E0\n&PLL     SETA  &FL\n.E0      GBLC  &TRDATA\n         GBLC  &TR0SAV\n         GBLB  &TDFIRST\n         AIF   (&TDFIRST).A$99\n&TDFIRST SETB  1\n         LCLC  &TNAME\n&TNAME   SETC  'TR'.'&SYSNDX'\n&TRDATA  SETC  '&TNAME'.'1'\n&TR0SAV  SETC  '&TNAME'.'2'\n         B     &TNAME.3\n&TNAME.1 DS    CL133\n&TNAME.2 DS    18F\n&TNAME.3 DS    0H\n.A$99    ANOP\n         STM   R14,R12,&TR0SAV\n         MVI   &TRDATA,X'40'\n         MVC   &TRDATA+1(132),&TRDATA\n         MVC   &TRDATA+1(&PLL),&PL\n         BAL    R14,BELOW\n         PUT   &OUT,&TRDATA\n         BAL    R14,ABOVE\n         LM    R14,R12,&TR0SAV\n         MEXIT\n.E1      MNOTE 12,'TRACE REQUIRES AN OUT DATASET'\n.E2      MNOTE 12,'TRACE REQUIRES A FUNCTION PARAMETER LIST'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRACEIT": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x00\\x00\\x87\\x17O\\x00\\x87\\x17\\x7f\\x12\\x12\\x00\\x1b\\x00\\x19\\x00\\x00\\xc3\\xe2\\xc1\\xd3\\xc5\\xe7@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "1987-06-23T00:00:00", "modifydate": "1987-06-26T12:12:00", "lines": 27, "newlines": 25, "modlines": 0, "user": "CSALEX"}, "text": "         MACRO\n&NAME    TRACEIT &OUT,&PL\n&NAME    DS    0H\n         AIF   (T'&OUT EQ 'O').E1\n         AIF   (T'&PL EQ 'O').E2\n         LCLA  &PLL\n&PLL     SETA  K'&PL-2\n         GBLB  &FIRST\n         AIF   (&FIRST).INIT\n&FIRST   SETB  1\n         B     TR##INIT\nTR##LINE DC    CL134' TRACE - '\nTR##SAVE DS    4XL5\nTR##ROUT DS    0H\n         PUT   &OUT,TR##LINE\n         MVC   TR##LINE+9(125),TR##LINE+8\n         BR    R2\nTR##INIT DS    0H\n.INIT    ANOP\n         STM   R14,R2,TR##SAVE\n         MVC   TR##LINE+9(&PLL),=C&PL\n         BAL   R2,TR##ROUT\n         LM    R14,R2,TR##SAVE\n         MEXIT\n.E1      MNOTE 12,'TRACE REQUIRES AN OUT DATASET'\n.E2      MNOTE 12,'TRACE REQUIRES A FUNCTION PARAMETER LIST'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRACEL": {"ttr": 4109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x05\\x00\\x87\\x18\\x9f\\x00\\x92 _\\x14X\\x00,\\x00\\x1e\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1987-07-08T00:00:00", "modifydate": "1992-07-23T14:58:05", "lines": 44, "newlines": 30, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    TRACEL &OUT,&PL\n         AIF   (T'&OUT EQ ' ').E1\n         AIF   (T'&PL EQ ' ').E2\n         LCLA  &PLL\n&PLL     SETA  K'&PL-2\n         GBLC  &TRDATA\n         GBLB  &TLFIRST\n.*--------------------------------------------------------------------*\n         GBLC  &REGSAVR,&REGSMCR\n         GBLB  &REGSFLG,&REGDFLG\n         AIF   (&REGSFLG).A$RS\n&REGSAVR SETC  'GB'.'&SYSNDX'.'#'\n&REGSMCR SETC  'TRACEL'\n&REGSFLG SETB  1\n.A$RS    ANOP\n.*--------------------------------------------------------------------*\n         AIF   (&TLFIRST).A$99\n&TLFIRST SETB  1\n         LCLC  &TNAME\n&TNAME   SETC  'TR'.'&SYSNDX'\n&TRDATA  SETC  '&TNAME'.'1'\n         B     &TNAME.2\n&TNAME.1 DS    CL133\n.*--------------------------------------------------------------------*\n.*    IF GLOBAL REGISTER SAVE AREA DEFINED, BYPASS                    *\n.*--------------------------------------------------------------------*\n         AIF   (&REGDFLG).A$RD\n&REGDFLG SETB  1\n&REGSAVR DS    16F                     REGISTER SAVE AREA\n.A$RD    ANOP\n.*--------------------------------------------------------------------*\n&TNAME.2 DS    0H\n.A$99    ANOP\n         STM   R0,R15,&REGSAVR\n         MVI   &TRDATA,X'40'\n         MVC   &TRDATA+1(132),&TRDATA\n         MVC   &TRDATA+1(&PLL),=C&PL\n         PUT   &OUT,&TRDATA\n         LM    R0,R15,&REGSAVR\n         MEXIT\n.E1      MNOTE 12,'TRACE REQUIRES AN OUT DATASET'\n.E2      MNOTE 12,'TRACE REQUIRES A FUNCTION PARAMETER LIST'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRACELA": {"ttr": 4111, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x90\\x02_\\x00\\x90\\x02_\\x12\\x14\\x00 \\x00 \\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xc1\\xd2@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1990-01-25T00:00:00", "modifydate": "1990-01-25T12:14:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "TECHAK"}, "text": "         MACRO\n&NAME    TRACELA &OUT,&PL\n         AIF   (T'&OUT EQ ' ').E1\n         AIF   (T'&PL EQ ' ').E2\n         LCLA  &PLL\n&PLL     SETA  K'&PL-2\n         GBLC  &TRDATA\n         GBLC  &TR0SAV\n         GBLB  &TLFIRST\n         AIF   (&TLFIRST).A$99\n&TLFIRST SETB  1\n         LCLC  &TNAME\n&TNAME   SETC  'TR'.'&SYSNDX'\n&TRDATA  SETC  '&TNAME'.'1'\n&TR0SAV  SETC  '&TNAME'.'2'\n         B     &TNAME.3\n&TNAME.1 DS    CL133\n&TNAME.2 DS    18F\n&TNAME.3 DS    0H\n.A$99    ANOP\n         STM   R0,R15,&TR0SAV\n         MVI   &TRDATA,X'40'\n         MVC   &TRDATA+1(132),&TRDATA\n         MVC   &TRDATA+1(&PLL),=C&PL\n         BAL   R14,BELOW\n         PUT   &OUT,&TRDATA\n         BAL   R14,ABOVE\n         LM    R0,R15,&TR0SAV\n         MEXIT\n.E1      MNOTE 12,'TRACE REQUIRES AN OUT DATASET'\n.E2      MNOTE 12,'TRACE REQUIRES A FUNCTION PARAMETER LIST'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRACER": {"ttr": 4113, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00\\x00\\x00\\x87\\x17?\\x00\\x87\\x17O\\x10'\\x00\\r\\x00\\x10\\x00\\x00\\xc3\\xe2\\xc1\\xd3\\xc5\\xe7@@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-06-22T00:00:00", "modifydate": "1987-06-23T10:27:00", "lines": 13, "newlines": 16, "modlines": 0, "user": "CSALEX"}, "text": "         MACRO\n&NAME    TRACER &PL\n         AIF   (T'&PL EQ 'O').E1\n         LCLA  &PLL\n&PLL     SETA  K'&PL-2\n         ST    R1,SAVER1\n.MVX     MVC   LINEIO(&PLL),=C&PL\n         PUT   PRINTER1,PRLINE\n         MVC   LINEIO(132),SPACES\n         L     R1,SAVER1\n         MEXIT\n.E1      MNOTE 12,'TRACE REQUIRES A FUNCTION PARAMETER LIST'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNPACK": {"ttr": 4115, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1f\\x00\\x04\\x00\\x87\\x18\\x9f\\x00\\x93\\x11o\\x124\\x00N\\x00\\x1e\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.31", "flags": 0, "createdate": "1987-07-08T00:00:00", "modifydate": "1993-04-26T12:34:04", "lines": 78, "newlines": 30, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    UNPACK &REG,&PL,&OUT,&MF=,&LIST=NO,&HELP=NO\n         AIF   ('&HELP' EQ 'YES').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'UNPACK' parameters     *\n* and it's use, pass parameter of 'HELP=Yes'.                         *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n* Macro to unpack a register into a variable.                         *\n*                                                                     *\n*   PARAMETERS:                                                       *\n*       1. Register holding contents                                  *\n*       2. Length to unpack                                           *\n*       3. Output field (default \"upout(8)\")                          *\n*       4. MF=E/L for re-entrant programs.  (Not required for non     *\n*          re-entrant programs.)                                      *\n*       5. LIST=YES/NO, to determine generation of macro statements.  *\n*                                                                     *\n*   NOTE:                                                             *\n*       For re-entrant programs the list format only requires the     *\n*       MF= parameter,                                                *\n*            eg.      UNPACK MF=L                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         PUSH  PRINT\n         AIF   ('&LIST' NE 'NO').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n         AIF   (T'&NAME EQ 'O').A$YY\n&NAME    DS    0H\n.A$YY    ANOP\n         AIF   ('&MF' EQ 'L').A$ZZ\n         AIF   (T'&REG EQ 'O').E1\n         AIF   (T'&PL EQ 'O').E2\n.A$ZZ    ANOP\n         GBLC  &TNAME\n         LCLC  &UPWORK,&UPOUT\n         GBLB  &UNPFST1,&UNPFST2\n         AIF   (&UNPFST1).A$00\n&UNPFST1 SETB  1\n&TNAME   SETC  'UPK'.'&SYSNDX'\n.A$00    ANOP\n&UPWORK  SETC  '&TNAME'.'1'\n&UPOUT   SETC  '&TNAME'.'2'\n         AIF   ('&MF' EQ 'E').A$99          BYPASS IF EXEC FORM OF MAC\n         AIF   ('&MF' EQ 'L').A$11          BYPASS IF LIST FORM OF MAC\n         AIF   (&UNPFST2).A$99\n&UNPFST2 SETB  1\n         B     &TNAME.3                    BRANCH AROUND DATA\n.*--------------------------------------------------------------------*\n.*       DATA STORAGE                                                 *\n.*--------------------------------------------------------------------*\n.A$11    ANOP\n&UPWORK  DS    D\n&UPOUT   DS    CL8\n         AIF   ('&MF' EQ 'L').EXIT         BYPASS IF LIST FORM OF MAC\n.*--------------------------------------------------------------------*\n&TNAME.3 DS    0H\n.A$99    ANOP\n         CVD   &REG,&UPWORK\n         OI    &UPWORK+7,X'0F'\n         UNPK  &UPOUT.(8),&UPWORK+8-&PL.(&PL.)\n         AIF   (T'&OUT EQ 'O').EXIT\n         MVC   &OUT.(&PL.),&UPOUT+8-&PL.\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E1      MNOTE 12,'UNPACK REQUIRES SOURCE A REGISTER'\n         AGO   .EXIT\n.*--------------------------------------------------------------------*\n.E2      MNOTE 12,'UNPACK REQUIRES A LENGTH'\n.*--------------------------------------------------------------------*\n.EXIT    ANOP\n         POP   PRINT\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WCCDC": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1c\\x00I\\x00\\x87\\x19_\\x00\\x96\\x16_\\x17A\\x00`\\x00\\x87\\x00\\x00\\xe3\\xf6\\xf6\\xd2\\xd2\\xd2@@@@'", "ispf": {"version": "01.28", "flags": 0, "createdate": "1987-07-14T00:00:00", "modifydate": "1996-06-13T17:41:49", "lines": 96, "newlines": 135, "modlines": 0, "user": "T66KKK"}, "text": "         MACRO\n&NAME    WCCDC &WRITE,&AKBMDT,&COLOR,&LIST=YES,&HELP=NO\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n.*--------------------------------------------------------------------*\n         GBLB  &WCCDC1ST\n         AIF   (&WCCDC1ST).A$HELPE     IF NOT 1ST. TIME THRU\n&WCCDC1ST SETB 1\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'WCCDC' parameter and   *\n* it's use, pass parameter 'HELP=Yes'.                                *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n* Macro to set the start of \"SBA\" output attributes.                  *\n* These are the \"Write Control Characters\" (WCC).                     *\n*                                                                     *\n*   Parameters:                                                       *\n*       1. WRITE (W/EW/EWA)                                           *\n*                 (default 'W')                                       *\n*       2. AKBMDT (Y/N for alarm+restore keyboard+reset MDT)          *\n*                 (default 'NYY')                                     *\n*       3. COLOR/MONO  indicator                                      *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         GBLC  &COL#MON\n&COL#MON SETC  '&COLOR'\n&COL#MON SETC  'COLOR'                          FORCE COLOR\n         LCLC  &WCC\n         AIF   (T'&WRITE EQ 'O').WRW            WRITE OMITTED\n         AIF   ('&WRITE' EQ 'W').WRW            WRITE = WRITE\n         AIF   ('&WRITE' EQ 'EW').WRE           WRITE = ERASE/WRITE\n         AIF   ('&WRITE' EQ 'EWA').WRA          WRITE = ERASE/WRITE ALT\n         AGO   .E1\n.WRW     ANOP\n&WCC     SETC  'F1'\n         AGO   .DEFREST\n.WRE     ANOP\n&WCC     SETC  'F5'\n         AGO   .DEFREST\n.WRA     ANOP\n&WCC     SETC  '7E'\n.DEFREST ANOP\n         AIF   (T'&AKBMDT EQ 'O').WCCNYN\n         AIF   ('&AKBMDT' EQ 'YYY').WCCYYY\n         AIF   ('&AKBMDT' EQ 'YYN').WCCYYN\n         AIF   ('&AKBMDT' EQ 'YNY').WCCYNY\n         AIF   ('&AKBMDT' EQ 'YNN').WCCYNN\n         AIF   ('&AKBMDT' EQ 'NYY').WCCNYY\n         AIF   ('&AKBMDT' EQ 'NYN').WCCNYN\n         AIF   ('&AKBMDT' EQ 'NNY').WCCNNY\n         AIF   ('&AKBMDT' EQ 'NNN').WCCNNN\n         AGO   .E2\n.WCCYYY  ANOP\n&WCC     SETC  '&WCC.C7'\n         AGO   .COLORT\n.WCCYYN  ANOP\n&WCC     SETC  '&WCC.C6'\n         AGO   .COLORT\n.WCCYNY  ANOP\n&WCC     SETC  '&WCC.C5'\n         AGO   .COLORT\n.WCCYNN  ANOP\n&WCC     SETC  '&WCC.C4'\n         AGO   .COLORT\n.WCCNYY  ANOP\n&WCC     SETC  '&WCC.C3'\n         AGO   .COLORT\n.WCCNYN  ANOP\n&WCC     SETC  '&WCC.C2'\n         AGO   .COLORT\n.WCCNNY  ANOP\n&WCC     SETC  '&WCC.C1'\n         AGO   .COLORT\n.WCCNNN  ANOP\n&WCC     SETC  '&WCC.40'\n.COLORT  ANOP\n         AIF   (T'&COL#MON EQ 'O').DEFTCOL\n         AGO   .TSTCOLR\n.DEFTCOL ANOP\n&COL#MON SETC  'COLOR'\n.TSTCOLR ANOP\n         AIF   ('&COL#MON'(1,1) EQ 'C').PUTWCC\n         AIF   ('&COL#MON'(1,1) EQ 'M').PUTWCC\n         AGO   .E3\n.PUTWCC  ANOP\n&NAME    DC    X'&WCC'\n         MEXIT\n.E1      MNOTE 8,'VALID WRITES ARE \"W/EW/EWA.'\n.E2      MNOTE 8,'WCC NEEDS \"Y/N\" FOR ALARM, RESTORE KB + RESET MTD.'\n.E3      MNOTE 8,'INVALID COLOR INDICATOR. VALID VALUES \"Y/N\"'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WCCDCCOL": {"ttr": 4355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00T\\x00\\x916\\x1f\\x00\\x925?\\x11H\\x00c\\x00R\\x00\\x00\\xe9\\xe3\\xe2\\xc1\\xd3\\xd2@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1991-12-27T00:00:00", "modifydate": "1992-12-18T11:48:54", "lines": 99, "newlines": 82, "modlines": 0, "user": "ZTSALK"}, "text": "         MACRO\n&NAME    WCCDC &WRITE,&AKBMDT,&COLOR,&LIST=YES,&HELP=NO\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n.*--------------------------------------------------------------------*\n         GBLB  &WCCDC1ST\n         AIF   (&WCCDC1ST).A$HELPE     IF NOT 1ST. TIME THRU\n&WCCDC1ST SETB 1\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'WCCDC' parameter and   *\n* it's use, pass parameter 'HELP=Yes'.                                *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* THIS MACRO FORCES COLOR (EXTENDED ATTRIBUTES) DEFINITIONS......     *\n*                                                                     *\n* Macro to set the start of \"SBA\" output attributes.                  *\n* These are the \"Write Control Characters\" (WCC).                     *\n*                                                                     *\n*   Parameters:                                                       *\n*       1. WRITE (W/EW/EWA)                                           *\n*                 (default 'W')                                       *\n*       2. AKBMDT (Y/N for alarm+restore keyboard+reset MDT)          *\n*                 (default 'NYY')                                     *\n*       3. COLOR/MONO indicator                                       *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         GBLC  &COL#MON\n&COL#MON SETC  '&COLOR'\n&COL#MON SETC  'COLOR'\n         LCLC  &WCC\n         AIF   (T'&WRITE EQ 'O').WRW            WRITE OMITTED\n         AIF   ('&WRITE' EQ 'W').WRW            WRITE = WRITE\n         AIF   ('&WRITE' EQ 'EW').WRE           WRITE = ERASE/WRITE\n         AIF   ('&WRITE' EQ 'EWA').WRA          WRITE = ERASE/WRITE ALT\n         AGO   .E1\n.WRW     ANOP\n&WCC     SETC  'F1'\n         AGO   .DEFREST\n.WRE     ANOP\n&WCC     SETC  'F5'\n         AGO   .DEFREST\n.WRA     ANOP\n&WCC     SETC  '7E'\n.DEFREST ANOP\n         AIF   (T'&AKBMTD EQ 'O').WCCNYN\n         AIF   ('&AKBMTD' EQ 'YYY').WCCYYY\n         AIF   ('&AKBMTD' EQ 'YYN').WCCYYN\n         AIF   ('&AKBMTD' EQ 'YNY').WCCYNY\n         AIF   ('&AKBMTD' EQ 'YNN').WCCYNN\n         AIF   ('&AKBMTD' EQ 'NYY').WCCNYY\n         AIF   ('&AKBMTD' EQ 'NYN').WCCNYN\n         AIF   ('&AKBMTD' EQ 'NNY').WCCNNY\n         AIF   ('&AKBMTD' EQ 'NNN').WCCNNN\n         AGO   .E2\n.WCCYYY  ANOP\n&WCC     SETC  '&WCC.C7'\n         AGO   .COLORT\n.WCCYYN  ANOP\n&WCC     SETC  '&WCC.C6'\n         AGO   .COLORT\n.WCCYNY  ANOP\n&WCC     SETC  '&WCC.C5'\n         AGO   .COLORT\n.WCCYNN  ANOP\n&WCC     SETC  '&WCC.C4'\n         AGO   .COLORT\n.WCCNYY  ANOP\n&WCC     SETC  '&WCC.C3'\n         AGO   .COLORT\n.WCCNYN  ANOP\n&WCC     SETC  '&WCC.C2'\n         AGO   .COLORT\n.WCCNNY  ANOP\n&WCC     SETC  '&WCC.C1'\n         AGO   .COLORT\n.WCCNNN  ANOP\n&WCC     SETC  '&WCC.40'\n.COLORT  ANOP\n         AIF   (T'&COL#MON EQ 'O').DEFTCOL\n         AGO   .TSTCOLR\n.DEFTCOL ANOP\n&COL#MON SETC  'COLOR'\n.TSTCOLR ANOP\n         AIF   ('&COL#MON'(1,1) EQ 'C').PUTWCC\n         AIF   ('&COL#MON'(1,1) EQ 'M').PUTWCC\n         AGO   .E3\n.PUTWCC  ANOP\n&NAME    DC    X'&WCC'\n         MEXIT\n.E1      MNOTE 8,'VALID WRITES ARE \"W/EW/EWA.'\n.E2      MNOTE 8,'WCC NEEDS \"Y/N\" FOR ALARM, RESTORE KB + RESET MTD.'\n.E3      MNOTE 8,'INVALID COLOR INDICATOR. VALID VALUES \"Y/N\"'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WCCDCMON": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x001\\x00\\x916\\x1f\\x00\\x95 \\x0f\\x13C\\x00c\\x00R\\x00\\x00\\xe4\\xe3\\xd4\\xd7\\xf5\\xf4\\xf3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1991-12-27T00:00:00", "modifydate": "1995-07-19T13:43:31", "lines": 99, "newlines": 82, "modlines": 0, "user": "UTMP543"}, "text": "         MACRO\n&NAME    WCCDC &WRITE,&AKBMDT,&COLOR,&LIST=YES,&HELP=NO\n         PUSH  PRINT\n         AIF   ('&LIST'(1,1) NE 'N').A$XX\n         PRINT NOGEN\n.A$XX    ANOP\n.*--------------------------------------------------------------------*\n         GBLB  &WCCDC1ST\n         AIF   (&WCCDC1ST).A$HELPE     IF NOT 1ST. TIME THRU\n&WCCDC1ST SETB 1\n         AIF   ('&HELP'(1,1) EQ 'Y').A$HELP\n*---------------------------------------------------------------------*\n* For a more comprehensive description of the 'WCCDC' parameter and   *\n* it's use, pass parameter 'HELP=Yes'.                                *\n*---------------------------------------------------------------------*\n         AGO .A$HELPE\n.A$HELP  ANOP\n*---------------------------------------------------------------------*\n*                                                                     *\n* THIS MACRO FORCES MONOCHROME (NON-EXTENDED ATTRIBUTE) DEFINITIONS.. *\n*                                                                     *\n* Macro to set the start of \"SBA\" output attributes.                  *\n* These are the \"Write Control Characters\" (WCC).                     *\n*                                                                     *\n*   Parameters:                                                       *\n*       1. WRITE (W/EW/EWA)                                           *\n*                 (default 'W')                                       *\n*       2. AKBMDT (Y/N for alarm+restore keyboard+reset MDT)          *\n*                 (default 'NYY')                                     *\n*       3. COLOR/MONO indicator                                       *\n*---------------------------------------------------------------------*\n.A$HELPE ANOP\n         GBLC  &COL#MON\n&COL#MON SETC  '&COLOR'\n&COL#MON SETC  'MONO'\n         LCLC  &WCC\n         AIF   (T'&WRITE EQ 'O').WRW            WRITE OMITTED\n         AIF   ('&WRITE' EQ 'W').WRW            WRITE = WRITE\n         AIF   ('&WRITE' EQ 'EW').WRE           WRITE = ERASE/WRITE\n         AIF   ('&WRITE' EQ 'EWA').WRA          WRITE = ERASE/WRITE ALT\n         AGO   .E1\n.WRW     ANOP\n&WCC     SETC  'F1'\n         AGO   .DEFREST\n.WRE     ANOP\n&WCC     SETC  'F5'\n         AGO   .DEFREST\n.WRA     ANOP\n&WCC     SETC  '7E'\n.DEFREST ANOP\n         AIF   (T'&AKBMDT EQ 'O').WCCNYN\n         AIF   ('&AKBMDT' EQ 'YYY').WCCYYY\n         AIF   ('&AKBMDT' EQ 'YYN').WCCYYN\n         AIF   ('&AKBMDT' EQ 'YNY').WCCYNY\n         AIF   ('&AKBMDT' EQ 'YNN').WCCYNN\n         AIF   ('&AKBMDT' EQ 'NYY').WCCNYY\n         AIF   ('&AKBMDT' EQ 'NYN').WCCNYN\n         AIF   ('&AKBMDT' EQ 'NNY').WCCNNY\n         AIF   ('&AKBMDT' EQ 'NNN').WCCNNN\n         AGO   .E2\n.WCCYYY  ANOP\n&WCC     SETC  '&WCC.C7'\n         AGO   .COLORT\n.WCCYYN  ANOP\n&WCC     SETC  '&WCC.C6'\n         AGO   .COLORT\n.WCCYNY  ANOP\n&WCC     SETC  '&WCC.C5'\n         AGO   .COLORT\n.WCCYNN  ANOP\n&WCC     SETC  '&WCC.C4'\n         AGO   .COLORT\n.WCCNYY  ANOP\n&WCC     SETC  '&WCC.C3'\n         AGO   .COLORT\n.WCCNYN  ANOP\n&WCC     SETC  '&WCC.C2'\n         AGO   .COLORT\n.WCCNNY  ANOP\n&WCC     SETC  '&WCC.C1'\n         AGO   .COLORT\n.WCCNNN  ANOP\n&WCC     SETC  '&WCC.40'\n.COLORT  ANOP\n         AIF   (T'&COL#MON EQ 'O').DEFTCOL\n         AGO   .TSTCOLR\n.DEFTCOL ANOP\n&COL#MON SETC  'COLOR'\n.TSTCOLR ANOP\n         AIF   ('&COL#MON'(1,1) EQ 'C').PUTWCC\n         AIF   ('&COL#MON'(1,1) EQ 'M').PUTWCC\n         AGO   .E3\n.PUTWCC  ANOP\n&NAME    DC    X'&WCC'\n         MEXIT\n.E1      MNOTE 8,'VALID WRITES ARE \"W/EW/EWA.'\n.E2      MNOTE 8,'WCC NEEDS \"Y/N\" FOR ALARM, RESTORE KB + RESET MTD.'\n.E3      MNOTE 8,'INVALID COLOR INDICATOR. VALID VALUES \"Y/N\"'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WCCDCV": {"ttr": 4359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x19_\\x00\\x88%?\\x14T\\x00A\\x00A\\x00\\x00\\xc3\\xe2\\xc1\\xd3\\xc5\\xe7@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-07-14T00:00:00", "modifydate": "1988-09-09T14:54:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "CSALEX"}, "text": "         MACRO\n*---------------------------------------------------------------------*\n*   PARAMETERS:                                                       *\n*       1. DESTINATION ADDRESS                                        *\n*       2. ROW NUMBER                                                 *\n*       3. COLLUMN                                                    *\n*   FORMULAE:  ((R-1)*80+(C-1))/64   QOUTIENT  => ROW DISP IN TABLE   *\n*                                    REMAINDER => COL DISP IN TABLE   *\n*---------------------------------------------------------------------*\n&NAME    WCCDCV &OUT,&WRITE,&AKBMTD\n         LCLC  &WCC\n         AIF   (T'&WRITE EQ 'O').E1\n         AIF   (T'&WRITE EQ 'O').WRW            WRITE OMITTED\n         AIF   ('&WRITE' EQ 'W').WRW            WRITE = WRITE\n         AIF   ('&WRITE' EQ 'EW').WRE           WRITE = ERASE/WRITE\n         AIF   ('&WRITE' EQ 'EWA').WRA          WRITE = ERASE/WRITE ALT\n         AGO   .E1\n.WRW     ANOP\n&WCC     SETC  'F1'\n         AGO   .DEFREST\n.WRE     ANOP\n&WCC     SETC  'F5'\n         AGO   .DEFREST\n.WRA     ANOP\n&WCC     SETC  '7E'\n.DEFREST ANOP\n         AIF   (T'&AKBMTD EQ 'O').WCCNYY\n         AIF   ('&AKBMTD' EQ 'YYY').WCCYYY\n         AIF   ('&AKBMTD' EQ 'YYN').WCCYYN\n         AIF   ('&AKBMTD' EQ 'YNY').WCCYNY\n         AIF   ('&AKBMTD' EQ 'YNN').WCCYNN\n         AIF   ('&AKBMTD' EQ 'NYY').WCCNYY\n         AIF   ('&AKBMTD' EQ 'NYN').WCCNYN\n         AIF   ('&AKBMTD' EQ 'NNY').WCCNNY\n         AIF   ('&AKBMTD' EQ 'NNN').WCCNNN\n         AGO   .E2\n.WCCYYY  ANOP\n&WCC     SETC  '&WCC.C7'\n         AGO   .PUTWCC\n.WCCYYN  ANOP\n&WCC     SETC  '&WCC.C6'\n         AGO   .PUTWCC\n.WCCYNY  ANOP\n&WCC     SETC  '&WCC.C5'\n         AGO   .PUTWCC\n.WCCYNN  ANOP\n&WCC     SETC  '&WCC.C4'\n         AGO   .PUTWCC\n.WCCNYY  ANOP\n&WCC     SETC  '&WCC.C3'\n         AGO   .PUTWCC\n.WCCNYN  ANOP\n&WCC     SETC  '&WCC.C2'\n         AGO   .PUTWCC\n.WCCNNY  ANOP\n&WCC     SETC  '&WCC.C1'\n         AGO   .PUTWCC\n.WCCNNN  ANOP\n&WCC     SETC  '&WCC.40'\n.PUTWCC  ANOP\n         MVC   &OUT.(2),=X'&WCC'\n         MEXIT\n.E1      MNOTE 12,'VALID WRITES ARE \"W/EW/EWA.'\n.E2      MNOTE 12,'WCC NEEDS \"Y/N\" FOR ALARM, RESTORE KB + RESET MTD.'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "YREGS": {"ttr": 6149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x00\\x98&o\\x00\\x98&o\\x15\\x04\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xd7\\xc1\\xd3\\xd2@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-09-23T00:00:00", "modifydate": "1998-09-23T15:04:04", "lines": 19, "newlines": 19, "modlines": 0, "user": "SPALK"}, "text": "         MACRO\n&NAME    YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT898/CBT.V500.FILE898.PDS/MACLIB.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT898/CBT.V500.FILE898.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}