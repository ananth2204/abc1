{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012407000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE576.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE576.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x06'", "DS1TRBAL": "b'\\x88\"'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04K\\x00\\x03\\x04K\\x00\\x06\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x15o\\x01\\x02\\x15o\\x18\\x10\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-06-05T00:00:00", "modifydate": "2002-06-05T18:10:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 448    FILE:  576\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT448.FILE576\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 6 MEMBERS COUNTED; CUMULATIVE SIZE IS 726 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/05/02    18:10:55    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x02\\x15o\\x01\\x02\\x15o\\x17Y\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-06-05T00:00:00", "modifydate": "2002-06-05T17:59:03", "lines": 30, "newlines": 30, "modlines": 0, "user": "SBGOLOB"}, "text": "Sam,\n\nI have changed XCPY so that it will now handle uncataloged\ndatasets.  This meant a small change to the panel but I think it\nnow makes more sense - the source dataset is now first, followed\nby the destination dataset.\n\nXCPY works exactly as it did before but with additional\nfunctionality.  You can invoke the panel using an uncataloged\ndataset and then enter a VOLSER for that dataset.  XCPY will then\nretrieve the details and let you continue as normal.\n\nXCPY when invoked from the command line is now a little different\nas well.  It will work as it did before, but if you substitute\n<volume:dsname> for <dsname>, it will strip the volume from the\ndsname and populate the panel for you.  This should work for both\nthe source and destination datasets.\n\nI have updated the doco, but it is probably best to just let you\nplay with it.\n\nTell me how you go !\n\nRegards,\n\nMick Sheehy.\nSystems Programmer, Information Technology\nFAL Foodland Associated Limited\nT:+61 (8) 9311 6082 F:+61 (8) 9311 6012 M:+61 0417 965 986\nE:Michael.Sheehy@fal.com.au\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$XCPYDOC": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00B\\x01\\x02\\x07/\\x01\\x02\\x15o\\x18\\x04\\x00H\\x00\\x01\\x00\\x00\\xe2\\xc8\\xc5\\xd4\\xc9\\xc3@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-03-13T00:00:00", "modifydate": "2002-06-05T18:04:42", "lines": 72, "newlines": 1, "modlines": 0, "user": "SHEMIC"}, "text": "/*********************************************************************/\n/* NAME         : XCPY                                               */\n/* DESCRIPTION  : Extended Copy Facility allowing copies without     */\n/*              the need to : allocate a dataset.                    */\n/*                                                                   */\n/* AUTHOR       : Mick Sheehy                                        */\n/* DATE WRITTEN : February 4, 2002                                   */\n/*                                                                   */\n/*********************************************************************/\n\nXCPY retrieves the attributes of a dataset via the REXX TSO/E\nexternal function LISTDSI.\n\nThis information is then used to populate a panel which when\ndisplayed, allows the user the ability to change dataset\nattributes. (eg. Space allocations, destination volume etc..)\n\nThese attributes are then fed into a TSO ALLOCATE command. Based\non the success of this command, IEBGENER or IEBCOPY is then\ninvoked to copy sequential datasets or PDS's respectively.\n\nXCPY contains rudimentary validation which ensures the\ndestination dataset is large enough to hold the contents of the\noriginal.  This is based on the space allocated and NOT the space\nutilised.  XCPY will also ensure datasets are fully qualified\neven though I am one of those strange individuals who works with\nTSO with a profile containing \"NOPREFIX\"\n\n**********************************************\n**  IN SUMMARY BEFORE XCPY CAN BE INVOKED.  **\n**********************************************\n\n - XCPY REXX must be placed within the SYSEXEC concatenation.\n - XCPY panel may either :\n     ~ Be placed in the panel library concatenation and the\n       LIBDEF statement in the XCPY REXX be deleted or commented\n       out.\n          OR\n     ~ Be placed wherever the LIBDEF statement references.\n\n\nTo invoke XCPY :\n - Type XCPY next to a DSLIST dataset entry, the XCPY panel will\n   be displayed and the user can enter a destination dataset,\n   change any required attributes and hit <enter> to proceed.\n\n     OR\n\n - Type XCPY <original dataset> <destination dataset> from the\n   TSO command line.  This will display the XCPY panel with both\n   the original and destination datasets already filled in. The\n   user can then change any required attributes and hit <enter>\n   to proceed.\n\n - Type XCPY <volume1:original dataset> <volume2:destination\n   dataset> from the TSO command line.  This will display the\n   XCPY panel with both the original and destination datasets\n   already filled in.  In addition to this, the volumes on which\n   these datasets reside will also be filled in.\n\n   BY SPECIFYING THE VOLUME ON WHICH THE ORIGINAL DATASET\n   RESIDES, XCPY IS ABLE TO COPY UNCATALOGED DATASETS.\n\nI find this utility extremely handy - I hope others do to !\n\nAny comments can be forwarded on to me through Sam Golob at the\nfollowing email address : 'sbgolob@attglobal.net'\n\nCheers,\n\nMick Sheehy #;-)>\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE576": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00A\\x01\\x01\\x02_\\x01\\x02\\x12\\x8f\\t1\\x00\\x14\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2002-05-08T09:31:41", "lines": 20, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 576 is from Mick Sheehy, and contains a REXX exec which   *   FILE 576\n//*           makes it very easy to copy sequential and pds files   *   FILE 576\n//*           on MVS.  The package consists of one REXX exec and    *   FILE 576\n//*           one ISPF panel.  When you decide to copy a dataset    *   FILE 576\n//*           and execute the REXX, the panel appears and allows    *   FILE 576\n//*           you to change all kinds of information about the      *   FILE 576\n//*           target dataset, including its name, target volser,    *   FILE 576\n//*           and space allocation.  If the target dataset space    *   FILE 576\n//*           allocation is too small, then the program informs     *   FILE 576\n//*           you, and requests that you allocate more space, even  *   FILE 576\n//*           before any actual action is taken.                    *   FILE 576\n//*                                                                 *   FILE 576\n//*           You'll enjoy the wholesome Aussie flavour of the      *   FILE 576\n//*           dialog messages.                                      *   FILE 576\n//*                                                                 *   FILE 576\n//*           email: Michael Sheehy <Michael.Sheehy@fal.com.au>     *   FILE 576\n//*                                                                 *   FILE 576\n//*           Note:  Please see the $XCPYDOC member for a few       *   FILE 576\n//*                  helpful notes.                                 *   FILE 576\n//*                                                                 *   FILE 576\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XCPY": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x14\\x01\\x02\\x15o\\x01\\x02\\x15o\\x16\\x03\\x02.\\x02\\n\\x00\\x00\\xe2\\xc8\\xc5\\xd4\\xc9\\xc3@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2002-06-05T00:00:00", "modifydate": "2002-06-05T16:03:14", "lines": 558, "newlines": 522, "modlines": 0, "user": "SHEMIC"}, "text": "/*                               rexx                                        */\n/*****************************************************************************/\n/* NAME         : XCPY                                                       */\n/* DESCRIPTION  : Extended Copy Facility allowing copies without allocations */\n/* AUTHOR       : Mick Sheehy                                                */\n/* DATE WRITTEN : February 4, 2002                                           */\n/*                                                                           */\n/* MODIFICATIONS                                                             */\n/* 05/06/02 : SHEMIC : Modify to allow uncataloged original datasets.        */\n/*                   :  This includes a change to the panel.                 */\n/* 23/05/02 : SHEMIC : Modify xcpy to invoke IEBGENER via a TSOEXEC \"call\"   */\n/*                   :  rather than using LINKMVS.                           */\n/*                   : Improve logic ensuring datasets are fully qualified.  */\n/* 10/05/02 : SHEMIC : Modify TSO ALLOCATE command to use keyword \"REUSE\"    */\n/*                   :  instead of looping logic to reallocate a dataset if  */\n/*                   :  it is in use.                                        */\n/*                   : Ensure both the original and destination datasets are */\n/*                   :  fully qualified - before and after the panel is      */\n/*                   :  displayed.                                           */\n/* 06/05/02 : SHEMIC : Modify TSO CALL to IEBCOPY to invoke TSOEXEC and      */\n/*                   :  explicitly state which library IEBCOPY resides in.   */\n/*                   :  (ie. SYS1.LINKLIB)                                   */\n/* 02/05/02 : SHEMIC : Modify to change the PDS copy procedure to use        */\n/*                   :  IEBCOPY instead of ISPF service LMCOPY.              */\n/*                   : Add more meaningful error messages.                   */\n/* 01/05/02 : SHEMIC : Modify to convert allocations to bytes before         */\n/*                   :  comparing against the primary allocation.            */\n/* 23/04/02 : SHEMIC : Modify to protect against copying a dataset to a      */\n/*                   :  destination which is too small (ie. Primary alloc)   */\n/* 28/03/02 : SHEMIC : Modify to correct bug which disallowed a secondary    */\n/*                   :  allocation of space.                                 */\n/*                   : Improve logic controlling allocation of SYSIN.        */\n/*                   : Added the ability to PF3 out without performing the   */\n/*                   :  copy.                                                */\n/*****************************************************************************/\n/*                                                                           */\n/* If you don't want to put the panel into an ISPPLIB panel library,         */\n/* then uncomment the LIBDEF statement, and point it to a valid              */\n/* library containing the panel, at your installation.                       */\n/*                                                                           */\n/* Use a LIBDEF to point to the panel - prevents overcrowding in the SYSEXEC */\n/*                                                                           */\n/* Address ISPEXEC\n        \"LIBDEF ISPPLIB DATASET ID('SHEMIC.WORK.JCLLIB') STACK\"              */\nFailCount = 0\novolume = ' '\nvolume   = ''\nunit     = ''\ndsorg    = ''\nrecfm    = ''\nlrecl    = ''\nblksize  = ''\nalloc    = ''\nupages   = ''\nprimary  = ''\nOrigPrim = ''\nsecond   = ''\nOrigSec  = ''\nunits    = ''\nOrigunit = ''\nadirblk  = ''\nudirblk  = ''\nvolentered = ''\ndssms    = ''\nracfprot = ''\n/*                                                                           */\n/* Set up rudimentary space constants                                        */\n/*                                                                           */\ntrackbytes = 58778\ncyltracks  = 15\n/*                                                                           */\n/* Get the existing and new dataset names                                    */\n/*                                                                           */\nparse arg dsn dsn2\nif dsn = '' then\ndo\n   say \"Please enter the fully qualified FROM dsname.\"\n   parse pull DSFROM\n   if DSFROM /= \"\"\n   then do\n       dsn = ''''||STRIP(TRANSLATE(DSFROM,' ',''''))||''''\n   end\n   else do\n       say \"You must enter a fully qualified dsname to copy from\"\n       exit 0\n   end\nend\n/*                                                                           */\n/* Strip out a specified volume if specified.                                */\n/* Ensure original dataset is fully qualified.                               */\n/*                                                                           */\n    if INDEX(dsn,':') > 0\n    then do\n        ovolume = SUBSTR(dsn,1,INDEX(dsn,':')-1)\n        dsn = SUBSTR(dsn,INDEX(dsn,':')+1)\n    end\n    dsn = ''''||STRIP(TRANSLATE(dsn,' ',''''))||''''\n/*                                                                           */\n/* Strip out a specified volume if specified.                                */\n/* Ensure destination dataset is fully qualified.                            */\n/*                                                                           */\n    IF WORDS(STRIP(TRANSLATE(dsn2,' ',''''))) = 0\n    THEN DO\n        dsn2 = ''\n    END\n    ELSE DO\n        if INDEX(dsn2,':') > 0\n        then do\n            volentered = SUBSTR(dsn2,1,INDEX(dsn2,':')-1)\n            dsn2 = SUBSTR(dsn2,INDEX(dsn2,':')+1)\n        end\n        dsn2 = ''''||STRIP(TRANSLATE(dsn2,' ',''''))||''''\n    END\n/*                                                                           */\n/* Get dataset information for the existing dataset                          */\n/* Use LISTDSI with a volume only if a volume was specified.                 */\n/*                                                                           */\n/* If an uncataloged dataset is the source dataset, display the panel        */\n/* allowing the volume it resides on to be entered.  After the volume is     */\n/* entered, use LISTDSI to populate the remaining panel fields.              */\n/*                                                                           */\nif WORDS(STRIP(ovolume)) = 0\nthen do\n    x = listdsi(dsn directory prealloc)\nend\nelse do\n    OrigDsetVolume = 'volume('||ovolume||')'\n    x = listdsi(dsn OrigDsetVolume directory prealloc)\nend\ndo while (FailCount < 2)\n    FailCount = FailCount + 1\n    if x > 0\n    then do\n        if (STRIP(TRANSLATE(sysreason,' ','0')) = \"2\") & (FailCount <= 1)\n        then do\n            Address ISPEXEC\n                \"display panel(xcpypnl0) \"\n/*                                                                           */\n/* End / Return on receipt of PF3                                            */\n/*                                                                           */\n            if rc \\= 0\n            then do\n                say 'XCPY has been ended - copy terminated by request.'\n                exit 0\n            end\n            if words(ovolume) = 0\n            then do\n                x = 99\n            end\n            else do\n                OrigDsetVolume = 'volume('||ovolume||')'\n                x = listdsi(dsn OrigDsetVolume directory prealloc)\n            end\n        end\n        else do\n            if x = 99\n            then do\n                say \"Sorry . . XCPY detects that the Original dataset is \"||,\n                    \"uncataloged and \"\n                say \" no volume was specified.\"\n                say \"If a dataset is uncataloged, XCPY requires a volume\"||,\n                    \" to locate it.\"\n                say \" \"\n                say \"XCPY is now terminating.\"\n                exit\n            end\n            else do\n                say \"listdsi failed rc = \" x\n                say \"lastcc = \" lastcc \" sysreason = \" sysreason\n                exit\n            end\n        end\n    end\nend\n/*                                                                           */\n/* Extract dataset information from ISPF variables populated by LISTDSI      */\n/*                                                                           */\nAddress ISPEXEC\n    if words(STRIP(volentered)) = 0\n    then do\n        volume   = sysvolume\n    end\n    else do\n        volume   = volentered\n    end\n    if words(STRIP(ovolume)) = 0\n    then do\n        ovolume = volume\n    end\n    unit     = sysunit\n    dsorg    = sysdsorg\n    if dsorg = '???'\n    then do\n        dsorg = 'PS'\n    end\n    recfm    = sysrecfm\n    lrecl    = syslrecl\n    blksize  = sysblksize\n    alloc    = sysalloc\n    upages   = sysusedpages\n    primary  = sysprimary\n    OrigPrim = primary\n    second   = sysseconds\n    OrigSec  = second\n    units    = sysunits\n    Origunit = units\n    adirblk  = sysadirblk\n    udirblk  = sysudirblk\n    dssms    = sysdssms\n    racfprot = sysracfa\n/*                                                                           */\n/* Make variable information available to the panel                          */\n/*                                                                           */\n    \"vput (ovolume,volume,unit,dsorg,recfm,lrecl,blksize)\"\n    \"vput (alloc,upages,primary,second,units)\"\n    \"vput (adirblk,udirblk,dssms,racfprot)\"\n    \"vput (dsn,dsn2) profile\"\n    if sysreason > 0 then\n    do\n        say \"XCPY has failed with sysreason failure RC : \" sysreason\n        exit\n    end\n/*                                                                           */\n    Displayflag = 1\n    Do while Displayflag = 1\n/*                                                                           */\n/* Display the panel                                                         */\n/*                                                                           */\n        \"display panel(xcpypnl0) \"\n/*                                                                           */\n/* End / Return on receipt of PF3                                            */\n/*                                                                           */\n        if rc \\= 0\n        then do\n            say 'XCPY has been ended - copy terminated by request.'\n            exit 0\n        end\n        else do\n            Displayflag = 0\n        end\n/*                                                                           */\n/* Do not allow a copy of a dataset to a destination dataset which is        */\n/* smaller than the original....                                             */\n/*                                                                           */\n/*                                                                           */\n/* Calculate the maximum space allocation - taking secondary allocations     */\n/* into account.                                                             */\n/*                                                                           */\n        Origspace = OrigPrim + (OrigSec * 15)\n        Newspace = primary + (second * 15)\n/*                                                                           */\n/* Look for the truncated output from the displayed panel.                   */\n/*                                                                           */\n        unitsub = SUBSTR(units,1,5)\n        Origunitsub = SUBSTR(Origunit,1,5)\n/*                                                                           */\n/* Convert original dataset allocation to bytes.                             */\n/*                                                                           */\n        SELECT\n          WHEN Origunitsub = 'BLOCK'\n          THEN DO\n              Origspace = Origspace * blksize\n          END\n          WHEN Origunitsub = 'TRACK'\n          THEN DO\n              Origspace = Origspace * trackbytes\n          END\n          WHEN Origunitsub = 'CYLIN'\n          THEN DO\n              Origspace = Origspace * trackbytes * cyltracks\n          END\n          OTHERWISE nop\n        END\n/*                                                                           */\n/* Convert new dataset allocation to bytes.                                  */\n/*                                                                           */\n        SELECT\n          WHEN unitsub = 'BLOCK'\n          THEN DO\n              Newspace = Newspace * blksize\n          END\n          WHEN unitsub = 'TRACK'\n          THEN DO\n              Newspace = Newspace * trackbytes\n          END\n          WHEN unitsub = 'CYLIN'\n          THEN DO\n              Newspace = Newspace * trackbytes * cyltracks\n          END\n          OTHERWISE nop\n        END\n/*                                                                           */\n/* Test to ensure destination dataset is large enough to copy to.            */\n/*                                                                           */\n        if Newspace < Origspace\n        then do\n            if primary = 1\n            then do\n                ess = ''\n            end\n            else do\n                ess = 'S'\n            end\n            say 'Ooops - The destination dataset is too small! '\n            say '  '\n            say 'The allocation for dataset : '||dsn2\n            say ' Primary allocation        : '||primary||' '||units||ess\n            if second = 1\n            then do\n                ess = ''\n            end\n            else do\n                ess = 'S'\n            end\n            say ' Secondary allocation      : '||second||' '||units||ess\n            say '  '\n            say '  must be greater than or equal to the equivalent of '\n            say '  '\n            say OrigPrim||' primary and '||OrigSec||' secondary '||,\n                Origunit||'S'\n            say '  '\n            say 'Change the allocation and . .  have another go mate ;-) '\n            Displayflag = 1\n        end\n    end\n\n/*                                                                           */\n/* Build variables depending on the dataset characteristics                  */\n/*                                                                           */\n/*                                                                           */\n/* Ensure original dataset is fully qualified.                               */\n/*                                                                           */\n    dsn = ''''||STRIP(TRANSLATE(dsn,' ',''''))||''''\n/*                                                                           */\n/* Ensure destination dataset is fully qualified.                            */\n/*                                                                           */\n    dsn2 = ''''||STRIP(TRANSLATE(dsn2,' ',''''))||''''\n    if WORDS(STRIP(TRANSLATE(dsn2,' ',''''))) = 0\n    then do\n        say 'ERROR : Destination Dataset must be entered !'\n        exit 12\n    end\n    if (units = 'BLOCK')\n    then do\n        theunits = \"BLOCK(\"||blksize||\")\"\n    end\n    else\n    do\n        theunits = units||\" BLKSIZE(\"||blksize||\")\"\n    end\n    if (dssms = 'PDS')\n    then do\n        thedsntp = 'DSNTYPE(PDS)'\n        thedirbk = \"DIR(\"||adirblk||\")\"\n    end\n    else\n    do\n        thedsntp = ' '\n        thedirbk = ' '\n    end\n    recfm1 = SUBSTR(recfm,1,1)\n    recfm2 = SUBSTR(recfm,2,1)\n    recfm3 = SUBSTR(recfm,3,1)\n    therecfm = \"RECFM(\"||recfm1||\" \"||recfm2||\" \"||recfm3||\")\"\n    thelrecl = \"LRECL(\"||lrecl||\")\"\n/*                                                                           */\n/* Issue the TSO ALLOCATE command to allocate the new dataset using the      */\n/* attributes based on the original - but which may have been altered by     */\n/* the user - (ie Change volume, directory blocks, etc . . . )      !!       */\n/*                                                                           */\nAddress TSO\n  \"ALLOC DATASET(\"||dsn2||\") NEW VOLUME(\"||volume||\") UNIT(\"||unit||\") \"||,\n  \"DSORG(\"||dsorg||\") \"||theunits||\" \"||thelrecl||\" \"||therecfm||\" \"||,\n  \"SPACE(\"||primary||\",\"||second||\") RELEASE CATALOG \"||thedsntp||\" \"||thedirbk\n  if (RC > 0)\n  then do\n      say 'TSO dataset allocation has failed with RC : ' RC\n      exit\n  end\n/*                                                                           */\n/* Allocate SYSUT1, SYSUT2, SYSIN, SYSPRINT & SYSOUT to this REXX procedure  */\n/*                                                                           */\nAddress TSO\n    \"ALLOC F(SYSUT1) DSN(\"||dsn||\") VOLUME(\"||ovolume||\") SHR REUSE\"\n    if (RC > 0)\n    then do\n        say 'TSO SYSUT1 allocation has failed with RC : ' RC\n        Call Freedsn2\n        exit\n    end\n    \"ALLOC F(SYSUT2) DSN(\"||dsn2||\") VOLUME(\"||volume||\") SHR REUSE\"\n    if (RC > 0)\n    then do\n        say 'TSO SYSUT2 allocation has failed with RC : ' RC\n        Call Freedsn2\n        exit\n    end\n    \"ALLOC F(SYSIN) DUMMY REUSE\"\n    if (RC > 0)\n    then do\n        Call Freedsn2\n        exit\n    end\n    \"ALLOC F(SYSOUT) DUMMY REUSE\"\n    if (RC > 0)\n    then do\n        Call Freedsn2\n        exit\n    end\n    \"ALLOC F(SYSPRINT) DUMMY REUSE\"\n    if (RC > 0)\n    then do\n        Call Freedsn2\n        exit\n    end\n/*                                                                           */\n/* If the dataset is a PDS, use IEBCOPY to copy the dataset, otherwise use   */\n/* IEBGENER.                                                                 */\n/*                                                                           */\nif (dssms = 'PDS')\nthen do\n    ADDRESS TSO \"TSOEXEC CALL 'SYS1.LINKLIB(iebcopy)'\"\n    if (RC > 0)\n    then do\n        select\n            when RC = 4\n            then do\n                say 'IEBCOPY has failed.'\n                say 'One or more copy groups operations ended unsuccessfully'||,\n                    ' or were incompletely performed.'\n                say 'Recovery may be possible.  Return Code : '||RC\n            end\n            when RC = 8\n            then do\n                say 'IEBCOPY has failed.'\n                say 'An unrecoverable error exists - IEBCOPY ends with '||,\n                    ' Return Code : '||RC\n            end\n            OTHERWISE say 'IEBCOPY run under TSO has failed with RC : ' RC\n        end\n        Call Freedsn2\n        exit\n    end\n    else do\n        say 'IEBCOPY has been invoked . . . and finished with RC : '||RC\n    end\nend\nelse do\n    ADDRESS TSO \"TSOEXEC CALL 'SYS1.LINKLIB(iebgener)'\"\n    if (RC > 0)\n    then do\n        select\n          when RC = 4\n          then do\n              say 'Probable successful completion - please investigate.'\n              say 'Return Code : '||RC\n          end\n          when RC = 8\n          then do\n              say 'Either processing was ended after you requested '||,\n                  'processing of user header labels only,'\n              say 'or a DBCS error was encountered.  Return Code : '||RC\n          end\n          when RC = 12\n          then do\n              say 'Either an unrecoverable error exists and the job step'||,\n                  ' is stopped, or a DBCS error was encountered.'\n              say 'Return Code : '||RC\n          end\n          when RC = 16\n          then do\n             say 'A user routine passed a return code of 16 to IEBGENER.'||\n             say 'Return Code : '||RC\n          end\n          OTHERWISE say 'IEBGENER run under TSO has failed with RC : ' RC\n      end\n      Call Freedsn2\n      exit\n    end\n    else do\n        say 'IEBGENER has been invoked . . . and finished with RC : '||RC\n    end\nend\n/*                                                                           */\n/* Free all allocated datasets                                               */\n/*                                                                           */\n    \"FREE F(SYSUT1)\"\n    if (RC > 0),\n    then do\n        say 'TSO FREE of SYSUT1 has failed with RC : ' RC\n        say 'Warning : Dataset may still be allocated !'\n        Call Freedsn2\n        \"FREE F(SYSIN)\"\n        \"FREE F(SYSOUT)\"\n        \"FREE F(SYSPRINT)\"\n        exit\n    end\n    Call Freedsn2\n    if (RC > 0),\n    then do\n        say 'TSO FREE of SYSUT2 has failed with RC : ' RC\n        say 'Warning : Dataset may still be allocated !'\n        \"FREE F(SYSIN)\"\n        \"FREE F(SYSOUT)\"\n        \"FREE F(SYSPRINT)\"\n        exit\n    end\n    \"FREE F(SYSIN)\"\n    if (RC > 0),\n    then do\n        say 'TSO FREE of SYSIN has failed with RC : ' RC\n        say 'Warning : Dataset may still be allocated !'\n        Call Freedsn2\n        \"FREE F(SYSOUT)\"\n        \"FREE F(SYSPRINT)\"\n        exit\n    end\n    \"FREE F(SYSOUT)\"\n    if (RC > 0),\n    then do\n        say 'TSO FREE of SYSOUT has failed with RC : ' RC\n        say 'Warning : Dataset may still be allocated !'\n        Call Freedsn2\n        \"FREE F(SYSPRINT)\"\n        exit\n    end\n    \"FREE F(SYSPRINT)\"\n    if (RC > 0),\n    then do\n        say 'TSO FREE of SYSPRINT has failed with RC : ' RC\n        say 'Warning : Dataset may still be allocated !'\n        Call Freedsn2\n        exit\n    end\nsay ' '\nsay 'Original Dataset    : ' dsn\nsay 'On volume           : ' ovolume\nsay ' '\nsay '    has been successful copied to ...'\nsay ' '\nsay 'Destination Dataset : ' dsn2\nsay 'On volume           : ' volume\nsay 'Have a nice day :-)'\nsay ' '\nexit 0\n/*                                                                           */\n/* Subroutine which frees the newly created dataset                          */\n/*                                                                           */\nFreedsn2:\n    Address TSO\n        \"FREE dataset(\"||dsn2||\")\"\n        if (RC > 0),\n        then do\n            say 'TSO FREE has failed with RC : ' RC\n            say 'Warning : Datasets may still be allocated !'\n            exit\n        end\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XCPYPNL0": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1f\\x00\\x00\\x01\\x02\\x03\\x0f\\x01\\x02\\x15o\\x11B\\x00\"\\x00/\\x00\\x00\\xe2\\xc8\\xc5\\xd4\\xc9\\xc3@@@@'", "ispf": {"version": "01.31", "flags": 0, "createdate": "2002-01-30T00:00:00", "modifydate": "2002-06-05T11:42:00", "lines": 34, "newlines": 47, "modlines": 0, "user": "SHEMIC"}, "text": ")Attr\n ^ Type(input) intens(high) caps(on)\n $ Type(input) intens(high) caps(on)\n \u00a2 Type(input) intens(low) caps(off)\n # Type(output) intens(high) color(green)\n | Type(text) intens(high) color(green)\n ! Type(text) intens(low) hilite(uscore) color(turq)\n @ Type(text) intens(low) color(turq)\n)BODY EXPAND(\\\\)\n%\\-\\ Extended Copy Facility \\-\\\n%Command ===>_ZCMD                                          %Scroll ===> _SCIN+\n%\n+\n |Original Dataset    : ^dsn                                         +\n |         Volume     : ^ovolume@  {Optional}\n |Destination Dataset : ^dsn2                                        +\n |RACF Protection     : #racfprot\n+\n !XCPY will copy from Original to Destination using following Attributes|\n+\n |Volume       : ^volume+  |Unit        : ^unit+\n |Alloc. Unts  : ^units+   |Blocksize   : ^blksize+ |LRECL        : ^lrecl+\n |Organisation : #dsorg+   |Rec Format  : #recfm+   |Dataset Type : #dssms+\n+\n |Allocated    : #alloc+   |Primary     : ^primary+ |Secondary    : ^second+\n |Dir.Blocks   : ^adirblk+ |Used        : #udirblk+\n+\n+\n @   Enter or overtype details and press ENTER to continue. +\n)Init\n.CURSOR = 'dsn2'\n)Proc\n VPUT (SCIN) PROFILE\n)End\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT576/FILE576.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT576", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}