{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013135000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 999362, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE866.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 999362, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 999362, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE866.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x10\\x0c'", "DS1TRBAL": "b'#\\xfe'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x07^\\x00\\t\\x07_\\x00\\n\\x00\\x11'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04U\\x00\\x11\\x01\\x121\\x9f\\x01\\x121\\x9f\\x141\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf5@@@'", "ispf": {"version": "04.85", "flags": 0, "createdate": "2012-11-14T00:00:00", "modifydate": "2012-11-14T14:31:11", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-485"}, "text": "REGULAR CBT TAPE - VERSION 485    FILE:  866\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT485.FILE866\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 16 MEMBERS COUNTED; CUMULATIVE SIZE IS 9,093 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/14/12    14:31:11    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x12\\x16/\\x01\\x12\\x16/\"H\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-06-10T00:00:00", "modifydate": "2012-06-10T22:48:02", "lines": 27, "newlines": 27, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Batch SPUFI\nFrom:     Vladimir Mestovski <v2gri033@us.ibm.com>\nDate:     6/4/2012 10:19 AM\nTo:       sknutson@cbttape.org, sbgolob@cbttape.org\n\nHello everybody.\n\nI'm attaching a zip with my program called BSPUFI (Batch SPUFI).\nThe program combines all or almost all features of IBM sample\nprogram DSNTEP2/4 (aka SPUFI), DSNTIAUL (Unload), replaces QMF\nproc and queries using SESSION tables (DECLARE GLOBAL TEMPORARY\nTABLE) vs SAVE DATA tables, run DB2 commands and process its\noutput, write out selected reports to a flat file in different\nformats and read those files to db2 tables, and some other\nfeatures. This program is very useful for me, and probably it\nwould be useful for other zOS programmers.\n\nWhen you have some free time please take a look at the attachment\nand let me know your opinion, thanks.\n\n(See attached file: BSPUFI.zip)\nVladimir.\nv2gri033@us.ibm.com\n\nAttachments:\nBSPUFI.zip       143 KB\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE02": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00C\\x01\\x12\\x16/\\x01\\x12\\x16/#\\x04\\x00\\x18\\x00\\x14\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2012-06-10T00:00:00", "modifydate": "2012-06-10T23:04:43", "lines": 24, "newlines": 20, "modlines": 0, "user": "SBGOLOB"}, "text": "Notes on installation.\n\n1.  This package came as a zip of 4 files.  I repackaged them into\n    this pds, and you can reconstruct them as follows:\n\n    A.  The C file - This file's members were copied into File 866.\n\n    B.  The DBRMLIB file - You must RECEIVE this from member DBRMLIB:\n\n        TSO RECEIVE INDS(this.pds(DBRMLIB))\n\n    C.  The LOADLIB file - You must RECEIVE this from member LOADLIB:\n\n        TSO RECEIVE INDS(this.pds(LOADLIB))\n\n    D.  The output of the DEMOJOB.  You must receive this from member\n         DEMOSDSF:\n\n        TSO RECEIVE INDS(this.pds(DEMOSDSF))\n\n    I hope that the rest is self-explanatory.  Good luck.  Please\n    write to the author, not to me.\n\nS.GOLOB  (sbgolob@cbttape.org)   June 10, 2012\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$README": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00)\\x01\\x12\\x15o\\x01\\x12\\x15o\\x08T\\x00\\xe5\\x12\\xa5\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2012-06-04T00:00:00", "modifydate": "2012-06-04T08:54:29", "lines": 229, "newlines": 4773, "modlines": 0, "user": "V2IBAVM"}, "text": "Member list:\n\nBSPUFI     - C program -- Batch SPUFI\nCBSPUFI    - a compile job\nBINDPLAN   - a bind plan job\nDEMOJOB    - a demo job\nDEMOSQL    - input for demo job\nDEMOSQL1   - input for demo job\nOUTSQL     - output SQL w/o tags\n\n/**********************************************************************/\n/*                                                                    */\n/* Title       :  C SQL-DB2-TSO Processor/Executor/Monitor            */\n/*                                                                    */\n/* Author      :  Vladimir Mestovski, IBA, Minsk, Belarus             */\n/*             :  v2gri033@us.ibm.com  -- preffered for bugs          */\n/*             :  mestovsky@iba.by     -- additional                  */\n/*             :  for free use, not for sell                          */\n/*                                                                    */\n/* Environments:  z/OS                                                */\n/*                                                                    */\n/* Function:                                                          */\n/*                                                                    */\n/*  The program reads and executes SQL statements from the INSQL file.*/\n/*  Before execution it substitutes tags from TAGS file (if specified)*/\n/*  and writes adjusted statements to the OUTSQL file (if specified). */\n/*  It also recognizes and executes special comments and functional   */\n/*  commands that can be considered as an extension of SQL(see below).*/\n/*                                                                    */\n/* Parameters:                                                        */\n/*                                                                    */\n/*     INSQL(file) - input file with SQL statements,                  */\n/*                   where 'file' is DD:name or file-name,            */\n/*                   RECFM=FB, LRECL=any-allowed.                     */\n/*      TAGS(file) - input, optional, tags & its values,              */\n/*                   RECFM=FB, LRECL=any-allowed.                     */\n/*    OUTSQL(file) - output, optional, SQL w/o tags                   */\n/*                   RECFM=FB, LRECL=80                               */\n/*        SCAN(ON) - optional, just substitute tags, do not run SQL   */\n/*      PRINT(OFF) - optional, do not print out input statements      */\n/*                                                                    */\n/* Output report:                                                     */\n/*                                                                    */\n/*     DD:SYSPRINT - RECFM=FBA,LRECL=any-allowed                      */\n/*                   No page break, no partitions for select reports, */\n/*                   no extra SQLCA fields, but                       */\n/*                   CPU and TOTAL timings after each SQL statement.  */\n/* Return Codes:                                                      */\n/*             0 - program completed successfully                     */\n/*             4 - warning(s) was issued                              */\n/*             8 - syntax error                                       */\n/*            12 - SQL error happened                                 */\n/*            NN - various errors                                     */\n/*                                                                    */\n/* Functional commands:                                               */\n/* -------------------                                                */\n/* 1. WRITE \u00dddlm\u00a8 {FILE file } \u00ddAPPEND\u00a8 {select-stmnt;   }            */\n/*                {STACK DATA}          {DB2-command;    } (zOS only) */\n/*                                      {DDL select-stmnt}            */\n/*    Writes out a select/DSN report to a file or to internal stack.  */\n/*    Keyword 'dlm' specifies a column delimeter or file format:      */\n/*     CSV   -- CSV format with fixed positions of commas             */\n/*     TAB   -- tab delimeter (x'\\t')                                 */\n/*     COMMA -- comma (',')                                           */\n/*     BAR   -- vertcal bar ('|')                                     */\n/*     NODLM -- without any delimeter                                 */\n/*     ASIS  -- no delimeter, binary file, numbers are not converted  */\n/*     RPT   -- full report with column names                         */\n/*    Default 'dlm' is a blank.                                       */\n/*    Keyword 'file' can be specified as DD:NAME or real file-name.   */\n/*    APPEND allows to write data to the end of the existing file but */\n/*    not to the existing PDS/PDSE member (zOS restriction).          */\n/*    STACK DATA directs output to data memory stack.                 */\n/*                                                                    */\n/* 2. READ \u00dddlm\u00a8 {FILE file1} \u00ddDISCARD \u00ddfile2\u00a8\u00a8                       */\n/*               {STACK DATA}                                         */\n/*       INSERT INTO ... VALUES(*|column-positions);                  */\n/*                                                                    */\n/*    (where dlm is same as WRITE dlm except RPT)                     */\n/*    Read file1 records in and inserts them into a table.            */\n/*    Keyword DISCARD allows to bypass records with wrong data and    */\n/*    write them out to file2 (if specified).                         */\n/*    Column positions specify data position for each column.         */\n/*    Format is like the format of the LOAD utility, for example:     */\n/*    VALUES(1.12,14:15,...)                                          */\n/*    The VALUES(*) tells the program to find fields using dlm.       */\n/*    STACK DATA invokes input from data memory stack.                */\n/*                                                                    */\n/* 3. STACK \u00ddFIFO|LIFO\u00a8 \u00ddDDL\u00a8 select-stmnt;                           */\n/*          \u00ddDATA {\u00ddDDL\u00a8 select-stmnt;|DB2-command;}\u00a8                 */\n/*                                                                    */\n/*    Redirect a select report to the top of program's input (LIFO)   */\n/*    or to the bottom (FIFO-default). The STACK allows to execute    */\n/*    new statement(s) generated by a select-statement.               */\n/*    STACK DATA directs output to data memory stack.                 */\n/*                                                                    */\n/* 4. SAVE DATA AS table select-statement;                            */\n/*                                                                    */\n/*    It works as \"INSERT INTO table select-statement\".               */\n/*    If the table is a SESSION one and it was not declared before    */\n/*    the SESSION table is declared implicitly with fields used in    */\n/*    a select-statement.                                             */\n/*                                                                    */\n/* 5. INCLUDE FILE file;                                              */\n/*                                                                    */\n/*    It adds additional SQL statements from a file to main input.    */\n/*    Embedded INCLUDEs are not allowed.                              */\n/*                                                                    */\n/* 6. DDL \u00ddTABLE name\u00a8 select-statement;                              */\n/*                                                                    */\n/*    It generates                                                    */\n/*        DECLARE GLOBAL TEMPORARY TABLE name (                       */\n/*         column-definitions                                         */\n/*        ) ON COMMIT PRESERVE ROWS;                                  */\n/*    Default name is Tnn.                                            */\n/*                                                                    */\n/* 7. EXPLAIN sql-statement;  (only for z/OS, no PLAN_TABLE on AIX)   */\n/*                                                                    */\n/*    Prepares and displays EXPLAIN report for a given SQL statement. */\n/*    You must have PLAN_TABLE under your user ID or set the current  */\n/*    SQLID to an ID that has such table, for example:                */\n/*       SET CURRENT SQLID='MDCT';                                    */\n/*                                                                    */\n/* 8. SYStem system-command;                                          */\n/*                                                                    */\n/*    Executes a given command (TSO,shell,...) by C-system() function.*/\n/*    Use --#SET SYSRC nn if you need to suppress the nn code.        */\n/*                                                                    */\n/* 9. DB2 command; (AIX only)                                         */\n/*                                                                    */\n/*    Executes a given db2-command.                                   */\n/*    It is the same as \"SYSTEM DB2 command\"                          */\n/*                                                                    */\n/* 10 DB2 -command (zOS only)                                         */\n/*                                                                    */\n/*    Executes a given -DB2command,not DSN one. By default DB2 prints */\n/*    out a report to the SYSPRINT output. Use WRITE before DB2       */\n/*    if you want to redirect its output to a file or data stack for  */\n/*    further processing.                                             */\n/*                                                                    */\n/* 11 CONNECT TO location USER userid USING netrc-file                */\n/*                                                                    */\n/*    Executes CONNECT with the password taken from netrc-file.       */\n/*    (DD:NETRC,'MDCV.PROD.PASSWORD(userid)',/home/userid/.netrc)     */\n/*    'location' and 'userid' are case sensitive for search netrc-file*/\n/*                                                                    */\n/* 12 Conditional functional commands (where n=1-4):                  */\n/*                                                                    */\n/*  - RC=0|4|8;  -- reset the current RC                              */\n/*  - RCn=RC;    -- save the current RC                               */\n/*  - RCn=0|4|8; -- reset saved RCn                                   */\n/*  - IF RC\u00ddn\u00a8=0|4|8 any-statement; -- run a statement when IF is true*/\n/*  - IF RC\u00ddn\u00a8=0|4|8 DO; any-statements; ENDIF;                       */\n/*                                                                    */\n/* 13 Terminating execution:                                          */\n/*                                                                    */\n/*  - END; -- stop processing of input and exit with current RC       */\n/*  - EXIT m|RC\u00ddn\u00a8; -- exit with a given RC (m=0-8,n=1-4);            */\n/*                                                                    */\n/* 14 SAY|ECHO string;                                                */\n/*                                                                    */\n/*    Display string. The command itself is not printed out.          */\n/*                                                                    */\n/* 15. \u00ddEXEC SQL\u00a8 WHENEVER SQLERROR   {ROLLBACK;}  (default)          */\n/*                                    {CONTINUE;}                     */\n/*     \u00ddEXEC SQL\u00a8 WHENEVER SQLWARNING {CONTINUE;}  (default)          */\n/*                                    {SUPPRESS;}                     */\n/*                                    {ROLLBACK;}                     */\n/*    ROLLBACK -- exit with ROLLBACK after the 1st SQL error/warning. */\n/*    CONTINUE -- print out messages and continue processing          */\n/*    SUPPRESS -- do not print out warning messages                   */\n/*                                                                    */\n/* 16. RUNSTATS TABLE table-name other-options; (FISHKILL,not DB2LAB) */\n/*                                                                    */\n/*    It needs the SYSPROC.DSNUTILS stored procedure started correctly*/\n/*    It retrieves the need DB&TSnames from the SYSIBM.SYSTABLES table*/\n/*    and insert them into RUNSTATS clause with TABLESPACE key word.  */\n/*                                                                    */\n/* Special comments:                                                  */\n/* -----------------                                                  */\n/*                                                                    */\n/* --#SET SIGNPOS ON|OFF|NO (default ON)                              */\n/*    OFF does not add a sign position for character numbers          */\n/* --#SET EXCEL ON|OFF    (default ON)                                */\n/*    ON indicates that input file was created by Excel(not fixed pos)*/\n/* --#SET NULLCHAR \u00ddc|BLANK\u00a8  (default '?')                           */\n/*    Specifies a char for a NULL value in a SELECT report            */\n/* --#SET LOADNULL ON|OFF (default OFF)                               */\n/*    ON allows to interpret a NULLCHAR as a NULL for READ command    */\n/* --#SET MULTIROWS nn    (default 100, valid range  1-32767)         */\n/*    Specifies number of multi-rows for SELECT(WRITE) & INSERT(READ) */\n/* --#SET NUMVARS nn      (default 256, valid range 50-32767)         */\n/*    Specifies max number of columns in a table                      */\n/* --#SET SYSRC nn        (default 4,   valid range  0-32   )         */\n/*    Specifies max RC allowed from SYSTEM command                    */\n/* --#SET SQLDLM c        (default ';')                               */\n/*    Specifies a delimeter of statements in INSQL file               */\n/* --#SET TRACE ON|OFF    (default OFF)                               */\n/*    For internal use, display additional info for debugging         */\n/* --#SET SCAN ON|OFF     (default OFF)                               */\n/*    OFF -- do not run any statement, just substitute TAGs           */\n/* --#SET PRINT ON|OFF    (default ON)                                */\n/*    ON -- print out input statements, OFF -- do not print           */\n/* --;                                                                */\n/*    Remove from processing INSQL records beginning with '--;'       */\n/*    Use the comment in the TAG file if you want to hide test stmnts.*/\n/*    <TST>   --;    <-- to hide, do not print out the record         */\n/*    <TST>   null   <-- to actvate                                   */\n/* --!                                                                */\n/*    Print out the line ignoring #SET PRINT OFF                      */\n/*                                                                    */\n/* The program can run any SQL statement that can be                  */\n/* dynamically prepared (see IBM SQL Reference) plus some             */\n/* additional statements:                                             */\n/*                                                                    */\n/*   CONNECT                                                          */\n/*   CONNECT RESET                                                    */\n/*   CONNECT TO location                                              */\n/*   CONNECT TO location USER userid USING netrc-file                 */\n/*                                                                    */\n/* A list of supported SQL Data Types:                                */\n/*                                                                    */\n/*     CHAR      VARCHAR     LONG VARCHAR                             */\n/*     DECIMAL   SMALLINT    INTEGER                                  */\n/*     DATE      TIME        TIMESTAMP                                */\n/*     FLOAT     FLOAT(n)    DOUBLE PRECISION                         */\n/*     REAL                                                           */\n/*                                                                    */\n/**********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE866": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04U\\x00\\x06\\x01\\x121\\x9f\\x01\\x121\\x9f\\x141\\x00\"\\x00\"\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf5@@@'", "ispf": {"version": "04.85", "flags": 0, "createdate": "2012-11-14T00:00:00", "modifydate": "2012-11-14T14:31:06", "lines": 34, "newlines": 34, "modlines": 0, "user": "CBT-485"}, "text": "//***FILE 866 is from Vladimir Mestovski and contains a program     *   FILE 866\n//*           called BSPUFI (Batch SPUFI or C SQL-DB2-TSO           *   FILE 866\n//*           Processor)                                            *   FILE 866\n//*                                                                 *   FILE 866\n//*   Author      :  Vladimir Mestovski, IBA, Minsk, Belarus        *   FILE 866\n//*   ------      :  v2gri033@us.ibm.com  -- preferred for bugs     *   FILE 866\n//*               :  mestovsky@iba.by     -- additional email       *   FILE 866\n//*               :  This program is for free use, not for sale.    *   FILE 866\n//*                                                                 *   FILE 866\n//*   Short description:                                            *   FILE 866\n//*                                                                 *   FILE 866\n//*     The program reads an input file with SQL/DB2/TSO            *   FILE 866\n//*     statements/ commands and executes them. After each SQL      *   FILE 866\n//*     the program prints out CPU and TOTAL times what helps to    *   FILE 866\n//*     create effective SQL.  You can start SQL statements with    *   FILE 866\n//*     special internal commands like WRITE for a SELECT to        *   FILE 866\n//*     redirect its report in different formats                    *   FILE 866\n//*     (CSV,TAB,ASIS,RPT,...) to a flat file or internal data      *   FILE 866\n//*     stacks, or READ for an INSERT to load input into a          *   FILE 866\n//*     table.  You can program conditional execution of SQL        *   FILE 866\n//*     statements using labels, special variables RC\u00ddn\u00a8 and        *   FILE 866\n//*     commands IF,GOTO/SKIP...  See other features of \"mySQL      *   FILE 866\n//*     for zOS\" in the program's header.                           *   FILE 866\n//*                                                                 *   FILE 866\n//*   List of members:                                              *   FILE 866\n//*                                                                 *   FILE 866\n//*     BSPUFI  -- source C code                                    *   FILE 866\n//*     CBSPUFI -- compile/bind job                                 *   FILE 866\n//*     DEMOJOB -- demo job                                         *   FILE 866\n//*     DEMOSQL -- main input SQL for demo job                      *   FILE 866\n//*     DEMOSQL1-- aux input SQL for demo job                       *   FILE 866\n//*     SQL     -- ISPF Edit Macro to run the program               *   FILE 866\n//*                in interactive mode                              *   FILE 866\n//*                                                                 *   FILE 866\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BINDPLAN": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01K\\x005\\x01\\x12\\x04o\\x01\\x12\\x15o\\x08H\\x00*\\x00\\x95\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.75", "flags": 0, "createdate": "2012-02-15T00:00:00", "modifydate": "2012-06-04T08:48:35", "lines": 42, "newlines": 149, "modlines": 0, "user": "V2IBAVM"}, "text": "//BINDPLAN JOB ($2919BA,BIN070,FSH334,DEPT19BA),'BIND',\n//       NOTIFY=&SYSUID,MSGCLASS=H,MSGLEVEL=(1,1),TIME=5\n//*\n//* GLOBAL VARIABLES\n// SET     M=BSPUFI                          C/C++ MEMBER NAME\n// SET     L=&M                              LOAD MODULE NAME\n// SET     D=&M                              DBRM NAME\n// SET   DB2=DB2E                            SSID\n// SET  PLAN=&M                              PLAN NAME\n//*\n// SET  CLIB=&SYSUID..CBT.BSPUFI.C\n// SET  LLIB=&SYSUID..CBT.BSPUFI.LOADLIB\n// SET  DLIB=&SYSUID..CBT.BSPUFI.DBRMLIB\n//*\n//* BIND PLAN\n//*\n//BIND    EXEC PGM=IKJEFT01,DYNAMNBR=20,\n// PARM='DSN SYSTEM(&DB2)'\n//DBRMLIB  DD DSN=&DLIB(&D),DISP=SHR\n//SYSTSPRT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD DUMMY\n//SYSTSIN  DD *\n    BIND PLAN(BSPUFI) MEMBER(BSPUFI) VALIDATE(BIND) -\n    ISOLATION(CS) ACQUIRE(USE) EXPLAIN(NO)\n    END\n/*\n//*\n//*  GRANTS\n//*\n//GRANTS  EXEC PGM=IKJEFT01,DYNAMNBR=20,COND=(4,LT),\n// PARM='DSN SYSTEM(&DB2)'\n//*\n//STEPLIB  DD DSN=&LLIB,DISP=SHR\n//SYSTSIN  DD *\n RUN PROG(BSPUFI) PLAN(BSPUFI) +\n  PARMS('INSQL(DD:SYSIN)')\n//SYSTSPRT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n GRANT EXECUTE ON PLAN BSPUFI TO PUBLIC;\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BSPUFI": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x121\\x9f\\x01\\x121\\x9f\\x065\\x15E\\x15E\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-11-14T00:00:00", "modifydate": "2012-11-14T06:35:22", "lines": 5445, "newlines": 5445, "modlines": 0, "user": "V2IBAVM"}, "text": "       const char pgm_ver\u00dd\u00a8=\"Version 2012-10-31\";\n       const char pgm_tit\u00dd\u00a8=\"C SQL-DB2-TSO Processor\";\n       const char pgm_dev\u00dd\u00a8=\"Vladimir Mestovski,IBA,Minsk\";\n       const char pgm_env\u00dd\u00a8=\"zOS\";\n/**********************************************************************/\n/*                                                                    */\n/* Title       :  C SQL-DB2-TSO Processor                             */\n/*                                                                    */\n/* Author      :  Vladimir Mestovski, IBA, Minsk, Belarus             */\n/*             :  v2gri033@us.ibm.com  -- for bugs                    */\n/*             :  mestovsky@iba.by     -- alternative                 */\n/*                                                                    */\n/* Environments:  z/OS (possible AIX,Windows)                         */\n/*                                                                    */\n/* Function:                                                          */\n/*                                                                    */\n/*  The program reads and executes SQL statements from the INSQL file.*/\n/*  Before execution it substitutes tags from TAGS file (if specified)*/\n/*  and writes adjusted statements to the OUTSQL file (if specified). */\n/*  It also recognizes and executes special comments and functional   */\n/*  commands that can be considered as an extension of SQL(see below).*/\n/*  By default the program runs a ROLLBACK after the 1st SQL error    */\n/*  occured, prints out select reports in QMF style, write a select   */\n/*  report to a file or internal stack, read a file/stack to a table, */\n/*  execute EXPLAIN, draw column names of a table...and more.         */\n/*                                                                    */\n/* Parameters:                                                        */\n/*                                                                    */\n/*     INSQL(file) - input file with SQL statements w/o seq numbering */\n/*                   where 'file' is DD:name or file-name             */\n/*                   RECFM=FB|VB|U, LRECL=any-allowed.                */\n/*      TAGS(file) - input, optional, tags & its values,              */\n/*                   RECFM=FB|VB|U, LRECL=any-allowed.                */\n/*    OUTSQL(file) - output, optional, SQL w/o tags                   */\n/*                   RECFM=FB, LRECL=80                               */\n/*       LOG(file) - output, optional, a copy of sysout/SYSPRINT      */\n/*                   RECFM=FBA,LRECL=any-allowed                      */\n/*        SCAN(ON) - optional, just substitute tags, do not run SQL   */\n/*      PRINT(OFF) - optional, do not print out input statements      */\n/*                                                                    */\n/* Output report:                                                     */\n/*                                                                    */\n/*     DD:SYSPRINT - RECFM=FBA,LRECL=any-allowed                      */\n/*                   No page break, no partitions for select reports, */\n/*                   no extra SQLCA fields, but                       */\n/*                   CPU and TOTAL timings after each SQL statement.  */\n/* Return Codes:                                                      */\n/*             0 - program completed successfully                     */\n/*             4 - warning(s) was issued                              */\n/*             8 - syntax error                                       */\n/*            12 - SQL error happened                                 */\n/*            NN - various errors                                     */\n/*                                                                    */\n/* Functional commands:                                               */\n/* -------------------                                                */\n/* 1. WRITE \u00dddlm\u00a8 {FILE file } \u00ddAPPEND\u00a8  {select-stmnt;           }   */\n/*                {STACK DATA}           {DB2 -command; (zOS only)}   */\n/*                {STACK LABEL label\u00dd:\u00a8} {DDL select-stmnt        }   */\n/*                                       {ECHO text               }   */\n/*                                                                    */\n/*    Writes out a select|DB2|DDL report to a file or memory stack.   */\n/*    Keyword 'dlm' specifies a column delimeter or file format:      */\n/*     CSV   -- CSV format with fixed positions of commas, double     */\n/*              quotes (\") in data, if exist, are replaced with       */\n/*              with single ones (')                                  */\n/*     TAB   -- tab delimeter (x'\\t')                                 */\n/*     COMMA -- comma (',')                                           */\n/*     BAR   -- vertcal bar ('|')                                     */\n/*     NODLM -- without any delimeter                                 */\n/*     ASIS  -- no delimeter, binary file, numbers are not converted  */\n/*     RPT   -- full report with column names                         */\n/*    Default 'dlm' is a blank.                                       */\n/*    Keyword 'file' can be specified as DD:NAME or real file-name.   */\n/*    APPEND allows to write data to the end of the existing file but */\n/*    not to the existing PDS/PDSE member (zOS restriction).          */\n/*    STACK tells the program to write data to unnamed DATA memory    */\n/*    stack or to named by 'label' LABEL stack.                       */\n/*                                                                    */\n/* 2. READ \u00dddlm\u00a8 {FILE file1          } \u00ddDISCARD \u00ddfile2\u00a8\u00a8             */\n/*               {STACK DATA          }                               */\n/*               {STACK LABEL label\u00dd:\u00a8}                               */\n/*       INSERT INTO ... VALUES(*|column-positions);                  */\n/*                                                                    */\n/*    (where dlm is same as WRITE dlm excluding RPT)                  */\n/*    Read file1 records in and inserts them into a table.            */\n/*    Keyword DISCARD allows to bypass records with wrong data and    */\n/*    write them out to file2 (if specified).                         */\n/*    Column positions specify data position for each column.         */\n/*    Format is like the format of the LOAD utility, for example:     */\n/*    VALUES(1.12,14:15,...)                                          */\n/*    The VALUES(*) tells the program to find fields using dlm.       */\n/*    STACK retrieves input from data memory stacks.                  */\n/*                                                                    */\n/* 3. STACK \u00ddLIFO          \u00a8 {select-stmnt;            }              */\n/*          \u00ddFIFO          \u00a8 {DDL select-stmnt;        }              */\n/*          \u00ddDATA          \u00a8 {DB2 -command; (zOS only) }              */\n/*          \u00ddLABEL label\u00dd:\u00a8\u00a8 {ECHO text;               }              */\n/*                                                                    */\n/*    The STACK saves output of the SELECT/DDL/DB2 clause in special  */\n/*    memory stacks. The program reads stack LIFO as input at once,   */\n/*    stack FIFO at the end of main input, stacks LABEL when          */\n/*    specified labels found in input stream (max 50 stacks allowed). */\n/*    Stack DATA is used as a temporary memory file.                  */\n/*                                                                    */\n/* 4. SAVE DATA AS table select-statement;                            */\n/*                                                                    */\n/*    It works as \"INSERT INTO table select-statement\".               */\n/*    If the table is a SESSION one and it was not declared before    */\n/*    the SESSION table is declared implicitly with fields used in    */\n/*    a select-statement.                                             */\n/*                                                                    */\n/* 5. INCLUDE FILE file;                                              */\n/*                                                                    */\n/*    It adds additional SQL statements from a file to main input.    */\n/*    Embedded INCLUDEs are not allowed for now.                      */\n/*                                                                    */\n/* 6. DDL \u00ddTABLE name\u00a8 select-statement;                              */\n/*                                                                    */\n/*    It generates DDL for a session table based on a select stmnt:   */\n/*        DECLARE GLOBAL TEMPORARY TABLE name (                       */\n/*         column-definitions                                         */\n/*        ) ON COMMIT PRESERVE ROWS;                                  */\n/*    Default name is Tnn.                                            */\n/*                                                                    */\n/* 7. EXPLAIN sql-statement;  (only for z/OS, no PLAN_TABLE on AIX)   */\n/*                                                                    */\n/*    Prepares and displays EXPLAIN report for a given SQL statement. */\n/*    You must have PLAN_TABLE under your user ID or set the current  */\n/*    SQLID to an ID that has such table, for example:                */\n/*       SET CURRENT SQLID='MDCT';                                    */\n/*                                                                    */\n/* 8. SYStem system-command;                                          */\n/*                                                                    */\n/*    Executes a given command (TSO,shell,...) by C-system() function.*/\n/*    Use --#SET SYSRC nn if you need to suppress the nn code.        */\n/*                                                                    */\n/* 9. DB2 command; (AIX only)                                         */\n/*                                                                    */\n/*    Executes a given db2-command.                                   */\n/*    It is the same as \"SYSTEM DB2 command\"                          */\n/*                                                                    */\n/* 10 DB2 -command (zOS only)                                         */\n/*                                                                    */\n/*    Executes a given -DB2command,not DSN one. By default DB2 prints */\n/*    out a report to the SYSPRINT output. Use WRITE before DB2       */\n/*    if you want to redirect its output to a file or data stack for  */\n/*    further processing.                                             */\n/*                                                                    */\n/* 11 CONNECT TO location USER userid USING netrc-file                */\n/*                                                                    */\n/*    Executes CONNECT with the password taken from netrc-file.       */\n/*    (DD:NETRC,'MDCV.PROD.PASSWORD(userid)',/home/userid/.netrc)     */\n/*    'location' and 'userid' are case sensitive for search netrc-file*/\n/*                                                                    */\n/* 12 Conditional functional commands (where n=1-4):                  */\n/*                                                                    */\n/*  - RC=0|4|8;  -- reset the current RC                              */\n/*  - RCn=RC;    -- save the current RC                               */\n/*  - RCn=0|4|8; -- reset saved RCn                                   */\n/*  - IF RC\u00ddn\u00a8=0|4|8 any-statement; -- run a statement when IF is true*/\n/*  - IF SQLCODE=code any-statement; -- run a stment when IF is true  */\n/*  - IF RC\u00ddn\u00a8=0|4|8  DO; any-statements; ENDIF;                      */\n/*  - IF SQLCODE=code DO; any-statements; ENDIF;                      */\n/*                                                                    */\n/* 13 Terminating execution:                                          */\n/*                                                                    */\n/*  - END; -- stop processing of input and exit with current RC       */\n/*  - EXIT m|RC\u00ddn\u00a8; -- exit with a given RC (m=0-8,n=1-4);            */\n/*                                                                    */\n/* 14 ECHO string;                                                    */\n/*                                                                    */\n/*    Display string. The command itself is not printed out.          */\n/*    Can be used together with WRITE&READ STACK statements:          */\n/*      WRITE STACK DATA ECHO string; -- put a string to data stack   */\n/*      READ  STACK DATA ECHO \u00ddnn\u00a8 \u00ddstring\u00a8 -- read and print out     */\n/*       'nn' records from data stack, 'string' here is a header.     */\n/*       Default value for 'nn' is 32700.                             */\n/*                                                                    */\n/* 15 SAY message;                                                    */\n/*                                                                    */\n/*    Print out a message ignoring PRINT(OFF) parameter.              */\n/*                                                                    */\n/* 16. WHENEVER {SQLERROR  } {ROLLBACK;  } <-- (default)              */\n/*              {SQLWARNING} {SUPPRESS;  }                            */\n/*                           {CONTINUE;  }                            */\n/*                           {GOTO label;}                            */\n/*                                                                    */\n/*    ROLLBACK -- exit with ROLLBACK after the 1st SQL error/warning. */\n/*    CONTINUE -- print out messages and continue processing          */\n/*    SUPPRESS -- do not print out error/warning messages             */\n/*    GOTO label -- go forward to a label                             */\n/*                                                                    */\n/* 17. RUNSTATS TABLE table-name other-options; (FISHKILL,not DB2LAB) */\n/*                                                                    */\n/*    It needs the SYSPROC.DSNUTILS stored procedure started correctly*/\n/*    It retrieves the need DB&TSnames from the SYSIBM.SYSTABLES table*/\n/*    and insert them into RUNSTATS clause with TABLESPACE key-word.  */\n/*                                                                    */\n/* 18. SKIP label\u00dd:\u00a8                                                  */\n/*     GOTO label\u00dd:\u00a8                                                  */\n/*    Bypass input till label: starting in the column 1               */\n/*                                                                    */\n/* 19. DRAW COLNAMES table                                            */\n/*                                                                    */\n/*    Draw column names for a table. Use together with                */\n/*      STACK LABEL label                                             */\n/*    to redirect a column name list to the need select statement     */\n/*    when a history table is copied to an odrinary one.              */\n/*                                                                    */\n/* 20. PRINT SQLERROR;                                                */\n/*                                                                    */\n/* Special comments:                                                  */\n/* -----------------                                                  */\n/*                                                                    */\n/* --#SET SIGNPOS ON|OFF|NO (default ON)                              */\n/*    OFF does not add a sign position for character numbers          */\n/* --#SET EXCEL ON|OFF    (default ON)                                */\n/*    ON indicates that input file was created by Excel(not fixed pos)*/\n/* --#SET NULLCHAR \u00ddc|BLANK\u00a8  (default '?')                           */\n/*    Specifies a char for a NULL value in a SELECT report            */\n/* --#SET LOADNULL ON|OFF (default OFF)                               */\n/*    ON allows to interpret a NULLCHAR as a NULL for READ command    */\n/* --#SET MULTIROWS nn    (default 100, valid range  1-32767)         */\n/*    Specifies number of multi-rows for SELECT(WRITE) & INSERT(READ) */\n/* --#SET NUMVARS nn      (default 256, valid range 50-32767)         */\n/*    Specifies max number of columns in a table                      */\n/* --#SET SYSRC nn        (default 4,   valid range  0-32   )         */\n/*    Specifies max RC allowed from SYSTEM command                    */\n/* --#SET SQLDLM c        (default ';')                               */\n/* --#SET TERMINATOR c    (default ';')             (like DSNTEP2/4)  */\n/*    Specifies a delimeter of statements in INSQL file               */\n/* --#SET TRACE ON|OFF    (default OFF)                               */\n/*    For internal use, display additional info for debugging         */\n/* --#SET SCAN ON|OFF     (default OFF)                               */\n/*    OFF -- do not run any statement, just substitute TAGs           */\n/* --#SET PRINT ON|OFF    (default ON)                                */\n/*    ON -- print out input statements, OFF -- do not print           */\n/* --;                                                                */\n/*    Remove from processing INSQL records beginning with '--;'       */\n/*    Use the comment in the TAG file if you want to hide test stmnts.*/\n/*    <TST>   --;    <-- to hide, do not print out the record         */\n/*    <TST>   null   <-- to actvate                                   */\n/* --!                                                                */\n/*    Print out the line ignoring #SET PRINT OFF                      */\n/* --#SET LABELS ON|OFF   (default ON)                                */\n/*    ON -- treat the 'string:' starting at column 1 as a label,      */\n/*          the rest of the input line is ignored.                    */\n/*                                                                    */\n/* The program can run any SQL statement that can be                  */\n/* dynamically prepared (see IBM SQL Reference) plus some             */\n/* additional statements:                                             */\n/*                                                                    */\n/*   CONNECT                                                          */\n/*   CONNECT RESET                                                    */\n/*   CONNECT TO location                                              */\n/*   CONNECT TO location USER userid USING netrc-file                 */\n/*   WHENEVER                                                         */\n/*                                                                    */\n/* A list of supported SQL Data Types:                                */\n/*                                                                    */\n/*     CHAR      VARCHAR     LONG VARCHAR                             */\n/*     DECIMAL   SMALLINT    INTEGER      BIGINT                      */\n/*     DATE      TIME        TIMESTAMP                                */\n/*     FLOAT     FLOAT(n)    DOUBLE PRECISION                         */\n/*     REAL      BINARY      VARBINARY                                */\n/*     DECFLOAT(partly)                                               */\n/*                                                                    */\n/**********************************************************************/\n/* SQLCA stucture:                                                    */\n/* ----------------                                                   */\n/*  struct sqlca                                                      */\n/*    { unsigned  char     sqlcaid\u00dd8\u00a8;                                */\n/*                long     sqlcabc;                                   */\n/*                long     sqlcode;                                   */\n/*                short    sqlerrml;                                  */\n/*      unsigned  char     sqlerrmc\u00dd70\u00a8;                              */\n/*      unsigned  char     sqlerrp\u00dd8\u00a8;                                */\n/*                long     sqlerrd\u00dd6\u00a8;                                */\n/*      unsigned  char     sqlwarn\u00dd11\u00a8;                               */\n/*      unsigned  char     sqlstate\u00dd5\u00a8;                               */\n/*    } ;                                                             */\n/*  struct sqlca sqlca;                                               */\n/*                                                                    */\n/* SQLDA stuctures:                                                   */\n/* +-------------------------------+                                  */\n/* :struct sqlda                   :                                  */\n/* :     { char   sqldaid\u00dd8\u00a8;      :                                  */\n/* :       long   sqldabc;         :                                  */\n/* :       short  sqln;            :     For each column:             */\n/* :       short  sqld;            :     +--------------------------+ */\n/* :       struct sqlvar sqlvar\u00dd1\u00a8;: --> :struct sqlvar             : */\n/* :     };                        :     :   { short  sqltype;      : */\n/* +-------------------------------+     :     short  sqllen;       : */\n/* +---- not supported ------------+     :     char  *sqldata;      : */\n/* :struct sqlvar2                 :     :     short *sqlind;       : */\n/* :     { struct                  :     :     struct sqlname       : */\n/* :       { long   sqllonglen;    :     :        { short  length;  : */\n/* :       unsigned long reserved; :     :          char   data\u00dd30\u00a8;: */\n/* :       } len;                  :     :        } sqlname;        : */\n/* :       char  *sqldatalen;      :     :   };                     : */\n/* :       struct sqldistinct_type :     +--------------------------+ */\n/* :        { short  length;       :                                  */\n/* :          char   data\u00dd30\u00a8;     :                                  */\n/* :        } sqldatatype_name;    :                                  */\n/* :     };                        :                                  */\n/* +-------------------------------+                                  */\n/**********************************************************************/\n//\n// Macros for brief coding:\n// ------------------------\n#define SQLERRD3    sqlca.sqlerrd\u00dd2\u00a8\n#define SQLERRM     sqlca.sqlerrmc\n#define SQLERRL     sqlca.sqlerrml\n#define SQLDAid     pSQLDA->sqldaid\n#define SQLDAbc     pSQLDA->sqldabc\n#define SQLn        pSQLDA->sqln\n#define SQLd        pSQLDA->sqld\n#define SQLTYPE(i)  pSQLDA->sqlvar\u00ddi\u00a8.sqltype\n#define SQLDATA(i)  pSQLDA->sqlvar\u00ddi\u00a8.sqldata\n#define SQLIND(i)   pSQLDA->sqlvar\u00ddi\u00a8.sqlind\n#define SQLLEN(i)   pSQLDA->sqlvar\u00ddi\u00a8.sqllen\n#define SQLNAMEL(i) pSQLDA->sqlvar\u00ddi\u00a8.sqlname.length\n#define SQLNAMED(i) pSQLDA->sqlvar\u00ddi\u00a8.sqlname.data\n//\n// SQLTYPE values:\n// ---------------\n// Date,Time, Time stamp\n#define   sDATE       384\n#define   sDATEn      385\n#define   sTIME       388\n#define   sTIMEn      389\n#define   sTIMESTAMP  392\n#define   sTIMESTAMPn 393\n// Binary LOB, Char LOB,\n#define   sBLOB       404\n#define   sBLOBn      405\n#define   sCLOB       408\n#define   sCLOBn      409\n#define   sDBCLOB     412\n#define   sDBCLOBn    413\n// CHAR, Var CHAR, Long Var CHAR\n#define   sVCHAR      448\n#define   sVCHARn     449\n#define   sCHAR       452\n#define   sCHARn      453\n#define   sLVCHAR     456\n#define   sLVCHARn    457\n// GRAPHIC  Var CHAR, Long\n#define   sGVCHAR     464\n#define   sGVCHARn    465\n#define   sGCHAR      468\n#define   sGCHARn     469\n#define   sGLCHAR     472\n#define   sGLCHARn    473\n// FLOAT\n#define   sFLOAT      480\n#define   sFLOATn     481\n// PACKED DECIMAL\n#define   sDEC        484\n#define   sDECn       485\n// BIGINT                     // new in V9.1\n#define   sBIGINT     492\n#define   sBIGINTn    493\n// INTEGER\n#define   sINT        496\n#define   sINTn       497\n// SMALL INTEGER\n#define   sSMINT      500\n#define   sSMINTn     501\n// ROWID\n#define   sROWID      904\n#define   sROWIDn     905\n// VARBINARY                  // new in V9.1\n#define   sVARBIN     908\n#define   sVARBINn    909\n// BINARY                     // new in V9.1\n#define   sBIN        912\n#define   sBINn       913\n// BLOB LOCATOR\n#define   sBLOBLOC    960\n#define   sBLOBLOCn   961\n// CLOB LOCATOR\n#define   sCLOBLOC    964\n#define   sCLOBLOCn   965\n// DBCLOB LOCATOR\n#define   sDBCLOBLOC  968\n#define   sDBCLOBLOCn 969\n// DECFLOAT(16)|(34)         // new in V9.1 (8,16)\n#define   sDECFLOAT   996\n#define   sDECFLOATn  997\n// XML\n#define   sXML        988\n#define   sXMLn       989\n//\n#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <math.h>\n#include <search.h>\n#include <errno.h>\n#include <time.h>\n#include <cfloat>\n#include <limits>\n\nusing namespace std;\n\n#define NO       0\n#define OFF      0\n#define ON       1\n#define YES      1\n#define EQUALS   0\n#define Max(a,b) (((a)>(b)) ? (a) : (b))\n#define min(a,b) (((a)>(b)) ? (b) : (a))\n#define MAXSQLSIZE 32700\n#define RETURN_LEN 80000               /* Length of IFI return buffer*/\n\n/*****************************************************************/\n/*                                                               */\n/* Declaration of internal functions                             */\n/*                                                               */\n/*****************************************************************/\n\n  void printHexChars(char* p, int n);\n  void printSQLDA(void);\n  void processSQLwarning(char * Msg);\n  void processSQLerror(char * Msg);\n  void processSQLCODE(char * Msg);\n  void PrintSqlError(char * ErrorMsg);\n char* get_parm(int argc,char* argv\u00dd\u00a8,\n                char* skey, char* ekey, char* defvalue);\n char* strip(char *buf, char action);\n char* strNcpy(char* str1,char *str2, int sizeofstr1);\n char* findword(char* str, int n, int &outlen);\n  void getwords(char* str,short n, char Upcase);\n   int words(char* str);\ndouble CPUtime(double t);\nunsigned int TOTALtime(unsigned int t);\n  void printCTM(void);\n  void Exit(int rc);\n   int freadbin(  char* fileName,  // IN:    DD:ddname/file name\n                 FILE** fp,        // OUTIN: file pointer\n                  char* buf,       // INOUT: buffer\n                    int bufsize,   // IN:    number bytes to read\n                   int* eof,       // OUT:   =1, if EOF\n                  long* ctr,       // OUT:   record counter\n                  char* msg ) ;    // OUT:   error message\n   int fgetstr(   char* fileName,  // IN:    DD:ddname\n                 FILE** fp,        // OUTIN: file pointer\n                  char* buf,       // INOUT: buffer\n                    int bufsize,   // IN:    sizeof(buf)\n                   int* eof,       // OUT:   =1, if EOF\n                  long* ctr,       // OUT:   record counter\n                  char* msg );     // OUT:   error message\n  void resetGlobalVariables(void) ;\n  void LOAD_TAGS_ARRAY(void) ;\n  void allocSQLDA(short n) ;\n  void OPEN_INIT(int argc, char *argv\u00dd\u00a8);\n  void replaceTags(void) ;\n  void PROCESS_FUNCTIONAL_SET(void);\n char* getFIFO(char *out) ;\n char* getLIFO(char *out) ;\n int   getLABEL(char *out) ;\n void  getIFDO(void);\n  void READ_INPUT_LINE(void);\n  void APPEND_INPUT_TO_STMNT(void);\n char* processEXEC()   ;\n  void processCONNECT() ;\n  void printCONNECTinfo();\n char* processSET()    ;\n char* processRELEASE() ;\n char* processWRITE(void)  ;\n char* processSAVE(void)  ;\n void  processDDL(void)  ;\n void  processINCLUDE(void)  ;\n char* processREAD(void)  ;\n  void syntaxRWerror(short i) ;\n   int checkSQLd(void) ;\n  void describeINSERT(char *p) ;\n char* checkdigits(char *p);\n  void parseVALUES(char *p);\n char* processEXPLAIN();\n char* processSTACK();\n  void processEND(void);\n  void processSAY(void);\n  void processECHO(void);\n char* processIF(void);\n  void processRC(void);\n  void processEXIT(void);\n  void processSYSTEM();\n  void processDB2();\n short checkforLABEL();\n  void PREPROCESS_SQL_STMNT(void);\n  void parseColumnLength(void);\n  void parseColumnNames(void);\n  void openWRITE(void);\n  void openDISCARD(void);\n  long writeRecord(FILE *fp, char *fn, char *buf,\n                   long *cnt,long lrecl);\n  void outBUFrecord(void);\n  void printDashes(char *po,struct COLNAME *pn);\n  void printColumnNames(void);\n   int checkint(char* p, short len, short maxn);\n   int checkdatetime(char* p, short len);\n   int checkfloat(char* p);\n   int char2dec(char* sqldata,\n                char* inbuf,  short inlen);\n  void shift4bits(unsigned char *p,short len);\n  void dec2char(char* sqldata,\n                char* outbuf,  short outlen);\n  void printC1rows(short n);\n  void freeSQLDA(void);\n  void allocSQLVARarrays(short n);\n  void executeSELECT(void);\n   int fillCOLPOSarray(char *ps);\n  void loadSQLDATAarrays(void);\n  long processDISCARDrows(long code);\n  void executeSTATEMENT(void);\n  void printHelpExplain(void);\n  void POSTPROCESS_SQL_STMNT(void);\n  void PROCESS_SQL_STMNT(void);\n   int callIFI(char *);\n char* getIFIline(int i,char* out);\n void DsnUtilsClearParms();\n void callDsnUtils();\n void runStatsTableSpace\n    ( char          *uId,\n      char          *restart,\n      char          *utStmt);\n void processRUNSTATS(void);\n void getDBTSnames(char* table);\n void processLOCK(void);\n void displyTSstatus(int);\n void processWHENEVER(void);\n void print904info(void);\n void print911info(void);\n void processSKIP(void);\n void processPRINT(void);\n void writeOUTSQLline(void);\nshort prepareSTACKlabel(char*);\nshort extractLABEL(char* str,short len, char* label);\n void strUXcpy(char*,char*,short);\nshort strPXcpy(char*,char*,short);\n\n/*****************************************************************/\n/*                                                               */\n/* Declaration of the DB2 structures and cursors                 */\n/*                                                               */\n/*****************************************************************/\n\n\n       EXEC SQL INCLUDE SQLCA;\n       EXEC SQL INCLUDE SQLDA;\n\n       EXEC SQL DECLARE STMNT1 STATEMENT;\n       EXEC SQL DECLARE STMNT2 STATEMENT;\n\n       EXEC SQL DECLARE C1 CURSOR\n         WITH ROWSET POSITIONING\n              FOR STMNT1;\n\n       EXEC SQL DECLARE C2 CURSOR\n              FOR STMNT2;\n/*---------------------------------------------------------------*/\n/* Host variables for DB2                                        */\n/*---------------------------------------------------------------*/\n\nstruct sqlda *pSQLDA;\n\nEXEC SQL BEGIN DECLARE SECTION;\n\nstruct {\n   short Len;\n   char  Str\u00dd32700\u00a8;\n} SQL;\n\nstruct {\n   short Len;\n   char  Str\u00dd32700\u00a8;\n} SELECT;\n\nstruct {\n short len;\n  char data\u00dd80\u00a8;\n} attr;\n\nstruct {\n short len;\n  char str\u00dd17\u00a8;\n} password;\n\nstruct {\n short len;\n  char str\u00dd17\u00a8;\n} userid;\n\n//--------------------------------------------------------------//\n// GET DIAGNOSTICS variables                                    //\n//--------------------------------------------------------------//\n           long iERROR;\n           long nERROR;\n           long row_count;\n           long row_num;\n          short multiRows=100,m1=1;\n\n short SCODE;\n  char SMESSAGE\u00dd4095\u00a8;\n  char SSTATE\u00dd6\u00a8;\n short TOKEN_COUNT;\n  char TOKEN1\u00dd30\u00a8;\n  char TOKEN2\u00dd30\u00a8;\n  char TOKEN3\u00dd30\u00a8;\n  char server_class\u00dd51\u00a8;\n  char   product_id\u00dd11\u00a8;\n  char     location\u00dd17\u00a8;\n  char       server\u00dd17\u00a8;\n  char connect_info\u00dd51\u00a8;\n  char ctm\u00dd28\u00a8;\n\n //    EXEC SQL BEGIN DECLARE SECTION;\n         char          uId\u00dd17\u00a8;        // Utility ID\n         char          restart\u00dd9\u00a8;     // Utility restart point\n         char          utStmt\u00dd32705\u00a8;  // Utility control statement\n         long int      retCode;        // Highest retcode from utility\n         char          utility\u00dd21\u00a8;    // Utility name\n                                       // Data Definition: SYSREC\n         char          recDsn\u00dd45\u00a8;     // ..data set name\n         char          recDevt\u00dd9\u00a8;     // ..device type\n         short int     recSpace;       // ..no. of cylinders (primary)\n                                       // Data Definition: SYSDISC\n         char          discDsn\u00dd45\u00a8;    // ..data set name\n         char          discDevt\u00dd9\u00a8;    // ..device type\n         short int     discSpace;      // ..no. of cylinders (primary)\n                                       // Data Definition: SYSPUNCH\n         char          pnchDsn\u00dd45\u00a8;    // ..data set name\n         char          pnchDevt\u00dd9\u00a8;    // ..device type\n         short int     pnchSpace;      // ..no. of cylinders (primary)\n                                       // Data Definition: SYSCOPY\n         char          copyDsn1\u00dd45\u00a8;   // ..data set name\n         char          copyDevt1\u00dd9\u00a8;   // ..device type\n         short int     copySpace1;     // ..no. of cylinders (primary)\n                                       // Data Definition: SYSCOPY2\n         char          copyDsn2\u00dd45\u00a8;   // ..data set name\n         char          copyDevt2\u00dd9\u00a8;   // ..device type\n         short int     copySpace2;     // ..no. of cylinders (primary)\n                                       // Data Definition: SYSRCPY1\n         char          rcpyDsn1\u00dd45\u00a8;   // ..data set name\n         char          rcpyDevt1\u00dd9\u00a8;   // ..device type\n         short int     rcpySpace1;     // ..no. of cylinders (primary)\n                                       // Data Definition: SYSRCPY2\n         char          rcpyDsn2\u00dd45\u00a8;   // ..data set name\n         char          rcpyDevt2\u00dd9\u00a8;   // ..device type\n         short int     rcpySpace2;     // ..no. of cylinders (primary)\n                                       // Data Definition: SYSUT1\n         char          workDsn1\u00dd45\u00a8;   // ..data set name\n         char          workDevt1\u00dd9\u00a8;   // ..device type\n         short int     workSpace1;     // ..no. of cylinders (primary)\n                                       // Data Definition: SORTOUT\n         char          workDsn2\u00dd45\u00a8;   // ..data set name\n         char          workDevt2\u00dd9\u00a8;   // ..device type\n         short int     workSpace2;     // ..no. of cylinders (primary)\n                                       // Data Definition: SYSMAP\n         char          mapDsn\u00dd45\u00a8;     // ..data set name\n         char          mapDevt\u00dd9\u00a8;     // ..device type\n         short int     mapSpace;       // ..no. of cylinders (primary)\n                                       // Data Definition: SYSERR\n         char          errDsn\u00dd45\u00a8;     // ..data set name\n         char          errDevt\u00dd9\u00a8;     // ..device type\n         short int     errSpace;       // ..no. of cylinders (primary)\n                                       // Data Definition: FILTER\n         char          filtrDsn\u00dd45\u00a8;   // ..data set name\n         char          filtrDevt\u00dd9\u00a8;   // ..device type\n         short int     filtrSpace;     // ..no. of cylinders (primary)\n\n        static volatile SQL TYPE IS RESULT_SET_LOCATOR *DsnUtils_rs_loc;\n        long int      seqNo;           // Sequence of row in result set\n        struct                         // Data\n        { short int length;            // ..length of data\n          char      data\u00dd254\u00a8;         // ..data content\n        }           text;\n        char CREATOR\u00dd25\u00a8;\n        char NAME\u00dd25\u00a8;\n        char TSNAME\u00dd25\u00a8;\n        char DBNAME\u00dd25\u00a8;\n\nEXEC SQL END DECLARE SECTION;\n\nconst char   multistr\u00dd\u00a8=\"FOR MULTIPLE ROWS \";\nconst char  notatomic\u00dd\u00a8=\"NOT ATOMIC CONTINUE ON SQLEXCEPTION\";\nconst char  deletestr\u00dd\u00a8=\"DELETE FROM PLAN_TABLE WHERE QUERYNO=0\";\nconst char explainstr\u00dd\u00a8=\"EXPLAIN PLAN SET QUERYNO=0 FOR \";\n\nconst char selectPlan\u00dd\u00a8=\n    \"SELECT\"\n        \" DEC(PARENT_QBLOCKNO,3) PAR_BLK_NO\"\n        \",DEC(QBLOCKNO,3) QUE_BLK_NO\"\n        \",DEC(PLANNO,3) QUE_Run_Ord\"\n        \",QBLOCK_TYPE QUERY_BLOCK_TYPE\"\n        \",DEC(METHOD,1) Join_Mthd\"\n        \",ACCESSTYPE    Acc_Type\"\n        \",DEC(TABNO,3)  TBL_No\"\n        \",TABLE_TYPE TBL_TYP\"\n        \",CAST(A.CREATOR AS CHAR(08)) Table_Owner\"\n        \",CAST(A.TNAME   AS CHAR(25)) Table_Name\"\n        \",DEC(B.CARDF,8)  CATALOG_TABLE_CARDF\"\n        \",CAST(ACCESSNAME AS CHAR(12))  Used_Index\"\n        \",CASE WHEN C.COLCOUNT IS NOT NULL THEN INDEXONLY\"\n        \" ELSE NULL END AS I_O\"\n        \",DEC(C.COLCOUNT,3) Total_Index_Cols\"\n        \",CASE WHEN C.COLCOUNT IS NOT NULL THEN DEC(MATCHCOLS,2)\"\n        \" ELSE NULL END AS Used_Index_Cols\"\n        \",DEC(MERGE_JOIN_COLS,3) MERGE_JOIN_COLS\"\n        \",DEC(C.FIRSTKEYCARDF,8) FIRST_KEY_CARDF\"\n        \",DEC(C.FULLKEYCARDF,8) FULL_KEY_CARDF\"\n        \",C.UNIQUERULE INDEX_UNIQ_RULE\"\n        \",TSLOCKMODE TS_LOCK_MODE \"\n    \"FROM PLAN_TABLE A \"\n    \"LEFT JOIN SYSIBM.SYSTABLES B \"\n      \"ON A.CREATOR = B.CREATOR \"\n     \"AND A.TNAME = B.NAME \"\n    \"LEFT JOIN SYSIBM.SYSINDEXES C \"\n      \"ON A.CREATOR = C.TBCREATOR \"\n     \"AND A.TNAME = C.TBNAME \"\n     \"AND A.ACCESSNAME = C.NAME \"\n   \"WHERE QUERYNO=0 \"\n   \"ORDER BY QBLOCKNO,PLANNO\" ;\n\nconst char cmdDIStmpl\u00dd\u00a8=\"-DIS DATABASE(%s) SPACENAM(%s) LIMIT(*) LOCKS\";\nconst char cmdDIS911\u00dd\u00a8 =\"-DIS DB(*) SPACE(*) LIMIT(*) LOCKS ONLY\";\nconst char cmdDIS904A\u00dd\u00a8=\"-DIS DB(DSNDB07) SPACE(*) LIMIT(*) USE ONLY\";\nchar cmdDIS\u00dd250\u00a8;\nconst char cmdRUNSTATStmpl\u00dd\u00a8=\"RUNSTATS TABLESPACE %s.%s TABLE(%s) %s\";\n//--------------------------------------------------------------//\n// Column structures                                            //\n//--------------------------------------------------------------//\nstruct COLNAME {        // for each SQLNAME\n  char  sqlname\u00dd31\u00a8;    //  original SQLNAME\n short  parts;          //  number of parts\n  char *partptr\u00dd15\u00a8;    //  array of part pointers\n short  partlen\u00dd15\u00a8;    //  array of part lengths\n short  partmaxlen;     //  max part len\n short  width;          //  width of column\n} *pCOLNAME=NULL;\n\n short colines;         // max part number\n\nstruct COLDATA {        // for each SQLVAR\n short  type;           //  original SQLTYPE\n short  len;            //  original SQLLEN\n short  clen;           //  char length\n short  width;          //  width of column\n  char  align;          //  report alignment\n} *pCOLDATA=NULL;\n\n short datalen=0;       // sum of widths\n\nstruct COLPOS {         // for each VALUES position (READ)\n  char sqlname\u00dd31\u00a8;     //  original SQLNAME\n  char posstr\u00dd21\u00a8;      //  p1:p2 or p1.l1 or f1\n  char fflag;           //  f-flag for fn fields\n  char pos1\u00dd7\u00a8;         //  p1\n  char pos2\u00dd7\u00a8;         //  p2 or l1\n short start;           //  p1\n short len;             //  l1\n  char dlm;             //  '.' or ':'\n short mlen;            //  width of column\n} *pCOLPOS;\n\n short maxpos=0;        // sum of mlen\n short fixposFlag;      // ON if not '*'\n\n//--------------------------------------------------------------//\n// FILE declarations                                            //\n//--------------------------------------------------------------//\nchar  fnINSQL\u00dd100\u00a8;\nFILE  *fpINSQL = NULL;\nint   eofINSQL;\nchar  BUF\u00dd32767\u00a8;\nchar  *pBUF=NULL;\nlong  cntINPUT  = 0;\n\nchar  fnOUTSQL\u00dd100\u00a8;\nFILE  *fpOUTSQL = NULL;\nchar  buf81\u00dd81\u00a8;\n\nchar  fnTAGS\u00dd100\u00a8=\"\\0\";\nFILE  *fpTAGS = NULL;\nint   eofTAGS = 0;\nlong  cntTAGS = 0;\n\nFILE  *fpwTAGS  = NULL;\nlong  rowsTAGS  = 0;\n\nchar  fnLOG\u00dd100\u00a8=\"\\0\";\nFILE  *fpLOG = NULL;\n\nFILE  *fpWRITE = NULL;\nchar  fnWRITE\u00dd100\u00a8;\nchar  modeMVSab\u00dd\u00a8=\"ab,type=record,recfm=fb,lrecl=%d,blksize=0\";\nchar  modeMVSa\u00dd\u00a8=\"a,recfm=fb,lrecl=%d,blksize=0\";\nchar  modeMVSwb\u00dd\u00a8=\"wb,type=record,recfm=fb,lrecl=%d,blksize=0\";\nchar  modeMVSw\u00dd\u00a8=\"w,recfm=fb,lrecl=%d,blksize=0\";\nint   lreclWRITE=0;\nlong  cntWRITE=0;\n\nFILE  *fpREAD = NULL;\nchar  fnREAD\u00dd100\u00a8;\nint   lreclREAD=0;\nlong  cntREAD=0;\nint   eofREAD=0;\nlong  totalSQLERRD3=0;\n\nFILE  *fpDISCARD = NULL;\nchar  fnDISCARD\u00dd100\u00a8;\nlong  cntDISCARD=0;\n\nFILE  *fpNETRC = NULL;\nchar  fnNETRC\u00dd100\u00a8;\nint   lreclNETRC=0;\nlong  cntNETRC=0;\nint   eofNETRC=0;\n\nFILE  *fpINCLUDE = NULL;\nchar  fnINCLUDE\u00dd100\u00a8;\nlong  cntINCLUDE=0;\nint   eofINCLUDE=YES;\n\nchar  outBUF\u00dd32767\u00a8;\n\n//--------------------------------------------------------------//\n// #SET variables                                               //\n//--------------------------------------------------------------//\nshort trace=OFF;\nshort testFlag=OFF;\nshort printFlag=ON;\nshort scanFlag=OFF;\nshort signposFlag=ON;\nshort hold_signposFlag=ON;\nshort excelFlag=ON;\nshort labelFlag=ON;\nshort multiRows_save;\nshort readRows=0;\nshort builtRows=0;\nchar  sqldlm\u00dd2\u00a8=\";\";\nchar  nullchar='?';\nchar  hold_nullchar=' ';\nshort loadnullFlag=OFF;\nshort numvars = 256;\nshort sysrc = 4;\n\n//--------------------------------------------------------------//\n// Timings variables                                            //\n//--------------------------------------------------------------//\nunsigned int tottime2, tottimeall2;\nunsigned int tottime1, tottimeall;\ndouble cputime1, cputimeall;\n\n//--------------------------------------------------------------//\n// Program actions                                              //\n//--------------------------------------------------------------//\nshort action;\n#define actSQL          0\n#define actREAD         1\n#define actWRITE        2\n#define actSTACK        3\n// Flags\nshort  newSTMNT=NO;\nshort  doneSTMNT=NO;\nshort  fCSV=NO,fASIS=NO,fRPT=NO,fLIFO=NO,fFIFO=NO,fDATA=NO,fEXPLAIN=NO,\n       fDISCARD=NO,fDISCARDfn=NO,fAPPEND=NO,fLOCK=NO,fLABEL=NO,\n       fECHO=NO;\nchar fSQLERROR='R',fSQLWARNING='R';\n//--------------------------------------------------------------//\n// Parsing variables                                            //\n//--------------------------------------------------------------//\nstruct WORD {\n  char str\u00dd251\u00a8;\n  char *ptr;\n short len;\n} word\u00dd7\u00a8;\n\nchar  word1\u00dd251\u00a8;\nchar  word2\u00dd251\u00a8;\nchar  word3\u00dd251\u00a8;\nint   nwords=0;\n\n//--------------------------------------------------------------//\n// STACK  variables                                             //\n//--------------------------------------------------------------//\nstruct stack {\n    struct stack *next;\n    short int len;\n    char   data\u00dd1\u00a8;\n};\nstruct stack *pstackFIFO  = NULL;\nstruct stack *pstackLIFO  = NULL;\nstruct stack *pstackDATA  = NULL;\nstruct stack *pstackIFDO  = NULL;\nstruct stack *pstackLABEL = NULL;\nstruct stack *plastFIFO   = (struct stack *) &pstackFIFO;\nstruct stack *plastLIFO   = (struct stack *) &pstackLIFO;\nstruct stack *plastDATA   = (struct stack *) &pstackDATA;\nstruct stack *plastLABEL  = (struct stack *) &pstackLABEL;\n short eofFIFO=YES,eofLIFO=YES,eofDATA=YES,eofLABEL=YES;\n  char  skipLABEL\u00dd22\u00a8=\"\\0\";\n  char  stackLABEL\u00dd22\u00a8=\"\\0\";\n  char  sqlerrorLABEL\u00dd22\u00a8=\"\\0\";\n  char  sqlwarningLABEL\u00dd22\u00a8=\"\\0\";\n\nstruct entryLABEL {\n struct stack *pfirst;\n struct stack *plast;\n   char label\u00ddsizeof(stackLABEL)\u00a8;\n};\n const short numLABEL=50;\nentryLABEL arrayLABEL\u00ddnumLABEL\u00a8;\n short foundstackLABEL=NO;\n short indexLABEL;\n//--------------------------------------------------------------//\n// IFDO   variables                                             //\n//--------------------------------------------------------------//\nstruct cache {\n    struct cache *back;\n    char   flag\u00dd2\u00a8;                 // 'Y'- active 'N' - nonactive\n    short  cntIF;                   // counter of internal false IF\n};\nstruct cache *pcacheIFDO = NULL;\nstruct cache *plastIFDO = (struct cache *) &pcacheIFDO;\n\n//--------------------------------------------------------------//\n// Mixed   variables                                            //\n//--------------------------------------------------------------//\nchar   pgmname\u00dd100\u00a8;\nint    i=0,n=0,sessionNo=1;\nint    rc=0,RC=0,RC1=0,RC2=0,RC3=0,RC4=0;\nchar   msg\u00dd133\u00a8;\nshort  eofC1=NO;\nshort  parmUpper=NO;\nlong   rowsC1=0;\nchar   dlm\u00dd2\u00a8;\nchar   saveTABLE\u00dd31\u00a8;\nunsigned short prec,scale,memory;\nshort  fCTM=1;\nlong int code;\n\n//-------------------------------------------------------------------//\n//  IFCA - (Instrumentation Facility Communication Area) contains    //\n//         information regarding the success of the call to IFI and  //\n//         provides feedback information to the application program. //\n//                                                                   //\n//  WARNING: This area must be maintained to include any changes to  //\n//           the mapping macro DSNDIFCA.                             //\n//-------------------------------------------------------------------//\ntypedef struct {                       /* Second parm for IFI call   */\n     short int   len;                  /* Length of the IFCA,        */\n                                       /*  including length field    */\n     short int   unused1;              /* Reserved                   */\n     char        eye_catcher\u00dd4\u00a8;       /* Valid eye catcher of IFCA  */\n                                       /*  used to verify IFCA block */\n     char        owner_id\u00dd4\u00a8;          /* Used to establish ownership*/\n                                       /*  of an OPN destination     */\n     long int    rc;                   /* Rtrn code for IFC API call */\n     long int    reason;               /* Reason cd for IFC API call */\n     long int    gotten_bytes;         /* Bytes of recrd rtrnd by IFI*/\n     long int    lost_bytes;           /* Bytes that did not fit     */\n     long int    opn_writ_seq_num;     /* Last OPN writer sequ numbr */\n                                       /*  rtrnd for a READA function*/\n     long int    num_recds_lost;       /* Records lost indicator     */\n     char        opn_name_for_reada\u00dd4\u00a8;/* OPN nm used for READA requ */\n     struct {                          /* Area with up to 8 OPN names*/\n       short int   opn_len;            /* Length+4 of OPN names rtrnd*/\n       short int   unused2;            /* Reserved                   */\n       char        array_opn_names\u00dd4\u00a8\u00dd8\u00a8;\n                                       /* Area for OPN names returned*/\n     }           opn_names_area;\n     struct {                          /* Area with up to 8 trace nos*/\n       short int   trace_len;          /* Length+4 of trace nos rtrnd*/\n       short int   unused3;            /* Reserved                   */\n       char        array_trace_nos\u00dd2\u00a8\u00dd8\u00a8;\n                                       /* Area for trace nos returned*/\n     }           trace_nos_area;\n     struct {                          /* Diagnosticd area           */\n       short int diagnos_len;          /* Diagnostics length         */\n       short int unused4;              /* Reserved                   */\n       char diagnos_data\u00dd80\u00a8;          /* Diagnostics data           */\n     }           diagnos_area;\n   }           ifca;                   /****** end IFCA typedef ******/\n\n   ifca        *pi=NULL;               /* Pointer to IFCA structure  */\n\ntypedef struct {                       /* Third parm for IFI call    */\n     short int   len;                  /* Length+4 of text or command*/\n     short int   unused;               /* Reserved                   */\n     char        command\u00dd254\u00a8;         /* Actual command             */\n     }         command_area;\n\n   command_area *po=NULL;              /* Pointer to IFI output area */\n\ntypedef struct {                       /* Fourth parm for IFI call   */\n     long int    len; ;                /* Length+4 of IFI return area*/\n     char        report\u00ddRETURN_LEN\u00a8;   /* IFI return area            */\n     }         return_area;\n\n   return_area *pr=NULL;               /* Pointer to IFI return area */\n#if defined(__MVS__)\nextern \"OS\" short int dsnwli(char*,ifca*,return_area*,command_area*);\n#endif\n/**********************************************************************/\n/*                                                                    */\n/*                       Internal functions                           */\n/*                                                                    */\n/**********************************************************************/\n/*********************************************************************\\\n|\n|  Xprintf() -- Put a text into the LOG and SYSPRINT files\n|\n\\*********************************************************************/\nvoid Xprintf(char *fmt, ...)\n{\n   va_list arg_ptr;\n   va_start(arg_ptr, fmt);\n   vsprintf(msg, fmt, arg_ptr);\n   va_end(arg_ptr);\n   if ((printFlag) || (strncmp(msg,\"--!\",3)==EQUALS)) {\n    printf(\"%s\",msg);\n    fflush(stdout);\n   }\n   if (fpLOG) fprintf(fpLOG,\"%s\",msg);\n}\n/*********************************************************************\\\n|\n|  printHexChars() -- for test only\n|\n\\*********************************************************************/\nvoid printHexChars(char* p, int n) {                            // $fnc$\n int i;\n char hex\u00dd4\u00a8=\"\\0\\0\\0\";\n char out\u00dd3\u00a8;\n unsigned char byte;\n for (i=0;i<n;i++) {\n  byte=p\u00ddi\u00a8;\n  sprintf(hex,\"0%x\",byte);\n  if (strlen(hex)>2) memcpy(&out,&hex\u00dd1\u00a8,3);\n  else strcpy(out,hex);\n  Xprintf(\"%s \",out);\n }\n}\n/*********************************************************************\\\n|\n|  strPXcpy() -- pack two chars to one byte\n|\n\\*********************************************************************/\n short strPXcpy(char* po,char* pi,short n) {\n  char chex\u00dd17\u00a8=\"0123456789ABCDEF\";\n  char hex\u00dd17\u00a8={0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,\n                0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F};\n unsigned char byte,out,out1,out2;\n  char *p;\n  short i,j=0;\n for (i=0;i<n;i=i+2) {\n// f0\n  byte=toupper(pi\u00ddi\u00a8);\n  p=strchr(chex,byte);\n  if (p==NULL) return(1);\n  out1=hex\u00ddp-chex\u00a8;\n  out=out1<<4;\n// 0f\n  if ((i+1)==n) {po\u00ddj++\u00a8=out;return(0);}\n  byte=toupper(pi\u00ddi+1\u00a8);\n  p=strchr(chex,byte);\n  if (p==NULL) return(1);\n  out1=hex\u00ddp-chex\u00a8;\n  out2=out|out1;\n  po\u00ddj++\u00a8=out2;\n }\n return(0);\n}\n/*********************************************************************\\\n|\n|  strUXcpy() -- unpack one byte to two chars\n|\n\\*********************************************************************/\n void strUXcpy(char* po,char* pi,short n) {\n short i;\n char hex\u00dd4\u00a8=\"\\0\\0\\0\";\n unsigned char byte;\n\n for (i=0;i<n;i++) {\n  byte=pi\u00ddi\u00a8;\n  sprintf(hex,\"0%X\",byte);\n  if (strlen(hex)>2) memcpy(&po\u00ddi*2\u00a8,&hex\u00dd1\u00a8,2);\n  else memcpy(&po\u00ddi*2\u00a8,&hex\u00dd0\u00a8,2);\n }\n}\n/*********************************************************************\\\n|\n|  parseDecSQLLEN() -- parse decimal SQLLEN(i)\n|\n\\*********************************************************************/\nvoid parseDecSQLLEN(int i) {\n       prec=(short)(((char *)&SQLLEN(i))\u00dd0\u00a8);\n      scale=(short)(((char *)&SQLLEN(i))\u00dd1\u00a8);\n      memory=prec/2+1;\n}\n/*********************************************************************\\\n|\n|  printSQLDA() -- Print SQLDA fields (test only)\n|\n\\*********************************************************************/\nvoid printSQLDA(void) {                                         // $fnc$\n int i;\n char name\u00dd31\u00a8;\n          Xprintf(\" SQLDAID=%-6s, SQLDABC=%d, SQLN=%d, SQLD=%d\\n\",\n                     SQLDAid,      SQLDAbc,    SQLn,    SQLd);\n for (i=0;i<SQLd;i++) {\n  memset(name,'\\0',sizeof(name));\n  strncpy(name,SQLNAMED(i),SQLNAMEL(i));\n                  Xprintf(\" SQLVAR\u00dd%d\u00a8.SQLNAME.LEN=%d\\n\",i,SQLNAMEL(i));\n                  Xprintf(\" SQLVAR\u00dd%d\u00a8.SQLNAME.DATA='%s'\\n\",i,name);\n                  Xprintf(\" hex SQLNAME(%d)=\",i);\n                  printHexChars(SQLNAMED(i),8);\n                  Xprintf(\"\\n\");\n                  Xprintf(\" SQLVAR\u00dd%d\u00a8.SQLTYPE=%d\\n\",i,SQLTYPE(i));\n  if ((SQLTYPE(i)==484)||(SQLTYPE(i)==485)) {\n                  parseDecSQLLEN(i);\n                  Xprintf(\" SQLVAR\u00dd%d\u00a8.SQLLEN=%d.%d\\n\",i,prec,scale);\n  } else          Xprintf(\" SQLVAR\u00dd%d\u00a8.SQLLEN=%d\\n\",i,SQLLEN(i));\n  if (SQLDATA(i)) Xprintf(\" SQLVAR\u00dd%d\u00a8.SQLDATA=%x\\n\",i,SQLDATA(i));\n  else            Xprintf(\" SQLVAR\u00dd%d\u00a8.SQLDATA=NULL\\n\");\n  if (SQLIND(i))  Xprintf(\" SQLVAR\u00dd%d\u00a8.SQLIND=%x\\n\",i,SQLIND(i));\n  else            Xprintf(\" SQLVAR\u00dd%d\u00a8.SQLIND=NULL\\n\");\n                  Xprintf(\" \\n\");\n }\n}\n/*********************************************************************\\\n|\n|  processSQLCODE() -- process SQLCODE\n|\n\\*********************************************************************/\nvoid processSQLCODE(char * Msg) {                               // $fnc$\n   code=SQLCODE;\n   if (SQLCODE==100) return;\n   if (SQLCODE>0) processSQLwarning(Msg);\n   else           processSQLerror(Msg);\n   return;\n}\n/*********************************************************************\\\n|\n|  processSQLerror() -- process SQL errors\n|\n\\*********************************************************************/\nvoid processSQLerror(char * ErrorMsg) {                         // $fnc$\n code=SQLCODE;\n doneSTMNT=YES;\n RC=8;\n // WHENEVER SQLERROR ROLLBACK\n if (fSQLERROR=='R') {PrintSqlError(ErrorMsg);Exit(12);}\n // WHENEVER SQLERROR CONTINUE\n if (fSQLERROR=='C') {PrintSqlError(ErrorMsg);return;}\n Xprintf(\"*** SQLCODE=%d, RC=%d\\n\",code,RC);\n // WHENEVER SQLERROR SUPPRESS\n if (fSQLERROR=='S') return;\n // WHENEVER SQLERROR GOTO\n if (fSQLERROR=='G') {\n    strcpy(skipLABEL,sqlerrorLABEL);\n    Xprintf(\"*** GOTO %s\\n\",skipLABEL);\n }\n return;\n}\n/*********************************************************************\\\n|\n|  processSQLwarning() -- process SQL warnings\n|\n\\*********************************************************************/\nvoid processSQLwarning(char * WarnMsg) {                        // $fnc$\n\n   if (SQLCODE==100) return;\n   if (SQLCODE== 98) return;    // SQL STATEMENT ENDS WITH A SEMICOLON\n   if (SQLCODE==562) return;    // A GRANT WAS IGNORED BECAUSE EXISTS\n //if (SQLCODE== 12) return;    // THE UNQUALIFIED COLUMN NAME\n                                // WAS INTERPRETED AS   COR REF\n //if (SQLCODE==445) return;    // VALUE value HAS BEEN TRUNCATED\n // WHENEVER SQLWARNING SUPPRESS\n if (fSQLWARNING=='S') {SQLCODE=0;return;}\n RC=8;\n // WHENEVER SQLWARNING CONTINUE\n   if (fSQLWARNING=='C') {PrintSqlError(WarnMsg);return;}\n // WHENEVER SQLWARNING GOTO\n if (fSQLWARNING=='G') {\n    Xprintf(\"*** SQLCODE=%d, RC=%d\\n\",SQLCODE,RC);\n    strcpy(skipLABEL,sqlwarningLABEL);\n    Xprintf(\"*** GOTO %s\\n\",skipLABEL);\n }\n // WHENEVER SQLWARNING ROLLBACK\n if (fSQLWARNING=='R') {PrintSqlError(WarnMsg);Exit(12);}\n return;\n}\n/*********************************************************************\\\n|\n|  PrintSqlError(): Print SQL error messages\n|\n\\*********************************************************************/\n       void PrintSqlError(char * ErrorMsg) {\n       char msg\u00dd66\u00a8, *p;\n       int i,j,m,k=0;\n\n       EXEC SQL GET DIAGNOSTICS :nERROR = NUMBER;\n       if ((nERROR==0)&&(SQLCODE!=0)) { // -805 here!!!\n         Xprintf(\" \\n\");\n         Xprintf(\"*** DB2error(s) on %s:\\n\",ErrorMsg);\n         Xprintf(\"*** SQLCODE = %d\\n\",SQLCODE);\n         SQLERRM\u00ddSQLERRL\u00a8='\\0';\n         Xprintf(\"*** SQLERRM = %s\\n\",SQLERRM);\n         return;\n       }\n       if (nERROR==1) m=1; else m=2;\n       for (iERROR=nERROR;iERROR>=m;iERROR--){\n          memset(SMESSAGE,'\\0',sizeof(SMESSAGE)); row_num=0;\n          EXEC SQL GET DIAGNOSTICS CONDITION :iERROR\n                         :SMESSAGE = MESSAGE_TEXT\n                        ,:SCODE = DB2_RETURNED_SQLCODE\n                        ,:SSTATE = RETURNED_SQLSTATE\n                        ,:row_num     = DB2_ROW_NUMBER\n                        ,:TOKEN_COUNT = DB2_TOKEN_COUNT\n                        ,:TOKEN1 = DB2_ORDINAL_TOKEN_1\n                        ,:TOKEN2 = DB2_ORDINAL_TOKEN_2\n                        ,:TOKEN3 = DB2_ORDINAL_TOKEN_3\n                         ;\n        if (SCODE==100) continue;\n        if ((SCODE>0)&&(fSQLWARNING=='S')) continue;\n        if (k==0) Xprintf(\"\\n *DB2error(s) on %s:\\n\",ErrorMsg);\n        Xprintf(\" *DB2error#%d* SQLCODE = %+d\",++k,SCODE);\n        if ((action==actREAD)&&(row_num>0))\n        Xprintf(\", row_number = %d\\n\",totalSQLERRD3+row_num);\n        else if (row_num>0)\n        Xprintf(\", row_number = %d\\n\",row_num);\n        else Xprintf(\"\\n\");\n\n        for (i=0;i<strlen(SMESSAGE);i=i+strlen(msg)) {\n         if (SMESSAGE\u00ddi\u00a8==' ') i++;\n         p=SMESSAGE+i+min(sizeof(msg)-1,strlen(SMESSAGE+i));\n         for (j=0;(j<40)&&(p\u00dd-j\u00a8!='\\0')&&(p\u00dd-j\u00a8!=' ');j++);\n          memset(msg,'\\0',sizeof(msg));\n          strncpy(msg,SMESSAGE+i,sizeof(msg)-1-j);\n          if (i==0) Xprintf(\" *DB2error#%d* %s\\n\",k,msg);\n          else Xprintf(\"              %s\\n\",msg);\n        } // for i\n        Xprintf(\" *DB2error#%d* SQLSTATE = %s\\n\",k,SSTATE);\n        if (SCODE==-904) print904info();\n        if (SCODE==-911) print911info();\n        Xprintf(\" \\n\");\n       } // for iERROR\n       }\n\n/*********************************************************************\\\n|\n| print904info() -- print out DB&TS status\n|\n\\*********************************************************************/\nvoid print904info(void) {\n#if defined(__MVS__)\n short rc;\n char *p;\n   if ((TOKEN_COUNT==3) &&\n       (strcmp(TOKEN2,\"00000200\")==EQUALS) &&\n       ((p=strchr(TOKEN3,'.'))!=NULL)) {\n\n    memset(DBNAME,'\\0',sizeof(DBNAME));\n    memset(TSNAME,'\\0',sizeof(TSNAME));\n    strncpy(DBNAME,TOKEN3,p-TOKEN3);\n    strcpy(TSNAME,p+1);\n    sprintf(cmdDIS,cmdDIStmpl,DBNAME,TSNAME);\n    Xprintf(\"*** %s\\n\",cmdDIS);\n    rc=callIFI(cmdDIS);\n    displyTSstatus(SCODE);\n    return;\n   }\n   if ( (strcmp(TOKEN1,\"00C90084\")==EQUALS) &&\n        (strcmp(TOKEN2,\"00000100\")==EQUALS) &&\n        (strcmp(TOKEN3,\"DSNDB07\")==EQUALS) ) {\n     strcpy(cmdDIS,cmdDIS904A);\n     Xprintf(\"*** %s\\n\",cmdDIS);\n     rc=callIFI(cmdDIS);\n     displyTSstatus(SCODE);\n     return;\n   }\n   print911info();\n#endif\n}\n/*********************************************************************\\\n|\n| print911info() -- print out DB&TS status\n|\n\\*********************************************************************/\nvoid print911info(void) {\n#if defined(__MVS__)\n short rc;\n   strcpy(cmdDIS,cmdDIS911);\n   Xprintf(\"*** %s\\n\",cmdDIS);\n   rc=callIFI(cmdDIS);\n   displyTSstatus(SCODE);\n#endif\n}\n/*********************************************************************\\\n|\n|  get_parm(): Get a program parameter between skey & ekey\n|\n\\*********************************************************************/\nchar* get_parm(int argc,char* argv\u00dd\u00a8,                           // $fnc$\n               char* skey, char* ekey, char* defvalue)          // $fnc$\n{\n    char *s,*e;\n    int i,k,l;\n\n    if (parmUpper==NO) {\n     for (i=1;i<argc;i++) {\n      strcpy(word\u00ddi\u00a8.str,argv\u00ddi\u00a8);\n      l=strlen(word\u00ddi\u00a8.str);\n      for (k=0;(k<l)&&(word\u00ddi\u00a8.str\u00ddk\u00a8!='(');k++)\n      { word\u00ddi\u00a8.str\u00ddk\u00a8=toupper(word\u00ddi\u00a8.str\u00ddk\u00a8); }\n     }\n     parmUpper=YES;\n    }\n    for (i=1;i<argc;i++) {\n     s = strstr(word\u00ddi\u00a8.str,skey);\n     if (s!=NULL) {\n      s = s + strlen(skey);\n      e = strstr(s,ekey);\n      if (e!=NULL) {\n       e\u00dd0\u00a8='\\0';\n       return(s);\n      }\n     }\n    }\n    return(defvalue);\n}\n/*********************************************************************\\\n|\n|  strip() -- Strip leading or/and trailing blanks\n|\n\\*********************************************************************/\nchar*  strip(char *buf, char action)                            // $fnc$\n {\n    int i=0;\n    int j=0;\n    if ((buf == NULL) || (strlen(buf)==0)) return(buf);\n\n    // Leading or Both\n    if ((action == 'L') || (action == 'B'))\n    {\n      for (j=0; ( ((*(buf+j) == ' ')||(*(buf+j) == '\\t'))\n                   && (j<strlen(buf)) ); j++)\n      {\n      }\n    }\n    // Trailing or Both\n    if ((action == 'T') || (action == 'B'))\n    {\n      for (i=strlen(buf)-1;\n           ((*(buf+i) == ' ' ) ||\n            (*(buf+i) == '\\n') ||\n            (*(buf+i) == '\\t') ||\n            (*(buf+i) == '\\0')) && (i>=0); i--)\n      {\n        *(buf+i) = '\\0';\n      }\n    }\n    for (i=j;i<strlen(buf);i++)\n      { if ((*(buf+i) == '\\n') || (*(buf+i) == '\\t')) buf\u00ddi\u00a8=' '; }\n\n    return(buf+j);\n }\n/*********************************************************************\\\n|\n|  strNcpy() = strncpy() + traling blanks\n|\n\\*********************************************************************/\nchar*  strNcpy(char* str1,char *str2, int sizeofstr1)           // $fnc$\n {\n    int i;\n    if (sizeofstr1 < 2) return(NULL);\n\n    strncpy(str1, str2, sizeofstr1-1);\n    str1\u00ddsizeofstr1-1\u00a8 = '\\0';\n\n    for (i=0; i < strlen(str1); i++)\n    {\n      if (str1\u00ddi\u00a8 == '\\n')\n        str1\u00ddi\u00a8=' ';\n    }\n    for (i=strlen(str1); i < sizeofstr1-1; i++)\n    {\n        str1\u00ddi\u00a8=' ';\n    }\n    return(str1);\n }\n/*********************************************************************\\\n|\n|  findword() -- returns an 'nth' word and its length\n|\n\\*********************************************************************/\n char*  findword(char* str, int n, int &outlen)                 // $fnc$\n {\n   int i=0,l=0,nn=0;\n   char *s,*e;\n\n    outlen=0;\n    l=strlen(str);\n\n    if ((str==NULL) || (n==0) || (l==0)) return(NULL);\n\n    do {\n      // Bypass leading blanks\n      for (i=i+outlen; ((i<l) && (str\u00ddi\u00a8==' ')); i++);\n      // Check for a blank str or word\n      if (i>=l) {\n       outlen=0;\n       return(NULL);\n      }\n      // A word found\n      nn++;                      // word number\n      s=str+i;                   // ptr to word\n      e=strchr(s,' ');           // find the word end(next blank)\n      if (e==NULL) e=str+l;      // if end of str found\n      outlen=e-s;               // length=end-start\n      // return if the need word found\n      if (nn==n) return(s);\n    } while(i<l);\n\n    return(NULL);\n }\n/*********************************************************************\\\n|\n|  getwords() -- parse a string and populate the struct word\u00dd7\u00a8 array\n|\n\\*********************************************************************/\n void  getwords(char* str,short n, char Upcase)                 // $fnc$\n {\n    int i,k,nn=min(n,7),j=0;\n\n    memset(word,'\\0',sizeof(word));        // null the array\n    for (i=0;i<nn;i++) {\n      while (str\u00ddj\u00a8==' ') {j++;}           // Bypass leading blanks\n      if (str\u00ddj\u00a8=='\\0') return;            // no more words\n      word\u00ddi\u00a8.ptr=&str\u00ddj\u00a8;                 // start of a word\n      while ((str\u00ddj\u00a8!=' ')&&(str\u00ddj\u00a8!='\\0')) {j++;} // find the end\n      word\u00ddi\u00a8.len=&str\u00ddj\u00a8-word\u00ddi\u00a8.ptr;     // length of the word\n      strncpy(word\u00ddi\u00a8.str,word\u00ddi\u00a8.ptr,     // copy it to str\n//      min(sizeof(WORD::str)-1,word\u00ddi\u00a8.len));\n        min(sizeof(word\u00ddi\u00a8.str)-1,word\u00ddi\u00a8.len));\n      if (Upcase=='U')\n      for (k=0;k<strlen(word\u00ddi\u00a8.str);k++)\n       word\u00ddi\u00a8.str\u00ddk\u00a8=toupper(word\u00ddi\u00a8.str\u00ddk\u00a8);\n    }\n\n }\n/*********************************************************************\\\n|\n|  words() -- returns the number of blank-delimited words in string\n|\n\\*********************************************************************/\n int words(char* str)                                           // $fnc$\n {\n   int i=0,l=0,n=0,wordlen=0;\n   char *s,*e;\n\n    l=strlen(str);\n    if ((str==NULL) || (l==0)) return(0);\n\n    do {\n                                 // Bypass leading blanks\n      for (i=i+wordlen; ((i<l) && (str\u00ddi\u00a8==' ')); i++);\n      if (i>=l) return(n);       // return if next word not found\n      n++;                       // word number\n      s=str+i;                   // ptr to word\n      e=strchr(s,' ');           // find the word end(next blank)\n      if (e==NULL) e=str+l;      // if end of str found\n      wordlen=e-s;               // length=end-start\n    } while(i<l);\n\n    return(n);\n }\n/*********************************************************************\\\n|\n|  CPUtime(): Get CPU time\n|\n\\*********************************************************************/\ndouble CPUtime(double t) {                                      // $fnc$\n    if (t == 0) return ((double) clock() / CLOCKS_PER_SEC);\n    return ( ( ((double) clock()) / CLOCKS_PER_SEC ) - t );\n}\n/*********************************************************************\\\n|\n|  TOTALtime() : Get TOTAL time\n|\n\\*********************************************************************/\nunsigned int TOTALtime(unsigned int t) {                        // $fnc$\n    if (t == 0) return ((unsigned int) time(NULL) );\n    return ( ((unsigned int) time(NULL)) - t );\n}\n/*********************************************************************\\\n|\n|  printCTM() : Print current timestamp\n|\n\\*********************************************************************/\nvoid printCTM(void) {                                           // $fnc$\n    if (fCTM==NO) return;\n    EXEC SQL SET :ctm = CURRENT TIMESTAMP;\n    if (SQLCODE==0)\n    Xprintf(\"+++ Current TimeStamp = %s\\n\",ctm);\n    else { fCTM=NO;\n#if defined(__MVS__)\n    processSQLerror(\"CURRENT TIMESTAMP\"); Exit(12);\n#else\n    SQLCODE=0;\n#endif\n    }\n    return;\n}\n/*********************************************************************\\\n|\n|  printTotalTimings()\n|\n\\*********************************************************************/\nvoid printTotalTimings() {\n    printCTM();\n    Xprintf(\"+++ End of %s, RC=%d\\n\",pgmname,RC);\n    Xprintf(\"+++ CPU time = %.4f seconds, TOTAL time = %d seconds \\n\",\n               CPUtime(cputimeall),TOTALtime(tottimeall));\n}\n/*********************************************************************\\\n|\n|  Exit() : Program's exit\n|\n\\*********************************************************************/\nvoid Exit(int rc) {                                             // $fnc$\n    if (trace) Xprintf(\"*** Exit: SQLCODE=%d, rc=%d\\n\",SQLCODE,rc);\n    if (rc>4) {\n     if (rc==999) Xprintf(\" \\n*ERROR* Memory out\\n \");\n     SQLCODE=0;\n     EXEC SQL ROLLBACK;\n     if (SQLCODE==0)\n          Xprintf(\"\\n \\n*** R O L L B A C K successful ***\\n \\n\");\n     else Xprintf(\"\\n \\n*** ROLLBACK failed, sqlcode=%d \\n \\n\",SQLCODE);\n    }\n    RC=rc;\n    printTotalTimings();\n    exit(rc);\n}\n/*********************************************************************\\\n|\n|  freadbin() -- Read a binary file\n|\n\\*********************************************************************/\nint freadbin( char*  fileName,  // IN:    DD:ddname/file name   // $fnc$\n              FILE** fp,        // OUTIN: file pointer          // $fnc$\n              char*  buf,       // INOUT: buffer                // $fnc$\n               int   bufsize,   // IN:    number bytes to read  // $fnc$\n               int*  eof,       // OUT:   =1, if EOF            // $fnc$\n              long*  ctr,       // OUT:   record counter        // $fnc$\n              char*  msg )      // OUT:   error message         // $fnc$\n{\n  int rc = 0;\n  int n = 0;\n  if (*eof==1) {memset(buf,'\\0',bufsize); return(0);}\n  //\n  //  Open file\n  //\n  if (*fp == NULL)\n  {\n#if defined(__MVS__)\n     *fp = fopen(fileName, \"rb,type=record\");\n#else\n     *fp = fopen(fileName, \"rb\");\n#endif\n     if (*fp == NULL)\n     {\n        sprintf(msg,\"*ERROR* Open %s failed:\\n %s\",\n                fileName, strerror(errno));\n        return(1);\n     }\n     (*ctr)=0;\n  }\n  //\n  //  Read file\n  //\n  n=fread(buf,1,bufsize,*fp);\n  if (trace) Xprintf(\" freadbin() read %d bytes\\n\",n);\n   if (n==0) {\n      *eof = 1;\n      fclose(*fp); *fp=NULL; return(0);\n   }\n   if (n!=bufsize) {\n    (*ctr)++;\n     sprintf(msg,\n     \"*ERROR* %s file record #%d,\\n\"\n     \"        read %d bytes, but expected %d\",\n     fileName,*ctr,n,bufsize);\n     fclose(*fp); return(2);\n   }\n   if (ferror(*fp))\n   {\n      sprintf(msg,\"*ERROR* fread from %s failed:\\n        %s\",\n              fileName, strerror(errno));\n        memset(buf,'\\0',bufsize);\n      fclose(*fp); return(2);\n   }\n   (*ctr)++;\n  return(0);\n }\n/*********************************************************************\\\n|\n|  freadtxt() -- Read a text file\n|\n\\*********************************************************************/\nint freadtxt( char*  fileName,  // IN:    DD:ddname/file name   // $fnc$\n              FILE** fp,        // OUTIN: file pointer          // $fnc$\n              char*  buf,       // INOUT: buffer                // $fnc$\n               int   bufsize,   // IN:    number bytes to read  // $fnc$\n               int*  eof,       // OUT:   =1, if EOF            // $fnc$\n              long*  ctr,       // OUT:   record counter        // $fnc$\n              char*  msg )      // OUT:   error message         // $fnc$\n{\n  int rc = 0;\n  int n = 0;\n  if (*eof==1) {memset(buf,'\\0',bufsize); return(0);}\n  //\n  //  Open file\n  //\n  if (*fp == NULL)\n  {\n#if defined(__MVS__)\n     *fp = fopen(fileName, \"rb,type=record\");\n#else\n     *fp = fopen(fileName, \"r\");\n#endif\n     if (*fp == NULL)\n     {\n        sprintf(msg,\"*ERROR* Open %s failed:\\n %s\",\n                fileName, strerror(errno));\n        return(1);\n     }\n     (*ctr)=0;\n  }\n  //\n  //  Read file\n  //\n  memset(buf,'\\0',bufsize);\n  n=fread(buf,1,bufsize,*fp);\n  if (trace) Xprintf(\" n=%d,buf=<%s>\\n\",n,buf);\n\n   if (feof(*fp)) {\n      *eof = 1;\n      fclose(*fp); *fp=NULL; return(0);\n   }\n   if (ferror(*fp))\n   {\n     sprintf(msg,\"*ERROR* fread from %s failed on record #%d:\\n%s\\n\",\n              fileName,(*ctr)+1, strerror(errno));\n      fclose(*fp); return(2);\n   }\n   (*ctr)++;\n  return(0);\n }\n/*********************************************************************\\\n|\n|  fgetstr() -- Read a text file\n|\n\\*********************************************************************/\nint fgetstr( char*   fileName,  // IN:    DD:ddname|file_name   // $fnc$\n              FILE** fp,        // OUTIN: file pointer          // $fnc$\n              char*  buf,       // INOUT: buffer                // $fnc$\n              int    bufsize,   // IN:    sizeof(buf)           // $fnc$\n              int*   eof,       // OUT:   =1, if EOF            // $fnc$\n              long*  ctr,       // OUT:   record counter        // $fnc$\n              char*  msg )      // OUT:   error message         // $fnc$\n{\n  int rc = 0;\n  if (*eof==1) {memset(buf,'\\0',bufsize); return(0);}\n  memset(buf,'\\n',bufsize);\n  //\n  //  Open file\n  //\n  if (*fp == NULL)\n  {\n     *fp = fopen(fileName,\"r\");\n     if (*fp == NULL)\n     {\n        sprintf(msg,\"*ERROR* Open %s with mode=\\\"r\\\" failed:\\n %s\",\n                fileName, strerror(errno));\n        memset(buf,'\\0',bufsize);\n        return(1);\n     }\n     *ctr=0;\n  }\n  //\n  //  Read file\n  //\n  if (fgets(buf, bufsize, *fp) == NULL)\n  {\n   if (ferror(*fp))\n   {\n      sprintf(msg,\"*ERROR* fgets from %s failed:\\n %s\",\n              fileName, strerror(errno));\n        memset(buf,'\\0',bufsize);\n      rc = 2;\n   }\n   if (feof(*fp))\n   {\n      *eof = 1;\n      memset(buf,'\\0',bufsize);\n   }\n  }\n  else\n  {\n   (*ctr)++;\n   if ((*(buf+bufsize-1) != '\\n')||(strlen(buf)>=bufsize))\n   {\n     sprintf(msg,\n     \"*ERROR* %s file record #%d truncated, \\n\"\n     \"         strlen=%d, BUFSIZE=%d\",\n     fileName,*ctr,strlen(buf),bufsize);\n     rc = 2;\n    } else {                                /* change '\\n' to '\\0' */\n     if (buf\u00ddstrlen(buf)-1\u00a8=='\\n') buf\u00ddstrlen(buf)-1\u00a8='\\0';\n     for (int i=0;i<strlen(buf);i++)\n     {if (buf\u00ddi\u00a8=='\\n') buf\u00ddi\u00a8=' ';}\n    }\n  }\n  //\n  //  Close file if I/O error or EOF\n  //\n  if ((rc!=0) || (*eof==1))\n   {\n      fclose(*fp); *fp=NULL;\n   }\n  return(rc);\n }\n/*********************************************************************\\\n|\n| resetGlobalVariables(void)\n|\n\\*********************************************************************/\nvoid resetGlobalVariables(void) {                               // $fnc$\n     freeSQLDA();\n     SQL.Len=0;\n     memset(SQL.Str,'\\0',sizeof(SQL.Str));\n     doneSTMNT=YES;\n     action=actSQL;\n     fCSV=fASIS=fRPT=fLIFO=fFIFO=fDATA=fEXPLAIN=fDISCARD=fDISCARDfn=NO;\n     fAPPEND=NO,fLOCK=NO,fECHO=NO;\n     strcpy(dlm,\"|\");\n     lreclWRITE=0;\n     lreclREAD=0;\n     cntWRITE=0;\n     cntREAD=0;\n     datalen=0;\n     totalSQLERRD3=0;\n     cntDISCARD=0;\n     return;\n}\n/*********************************************************************\\\n|\n| LOAD_TAGS_ARRAY()\n|\n\\*********************************************************************/\nvoid LOAD_TAGS_ARRAY(void) {                                    // $fnc$\n  char* ptr=NULL;\n  int n=0,i;\n\n     if((fpwTAGS=tmpfile())==NULL) {\n        Xprintf(\" \\n*ERROR* Cannot make a temporary tags file\\n\");\n        Exit(12);\n     }\n\n     // Process TAGS lines\n     do {\n       ptr=strip(BUF,'B');                   // remove extra blanks\n       if ((ptr!=NULL) && (strlen(ptr)>0) && // bypass empty line\n           (strncmp(ptr,\"--\",2)!=EQUALS)  && // bypass '--' comments\n           (strncmp(ptr,\"*\",1) !=EQUALS))    // bypass '*' comments\n       {\n         // take two words from the line\n         getwords(ptr,2,'L');\n         if (strlen(word\u00dd1\u00a8.str)==0) strcpy(word\u00dd1\u00a8.str,\"null\");\n         fprintf(fpwTAGS,\"%s %s \",word\u00dd0\u00a8.str,word\u00dd1\u00a8.str);\n         rowsTAGS++;\n       }\n       // read next line\n       rc=fgetstr(fnTAGS,&fpTAGS,(char*)&BUF,\n              sizeof(BUF),&eofTAGS,&cntTAGS,msg);\n       if (rc!=0) { Xprintf(\"\\n \\n%s\\n\",msg); Exit(12); }\n     } while(!eofTAGS);\n\n     // display TAGS array\n     rewind(fpwTAGS);\n     for (i=1;i<=rowsTAGS;i++) {\n        if (i==1)\n        Xprintf(\"+++ Used substitutions:\\n\");\n        fscanf(fpwTAGS,\"%s %s\",word\u00dd0\u00a8.str,word\u00dd1\u00a8.str);\n        if (strncmp(word\u00dd0\u00a8.str,\"<PASSWORD\",9)==EQUALS)\n         strcpy(word\u00dd1\u00a8.str,\"********\");\n        Xprintf(\"    %-40s %s\\n\",word\u00dd0\u00a8.str,word\u00dd1\u00a8.str);\n     }\n     Xprintf(\" \\n\");\n}\n/*********************************************************************\\\n|\n|  allocSQLDA(short n) -- re/allocate SQLDA\n|\n\\*********************************************************************/\nvoid allocSQLDA(short n) {                                      // $fnc$\n//define SQLDASIZE(n) (sizeof(struct sqlda)+(n-1)* sizeof(struc sqlvar))\n     if (pSQLDA) free(pSQLDA);\n     pSQLDA = (struct sqlda *) malloc(SQLDASIZE(n));\n     if (pSQLDA==NULL) Exit(999);\n     memset(pSQLDA,'\\0',SQLDASIZE(n));\n     SQLn = n;\n}\n/*********************************************************************\\\n|\n|  OPEN_INIT() -- Open files and init variables\n|\n\\*********************************************************************/\nvoid OPEN_INIT(int argc, char *argv\u00dd\u00a8)                          // $fnc$\n{\n    strcpy(fnLOG,get_parm(argc,argv,\"LOG(\",\")\",\"\"));\n     if ((strlen(fnLOG)>0) &&\n         ((fpLOG=fopen(fnLOG, \"w\"))==NULL)) {\n      Xprintf(\" \\n*ERROR* Open file LOG %s failed:\\n\"\n                    \"       %s\\n\", fnLOG, strerror(errno));\n      Exit(12);\n     }\n    strcpy(word2,get_parm(argc,argv,\"PRINT(\",\")\",\"\"));\n    if (strlen(word2)>0)  {\n     if ((strcmp(word2,\"OFF\")==EQUALS) ||\n        (strcmp(word2,\"off\")==EQUALS)) printFlag=OFF;\n    }\n   Xprintf(\"+++ %s for %s, %s\",pgm_tit,pgm_env,pgm_ver);\n   Xprintf(\" (built on %s %s, author %s)\\n\"\n           ,__DATE__,__TIME__,pgm_dev);\n    cputimeall= CPUtime(0);\n    tottimeall= TOTALtime(0);\n    strcpy(pgmname,argv\u00dd0\u00a8);\n    printCTM();\n    Xprintf(\" \\n\");\n//--------------------------------------------------------------//\n// Process parameters                                           //\n//--------------------------------------------------------------//\n    if (argc>7) {\n     Xprintf(\" \\n*ERROR* Invalid number of parameters\\n\"\n       \"*** z/OS example:\\n\"\n       \"    PARMS('INSQL(DD:INSQL) TAGS(filename) OUTSQL(DD:name)\"\n       \" LOG(file) SCAN(ON) PRINT(OFF)')\\n\");\n      Exit(8);\n    }\n    strcpy(fnINSQL, get_parm(argc,argv,\"INSQL(\",\")\",\"DD:INSQL\"));\n    strcpy(fnOUTSQL,get_parm(argc,argv,\"OUTSQL(\",\")\",\"\"));\n    strcpy(fnTAGS,get_parm(argc,argv,\"TAGS(\",\")\",\"\"));\n    strcpy(word1,get_parm(argc,argv,\"SCAN(\",\")\",\"\"));\n    Xprintf(\"+++ Used parameters:\\n\"\n            \"                INSQL(%s)\\n\",fnINSQL);\n    if (strlen(fnTAGS)>0)\n    Xprintf(\"                 TAGS(%s)\\n\",fnTAGS);\n    if (strlen(fnOUTSQL)>0)\n    Xprintf(\"               OUTSQL(%s)\\n\",fnOUTSQL);\n    if (strlen(fnLOG)>0)\n    Xprintf(\"                  LOG(%s)\\n\",fnLOG);\n\n    if (strlen(word1)>0)  {\n    Xprintf(\"                 SCAN(%s)\\n\",word1);\n     if (strcmp(word1,\"ON\")==EQUALS) scanFlag=ON;\n    }\n    if (strlen(word2)>0)\n    Xprintf(\"                PRINT(%s)\\n\",word2);\n    Xprintf(\" \\n\");\n//--------------------------------------------------------------//\n// Open files\n//--------------------------------------------------------------//\n\n     if  ( (fpINSQL=fopen(fnINSQL,\"r\")) == NULL ) {\n      Xprintf(\" \\n*ERROR* INSQL Open %s failed: %s\\n\",\n                fnINSQL, strerror(errno));\n      Exit(12);\n      }\n\n\n     if ((strlen(fnTAGS)>0) &&\n         ((fpTAGS=fopen(fnTAGS, \"r\"))==NULL)) {\n      Xprintf(\" \\n*ERROR* TAGS Open %s failed: %s\\n\",\n                fnTAGS, strerror(errno));\n      Exit(12);\n     }\n     if (fpTAGS)\n     LOAD_TAGS_ARRAY();\n\n     if ((strlen(fnOUTSQL)>0) &&\n#if defined(__MVS__)\n        ((fpOUTSQL=fopen(fnOUTSQL,\"w,lrecl=80,recfm=fb\"))==NULL)) {\n#else\n        ((fpOUTSQL=fopen(fnOUTSQL,\"w\"))==NULL)) {\n#endif\n      Xprintf(\" \\n*ERROR* Open file OUTSQL %s failed:\\n\"\n                   \"        %s\\n\", fnOUTSQL, strerror(errno));\n      Exit(12);\n     }\n\n     allocSQLDA(numvars);\n     resetGlobalVariables();\n     memset(arrayLABEL,'\\0',sizeof(arrayLABEL));\n}\n/*********************************************************************\\\n|\n| replaceTags() -- replace <tags> with real table names from TAGS file\n|\n\\*********************************************************************/\nvoid replaceTags(void) {                                        // $fnc$\n  char *s,*e;\n  int i,j;\n\n     if (fpwTAGS==NULL) return;\n     rewind(fpwTAGS);\n     for (j=1;j<=rowsTAGS;j++) {\n\n        fscanf(fpwTAGS,\"%s %s\",word1,word2);\n        if (strcmp(word1,word2)==EQUALS) continue;\n        if ((strcmp(word2,\"null\")==EQUALS)||\n            (strcmp(word2,\"NULL\")==EQUALS))\n          memset(word2,'\\0',sizeof(word2));\n\n        s=strstr(BUF,word1);\n        for (i=1;((i<50)&&(s));i++) {\n          e=s+strlen(word1);\n          memset(s,'\\0',1);\n          strcpy(word3,e);\n          strcat(BUF,word2);\n          strcat(BUF,word3);\n          s=strstr(s,word1);\n        }\n     }\n}\n/*********************************************************************\\\n|\n| PROCESS_FUNCTIONAL_SET() -- process \"--#SET\" functional comments\n|\n\\*********************************************************************/\nvoid PROCESS_FUNCTIONAL_SET(void)                               // $fnc$\n{\nint n=0;\n\n// remove ending ';' from operand\n     if ((strcmp(word\u00dd1\u00a8.str,\"SQLDLM\")!=EQUALS)&&\n         (strcmp(word\u00dd1\u00a8.str,\"TERMINATOR\")!=EQUALS)&&\n         (word\u00dd2\u00a8.str\u00ddword\u00dd2\u00a8.len-1\u00a8==';'))\n          word\u00dd2\u00a8.str\u00ddword\u00dd2\u00a8.len-1\u00a8='\\0';\n\n// --#SET TRACE ON|OFF (default OFF)\n     if (strcmp(word\u00dd1\u00a8.str,\"TRACE\")==EQUALS) {\n       if (strcmp(word\u00dd2\u00a8.str,\"ON\")==EQUALS) trace=ON;\n       else trace=OFF;\n     } else\n\n// --#SET PRINT ON|OFF (default ON)\n     if (strcmp(word\u00dd1\u00a8.str,\"PRINT\")==EQUALS) {\n       if (strcmp(word\u00dd2\u00a8.str,\"OFF\")==EQUALS) printFlag=OFF;\n       else printFlag=ON;\n     } else\n\n// --#SET SCAN ON|OFF (default OFF)\n     if (strcmp(word\u00dd1\u00a8.str,\"SCAN\")==EQUALS) {\n       if (strcmp(word\u00dd2\u00a8.str,\"ON\")==EQUALS) scanFlag=ON;\n       else scanFlag=OFF;\n     } else\n\n// --#SET SIGNPOS ON|OFF (default OFF)\n     if (strcmp(word\u00dd1\u00a8.str,\"SIGNPOS\")==EQUALS) {\n       if ((strcmp(word\u00dd2\u00a8.str,\"OFF\")==EQUALS)||\n           (strcmp(word\u00dd2\u00a8.str,\"NO\")==EQUALS)) signposFlag=OFF;\n       else signposFlag=ON;\n     } else\n\n// --#SET EXCEL ON|OFF (default ON)\n     if (strcmp(word\u00dd1\u00a8.str,\"EXCEL\")==EQUALS) {\n       if (strcmp(word\u00dd2\u00a8.str,\"OFF\")==EQUALS) excelFlag=OFF;\n       else excelFlag=ON;\n     } else\n\n// --#SET LABELS ON|OFF (default ON)\n     if (strcmp(word\u00dd1\u00a8.str,\"LABELS\")==EQUALS) {\n       if (strcmp(word\u00dd2\u00a8.str,\"OFF\")==EQUALS) labelFlag=OFF;\n       else labelFlag=ON;\n     } else\n\n// --#SET LOADNULL ON|OFF (default OFF)\n     if (strcmp(word\u00dd1\u00a8.str,\"LOADNULL\")==EQUALS) {\n       if (strcmp(word\u00dd2\u00a8.str,\"ON\")==EQUALS) loadnullFlag=ON;\n       else loadnullFlag=OFF;\n     } else\n\n// --#SET MULTIROWS nn   (default 100, valid range 1-32767)\n     if (strcmp(word\u00dd1\u00a8.str,\"MULTIROWS\")==EQUALS) {\n       if (strlen(word\u00dd2\u00a8.str)!=0) {\n         for (i=0;i<strlen(word\u00dd2\u00a8.str);i++) {\n           if ((word\u00dd2\u00a8.str\u00ddi\u00a8<'0') || (word\u00dd2\u00a8.str\u00ddi\u00a8>'9'))\n           {Xprintf(\" \\n*ERROR* Invalid digit: %s \\n \",word\u00dd2\u00a8.str);\n            Exit(8);}\n         }\n         i=atoi(word\u00dd2\u00a8.str);\n         if ((i<1)||(i>32767)) {\n          Xprintf(\" \\n*ERROR* %d is not in 1-32767 \\n \",i);\n          Exit(8);\n         } else multiRows=i;\n       } else Xprintf(\"*** Current MULTIROWS is %d\\n\",multiRows);\n     } else\n\n// --#SET NUMVARS nn     (default 256, valid range 50-32767)\n     if (strcmp(word\u00dd2\u00a8.str,\"NUMVARS\")==EQUALS) {\n       if (strlen(word\u00dd2\u00a8.str)!=0) {\n         for (i=0;i<strlen(word\u00dd1\u00a8.str);i++) {\n           if ((word\u00dd2\u00a8.str\u00ddi\u00a8<'0') || (word\u00dd2\u00a8.str\u00ddi\u00a8>'9'))\n           {Xprintf(\" \\n*ERROR* Invalid digit: %s \\n \",word\u00dd1\u00a8.str);\n            Exit(8);}\n         }\n         i=atoi(word\u00dd2\u00a8.str);\n         if ((i<50)||(i>32767)) {\n          Xprintf(\" \\n*ERROR* %d is not in 50-32767 \\n \",i);\n          Exit(8);\n         } else {\n          numvars=i;\n          free(pSQLDA); pSQLDA=NULL;\n          pSQLDA = (struct sqlda *) malloc(SQLDASIZE(numvars));\n          if (pSQLDA==NULL) Exit(999);\n          memset(pSQLDA,'\\0',SQLDASIZE(numvars));\n          SQLn = numvars;\n          Xprintf(\"*** Current NUMVARS is %d\\n\",numvars);\n         }\n       } else Xprintf(\"*** Current NUMVARS is %d\\n\",numvars);\n     } else\n\n// --#SET SYSRC nn       (default 4,   valid range 0-32)\n     if (strcmp(word\u00dd1\u00a8.str,\"SYSRC\")==EQUALS) {\n       if (strlen(word\u00dd2\u00a8.str)!=0) {\n         for (i=0;i<strlen(word\u00dd2\u00a8.str);i++) {\n           if ((word\u00dd2\u00a8.str\u00ddi\u00a8<'0') || (word\u00dd2\u00a8.str\u00ddi\u00a8>'9'))\n           {Xprintf(\" \\n*ERROR* Invalid digit: %s \\n \",word\u00dd2\u00a8.str);\n            Exit(8);}\n         }\n         i=atoi(word\u00dd2\u00a8.str);\n         if ((i<0)||(i>32)) {\n          Xprintf(\" \\n*ERROR* %d is not in 0-32 \\n \",i);\n          Exit(8);\n         } else sysrc=i;\n       } else Xprintf(\"\\n*** Current SYSRC is %d\",sysrc);\n     } else\n\n// --#SET SQLDLM c      (default ';')\n// --#SET TERMINATOR c  (default ';')\n     if ((strcmp(word\u00dd1\u00a8.str,\"SQLDLM\")==EQUALS)||\n         (strcmp(word\u00dd1\u00a8.str,\"TERMINATOR\")==EQUALS)) {\n       if (strlen(word\u00dd2\u00a8.str)==1)\n        strcpy(sqldlm,word\u00dd2\u00a8.str);\n       else Xprintf(\"*** Current %s is '%s'\\n\",word\u00dd1\u00a8.str,sqldlm);\n     } else\n// --#SET NULLCHAR c    (default '?')\n     if (strcmp(word\u00dd1\u00a8.str,\"NULLCHAR\")==EQUALS) {\n       if ((strlen(word\u00dd2\u00a8.str)>0)) {\n        if (strcmp(word\u00dd2\u00a8.str,\"BLANK\")==EQUALS) nullchar=' ';\n        else nullchar=word\u00dd2\u00a8.str\u00dd0\u00a8;\n       }\n       else nullchar='?';\n       Xprintf(\"*** Current NULLCHAR is '%c'\\n\",nullchar);\n     } else {\n\n     Xprintf(\" \\n*ERROR* Unknown #SET function '%s' \\n \",word\u00dd1\u00a8.str)   ;\n     Exit(8);\n     }\n}\n/*********************************************************************\\\n|\n|  getFIFO() -- get a record from STACK FIFO stack\n|\n\\*********************************************************************/\nchar* getFIFO(char *out) {                                      // $fnc$\n struct stack *pnext;\n\n    if (pstackFIFO==NULL) {eofFIFO=YES;out\u00dd0\u00a8='\\0';return(NULL);}\n    strcpy(out,pstackFIFO->data);\n    pnext = pstackFIFO->next;\n    free(pstackFIFO);\n    pstackFIFO=pnext;\n    if (pstackFIFO==NULL)\n    plastFIFO = (struct stack * ) &pstackFIFO;\n\n    return(out);\n}\n/*********************************************************************\\\n|\n|  getLIFO() -- get a record from STACK LIFO stack\n|\n\\*********************************************************************/\nchar* getLIFO(char *out) {                                      // $fnc$\n struct stack *pnext;\n\n    if (pstackLIFO==NULL) {eofLIFO=YES;out\u00dd0\u00a8='\\0';return(NULL);}\n    strcpy(out,pstackLIFO->data);\n    pnext = pstackLIFO->next;\n    free(pstackLIFO);\n    pstackLIFO=pnext;\n    if (pstackLIFO==NULL)\n    plastLIFO = (struct stack * ) &pstackLIFO;\n    return(out);\n}\n/*********************************************************************\\\n|\n|  getLABEL() -- get a record from STACK LABEL stack\n|\n\\*********************************************************************/\nint  getLABEL(char *out) {\n struct stack *pnext;\n  short i=indexLABEL;\n  int len=0;\n    if (arrayLABEL\u00ddi\u00a8.pfirst==NULL)\n     {eofLABEL=YES;foundstackLABEL=NO;\n      out\u00dd0\u00a8='\\0';arrayLABEL\u00ddi\u00a8.label\u00dd0\u00a8='\\0';return(NULL);}\n    len=arrayLABEL\u00ddi\u00a8.pfirst->len;\n    memcpy(out,arrayLABEL\u00ddi\u00a8.pfirst->data,len);\n    out\u00ddlen\u00a8='\\0';\n    pnext = arrayLABEL\u00ddi\u00a8.pfirst->next;\n    free(arrayLABEL\u00ddi\u00a8.pfirst);\n    arrayLABEL\u00ddi\u00a8.pfirst=pnext;\n    if (arrayLABEL\u00ddi\u00a8.pfirst==NULL) {\n     arrayLABEL\u00ddi\u00a8.plast = (struct stack * ) &arrayLABEL\u00ddi\u00a8.pfirst;\n    }\n    return(len);\n}\n/*********************************************************************\\\n|\n|  getDATA() -- get a record from STACK DATA stack\n|\n\\*********************************************************************/\nint   getDATA(char *out) {                                      // $fnc$\n struct stack *pnext;\n  int len=0;\n    if (pstackDATA==NULL) {eofDATA=YES;out\u00dd0\u00a8='\\0';return(0);}\n    len=pstackDATA->len;\n    memcpy(out,pstackDATA->data,len);\n    out\u00ddlen\u00a8='\\0';\n    pnext = pstackDATA->next;\n    free(pstackDATA);\n    pstackDATA=pnext;\n    if (pstackDATA==NULL)\n    plastDATA = (struct stack * ) &pstackDATA;\n    return(len);\n}\n/*********************************************************************\\\n|\n|  getIFDO() -- get last record from IFDO stack\n|\n\\*********************************************************************/\nvoid  getIFDO(void) {                                           // $fnc$\n struct cache *pback;\n\n    if (plastIFDO==NULL) return;\n    pback = plastIFDO->back;\n    free(plastIFDO);\n    plastIFDO=pback;\n    return;\n}\n/*********************************************************************\\\n|\n|  writeOUTSQLline() -- write input line to OUTSQL file\n|\n\\*********************************************************************/\nvoid  writeOUTSQLline() {                                       // $fnc$\n\n     n=fprintf(fpOUTSQL,\"%-80s\\n\",BUF);\n     if (n<1) { Xprintf(\" \\n*ERROR* fprintf(%s,...) failed:\\n%s\\n\",\n                        fnOUTSQL, strerror(errno));\n                Xprintf(\"BUF='%-80s'\\n\",BUF);\n                Exit(12); }\n\n}\n/*********************************************************************\\\n|\n|  READ_INPUT_LINE() -- read and process the INSQL file\n|\n\\*********************************************************************/\nvoid READ_INPUT_LINE(void)                                      // $fnc$\n{\n char* ptr;\n short done=NO,fINSQL;\n int   n=0,l=0,len;\n\n     if ((newSTMNT==NO)||(pBUF)) return;\n     while (done==NO)\n     {  // read an input record\n        fINSQL=NO;\n        // ... from FIFO stack when eofINSQL\n        if (eofINSQL) {\n           ptr=getFIFO(BUF);\n           if (ptr==NULL) break;\n        if (trace) Xprintf(\" getFIFO='%s'\\n\",ptr);\n        } else\n        // ... from LIFO stack\n        if (pstackLIFO) {\n           ptr=getLIFO(BUF);\n           if (trace) Xprintf(\" getLIFO='%s'\\n\",ptr);\n        } else\n        // ... from LABEL stack\n        if ((foundstackLABEL==ON)&&(arrayLABEL\u00ddindexLABEL\u00a8.pfirst)) {\n           len=getLABEL(BUF);\n           if (trace) Xprintf(\" getLABEL(BUF)='%s'\\n\",BUF);\n           ptr=BUF;\n        } else\n        // ... from INCLUDE file\n         if (eofINCLUDE==NO) {\n         rc=fgetstr(fnINCLUDE,&fpINCLUDE,(char*)&BUF,\n              sizeof(BUF),&eofINCLUDE,&cntINCLUDE,msg);\n\n         if (rc!=0) { Xprintf(\"\\n \\n%s\\n\",msg); Exit(12); }\n         if (eofINCLUDE==YES) break;\n         if (trace) Xprintf(\" fgetstr='%s'\\n\",BUF);\n        }\n        // ... from INSQL file\n        else {\n        fINSQL=YES;\n        rc=fgetstr(fnINSQL,&fpINSQL,(char*)&BUF,\n              sizeof(BUF),&eofINSQL,&cntINPUT,msg);\n\n        if (rc!=0) { Xprintf(\"\\n \\n%s\\n\",msg); Exit(12); }\n        if (eofINSQL==YES) break;\n        if (trace) Xprintf(\" fgetstr='%s'\\n\",BUF);\n        }\n        // substitute <tags>\n        replaceTags();\n\n        // bypass till a SKIP label if specified\n        if (skipLABEL\u00dd0\u00a8!='\\0'&&strcmp(skipLABEL,BUF)!=EQUALS)\n        { if ((fpOUTSQL)&&(fINSQL))\n          writeOUTSQLline(); continue; }\n\n        // bypass lines with special comments\n        ptr=findword(BUF,1,l);\n        if ((ptr)&&(strncmp(ptr,\"--;\",3)==EQUALS)) continue;\n\n        // suppress SAY/ECHO printing out\n        if (!(((ptr)&&(SQL.Len==0)&&\n               (\n                (strncmp(ptr,\"SAY\",3)==EQUALS) ||\n                (strncmp(ptr,\"ECHO\",4)==EQUALS)\n               )\n              )||\n              ((ptr)&&(SQL.Len>0)&&\n               (\n                (strncmp(SQL.Str,\"SAY\",3)==EQUALS) ||\n                (strncmp(SQL.Str,\"ECHO\",4)==EQUALS)\n               )\n           ) ))\n        // print out input line\n         Xprintf(\" %s\\n\",BUF);\n\n        // write out an OUTSQL line\n        if ((fpOUTSQL)&&(fINSQL))\n        writeOUTSQLline();\n\n        ptr=strip(BUF,'B');                  // remove extra blanks\n        if (ptr==NULL) continue;             // bypass empty line\n        if (strlen(ptr)==0) continue;        // bypass blank line\n\n        // process functional comments\n        if (strncmp(ptr,\"--#\",3)==EQUALS) {\n         getwords(ptr,3,'U');\n         if (strcmp(word\u00dd0\u00a8.str,\"--#SET\")==EQUALS)\n          PROCESS_FUNCTIONAL_SET();\n         continue;\n        }\n        // bypass comments\n        if (strncmp(ptr,\"--\",2)==EQUALS) continue;\n\n        // process a label if it is\n        if ((labelFlag==ON)&&(checkforLABEL()==YES)) continue;\n\n        if (!scanFlag)\n        done=YES;\n     }\n     if ((eofINSQL==YES)&&(fpOUTSQL))\n      {fclose(fpOUTSQL);fpOUTSQL=NULL;}\n}\n/*********************************************************************\\\n|\n|  APPEND_INPUT_TO_STMNT(void) -- add input to SQL buffer\n|\n\\*********************************************************************/\nvoid APPEND_INPUT_TO_STMNT(void)                                // $fnc$\n{\n  char *ptr,*s;\n   int i,l;\n short nquotes=0;\n\n        if (pBUF==NULL) ptr=strip(BUF,'L');  // bypass leading blanks\n        else ptr=strip(pBUF,'L');            // continue proccesing\n        s=ptr;                               // init work pointer\n        l=strlen(s);\n\n        if ((SQL.Len>0)&&(SQL.Str\u00ddSQL.Len-1\u00a8!=' ')) {\n          SQL.Str\u00ddSQL.Len\u00a8=' ';\n          SQL.Len++;\n        }\n\n        for (i=0;((i<l)&&(newSTMNT));i++) {\n\n         switch (s\u00ddi\u00a8) {\n\n          case '\\'':                         // sum qoutes number\n           nquotes++;\n           break;\n\n          case '-':                          // process ending comments\n           if ( ((nquotes%2)==0) && (s\u00ddi+1\u00a8=='-') ) {\n            pBUF=NULL;                       // ignore the rest of line\n            return;                          // get next line\n           }\n           break;\n\n          default:                           // process delimiter\n\n           if (((nquotes%2)==0) &&\n                (s\u00ddi\u00a8==sqldlm\u00dd0\u00a8) ) {\n            newSTMNT=NO;\n            if (s\u00ddi+1\u00a8=='\\0') pBUF=NULL;\n            else pBUF=&s\u00ddi+1\u00a8;\n           }\n         } // switch\n         SQL.Len++;\n         if (SQL.Len>=MAXSQLSIZE) {\n         Xprintf(\" \\n*ERROR* Too long statement: %d chars\\n\",SQL.Len);\n         Xprintf(\"statement='%s'\\n\",SQL.Str);\n           Exit(8);\n         }\n         if (newSTMNT==NO) {\n           SQL.Str\u00ddSQL.Len\u00a8='\\0';\n           SQL.Len--;\n         }\n         else {\n         if (((nquotes%2)==0) && (s\u00ddi\u00a8==' ')&&(s\u00ddi-1\u00a8==' ')) SQL.Len--;\n           else SQL.Str\u00ddSQL.Len-1\u00a8=s\u00ddi\u00a8;\n         }\n        }\n        if (nquotes%2>0)\n         {Xprintf(\" \\n*ERROR* unpaired quote found\\n\"); Exit(8);}\n}\n/*********************************************************************\\\n|\n| processEXEC() -- remove \"EXEC SQL\" words from SQL buffer\n|\n\\*********************************************************************/\nchar* processEXEC()   {                                         // $fnc$\n      if (strcmp(word\u00dd1\u00a8.str,\"SQL\")==EQUALS) return(word\u00dd2\u00a8.ptr);\n      return(NULL);\n}\n/*********************************************************************\\\n|\n| processWHENEVER() -- WHENEVER SQLERROR CONTINUE|ROLLBACK\n|\n\\*********************************************************************/\nvoid processWHENEVER() {                                        // $fnc$\n short rc=0;\n      if (strcmp(word\u00dd1\u00a8.str,\"SQLERROR\")==EQUALS) {\n       memset(sqlerrorLABEL,'\\0',sizeof(sqlerrorLABEL));\n       if (strcmp(word\u00dd2\u00a8.str,\"CONTINUE\")==EQUALS)\n       { fSQLERROR='C'; doneSTMNT=YES; return; }\n       if (strcmp(word\u00dd2\u00a8.str,\"ROLLBACK\")==EQUALS)\n       { fSQLERROR='R'; doneSTMNT=YES; return; }\n       if (strcmp(word\u00dd2\u00a8.str,\"SUPPRESS\")==EQUALS)\n       { fSQLERROR='S'; doneSTMNT=YES; return; }\n       if (strcmp(word\u00dd2\u00a8.str,\"GOTO\")==EQUALS)\n       { rc=extractLABEL(word\u00dd3\u00a8.str,word\u00dd3\u00a8.len,sqlerrorLABEL);\n         if (rc==0) {fSQLERROR='G'; doneSTMNT=YES; return; }\n       }\n      } else\n      if (strcmp(word\u00dd1\u00a8.str,\"SQLWARNING\")==EQUALS) {\n       memset(sqlwarningLABEL,'\\0',sizeof(sqlwarningLABEL));\n       if (strcmp(word\u00dd2\u00a8.str,\"CONTINUE\")==EQUALS)\n       { fSQLWARNING='C'; doneSTMNT=YES; return; }\n       if (strcmp(word\u00dd2\u00a8.str,\"ROLLBACK\")==EQUALS)\n       { fSQLWARNING='R'; doneSTMNT=YES; return; }\n       if (strcmp(word\u00dd2\u00a8.str,\"SUPPRESS\")==EQUALS)\n       { fSQLWARNING='S'; doneSTMNT=YES; return; }\n       if (strcmp(word\u00dd2\u00a8.str,\"GOTO\")==EQUALS)\n       { rc=extractLABEL(word\u00dd3\u00a8.str,word\u00dd3\u00a8.len,sqlwarningLABEL);\n         if (rc==0) {fSQLERROR='G'; doneSTMNT=YES; return; }\n       }\n      }\n      Xprintf(\" \\n*ERROR* Invalid % syntax\\n\",word\u00dd0\u00a8.str);\n      Exit(8);\n}\n/*********************************************************************\\\n|\n| passwordNETRC() -- get a password from a NETRC file\n|\n\\*********************************************************************/\nvoid passwordNETRC() {\n\n    eofNETRC=NO;rc=0;outBUF\u00dd0\u00a8='\\0';\n\n    for (;(eofNETRC==NO)&&(rc==0);\n          rc=fgetstr(fnNETRC,&fpNETRC,(char*)&outBUF,\n          sizeof(outBUF),&eofNETRC,&cntNETRC,msg)     )\n    {\n      nwords=words(outBUF);\n      if (nwords!=6) continue;\n      getwords(outBUF,6,'U');\n      if (strcmp(word\u00dd0\u00a8.str,\"MACHINE\" )!=EQUALS)  continue;\n      if (strcmp(word\u00dd2\u00a8.str,\"LOGIN\"   )!=EQUALS)  continue;\n      if (strcmp(word\u00dd4\u00a8.str,\"PASSWORD\")!=EQUALS)  continue;\n      if (strncmp(word\u00dd1\u00a8.ptr,location,\n          Max(word\u00dd1\u00a8.len,strlen(location)))!=EQUALS) continue;\n      if (strncmp(word\u00dd3\u00a8.ptr,userid.str,\n          Max(word\u00dd3\u00a8.len,userid.len))!=EQUALS) continue;\n      if (word\u00dd5\u00a8.len>(sizeof(password.str)-1)) continue;\n      break;\n    }\n    if (rc!=0) { Xprintf(\"\\n \\n%s\\n\",msg); Exit(8); }\n    if (eofNETRC) {\n     Xprintf(\" \\n*ERROR* Machine %s with Login %s not found in %s\\n\",\n            location,userid.str,fnNETRC);\n     Exit(8);\n    }\n    memset(password.str,'\\0',sizeof(password.str));\n    strncpy(password.str,word\u00dd5\u00a8.ptr,word\u00dd5\u00a8.len);\n    password.len=strlen(password.str);\n    memset(outBUF,'\\0',sizeof(outBUF));\n    memset(word\u00dd5\u00a8.str,'\\0',sizeof(word\u00dd5\u00a8.str));\n}\n/*********************************************************************\\\n|\n| processCONNECT() -- run CONNECT directly\n|\n\\*********************************************************************/\nvoid  processCONNECT() {                                        // $fnc$\n   switch (nwords) {\n    case 1:\n          EXEC SQL CONNECT;\n        break;\n    case 2:\n    // CONNECT RESET\n        if (strcmp(word\u00dd1\u00a8.str,\"RESET\")==EQUALS) {\n          EXEC SQL CONNECT RESET;\n        }\n        break;\n    case 3:\n    // CONNECT TO location\n        if (strcmp(word\u00dd1\u00a8.str,\"TO\")==EQUALS) {\n          memset(location,'\\0',sizeof(location));\n          strncpy(location,word\u00dd2\u00a8.ptr,\n                  min(word\u00dd2\u00a8.len,sizeof(location)-1));\n          EXEC SQL CONNECT TO :location;\n        }\n        break;\n    case 7:\n    // CONNECT TO location USER userid USING netrc-file\n        if ((strcmp(word\u00dd1\u00a8.str,\"TO\")==EQUALS)&&\n            (strcmp(word\u00dd3\u00a8.str,\"USER\")==EQUALS)&&\n            (strcmp(word\u00dd5\u00a8.str,\"USING\")==EQUALS)) {\n          memset(location,'\\0',sizeof(location));\n          strncpy(location,word\u00dd2\u00a8.ptr,\n                  min(word\u00dd2\u00a8.len,sizeof(location)-1));\n          memset(userid.str,'\\0',sizeof(userid.str));\n          strncpy(userid.str,word\u00dd4\u00a8.ptr,\n                  min(word\u00dd4\u00a8.len,sizeof(userid.str)-1));\n          userid.len=strlen(userid.str);\n          memset(fnNETRC,'\\0',sizeof(fnNETRC));\n          strncpy(fnNETRC,word\u00dd6\u00a8.ptr,\n                  min(word\u00dd6\u00a8.len,sizeof(fnNETRC)-1));\n          passwordNETRC();\n          EXEC SQL CONNECT TO :location USER :userid USING :password;\n          memset(password.str,'\\0',sizeof(password.str));\n        break;\n        }\n    default:\n        Xprintf(\" \\n*ERROR* Invalid or unsupported CONNECT syntax\\n\");\n        Exit(8);\n   }\n   if (SQLCODE) {processSQLCODE(\"CONNECT\"); return;}\n\n         Xprintf(\"*** CONNECT successful\");\n        EXEC SQL GET DIAGNOSTICS CONDITION 1 :connect_info=SERVER_NAME,\n        :server_class = DB2_SERVER_CLASS_NAME,\n        :product_id=DB2_PRODUCT_ID;\n         Xprintf(\", SERVER_NAME='%s'\",connect_info);\n         Xprintf(\", PRODUCT_ID='%s'\\n\",product_id);\n         Xprintf(\"*** SERVER_CLASS='%s'\\n\",server_class);\n   doneSTMNT=YES;\n   return;\n}\n/*********************************************************************\\\n|\n| printCONNECTinfo() -- print out SQLERRMC tokens\n|\n\\*********************************************************************/\nvoid printCONNECTinfo(void) {\n short i;\n unsigned char byte;\n   if (sqlca.sqlerrml>0) {\n    memset(connect_info,'\\0',sizeof(connect_info));\n    strncpy(connect_info,(char*)sqlca.sqlerrmc,sqlca.sqlerrml);\n    for (i=0;i<strlen(connect_info);i++) {\n     byte=connect_info\u00ddi\u00a8;\n     if (byte==0xFF) {connect_info\u00ddi\u00a8=';'; }\n    }\n    Xprintf(\"*** CONNECT_INFO = '%s'\\n\",connect_info);\n   }\n}\n/*********************************************************************\\\n|\n| processSET() -- run SET CONNECTION location-name\n|\n\\*********************************************************************/\nchar* processSET()    {                                         // $fnc$\n   if (strcmp(word\u00dd1\u00a8.str,\"CONNECTION\")!=EQUALS) return(NULL);\n   if (nwords!=3) {\n Xprintf(\" \\n*ERROR* Invalid or unsupported SET CONNECTION syntax\\n\");\n    Exit(8);\n   }\n          memset(location,'\\0',sizeof(location));\n          strncpy(location,word\u00dd2\u00a8.ptr,\n                  min(word\u00dd2\u00a8.len,sizeof(location)-1));\n   EXEC SQL SET CONNECTION :location;\n   if (SQLCODE) {processSQLCODE(\"SET CONNECTION\"); return(NULL);}\n\n        EXEC SQL GET DIAGNOSTICS CONDITION 1 :connect_info=SERVER_NAME;\n         Xprintf(\"*** %-9s successful\",word\u00dd0\u00a8.str);\n         Xprintf(\", SERVER_NAME='%s'\\n\",connect_info);\n   doneSTMNT=YES;\n   return(NULL);\n}\n/*********************************************************************\\\n|\n| processRELEASE() -- run RELEASE here w/o PREPARE & EXECUTE\n|\n\\*********************************************************************/\nchar* processRELEASE() {                                        // $fnc$\n   if (strcmp(word\u00dd1\u00a8.str,\"SAVEPOINT\")==EQUALS) return(NULL);\n   switch (nwords) {\n    case 2:\n        if (strcmp(word\u00dd1\u00a8.str,\"CURRENT\")==EQUALS) {\n          EXEC SQL RELEASE CURRENT;\n          break;\n        } else\n        if (strcmp(word\u00dd1\u00a8.str,\"ALL\")==EQUALS) {\n          EXEC SQL RELEASE ALL;\n          break;\n        } else {\n          memset(location,'\\0',sizeof(location));\n          strncpy(location,word\u00dd1\u00a8.ptr,\n                  min(word\u00dd1\u00a8.len,sizeof(location)-1));\n          EXEC SQL RELEASE :location;\n          break;\n        }\n    case 3:\n        if ((strcmp(word\u00dd1\u00a8.str,\"ALL\")==EQUALS)&&\n            (strcmp(word\u00dd2\u00a8.str,\"PRIVATE\")==EQUALS)) {\n          EXEC SQL RELEASE ALL PRIVATE;\n          break;\n        }\n    default:\n        Xprintf(\" \\n*ERROR* Invalid or unsupported RELEASE syntax\\n\");\n        Exit(8);\n   }\n   if (SQLCODE) {processSQLCODE(\"RELEASE\"); return(NULL);}\n       EXEC SQL GET DIAGNOSTICS CONDITION 1 :connect_info=SERVER_NAME;\n       Xprintf(\"*** %-9s successful\",word\u00dd0\u00a8.str);\n       Xprintf(\", SERVER_NAME='%s'\\n\",connect_info);\n   doneSTMNT=YES;\n   return(NULL);\n}\n/*********************************************************************\\\n|\n|  processWRITE() -- WRITE \u00dddlm\u00a8 FILE file SELECT|WITH ...\n|\n\\*********************************************************************/\nchar* processWRITE(void)  {                                     // $fnc$\n short i=1,rc=0;\n  action=actWRITE;\n  fCSV=fASIS=fRPT=fAPPEND=fDATA=fLABEL=NO;\n  strcpy(dlm,\" \");\n   if ((strcmp(word\u00ddi\u00a8.str,\"FILE\")!=EQUALS)&&\n       (strcmp(word\u00ddi\u00a8.str,\"STACK\")!=EQUALS)) {\n       if (strcmp(word\u00ddi\u00a8.str,\"CSV\"  )==EQUALS) {dlm\u00dd0\u00a8=','; fCSV=YES; }\n  else if (strcmp(word\u00ddi\u00a8.str,\"COMMA\")==EQUALS) {dlm\u00dd0\u00a8=',';           }\n  else if (strcmp(word\u00ddi\u00a8.str,\"TAB\"  )==EQUALS) {dlm\u00dd0\u00a8='\\t';          }\n  else if (strcmp(word\u00ddi\u00a8.str,\"BAR\"  )==EQUALS) {dlm\u00dd0\u00a8='|';           }\n  else if (strcmp(word\u00ddi\u00a8.str,\"RPT\"  )==EQUALS) {dlm\u00dd0\u00a8='|'; fRPT=YES; }\n  else if (strcmp(word\u00ddi\u00a8.str,\"NODLM\")==EQUALS) {dlm\u00dd0\u00a8='\\0';          }\n  else if (strcmp(word\u00ddi\u00a8.str,\"ASIS\" )==EQUALS) {dlm\u00dd0\u00a8='\\0';fASIS=YES;}\n  else syntaxRWerror(i);\n  i++;\n  }\n  if ((strcmp(word\u00ddi\u00a8.str,\"FILE\")!=EQUALS)&&\n      (strcmp(word\u00ddi\u00a8.str,\"STACK\")!=EQUALS)) syntaxRWerror(i);\n  // process STACK\n  if  (strcmp(word\u00ddi\u00a8.str,\"STACK\")==EQUALS) {\n    i++;\n    if ((strcmp(word\u00ddi\u00a8.str,\"DATA\")!=EQUALS)&&\n        (strcmp(word\u00ddi\u00a8.str,\"LABEL\")!=EQUALS)) syntaxRWerror(i);\n    if (strcmp(word\u00ddi\u00a8.str,\"DATA\")==EQUALS) fDATA=YES;\n    else {rc=prepareSTACKlabel(word\u00dd++i\u00a8.str);\n          if (rc) syntaxRWerror(i);\n          fLABEL=YES;\n         }\n    i++;\n  } else {\n // process FILE name\n    i++;\n   if ((strcmp(word\u00ddi\u00a8.str,\"SELECT\")==EQUALS)||\n       (strcmp(word\u00ddi\u00a8.str,\"WITH\")==EQUALS)||\n       (strcmp(word\u00ddi\u00a8.str,\"APPEND\")==EQUALS)||\n       (word\u00ddi\u00a8.len==0))\n       syntaxRWerror(i);\n   memset(fnWRITE,'\\0',sizeof(fnWRITE));\n   strncpy(fnWRITE,word\u00ddi\u00a8.ptr,\n           min(word\u00ddi\u00a8.len,sizeof(fnWRITE)-1));\n   i++;\n  }\n  if (strcmp(word\u00ddi\u00a8.str,\"APPEND\")==EQUALS)\n     {fAPPEND=YES; i++;}\n  return(word\u00ddi\u00a8.ptr);\n}\n/*********************************************************************\\\n|\n|  createSESSION() -- declare a session table based on sqlvars\n|\n\\*********************************************************************/\nvoid createSESSION(char *table) {\n int i,n;\n char str\u00dd30\u00a8;\n\n    if (SQLd==0) return;\n    strcpy(SELECT.Str,\"DECLARE GLOBAL TEMPORARY TABLE \");\n    strcat(SELECT.Str,table);\n    strcat(SELECT.Str,\" (\");\n\n    for(i=0;i<SQLd;i++) {\n      n=0;\n      if (SQLNAMEL(i)==0) {\n       sprintf(str,\"COL%d\",i+1);\n       strncat(SELECT.Str,str,strlen(str));\n      } else\n      strncat(SELECT.Str,SQLNAMED(i),SQLNAMEL(i));\n      strcat(SELECT.Str,\" \");\n\n      switch (SQLTYPE(i)) {\n        case sVARBINn: n=1;\n        case sVARBIN:\n           strcat(SELECT.Str,\"VARBINARY(\");\n           sprintf(str,\"%d)\",SQLLEN(i));\n           strcat(SELECT.Str,str);\n           break;\n        case sBINn: n=1;\n        case sBIN:\n           strcat(SELECT.Str,\"BINARY(\");\n           sprintf(str,\"%d)\",SQLLEN(i));\n           strcat(SELECT.Str,str);\n           break;\n        case sVCHARn:   case sLVCHARn: n=1;\n        case sVCHAR:    case sLVCHAR:\n           strcat(SELECT.Str,\"VARCHAR(\");\n           sprintf(str,\"%d)\",SQLLEN(i));\n           strcat(SELECT.Str,str);\n           break;\n        case sCHARn: n=1;\n        case sCHAR:\n           strcat(SELECT.Str,\"CHAR(\");\n           sprintf(str,\"%d)\",SQLLEN(i));\n           strcat(SELECT.Str,str);\n           break;\n        case sDATEn: n=1;     case sDATE:\n           strcat(SELECT.Str,\"DATE\");\n           break;\n        case sTIMEn: n=1;      case sTIME:\n           strcat(SELECT.Str,\"TIME\");\n           break;\n        case sTIMESTAMPn: n=1;case sTIMESTAMP:\n           strcat(SELECT.Str,\"TIMESTAMP\");\n           break;\n        case sFLOATn:n=1;     case sFLOAT:\n           if (SQLLEN(i)==4)\n           strcat(SELECT.Str,\"FLOAT\");\n           else\n           strcat(SELECT.Str,\"DOUBLE\");\n           break;\n        case sBIGINTn:n=1;       case sBIGINT:\n           strcat(SELECT.Str,\"BIGINT\");\n           break;\n        case sINTn:n=1;       case sINT:\n           strcat(SELECT.Str,\"INTEGER\");\n           break;\n        case sSMINTn:n=1;     case sSMINT:\n           strcat(SELECT.Str,\"SMALLINT\");\n           break;\n        case sDECn:n=1;       case sDEC:\n           strcat(SELECT.Str,\"DECIMAL(\");\n           parseDecSQLLEN(i);\n           sprintf(str,\"%d\",prec);\n           strcat(SELECT.Str,str);\n           if (scale>0) {\n            sprintf(str,\",%d\",scale);\n            strcat(SELECT.Str,str);\n           }\n           strcat(SELECT.Str,\")\");\n           break;\n        case sDECFLOATn:n=1;   case sDECFLOAT:\n           if (SQLLEN(i)==8)  strcat(SELECT.Str,\"DECFLOAT(16)\");\n           else               strcat(SELECT.Str,\"DECFLOAT(34)\");\n           break;\n        default:\n           Xprintf(\" \\n*ERROR* Unsupported SQLTYPE=%d\\n\",SQLTYPE(i));\n           Exit(8);\n      } // switch\n    if (n==0) strcat(SELECT.Str,\" WITH DEFAULT NOT NULL\");\n    if (n==1) strcat(SELECT.Str,\" WITH DEFAULT NULL\");\n    if (i<SQLd-1) strcat(SELECT.Str,\",\");\n    }  // for\n    strcat(SELECT.Str,\") ON COMMIT PRESERVE ROWS\");\n    SELECT.Len=strlen(SELECT.Str);\n    if (trace) Xprintf(\" SELECT.Str='%s'\\n\",SELECT.Str);\n    EXEC SQL PREPARE STMNT2 FROM :SELECT;\n    if (SQLCODE) {processSQLCODE(\"PREPARE SESSION\"); return;}\n    EXEC SQL EXECUTE STMNT2;\n    if (SQLCODE) {processSQLCODE(\"EXECUTE SESSION\"); return;}\n    SQLd=0;\n    Xprintf(\"*** Temporary table %s declared implicitly\\n\",table);\n}\n/*********************************************************************\\\n|\n|  processSAVE() -- SAVE DATA AS table SELECT|WITH ...\n|\n\\*********************************************************************/\nchar* processSAVE(void)  {                                     // $fnc$\n short i=1;\n  if ((strcmp(word\u00dd1\u00a8.str,\"DATA\")!=EQUALS)||\n      (strcmp(word\u00dd2\u00a8.str,\"AS\")!=EQUALS)||\n      (word\u00dd3\u00a8.len==0)||\n      ((strcmp(word\u00dd4\u00a8.str,\"SELECT\")!=EQUALS)&&\n       (strcmp(word\u00dd4\u00a8.str,\"WITH\")==EQUALS)) )\n  { Xprintf(\" \\n*ERROR* Invalid SAVE DATA AS syntax\\n\"); Exit(8);}\n\n//                 SAVE DATA AS  -- overlay\n  strncpy(SQL.Str,\"INSERT INTO \",12);\n  strcpy(SELECT.Str,\"SELECT * FROM \");\n  strcat(SELECT.Str,word\u00dd3\u00a8.str);\n  SELECT.Len=strlen(SELECT.Str);\n  EXEC SQL PREPARE STMNT2 FROM :SELECT;\n  if (SQLCODE==0) {\n   if (trace) Xprintf(\" SQL.Str=%s\\n\",SQL.Str);\n   return(NULL);\n  }\n  if (strncmp(word\u00dd3\u00a8.str,\"SESSION.\",8)!=EQUALS)\n  { Xprintf(\" \\n*ERROR* Table %s not exists\\n\",word\u00dd3\u00a8.str); Exit(8);}\n  // try to create a SESSION table\n  strcpy(SELECT.Str,word\u00dd4\u00a8.ptr);\n  SELECT.Len=strlen(SELECT.Str);\n  EXEC SQL PREPARE STMNT2 FROM :SELECT;\n  if (SQLCODE) {processSQLCODE(\"PREPARE SELECT\"); return(NULL);}\n  // get column description\n  do {\n   EXEC SQL DESCRIBE STMNT2 INTO :*pSQLDA;\n   if (SQLCODE) {processSQLCODE(\"DESCRIBE SELECT\"); return(NULL);}\n  } while (checkSQLd());\n  createSESSION(word\u00dd3\u00a8.str);\n  return(NULL);\n}\n/*********************************************************************\\\n|\n|  processDDL() -- generate DDL for a select\n|\n\\*********************************************************************/\nvoid processDDL(void)  {                                       // $fnc$\n short i=1,n=0;\n char str\u00dd30\u00a8;\n char *p=word\u00dd1\u00a8.ptr;\n\n  datalen=80;\n  if (action==actWRITE) openWRITE();\n\n  memset(str,'\\0',sizeof(str));\n  if (strcmp(word\u00dd1\u00a8.str,\"TABLE\")==EQUALS) {\n   strncpy(str,word\u00dd2\u00a8.str,min(sizeof(str)-1,word\u00dd2\u00a8.len));\n   p=word\u00dd3\u00a8.ptr;\n  } else {\n   sprintf(str,\"SESSION.T%d\",sessionNo++);\n   p=word\u00dd1\u00a8.ptr;\n  }\n\n  strcpy(SELECT.Str,p);\n  SELECT.Len=strlen(p);\n  EXEC SQL PREPARE STMNT2 FROM :SELECT;\n  if (SQLCODE) {\n   Xprintf(\" \\n*ERROR* PREPARE '%s'\\n\",SELECT.Str);\n   processSQLCODE(\"PREPARE SELECT\");\n   return;\n  }\n  // get column description\n  do {\n   EXEC SQL DESCRIBE STMNT2 INTO :*pSQLDA;\n   if (SQLCODE) {processSQLCODE(\"DESCRIBE SELECT\"); return;}\n  } while (checkSQLd());\n  if (SQLd==0) {\n   Xprintf(\" \\n*ERROR* DDL is allowed before a SELECT only\\n\");\n   Exit(8);\n  }\n\n  doneSTMNT=YES;\n  sprintf(outBUF,\"    DECLARE GLOBAL TEMPORARY TABLE %s (\",str);\n  outBUFrecord();\n\n  for(i=0;i<SQLd;i++) {\n      n=0;\n      memset(outBUF,'\\0',sizeof(outBUF));\n      memset(outBUF,' ',6);\n      if (SQLNAMEL(i)==0) {\n       sprintf(outBUF+6,\"COL%d\",i+1);\n      } else\n       strncpy(outBUF+6,SQLNAMED(i),SQLNAMEL(i));\n      strcat(outBUF,\" \");\n\n      strncat(outBUF,\"                       \",\n              Max((short)(20+6-strlen(outBUF)),1));\n\n      switch (SQLTYPE(i)) {\n        case sVARBINn: n=1;\n        case sVARBIN:\n           strcat(outBUF,\"VARBINARY(\");\n           sprintf(str,\"%d)\",SQLLEN(i));\n           strcat(outBUF,str);\n           break;\n        case sBINn: n=1;\n        case sBIN:\n           strcat(outBUF,\"BINARY(\");\n           sprintf(str,\"%d)\",SQLLEN(i));\n           strcat(outBUF,str);\n           break;\n        case sVCHARn:   case sLVCHARn: n=1;\n        case sVCHAR:    case sLVCHAR:\n           strcat(outBUF,\"VARCHAR(\");\n           sprintf(str,\"%d)\",SQLLEN(i));\n           strcat(outBUF,str);\n           break;\n        case sCHARn: n=1;\n        case sCHAR:\n           strcat(outBUF,\"CHAR(\");\n           sprintf(str,\"%d)\",SQLLEN(i));\n           strcat(outBUF,str);\n           break;\n        case sDATEn: n=1;     case sDATE:\n           strcat(outBUF,\"DATE\");\n           break;\n        case sTIMEn: n=1;      case sTIME:\n           strcat(outBUF,\"TIME\");\n           break;\n        case sTIMESTAMPn: n=1;case sTIMESTAMP:\n           strcat(outBUF,\"TIMESTAMP\");\n           break;\n        case sFLOATn:n=1;     case sFLOAT:\n           if (SQLLEN(i)==4)\n           strcat(outBUF,\"FLOAT\");\n           else\n           strcat(outBUF,\"DOUBLE\");\n           break;\n        case sBIGINTn:n=1;    case sBIGINT:\n           strcat(outBUF,\"BIGINT\");\n           break;\n        case sINTn:n=1;       case sINT:\n           strcat(outBUF,\"INTEGER\");\n           break;\n        case sSMINTn:n=1;     case sSMINT:\n           strcat(outBUF,\"SMALLINT\");\n           break;\n        case sDECn:n=1;       case sDEC:\n           strcat(outBUF,\"DECIMAL(\");\n           parseDecSQLLEN(i);\n           sprintf(str,\"%d\",prec);\n           strcat(outBUF,str);\n           if (scale>0) {\n            sprintf(str,\",%d\",scale);\n            strcat(outBUF,str);\n           }\n           strcat(outBUF,\")\");\n           break;\n        case sDECFLOATn:n=1;   case sDECFLOAT:\n           if (SQLLEN(i)==8)\n           strcat(outBUF,\"DECFLOAT(16)\");\n           else\n           strcat(outBUF,\"DECFLOAT(34)\");\n           break;\n        default:\n           Xprintf(\" \\n*ERROR* Unsupported SQLTYPE=%d\\n\",SQLTYPE(i));\n           Exit(8);\n      } // switch\n    strncat(outBUF,\"                                            \",\n              Max((short)(42-strlen(outBUF)),1));\n    if (n==0) strcat(outBUF,\" WITH DEFAULT NOT NULL\");\n    if (n==1) strcat(outBUF,\" WITH DEFAULT NULL\");\n    if (i<SQLd-1) strcat(outBUF,\",\");\n    outBUFrecord();\n    }  // for\n    strcpy(outBUF+4,\") ON COMMIT PRESERVE ROWS;\");\n    outBUFrecord();\n    if (action==actWRITE)\n    {Xprintf(\"*** Successful WRITE of %d record(s),\"\n           \" RECFM=FB, LRECL=%d\\n\",cntWRITE,lreclWRITE);RC=0;}\n  return;\n}\n/*********************************************************************\\\n|\n|  processDRAW() -- generate a column list for a table\n|\n\\*********************************************************************/\nvoid processDRAW(void) {\n short i;\n char colnn\u00dd10\u00a8;\n  if ((strcmp(word\u00dd1\u00a8.str,\"COLNAMES\")!=EQUALS) ||\n      (word\u00dd2\u00a8.len==0)) {\n   Xprintf(\" \\n*ERROR* Invalid %s syntax\\n\",word\u00dd0\u00a8.str);\n   Exit(8);\n  }\n\n  sprintf(SELECT.Str,\"SELECT * FROM %s\",word\u00dd2\u00a8.str);\n  SELECT.Len=strlen(SELECT.Str);\n  EXEC SQL PREPARE STMNT2 FROM :SELECT;\n  if (SQLCODE) {\n   Xprintf(\" \\n*ERROR* PREPARE '%s'\\n\",SELECT.Str);\n   processSQLCODE(\"PREPARE SELECT\");\n   return;\n  }\n  // get column names\n  do {\n   EXEC SQL DESCRIBE STMNT2 INTO :*pSQLDA;\n   if (SQLCODE) {processSQLCODE(\"DESCRIBE SELECT\"); return;}\n  } while (checkSQLd());\n\n  memset(outBUF,'\\0',sizeof(outBUF));\n  memset(outBUF,' ',8);\n  for(i=0;i<SQLd;i++) {\n    if (i>0) strcat(outBUF,\", \");\n    if (SQLNAMEL(i)==0) {sprintf(colnn,\"COL%d\",i+1);\n                         strcat(outBUF,colnn);}\n    else\n    {\n     strncat(outBUF,SQLNAMED(i),SQLNAMEL(i));\n     if (strlen(outBUF)>55)\n     {\n      outBUFrecord();\n      memset(outBUF,'\\0',sizeof(outBUF));\n      memset(outBUF,' ',6);\n     }\n    }\n   }\n   if (strlen(outBUF)>0) outBUFrecord();\n   doneSTMNT=YES;\n  return;\n}\n/*********************************************************************\\\n|\n|  processINCLUDE -- open INCLUDE file with additional SQL input\n|\n\\*********************************************************************/\nvoid processINCLUDE(void)  {                                    // $fnc$\n   if (eofINCLUDE==NO) {\n     Xprintf(\" \\n*ERROR* Embedded INCLUDE is not allowed\\n\");\n     Exit(8);\n   }\n   if (strcmp(word\u00dd1\u00a8.str,\"FILE\")==EQUALS) {\n    if (word\u00dd2\u00a8.len==0) {\n     Xprintf(\" \\n*ERROR* Missing file name found\\n\");\n     Exit(8);\n    }\n    memset(fnINCLUDE,'\\0',sizeof(fnINCLUDE));\n    strncpy(fnINCLUDE,word\u00dd2\u00a8.str,min(word\u00dd2\u00a8.len,sizeof(fnINCLUDE)-1));\n    if ( (fpINCLUDE=fopen(fnINCLUDE,\"r\")) == NULL ) {\n     Xprintf(\" \\n*ERROR* INCLUDE Open %s failed: %s \\n\",\n                fnINCLUDE, strerror(errno));\n     Exit(12);\n    }\n    eofINCLUDE=NO;\n    doneSTMNT=YES;\n    return;\n   }\n   Xprintf(\" \\n*ERROR* Invalid syntax\\n\");\n   Exit(8);\n}\n/*********************************************************************\\\n|\n|  processREAD() -- READ \u00dddlm\u00a8 FILE file \u00ddDISCARD \u00ddfile\u00a8\u00a8\n|                   INSERT INTO table \u00dd(columns)\u00a8 VALUES(*|p1:p2,p3.l3)\n|\n\\*********************************************************************/\nchar* processREAD(void)  {                                      // $fnc$\n char  *ptr;\n short i=1,error=NO;\n   action=actREAD;\n   fCSV=fASIS=fDISCARD=fDISCARDfn=fDATA=fLABEL=NO;\n   strcpy(dlm,\" \");\n   memset(fnDISCARD,'\\0',sizeof(fnDISCARD));\n\n   if ((strcmp(word\u00ddi\u00a8.str,\"FILE\")!=EQUALS)&&\n       (strcmp(word\u00ddi\u00a8.str,\"STACK\")!=EQUALS)) {\n      if (strcmp(word\u00ddi\u00a8.str,\"CSV\"  )==EQUALS) {dlm\u00dd0\u00a8=','  ;fCSV=YES ;}\n else if (strcmp(word\u00ddi\u00a8.str,\"COMMA\")==EQUALS) {dlm\u00dd0\u00a8=','  ;          }\n else if (strcmp(word\u00ddi\u00a8.str,\"TAB\"  )==EQUALS) {dlm\u00dd0\u00a8='\\t' ;          }\n else if (strcmp(word\u00ddi\u00a8.str,\"BAR\"  )==EQUALS) {dlm\u00dd0\u00a8='|'  ;          }\n else if (strcmp(word\u00ddi\u00a8.str,\"NODLM\")==EQUALS) {dlm\u00dd0\u00a8='\\0' ;          }\n else if (strcmp(word\u00ddi\u00a8.str,\"ASIS\" )==EQUALS) {dlm\u00dd0\u00a8='\\0' ;fASIS=YES;}\n else syntaxRWerror(i);\n     i++;\n   }\n   if ((strcmp(word\u00ddi\u00a8.str,\"FILE\")!=EQUALS)&&\n       (strcmp(word\u00ddi\u00a8.str,\"STACK\")!=EQUALS)) syntaxRWerror(i);\n  // process STACK\n  if  (strcmp(word\u00ddi\u00a8.str,\"STACK\")==EQUALS) {\n    i++;\n    if ((strcmp(word\u00ddi\u00a8.str,\"DATA\")!=EQUALS)&&\n        (strcmp(word\u00ddi\u00a8.str,\"LABEL\")!=EQUALS)) syntaxRWerror(i);\n    if (strcmp(word\u00ddi\u00a8.str,\"DATA\")==EQUALS) fDATA=YES;\n    else {rc=prepareSTACKlabel(word\u00dd++i\u00a8.str);\n          if (rc||eofLABEL) syntaxRWerror(i);\n          fLABEL=YES;\n         }\n    i++;\n  } else {\n // process FILE name\n    i++;\n   if ((strcmp(word\u00ddi\u00a8.str,\"DISCARD\")==EQUALS)||\n       (strcmp(word\u00ddi\u00a8.str,\"INSERT\" )==EQUALS)||\n       (word\u00ddi\u00a8.len==0)) syntaxRWerror(i);\n       memset(fnREAD,'\\0',sizeof(fnREAD));\n       strncpy(fnREAD,word\u00ddi\u00a8.ptr,min(word\u00ddi\u00a8.len,sizeof(fnREAD)-1));\n   i++;\n   }\n // process DISCARD name\n   if (strcmp(word\u00ddi\u00a8.str,\"DISCARD\")==EQUALS) {\n      fDISCARD=ON;\n      i++;\n      if (word\u00ddi\u00a8.len==0) syntaxRWerror(i);\n      if (strcmp(word\u00ddi\u00a8.str,\"INSERT\")!=EQUALS) {\n       strncpy(fnDISCARD,word\u00ddi\u00a8.ptr,\n               min(word\u00ddi\u00a8.len,sizeof(fnDISCARD)-1));\n       fDISCARDfn=ON;\n       multiRows_save = multiRows;\n       multiRows = 1;\n       i++;\n      }\n   }\n   if ((strcmp(word\u00ddi\u00a8.str,\"ECHO\")==EQUALS)||\n       (strcmp(word\u00ddi\u00a8.str,\"SAY\")==EQUALS))\n   return(word\u00ddi\u00a8.ptr);\n\n   if ((strcmp(word\u00ddi\u00a8.str,\"INSERT\")!=EQUALS)||\n       ((ptr=strstr(word\u00ddi\u00a8.ptr,\"VALUES\"))==NULL)||\n       ((ptr=strchr(ptr,'('))==NULL)||\n       ((ptr=strchr(ptr,')'))==NULL)\n      )\n{Xprintf(\" \\n*ERROR* READ must be before INSERT INTO...VALUES(...);\\n\");\n   if (trace) Xprintf(\" word\u00dd%d\u00a8.ptr='%s'\\n\",i,word\u00ddi\u00a8.ptr);\n    Exit(8);}\n    describeINSERT(word\u00ddi\u00a8.ptr);\n   return(word\u00ddi\u00a8.ptr);\n}\n/*********************************************************************\\\n|\n|  syntaxRWerror() -- print out READ/WRITE syntax error message\n|\n\\*********************************************************************/\nvoid syntaxRWerror(short i) {                                   // $fnc$\n   Xprintf(\" \\n*ERROR* Invalid syntax on %s\\n\",word\u00ddi\u00a8.str);\n   Exit(8);\n}\n/*********************************************************************\\\n|\n|  describeINSERT() -- describe INSERT columns into SQLDA\n|\n\\*********************************************************************/\nvoid describeINSERT(char *p) {                                  // $fnc$\n char *p1,*p2,*pv,*pt;\n int  n;\n\n    memset(SELECT.Str,'\\0',sizeof(SELECT.Str));\n    // find a table name\n    pt=findword(p,3,n);\n\n    // build \"SELECT *|column-list FROM table\" from the INSERT stmnt\n    p1=pt+n+1;                               // start of possible list\n    pv=strstr(p1,\"VALUES\");                  // start of VALUES word\n    p1=strchr(p1,'(');                       // find '('\n    if (p1<pv) {                             // if '(' is before VALUES\n     p1++;if (p1\u00dd0\u00a8==' ') p1++;              // p1 is start\n     p2=strchr(p1,')');                      // find ')'\n     if (p2>pv) return;                      // if ')' is after VALUES\n     strcpy(SELECT.Str,\"SELECT \");           // build SELECT\n     strncat(SELECT.Str,p1,p2-p1);           // with column names\n    } else                                   // if there is no list\n     strcpy(SELECT.Str,\"SELECT *\");          // use * for all columns\n    strcat(SELECT.Str,\" FROM \");             // append FROM\n    strncat(SELECT.Str,pt,n);                // append table name\n    SELECT.Len=strlen(SELECT.Str);           // complete SELECT struct\n\n    if (trace)\n      Xprintf(\" struct SELECT {%d,'%s'}\\n\",SELECT.Len,SELECT.Str);\n\n    // Prepare & describe the SELECT into SQLDA\n    EXEC SQL PREPARE STMNT2 FROM :SELECT;\n     if (SQLCODE) {processSQLCODE(\"PREPARE SELECT\"); return;}\n    do {\n    EXEC SQL DESCRIBE STMNT2 INTO :*pSQLDA;\n     if (SQLCODE) {processSQLCODE(\"DESCRIBE SELECT\"); return;}\n    } while (checkSQLd());\n    parseVALUES(pv);\n}\n/*********************************************************************\\\n|\n|  parseVALUES()  -- parse column positions\n|\n\\*********************************************************************/\nvoid parseVALUES(char *p) {                                     // $fnc$\n char *ps,*pe,*pv;\n struct COLPOS *pc;\n int  i,rc;\n\n    pCOLPOS=(struct COLPOS*) malloc(sizeof(struct COLPOS)*SQLd);\n    if (pCOLPOS==NULL) Exit(999);\n    memset(pCOLPOS,'\\0',sizeof(COLPOS)*SQLd);\n\n    pv=strchr(p,'('); pv++; ps=pv;               // point to first pos\n    pe=strchr(p,')'); pe\u00dd0\u00a8='\\0';                // kill the ')'\n\n    while (ps=strchr(ps,' ')) {strcpy(ps,ps+1);} // remove blanks\n                                                 // from positions\n    ps=pv;\n    if ((rc=(strcmp(ps,\"*\")==EQUALS))&&\n        (strlen(dlm)==0)&&(!fASIS)) {\n      Xprintf(\" \\n*ERROR* VALUES(*) is invalid for NODLM file\\n\");\n      Exit(8);\n    }\n    fixposFlag=strcmp(ps,\"*\");                   // 0=\"*\"\n    for (i=0;(i<SQLd)&&(fixposFlag);i++) {       // if not \"*\"\n     pc=&pCOLPOS\u00ddi\u00a8;\n     if (pe=strchr(ps,',')) {                    // char i-pos\n//    strncpy(pc->posstr,ps,min(pe-ps,sizeof(COLPOS::posstr)-1));\n      strncpy(pc->posstr,ps,min(pe-ps,20));\n      ps=pe+1;\n      }\n     else {                                       // last char pos\n//    strncpy(pc->posstr,ps,min(strlen(ps),sizeof(COLPOS::posstr)-1));\n      strncpy(pc->posstr,ps,min(strlen(ps),20));\n\n      break;\n     }\n    }\n\n    if ((i+1<SQLd)&&(fixposFlag))\n     {Xprintf(\" \\n*ERROR* Number of VALUES positions is %d but \"\n             \"the target table has %d columns\",i+1,SQLd); Exit(8);}\n    maxpos=0;\n    for (i=0;(i<SQLd)&&(fixposFlag);i++) {         // for each column\n     pc=&pCOLPOS\u00ddi\u00a8;\n//   pc->posstr=toupper(pc->posstr);\n           if (ps=strchr(pc->posstr,':')) pc->dlm=':';\n      else if (ps=strchr(pc->posstr,'.')) pc->dlm='.';\n      else\n     {Xprintf(\" \\n*ERROR* Invalid syntax of positions #%d (%s): \"\n             \"empty or bypassed ':' or '.'\",i+1,pc->posstr); Exit(8); }\n\n     strncpy(pc->pos1,pc->posstr,ps-pc->posstr);\n     strcpy(pc->pos2,ps+1);\n     if ((strlen(pc->pos1)==0)||\n         (strlen(pc->pos2)==0)||\n//       (strlen(pc->pos1)==sizeof(COLPOS::pos1)-1)||\n//       (strlen(pc->pos2)==sizeof(COLPOS::pos2)-1)||\n         (strlen(pc->pos1)==6)||\n         (strlen(pc->pos2)==6)||\n         (checkdigits(pc->pos1)!=NULL)||\n         (checkdigits(pc->pos2)!=NULL)||\n         (atoi(pc->pos1)==0)||(atoi(pc->pos1)>32767)||\n         (atoi(pc->pos2)==0)||(atoi(pc->pos2)>32767))\n     {Xprintf(\" \\n*ERROR* Invalid syntax of positions #%d (%s)\\n\",\n             i+1,pc->posstr); Exit(8); }\n     pc->start=atoi(pc->pos1);\n     pc->len=atoi(pc->pos2);\n     if ( (pc->dlm==':')&&(pc->start>pc->len) )\n     {Xprintf(\" \\n*ERROR* Invalid positions #%d (%s), \",\n             \"start > end \\n\",i+1,pc->posstr); Exit(8); }\n     if (pc->dlm==':') pc->len=pc->len-pc->start+1;\n     maxpos=Max(maxpos,pc->start+pc->len-1);\n    }\n    ps=pv;\n    for (i=0;i<SQLd;i++) {                   // for each column\n     strcpy(ps,\"?,\");\n     ps=ps+2;\n     pc=&pCOLPOS\u00ddi\u00a8;\n     strncpy(pc->sqlname,SQLNAMED(i),SQLNAMEL(i));\n    }\n    ps--;\n    strcpy(ps,\")\");\n    allocSQLVARarrays(multiRows);\n}\n/*********************************************************************\\\n|\n|  checkdigits()\n|\n\\*********************************************************************/\nchar* checkdigits(char *p) {                                    // $fnc$\n  for (int i=0;i<strlen(p);i++) {\n   if ((*p<'0')||(*p>'9')) return(p);\n   p++;\n  }\n  return(NULL);\n}\n/*********************************************************************\\\n|\n|  checkSQLd() -- check if SQLVARs number is too small\n|\n\\*********************************************************************/\nint checkSQLd(void) {                                           // $fnc$\n if ((SQLd+1)>SQLn) {\n  numvars=SQLd+1;\n  allocSQLDA(numvars);\n  Xprintf(\" --#SET NUMVARS %d\\n\",numvars);\n  return(1);\n }\n return(0);\n}\n/*********************************************************************\\\n|\n|  processEXPLAIN()\n|\n\\*********************************************************************/\nchar* processEXPLAIN()  {                                       // $fnc$\n\n    if ((strcmp(word\u00dd1\u00a8.str,\"PLAN\")==EQUALS)||\n       (strcmp(word\u00dd1\u00a8.str,\"ALL\")==EQUALS)) return(NULL);\n\n    strcpy(BUF,word\u00dd1\u00a8.ptr);                   // w/o EXPLAIN word\n    // DELETE FROM PLAN_TABLE WHERE QUERYNO=0\n    strcpy(SQL.Str,deletestr);                 // DELETE QUERYNO=0;\n    SQL.Len=strlen(SQL.Str);\n    EXEC SQL PREPARE STMNT2 FROM :SQL;\n    if (SQLCODE) {processSQLCODE(\"PREPARE DELETE PLAN\"); return(NULL);}\n\n    EXEC SQL EXECUTE STMNT2;\n    if ((SQLCODE!=0)&&(SQLCODE!=100))\n     {processSQLCODE(\"EXECUTE DELETE PLAN\"); return(NULL);}\n\n    // EXPLAIN PLAN SET QUERYNO=0 FOR\n    strcpy(SQL.Str,explainstr);\n    strcat(SQL.Str,BUF);\n    SQL.Len=strlen(SQL.Str);\n    EXEC SQL PREPARE STMNT2 FROM :SQL;\n    if (SQLCODE) {processSQLCODE(\"PREPARE EXPLAIN PLAN\");return(NULL);}\n\n    EXEC SQL EXECUTE STMNT2;\n    if ((SQLCODE!=0)&&(SQLCODE!=100))\n     {processSQLCODE(\"EXECUTE EXPLAIN PLAN\"); return(NULL);}\n\n    // SELECT fields FROM PLAN_TABLE WHERE QUERYNO=0 ORDER BY ...\n    strcpy(SQL.Str,selectPlan);\n    SQL.Len=strlen(SQL.Str);\n    fEXPLAIN=YES;\n    hold_signposFlag=signposFlag;\n    hold_nullchar=nullchar;\n    signposFlag=NO;\n    nullchar=' ';\n    return(NULL);\n}\n/*********************************************************************\\\n|\n|  processSTACK()\n|\n\\*********************************************************************/\nchar* processSTACK()  {                                         // $fnc$\n short i,rc=0;\n    fFIFO=fLIFO=fDATA=fLABEL=NO;\n         if (strcmp(word\u00dd1\u00a8.str,\"DATA\")==EQUALS) {fDATA=YES; i=2;}\n    else if (strcmp(word\u00dd1\u00a8.str,\"FIFO\")==EQUALS) {fFIFO=YES; i=2;}\n    else if (strcmp(word\u00dd1\u00a8.str,\"LIFO\")==EQUALS) {fLIFO=YES; i=2;}\n    else if (strcmp(word\u00dd1\u00a8.str,\"LABEL\")==EQUALS) {fLABEL=YES; i=3;\n             rc=prepareSTACKlabel(word\u00dd2\u00a8.str);}\n    else rc=1;\n    if (rc) {Xprintf(\" \\n*ERROR* Invalid STACK syntax\\n\");Exit(8);}\n    action=actSTACK;\n    strcpy(dlm,\"\\0\");\n    return(word\u00ddi\u00a8.ptr);\n}\n/*********************************************************************\\\n|\n|  prepareSTACKlabel()\n|\n\\*********************************************************************/\nshort prepareSTACKlabel(char* label) {                          // $fnc$\n char  l\u00ddsizeof(stackLABEL)\u00a8;\n short n,i,f=0;\n  n=strlen(label);\n  if ((strcmp(label,\"SELECT\")==EQUALS)||\n      (strcmp(label,\"DDL\"   )==EQUALS)||\n      (strcmp(label,\"DB2\"   )==EQUALS)||\n      (strcmp(label,\"WITH\"  )==EQUALS)) return(1);\n  if (n==0||n>sizeof(stackLABEL)-2) return(1);\n  memset(l,'\\0',sizeof(l));\n  strcpy(l,label);\n  if (l\u00ddn-1\u00a8!=':') l\u00ddn\u00a8=':';\n  // Check if the stack label exists already\n  for (i=0;i<numLABEL;i++) {\n   if (strcmp(arrayLABEL\u00ddi\u00a8.label,l)==EQUALS) {\n    indexLABEL=i;\n    eofLABEL=NO;\n    return(0);\n   }\n  }\n  // Label is new, prepare a stack entry\n  for (i=0;i<numLABEL;i++) {\n    if (arrayLABEL\u00ddi\u00a8.label\u00dd0\u00a8!='\\0') continue;\n    strcpy(arrayLABEL\u00ddi\u00a8.label,l);\n    indexLABEL=i;\n    arrayLABEL\u00ddi\u00a8.pfirst = NULL;\n    arrayLABEL\u00ddi\u00a8.plast  = (struct stack *) &arrayLABEL\u00ddi\u00a8.pfirst;\n    eofLABEL=YES;\n    return(0);\n  }\n  Xprintf(\" \\n*ERROR* Max STACK LABEL number (%d) exeeded\\n\",numLABEL);\n  Exit(8);\n  return(1);\n}\n/*********************************************************************\\\n|\n|  processEND()\n|\n\\*********************************************************************/\nvoid  processEND(void) {                                        // $fnc$\n  eofINSQL=YES;          // what about the end of STACK????\n  doneSTMNT=YES;\n}\n/*********************************************************************\\\n|\n|  processECHO()\n|\n\\*********************************************************************/\nvoid  processECHO(void) {\n int n=32700,i=1;\n  strcpy(outBUF,word\u00dd1\u00a8.ptr);\n  multiRows_save=multiRows;\n  multiRows=1;\n  if (action==actWRITE) {\n    datalen=80;\n    openWRITE();\n    outBUFrecord();\n  } else\n  if (action==actREAD) {\n      if ((nwords>1) && (checkint(word\u00dd1\u00a8.ptr,word\u00dd1\u00a8.len,8)==0))\n      { n=atoi(word\u00dd1\u00a8.ptr); i=2;}\n      if (nwords>i) Xprintf(\"%s\\n\",word\u00ddi\u00a8.ptr);\n      fECHO=YES;\n      loadSQLDATAarrays();\n      for (i=0;((eofREAD==NO)&&(i<n));i++) {\n        outBUFrecord();\n        loadSQLDATAarrays();\n      }\n  } else outBUFrecord();\n  multiRows=multiRows_save;\n  doneSTMNT=YES;\n}\n/*********************************************************************\\\n|\n|  processSAY()\n|\n\\*********************************************************************/\nvoid  processSAY(void) {\n  printf(\"%s\\n\",word\u00dd1\u00a8.ptr);\n  doneSTMNT=YES;\n}\n/*********************************************************************\\\n|\n|  processRC() -- set/reset or save current RC\n|\n\\*********************************************************************/\nvoid  processRC(void) {                                         // $fnc$\n         if (strcmp(word\u00dd0\u00a8.str,\"RC=0\")==EQUALS) RC=0;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC=4\")==EQUALS) RC=4;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC=8\")==EQUALS) RC=8;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC1=0\")==EQUALS) RC1=0;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC2=0\")==EQUALS) RC2=0;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC3=0\")==EQUALS) RC3=0;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC4=0\")==EQUALS) RC4=0;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC1=4\")==EQUALS) RC1=4;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC2=4\")==EQUALS) RC2=4;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC3=4\")==EQUALS) RC3=4;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC4=4\")==EQUALS) RC4=4;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC1=8\")==EQUALS) RC1=8;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC2=8\")==EQUALS) RC2=8;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC3=8\")==EQUALS) RC3=8;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC4=8\")==EQUALS) RC4=8;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC1=RC\")==EQUALS) RC1=RC;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC2=RC\")==EQUALS) RC2=RC;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC3=RC\")==EQUALS) RC3=RC;\n    else if (strcmp(word\u00dd0\u00a8.str,\"RC4=RC\")==EQUALS) RC4=RC;\n    else { Xprintf(\" \\n*ERROR* Invalid syntax, \"\n                  \"valid RC\u00ddn\u00a8=0|4|8,RCn=RC (n=1-4)\\n\");Exit(8);}\n    doneSTMNT=YES;\n}\n/*********************************************************************\\\n|\n|  processIF() -- IF condition \u00ddDO;\u00a8 statement(s); \u00ddENDIF;\u00a8\n|\n\\*********************************************************************/\nchar* processIF(void) {                                         // $fnc$\n short flagIF=NO;\n struct cache *p;\n         if (!strcmp(word\u00dd1\u00a8.str,\"RC=0\"))  {if (RC==0)  flagIF=YES;}\n    else if (!strcmp(word\u00dd1\u00a8.str,\"RC=4\"))  {if (RC==4)  flagIF=YES;}\n    else if (!strcmp(word\u00dd1\u00a8.str,\"RC=8\"))  {if (RC==8)  flagIF=YES;}\n    else if (!strcmp(word\u00dd1\u00a8.str,\"RC1=0\")) {if (RC1==0) flagIF=YES;}\n    else if (!strcmp(word\u00dd1\u00a8.str,\"RC1=4\")) {if (RC1==4) flagIF=YES;}\n    else if (!strcmp(word\u00dd1\u00a8.str,\"RC1=8\")) {if (RC1==8) flagIF=YES;}\n    else if (!strcmp(word\u00dd1\u00a8.str,\"RC2=0\")) {if (RC2==0) flagIF=YES;}\n    else if (!strcmp(word\u00dd1\u00a8.str,\"RC2=4\")) {if (RC2==4) flagIF=YES;}\n    else if (!strcmp(word\u00dd1\u00a8.str,\"RC2=8\")) {if (RC2==8) flagIF=YES;}\n    else if (!strcmp(word\u00dd1\u00a8.str,\"RC3=0\")) {if (RC3==0) flagIF=YES;}\n    else if (!strcmp(word\u00dd1\u00a8.str,\"RC3=4\")) {if (RC3==4) flagIF=YES;}\n    else if (!strcmp(word\u00dd1\u00a8.str,\"RC3=8\")) {if (RC3==8) flagIF=YES;}\n    else if (!strcmp(word\u00dd1\u00a8.str,\"RC4=0\")) {if (RC4==0) flagIF=YES;}\n    else if (!strcmp(word\u00dd1\u00a8.str,\"RC4=4\")) {if (RC4==4) flagIF=YES;}\n    else if (!strcmp(word\u00dd1\u00a8.str,\"RC4=8\")) {if (RC4==8) flagIF=YES;}\n    else if (!strncmp(word\u00dd1\u00a8.str,\"SQLCODE=\",8) && word\u00dd1\u00a8.len>8 )\n      {if (code==atoi(&word\u00dd1\u00a8.str\u00dd8\u00a8)) flagIF=YES;}\n    else { Xprintf(\" \\n*ERROR* Invalid IF syntax on '%s', \"\n           \"Valid: RC\u00ddn\u00a8=0|4|8 (n=1-4) or SQLCODE=code\\n\",word\u00dd1\u00a8.str);\n           Exit(8);}\n    if ( (strcmp(word\u00dd2\u00a8.str,\"DO\")==EQUALS)\n            &&  (word\u00dd3\u00a8.len==0)            )\n    {\n    // it is a IF ... DO;\n      if ( (plastIFDO)&&(plastIFDO->flag\u00dd0\u00a8=='N')) {\n       plastIFDO->cntIF++;\n       doneSTMNT=YES;\n       return(NULL);\n      }\n      p = (cache*) malloc(sizeof(struct cache));\n      if (p==NULL) Exit(999);\n      p->back = plastIFDO;\n      if (flagIF==YES) strcpy(p->flag,\"Y\");\n      else             strcpy(p->flag,\"N\");\n      plastIFDO=p;\n      plastIFDO->cntIF=0;\n      doneSTMNT=YES;\n      if (flagIF==NO)\n       Xprintf(\"*** False IF %s, statements bypassed till ENDIF\\n\",\n                              word\u00dd1\u00a8.str);\n      return(NULL);\n    } else\n    // it is a single IF\n     if ( (plastIFDO)&&(plastIFDO->flag\u00dd0\u00a8=='N') )\n          { doneSTMNT=YES; return(NULL); }\n     if (flagIF==YES) return(word\u00dd2\u00a8.ptr);\n     Xprintf(\"*** False IF %s, statement bypassed\\n\",word\u00dd1\u00a8.str);\n     doneSTMNT=YES;   return(NULL);\n\n}\n/*********************************************************************\\\n|\n|  processENDIF() -- end of IF-DO block\n|\n\\*********************************************************************/\nvoid processENDIF(void) {\n    if ( (plastIFDO)&&(plastIFDO->flag\u00dd0\u00a8=='N')\n        &&(plastIFDO->cntIF>0))\n     plastIFDO->cntIF--;\n     else getIFDO();\n    doneSTMNT=YES;\n}\n/*********************************************************************\\\n|\n|  processSKIP() -- go forward to a label\n|\n\\*********************************************************************/\nvoid processSKIP(void) {\n short rc=0;\n    rc=extractLABEL(word\u00dd1\u00a8.str,word\u00dd1\u00a8.len,skipLABEL);\n    if (rc!=0) {\n     Xprintf(\" \\n*ERROR* Invalid %s syntax\\n\",word\u00dd0\u00a8.str);\n     Exit(8);\n    }\n    doneSTMNT=YES;\n}\n/*********************************************************************\\\n|\n|  checkforLABEL() -- check and process a label\n|\n\\*********************************************************************/\nshort checkforLABEL(void) {\nint n;\nshort i;\nchar *p;\nshort rc=0;\n    if (BUF\u00dd0\u00a8==' ' || BUF\u00dd1\u00a8=='\\0') return(NO);\n    p=findword(BUF,1,n);\n    if (p==NULL) return(NO);\n    if (n==1) return(NO);\n    if (p\u00ddn-1\u00a8!=':') return(NO);\n    if (memchr(p,'\\'',n)!=NULL) return(NO);\n    if (skipLABEL\u00dd0\u00a8!='\\0') skipLABEL\u00dd0\u00a8='\\0';\n    for (i=0;i<numLABEL;i++) {\n     if ((arrayLABEL\u00ddi\u00a8.label\u00dd0\u00a8!='\\0') &&\n         (memcmp(arrayLABEL\u00ddi\u00a8.label,p,n)==EQUALS))\n      { foundstackLABEL=ON; indexLABEL=i; break; }\n    }\n    return(YES);\n}\n/*********************************************************************\\\n|\n|  extractLABEL() -- check and populate a label\n|\n\\*********************************************************************/\nshort extractLABEL(char* str,short len, char* label) {\n\n    if (str==NULL||len==0||len>20||label==NULL) return(1);\n    memset(label,'\\0',sizeof(skipLABEL));\n    if (memchr(str,'\\'',n)!=NULL) return(1);\n    strncpy(label,str,len);\n    if (label\u00ddlen-1\u00a8!=':')\n     label\u00ddlen\u00a8=':';\n    return(0);\n}\n/*********************************************************************\\\n|\n|  processEXIT()\n|\n\\*********************************************************************/\nvoid processEXIT(void)  {                                       // $fnc$\n         if (       word\u00dd1\u00a8.len==0 )          Exit(RC);\n    else if (strcmp(word\u00dd1\u00a8.str,\"0\")==EQUALS) Exit(RC=0);\n    else if (strcmp(word\u00dd1\u00a8.str,\"1\")==EQUALS) Exit(RC=1);\n    else if (strcmp(word\u00dd1\u00a8.str,\"2\")==EQUALS) Exit(RC=2);\n    else if (strcmp(word\u00dd1\u00a8.str,\"3\")==EQUALS) Exit(RC=3);\n    else if (strcmp(word\u00dd1\u00a8.str,\"4\")==EQUALS) Exit(RC=4);\n    else if (strcmp(word\u00dd1\u00a8.str,\"5\")==EQUALS) Exit(RC=5);\n    else if (strcmp(word\u00dd1\u00a8.str,\"6\")==EQUALS) Exit(RC=6);\n    else if (strcmp(word\u00dd1\u00a8.str,\"7\")==EQUALS) Exit(RC=7);\n    else if (strcmp(word\u00dd1\u00a8.str,\"8\")==EQUALS) Exit(RC=8);\n    else if (strcmp(word\u00dd1\u00a8.str,\"RC\")==EQUALS) Exit(RC);\n    else if (strcmp(word\u00dd1\u00a8.str,\"RC1\")==EQUALS) Exit(RC1);\n    else if (strcmp(word\u00dd1\u00a8.str,\"RC2\")==EQUALS) Exit(RC2);\n    else if (strcmp(word\u00dd1\u00a8.str,\"RC3\")==EQUALS) Exit(RC3);\n    else if (strcmp(word\u00dd1\u00a8.str,\"RC4\")==EQUALS) Exit(RC4);\n  else { Xprintf(\" \\n*ERROR* Invalid syntax, valid 0-8,RCn\\n\");Exit(8);}\n}\n/*********************************************************************\\\n|\n|  processPRINT()\n|\n\\*********************************************************************/\nvoid processPRINT(void) {\n    if (strcmp(word\u00dd1\u00a8.str,\"SQLERROR\")==EQUALS)\n    {SQLCODE=code;PrintSqlError(\"PRINT\");}\n    doneSTMNT=YES;\n}\n/*********************************************************************\\\n|\n|  processSYSTEM()\n|\n\\*********************************************************************/\nvoid processSYSTEM() {                                          // $fnc$\n\n  long rc=0;\n\n   // Start timings\n   cputime1 = CPUtime(0);\n   tottime1 = TOTALtime(0);\n   fflush(stdout);\n   rc=system(word\u00dd1\u00a8.ptr);\n   Xprintf(\"*** %s completed with RC = %d\",word\u00dd1\u00a8.str,rc);\n   if (rc>0) Xprintf(\", (SYSRC=%d)\",sysrc);\n   Xprintf(\"\\n\");\n   Xprintf(\"*** CPU time = %.4f seconds, TOTAL time = %d seconds\\n\",\n              CPUtime(cputime1),TOTALtime(tottime1));\n   if ((rc>sysrc)||(rc==-1)) Exit(12);\n   RC=rc;\n   doneSTMNT=YES;\n}\n#if defined(_AIX)\n/*********************************************************************\\\n|\n|  processDB2() -- Run a DB2 command (AIX)\n|\n\\*********************************************************************/\nvoid processDB2()    {                                          // $fnc$\n\n  long rc=0;\n\n   // Start timings\n   cputime1 = CPUtime(0);\n   tottime1 = TOTALtime(0);\n   fflush(stdout);\n   rc=system(word\u00dd0\u00a8.ptr);\n   Xprintf(\"*** %s completed with RC = %d\",word\u00dd1\u00a8.str,rc);\n   if (rc>0) Xprintf(\", (SYSRC=%d)\",sysrc);\n   Xprintf(\"\\n\");\n   Xprintf(\"*** CPU time = %.4f seconds, TOTAL time = %d seconds\\n\",\n              CPUtime(cputime1),TOTALtime(tottime1));\n   if ((rc>sysrc)||(rc==-1)) Exit(12);\n   RC=rc;\n   doneSTMNT=YES;\n}\n#endif\n#if defined(__MVS__)\n/*********************************************************************\\\n|\n|  processDB2() -- Run a DB2 command, not DSN (zOS)\n|\n\\*********************************************************************/\nvoid processDB2()    {                                          // $fnc$\n\n  long rc=0;\n short int i;\n char *p=NULL;\n\n   // Run a DB2 command\n   rc=callIFI(word\u00dd1\u00a8.ptr);\n   if (rc<=4) {\n    datalen=80;\n    if (action==actWRITE) openWRITE();\n    for (i=1;;i++) {                  // Retrieve and output the report\n     p=getIFIline(i,outBUF);\n     if (p==NULL) break;\n     if (p) outBUFrecord();\n    }\n   }\n   if (rc>0) {\n    Xprintf(\"*** %s completed with RC = %d\",word\u00dd1\u00a8.str,rc);\n    Xprintf(\", (SYSRC=%d)\\n\",sysrc);\n    if ((rc>sysrc)||(rc<0)) Exit(12);\n   }\n   if (action==actWRITE)\n   Xprintf(\"*** Successful WRITE of %d record(s),\"\n           \" RECFM=FB, LRECL=80\\n\",cntWRITE);\n   RC=rc;\n   doneSTMNT=YES;\n}\n#endif\n#if defined(__MVS__)\n/*********************************************************************\\\n|\n|  callIFI() -- run a DB2 command via IFI interface\n|               (based on SDSNSAMP(DSN8ED2))\n\\*********************************************************************/\nint  callIFI(char* cmd) {\n\n short int len,i;\n long int report_bytes;\n char  *p;\n\n   // Initialize the IFI parameters\n\n   if (pi==NULL) pi = (ifca *) malloc( sizeof(ifca) );\n   if (!pi) Exit(999);                 /* Point to IFCA structure    */\n\n   memset(pi,'\\0',sizeof(ifca));\n   pi->len = sizeof(ifca);             /* Note length of IFCA area   */\n   strcpy(pi->eye_catcher,\"IFCA\");     /* Initialize eye catcher     */\n   strcpy(pi->owner_id,\"LOC2\");        /* DB2 Loc: 1=Local, 2=Remote */\n\n   if (pr==NULL) pr = (return_area *) malloc( sizeof(return_area) );\n   if (!pr) Exit(999);                 /* Point to IFCA structure    */\n   memset(pr,' ',sizeof(return_area));\n                                       /* Point to IFI return area   */\n   pr->len = sizeof(return_area);      /* Length of return buffer    */\n\n   if (po==NULL) po = (command_area *) malloc( sizeof(command_area) );\n   if (!po) Exit(999);                 /* Point to IFI command area  */\n\n   memset(po,' ',sizeof(command_area));\n   po->len = strlen(cmd)+4;            /* Note length of command text*/\n   strncpy(po->command,cmd,            /* Copy in command            */\n    min(sizeof(command_area::command)-1,strlen(cmd)));\n\n   // Make the IFI call via the DSNWLI macro\n\n   dsnwli(\"COMMAND \",pi,pr,po );\n\n  if (pi->reason!=0) {\n    Xprintf(\" *** IFI rc=%d\\n\",pi->rc);\n    Xprintf(\" *** IFI reason=%x\\n\",pi->reason);\n    Xprintf(\" *** IFI gotten bytes=%d\\n\",pi->gotten_bytes);\n    Xprintf(\" *** IFI lost bytes=%d\\n\",pi->lost_bytes);\n    Xprintf(\" *** IFI bufsize=%d\\n\",RETURN_LEN);\n    for (i=1;;i++) {\n     p=getIFIline(i,outBUF);\n     if (p==NULL) break;\n     Xprintf(\" *** %s\\n\",outBUF);\n    }\n  }\n  return(pi->rc);\n}\n#endif\n#if defined(__MVS__)\n/*********************************************************************\\\n|\n|  getIFIline -- retrive i-th line from IFI buffer\n|\n\\*********************************************************************/\nchar* getIFIline(int i,char* out) {\n short int len=0,j,k=0;\n  long int report_bytes=pi->gotten_bytes;\n  char    *p=pr->report;\n\n   if (report_bytes<=0) return(NULL);\n\n   for (k=1;((report_bytes>0)&&(k<i));k++) {\n    p=p+len;\n    memcpy(&len,p,2);\n    report_bytes-=len;\n   }\n   if (k<i) return(NULL);\n   memset(out,' ',80);\n   memcpy(out,p+4,min(len,80));\n   for (j=0;j<80;j++)\n   { if ((*(out+j)=='\\n')||(*(out+j)=='\\t')) out\u00ddj\u00a8=' '; }\n   out\u00dd80\u00a8='\\0';\n   return(out);\n}\n#endif\n/*********************************************************************\\\n|\n|  processLOCK()\n|\n\\*********************************************************************/\nvoid  processLOCK() {                                           // $fnc$\n#if defined(__MVS__)\n  long rc=0;\n\n  if ((strcmp(word\u00dd1\u00a8.str,\"TABLE\")!=EQUALS)||\n      (strcmp(word\u00dd2\u00a8.str,\"\")==EQUALS)) return;\n   getDBTSnames(word\u00dd2\u00a8.str);\n   if (strlen(DBNAME)>0) {\n    sprintf(cmdDIS,cmdDIStmpl,DBNAME,TSNAME);\n    Xprintf(\"*** %s\\n\",cmdDIS);\n    rc=callIFI(cmdDIS);\n    displyTSstatus(0);\n    fLOCK=YES;\n   }\n#endif\n}\n/*********************************************************************\\\n|\n|  displyTSstatus() -- print out IFI buffer with TS lines\n|\n\\*********************************************************************/\nvoid displyTSstatus(int sqlcode) {\n#if defined(__MVS__)\n short int i;\n char *p=NULL;\n   // Retrieve and print out a TS report\n   for (i=1;;i++) {\n    p=getIFIline(i,outBUF);\n    if (p==NULL) break;\n    if (strncmp(outBUF+9,\"TS  \",4)!=EQUALS) continue;\n    if ((sqlcode==-911)&&\n        (strncmp(outBUF+60,\"H-IS,S\",6)==EQUALS) ) continue;\n    Xprintf(\"*** %s\\n\",outBUF);\n//  fflush(stdout);\n   }\n#endif\n}\n#if defined(__MVS__)\n/*********************************************************************\\\n|\n|  processRUNSTATS()\n|\n\\*********************************************************************/\nvoid  processRUNSTATS() {                                       // $fnc$\nchar cmd\u00dd250\u00a8;\n\n  strcpy(cmd,word\u00dd0\u00a8.str);\n  if (strcmp(word\u00dd1\u00a8.str,\"TABLE\")==EQUALS) {\n   getDBTSnames(word\u00dd2\u00a8.str);\n   sprintf(cmd,cmdRUNSTATStmpl,DBNAME,TSNAME,word\u00dd2\u00a8.str,word\u00dd3\u00a8.ptr);\n   Xprintf(\"*** %s\\n\",cmd);\n  } else {\n   strcpy(cmd,word\u00dd0\u00a8.ptr);\n  }\n  runStatsTableSpace(pgmname,\"\",cmd);\n//fflush(stdout);\n  doneSTMNT=YES;\n    rc=retCode;\n     if (rc>0) {\n      Xprintf(\"*** %s completed with RC = %d\",word\u00dd0\u00a8.str,rc);\n      Xprintf(\", (SYSRC=%d)\\n\",sysrc);\n      if ((rc>sysrc)||(rc<0)) Exit(12);\n     }\n}\n/*********************************************************************\\\n|\n|  runStatsTableSpace()\n|\n\\*********************************************************************/\nvoid runStatsTableSpace                // API for RUNSTATS TABLESPACE\n   ( char          *iuId,               // Utility ID\n     char          *irestart,           // Utility restart point\n     char          *iutStmt             // Utility control statement\n   )\n{    DsnUtilsClearParms();\n     strcpy(uId,iuId );\n     strcpy(restart,irestart );\n     strcpy(utility,\"RUNSTATS TABLESPACE\" );\n     strcpy(utStmt,iutStmt );\n\n     callDsnUtils();\n\n}\n/*********************************************************************\\\n|\n|  callDsnUtils()\n|\n\\*********************************************************************/\nvoid callDsnUtils() {\n\n       EXEC SQL\n       CALL SYSPROC.DSNUTILS( :uId,      :restart,   :utStmt,\n                              :retCode,  :utility,\n                              :recDsn,   :recDevt,   :recSpace,\n                              :discDsn,  :discDevt,  :discSpace,\n                              :pnchDsn,  :pnchDevt,  :pnchSpace,\n                              :copyDsn1, :copyDevt1, :copySpace1,\n                              :copyDsn2, :copyDevt2, :copySpace2,\n                              :rcpyDsn1, :rcpyDevt1, :rcpySpace1,\n                              :rcpyDsn2, :rcpyDevt2, :rcpySpace2,\n                              :workDsn1, :workDevt1, :workSpace1,\n                              :workDsn2, :workDevt2, :workSpace2,\n                              :mapDsn,   :mapDevt,   :mapSpace,\n                              :errDsn,   :errDevt,   :errSpace,\n                              :filtrDsn, :filtrDevt, :filtrSpace\n                            );\n\n       if( SQLCODE != 0  &&  SQLCODE != 466 )\n       {processSQLCODE(\"CALL SYSPROC.DSNUTILS\"); return;}\n\n       EXEC SQL\n         ASSOCIATE\n         LOCATOR( :DsnUtils_rs_loc )\n            WITH PROCEDURE SYSPROC.DSNUTILS;\n       if( SQLCODE != 0  )\n       {processSQLCODE(\"ASSOCIATE LOCATOR\"); return;}\n\n       EXEC SQL\n       ALLOCATE DSNUTILS_RS_CSR\n         CURSOR FOR RESULT SET :DsnUtils_rs_loc;\n       if( SQLCODE != 0  )\n       {processSQLCODE(\"ALLOCATE CURSOR\"); return;}\n\n       memset( text.data,'\\0',254 );\n\n       EXEC SQL\n       FETCH DSNUTILS_RS_CSR\n        INTO  :seqNo,\n              :text;\n\n       while( SQLCODE == 0 ) {\n        strcpy(outBUF,text.data);\n        outBUFrecord();\n        memset( text.data,'\\0',254 );\n\n         EXEC SQL\n           FETCH DSNUTILS_RS_CSR\n            INTO  :seqNo,\n                  :text;\n\n       }\n\n       if( SQLCODE != 0  &&  SQLCODE != 100 )\n       {processSQLCODE(\"FETCH DSNUTILS_RS_CSR\"); return;}\n\n}\n/*********************************************************************\\\n|\n|  DsnUtilsClearParms()\n|\n\\*********************************************************************/\nvoid DsnUtilsClearParms() {\n         memset( uId,      '\\0'    ,17 );\n         memset( restart,  '\\0'    ,9 );\n         memset( utStmt,   '\\0'    ,32705 );\n         retCode = 0;\n         memset( utility,  '\\0'    ,21 );\n\n         memset( recDsn,   '\\0'    ,45 );\n         memset( recDevt,  '\\0'    ,9 );\n         recSpace = 0;\n\n         memset( discDsn,  '\\0'    ,45 );\n         memset( discDevt, '\\0'    ,9 );\n         discSpace = 0;\n\n         memset( pnchDsn,  '\\0'    ,45 );\n         memset( pnchDevt, '\\0'    ,9 );\n         pnchSpace = 0;\n\n         memset( copyDsn1, '\\0'    ,45 );\n         memset( copyDevt1,'\\0'    ,9 );\n         copySpace1 = 0;\n\n         memset( copyDsn2, '\\0'    ,45 );\n         memset( copyDevt2,'\\0'    ,9 );\n         copySpace2 = 0;\n\n         memset( rcpyDsn1, '\\0'    ,45 );\n         memset( rcpyDevt1,'\\0'    ,9 );\n         rcpySpace1 = 0;\n\n         memset( rcpyDsn2, '\\0'    ,45 );\n         memset( rcpyDevt2,'\\0'    ,9 );\n         rcpySpace2 = 0;\n\n         memset( workDsn1, '\\0'    ,45 );\n         memset( workDevt1,'\\0'    ,9 );\n         workSpace1 = 0;\n\n         memset( workDsn2, '\\0'    ,45 );\n         memset( workDevt2,'\\0'    ,9 );\n         workSpace2 = 0;\n\n         memset( mapDsn,   '\\0'    ,45 );\n         memset( mapDevt,  '\\0'    ,9 );\n         mapSpace = 0;\n\n         memset( errDsn,   '\\0'    ,45 );\n         memset( errDevt,  '\\0'    ,9 );\n         errSpace = 0;\n\n         memset( filtrDsn, '\\0'    ,45 );\n         memset( filtrDevt,'\\0'    ,9 );\n         filtrSpace = 0;\n}\n/*********************************************************************\\\n|\n| getDBTSnames() -- get DBNAME and TSNAME for a given table\n|\n\\*********************************************************************/\nvoid getDBTSnames(char* table) {\nchar *p;\n  memset(DBNAME, '\\0',sizeof(DBNAME));\n  memset(TSNAME, '\\0',sizeof(TSNAME));\n  memset(NAME,   '\\0',sizeof(NAME));\n  memset(CREATOR,'\\0',sizeof(CREATOR));\n  p=strchr(table,'.');\n  if (p==NULL) return;\n  strncpy(CREATOR,table,min(p-table,sizeof(CREATOR)-1));\n  strncpy(NAME,p+1,min(strlen(p+1),sizeof(NAME)-1));\n  if (trace) Xprintf(\"*** CREATOR='%s', NAME='%s'\\n\",CREATOR,NAME);\n        EXEC SQL\n        SELECT DBNAME,TSNAME INTO :DBNAME,:TSNAME\n          FROM SYSIBM.SYSTABLES\n         WHERE CREATOR=:CREATOR AND NAME=:NAME;\n//  if( SQLCODE != 0  )\n//  {processSQLCODE(\"SELECT DBNAME,TSNAME FROM SYSTABLES\"); return;}\n    strip(DBNAME,'T');\n    strip(TSNAME,'T');\n}\n#endif\n/*********************************************************************\\\n|\n| PREPROCESS_SQL_STMNT() -- recognize and process functional commands\n|\n\\*********************************************************************/\nvoid PREPROCESS_SQL_STMNT(void)                                 // $fnc$\n{\n char *p;\n\n     if (SQL.Len==0) { doneSTMNT=YES; return; }\n do {\n     p=NULL;\n     nwords=words(SQL.Str);\n     getwords(SQL.Str,7,'U');\n     strcpy(word1,word\u00dd0\u00a8.str);\n          if ( strcmp(word1,\"IF\"     ) == EQUALS) p=processIF();\n     else if ( strcmp(word1,\"ENDIF\"  ) == EQUALS)   processENDIF();\n     else {\n      if ((plastIFDO)&&(plastIFDO->flag\u00dd0\u00a8=='N'))  doneSTMNT=YES;\n      else if ( strcmp(word1,\"EXEC\"    ) == EQUALS) p=processEXEC();\n      else if ( strcmp(word1,\"CONNECT\" ) == EQUALS)   processCONNECT();\n      else if ( strcmp(word1,\"SET\"     ) == EQUALS) p=processSET();\n      else if ( strcmp(word1,\"RELEASE\" ) == EQUALS) p=processRELEASE();\n      else if ( strcmp(word1,\"EXPLAIN\" ) == EQUALS) p=processEXPLAIN();\n      else if ( strcmp(word1,\"WRITE\"   ) == EQUALS) p=processWRITE();\n      else if ( strcmp(word1,\"READ\"    ) == EQUALS) p=processREAD();\n      else if ( strcmp(word1,\"SAVE\"    ) == EQUALS) p=processSAVE();\n      else if ( strcmp(word1,\"DDL\"     ) == EQUALS)   processDDL();\n      else if ( strcmp(word1,\"INCLUDE\" ) == EQUALS)   processINCLUDE();\n      else if ( strcmp(word1,\"STACK\"   ) == EQUALS) p=processSTACK();\n      else if (strncmp(word1,\"RC\"    ,2) == EQUALS)   processRC();\n      else if ( strcmp(word1,\"EXIT\"    ) == EQUALS)   processEXIT();\n      else if ( strcmp(word1,\"END\"     ) == EQUALS)   processEND();\n      else if ( strcmp(word1,\"SYSTEM\"  ) == EQUALS)   processSYSTEM();\n      else if ( strcmp(word1,\"SYS\"     ) == EQUALS)   processSYSTEM();\n#if defined(__MVS__) || defined(_AIX)\n      else if ( strcmp(word1,\"DB2\"     ) == EQUALS)   processDB2();\n#endif\n      else if ( strcmp(word1,\"SAY\"     ) == EQUALS)   processSAY();\n      else if ( strcmp(word1,\"ECHO\"    ) == EQUALS)   processECHO();\n#if defined(__MVS__)\n      else if ( strcmp(word1,\"RUNSTATS\") == EQUALS)   processRUNSTATS();\n      else if ( strcmp(word1,\"LOCK\"    ) == EQUALS)   processLOCK();\n#endif\n      else if ( strcmp(word1,\"WHENEVER\") == EQUALS)   processWHENEVER();\n      else if ( strcmp(word1,\"SKIP\"    ) == EQUALS)   processSKIP();\n      else if ( strcmp(word1,\"GOTO\"    ) == EQUALS)   processSKIP();\n      else if ( strcmp(word1,\"PRINT\"   ) == EQUALS)   processPRINT();\n      else if ( strcmp(word1,\"DRAW\"    ) == EQUALS)   processDRAW();\n     }\n     if (doneSTMNT) { SQL.Len=0; break; }\n     if (p!=NULL)   { strcpy(SQL.Str,p); SQL.Len=strlen(SQL.Str); }\n\n  } while((p!=NULL)&&(SQL.Len>0));\n\n  if (SQL.Len==0)  doneSTMNT=YES;\n  return;\n}\n/*********************************************************************\\\n|\n|  parseColumnLength() -- create COLDATA array\n|\n\\*********************************************************************/\nvoid parseColumnLength(void) {                                  // $fnc$\n\n struct COLDATA *p;\n int i,m;\n\n    if (SQLd==0) return;\n\n    pCOLDATA= (struct COLDATA*) malloc(sizeof(struct COLDATA)*SQLd);\n    if (pCOLDATA==NULL) Exit(999);\n\n    memset(pCOLDATA,'\\0',sizeof(struct COLDATA)*SQLd);\n\n    for(i=0;i<SQLd;i++) {\n\n      p=&pCOLDATA\u00ddi\u00a8;\n      p->type=SQLTYPE(i);\n      p->len=SQLLEN(i);\n\n      if (i>0) datalen=datalen+strlen(dlm);\n\n      switch (SQLTYPE(i)) {\n        case sVCHAR:     case sVCHARn:\n        case sLVCHAR:    case sLVCHARn:\n           if (fASIS) p->clen=SQLLEN(i)+2+1;\n           else p->clen=SQLLEN(i);\n           p->width=p->clen+fCSV*2;\n           p->align='L';\n           break;\n        case sCHAR:      case sCHARn:\n           if (fASIS) p->clen=SQLLEN(i)+1;\n           else p->clen=SQLLEN(i);\n           p->width=p->clen+fCSV*2;\n           p->align='L';\n           break;\n        case sVARBIN:    case sVARBINn:\n           if (fASIS) p->clen=SQLLEN(i)+2+1;\n           else p->clen=SQLLEN(i)*2;\n           p->width=p->clen+fCSV*2;\n           p->align='L';\n           break;\n        case sBIN:      case sBINn:\n           if (fASIS) p->clen=SQLLEN(i)+1;\n           else p->clen=SQLLEN(i)*2;\n           p->width=p->clen+fCSV*2;\n           p->align='L';\n           break;\n        case sDATE:      case sDATEn:\n        case sTIME:      case sTIMEn:\n        case sTIMESTAMP: case sTIMESTAMPn:\n           if (fASIS) p->clen=SQLLEN(i)+1;\n           else p->clen=SQLLEN(i);\n           p->width=p->clen;\n           p->align='C';\n           break;\n        case sFLOAT:     case sFLOATn:\n           if (fASIS) p->clen=SQLLEN(i)+1;\n           else p->clen=SQLLEN(i)*2+4;\n           p->width=p->clen;\n           p->align='C';\n           break;\n        case sBIGINT:    case sBIGINTn:\n           if (fASIS) p->clen=SQLLEN(i)+1;\n           else p->clen=19+signposFlag;\n           p->width=p->clen;\n           p->align='C';\n           break;\n        case sINT:       case sINTn:\n           if (fASIS) p->clen=SQLLEN(i)+1;\n           else p->clen=10+signposFlag;\n           p->width=p->clen;\n           p->align='C';\n           break;\n        case sSMINT:     case sSMINTn:\n           if (fASIS) p->clen=SQLLEN(i)+1;\n           else p->clen=5+signposFlag;\n           p->width=p->clen;\n           p->align='C';\n           break;\n        case sDEC:       case sDECn:\n           parseDecSQLLEN(i);\n           if (fASIS) p->clen=memory+1;\n           else p->clen=prec+signposFlag+(scale>0);\n           p->width=p->clen;\n           p->align='C';\n           break;\n        case sDECFLOAT:  case sDECFLOATn:\n           if (fASIS) p->clen=SQLLEN(i)+1;\n           else if (SQLLEN(i)==8) p->clen=16+signposFlag+1; // ????\n           else p->clen=34+signposFlag+1;                   // ????\n           p->width=p->clen;\n           p->align='C';\n           break;\n        default:\n           Xprintf(\"\\n \\n*ERROR* Unsupported SQLTYPE=%d\\n\",SQLTYPE(i));\n           Exit(8);\n      } // switch\n      datalen=datalen+p->width;\n    }  // for\n}\n/*********************************************************************\\\n|\n|  parseColumnNames() -- create COLNAME array\n|\n\\*********************************************************************/\nvoid parseColumnNames(void)  {                                  // $fnc$\n char *s,*e;\n struct COLNAME *p;\n int i,j;\n\n    if (SQLd==0) return;\n\n    colines=0;\n    pCOLNAME= (struct COLNAME*) malloc(sizeof(struct COLNAME)*SQLd);\n    if (pCOLNAME==NULL) Exit(999);\n    memset(pCOLNAME,'\\0',sizeof(struct COLNAME)*SQLd);\n\n    for(i=0;i<SQLd;i++) {\n      p=&pCOLNAME\u00ddi\u00a8;\n      strncpy(p->sqlname,SQLNAMED(i),30);\n      s=strip(p->sqlname,'T');\n      p->partmaxlen=0;\n\n      for (j=0;j<15;j++) {\n       p->partptr\u00ddj\u00a8=s;\n       e=strchr(s,'_');\n       if (e==NULL) break;\n       p->partlen\u00ddj\u00a8=e-s;\n       p->partmaxlen=Max(p->partmaxlen,p->partlen\u00ddj\u00a8);\n       s=e+1;\n      }\n\n      e=strchr(s,'\\0');\n      p->partlen\u00ddj\u00a8=e-s;\n      p->partmaxlen=Max(p->partmaxlen,p->partlen\u00ddj\u00a8);\n      p->parts=j+1;\n      colines=Max(colines,p->parts);\n    }\n}\n/*********************************************************************\\\n|\n|  openWRITE() -- open an output WRITE file\n|\n\\*********************************************************************/\nvoid openWRITE(void) {                                          // $fnc$\n char mode\u00dd81\u00a8;\n\n    lreclWRITE=datalen;\n    if (fDATA||fLABEL) return;\n\n#if defined(_WIN32) || defined(_AIX)\n// Windows or AIX\n    if (fAPPEND) {\n     if (fASIS) strcpy(mode,\"ab\");\n     else       strcpy(mode,\"a\");\n    } else {\n     if (fASIS) strcpy(mode,\"wb\");\n     else       strcpy(mode,\"w\");\n    }\n#else\n// zOS\n    if (fAPPEND) {\n     if (fASIS) strcpy(mode,\"ab\");\n     else       sprintf(mode,modeMVSa,lreclWRITE);\n    } else {\n     if (fASIS) sprintf(mode,modeMVSwb,lreclWRITE);\n     else       sprintf(mode,modeMVSw,lreclWRITE);\n    }\n#endif\n    fpWRITE=fopen(fnWRITE,mode);\n    if (fpWRITE==NULL) {\n      Xprintf(\" \\n*ERROR* Open WRITE FILE %s with \\\"%s\\\" failed:\\n\"\n             \"%s\\n\", fnWRITE, mode, strerror(errno));\n      Exit(8);\n    }\n}\n/*********************************************************************\\\n|\n|  openDISCARD() -- open an output DISCARD file\n|\n\\*********************************************************************/\nvoid openDISCARD(void) {                                        // $fnc$\n char mode\u00dd81\u00a8;\n\n#if defined(_WIN32) || defined(_AIX)\n    if (fASIS) strcpy(mode,\"wb\");\n    else       strcpy(mode,\"w\");\n#else\n    if (fASIS) sprintf(mode,modeMVSwb,lreclREAD);\n    else       sprintf(mode,modeMVSw,lreclREAD);\n#endif\n    fpDISCARD=fopen(fnDISCARD,mode);\n    if (fpDISCARD==NULL) {\n      Xprintf(\" \\n*ERROR* Open DISCARD file %s with \\\"%s\\\" failed:\\n\"\n             \"%s\\n\", fnDISCARD, mode, strerror(errno));\n      Exit(8);\n    }\n}\n/*********************************************************************\\\n|\n|  writeRecord() -- write out WRITE or DISCARD file record\n|\n\\*********************************************************************/\nlong writeRecord(FILE *fp, char *fn, char *buf,// $fnc$\n                 long *cnt,long lrecl) {                        // $fnc$\n long n;\n    if (fASIS) n=fwrite(buf,1,lrecl,fp);\n    else       n=fprintf(fp,\"%s\\n\",buf);\n    (*cnt)++;\n    if (n<=0) {\n      Xprintf(\" \\n*ERROR* Write file %s failed on record #%d:\\n\"\n             \"%s\\n\", fn, *cnt, strerror(errno));\n      Xprintf(\"lrecl=%d, datalen=%d, lreclWRITE=%d, strlen(buf)=%d\\n\"\n              \"buf='%s'\\n\",\n             lrecl,datalen,lreclWRITE,strlen(buf),buf);\n      Exit(8);\n    }\n return(n);\n}\n/*********************************************************************\\\n|\n|  outBUFrecord() -- print/write/stack the outBUF\n|\n\\*********************************************************************/\nvoid outBUFrecord(void)  {                                      // $fnc$\n long n=0;\n struct stack *p;\n short i=indexLABEL;\n\n   // SELECT\n   if ((action==actSQL)||((action==actREAD)&&(fECHO==YES))) {\n    Xprintf(\"%s\\n\",outBUF);\n    return;\n   }\n   // WRITE\n   if ((action==actWRITE)&&(fDATA==NO)&&(fLABEL==NO)) {\n    n=writeRecord(fpWRITE,fnWRITE,outBUF,&cntWRITE,lreclWRITE);\n    return;\n   }\n   // STACK\n   if ((action==actSTACK)||(fDATA==YES)||(fLABEL==YES)) {\n     if (fASIS) {\n      p = (stack*) malloc(sizeof(struct stack)+datalen);\n      if (p==NULL) Exit(999);\n      p->len  = datalen;\n      memcpy(p->data,outBUF,datalen);\n     } else {\n      p = (stack*) malloc(sizeof(struct stack)+strlen(outBUF));\n      if (p==NULL) Exit(999);\n      p->len  = strlen(outBUF);\n      strcpy(p->data,outBUF);\n     }\n     p->next = NULL;\n          if (fLIFO)  { plastLIFO->next=p;  plastLIFO=p;  eofLIFO=NO; }\n     else if (fFIFO)  { plastFIFO->next=p;  plastFIFO=p;  eofFIFO=NO; }\n     else if (fDATA)  { plastDATA->next=p;  plastDATA=p;  eofDATA=NO;\n                        cntWRITE++;}\n     else if (fLABEL) { arrayLABEL\u00ddi\u00a8.plast->next=p;\n                        arrayLABEL\u00ddi\u00a8.plast=p;\n                        eofLABEL=NO;\n                        cntWRITE++;}\n   }\n}\n/*********************************************************************\\\n|\n|  printDashes() -- print out a line with column dashes\n|\n\\*********************************************************************/\nvoid printDashes(char *po,struct COLNAME *pn) {                 // $fnc$\n\n    if (pCOLNAME==NULL) return;\n    po\u00dd0\u00a8='+'; po=po+1;\n    for(i=0;i<SQLd;i++) {\n      pn=&pCOLNAME\u00ddi\u00a8;\n      memset(po,'-',pn->width);\n      po=po+pn->width;\n      po\u00dd0\u00a8='+'; po=po+1;\n    }\n    po\u00dd0\u00a8='\\0';\n    outBUFrecord();\n}\n/*********************************************************************\\\n|\n|  printColumnNames() -- print out column names (report header)\n|\n\\*********************************************************************/\nvoid printColumnNames(void)  {                                  // $fnc$\n struct COLNAME *pn;\n struct COLDATA *pd;\n char *po,*pj,*pw;\n int i,j,l;\n\n    if (pCOLNAME==NULL) return;\n\n    // set up widths of columns\n    datalen=0;\n    for(i=0;i<SQLd;i++) {\n      pn=&pCOLNAME\u00ddi\u00a8;\n      pd=&pCOLDATA\u00ddi\u00a8;\n      pn->width=Max(pn->partmaxlen,pd->width);\n      pd->width=pn->width;\n      if (pn->partmaxlen>pd->clen)\n      pd->align='C';\n      datalen=datalen+pn->width+strlen(dlm);\n    }\n    datalen++;\n    if ((action==actWRITE)&&(fpWRITE==NULL)) openWRITE();\n    // print out dashes\n    printDashes(po=outBUF,pn);\n\n    // print out column names\n    for(l=0;l<colines;l++) {\n      po=outBUF; po\u00dd0\u00a8='|';po++;\n\n      // loop for each column\n      for(i=0;i<SQLd;i++) {\n        pn=&pCOLNAME\u00ddi\u00a8;\n        pd=&pCOLDATA\u00ddi\u00a8;\n        memset(po,' ',pn->width);\n\n        if ((colines-(pn->parts))<=l) {\n          j=l-(colines-pn->parts);\n          pj=pn->partptr\u00ddj\u00a8;\n          switch (pd->align) {\n            case 'L':\n             if (pn->partmaxlen<pn->width)\n             pw=po+1; else pw=po;\n             break;\n            case 'R':\n             pw=po+(pn->width)-(pn->partmaxlen);\n             if (pn->partmaxlen<pn->width)\n             pw=pw-1;\n             break;\n            case 'C':\n             pw=po+((pn->width)-(pn->partmaxlen))/2;\n             break;\n            default: Exit(666);\n          }\n          strncpy(pw,pj,pn->partlen\u00ddj\u00a8);\n        }\n        po=po+pn->width;\n        po\u00dd0\u00a8='|'; po++;\n      }\n      po\u00dd0\u00a8='\\0';\n      outBUFrecord();\n    }\n    // print out dashes\n    printDashes(po=outBUF,pn);\n}\n/*********************************************************************\\\n|\n|  checkint() -- check a string with a whole number\n|\n\\*********************************************************************/\nint checkint(char* p, short len, short maxn) {                  // $fnc$\n short n=0;\n char sign=' ';\n   for (short i=0;i<len;i++) {\n    switch (p\u00ddi\u00a8) {\n      case ' ': if ((n==0)&&(sign==' ')) continue;\n                else return(1);\n      case '+': if ((n==0)&&(sign==' ')) {sign='+'; continue;}\n                else return(2);\n      case '-': if ((n==0)&&(sign==' ')) {sign='-'; continue;}\n                else return(3);\n      default:\n        if ((p\u00ddi\u00a8=='0')&&(n==0)) {sign='x'; continue;}\n        if ((p\u00ddi\u00a8<'0')||(p\u00ddi\u00a8>'9')) return(5);\n        if (++n>maxn)               return(6);\n    }\n   }\n   return(0);\n}\n/*********************************************************************\\\n|\n|  checkdatetime() -- check a string with date/time/timestamp\n|\n\\*********************************************************************/\nint checkdatetime(char* p, short len) {                         // $fnc$\n\n   for (short i=0;i<len;i++) {\n    switch (p\u00ddi\u00a8) {\n      case '.':  continue;\n      case '-':  continue;\n      case '/':  continue;\n      case ':':  continue;\n      default:\n        if ((p\u00ddi\u00a8<'0')||(p\u00ddi\u00a8>'9')) return(5);\n    }\n   }\n   return(0);\n}\n/*********************************************************************\\\n|\n|  checkfloat() -- check a string with a float number\n|\n\\*********************************************************************/\nint checkfloat(char* p) {                                       // $fnc$\n short n=0,e=0,d=0;\n char sign=' ';\n   for (short i=0;i<strlen(p);i++) {\n    switch (p\u00ddi\u00a8) {\n      case ' ': if ((n==0)&&(sign==' '))\n                { continue;}                 else return(1);\n      case '+': if ((sign==' ')&&((n==0)||(e==1)))\n                {sign='x'; continue;}        else return(2);\n      case '-': if ((sign==' ')&&((n==0)||(e==1)))\n                {sign='x'; continue;}        else return(3);\n      case '.': if (d==0)\n                {d++ ; continue;}            else return(4);\n      case 'e':\n      case 'E': if (e==0)\n                {sign=' ';++e;++n;continue;} else return(5);\n      default:\n                if (n==0) {sign='x';}\n                if ((p\u00ddi\u00a8<'0')||(p\u00ddi\u00a8>'9'))       return(6);\n                n++;\n    }\n   }\n   if (n==0) return(7);\n   return(0);\n}\n/*********************************************************************\\\n|\n|  char2dec() -- convert char decimal to binary packed decimal\n|\n\\*********************************************************************/\nint  char2dec(char* sqldata,char* inbuf,short inlen)            // $fnc$\n{\n unsigned char sign='\\0';\n short whole=prec-scale;\n short memlen=memory;                            // size of memory\n short i;\n unsigned char *p=(unsigned char*)inbuf;\n unsigned char packdec\u00dd17\u00a8;\n short iprec=0,iscale=-1;\n\n    memset(packdec,'\\0',sizeof(packdec));        // for packed digits\n    memset(sqldata,'\\0',memlen);                 // output buffer\n\n    for (i=0;i<inlen;i++) {\n      switch (p\u00ddi\u00a8) {\n       case ' ': if (iprec==0)   continue;          else return(1);\n       case '+': if (sign=='\\0') {sign=0x0C;break;} else return(2);\n       case '-': if (sign=='\\0') {sign=0x0D;break;} else return(3);\n       case '.': if (iscale==-1) {iscale=0; break;} else return(4);\n       default:\n        if ((p\u00ddi\u00a8<'0')||(p\u00ddi\u00a8>'9'))                      return(5);\n        if ((p\u00ddi\u00a8=='0')&&(iprec==0)) continue;\n        if ((++iprec>whole)&&(iscale==-1))               return(6);\n        if ((iscale>-1)&&(++iscale>scale)) continue;\n        shift4bits(packdec,16);\n        packdec\u00dd15\u00a8=(packdec\u00dd15\u00a8)|(p\u00ddi\u00a8&0x0F);\n      } // switch\n    } // for\n    if (iscale==-1) iscale=0;\n    for (i=iscale;(i<scale)&&(++iprec<prec);i++) {\n      shift4bits(packdec,16);\n    }\n    if (sign=='\\0') sign=0x0c;\n    shift4bits(packdec,16);\n    packdec\u00dd15\u00a8=packdec\u00dd15\u00a8|sign;\n    memcpy(sqldata,packdec+16-memlen,memlen);\n    return(0);\n}\n/*********************************************************************\\\n|\n|  shift4bits() -- shift a string to left on 4 bits\n|\n\\*********************************************************************/\nvoid  shift4bits(unsigned char *p,short len) {           // $fnc$\n for (int i=0;i<len;i++) {\n     p\u00ddi\u00a8=(p\u00ddi\u00a8<<4)|((p\u00ddi+1\u00a8)>>4);\n }\n}\n/*********************************************************************\\\n|\n|  dec2char() -- convert packed decimal to char formated number\n|\n\\*********************************************************************/\nvoid dec2char(char* sqldata,char* outbuf,short outlen)          // $fnc$\n{\n  unsigned char byte,sign;\n short i,j,k=0,jp;\n\n    j=outlen-1;                                  // blank out\n    memset(outbuf,' ',j);                        // the output buffer\n    outbuf\u00ddj\u00a8='\\0';                              // add end of line\n    j--;                                         // position for char\n    jp=j;                                        // default for leading\n                                                 // zeroes\n    for (i=memory-1;i>=0;i--) {                  // unpack dec digits\n      byte = sqldata\u00ddi\u00a8;                         // from last to first\n      if (k==0) sign=((byte<<4)>>4)|0xF0;        // remember a sign\n      else {                                     // add a decimal point\n       if ((scale>0)&&(k==scale)) {outbuf\u00ddj--\u00a8='.'; jp=j;}\n       outbuf\u00ddj--\u00a8=byte & 0x0F | '0';            // unpack a low digit\n       k++;\n      }                                          // add a decimal point\n      if ((scale>0)&&(k==scale)) {outbuf\u00ddj--\u00a8='.'; jp=j;}\n      outbuf\u00ddj--\u00a8=(byte>>4)|'0';                 // unpack a high digit\n      k++;\n    }\n    // replace leading zeroes with blanks\n    for (i=j+1;i<jp;i++) {                       // start from last\n     if (outbuf\u00ddi\u00a8!='0') break;                  // first non-0 found\n     else {outbuf\u00ddi\u00a8=' '; j++;}                  // j is a pos for sign\n    }\n\n    if (sign==0xFd) outbuf\u00ddj\u00a8='-';               // add a minus sign\n}\n/*********************************************************************\\\n|\n|  printC1rows()-- build output records from the fetched rows\n|\n\\*********************************************************************/\nvoid printC1rows(short n) {                                     // $fnc$\n short i,k;\n  char *p1;\n  char *po,*pw;\n short *p2;\n  char cbuf\u00dd34\u00a8;\nstruct COLDATA *pd;\n short m,z;\n\n   // process all fetched multi rows\n   for(k=0;k<n;k++) {\n    po=outBUF;\n    if ( (action==actSQL)||((action==actWRITE)&&(fRPT==YES)) )\n     { po\u00dd0\u00a8='|';po++;}\n\n    // process each column\n    for(i=0;i<SQLd;i++) {\n     p1=SQLDATA(i)+SQLLEN(i)*k;\n     p2=SQLIND(i)+k;\n     pd=&pCOLDATA\u00ddi\u00a8;\n     memset(po,' ',pd->width);\n     pw=po;\n\n     // process NULL value\n     if ((!fASIS)&(*p2<0)) {\n        pw=po+(pd->width)/2;\n       *pw=nullchar;\n     } else\n     // process not NULL value  or ASIS\n     switch (SQLTYPE(i)) {\n\n      case sCHAR:      case sCHARn:\n           if (fASIS) { memcpy(po,(char*)p2+1,1);\n                        memcpy(po+1,p1,SQLLEN(i)); break;}\n           for (z=0;z<pd->clen;z++) if (isprint(p1\u00ddz\u00a8)==0) p1\u00ddz\u00a8=' ';\n           if (fCSV) {\n             po\u00dd0\u00a8='\"'; pw=po+1;\n             for (z=0;z<pd->clen;z++) {\n              if (p1\u00ddz\u00a8=='\"') p1\u00ddz\u00a8='\\'';   // replace double to single\n             }\n             strncpy(pw,p1,pd->clen);\n             pw=pw+pd->clen; pw\u00dd0\u00a8='\"';\n           } else {\n           if (pd->align=='C')\n              pw=po+((pd->width)-(pd->len))/2;\n             strncpy(pw,p1,pd->clen);\n           }\n           break;\n      case sBIN:       case sBINn:\n           if (fASIS) { memcpy(po,(char*)p2+1,1);\n                        memcpy(po+1,p1,SQLLEN(i)); break;}\n           if (fCSV) {\n             po\u00dd0\u00a8='\"'; pw=po+1;\n             strUXcpy(pw,p1,SQLLEN(i));\n             pw=pw+pd->clen; pw\u00dd0\u00a8='\"';\n           } else {\n           if (pd->align=='C')\n              pw=po+((pd->width)-(pd->len))/2;\n             strUXcpy(pw,p1,SQLLEN(i));\n           }\n           break;\n\n      case sDATE:      case sDATEn:\n      case sTIME:      case sTIMEn:\n      case sTIMESTAMP: case sTIMESTAMPn:\n           if (fASIS) { memcpy(po,(char*)p2+1,1);\n                        memcpy(po+1,p1,SQLLEN(i)); break;}\n           if (pd->align=='C')\n             pw=po+((pd->width)-(pd->len))/2;\n           strncpy(pw,p1,pd->clen);\n           break;\n\n      case sLVCHAR:    case sLVCHARn:\n      case sVCHAR:     case sVCHARn:\n           if (multiRows>1) m=SQLLEN(i)%2; else m=0;\n           p1=SQLDATA(i)+(SQLLEN(i)+sizeof(short)+m)*k;\n           if (fASIS) { memcpy(po,(char*)p2+1,1);\n                        memcpy(po+1,p1,SQLLEN(i)+2); break;}\n           for (z=0;z<*(short*)p1;z++)\n            if (isprint(p1\u00ddz+2\u00a8==0)) p1\u00ddz+2\u00a8=' ';\n           if (fCSV) {\n            po\u00dd0\u00a8='\"'; pw=po+1;\n            for (z=0;z<*(short*)p1;z++) {\n             if (p1\u00ddz+2\u00a8=='\"') p1\u00ddz+2\u00a8='\\''; // replace double to single\n            }\n            strncpy(pw,p1+2,*(short*)p1);\n            pw=pw+*(short*)p1; pw\u00dd0\u00a8='\"';\n           } else {\n            strncpy(po,p1+2,*(short*)p1);\n           }\n           break;\n\n      case sVARBIN:     case sVARBINn:\n           if (multiRows>1) m=SQLLEN(i)%2; else m=0;\n           p1=SQLDATA(i)+(SQLLEN(i)+sizeof(short)+m)*k;\n           if (fASIS) { memcpy(po,(char*)p2+1,1);\n                        memcpy(po+1,p1,SQLLEN(i)+2); break;}\n           if (fCSV) {po\u00dd0\u00a8='\"'; pw=po+1;}\n           strUXcpy(pw,p1+2,*(short*)p1);\n           if (fCSV) {pw=pw+*(short*)p1*2; pw\u00dd0\u00a8='\"';}\n           break;\n\n      case sFLOAT:     case sFLOATn:\n           if (fASIS) { memcpy(po,(char*)p2+1,1);\n                        memcpy(po+1,p1,SQLLEN(i)); break;}\n           if (SQLLEN(i)==4)\n           sprintf(cbuf,\"%8.5e\\0\",*(float*)p1);\n           else\n           sprintf(cbuf,\"%16.13e\\0\",*(double*)p1);\n           pw=po+(pd->width)-strlen(cbuf);\n           strncpy(pw,cbuf,strlen(cbuf));\n           break;\n\n      case sBIGINT:    case sBIGINTn:\n           if (fASIS) { memcpy(po,(char*)p2+1,1);\n                        memcpy(po+1,p1,SQLLEN(i)); break;}\n           sprintf(cbuf,\"%20lld\\0\",*(long long int*)p1);\n           pw=po+((pd->width)-(pd->clen))/2;\n           strncpy(pw,cbuf+strlen(cbuf)-(pd->clen),pd->clen);\n           break;\n\n      case sINT:       case sINTn:\n           if (fASIS) { memcpy(po,(char*)p2+1,1);\n                        memcpy(po+1,p1,SQLLEN(i)); break;}\n           sprintf(cbuf,\"%11d\\0\",*(int*)p1);\n           pw=po+((pd->width)-(pd->clen))/2;\n           strncpy(pw,cbuf+strlen(cbuf)-(pd->clen),pd->clen);\n           break;\n\n      case sSMINT:     case sSMINTn:\n           if (fASIS) { memcpy(po,(char*)p2+1,1);\n                        memcpy(po+1,p1,SQLLEN(i)); break;}\n           sprintf(cbuf,\"%6d\\0\",*(short*)p1);\n           pw=po+((pd->width)-(pd->clen))/2;\n           strncpy(pw,cbuf+strlen(cbuf)-(pd->clen),pd->clen);\n           break;\n\n      case sDEC:       case sDECn:\n           parseDecSQLLEN(i);\n           p1=SQLDATA(i)+memory*k;\n           if (fASIS) { memcpy(po,(char*)p2+1,1);\n                        memcpy(po+1,p1,memory); break;}\n           dec2char(p1,cbuf,sizeof(cbuf));\n           pw=po+((pd->width)-(pd->clen))/2;\n           strncpy(pw,cbuf+sizeof(cbuf)-1-pd->clen,pd->clen);\n           break;\n\n      case sDECFLOAT:  case sDECFLOATn:                     // ??????\n           if (fASIS) { memcpy(po,(char*)p2+1,1);\n                        memcpy(po+1,p1,SQLLEN(i)); break;}\n           Xprintf(\"\\n \\n*RESTRICTION* Use CHAR function to convert\"\n                  \" DECFLOAT datatype to character string\\n\");\n                  Exit(8);\n      default:\n      Xprintf(\" \\n*ERROR* Unsupported SQLTYPE=%d\\n\",SQLTYPE(i));\n      Exit(8);\n    } // switch\n    po=po+pd->width;\n    strcpy(po,dlm);                    // NODLM has a null delimeter\n    po=po+strlen(dlm);\n   } // for i\n   po=po-strlen(dlm);\n   if ( (action==actSQL)||((action==actWRITE)&&(fRPT==YES)) )\n   {po\u00dd0\u00a8='|';po++;}\n   po\u00dd0\u00a8='\\0';\n   outBUFrecord();\n  } // for k\n  if (eofC1)\n  printDashes(outBUF,pCOLNAME);\n}\n/*********************************************************************\\\n|\n|  freeSQLDA() -- free SQLDATA & SQLIND arrays, close files\n|\n\\*********************************************************************/\nvoid freeSQLDA(void) {                                          // $fnc$\n int i;\n   if ((action==actREAD)&&(multiRows>1)) SQLd--;\n   for(i=0;i<SQLd;i++) {\n    free(SQLDATA(i));\n    SQLDATA(i)=NULL;\n    free(SQLIND(i));\n    SQLIND(i)=NULL;\n   }\n   SQLd=0;\n   if (pCOLNAME)  {free(pCOLNAME);    pCOLNAME=NULL; }\n   if (pCOLDATA)  {free(pCOLDATA);    pCOLDATA=NULL; }\n   if (fpWRITE)   {fclose(fpWRITE);   fpWRITE=NULL;  }\n   if (fpREAD)    {fclose(fpREAD);    fpREAD=NULL;   }\n   if (fpDISCARD) {fclose(fpDISCARD); fpDISCARD=NULL;}\n   if (fpNETRC)   {fclose(fpNETRC);   fpNETRC=NULL;  }\n}\n/*********************************************************************\\\n|\n|  allocSQLVARarrays() -- set SQLDA fields\n|\n\\*********************************************************************/\nvoid allocSQLVARarrays(short n)  {                              // $fnc$\n short i,m;\n struct bytes18 {\n    int byte14;\n  short byte56;\n  short byte78;\n } dw;\n char *p1;\n short *p2;\n dw.byte14=0x00000000;dw.byte56=0x0001;dw.byte78=n;\n\n   if (trace) printSQLDA();\n   for(i=0;i<SQLd;i++) {\n    switch (SQLTYPE(i)) {\n      case sCHAR:      case sCHARn:\n      case sBIN:       case sBINn:\n      case sDATE:      case sDATEn:\n      case sTIME:      case sTIMEn:\n      case sTIMESTAMP: case sTIMESTAMPn:\n      case sFLOAT:     case sFLOATn:\n      case sINT:       case sINTn:\n      case sSMINT:     case sSMINTn:\n      case sBIGINT:    case sBIGINTn:\n      case sDECFLOAT:  case sDECFLOATn:\n           p1 = (char *) malloc(SQLLEN(i)*n);\n           if (fASIS) maxpos+=SQLLEN(i)+1;\n           break;\n      case sVARBIN:    case sVARBINn:\n      case sVCHAR:     case sVCHARn:\n      case sLVCHAR:    case sLVCHARn:\n           if (multiRows>1) m=SQLLEN(i)%2; else m=0;\n           p1 = (char *) malloc((SQLLEN(i)+2+m)*n);\n           if (fASIS) maxpos+=SQLLEN(i)+2+1;\n           break;\n      case sDEC:       case sDECn:\n           parseDecSQLLEN(i);\n           p1 = (char *) malloc(memory*n);\n           if (fASIS) maxpos+=memory+1;\n           break;\n      default:\n      Xprintf(\" \\n*ERROR* Unsupported SQLTYPE=%d, SQLNAME=%s\\n\",\n              SQLTYPE(i),SQLNAMED(i));\n      Exit(8);\n    } // switch\n    p2 = (short *) malloc(sizeof(short)*n);\n    if ((p1==NULL)||(p2==NULL)) Exit(999);\n    memset(p2,'\\0',sizeof(short)*n);\n    SQLDATA(i)=p1;\n    SQLIND(i)=p2;\n       if (n>1) {\n       memcpy(SQLNAMED(i),&dw,8);\n       SQLNAMEL(i)=8; }\n   } // for\n       if ((action==actREAD)&&(n>1)) {\n        i=SQLd;\n        SQLd++;\n        SQLTYPE(i)=sSMINT;\n        SQLLEN(i)=2;\n        dw.byte14=0x00000000;dw.byte56=0x0002;dw.byte78=0x0000;\n        memcpy(SQLNAMED(i),&dw,8);\n        SQLDATA(i)=(char*)&builtRows;\n        SQLNAMEL(i)=8;\n       }\n// if (trace) printSQLDA();\n}\n/*********************************************************************\\\n|\n|  executeSELECT() -- execute a SELECT statement\n|\n|     Using a multiple-row FETCH statement with a descriptor\n|\n|      1. Declare an SQLDA structure.\n|      2. Dynamically allocate the SQLDA and the necessary arrays\n|         for the column values.\n|      3. Set the fields in the SQLDA for the column values that\n|         are to be retrieved.\n|      4. Open the cursor.\n|      5. Fetch the rows.\n|\n\\*********************************************************************/\nvoid executeSELECT(void) {                                      // $fnc$\n\n   parseColumnLength();\n   if ( (action==actSQL)||((action==actWRITE)&&(fRPT)) )\n   parseColumnNames();\n\n   if ( (action==actSQL)||((action==actWRITE)&&(fRPT)) )\n   printColumnNames();\n\n   if ((action==actWRITE)&&(fpWRITE==NULL))\n   openWRITE();\n\n   allocSQLVARarrays(multiRows);\n\n       if (multiRows>1)\n       EXEC SQL OPEN C1;\n       else\n       EXEC SQL OPEN C2;\n\n       if  (SQLCODE)  processSQLCODE(\"OPEN CURSOR\");\n       if  (SQLCODE)  return;\n   eofC1=NO;\n   rowsC1=0;\n\n   do {\n       if (multiRows>1)\n       EXEC SQL FETCH\n                   NEXT ROWSET\n                   FROM C1\n                   FOR :multiRows ROWS\n                   INTO\n                   DESCRIPTOR :*pSQLDA;\n       else\n       EXEC SQL FETCH\n                   FROM C2\n                   INTO\n                   DESCRIPTOR :*pSQLDA;\n\n       if  (SQLCODE==100) eofC1=YES;\n       else {if  (SQLCODE)  processSQLCODE(\"FETCH CURSOR\");\n             if  (SQLCODE)  return;}\n       if (multiRows>1);\n       else if (eofC1) SQLERRD3=0; else SQLERRD3=1;\n       if (trace) Xprintf(\" trace: SQLERRD3=%d\\n\",SQLERRD3);\n       rowsC1=rowsC1+SQLERRD3;\n       printC1rows(SQLERRD3);\n\n   } while (eofC1==NO);\n\n       if (multiRows>1)\n       EXEC SQL CLOSE C1;\n       else\n       EXEC SQL CLOSE C2;\n       if (SQLCODE) processSQLCODE(\"CLOSE CURSOR\");\n       if (SQLCODE) return;\n\n   if (Max(rowsC1,cntWRITE)>0) {\n   if (action==actWRITE)\n   {Xprintf(\"*** Successful WRITE of %d record(s),\"\n           \" RECFM=FB, LRECL=%d\\n\",cntWRITE,lreclWRITE);RC=0;}\n    else\n    {Xprintf(\"*** Successful retrieval of %d row(s)\\n\",rowsC1);RC=0;}\n   }\n   else {\n    Xprintf(\"*** Empty selection, RC=4\\n\");\n    RC=4;\n   }\n}\n/*<READ>**************************************************************\\\n|\n|  fillCOLPOSarray() -- generate positions for VALUES(*);\n|\n\\*********************************************************************/\nint fillCOLPOSarray(char *ps) {                                 // $fnc$\n struct COLPOS *pc;\n   char *pe,*pw,*pf=ps;\n   char wdlm=dlm\u00dd0\u00a8;\n  short i,m;\n\n    maxpos=0;\n    if (multiRows>1) m1=1; else m1=0;\n\n    for(i=0;i<SQLd-m1;i++,maxpos+=pc->len) {\n\n      pc=&pCOLPOS\u00ddi\u00a8;\n      pc->start=ps-pf+1;\n      if (i+1==SQLd-m1) wdlm='\\0';\n      pw=ps;\n\n      // start ASIS\n      if (fASIS) {\n       switch (SQLTYPE(i)) {\n        case sVCHAR:  case sVCHARn:\n        case sLVCHAR: case sLVCHARn:\n        case sVARBIN: case sVARBINn:\n         pc->mlen=SQLLEN(i)+2;\n         break;\n        case sDEC: case sDECn:\n         parseDecSQLLEN(i);\n         pc->mlen=memory;\n         break;\n        default:\n         pc->mlen=SQLLEN(i);\n       }\n       pc->len=pc->mlen+1;               // 1 is for NULL indicator\n       ps=ps+pc->len;\n       continue;\n      } // end ASIS\n\n      // start CSV\n      if ((fCSV)&&(ps\u00dd0\u00a8=='\\\"')) {\n       if ((pe=strchr(ps+1,'\\\"'))==NULL) return(i+1);\n       pw=pe+1;\n      } // end CSV\n\n      if ((pe=strchr(pw,wdlm))==NULL) return(i+1);\n      pc->len=pe-ps;\n      ps=pe+1;\n      if (wdlm==' ') while (ps\u00dd0\u00a8==' ') ps++;\n    }\n    // print out generated positions\n    if (trace) {\n     for (i=0;i<SQLd-m1;i++) {\n      pc=&pCOLPOS\u00ddi\u00a8;\n      if (i==0) Xprintf(\"*** VALUES(\");\n      Xprintf(\"%d.%d\",pc->start,pc->len);\n      if (i+1<SQLd-m1) Xprintf(\",\"); else Xprintf(\")/n\");\n     }\n    }\n    return(0);\n}\n/*<READ>**************************************************************\\\n|\n|  loadSQLDATAarrays() -- read a READ file and populate SQLDATA arrays\n|\n\\*********************************************************************/\nvoid loadSQLDATAarrays(void) {                                  // $fnc$\n  short i,j,k,l,m,*pi,w;\n   long nn;\n    int n,len;\n struct COLPOS *pc;\n   char *po,*pd,*pw;\n   char char_save;\n\n   if (multiRows>1) m1=1; else m1=0;\n\n   // read a group of input records\n   for(k=0;k<multiRows;k++) {\n    // from STACK DATA\n    if (fDATA) {\n     lreclREAD=getDATA(outBUF);\n     if (trace) Xprintf(\" getDATA(outBUF)='%s'\\n\",outBUF);\n     eofREAD=eofDATA;\n     if (eofREAD==NO) cntREAD++;\n     rc=0;\n    } else\n    // from STACK LABEL\n    if (fLABEL) {\n     lreclREAD=getLABEL(outBUF);\n     if (trace) Xprintf(\" getLABEL(outBUF)='%s'\\n\",outBUF);\n     eofREAD=eofLABEL;\n     if (eofREAD==NO) cntREAD++;\n     rc=0;\n    } else {\n    // from FILE\n     if (fASIS) {\n      if (lreclREAD==0) lreclREAD=maxpos;\n      rc=freadbin(fnREAD,&fpREAD,(char*)&outBUF,          // binary\n                  lreclREAD,&eofREAD,&cntREAD,msg);\n     } else {\n      rc=freadtxt(fnREAD,&fpREAD,(char*)&outBUF,           // text\n                 sizeof(outBUF),&eofREAD,&cntREAD,msg);\n      if (eofREAD==NO) lreclREAD=strlen(outBUF);\n     }\n    }\n    if (rc!=0) { Xprintf(\"\\n \\n%s\\n\",msg); Exit(12); }\n    if (fECHO) return;\n    if (eofREAD==YES) break;\n    readRows++;\n\n    // populate COLPOS array for VALUES(*) or\n    // repopulate when CSV & #SET EXCEL ON is specified\n    if ((pCOLPOS->start==0)||((excelFlag)&&(fCSV))||(!fixposFlag)) {\n     rc=fillCOLPOSarray(outBUF);\n\n     if (rc>0) {\n      Xprintf(\" \\n*ERROR* Missing delimeter found, \"\n             \"field #%d, record #%d\\n\",rc,cntREAD);\n      Xprintf(\"'%s'\\n\",outBUF);\n      Exit(8);\n     }\n    }\n    if ((fASIS==NO)&&(maxpos>strlen(outBUF))) {  // add trailing blanks\n     memset(outBUF+strlen(outBUF),' ',maxpos-strlen(outBUF));\n     outBUF\u00ddmaxpos\u00a8='\\0';\n     lreclREAD=strlen(outBUF);\n    }\n\n   // process all fields on a record\n    for(i=0;i<SQLd-m1;i++) {       // bypass the last special entry\n     pd=SQLDATA(i)+SQLLEN(i)*k;            // current SQLDATA entry\n     pi=SQLIND(i)+k;                       // current SQLIND entry\n     pc=&pCOLPOS\u00ddi\u00a8;                       // current COLPOS entry\n     po=outBUF+pc->start-1;                // current input field\n     l=pc->len;                            // and its length\n\n     // process null char value first\n     // if --#SET LOADNULL ON\n     if ((fASIS==NO)&&(loadnullFlag==ON)) {\n      pw=findword(po,1,n);\n      if ( (pw!=NULL) && (pw\u00dd0\u00a8==nullchar) &&\n          ((n==1) || (pw-po+1==l)) ) {        // for \"?,\" word\n       *pi=-1;continue;}\n     }\n\n     // if READ ASIS specified:\n     if (fASIS==YES) {\n      if (po\u00dd0\u00a8=='\\0') *pi=0; else *pi=-1;    // set the null indicator\n      m=0;\n       switch (SQLTYPE(i)) {\n        case sVCHAR:  case sVCHARn: case sLVCHAR: case sLVCHARn:\n        case sVARBIN: case sVARBINn:\n         if (multiRows>1) m=SQLLEN(i)%2;\n        default: break;\n       }\n      pd=SQLDATA(i)+(pc->mlen)*k+k*m;         // ptr to SQLDATA entry\n      memcpy(pd,po+1,pc->mlen);               // fill in it\n      continue;                               // work is done\n     } // fASIS\n\n     // process not null char value\n     *pi=0;                                   // not null indicator\n     switch (SQLTYPE(i)) {\n\n      case sDATE:      case sDATEn:\n      case sTIME:      case sTIMEn:\n      case sTIMESTAMP: case sTIMESTAMPn:\n           if (rc=checkdatetime(po,l)) break;\n           memset(pd,' ',SQLLEN(i));\n           strncpy(pd,po,min(SQLLEN(i),l));\n           break;\n\n      case sCHAR:      case sCHARn:\n           memset(pd,' ',SQLLEN(i));\n           if ((fCSV)&&(po\u00dd0\u00a8=='\\\"')&&(po\u00ddl-1\u00a8=='\\\"'))\n           { l=l-2; po++; }\n           strncpy(pd,po,min(SQLLEN(i),l));\n           break;\n\n      case sVCHAR:     case sVCHARn:\n      case sLVCHAR:    case sLVCHARn:\n           if (multiRows>1) m=SQLLEN(i)%2; else m=0;\n           pd=SQLDATA(i)+(SQLLEN(i)+sizeof(short)+m)*k;\n           memset(pd,'\\0',SQLLEN(i)+sizeof(short)+m);\n           if ((fCSV)&&(po\u00dd0\u00a8=='\\\"'))\n           { l--;po++; for (j=l;((j>0)&&(po\u00ddj-1\u00a8==' '));j--);\n             if (po\u00ddj-1\u00a8=='\\\"') j--;\n           } else\n           for (j=l; ((j>0)&&(po\u00ddj-1\u00a8==' '));j--);\n           j=min(SQLLEN(i),j);\n           memcpy(pd,&j,sizeof(j));\n           pd+=2;\n           strncpy(pd,po,j);\n           break;\n\n      case sVARBIN:    case sVARBINn:\n           if (multiRows>1) m=SQLLEN(i)%2; else m=0;\n           pd=SQLDATA(i)+(SQLLEN(i)+sizeof(short)+m)*k;\n           memset(pd,'\\0',SQLLEN(i)+sizeof(short)+m);\n           if ((fCSV)&&(po\u00dd0\u00a8=='\\\"'))\n           { l--;po++; for (j=l;((j>0)&&(po\u00ddj-1\u00a8==' '));j--);\n             if (po\u00ddj-1\u00a8=='\\\"') j--;\n           } else\n           for (j=l; ((j>0)&&(po\u00ddj-1\u00a8==' '));j--);\n           w=(j+1)/2;\n           if (w>SQLLEN(i)) {rc=1; break;}\n           memcpy(pd,&w,sizeof(short));\n           pd+=2;\n           rc=strPXcpy(pd,po,j);\n           break;\n\n      case sBIN:       case sBINn:\n           memset(pd,'\\0',SQLLEN(i));\n           if ((fCSV)&&(po\u00dd0\u00a8=='\\\"')&&(po\u00ddl-1\u00a8=='\\\"'))\n           { l=l-2; po++; }\n           w=(l+1)/2;\n           if (w>SQLLEN(i)) {rc=1;  break;}\n           rc=strPXcpy(pd,po,l);\n           break;\n\n      case sFLOAT:     case sFLOATn:\n           strncpy(word2,po,min(l,sizeof(word2)-1));\n           word2\u00ddmin(l,sizeof(word2)-1)\u00a8='\\0';\n           if (rc=checkfloat(word2)) break;\n           if (SQLLEN(i)==4)\n           *(float*)pd=atof(word2);\n           else\n           *(double*)pd=atof(word2);\n           break;\n\n      case sINT:       case sINTn:\n      case sSMINT:     case sSMINTn:\n      case sBIGINT:    case sBIGINTn:\n           if (SQLLEN(i)==8) rc=checkint(po,l,19);\n           else\n           if (SQLLEN(i)==4) rc=checkint(po,l,10);\n           else              rc=checkint(po,l,5);\n           if (rc) break;\n           strncpy(word2,po,min(l,sizeof(word2)-1));\n           word2\u00ddmin(l,sizeof(word2)-1)\u00a8='\\0';\n           if (SQLLEN(i)==8)\n            *(long long int*)pd=atoi(word2);\n           else\n           if (SQLLEN(i)==4)\n            *(int*)pd=atoi(word2);\n           else\n            *(short*)pd=atoi(word2);\n           break;\n\n      case sDEC:       case sDECn:\n           parseDecSQLLEN(i);\n           pd=SQLDATA(i)+memory*k;\n           if (fCSV) for (;(l>0)&&(po\u00ddl-1\u00a8==' ');l--);\n           rc=char2dec(pd,po,l);\n           break;\n      case sDECFLOAT:       case sDECFLOATn:\n           Xprintf(\" \\n*RESTRICTION* DECFLOAT is not supported yet\\n\");\n           Exit(8);\n      default:\n           Xprintf(\" \\n*ERROR* Unsupported SQLTYPE=%d\\n\",SQLTYPE(i));\n           Exit(8);\n    } // switch\n    if (rc>0) {\n     char_save=po\u00ddpc->len\u00a8;\n     po\u00ddpc->len\u00a8='\\0';\n     if (fDISCARD) {\n       Xprintf(\"*** discard #%d, field %d (%d.%d, %s),\"\n              \" invalid value='%s'\\n\",\n             cntREAD,i+1,pc->start,pc->len,pc->sqlname,po);\n       k--;\n       if (fDISCARDfn) {\n         if (fpDISCARD==NULL) openDISCARD();\n         po\u00ddpc->len\u00a8=char_save;\n         nn=writeRecord(fpDISCARD,fnDISCARD,outBUF,\n                        &cntDISCARD,lreclREAD);\n       } else cntDISCARD++;\n       break;\n     } else {\n      outBUF\u00ddpc->start+pc->len-1\u00a8='\\0';\n      po=&outBUF\u00ddpc->start-1\u00a8;\n      Xprintf(\" \\n*ERROR%d* Invalid input field #%d on record #%d,\\n\"\n              \"positions=%d.%d, sqlname=%s, value='%s'\\n\",rc,\n             i+1,cntREAD,pc->start,pc->len,pc->sqlname,po);\n      Exit(8);\n     }\n    } // rc>0\n   } // for i\n   if (rc==0) builtRows++;\n  } // for k\n}\n/*********************************************************************\\\n|\n|  processDISCARDrows() -- multi-rows INSERT failure processing\n|\n\\*********************************************************************/\nlong processDISCARDrows(long code) {                            // $fnc$\n long nn; int i,k=1;\n//printf(\"\\n code=%d\",code);\n        EXEC SQL GET DIAGNOSTICS :row_count=ROW_COUNT\n                          ,:nERROR=NUMBER;\n\n        if (multiRows>1) {\n         switch (code) {\n      //-253 A NON-ATOMIC statement STATEMENT SUCCESSFULLY COMPLETED FOR\n      //      SOME OF THE REQUESTED ROWS, POSSIBLY WITH WARNINGS,\n      //      AND ONE OR MORE ERRORS\n          case -253:\n         totalSQLERRD3=totalSQLERRD3 + row_count;\n      // -254 A NON-ATOMIC statement STATEMENT ATTEMPTED TO PROCESS\n      //      MULTIPLE ROWS OF DATA, BUT ERRORS OCCURRED\n          case -254:\n               break;\n          default:\n               return(code);\n         }\n        }\n        if (multiRows==1) {i=1;k=1;nERROR=1;} else {i=2;k=0;}\n        for (iERROR=i;iERROR<=nERROR;iERROR++) {\n         EXEC SQL GET DIAGNOSTICS CONDITION :iERROR\n         :SMESSAGE = MESSAGE_TEXT\n        ,:SCODE = DB2_RETURNED_SQLCODE\n        ,:SSTATE = RETURNED_SQLSTATE\n        ,:row_num     = DB2_ROW_NUMBER;\n\n          if (SCODE>=0) continue;\n    Xprintf(\"*** discard #%d, SQLCODE=%d, %s\\n\",\n            cntREAD-builtRows+row_num+k,SCODE,SMESSAGE);\n\n    if (fDISCARDfn) {\n      if (fpDISCARD==NULL) openDISCARD();\n      nn=writeRecord(fpDISCARD,fnDISCARD,outBUF,&cntDISCARD,lreclREAD);\n    } else cntDISCARD++;\n        }\n  return(0);\n}\n/*********************************************************************\\\n|\n|  executeSTATEMENT() -- execute a non-SELECT statement\n|\n\\*********************************************************************/\nvoid executeSTATEMENT(void) {                                   // $fnc$\n   if (doneSTMNT) return;\n   if (action!=actREAD)\n   EXEC SQL EXECUTE STMNT2;\n   else {\n    // multi-rows INSERT from a READ file\n    eofREAD=NO;\n    totalSQLERRD3=0;\n    // process each multiRows group of records\n    while ((SQLCODE==0)&&(eofREAD==NO)) {\n      builtRows=readRows=0;\n      loadSQLDATAarrays();\n      if (builtRows>0) {\n       if (multiRows>1)\n       EXEC SQL EXECUTE STMNT1 USING DESCRIPTOR :*pSQLDA;\n       else\n       EXEC SQL EXECUTE STMNT2 USING DESCRIPTOR :*pSQLDA;\n       if (SQLCODE==0)  totalSQLERRD3=totalSQLERRD3+SQLERRD3;\n       else if (fDISCARD) SQLCODE=processDISCARDrows(SQLCODE);\n      }\n    } // while\n   } // else\n\n   if  (SQLCODE<0) { processSQLerror(\"EXECUTE\"); return; }\n   if  (SQLCODE>0) { processSQLwarning(\"EXECUTE\");SQLCODE=0;}\n\n   if  (SQLCODE==100) {\n      Xprintf(\"*** SQLCODE = +100, no rows found, RC=4\\n\");\n      RC=4;\n   } else\n   if ((strcmp(word1,\"DELETE\")==EQUALS)&&(SQLERRD3==-1))\n      Xprintf(\"*** Successful DELETE of ALL rows\\n\");\n   else\n   if ( (strcmp(word1,\"DELETE\")==EQUALS)||\n       ((strcmp(word1,\"INSERT\")==EQUALS)&&(action!=actREAD))||\n        (strcmp(word1,\"UPDATE\")==EQUALS)||\n        (strcmp(word1,\"SAVE\")==EQUALS))\n      { if (SQLERRD3>0) {\n       Xprintf(\"*** Successful %s of %d row(s)\\n\",word1,SQLERRD3);\n       RC=0;\n      } else {\n       Xprintf(\"*** Empty %s, %d row(s), RC=4\\n\",word1,SQLERRD3);\n       RC=4;\n      }\n   } else\n   if (action==actREAD) {\n      if (cntREAD==0) {\n       if (fDATA)\n       Xprintf(\"*WARNING* STACK DATA is empty, RC=4\\n\");\n       else\n       if (fLABEL)\n       Xprintf(\"*WARNING* STACK LABEL is empty, RC=4\\n\");\n       else\n       Xprintf(\"*WARNING* File %s is empty, RC=4\\n\",fnREAD);\n       RC=4;\n      } else\n      if (cntREAD==totalSQLERRD3)\n  {Xprintf(\"*** Successful READ & INSERT of %d row(s)\\n\",cntREAD);RC=0;}\n      else\n      if (cntREAD>totalSQLERRD3) {\n       Xprintf(\"*** READ %d records, INSERT %d rows, DISCARD %d rows\",\n              cntREAD, totalSQLERRD3, cntDISCARD);\n       RC=4; Xprintf(\", RC=4\\n\");\n      } else Exit(777);\n   }\n   else\n     {Xprintf(\"*** %-9s successful\\n\",word1);RC=0;}\n}\n/*********************************************************************\\\n|\n|  printHelpExplain() -- print out some info about PLAN_TABLE fields\n|\n\\*********************************************************************/\nvoid printHelpExplain(void) {                                   // $fnc$\nXprintf(\" JOIN_METHOD indicates the join method used for the step: \\n\");\nXprintf(\" 0  -- First, continuation of previous access, or not used\\n\");\nXprintf(\" 1  -- Nested loop join.                                  \\n\");\nXprintf(\" 2  -- Merge scan join.                                   \\n\");\nXprintf(\" 3  -- Sorts needed by ORDER BY, GROUP BY, DISTINCT, ...  \\n\");\nXprintf(\" 4  -- Hybrid join.                                       \\n\");\nXprintf(\" ACCESS_TYPE indicates the method of accessing the table: \\n\");\nXprintf(\" I  -- By an index                                        \\n\");\nXprintf(\" I1 -- By a one-fetch index scan                          \\n\");\nXprintf(\" M  -- By a multiple index scan (followed by MX,MI,or MU) \\n\");\nXprintf(\" MI -- By an intersection of multiple indexes             \\n\");\nXprintf(\" MU -- By a union of multiple indexes                     \\n\");\nXprintf(\" MX -- By an index scan on the index named in ACCESSNAME  \\n\");\nXprintf(\" N  -- By an index scan when the IN keyword is            \\n\");\nXprintf(\" R  -- By a table space scan                              \\n\");\nXprintf(\" RW -- By a work file scan                                \\n\");\nXprintf(\" V  -- By buffers for an INSERT statement within a SELECT \\n\");\n}\n/*********************************************************************\\\n|\n|  POSTPROCESS_SQL_STMNT() -- post-processing of some statements\n|\n\\*********************************************************************/\nvoid POSTPROCESS_SQL_STMNT(void)                                // $fnc$\n{\n  if (doneSTMNT) return;\n  if ((plastIFDO)&&(plastIFDO->flag\u00dd0\u00a8=='N')) return;\n  if (fEXPLAIN) {\n   printHelpExplain();\n   fEXPLAIN=OFF;\n   signposFlag=hold_signposFlag;\n   nullchar=hold_nullchar;\n  }\n  if ((fDISCARD)&&(fDISCARDfn)) {\n   if (fpDISCARD==NULL) openDISCARD();\n   multiRows=multiRows_save;\n  }\n#if defined(__MVS__)\n  if (fLOCK) {\n   rc=callIFI(cmdDIS);\n   displyTSstatus(0);\n   fLOCK=NO;\n  }\n#endif\n   Xprintf(\"*** CPU time = %.4f seconds, TOTAL time = %d seconds\\n\",\n              CPUtime(cputime1),TOTALtime(tottime1));\n   doneSTMNT=YES;\n}\n/*********************************************************************\\\n|\n|  PROCESS_SQL_STMNT() -- prepare & describe an SQL statement\n|\n\\*********************************************************************/\nvoid PROCESS_SQL_STMNT(void)                                    // $fnc$\n{\n   if (trace) Xprintf(\" SQL.Len=%d \\n SQL.Str=\\\"%s\\\"\\n\",SQL.Len,SQL.Str);\n\n   if ((SQL.Len==0)||(doneSTMNT==YES)) return;\n   if ((plastIFDO)&&(plastIFDO->flag\u00dd0\u00a8=='N')) return;\n\n   // Prepare an SQL statement\n    EXEC SQL PREPARE STMNT2 FROM :SQL;\n\n   if (SQLCODE) {processSQLCODE(\"PREPARE STMNT2\"); if (SQLCODE) return;}\n\n   // Describe an SQL statement\n   if (SQLd==0) {\n    do {\n        EXEC SQL DESCRIBE STMNT2 INTO :*pSQLDA;\n    } while (checkSQLd());\n   }\n\n   // Special Prepare for multi-rows\n   if ((SQLd>0)&&(multiRows>1)) {\n    if (action==actREAD) {\n        strcpy(attr.data,multistr);\n        strcat(attr.data,notatomic);\n        attr.len=strlen(attr.data);\n        EXEC SQL PREPARE STMNT1\n            ATTRIBUTES :attr\n               FROM :SQL;\n    } else\n        EXEC SQL PREPARE STMNT1 FROM :SQL;\n   if (SQLCODE) {processSQLCODE(\"PREPARE STMNT1\"); if (SQLCODE) return;}\n   }\n\n   if ((trace)&&(SQLd>0)) printSQLDA();\n\n   // Start timings\n   cputime1 = CPUtime(0);\n   tottime1 = TOTALtime(0);\n\n   // Execute SQL stamenent\n\n   if ((SQLd>0)&&(action!=actREAD))\n     executeSELECT();\n   else\n     executeSTATEMENT();\n\n}\n//****************************************************************\n//**                                                            **\n//**                   M A I N  L I N E                         **\n//**                                                            **\n//****************************************************************\nint main(int argc, char *argv\u00dd\u00a8)                                // $fnc$\n{\n   OPEN_INIT(argc,argv);\n\n   newSTMNT=YES;\n   READ_INPUT_LINE();\n\n   while((eofINSQL==NO)||(eofFIFO==NO))\n   {\n     while( (newSTMNT==YES) && ( (eofINSQL==NO)||(eofFIFO==NO) ) )\n     {\n        APPEND_INPUT_TO_STMNT();\n        READ_INPUT_LINE();\n     }\n     doneSTMNT=NO;\n     while(doneSTMNT==NO)\n     {\n        PREPROCESS_SQL_STMNT();\n        PROCESS_SQL_STMNT();\n        POSTPROCESS_SQL_STMNT();\n     }\n     newSTMNT=YES;\n     resetGlobalVariables();\n     READ_INPUT_LINE();\n   }\n\n   PREPROCESS_SQL_STMNT();\n   PROCESS_SQL_STMNT();\n   POSTPROCESS_SQL_STMNT();\n\n  printTotalTimings();\n  if (fpLOG) fclose(fpLOG);\n  return(RC);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CBSPUFI": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01N\\x009\\x01\\x12'\\x0f\\x01\\x12'\\x0f\\tX\\x00s\\x00r\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.78", "flags": 0, "createdate": "2012-09-26T00:00:00", "modifydate": "2012-09-26T09:58:39", "lines": 115, "newlines": 114, "modlines": 0, "user": "V2IBAVM"}, "text": "//CBSPUFI JOB ($2919BA,BIN070,FSH334,DEPT19BA),'C/C++ COMPILER',\n//       NOTIFY=&SYSUID,MSGCLASS=H,MSGLEVEL=(1,1),TIME=5\n//*\n//* GLOBAL VARIABLES\n//*\n// SET     M=BSPUFI                          C/C++ MEMBER NAME\n// SET     L=&M                              LOAD MODULE NAME\n// SET     D=&M                              DBRM NAME\n// SET   DB2=DB2E                            SSID\n// SET  PLAN=&M                              PLAN NAME\n//*\n// SET  CLIB=&SYSUID..CBT484.FILE866\n// SET  LLIB=MDCT.TEST.LOADLIB <-- SPECIFY YOUR LIBRARY\n// SET  DLIB=MDCT.TEST.DBRMLIB <-- SPECIFY YOUR LIBRARY\n//*\n//*   DB2 SQL PRE-COMPILER\n//*\n//DB2PC   EXEC PGM=DSNHPC,\n// PARM='HOST(CPP) CCSID(1047) SOURCE TIME(ISO) DATE(ISO) CONNECT(2)'\n//STEPLIB  DD  DSN=SYS1.&DB2..DSNEXIT,DISP=SHR\n//         DD  DSN=SYS1.&DB2..DSNLOAD,DISP=SHR\n//SYSIN    DD  DSN=&CLIB(&M),DISP=SHR\n//SYSCIN   DD  DSN=&&CIN,DISP=(NEW,PASS),\n//             UNIT=SYSDA,SPACE=(CYL,(10,10)),DCB=(RECFM=FB,LRECL=80)\n//SYSTERM  DD  SYSOUT=*\n//SYSLIB   DD  DUMMY\n//DBRMLIB  DD  DSN=&DLIB(&D),DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(20,20)),\n//             DISP=(NEW,DELETE,DELETE)\n//ABEND   EXEC PGM=JTERM,COND=(4,GE,DB2PC)\n//*\n//* C/C++ COMPILE (V1.7 Z/OS XL C++).\n//*\n//CPP     EXEC PGM=CCNDRVR,REGION=4096K,\n// PARM=('NATLANG(ENU)/CXX SOURCE OPT ')   --LP64\n//STEPLIB  DD  DSNAME=SYS1.SCEERUN,DISP=SHR\n//         DD  DSNAME=SYS1.SCEERUN2,DISP=SHR\n//         DD  DSNAME=SYS1.SCCNCMP,DISP=SHR\n//SYSIN    DD  DSN=&&CIN,DISP=(OLD,DELETE)\n//SYSLIN   DD  DSN=&&LIN,DISP=(NEW,PASS),\n//             UNIT=SYSDA,SPACE=(CYL,(10,10)),DCB=(RECFM=FB,LRECL=80)\n//USERLIB  DD  DUMMY\n//SYSUT17  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSCPRT  DD  SYSOUT=*\n//ABEND   EXEC PGM=JTERM,COND=(4,GE,CPP)\n//*\n//* PRE-LINKEDIT STEP\n//*\n//PLKED   EXEC PGM=EDCPRLK,PARM='ER,NODYNAM'\n//*\n//STEPLIB  DD  DSN=SYS1.SCEERUN,DISP=SHR\n//SYSMSGS  DD  DSN=SYS1.SCEEMSGP(EDCPMSGE),DISP=SHR\n//SYSLIB   DD  DSN=SYS1.SCEECPP,DISP=SHR\n//         DD  DSN=SYS1.SCEELKEX,DISP=SHR\n//         DD  DSN=SYS1.SCEEOBJ,DISP=SHR\n//SYSIN    DD  DSN=&&LIN,DISP=(OLD,DELETE)\n//SYSMOD   DD  DSNAME=&&PLKSET,DISP=(NEW,PASS),\n//             SPACE=(32000,(30,30)),UNIT=SYSALLDA,\n//             DCB=(RECFM=FB,LRECL=80)\n//SYSOUT   DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSDEFSD DD  DUMMY\n//ABEND   EXEC PGM=JTERM,COND=(4,GE,PLKED)\n//*\n//* LINKEDIT STEP:\n//*\n//LKED   EXEC PGM=HEWL,PARM='AMODE=31,MAP'\n//*\n//SYSLIB   DD  DSN=SYS1.SCEELKED,DISP=SHR\n//         DD  DSN=SYS1.SCEESPC,DISP=SHR\n//         DD  DSN=SYS1.&DB2..DSNLOAD,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=*.PLKED.SYSMOD,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=&LLIB(&L),DISP=SHR\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(32000,(30,30))\n//SYSIN    DD  DUMMY\n//SYSIN    DD *\n  INCLUDE SYSLIB(DSNHLI)\n  INCLUDE SYSLIB(DSNELI)\n  INCLUDE SYSLIB(DSNWLIR)\n  NAME BSPUFI(R)\n/*\n//ABEND   EXEC PGM=JTERM,COND=(4,GE,LKED)\n//*\n//* BIND PLAN\n//*\n//BIND    EXEC PGM=IKJEFT01,DYNAMNBR=20,\n// PARM='DSN SYSTEM(&DB2)'\n//DBRMLIB  DD DSN=&DLIB(&D),DISP=SHR\n//SYSTSPRT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD DUMMY\n//SYSTSIN  DD *\n    BIND PLAN(BSPUFI) MEMBER(BSPUFI) VALIDATE(BIND) -\n    ISOLATION(CS) ACQUIRE(USE) EXPLAIN(NO)\n    END\n/*\n//*\n//*  GRANTS\n//*\n//GRANTS  EXEC PGM=IKJEFT01,DYNAMNBR=20,COND=(4,LT),\n// PARM='DSN SYSTEM(&DB2)'\n//*\n//STEPLIB  DD DSN=&LLIB,DISP=SHR\n//SYSTSIN  DD *\n RUN PROG(BSPUFI) PLAN(BSPUFI) +\n  PARMS('INSQL(DD:SYSIN)')\n//SYSTSPRT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n GRANT EXECUTE ON PLAN BSPUFI TO PUBLIC;\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DBRMLIB": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x16/\\x01\\x12\\x16/\"7\\x00z\\x00z\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-06-10T00:00:00", "modifydate": "2012-06-10T22:37:00", "lines": 122, "newlines": 122, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "DEMOJOB": {"ttr": 2828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\n\\x00G\\x01\\x12\\x15\\x1f\\x01\\x12'\\x0f\\x08@\\x00\\x1a\\x00\\x13\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.10", "flags": 0, "createdate": "2012-05-30T00:00:00", "modifydate": "2012-09-26T08:40:47", "lines": 26, "newlines": 19, "modlines": 0, "user": "V2IBAVM"}, "text": "//DEMOJOB JOB ($2919BA,BIN070,FSH334,DEPT19BA),'RUN SQL',\n//       NOTIFY=&SYSUID,MSGCLASS=H,MSGLEVEL=(1,1),TIME=5\n//*\n//RUN01   EXEC PGM=IKJEFT01,DYNAMNBR=50\n//STEPLIB  DD DSN=MDCT.TEST.LOADLIB,DISP=SHR\n//SYSTSIN  DD *\n DSN SYSTEM (DB2E)\n RUN PROG(BSPUFI) PLAN(BSPUFI) +\n      PARMS('INSQL(DD:SYSIN) TAGS(DD:TAGS) OUTSQL(DD:OUTSQL)' )\n/*\n//TAGS     DD *                  <-- TAGS TO ADJUST INPUT SQL\n--TAGS---       --VALUES--        -- THIS IS A COMMENT IN TAGS FILE\n<CREATOR>       DSN8810           -- TEST TABLE CREATOR NAME\n<TABLE>         EMP               -- TEST TABLE NAME\n<COLUMN>        EMPNO             -- FOR CREATE UNIQUE INDEX\n<NN>            2                 -- FETCH FIRST <NN> ROWS ONLY\n/*\n//SYSIN    DD DSN=&SYSUID..CBT484.FILE866(DEMOSQL),DISP=SHR\n//INCLUDE  DD DSN=&SYSUID..CBT484.FILE866(DEMOSQL1),DISP=SHR\n//OUTSQL   DD SYSOUT=*\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,(1,1))\n//*\n//SYSPRINT DD SYSOUT=*,LRECL=330  <-- ADJUST IF YOU NEED MORE OR LESS\n//SYSTSPRT DD SYSOUT=*\n//CEEDUMP  DD DUMMY\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DEMOSDSF": {"ttr": 2830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x16/\\x01\\x12\\x16/\"A\\x02\\x9d\\x02\\x9d\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-06-10T00:00:00", "modifydate": "2012-06-10T22:41:00", "lines": 669, "newlines": 669, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "DEMOSQL": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01?\\x00\\x04\\x01\\x12\\x15/\\x01\\x12\\x15?\\x11%\\x01 \\x00Q\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.63", "flags": 0, "createdate": "2012-05-31T00:00:00", "modifydate": "2012-06-01T11:25:04", "lines": 288, "newlines": 81, "modlines": 0, "user": "V2IBAVM"}, "text": "------------------------------------------------------------------------\n-- 'Display info about the current server'\n------------------------------------------------------------------------\nCONNECT;\n------------------------------------------------------------------------\n-- 'LOCK displays table space statuses before and after'\n------------------------------------------------------------------------\nLOCK TABLE <CREATOR>.<TABLE> IN SHARE MODE;\n\nCOMMIT;\n\nLOCK TABLE <CREATOR>.<TABLE> IN EXCLUSIVE MODE;\n\n------------------------------------------------------------------------\n-- 'Show a select report, use LRECL=nnnn in DD:SYSPRINT if you need'\n------------------------------------------------------------------------\nSELECT * FROM <CREATOR>.<TABLE>\nFETCH FIRST <NN> ROWS ONLY;\n\n------------------------------------------------------------------------\n-- 'Show an EXPLAIN report'\n------------------------------------------------------------------------\nWHENEVER SQLERROR CONTINUE;      -- if you do not have PLAN_TABLE\n\nEXPLAIN\n SELECT DISTINCT A.* FROM <CREATOR>.<TABLE> A\n UNION ALL\n SELECT A.* FROM <CREATOR>.<TABLE> A\n;\nWHENEVER SQLERROR ROLLBACK;\n\n------------------------------------------------------------------------\n-- 'Unload a select report to files in different formans'\n-- 'and load a session table'\n-- 'SESSION tables look like programs arrays'\n------------------------------------------------------------------------\nDECLARE GLOBAL TEMPORARY TABLE SESSION.W1 LIKE <CREATOR>.<TABLE>;\n\n-------------------------------\n-- 'a blank as a delimeter'  --\n-------------------------------\nWRITE FILE DD:SYSUT1\n SELECT * FROM <CREATOR>.<TABLE>\n FETCH FIRST <NN> ROWS ONLY;\nECHO\n....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8\n ...+....9....+....0....+....1....+....2....+....3....+....4....+....5....+....;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\nREAD FILE DD:SYSUT1 INSERT INTO SESSION.W1 VALUES(*);\n\n-------------------------------\n-- 'TAB(\\t) as a delimeter'  --\n-------------------------------\nWRITE TAB FILE DD:SYSUT1\n SELECT * FROM <CREATOR>.<TABLE>\n FETCH FIRST <NN> ROWS ONLY;\nECHO\n....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8\n ...+....9....+....0....+....1....+....2....+....3....+....4....+....5....+....;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\nREAD TAB FILE DD:SYSUT1 INSERT INTO SESSION.W1 VALUES(*);\n\n-------------------------------\n-- 'a comma as a delimeter'  --\n-------------------------------\nWRITE COMMA FILE DD:SYSUT1\n SELECT * FROM <CREATOR>.<TABLE>\n FETCH FIRST <NN> ROWS ONLY;\nECHO\n....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8\n ...+....9....+....0....+....1....+....2....+....3....+....4....+....5....+....;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\nREAD COMMA FILE DD:SYSUT1 INSERT INTO SESSION.W1 VALUES(*);\n\n-------------------------------\n-- '\"|\"     as a delimeter'  --\n-------------------------------\nWRITE BAR FILE DD:SYSUT1\n SELECT * FROM <CREATOR>.<TABLE>\n FETCH FIRST <NN> ROWS ONLY;\nECHO\n....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8\n ...+....9....+....0....+....1....+....2....+....3....+....4....+....5....+....;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\nREAD BAR FILE DD:SYSUT1 INSERT INTO SESSION.W1 VALUES(*);\n\n-------------------------------\n-- 'Select report to a file' --\n-------------------------------\nWRITE RPT FILE DD:SYSUT1\n SELECT * FROM <CREATOR>.<TABLE>\n FETCH FIRST <NN> ROWS ONLY;\nECHO\n....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8\n ...+....9....+....0....+....1....+....2....+....3....+....4....+....5....+....;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\n\n-------------------------------\n-- 'Without any delimeter'   --\n-------------------------------\nWRITE NODLM FILE DD:SYSUT1\n SELECT * FROM <CREATOR>.<TABLE>\n FETCH FIRST <NN> ROWS ONLY;\nECHO\n....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8\n ...+....9....+....0....+....1....+....2....+....3....+....4....+....5....+....;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\nREAD NODLM FILE DD:SYSUT1 INSERT INTO SESSION.W1\n VALUES(1.6,7:18,19.1,20:34,35:37,38:41,42:51,52:60,\n        61:65,66.1,67:76,77:86,87:97,98:108);\n\n-------------------------------\n-- 'ASIS -- binary format'   --\n-------------------------------\nWRITE ASIS FILE DD:SYSUT1\n SELECT * FROM <CREATOR>.<TABLE> A\n FETCH FIRST <NN> ROWS ONLY;\nECHO\n....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8\n ...+....9....+....0....+....1....+....2....+....3....+....4....+....5....+....;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\nREAD ASIS FILE DD:SYSUT1 INSERT INTO SESSION.W1 VALUES(*);\n\nSELECT * FROM SESSION.W1;\nDELETE FROM SESSION.W1;\n\n-------------------------------\n-- 'CSV file, fixed format'  --\n-------------------------------\nWRITE CSV FILE DD:SYSUT1     -- CSV\n SELECT * FROM <CREATOR>.<TABLE>\n FETCH FIRST <NN> ROWS ONLY;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\nREAD CSV FILE DD:SYSUT1 INSERT INTO SESSION.W1 VALUES(*);\nSELECT * FROM SESSION.W1;\n\n------------------------------------------------------------------------\n-- 'CREATE INDEX helps to improve CPU timings for complex SQLs'\n------------------------------------------------------------------------\nCREATE UNIQUE INDEX SESSION.I1 ON SESSION.W1 (<COLUMN>);\n\n-- 'Reject records w/ SQL errors'\nREAD CSV FILE DD:SYSUT1\n DISCARD TEMP.EMP.DISCARD.CSV   -- DD:NAME or DSN for rejected records\n  INSERT INTO SESSION.W1 VALUES(*);\n\nRC1=RC;   -- save the current RC for late use\n\n------------------------------------------------------------------------\n-- 'Run DB2 commands twice from a file'\n------------------------------------------------------------------------\nDECLARE GLOBAL TEMPORARY TABLE SESSION.TS_USE (L CHAR(80));\n\nINCLUDE FILE DD:INCLUDE;\n\nCOMMIT;                     -- free some resources\n\nINCLUDE FILE DD:INCLUDE;\n\n------------------------------------------------------------------------\n-- 'Runstats w/o db and ts names, it needs PROCEDURE SYSPROC.DSNUTILS'\n------------------------------------------------------------------------\nWHENEVER SQLERROR CONTINUE;\n\nRUNSTATS TABLE <CREATOR>.<TABLE> INDEX(ALL);\n\n------------------------------------------------------------------------\n-- 'Conditional executions IF-DO;-ENDIF;'\n------------------------------------------------------------------------\nIF RC=8 DO;\n SYSTEM SEND 'RUNSTATS FAILED, THIS MESSAGE FROM' USER(*); -- TSO cmd\n ROLLBACK;\n CONNECT;\n DB2 -DISPLAY PROCEDURE (SYSPROC.DSNUTILS);\nENDIF;\n\n------------------------------------------------------------------------\n-- 'Generate and execute SQL'\n------------------------------------------------------------------------\n                           -- LIFO: run generated SQL at once\nSTACK LIFO                 -- FIFO: run generated SQL at the input end\n SELECT CHAR(L,100) FROM\n (\n  SELECT\n   'SELECT '''\n        ||STRIP(CREATOR)||'.'||STRIP(NAME)||''' AS TABLE_NAME,'\n        ||'COUNT(*) TOTAL_ROWS FROM '\n        || STRIP(CREATOR)||'.'||STRIP(NAME)||' UNION ALL' AS L\n    FROM SYSIBM.SYSTABLES\n   WHERE CREATOR='<CREATOR>'\n     AND NAME LIKE 'P%'\n     AND TYPE='T'\n UNION ALL\n  SELECT\n   'SELECT ''END-OF-REPORT'' AS TABLE_NAME,'\n        ||'0 AS TOTAL_ROWS FROM SYSIBM.SYSDUMMY1;'        AS L\n   FROM SYSIBM.SYSDUMMY1\n ) A\n--#SET PRINT OFF\n;\n--#SET PRINT ON\n\nWHENEVER SQLERROR ROLLBACK;\n\n------------------------------------------------------------------------\n-- 'DDL helps to understand what fields DB2 generates ...'\n-- 'Here it generates VARCHAR(300) vs CHAR(100) when UNION is used...'\n------------------------------------------------------------------------\nDDL\n   SELECT CHAR(\n    'SELECT '''\n         ||STRIP(CREATOR)||'.'||STRIP(NAME)||''' AS TABLE_NAME,'\n         ||'COUNT(*) TOTAL_ROWS FROM '\n         || STRIP(CREATOR)||'.'||STRIP(NAME)||' UNION ALL',100) L\n    FROM SYSIBM.SYSTABLES\n  UNION ALL\n   SELECT CHAR(\n    'SELECT ''END-OF-REPORT'' AS TABLE_NAME,'\n         ||'0 AS TOTAL_ROWS FROM SYSIBM.SYSDUMMY1;',100) L\n    FROM SYSIBM.SYSDUMMY1\n;\n------------------------------------------------------------------------\n-- 'Generate and execute DDL for a session table'\n------------------------------------------------------------------------\nSTACK LIFO\n DDL TABLE SESSION.W2\n  SELECT * FROM <CREATOR>.<TABLE>;\n\nINSERT INTO SESSION.W2\n SELECT * FROM <CREATOR>.<TABLE>;\n\n------------------------------------------------------------------------\n-- 'SAVE DATA implicitly declare a session table and populate it'\n------------------------------------------------------------------------\nSAVE DATA AS SESSION.W3\n SELECT * FROM SESSION.W2;\n\nSELECT * FROM SESSION.W3;\n------------------------------------------------------------------------\n-- 'Run TSO DELETE command if discard file not empty'\n------------------------------------------------------------------------\nIF RC1=4\n SYS DELETE TEMP.EMP.DISCARD.CSV;            -- TSO command\n-- try again, set max allowed RC to 8\n--#SET SYSRC 8\n SYS DELETE TEMP.EMP.DISCARD.CSV;\n IF RC=0 EXIT 8;                   -- EXIT abends the program\n RC=0;\n------------------------------------------------------------------------\n--'--#SET SIGNPOS ON|OFF|NO (default ON)                               '\n--'   OFF does not add a sign position for character numbers           '\n------------------------------------------------------------------------\nWRITE CSV STACK DATA\n SELECT * FROM <CREATOR>.<TABLE> FETCH FIRST 1 ROW ONLY;\n\n--#SET SIGNPOS OFF\n\nWRITE CSV STACK DATA\n SELECT * FROM <CREATOR>.<TABLE> FETCH FIRST 1 ROW ONLY;\n\nDECLARE GLOBAL TEMPORARY TABLE OUT (L VARCHAR(150));\n\nREAD NODLM STACK DATA\n INSERT INTO SESSION.OUT VALUES(1.150);\n\nSELECT * FROM SESSION.OUT;\n\nWRITE NODLM STACK DATA\n SELECT * FROM SESSION.OUT;\n\nDELETE FROM SESSION.W3;\n\n--#SET TRACE ON\n\nREAD CSV STACK DATA\n INSERT INTO SESSION.W3 VALUES(*);\n\n--#SET TRACE OFF\n\nSELECT * FROM SESSION.W3;\n\n--; This is a special comment, not printed out and copied to OUTSQL\n--#SET PRINT OFF\n-- This comment is supressed by PRINT OFF\n--! This comment is always printed out, no supression\n--#SET PRINT ON\n\nEND;   -- optional, can be in the middle of the input\n", "mimetype": "text/html", "datatype": "ebcdic", "extension": ".html"}, "DEMOSQL1": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x15\\x01\\x12\\x15\\x0f\\x01\\x12\\x15?\\x05B\\x00\\x0f\\x00\\t\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2012-05-29T00:00:00", "modifydate": "2012-06-01T05:42:15", "lines": 15, "newlines": 9, "modlines": 0, "user": "V2IBAVM"}, "text": "WRITE STACK DATA\n DB2 -DISPLAY DB(*) SP(*) LIMIT(*) USE ONLY\n;\nWRITE STACK DATA\n DB2 -DISPLAY DB(*) SP(*) LIMIT(*) LOCKS ONLY\n;\nREAD  STACK DATA\n INSERT INTO SESSION.TS_USE VALUES(1:80)\n;\nDELETE FROM SESSION.TS_USE WHERE L NOT LIKE ('% TS %')\n;\nDELETE FROM SESSION.TS_USE WHERE L LIKE ('SYS%')\n;\nSELECT DISTINCT A.* FROM SESSION.TS_USE A ORDER BY 1\n;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOADLIB": {"ttr": 3337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x16/\\x01\\x12\\x16/\"9\\x06\\x8a\\x06\\x8a\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-06-10T00:00:00", "modifydate": "2012-06-10T22:39:00", "lines": 1674, "newlines": 1674, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "OUTSQL": {"ttr": 4100, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x16/\\x01\\x12\\x16/!W\\x01\\x1f\\x01\\x1f\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-06-10T00:00:00", "modifydate": "2012-06-10T21:57:00", "lines": 287, "newlines": 287, "modlines": 0, "user": "V2IBAVM"}, "text": "------------------------------------------------------------------------\n-- 'Display info about the current server'\n------------------------------------------------------------------------\nCONNECT;\n------------------------------------------------------------------------\n-- 'LOCK displays table space statuses before and after'\n------------------------------------------------------------------------\nLOCK TABLE DSN8810.EMP IN SHARE MODE;\n\nCOMMIT;\n\nLOCK TABLE DSN8810.EMP IN EXCLUSIVE MODE;\n\n------------------------------------------------------------------------\n-- 'Show a select report, use LRECL=nnnn in DD:SYSPRINT if you need'\n------------------------------------------------------------------------\nSELECT * FROM DSN8810.EMP\nFETCH FIRST 2 ROWS ONLY;\n\n------------------------------------------------------------------------\n-- 'Show an EXPLAIN report'\n------------------------------------------------------------------------\nWHENEVER SQLERROR CONTINUE;      -- if you do not have PLAN_TABLE\n\nEXPLAIN\n SELECT DISTINCT A.* FROM DSN8810.EMP A\n UNION ALL\n SELECT A.* FROM DSN8810.EMP A\n;\nWHENEVER SQLERROR ROLLBACK;\n\n------------------------------------------------------------------------\n-- 'Unload a select report to files in different formans'\n-- 'and load a session table'\n-- 'SESSION tables look like programs arrays'\n------------------------------------------------------------------------\nDECLARE GLOBAL TEMPORARY TABLE SESSION.W1 LIKE DSN8810.EMP;\n\n-------------------------------\n-- 'a blank as a delimeter'  --\n-------------------------------\nWRITE FILE DD:SYSUT1\n SELECT * FROM DSN8810.EMP\n FETCH FIRST 2 ROWS ONLY;\nECHO\n....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8\n ...+....9....+....0....+....1....+....2....+....3....+....4....+....5....+....;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\nREAD FILE DD:SYSUT1 INSERT INTO SESSION.W1 VALUES(*);\n\n-------------------------------\n-- 'TAB(\\t) as a delimeter'  --\n-------------------------------\nWRITE TAB FILE DD:SYSUT1\n SELECT * FROM DSN8810.EMP\n FETCH FIRST 2 ROWS ONLY;\nECHO\n....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8\n ...+....9....+....0....+....1....+....2....+....3....+....4....+....5....+....;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\nREAD TAB FILE DD:SYSUT1 INSERT INTO SESSION.W1 VALUES(*);\n\n-------------------------------\n-- 'a comma as a delimeter'  --\n-------------------------------\nWRITE COMMA FILE DD:SYSUT1\n SELECT * FROM DSN8810.EMP\n FETCH FIRST 2 ROWS ONLY;\nECHO\n....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8\n ...+....9....+....0....+....1....+....2....+....3....+....4....+....5....+....;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\nREAD COMMA FILE DD:SYSUT1 INSERT INTO SESSION.W1 VALUES(*);\n\n-------------------------------\n-- '\"|\"     as a delimeter'  --\n-------------------------------\nWRITE BAR FILE DD:SYSUT1\n SELECT * FROM DSN8810.EMP\n FETCH FIRST 2 ROWS ONLY;\nECHO\n....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8\n ...+....9....+....0....+....1....+....2....+....3....+....4....+....5....+....;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\nREAD BAR FILE DD:SYSUT1 INSERT INTO SESSION.W1 VALUES(*);\n\n-------------------------------\n-- 'Select report to a file' --\n-------------------------------\nWRITE RPT FILE DD:SYSUT1\n SELECT * FROM DSN8810.EMP\n FETCH FIRST 2 ROWS ONLY;\nECHO\n....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8\n ...+....9....+....0....+....1....+....2....+....3....+....4....+....5....+....;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\n\n-------------------------------\n-- 'Without any delimeter'   --\n-------------------------------\nWRITE NODLM FILE DD:SYSUT1\n SELECT * FROM DSN8810.EMP\n FETCH FIRST 2 ROWS ONLY;\nECHO\n....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8\n ...+....9....+....0....+....1....+....2....+....3....+....4....+....5....+....;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\nREAD NODLM FILE DD:SYSUT1 INSERT INTO SESSION.W1\n VALUES(1.6,7:18,19.1,20:34,35:37,38:41,42:51,52:60,\n        61:65,66.1,67:76,77:86,87:97,98:108);\n\n-------------------------------\n-- 'ASIS -- binary format'   --\n-------------------------------\nWRITE ASIS FILE DD:SYSUT1\n SELECT * FROM DSN8810.EMP A\n FETCH FIRST 2 ROWS ONLY;\nECHO\n....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8\n ...+....9....+....0....+....1....+....2....+....3....+....4....+....5....+....;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\nREAD ASIS FILE DD:SYSUT1 INSERT INTO SESSION.W1 VALUES(*);\n\nSELECT * FROM SESSION.W1;\nDELETE FROM SESSION.W1;\n\n-------------------------------\n-- 'CSV file, fixed format'  --\n-------------------------------\nWRITE CSV FILE DD:SYSUT1     -- CSV\n SELECT * FROM DSN8810.EMP\n FETCH FIRST 2 ROWS ONLY;\nSYS OCOPY INDD(SYSUT1) OUTDD(SYSPRINT);\nREAD CSV FILE DD:SYSUT1 INSERT INTO SESSION.W1 VALUES(*);\nSELECT * FROM SESSION.W1;\n\n------------------------------------------------------------------------\n-- 'CREATE INDEX helps to improve CPU timings for complex SQLs'\n------------------------------------------------------------------------\nCREATE UNIQUE INDEX SESSION.I1 ON SESSION.W1 (EMPNO);\n\n-- 'Reject records w/ SQL errors'\nREAD CSV FILE DD:SYSUT1\n DISCARD TEMP.EMP.DISCARD.CSV   -- DD:NAME or DSN for rejected records\n  INSERT INTO SESSION.W1 VALUES(*);\n\nRC1=RC;   -- save the current RC for late use\n\n------------------------------------------------------------------------\n-- 'Run DB2 commands twice from a file'\n------------------------------------------------------------------------\nDECLARE GLOBAL TEMPORARY TABLE SESSION.TS_USE (L CHAR(80));\n\nINCLUDE FILE DD:INCLUDE;\n\nCOMMIT;                     -- free some resources\n\nINCLUDE FILE DD:INCLUDE;\n\n------------------------------------------------------------------------\n-- 'Runstats w/o db and ts names, it needs PROCEDURE SYSPROC.DSNUTILS'\n------------------------------------------------------------------------\nWHENEVER SQLERROR CONTINUE;\n\nRUNSTATS TABLE DSN8810.EMP INDEX(ALL);\n\n------------------------------------------------------------------------\n-- 'Conditional executions IF-DO;-ENDIF;'\n------------------------------------------------------------------------\nIF RC=8 DO;\n SYSTEM SEND 'RUNSTATS FAILED, THIS MESSAGE FROM' USER(*); -- TSO cmd\n ROLLBACK;\n CONNECT;\n DB2 -DISPLAY PROCEDURE (SYSPROC.DSNUTILS);\nENDIF;\n\n------------------------------------------------------------------------\n-- 'Generate and execute SQL'\n------------------------------------------------------------------------\n                           -- LIFO: run generated SQL at once\nSTACK LIFO                 -- FIFO: run generated SQL at the input end\n SELECT CHAR(L,100) FROM\n (\n  SELECT\n   'SELECT '''\n        ||STRIP(CREATOR)||'.'||STRIP(NAME)||''' AS TABLE_NAME,'\n        ||'COUNT(*) TOTAL_ROWS FROM '\n        || STRIP(CREATOR)||'.'||STRIP(NAME)||' UNION ALL' AS L\n    FROM SYSIBM.SYSTABLES\n   WHERE CREATOR='DSN8810'\n     AND NAME LIKE 'P%'\n     AND TYPE='T'\n UNION ALL\n  SELECT\n   'SELECT ''END-OF-REPORT'' AS TABLE_NAME,'\n        ||'0 AS TOTAL_ROWS FROM SYSIBM.SYSDUMMY1;'        AS L\n   FROM SYSIBM.SYSDUMMY1\n ) A\n--#SET PRINT OFF\n;\n--#SET PRINT ON\n\nWHENEVER SQLERROR ROLLBACK;\n\n------------------------------------------------------------------------\n-- 'DDL helps to understand what fields DB2 generates ...'\n-- 'Here it generates VARCHAR(300) vs CHAR(100) when UNION is used...'\n------------------------------------------------------------------------\nDDL\n   SELECT CHAR(\n    'SELECT '''\n         ||STRIP(CREATOR)||'.'||STRIP(NAME)||''' AS TABLE_NAME,'\n         ||'COUNT(*) TOTAL_ROWS FROM '\n         || STRIP(CREATOR)||'.'||STRIP(NAME)||' UNION ALL',100) L\n    FROM SYSIBM.SYSTABLES\n  UNION ALL\n   SELECT CHAR(\n    'SELECT ''END-OF-REPORT'' AS TABLE_NAME,'\n         ||'0 AS TOTAL_ROWS FROM SYSIBM.SYSDUMMY1;',100) L\n    FROM SYSIBM.SYSDUMMY1\n;\n------------------------------------------------------------------------\n-- 'Generate and execute DDL for a session table'\n------------------------------------------------------------------------\nSTACK LIFO\n DDL TABLE SESSION.W2\n  SELECT * FROM DSN8810.EMP;\n\nINSERT INTO SESSION.W2\n SELECT * FROM DSN8810.EMP;\n\n------------------------------------------------------------------------\n-- 'SAVE DATA implicitly declare a session table and populate it'\n------------------------------------------------------------------------\nSAVE DATA AS SESSION.W3\n SELECT * FROM SESSION.W2;\n\nSELECT * FROM SESSION.W3;\n------------------------------------------------------------------------\n-- 'Run TSO DELETE command if discard file not empty'\n------------------------------------------------------------------------\nIF RC1=4\n SYS DELETE TEMP.EMP.DISCARD.CSV;            -- TSO command\n-- try again, set max allowed RC to 8\n--#SET SYSRC 8\n SYS DELETE TEMP.EMP.DISCARD.CSV;\n IF RC=0 EXIT 8;                   -- EXIT abends the program\n RC=0;\n------------------------------------------------------------------------\n--'--#SET SIGNPOS ON|OFF|NO (default ON)                               '\n--'   OFF does not add a sign position for character numbers           '\n------------------------------------------------------------------------\nWRITE CSV STACK DATA\n SELECT * FROM DSN8810.EMP FETCH FIRST 1 ROW ONLY;\n\n--#SET SIGNPOS OFF\n\nWRITE CSV STACK DATA\n SELECT * FROM DSN8810.EMP FETCH FIRST 1 ROW ONLY;\n\nDECLARE GLOBAL TEMPORARY TABLE OUT (L VARCHAR(150));\n\nREAD NODLM STACK DATA\n INSERT INTO SESSION.OUT VALUES(1.150);\n\nSELECT * FROM SESSION.OUT;\n\nWRITE NODLM STACK DATA\n SELECT * FROM SESSION.OUT;\n\nDELETE FROM SESSION.W3;\n\n--#SET TRACE ON\n\nREAD CSV STACK DATA\n INSERT INTO SESSION.W3 VALUES(*);\n\n--#SET TRACE OFF\n\nSELECT * FROM SESSION.W3;\n\n--#SET PRINT OFF\n-- This comment is supressed by PRINT OFF\n--! This comment is always printed out, no supression\n--#SET PRINT ON\n\nEND;   -- optional, can be in the middle of the input\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SQL": {"ttr": 4106, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0e\\x00(\\x01\\x12%\\x1f\\x01\\x12'\\x0f\\x106\\x00T\\x00K\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.14", "flags": 0, "createdate": "2012-09-07T00:00:00", "modifydate": "2012-09-26T10:36:28", "lines": 84, "newlines": 75, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/*                                                                   */\n/* Name: SQL -- ISPF Edit Macro                                      */\n/*                                                                   */\n/* Function: Run BSPUFI program in interactive mode.                 */\n/*           When you edit/view a member with SQL statements         */\n/*           type SQL \u00ddSSID\u00a8 in the command line to execute them,    */\n/*           output of the program is displayed by Browse at the     */\n/*           end of execution.                                       */\n/*                                                                   */\n/* Note. Excluded lines by X/XX prefix command(s) are ignored.       */\n/*********************************************************************/\n/*                                                                   */\n/* ---------  Adjust the following default assignments ------------- */\n/*                                                                   */\n SSID = \"DB2E\"                                 /* default SSID       */\n BSPUFI=\"RUN PROGRAM(BSPUFI) PLAN(BSPUFI)\",\n        \"LIB('MDCT.TEST.LOADLIB') \",           /* specify your lib   */\n        \"PARMS('INSQL(DD:INSQL) PRINT(OFF) LOG(DD:LOG)' )\"\n/*                                                                   */\n/************************************* Vladimir Mestovski 2012 *******/\ntrace 'O'\n\nsql  = Userid()||'.$TEMP$.SQL'\nrpt  = Userid()||'.$TEMP$.LOG'\n\n\"ISREDIT MACRO (OPT1) PROCESS\"\n\"ISPEXEC CONTROL ERRORS RETURN\"\n\"ISREDIT (user) = USER_STATE\"\n\"ISREDIT (hrow,hcol) = CURSOR\"\n\"ISREDIT (scan) = SCAN\"\n\"ISREDIT SCAN OFF\"\n\"ISREDIT (LAST) = LINENUM .ZLAST\"\n\"ISREDIT (LRECL) = LRECL\"\n\nif opt1<>'' then parse upper var opt1 SSID .\n\nif datatype(LAST)='CHAR' then do;\n say \"*ERROR* YOU should remove pending prefix commands first..\"\n exit 8;\nend;\n\nk=0\ndo i = 1 to LAST\n \"ISREDIT\" '(statusx) = XSTATUS' i\n if statusx = 'X' then iterate\n \"ISREDIT\" '(DATA) = LINE' i\n k=k+1\n lines.k = DATA\nend\nlines.0=k\n\nx = Outtrap('o.')\n  Address TSO \"FREE FILE(INSQL)\"\n  Address TSO \"FREE FILE(LOG)\"\n  Address TSO \"DELETE '\"sql\"'\"\n  Address TSO \"DELETE '\"rpt\"'\"\nx=outtrap('OFF');\n\n  Address TSO \"ALLOCATE FI(INSQL) DSNAME('\"sql\"')\",\n              ' NEW DSORG(PS) RECFM(F,B) LRECL(80) ',\n              ' SPACE(1,1) CYLINDERS RELEASE UNIT(SYSDA) CATALOG REUSE'\n\n  Address TSO 'EXECIO * DISKW INSQL (FINIS STEM lines.'\n  If rc>1   then exit (restoreState(rc))\n\n  Address TSO \"ALLOCATE FILE(LOG) DSNAME('\"rpt\"')\",\n              \" NEW DSORG(PS) RECFM(V,B) \",\n              ' SPACE(10,10) TRACKS RELEASE UNIT(SYSDA) CATALOG REUSE'\n  Queue BSPUFI\n  Queue \"END\"\n\n  Address TSO \"DSN SYSTEM (\"SSID\")\"\n\n  Address MVS \"DELSTACK\"\n  \"ISPEXEC BROWSE DATASET('\"rpt\"')\"\n\n  Return (restoreState(0))\n\nrestoreState: parse arg src\n  'ISREDIT USER_STATE = (user)'\n  'ISREDIT SCAN = 'scan\n  'ISREDIT MEND'\n  Return src\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT866/FILE866.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT866", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}