       const char pgm_verÝ¨="Version 2012-10-31";
       const char pgm_titÝ¨="C SQL-DB2-TSO Processor";
       const char pgm_devÝ¨="Vladimir Mestovski,IBA,Minsk";
       const char pgm_envÝ¨="zOS";
/**********************************************************************/
/*                                                                    */
/* Title       :  C SQL-DB2-TSO Processor                             */
/*                                                                    */
/* Author      :  Vladimir Mestovski, IBA, Minsk, Belarus             */
/*             :  v2gri033@us.ibm.com  -- for bugs                    */
/*             :  mestovsky@iba.by     -- alternative                 */
/*                                                                    */
/* Environments:  z/OS (possible AIX,Windows)                         */
/*                                                                    */
/* Function:                                                          */
/*                                                                    */
/*  The program reads and executes SQL statements from the INSQL file.*/
/*  Before execution it substitutes tags from TAGS file (if specified)*/
/*  and writes adjusted statements to the OUTSQL file (if specified). */
/*  It also recognizes and executes special comments and functional   */
/*  commands that can be considered as an extension of SQL(see below).*/
/*  By default the program runs a ROLLBACK after the 1st SQL error    */
/*  occured, prints out select reports in QMF style, write a select   */
/*  report to a file or internal stack, read a file/stack to a table, */
/*  execute EXPLAIN, draw column names of a table...and more.         */
/*                                                                    */
/* Parameters:                                                        */
/*                                                                    */
/*     INSQL(file) - input file with SQL statements w/o seq numbering */
/*                   where 'file' is DD:name or file-name             */
/*                   RECFM=FB|VB|U, LRECL=any-allowed.                */
/*      TAGS(file) - input, optional, tags & its values,              */
/*                   RECFM=FB|VB|U, LRECL=any-allowed.                */
/*    OUTSQL(file) - output, optional, SQL w/o tags                   */
/*                   RECFM=FB, LRECL=80                               */
/*       LOG(file) - output, optional, a copy of sysout/SYSPRINT      */
/*                   RECFM=FBA,LRECL=any-allowed                      */
/*        SCAN(ON) - optional, just substitute tags, do not run SQL   */
/*      PRINT(OFF) - optional, do not print out input statements      */
/*                                                                    */
/* Output report:                                                     */
/*                                                                    */
/*     DD:SYSPRINT - RECFM=FBA,LRECL=any-allowed                      */
/*                   No page break, no partitions for select reports, */
/*                   no extra SQLCA fields, but                       */
/*                   CPU and TOTAL timings after each SQL statement.  */
/* Return Codes:                                                      */
/*             0 - program completed successfully                     */
/*             4 - warning(s) was issued                              */
/*             8 - syntax error                                       */
/*            12 - SQL error happened                                 */
/*            NN - various errors                                     */
/*                                                                    */
/* Functional commands:                                               */
/* -------------------                                                */
/* 1. WRITE Ýdlm¨ {FILE file } ÝAPPEND¨  {select-stmnt;           }   */
/*                {STACK DATA}           {DB2 -command; (zOS only)}   */
/*                {STACK LABEL labelÝ:¨} {DDL select-stmnt        }   */
/*                                       {ECHO text               }   */
/*                                                                    */
/*    Writes out a select|DB2|DDL report to a file or memory stack.   */
/*    Keyword 'dlm' specifies a column delimeter or file format:      */
/*     CSV   -- CSV format with fixed positions of commas, double     */
/*              quotes (") in data, if exist, are replaced with       */
/*              with single ones (')                                  */
/*     TAB   -- tab delimeter (x'\t')                                 */
/*     COMMA -- comma (',')                                           */
/*     BAR   -- vertcal bar ('|')                                     */
/*     NODLM -- without any delimeter                                 */
/*     ASIS  -- no delimeter, binary file, numbers are not converted  */
/*     RPT   -- full report with column names                         */
/*    Default 'dlm' is a blank.                                       */
/*    Keyword 'file' can be specified as DD:NAME or real file-name.   */
/*    APPEND allows to write data to the end of the existing file but */
/*    not to the existing PDS/PDSE member (zOS restriction).          */
/*    STACK tells the program to write data to unnamed DATA memory    */
/*    stack or to named by 'label' LABEL stack.                       */
/*                                                                    */
/* 2. READ Ýdlm¨ {FILE file1          } ÝDISCARD Ýfile2¨¨             */
/*               {STACK DATA          }                               */
/*               {STACK LABEL labelÝ:¨}                               */
/*       INSERT INTO ... VALUES(*|column-positions);                  */
/*                                                                    */
/*    (where dlm is same as WRITE dlm excluding RPT)                  */
/*    Read file1 records in and inserts them into a table.            */
/*    Keyword DISCARD allows to bypass records with wrong data and    */
/*    write them out to file2 (if specified).                         */
/*    Column positions specify data position for each column.         */
/*    Format is like the format of the LOAD utility, for example:     */
/*    VALUES(1.12,14:15,...)                                          */
/*    The VALUES(*) tells the program to find fields using dlm.       */
/*    STACK retrieves input from data memory stacks.                  */
/*                                                                    */
/* 3. STACK ÝLIFO          ¨ {select-stmnt;            }              */
/*          ÝFIFO          ¨ {DDL select-stmnt;        }              */
/*          ÝDATA          ¨ {DB2 -command; (zOS only) }              */
/*          ÝLABEL labelÝ:¨¨ {ECHO text;               }              */
/*                                                                    */
/*    The STACK saves output of the SELECT/DDL/DB2 clause in special  */
/*    memory stacks. The program reads stack LIFO as input at once,   */
/*    stack FIFO at the end of main input, stacks LABEL when          */
/*    specified labels found in input stream (max 50 stacks allowed). */
/*    Stack DATA is used as a temporary memory file.                  */
/*                                                                    */
/* 4. SAVE DATA AS table select-statement;                            */
/*                                                                    */
/*    It works as "INSERT INTO table select-statement".               */
/*    If the table is a SESSION one and it was not declared before    */
/*    the SESSION table is declared implicitly with fields used in    */
/*    a select-statement.                                             */
/*                                                                    */
/* 5. INCLUDE FILE file;                                              */
/*                                                                    */
/*    It adds additional SQL statements from a file to main input.    */
/*    Embedded INCLUDEs are not allowed for now.                      */
/*                                                                    */
/* 6. DDL ÝTABLE name¨ select-statement;                              */
/*                                                                    */
/*    It generates DDL for a session table based on a select stmnt:   */
/*        DECLARE GLOBAL TEMPORARY TABLE name (                       */
/*         column-definitions                                         */
/*        ) ON COMMIT PRESERVE ROWS;                                  */
/*    Default name is Tnn.                                            */
/*                                                                    */
/* 7. EXPLAIN sql-statement;  (only for z/OS, no PLAN_TABLE on AIX)   */
/*                                                                    */
/*    Prepares and displays EXPLAIN report for a given SQL statement. */
/*    You must have PLAN_TABLE under your user ID or set the current  */
/*    SQLID to an ID that has such table, for example:                */
/*       SET CURRENT SQLID='MDCT';                                    */
/*                                                                    */
/* 8. SYStem system-command;                                          */
/*                                                                    */
/*    Executes a given command (TSO,shell,...) by C-system() function.*/
/*    Use --#SET SYSRC nn if you need to suppress the nn code.        */
/*                                                                    */
/* 9. DB2 command; (AIX only)                                         */
/*                                                                    */
/*    Executes a given db2-command.                                   */
/*    It is the same as "SYSTEM DB2 command"                          */
/*                                                                    */
/* 10 DB2 -command (zOS only)                                         */
/*                                                                    */
/*    Executes a given -DB2command,not DSN one. By default DB2 prints */
/*    out a report to the SYSPRINT output. Use WRITE before DB2       */
/*    if you want to redirect its output to a file or data stack for  */
/*    further processing.                                             */
/*                                                                    */
/* 11 CONNECT TO location USER userid USING netrc-file                */
/*                                                                    */
/*    Executes CONNECT with the password taken from netrc-file.       */
/*    (DD:NETRC,'MDCV.PROD.PASSWORD(userid)',/home/userid/.netrc)     */
/*    'location' and 'userid' are case sensitive for search netrc-file*/
/*                                                                    */
/* 12 Conditional functional commands (where n=1-4):                  */
/*                                                                    */
/*  - RC=0|4|8;  -- reset the current RC                              */
/*  - RCn=RC;    -- save the current RC                               */
/*  - RCn=0|4|8; -- reset saved RCn                                   */
/*  - IF RCÝn¨=0|4|8 any-statement; -- run a statement when IF is true*/
/*  - IF SQLCODE=code any-statement; -- run a stment when IF is true  */
/*  - IF RCÝn¨=0|4|8  DO; any-statements; ENDIF;                      */
/*  - IF SQLCODE=code DO; any-statements; ENDIF;                      */
/*                                                                    */
/* 13 Terminating execution:                                          */
/*                                                                    */
/*  - END; -- stop processing of input and exit with current RC       */
/*  - EXIT m|RCÝn¨; -- exit with a given RC (m=0-8,n=1-4);            */
/*                                                                    */
/* 14 ECHO string;                                                    */
/*                                                                    */
/*    Display string. The command itself is not printed out.          */
/*    Can be used together with WRITE&READ STACK statements:          */
/*      WRITE STACK DATA ECHO string; -- put a string to data stack   */
/*      READ  STACK DATA ECHO Ýnn¨ Ýstring¨ -- read and print out     */
/*       'nn' records from data stack, 'string' here is a header.     */
/*       Default value for 'nn' is 32700.                             */
/*                                                                    */
/* 15 SAY message;                                                    */
/*                                                                    */
/*    Print out a message ignoring PRINT(OFF) parameter.              */
/*                                                                    */
/* 16. WHENEVER {SQLERROR  } {ROLLBACK;  } <-- (default)              */
/*              {SQLWARNING} {SUPPRESS;  }                            */
/*                           {CONTINUE;  }                            */
/*                           {GOTO label;}                            */
/*                                                                    */
/*    ROLLBACK -- exit with ROLLBACK after the 1st SQL error/warning. */
/*    CONTINUE -- print out messages and continue processing          */
/*    SUPPRESS -- do not print out error/warning messages             */
/*    GOTO label -- go forward to a label                             */
/*                                                                    */
/* 17. RUNSTATS TABLE table-name other-options; (FISHKILL,not DB2LAB) */
/*                                                                    */
/*    It needs the SYSPROC.DSNUTILS stored procedure started correctly*/
/*    It retrieves the need DB&TSnames from the SYSIBM.SYSTABLES table*/
/*    and insert them into RUNSTATS clause with TABLESPACE key-word.  */
/*                                                                    */
/* 18. SKIP labelÝ:¨                                                  */
/*     GOTO labelÝ:¨                                                  */
/*    Bypass input till label: starting in the column 1               */
/*                                                                    */
/* 19. DRAW COLNAMES table                                            */
/*                                                                    */
/*    Draw column names for a table. Use together with                */
/*      STACK LABEL label                                             */
/*    to redirect a column name list to the need select statement     */
/*    when a history table is copied to an odrinary one.              */
/*                                                                    */
/* 20. PRINT SQLERROR;                                                */
/*                                                                    */
/* Special comments:                                                  */
/* -----------------                                                  */
/*                                                                    */
/* --#SET SIGNPOS ON|OFF|NO (default ON)                              */
/*    OFF does not add a sign position for character numbers          */
/* --#SET EXCEL ON|OFF    (default ON)                                */
/*    ON indicates that input file was created by Excel(not fixed pos)*/
/* --#SET NULLCHAR Ýc|BLANK¨  (default '?')                           */
/*    Specifies a char for a NULL value in a SELECT report            */
/* --#SET LOADNULL ON|OFF (default OFF)                               */
/*    ON allows to interpret a NULLCHAR as a NULL for READ command    */
/* --#SET MULTIROWS nn    (default 100, valid range  1-32767)         */
/*    Specifies number of multi-rows for SELECT(WRITE) & INSERT(READ) */
/* --#SET NUMVARS nn      (default 256, valid range 50-32767)         */
/*    Specifies max number of columns in a table                      */
/* --#SET SYSRC nn        (default 4,   valid range  0-32   )         */
/*    Specifies max RC allowed from SYSTEM command                    */
/* --#SET SQLDLM c        (default ';')                               */
/* --#SET TERMINATOR c    (default ';')             (like DSNTEP2/4)  */
/*    Specifies a delimeter of statements in INSQL file               */
/* --#SET TRACE ON|OFF    (default OFF)                               */
/*    For internal use, display additional info for debugging         */
/* --#SET SCAN ON|OFF     (default OFF)                               */
/*    OFF -- do not run any statement, just substitute TAGs           */
/* --#SET PRINT ON|OFF    (default ON)                                */
/*    ON -- print out input statements, OFF -- do not print           */
/* --;                                                                */
/*    Remove from processing INSQL records beginning with '--;'       */
/*    Use the comment in the TAG file if you want to hide test stmnts.*/
/*    <TST>   --;    <-- to hide, do not print out the record         */
/*    <TST>   null   <-- to actvate                                   */
/* --!                                                                */
/*    Print out the line ignoring #SET PRINT OFF                      */
/* --#SET LABELS ON|OFF   (default ON)                                */
/*    ON -- treat the 'string:' starting at column 1 as a label,      */
/*          the rest of the input line is ignored.                    */
/*                                                                    */
/* The program can run any SQL statement that can be                  */
/* dynamically prepared (see IBM SQL Reference) plus some             */
/* additional statements:                                             */
/*                                                                    */
/*   CONNECT                                                          */
/*   CONNECT RESET                                                    */
/*   CONNECT TO location                                              */
/*   CONNECT TO location USER userid USING netrc-file                 */
/*   WHENEVER                                                         */
/*                                                                    */
/* A list of supported SQL Data Types:                                */
/*                                                                    */
/*     CHAR      VARCHAR     LONG VARCHAR                             */
/*     DECIMAL   SMALLINT    INTEGER      BIGINT                      */
/*     DATE      TIME        TIMESTAMP                                */
/*     FLOAT     FLOAT(n)    DOUBLE PRECISION                         */
/*     REAL      BINARY      VARBINARY                                */
/*     DECFLOAT(partly)                                               */
/*                                                                    */
/**********************************************************************/
/* SQLCA stucture:                                                    */
/* ----------------                                                   */
/*  struct sqlca                                                      */
/*    { unsigned  char     sqlcaidÝ8¨;                                */
/*                long     sqlcabc;                                   */
/*                long     sqlcode;                                   */
/*                short    sqlerrml;                                  */
/*      unsigned  char     sqlerrmcÝ70¨;                              */
/*      unsigned  char     sqlerrpÝ8¨;                                */
/*                long     sqlerrdÝ6¨;                                */
/*      unsigned  char     sqlwarnÝ11¨;                               */
/*      unsigned  char     sqlstateÝ5¨;                               */
/*    } ;                                                             */
/*  struct sqlca sqlca;                                               */
/*                                                                    */
/* SQLDA stuctures:                                                   */
/* +-------------------------------+                                  */
/* :struct sqlda                   :                                  */
/* :     { char   sqldaidÝ8¨;      :                                  */
/* :       long   sqldabc;         :                                  */
/* :       short  sqln;            :     For each column:             */
/* :       short  sqld;            :     +--------------------------+ */
/* :       struct sqlvar sqlvarÝ1¨;: --> :struct sqlvar             : */
/* :     };                        :     :   { short  sqltype;      : */
/* +-------------------------------+     :     short  sqllen;       : */
/* +---- not supported ------------+     :     char  *sqldata;      : */
/* :struct sqlvar2                 :     :     short *sqlind;       : */
/* :     { struct                  :     :     struct sqlname       : */
/* :       { long   sqllonglen;    :     :        { short  length;  : */
/* :       unsigned long reserved; :     :          char   dataÝ30¨;: */
/* :       } len;                  :     :        } sqlname;        : */
/* :       char  *sqldatalen;      :     :   };                     : */
/* :       struct sqldistinct_type :     +--------------------------+ */
/* :        { short  length;       :                                  */
/* :          char   dataÝ30¨;     :                                  */
/* :        } sqldatatype_name;    :                                  */
/* :     };                        :                                  */
/* +-------------------------------+                                  */
/**********************************************************************/
//
// Macros for brief coding:
// ------------------------
#define SQLERRD3    sqlca.sqlerrdÝ2¨
#define SQLERRM     sqlca.sqlerrmc
#define SQLERRL     sqlca.sqlerrml
#define SQLDAid     pSQLDA->sqldaid
#define SQLDAbc     pSQLDA->sqldabc
#define SQLn        pSQLDA->sqln
#define SQLd        pSQLDA->sqld
#define SQLTYPE(i)  pSQLDA->sqlvarÝi¨.sqltype
#define SQLDATA(i)  pSQLDA->sqlvarÝi¨.sqldata
#define SQLIND(i)   pSQLDA->sqlvarÝi¨.sqlind
#define SQLLEN(i)   pSQLDA->sqlvarÝi¨.sqllen
#define SQLNAMEL(i) pSQLDA->sqlvarÝi¨.sqlname.length
#define SQLNAMED(i) pSQLDA->sqlvarÝi¨.sqlname.data
//
// SQLTYPE values:
// ---------------
// Date,Time, Time stamp
#define   sDATE       384
#define   sDATEn      385
#define   sTIME       388
#define   sTIMEn      389
#define   sTIMESTAMP  392
#define   sTIMESTAMPn 393
// Binary LOB, Char LOB,
#define   sBLOB       404
#define   sBLOBn      405
#define   sCLOB       408
#define   sCLOBn      409
#define   sDBCLOB     412
#define   sDBCLOBn    413
// CHAR, Var CHAR, Long Var CHAR
#define   sVCHAR      448
#define   sVCHARn     449
#define   sCHAR       452
#define   sCHARn      453
#define   sLVCHAR     456
#define   sLVCHARn    457
// GRAPHIC  Var CHAR, Long
#define   sGVCHAR     464
#define   sGVCHARn    465
#define   sGCHAR      468
#define   sGCHARn     469
#define   sGLCHAR     472
#define   sGLCHARn    473
// FLOAT
#define   sFLOAT      480
#define   sFLOATn     481
// PACKED DECIMAL
#define   sDEC        484
#define   sDECn       485
// BIGINT                     // new in V9.1
#define   sBIGINT     492
#define   sBIGINTn    493
// INTEGER
#define   sINT        496
#define   sINTn       497
// SMALL INTEGER
#define   sSMINT      500
#define   sSMINTn     501
// ROWID
#define   sROWID      904
#define   sROWIDn     905
// VARBINARY                  // new in V9.1
#define   sVARBIN     908
#define   sVARBINn    909
// BINARY                     // new in V9.1
#define   sBIN        912
#define   sBINn       913
// BLOB LOCATOR
#define   sBLOBLOC    960
#define   sBLOBLOCn   961
// CLOB LOCATOR
#define   sCLOBLOC    964
#define   sCLOBLOCn   965
// DBCLOB LOCATOR
#define   sDBCLOBLOC  968
#define   sDBCLOBLOCn 969
// DECFLOAT(16)|(34)         // new in V9.1 (8,16)
#define   sDECFLOAT   996
#define   sDECFLOATn  997
// XML
#define   sXML        988
#define   sXMLn       989
//
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>
#include <search.h>
#include <errno.h>
#include <time.h>
#include <cfloat>
#include <limits>

using namespace std;

#define NO       0
#define OFF      0
#define ON       1
#define YES      1
#define EQUALS   0
#define Max(a,b) (((a)>(b)) ? (a) : (b))
#define min(a,b) (((a)>(b)) ? (b) : (a))
#define MAXSQLSIZE 32700
#define RETURN_LEN 80000               /* Length of IFI return buffer*/

/*****************************************************************/
/*                                                               */
/* Declaration of internal functions                             */
/*                                                               */
/*****************************************************************/

  void printHexChars(char* p, int n);
  void printSQLDA(void);
  void processSQLwarning(char * Msg);
  void processSQLerror(char * Msg);
  void processSQLCODE(char * Msg);
  void PrintSqlError(char * ErrorMsg);
 char* get_parm(int argc,char* argvÝ¨,
                char* skey, char* ekey, char* defvalue);
 char* strip(char *buf, char action);
 char* strNcpy(char* str1,char *str2, int sizeofstr1);
 char* findword(char* str, int n, int &outlen);
  void getwords(char* str,short n, char Upcase);
   int words(char* str);
double CPUtime(double t);
unsigned int TOTALtime(unsigned int t);
  void printCTM(void);
  void Exit(int rc);
   int freadbin(  char* fileName,  // IN:    DD:ddname/file name
                 FILE** fp,        // OUTIN: file pointer
                  char* buf,       // INOUT: buffer
                    int bufsize,   // IN:    number bytes to read
                   int* eof,       // OUT:   =1, if EOF
                  long* ctr,       // OUT:   record counter
                  char* msg ) ;    // OUT:   error message
   int fgetstr(   char* fileName,  // IN:    DD:ddname
                 FILE** fp,        // OUTIN: file pointer
                  char* buf,       // INOUT: buffer
                    int bufsize,   // IN:    sizeof(buf)
                   int* eof,       // OUT:   =1, if EOF
                  long* ctr,       // OUT:   record counter
                  char* msg );     // OUT:   error message
  void resetGlobalVariables(void) ;
  void LOAD_TAGS_ARRAY(void) ;
  void allocSQLDA(short n) ;
  void OPEN_INIT(int argc, char *argvÝ¨);
  void replaceTags(void) ;
  void PROCESS_FUNCTIONAL_SET(void);
 char* getFIFO(char *out) ;
 char* getLIFO(char *out) ;
 int   getLABEL(char *out) ;
 void  getIFDO(void);
  void READ_INPUT_LINE(void);
  void APPEND_INPUT_TO_STMNT(void);
 char* processEXEC()   ;
  void processCONNECT() ;
  void printCONNECTinfo();
 char* processSET()    ;
 char* processRELEASE() ;
 char* processWRITE(void)  ;
 char* processSAVE(void)  ;
 void  processDDL(void)  ;
 void  processINCLUDE(void)  ;
 char* processREAD(void)  ;
  void syntaxRWerror(short i) ;
   int checkSQLd(void) ;
  void describeINSERT(char *p) ;
 char* checkdigits(char *p);
  void parseVALUES(char *p);
 char* processEXPLAIN();
 char* processSTACK();
  void processEND(void);
  void processSAY(void);
  void processECHO(void);
 char* processIF(void);
  void processRC(void);
  void processEXIT(void);
  void processSYSTEM();
  void processDB2();
 short checkforLABEL();
  void PREPROCESS_SQL_STMNT(void);
  void parseColumnLength(void);
  void parseColumnNames(void);
  void openWRITE(void);
  void openDISCARD(void);
  long writeRecord(FILE *fp, char *fn, char *buf,
                   long *cnt,long lrecl);
  void outBUFrecord(void);
  void printDashes(char *po,struct COLNAME *pn);
  void printColumnNames(void);
   int checkint(char* p, short len, short maxn);
   int checkdatetime(char* p, short len);
   int checkfloat(char* p);
   int char2dec(char* sqldata,
                char* inbuf,  short inlen);
  void shift4bits(unsigned char *p,short len);
  void dec2char(char* sqldata,
                char* outbuf,  short outlen);
  void printC1rows(short n);
  void freeSQLDA(void);
  void allocSQLVARarrays(short n);
  void executeSELECT(void);
   int fillCOLPOSarray(char *ps);
  void loadSQLDATAarrays(void);
  long processDISCARDrows(long code);
  void executeSTATEMENT(void);
  void printHelpExplain(void);
  void POSTPROCESS_SQL_STMNT(void);
  void PROCESS_SQL_STMNT(void);
   int callIFI(char *);
 char* getIFIline(int i,char* out);
 void DsnUtilsClearParms();
 void callDsnUtils();
 void runStatsTableSpace
    ( char          *uId,
      char          *restart,
      char          *utStmt);
 void processRUNSTATS(void);
 void getDBTSnames(char* table);
 void processLOCK(void);
 void displyTSstatus(int);
 void processWHENEVER(void);
 void print904info(void);
 void print911info(void);
 void processSKIP(void);
 void processPRINT(void);
 void writeOUTSQLline(void);
short prepareSTACKlabel(char*);
short extractLABEL(char* str,short len, char* label);
 void strUXcpy(char*,char*,short);
short strPXcpy(char*,char*,short);

/*****************************************************************/
/*                                                               */
/* Declaration of the DB2 structures and cursors                 */
/*                                                               */
/*****************************************************************/


       EXEC SQL INCLUDE SQLCA;
       EXEC SQL INCLUDE SQLDA;

       EXEC SQL DECLARE STMNT1 STATEMENT;
       EXEC SQL DECLARE STMNT2 STATEMENT;

       EXEC SQL DECLARE C1 CURSOR
         WITH ROWSET POSITIONING
              FOR STMNT1;

       EXEC SQL DECLARE C2 CURSOR
              FOR STMNT2;
/*---------------------------------------------------------------*/
/* Host variables for DB2                                        */
/*---------------------------------------------------------------*/

struct sqlda *pSQLDA;

EXEC SQL BEGIN DECLARE SECTION;

struct {
   short Len;
   char  StrÝ32700¨;
} SQL;

struct {
   short Len;
   char  StrÝ32700¨;
} SELECT;

struct {
 short len;
  char dataÝ80¨;
} attr;

struct {
 short len;
  char strÝ17¨;
} password;

struct {
 short len;
  char strÝ17¨;
} userid;

//--------------------------------------------------------------//
// GET DIAGNOSTICS variables                                    //
//--------------------------------------------------------------//
           long iERROR;
           long nERROR;
           long row_count;
           long row_num;
          short multiRows=100,m1=1;

 short SCODE;
  char SMESSAGEÝ4095¨;
  char SSTATEÝ6¨;
 short TOKEN_COUNT;
  char TOKEN1Ý30¨;
  char TOKEN2Ý30¨;
  char TOKEN3Ý30¨;
  char server_classÝ51¨;
  char   product_idÝ11¨;
  char     locationÝ17¨;
  char       serverÝ17¨;
  char connect_infoÝ51¨;
  char ctmÝ28¨;

 //    EXEC SQL BEGIN DECLARE SECTION;
         char          uIdÝ17¨;        // Utility ID
         char          restartÝ9¨;     // Utility restart point
         char          utStmtÝ32705¨;  // Utility control statement
         long int      retCode;        // Highest retcode from utility
         char          utilityÝ21¨;    // Utility name
                                       // Data Definition: SYSREC
         char          recDsnÝ45¨;     // ..data set name
         char          recDevtÝ9¨;     // ..device type
         short int     recSpace;       // ..no. of cylinders (primary)
                                       // Data Definition: SYSDISC
         char          discDsnÝ45¨;    // ..data set name
         char          discDevtÝ9¨;    // ..device type
         short int     discSpace;      // ..no. of cylinders (primary)
                                       // Data Definition: SYSPUNCH
         char          pnchDsnÝ45¨;    // ..data set name
         char          pnchDevtÝ9¨;    // ..device type
         short int     pnchSpace;      // ..no. of cylinders (primary)
                                       // Data Definition: SYSCOPY
         char          copyDsn1Ý45¨;   // ..data set name
         char          copyDevt1Ý9¨;   // ..device type
         short int     copySpace1;     // ..no. of cylinders (primary)
                                       // Data Definition: SYSCOPY2
         char          copyDsn2Ý45¨;   // ..data set name
         char          copyDevt2Ý9¨;   // ..device type
         short int     copySpace2;     // ..no. of cylinders (primary)
                                       // Data Definition: SYSRCPY1
         char          rcpyDsn1Ý45¨;   // ..data set name
         char          rcpyDevt1Ý9¨;   // ..device type
         short int     rcpySpace1;     // ..no. of cylinders (primary)
                                       // Data Definition: SYSRCPY2
         char          rcpyDsn2Ý45¨;   // ..data set name
         char          rcpyDevt2Ý9¨;   // ..device type
         short int     rcpySpace2;     // ..no. of cylinders (primary)
                                       // Data Definition: SYSUT1
         char          workDsn1Ý45¨;   // ..data set name
         char          workDevt1Ý9¨;   // ..device type
         short int     workSpace1;     // ..no. of cylinders (primary)
                                       // Data Definition: SORTOUT
         char          workDsn2Ý45¨;   // ..data set name
         char          workDevt2Ý9¨;   // ..device type
         short int     workSpace2;     // ..no. of cylinders (primary)
                                       // Data Definition: SYSMAP
         char          mapDsnÝ45¨;     // ..data set name
         char          mapDevtÝ9¨;     // ..device type
         short int     mapSpace;       // ..no. of cylinders (primary)
                                       // Data Definition: SYSERR
         char          errDsnÝ45¨;     // ..data set name
         char          errDevtÝ9¨;     // ..device type
         short int     errSpace;       // ..no. of cylinders (primary)
                                       // Data Definition: FILTER
         char          filtrDsnÝ45¨;   // ..data set name
         char          filtrDevtÝ9¨;   // ..device type
         short int     filtrSpace;     // ..no. of cylinders (primary)

        static volatile SQL TYPE IS RESULT_SET_LOCATOR *DsnUtils_rs_loc;
        long int      seqNo;           // Sequence of row in result set
        struct                         // Data
        { short int length;            // ..length of data
          char      dataÝ254¨;         // ..data content
        }           text;
        char CREATORÝ25¨;
        char NAMEÝ25¨;
        char TSNAMEÝ25¨;
        char DBNAMEÝ25¨;

EXEC SQL END DECLARE SECTION;

const char   multistrÝ¨="FOR MULTIPLE ROWS ";
const char  notatomicÝ¨="NOT ATOMIC CONTINUE ON SQLEXCEPTION";
const char  deletestrÝ¨="DELETE FROM PLAN_TABLE WHERE QUERYNO=0";
const char explainstrÝ¨="EXPLAIN PLAN SET QUERYNO=0 FOR ";

const char selectPlanÝ¨=
    "SELECT"
        " DEC(PARENT_QBLOCKNO,3) PAR_BLK_NO"
        ",DEC(QBLOCKNO,3) QUE_BLK_NO"
        ",DEC(PLANNO,3) QUE_Run_Ord"
        ",QBLOCK_TYPE QUERY_BLOCK_TYPE"
        ",DEC(METHOD,1) Join_Mthd"
        ",ACCESSTYPE    Acc_Type"
        ",DEC(TABNO,3)  TBL_No"
        ",TABLE_TYPE TBL_TYP"
        ",CAST(A.CREATOR AS CHAR(08)) Table_Owner"
        ",CAST(A.TNAME   AS CHAR(25)) Table_Name"
        ",DEC(B.CARDF,8)  CATALOG_TABLE_CARDF"
        ",CAST(ACCESSNAME AS CHAR(12))  Used_Index"
        ",CASE WHEN C.COLCOUNT IS NOT NULL THEN INDEXONLY"
        " ELSE NULL END AS I_O"
        ",DEC(C.COLCOUNT,3) Total_Index_Cols"
        ",CASE WHEN C.COLCOUNT IS NOT NULL THEN DEC(MATCHCOLS,2)"
        " ELSE NULL END AS Used_Index_Cols"
        ",DEC(MERGE_JOIN_COLS,3) MERGE_JOIN_COLS"
        ",DEC(C.FIRSTKEYCARDF,8) FIRST_KEY_CARDF"
        ",DEC(C.FULLKEYCARDF,8) FULL_KEY_CARDF"
        ",C.UNIQUERULE INDEX_UNIQ_RULE"
        ",TSLOCKMODE TS_LOCK_MODE "
    "FROM PLAN_TABLE A "
    "LEFT JOIN SYSIBM.SYSTABLES B "
      "ON A.CREATOR = B.CREATOR "
     "AND A.TNAME = B.NAME "
    "LEFT JOIN SYSIBM.SYSINDEXES C "
      "ON A.CREATOR = C.TBCREATOR "
     "AND A.TNAME = C.TBNAME "
     "AND A.ACCESSNAME = C.NAME "
   "WHERE QUERYNO=0 "
   "ORDER BY QBLOCKNO,PLANNO" ;

const char cmdDIStmplÝ¨="-DIS DATABASE(%s) SPACENAM(%s) LIMIT(*) LOCKS";
const char cmdDIS911Ý¨ ="-DIS DB(*) SPACE(*) LIMIT(*) LOCKS ONLY";
const char cmdDIS904AÝ¨="-DIS DB(DSNDB07) SPACE(*) LIMIT(*) USE ONLY";
char cmdDISÝ250¨;
const char cmdRUNSTATStmplÝ¨="RUNSTATS TABLESPACE %s.%s TABLE(%s) %s";
//--------------------------------------------------------------//
// Column structures                                            //
//--------------------------------------------------------------//
struct COLNAME {        // for each SQLNAME
  char  sqlnameÝ31¨;    //  original SQLNAME
 short  parts;          //  number of parts
  char *partptrÝ15¨;    //  array of part pointers
 short  partlenÝ15¨;    //  array of part lengths
 short  partmaxlen;     //  max part len
 short  width;          //  width of column
} *pCOLNAME=NULL;

 short colines;         // max part number

struct COLDATA {        // for each SQLVAR
 short  type;           //  original SQLTYPE
 short  len;            //  original SQLLEN
 short  clen;           //  char length
 short  width;          //  width of column
  char  align;          //  report alignment
} *pCOLDATA=NULL;

 short datalen=0;       // sum of widths

struct COLPOS {         // for each VALUES position (READ)
  char sqlnameÝ31¨;     //  original SQLNAME
  char posstrÝ21¨;      //  p1:p2 or p1.l1 or f1
  char fflag;           //  f-flag for fn fields
  char pos1Ý7¨;         //  p1
  char pos2Ý7¨;         //  p2 or l1
 short start;           //  p1
 short len;             //  l1
  char dlm;             //  '.' or ':'
 short mlen;            //  width of column
} *pCOLPOS;

 short maxpos=0;        // sum of mlen
 short fixposFlag;      // ON if not '*'

//--------------------------------------------------------------//
// FILE declarations                                            //
//--------------------------------------------------------------//
char  fnINSQLÝ100¨;
FILE  *fpINSQL = NULL;
int   eofINSQL;
char  BUFÝ32767¨;
char  *pBUF=NULL;
long  cntINPUT  = 0;

char  fnOUTSQLÝ100¨;
FILE  *fpOUTSQL = NULL;
char  buf81Ý81¨;

char  fnTAGSÝ100¨="\0";
FILE  *fpTAGS = NULL;
int   eofTAGS = 0;
long  cntTAGS = 0;

FILE  *fpwTAGS  = NULL;
long  rowsTAGS  = 0;

char  fnLOGÝ100¨="\0";
FILE  *fpLOG = NULL;

FILE  *fpWRITE = NULL;
char  fnWRITEÝ100¨;
char  modeMVSabÝ¨="ab,type=record,recfm=fb,lrecl=%d,blksize=0";
char  modeMVSaÝ¨="a,recfm=fb,lrecl=%d,blksize=0";
char  modeMVSwbÝ¨="wb,type=record,recfm=fb,lrecl=%d,blksize=0";
char  modeMVSwÝ¨="w,recfm=fb,lrecl=%d,blksize=0";
int   lreclWRITE=0;
long  cntWRITE=0;

FILE  *fpREAD = NULL;
char  fnREADÝ100¨;
int   lreclREAD=0;
long  cntREAD=0;
int   eofREAD=0;
long  totalSQLERRD3=0;

FILE  *fpDISCARD = NULL;
char  fnDISCARDÝ100¨;
long  cntDISCARD=0;

FILE  *fpNETRC = NULL;
char  fnNETRCÝ100¨;
int   lreclNETRC=0;
long  cntNETRC=0;
int   eofNETRC=0;

FILE  *fpINCLUDE = NULL;
char  fnINCLUDEÝ100¨;
long  cntINCLUDE=0;
int   eofINCLUDE=YES;

char  outBUFÝ32767¨;

//--------------------------------------------------------------//
// #SET variables                                               //
//--------------------------------------------------------------//
short trace=OFF;
short testFlag=OFF;
short printFlag=ON;
short scanFlag=OFF;
short signposFlag=ON;
short hold_signposFlag=ON;
short excelFlag=ON;
short labelFlag=ON;
short multiRows_save;
short readRows=0;
short builtRows=0;
char  sqldlmÝ2¨=";";
char  nullchar='?';
char  hold_nullchar=' ';
short loadnullFlag=OFF;
short numvars = 256;
short sysrc = 4;

//--------------------------------------------------------------//
// Timings variables                                            //
//--------------------------------------------------------------//
unsigned int tottime2, tottimeall2;
unsigned int tottime1, tottimeall;
double cputime1, cputimeall;

//--------------------------------------------------------------//
// Program actions                                              //
//--------------------------------------------------------------//
short action;
#define actSQL          0
#define actREAD         1
#define actWRITE        2
#define actSTACK        3
// Flags
short  newSTMNT=NO;
short  doneSTMNT=NO;
short  fCSV=NO,fASIS=NO,fRPT=NO,fLIFO=NO,fFIFO=NO,fDATA=NO,fEXPLAIN=NO,
       fDISCARD=NO,fDISCARDfn=NO,fAPPEND=NO,fLOCK=NO,fLABEL=NO,
       fECHO=NO;
char fSQLERROR='R',fSQLWARNING='R';
//--------------------------------------------------------------//
// Parsing variables                                            //
//--------------------------------------------------------------//
struct WORD {
  char strÝ251¨;
  char *ptr;
 short len;
} wordÝ7¨;

char  word1Ý251¨;
char  word2Ý251¨;
char  word3Ý251¨;
int   nwords=0;

//--------------------------------------------------------------//
// STACK  variables                                             //
//--------------------------------------------------------------//
struct stack {
    struct stack *next;
    short int len;
    char   dataÝ1¨;
};
struct stack *pstackFIFO  = NULL;
struct stack *pstackLIFO  = NULL;
struct stack *pstackDATA  = NULL;
struct stack *pstackIFDO  = NULL;
struct stack *pstackLABEL = NULL;
struct stack *plastFIFO   = (struct stack *) &pstackFIFO;
struct stack *plastLIFO   = (struct stack *) &pstackLIFO;
struct stack *plastDATA   = (struct stack *) &pstackDATA;
struct stack *plastLABEL  = (struct stack *) &pstackLABEL;
 short eofFIFO=YES,eofLIFO=YES,eofDATA=YES,eofLABEL=YES;
  char  skipLABELÝ22¨="\0";
  char  stackLABELÝ22¨="\0";
  char  sqlerrorLABELÝ22¨="\0";
  char  sqlwarningLABELÝ22¨="\0";

struct entryLABEL {
 struct stack *pfirst;
 struct stack *plast;
   char labelÝsizeof(stackLABEL)¨;
};
 const short numLABEL=50;
entryLABEL arrayLABELÝnumLABEL¨;
 short foundstackLABEL=NO;
 short indexLABEL;
//--------------------------------------------------------------//
// IFDO   variables                                             //
//--------------------------------------------------------------//
struct cache {
    struct cache *back;
    char   flagÝ2¨;                 // 'Y'- active 'N' - nonactive
    short  cntIF;                   // counter of internal false IF
};
struct cache *pcacheIFDO = NULL;
struct cache *plastIFDO = (struct cache *) &pcacheIFDO;

//--------------------------------------------------------------//
// Mixed   variables                                            //
//--------------------------------------------------------------//
char   pgmnameÝ100¨;
int    i=0,n=0,sessionNo=1;
int    rc=0,RC=0,RC1=0,RC2=0,RC3=0,RC4=0;
char   msgÝ133¨;
short  eofC1=NO;
short  parmUpper=NO;
long   rowsC1=0;
char   dlmÝ2¨;
char   saveTABLEÝ31¨;
unsigned short prec,scale,memory;
short  fCTM=1;
long int code;

//-------------------------------------------------------------------//
//  IFCA - (Instrumentation Facility Communication Area) contains    //
//         information regarding the success of the call to IFI and  //
//         provides feedback information to the application program. //
//                                                                   //
//  WARNING: This area must be maintained to include any changes to  //
//           the mapping macro DSNDIFCA.                             //
//-------------------------------------------------------------------//
typedef struct {                       /* Second parm for IFI call   */
     short int   len;                  /* Length of the IFCA,        */
                                       /*  including length field    */
     short int   unused1;              /* Reserved                   */
     char        eye_catcherÝ4¨;       /* Valid eye catcher of IFCA  */
                                       /*  used to verify IFCA block */
     char        owner_idÝ4¨;          /* Used to establish ownership*/
                                       /*  of an OPN destination     */
     long int    rc;                   /* Rtrn code for IFC API call */
     long int    reason;               /* Reason cd for IFC API call */
     long int    gotten_bytes;         /* Bytes of recrd rtrnd by IFI*/
     long int    lost_bytes;           /* Bytes that did not fit     */
     long int    opn_writ_seq_num;     /* Last OPN writer sequ numbr */
                                       /*  rtrnd for a READA function*/
     long int    num_recds_lost;       /* Records lost indicator     */
     char        opn_name_for_readaÝ4¨;/* OPN nm used for READA requ */
     struct {                          /* Area with up to 8 OPN names*/
       short int   opn_len;            /* Length+4 of OPN names rtrnd*/
       short int   unused2;            /* Reserved                   */
       char        array_opn_namesÝ4¨Ý8¨;
                                       /* Area for OPN names returned*/
     }           opn_names_area;
     struct {                          /* Area with up to 8 trace nos*/
       short int   trace_len;          /* Length+4 of trace nos rtrnd*/
       short int   unused3;            /* Reserved                   */
       char        array_trace_nosÝ2¨Ý8¨;
                                       /* Area for trace nos returned*/
     }           trace_nos_area;
     struct {                          /* Diagnosticd area           */
       short int diagnos_len;          /* Diagnostics length         */
       short int unused4;              /* Reserved                   */
       char diagnos_dataÝ80¨;          /* Diagnostics data           */
     }           diagnos_area;
   }           ifca;                   /****** end IFCA typedef ******/

   ifca        *pi=NULL;               /* Pointer to IFCA structure  */

typedef struct {                       /* Third parm for IFI call    */
     short int   len;                  /* Length+4 of text or command*/
     short int   unused;               /* Reserved                   */
     char        commandÝ254¨;         /* Actual command             */
     }         command_area;

   command_area *po=NULL;              /* Pointer to IFI output area */

typedef struct {                       /* Fourth parm for IFI call   */
     long int    len; ;                /* Length+4 of IFI return area*/
     char        reportÝRETURN_LEN¨;   /* IFI return area            */
     }         return_area;

   return_area *pr=NULL;               /* Pointer to IFI return area */
#if defined(__MVS__)
extern "OS" short int dsnwli(char*,ifca*,return_area*,command_area*);
#endif
/**********************************************************************/
/*                                                                    */
/*                       Internal functions                           */
/*                                                                    */
/**********************************************************************/
/*********************************************************************\
|
|  Xprintf() -- Put a text into the LOG and SYSPRINT files
|
\*********************************************************************/
void Xprintf(char *fmt, ...)
{
   va_list arg_ptr;
   va_start(arg_ptr, fmt);
   vsprintf(msg, fmt, arg_ptr);
   va_end(arg_ptr);
   if ((printFlag) || (strncmp(msg,"--!",3)==EQUALS)) {
    printf("%s",msg);
    fflush(stdout);
   }
   if (fpLOG) fprintf(fpLOG,"%s",msg);
}
/*********************************************************************\
|
|  printHexChars() -- for test only
|
\*********************************************************************/
void printHexChars(char* p, int n) {                            // $fnc$
 int i;
 char hexÝ4¨="\0\0\0";
 char outÝ3¨;
 unsigned char byte;
 for (i=0;i<n;i++) {
  byte=pÝi¨;
  sprintf(hex,"0%x",byte);
  if (strlen(hex)>2) memcpy(&out,&hexÝ1¨,3);
  else strcpy(out,hex);
  Xprintf("%s ",out);
 }
}
/*********************************************************************\
|
|  strPXcpy() -- pack two chars to one byte
|
\*********************************************************************/
 short strPXcpy(char* po,char* pi,short n) {
  char chexÝ17¨="0123456789ABCDEF";
  char hexÝ17¨={0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
                0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F};
 unsigned char byte,out,out1,out2;
  char *p;
  short i,j=0;
 for (i=0;i<n;i=i+2) {
// f0
  byte=toupper(piÝi¨);
  p=strchr(chex,byte);
  if (p==NULL) return(1);
  out1=hexÝp-chex¨;
  out=out1<<4;
// 0f
  if ((i+1)==n) {poÝj++¨=out;return(0);}
  byte=toupper(piÝi+1¨);
  p=strchr(chex,byte);
  if (p==NULL) return(1);
  out1=hexÝp-chex¨;
  out2=out|out1;
  poÝj++¨=out2;
 }
 return(0);
}
/*********************************************************************\
|
|  strUXcpy() -- unpack one byte to two chars
|
\*********************************************************************/
 void strUXcpy(char* po,char* pi,short n) {
 short i;
 char hexÝ4¨="\0\0\0";
 unsigned char byte;

 for (i=0;i<n;i++) {
  byte=piÝi¨;
  sprintf(hex,"0%X",byte);
  if (strlen(hex)>2) memcpy(&poÝi*2¨,&hexÝ1¨,2);
  else memcpy(&poÝi*2¨,&hexÝ0¨,2);
 }
}
/*********************************************************************\
|
|  parseDecSQLLEN() -- parse decimal SQLLEN(i)
|
\*********************************************************************/
void parseDecSQLLEN(int i) {
       prec=(short)(((char *)&SQLLEN(i))Ý0¨);
      scale=(short)(((char *)&SQLLEN(i))Ý1¨);
      memory=prec/2+1;
}
/*********************************************************************\
|
|  printSQLDA() -- Print SQLDA fields (test only)
|
\*********************************************************************/
void printSQLDA(void) {                                         // $fnc$
 int i;
 char nameÝ31¨;
          Xprintf(" SQLDAID=%-6s, SQLDABC=%d, SQLN=%d, SQLD=%d\n",
                     SQLDAid,      SQLDAbc,    SQLn,    SQLd);
 for (i=0;i<SQLd;i++) {
  memset(name,'\0',sizeof(name));
  strncpy(name,SQLNAMED(i),SQLNAMEL(i));
                  Xprintf(" SQLVARÝ%d¨.SQLNAME.LEN=%d\n",i,SQLNAMEL(i));
                  Xprintf(" SQLVARÝ%d¨.SQLNAME.DATA='%s'\n",i,name);
                  Xprintf(" hex SQLNAME(%d)=",i);
                  printHexChars(SQLNAMED(i),8);
                  Xprintf("\n");
                  Xprintf(" SQLVARÝ%d¨.SQLTYPE=%d\n",i,SQLTYPE(i));
  if ((SQLTYPE(i)==484)||(SQLTYPE(i)==485)) {
                  parseDecSQLLEN(i);
                  Xprintf(" SQLVARÝ%d¨.SQLLEN=%d.%d\n",i,prec,scale);
  } else          Xprintf(" SQLVARÝ%d¨.SQLLEN=%d\n",i,SQLLEN(i));
  if (SQLDATA(i)) Xprintf(" SQLVARÝ%d¨.SQLDATA=%x\n",i,SQLDATA(i));
  else            Xprintf(" SQLVARÝ%d¨.SQLDATA=NULL\n");
  if (SQLIND(i))  Xprintf(" SQLVARÝ%d¨.SQLIND=%x\n",i,SQLIND(i));
  else            Xprintf(" SQLVARÝ%d¨.SQLIND=NULL\n");
                  Xprintf(" \n");
 }
}
/*********************************************************************\
|
|  processSQLCODE() -- process SQLCODE
|
\*********************************************************************/
void processSQLCODE(char * Msg) {                               // $fnc$
   code=SQLCODE;
   if (SQLCODE==100) return;
   if (SQLCODE>0) processSQLwarning(Msg);
   else           processSQLerror(Msg);
   return;
}
/*********************************************************************\
|
|  processSQLerror() -- process SQL errors
|
\*********************************************************************/
void processSQLerror(char * ErrorMsg) {                         // $fnc$
 code=SQLCODE;
 doneSTMNT=YES;
 RC=8;
 // WHENEVER SQLERROR ROLLBACK
 if (fSQLERROR=='R') {PrintSqlError(ErrorMsg);Exit(12);}
 // WHENEVER SQLERROR CONTINUE
 if (fSQLERROR=='C') {PrintSqlError(ErrorMsg);return;}
 Xprintf("*** SQLCODE=%d, RC=%d\n",code,RC);
 // WHENEVER SQLERROR SUPPRESS
 if (fSQLERROR=='S') return;
 // WHENEVER SQLERROR GOTO
 if (fSQLERROR=='G') {
    strcpy(skipLABEL,sqlerrorLABEL);
    Xprintf("*** GOTO %s\n",skipLABEL);
 }
 return;
}
/*********************************************************************\
|
|  processSQLwarning() -- process SQL warnings
|
\*********************************************************************/
void processSQLwarning(char * WarnMsg) {                        // $fnc$

   if (SQLCODE==100) return;
   if (SQLCODE== 98) return;    // SQL STATEMENT ENDS WITH A SEMICOLON
   if (SQLCODE==562) return;    // A GRANT WAS IGNORED BECAUSE EXISTS
 //if (SQLCODE== 12) return;    // THE UNQUALIFIED COLUMN NAME
                                // WAS INTERPRETED AS   COR REF
 //if (SQLCODE==445) return;    // VALUE value HAS BEEN TRUNCATED
 // WHENEVER SQLWARNING SUPPRESS
 if (fSQLWARNING=='S') {SQLCODE=0;return;}
 RC=8;
 // WHENEVER SQLWARNING CONTINUE
   if (fSQLWARNING=='C') {PrintSqlError(WarnMsg);return;}
 // WHENEVER SQLWARNING GOTO
 if (fSQLWARNING=='G') {
    Xprintf("*** SQLCODE=%d, RC=%d\n",SQLCODE,RC);
    strcpy(skipLABEL,sqlwarningLABEL);
    Xprintf("*** GOTO %s\n",skipLABEL);
 }
 // WHENEVER SQLWARNING ROLLBACK
 if (fSQLWARNING=='R') {PrintSqlError(WarnMsg);Exit(12);}
 return;
}
/*********************************************************************\
|
|  PrintSqlError(): Print SQL error messages
|
\*********************************************************************/
       void PrintSqlError(char * ErrorMsg) {
       char msgÝ66¨, *p;
       int i,j,m,k=0;

       EXEC SQL GET DIAGNOSTICS :nERROR = NUMBER;
       if ((nERROR==0)&&(SQLCODE!=0)) { // -805 here!!!
         Xprintf(" \n");
         Xprintf("*** DB2error(s) on %s:\n",ErrorMsg);
         Xprintf("*** SQLCODE = %d\n",SQLCODE);
         SQLERRMÝSQLERRL¨='\0';
         Xprintf("*** SQLERRM = %s\n",SQLERRM);
         return;
       }
       if (nERROR==1) m=1; else m=2;
       for (iERROR=nERROR;iERROR>=m;iERROR--){
          memset(SMESSAGE,'\0',sizeof(SMESSAGE)); row_num=0;
          EXEC SQL GET DIAGNOSTICS CONDITION :iERROR
                         :SMESSAGE = MESSAGE_TEXT
                        ,:SCODE = DB2_RETURNED_SQLCODE
                        ,:SSTATE = RETURNED_SQLSTATE
                        ,:row_num     = DB2_ROW_NUMBER
                        ,:TOKEN_COUNT = DB2_TOKEN_COUNT
                        ,:TOKEN1 = DB2_ORDINAL_TOKEN_1
                        ,:TOKEN2 = DB2_ORDINAL_TOKEN_2
                        ,:TOKEN3 = DB2_ORDINAL_TOKEN_3
                         ;
        if (SCODE==100) continue;
        if ((SCODE>0)&&(fSQLWARNING=='S')) continue;
        if (k==0) Xprintf("\n *DB2error(s) on %s:\n",ErrorMsg);
        Xprintf(" *DB2error#%d* SQLCODE = %+d",++k,SCODE);
        if ((action==actREAD)&&(row_num>0))
        Xprintf(", row_number = %d\n",totalSQLERRD3+row_num);
        else if (row_num>0)
        Xprintf(", row_number = %d\n",row_num);
        else Xprintf("\n");

        for (i=0;i<strlen(SMESSAGE);i=i+strlen(msg)) {
         if (SMESSAGEÝi¨==' ') i++;
         p=SMESSAGE+i+min(sizeof(msg)-1,strlen(SMESSAGE+i));
         for (j=0;(j<40)&&(pÝ-j¨!='\0')&&(pÝ-j¨!=' ');j++);
          memset(msg,'\0',sizeof(msg));
          strncpy(msg,SMESSAGE+i,sizeof(msg)-1-j);
          if (i==0) Xprintf(" *DB2error#%d* %s\n",k,msg);
          else Xprintf("              %s\n",msg);
        } // for i
        Xprintf(" *DB2error#%d* SQLSTATE = %s\n",k,SSTATE);
        if (SCODE==-904) print904info();
        if (SCODE==-911) print911info();
        Xprintf(" \n");
       } // for iERROR
       }

/*********************************************************************\
|
| print904info() -- print out DB&TS status
|
\*********************************************************************/
void print904info(void) {
#if defined(__MVS__)
 short rc;
 char *p;
   if ((TOKEN_COUNT==3) &&
       (strcmp(TOKEN2,"00000200")==EQUALS) &&
       ((p=strchr(TOKEN3,'.'))!=NULL)) {

    memset(DBNAME,'\0',sizeof(DBNAME));
    memset(TSNAME,'\0',sizeof(TSNAME));
    strncpy(DBNAME,TOKEN3,p-TOKEN3);
    strcpy(TSNAME,p+1);
    sprintf(cmdDIS,cmdDIStmpl,DBNAME,TSNAME);
    Xprintf("*** %s\n",cmdDIS);
    rc=callIFI(cmdDIS);
    displyTSstatus(SCODE);
    return;
   }
   if ( (strcmp(TOKEN1,"00C90084")==EQUALS) &&
        (strcmp(TOKEN2,"00000100")==EQUALS) &&
        (strcmp(TOKEN3,"DSNDB07")==EQUALS) ) {
     strcpy(cmdDIS,cmdDIS904A);
     Xprintf("*** %s\n",cmdDIS);
     rc=callIFI(cmdDIS);
     displyTSstatus(SCODE);
     return;
   }
   print911info();
#endif
}
/*********************************************************************\
|
| print911info() -- print out DB&TS status
|
\*********************************************************************/
void print911info(void) {
#if defined(__MVS__)
 short rc;
   strcpy(cmdDIS,cmdDIS911);
   Xprintf("*** %s\n",cmdDIS);
   rc=callIFI(cmdDIS);
   displyTSstatus(SCODE);
#endif
}
/*********************************************************************\
|
|  get_parm(): Get a program parameter between skey & ekey
|
\*********************************************************************/
char* get_parm(int argc,char* argvÝ¨,                           // $fnc$
               char* skey, char* ekey, char* defvalue)          // $fnc$
{
    char *s,*e;
    int i,k,l;

    if (parmUpper==NO) {
     for (i=1;i<argc;i++) {
      strcpy(wordÝi¨.str,argvÝi¨);
      l=strlen(wordÝi¨.str);
      for (k=0;(k<l)&&(wordÝi¨.strÝk¨!='(');k++)
      { wordÝi¨.strÝk¨=toupper(wordÝi¨.strÝk¨); }
     }
     parmUpper=YES;
    }
    for (i=1;i<argc;i++) {
     s = strstr(wordÝi¨.str,skey);
     if (s!=NULL) {
      s = s + strlen(skey);
      e = strstr(s,ekey);
      if (e!=NULL) {
       eÝ0¨='\0';
       return(s);
      }
     }
    }
    return(defvalue);
}
/*********************************************************************\
|
|  strip() -- Strip leading or/and trailing blanks
|
\*********************************************************************/
char*  strip(char *buf, char action)                            // $fnc$
 {
    int i=0;
    int j=0;
    if ((buf == NULL) || (strlen(buf)==0)) return(buf);

    // Leading or Both
    if ((action == 'L') || (action == 'B'))
    {
      for (j=0; ( ((*(buf+j) == ' ')||(*(buf+j) == '\t'))
                   && (j<strlen(buf)) ); j++)
      {
      }
    }
    // Trailing or Both
    if ((action == 'T') || (action == 'B'))
    {
      for (i=strlen(buf)-1;
           ((*(buf+i) == ' ' ) ||
            (*(buf+i) == '\n') ||
            (*(buf+i) == '\t') ||
            (*(buf+i) == '\0')) && (i>=0); i--)
      {
        *(buf+i) = '\0';
      }
    }
    for (i=j;i<strlen(buf);i++)
      { if ((*(buf+i) == '\n') || (*(buf+i) == '\t')) bufÝi¨=' '; }

    return(buf+j);
 }
/*********************************************************************\
|
|  strNcpy() = strncpy() + traling blanks
|
\*********************************************************************/
char*  strNcpy(char* str1,char *str2, int sizeofstr1)           // $fnc$
 {
    int i;
    if (sizeofstr1 < 2) return(NULL);

    strncpy(str1, str2, sizeofstr1-1);
    str1Ýsizeofstr1-1¨ = '\0';

    for (i=0; i < strlen(str1); i++)
    {
      if (str1Ýi¨ == '\n')
        str1Ýi¨=' ';
    }
    for (i=strlen(str1); i < sizeofstr1-1; i++)
    {
        str1Ýi¨=' ';
    }
    return(str1);
 }
/*********************************************************************\
|
|  findword() -- returns an 'nth' word and its length
|
\*********************************************************************/
 char*  findword(char* str, int n, int &outlen)                 // $fnc$
 {
   int i=0,l=0,nn=0;
   char *s,*e;

    outlen=0;
    l=strlen(str);

    if ((str==NULL) || (n==0) || (l==0)) return(NULL);

    do {
      // Bypass leading blanks
      for (i=i+outlen; ((i<l) && (strÝi¨==' ')); i++);
      // Check for a blank str or word
      if (i>=l) {
       outlen=0;
       return(NULL);
      }
      // A word found
      nn++;                      // word number
      s=str+i;                   // ptr to word
      e=strchr(s,' ');           // find the word end(next blank)
      if (e==NULL) e=str+l;      // if end of str found
      outlen=e-s;               // length=end-start
      // return if the need word found
      if (nn==n) return(s);
    } while(i<l);

    return(NULL);
 }
/*********************************************************************\
|
|  getwords() -- parse a string and populate the struct wordÝ7¨ array
|
\*********************************************************************/
 void  getwords(char* str,short n, char Upcase)                 // $fnc$
 {
    int i,k,nn=min(n,7),j=0;

    memset(word,'\0',sizeof(word));        // null the array
    for (i=0;i<nn;i++) {
      while (strÝj¨==' ') {j++;}           // Bypass leading blanks
      if (strÝj¨=='\0') return;            // no more words
      wordÝi¨.ptr=&strÝj¨;                 // start of a word
      while ((strÝj¨!=' ')&&(strÝj¨!='\0')) {j++;} // find the end
      wordÝi¨.len=&strÝj¨-wordÝi¨.ptr;     // length of the word
      strncpy(wordÝi¨.str,wordÝi¨.ptr,     // copy it to str
//      min(sizeof(WORD::str)-1,wordÝi¨.len));
        min(sizeof(wordÝi¨.str)-1,wordÝi¨.len));
      if (Upcase=='U')
      for (k=0;k<strlen(wordÝi¨.str);k++)
       wordÝi¨.strÝk¨=toupper(wordÝi¨.strÝk¨);
    }

 }
/*********************************************************************\
|
|  words() -- returns the number of blank-delimited words in string
|
\*********************************************************************/
 int words(char* str)                                           // $fnc$
 {
   int i=0,l=0,n=0,wordlen=0;
   char *s,*e;

    l=strlen(str);
    if ((str==NULL) || (l==0)) return(0);

    do {
                                 // Bypass leading blanks
      for (i=i+wordlen; ((i<l) && (strÝi¨==' ')); i++);
      if (i>=l) return(n);       // return if next word not found
      n++;                       // word number
      s=str+i;                   // ptr to word
      e=strchr(s,' ');           // find the word end(next blank)
      if (e==NULL) e=str+l;      // if end of str found
      wordlen=e-s;               // length=end-start
    } while(i<l);

    return(n);
 }
/*********************************************************************\
|
|  CPUtime(): Get CPU time
|
\*********************************************************************/
double CPUtime(double t) {                                      // $fnc$
    if (t == 0) return ((double) clock() / CLOCKS_PER_SEC);
    return ( ( ((double) clock()) / CLOCKS_PER_SEC ) - t );
}
/*********************************************************************\
|
|  TOTALtime() : Get TOTAL time
|
\*********************************************************************/
unsigned int TOTALtime(unsigned int t) {                        // $fnc$
    if (t == 0) return ((unsigned int) time(NULL) );
    return ( ((unsigned int) time(NULL)) - t );
}
/*********************************************************************\
|
|  printCTM() : Print current timestamp
|
\*********************************************************************/
void printCTM(void) {                                           // $fnc$
    if (fCTM==NO) return;
    EXEC SQL SET :ctm = CURRENT TIMESTAMP;
    if (SQLCODE==0)
    Xprintf("+++ Current TimeStamp = %s\n",ctm);
    else { fCTM=NO;
#if defined(__MVS__)
    processSQLerror("CURRENT TIMESTAMP"); Exit(12);
#else
    SQLCODE=0;
#endif
    }
    return;
}
/*********************************************************************\
|
|  printTotalTimings()
|
\*********************************************************************/
void printTotalTimings() {
    printCTM();
    Xprintf("+++ End of %s, RC=%d\n",pgmname,RC);
    Xprintf("+++ CPU time = %.4f seconds, TOTAL time = %d seconds \n",
               CPUtime(cputimeall),TOTALtime(tottimeall));
}
/*********************************************************************\
|
|  Exit() : Program's exit
|
\*********************************************************************/
void Exit(int rc) {                                             // $fnc$
    if (trace) Xprintf("*** Exit: SQLCODE=%d, rc=%d\n",SQLCODE,rc);
    if (rc>4) {
     if (rc==999) Xprintf(" \n*ERROR* Memory out\n ");
     SQLCODE=0;
     EXEC SQL ROLLBACK;
     if (SQLCODE==0)
          Xprintf("\n \n*** R O L L B A C K successful ***\n \n");
     else Xprintf("\n \n*** ROLLBACK failed, sqlcode=%d \n \n",SQLCODE);
    }
    RC=rc;
    printTotalTimings();
    exit(rc);
}
/*********************************************************************\
|
|  freadbin() -- Read a binary file
|
\*********************************************************************/
int freadbin( char*  fileName,  // IN:    DD:ddname/file name   // $fnc$
              FILE** fp,        // OUTIN: file pointer          // $fnc$
              char*  buf,       // INOUT: buffer                // $fnc$
               int   bufsize,   // IN:    number bytes to read  // $fnc$
               int*  eof,       // OUT:   =1, if EOF            // $fnc$
              long*  ctr,       // OUT:   record counter        // $fnc$
              char*  msg )      // OUT:   error message         // $fnc$
{
  int rc = 0;
  int n = 0;
  if (*eof==1) {memset(buf,'\0',bufsize); return(0);}
  //
  //  Open file
  //
  if (*fp == NULL)
  {
#if defined(__MVS__)
     *fp = fopen(fileName, "rb,type=record");
#else
     *fp = fopen(fileName, "rb");
#endif
     if (*fp == NULL)
     {
        sprintf(msg,"*ERROR* Open %s failed:\n %s",
                fileName, strerror(errno));
        return(1);
     }
     (*ctr)=0;
  }
  //
  //  Read file
  //
  n=fread(buf,1,bufsize,*fp);
  if (trace) Xprintf(" freadbin() read %d bytes\n",n);
   if (n==0) {
      *eof = 1;
      fclose(*fp); *fp=NULL; return(0);
   }
   if (n!=bufsize) {
    (*ctr)++;
     sprintf(msg,
     "*ERROR* %s file record #%d,\n"
     "        read %d bytes, but expected %d",
     fileName,*ctr,n,bufsize);
     fclose(*fp); return(2);
   }
   if (ferror(*fp))
   {
      sprintf(msg,"*ERROR* fread from %s failed:\n        %s",
              fileName, strerror(errno));
        memset(buf,'\0',bufsize);
      fclose(*fp); return(2);
   }
   (*ctr)++;
  return(0);
 }
/*********************************************************************\
|
|  freadtxt() -- Read a text file
|
\*********************************************************************/
int freadtxt( char*  fileName,  // IN:    DD:ddname/file name   // $fnc$
              FILE** fp,        // OUTIN: file pointer          // $fnc$
              char*  buf,       // INOUT: buffer                // $fnc$
               int   bufsize,   // IN:    number bytes to read  // $fnc$
               int*  eof,       // OUT:   =1, if EOF            // $fnc$
              long*  ctr,       // OUT:   record counter        // $fnc$
              char*  msg )      // OUT:   error message         // $fnc$
{
  int rc = 0;
  int n = 0;
  if (*eof==1) {memset(buf,'\0',bufsize); return(0);}
  //
  //  Open file
  //
  if (*fp == NULL)
  {
#if defined(__MVS__)
     *fp = fopen(fileName, "rb,type=record");
#else
     *fp = fopen(fileName, "r");
#endif
     if (*fp == NULL)
     {
        sprintf(msg,"*ERROR* Open %s failed:\n %s",
                fileName, strerror(errno));
        return(1);
     }
     (*ctr)=0;
  }
  //
  //  Read file
  //
  memset(buf,'\0',bufsize);
  n=fread(buf,1,bufsize,*fp);
  if (trace) Xprintf(" n=%d,buf=<%s>\n",n,buf);

   if (feof(*fp)) {
      *eof = 1;
      fclose(*fp); *fp=NULL; return(0);
   }
   if (ferror(*fp))
   {
     sprintf(msg,"*ERROR* fread from %s failed on record #%d:\n%s\n",
              fileName,(*ctr)+1, strerror(errno));
      fclose(*fp); return(2);
   }
   (*ctr)++;
  return(0);
 }
/*********************************************************************\
|
|  fgetstr() -- Read a text file
|
\*********************************************************************/
int fgetstr( char*   fileName,  // IN:    DD:ddname|file_name   // $fnc$
              FILE** fp,        // OUTIN: file pointer          // $fnc$
              char*  buf,       // INOUT: buffer                // $fnc$
              int    bufsize,   // IN:    sizeof(buf)           // $fnc$
              int*   eof,       // OUT:   =1, if EOF            // $fnc$
              long*  ctr,       // OUT:   record counter        // $fnc$
              char*  msg )      // OUT:   error message         // $fnc$
{
  int rc = 0;
  if (*eof==1) {memset(buf,'\0',bufsize); return(0);}
  memset(buf,'\n',bufsize);
  //
  //  Open file
  //
  if (*fp == NULL)
  {
     *fp = fopen(fileName,"r");
     if (*fp == NULL)
     {
        sprintf(msg,"*ERROR* Open %s with mode=\"r\" failed:\n %s",
                fileName, strerror(errno));
        memset(buf,'\0',bufsize);
        return(1);
     }
     *ctr=0;
  }
  //
  //  Read file
  //
  if (fgets(buf, bufsize, *fp) == NULL)
  {
   if (ferror(*fp))
   {
      sprintf(msg,"*ERROR* fgets from %s failed:\n %s",
              fileName, strerror(errno));
        memset(buf,'\0',bufsize);
      rc = 2;
   }
   if (feof(*fp))
   {
      *eof = 1;
      memset(buf,'\0',bufsize);
   }
  }
  else
  {
   (*ctr)++;
   if ((*(buf+bufsize-1) != '\n')||(strlen(buf)>=bufsize))
   {
     sprintf(msg,
     "*ERROR* %s file record #%d truncated, \n"
     "         strlen=%d, BUFSIZE=%d",
     fileName,*ctr,strlen(buf),bufsize);
     rc = 2;
    } else {                                /* change '\n' to '\0' */
     if (bufÝstrlen(buf)-1¨=='\n') bufÝstrlen(buf)-1¨='\0';
     for (int i=0;i<strlen(buf);i++)
     {if (bufÝi¨=='\n') bufÝi¨=' ';}
    }
  }
  //
  //  Close file if I/O error or EOF
  //
  if ((rc!=0) || (*eof==1))
   {
      fclose(*fp); *fp=NULL;
   }
  return(rc);
 }
/*********************************************************************\
|
| resetGlobalVariables(void)
|
\*********************************************************************/
void resetGlobalVariables(void) {                               // $fnc$
     freeSQLDA();
     SQL.Len=0;
     memset(SQL.Str,'\0',sizeof(SQL.Str));
     doneSTMNT=YES;
     action=actSQL;
     fCSV=fASIS=fRPT=fLIFO=fFIFO=fDATA=fEXPLAIN=fDISCARD=fDISCARDfn=NO;
     fAPPEND=NO,fLOCK=NO,fECHO=NO;
     strcpy(dlm,"|");
     lreclWRITE=0;
     lreclREAD=0;
     cntWRITE=0;
     cntREAD=0;
     datalen=0;
     totalSQLERRD3=0;
     cntDISCARD=0;
     return;
}
/*********************************************************************\
|
| LOAD_TAGS_ARRAY()
|
\*********************************************************************/
void LOAD_TAGS_ARRAY(void) {                                    // $fnc$
  char* ptr=NULL;
  int n=0,i;

     if((fpwTAGS=tmpfile())==NULL) {
        Xprintf(" \n*ERROR* Cannot make a temporary tags file\n");
        Exit(12);
     }

     // Process TAGS lines
     do {
       ptr=strip(BUF,'B');                   // remove extra blanks
       if ((ptr!=NULL) && (strlen(ptr)>0) && // bypass empty line
           (strncmp(ptr,"--",2)!=EQUALS)  && // bypass '--' comments
           (strncmp(ptr,"*",1) !=EQUALS))    // bypass '*' comments
       {
         // take two words from the line
         getwords(ptr,2,'L');
         if (strlen(wordÝ1¨.str)==0) strcpy(wordÝ1¨.str,"null");
         fprintf(fpwTAGS,"%s %s ",wordÝ0¨.str,wordÝ1¨.str);
         rowsTAGS++;
       }
       // read next line
       rc=fgetstr(fnTAGS,&fpTAGS,(char*)&BUF,
              sizeof(BUF),&eofTAGS,&cntTAGS,msg);
       if (rc!=0) { Xprintf("\n \n%s\n",msg); Exit(12); }
     } while(!eofTAGS);

     // display TAGS array
     rewind(fpwTAGS);
     for (i=1;i<=rowsTAGS;i++) {
        if (i==1)
        Xprintf("+++ Used substitutions:\n");
        fscanf(fpwTAGS,"%s %s",wordÝ0¨.str,wordÝ1¨.str);
        if (strncmp(wordÝ0¨.str,"<PASSWORD",9)==EQUALS)
         strcpy(wordÝ1¨.str,"********");
        Xprintf("    %-40s %s\n",wordÝ0¨.str,wordÝ1¨.str);
     }
     Xprintf(" \n");
}
/*********************************************************************\
|
|  allocSQLDA(short n) -- re/allocate SQLDA
|
\*********************************************************************/
void allocSQLDA(short n) {                                      // $fnc$
//define SQLDASIZE(n) (sizeof(struct sqlda)+(n-1)* sizeof(struc sqlvar))
     if (pSQLDA) free(pSQLDA);
     pSQLDA = (struct sqlda *) malloc(SQLDASIZE(n));
     if (pSQLDA==NULL) Exit(999);
     memset(pSQLDA,'\0',SQLDASIZE(n));
     SQLn = n;
}
/*********************************************************************\
|
|  OPEN_INIT() -- Open files and init variables
|
\*********************************************************************/
void OPEN_INIT(int argc, char *argvÝ¨)                          // $fnc$
{
    strcpy(fnLOG,get_parm(argc,argv,"LOG(",")",""));
     if ((strlen(fnLOG)>0) &&
         ((fpLOG=fopen(fnLOG, "w"))==NULL)) {
      Xprintf(" \n*ERROR* Open file LOG %s failed:\n"
                    "       %s\n", fnLOG, strerror(errno));
      Exit(12);
     }
    strcpy(word2,get_parm(argc,argv,"PRINT(",")",""));
    if (strlen(word2)>0)  {
     if ((strcmp(word2,"OFF")==EQUALS) ||
        (strcmp(word2,"off")==EQUALS)) printFlag=OFF;
    }
   Xprintf("+++ %s for %s, %s",pgm_tit,pgm_env,pgm_ver);
   Xprintf(" (built on %s %s, author %s)\n"
           ,__DATE__,__TIME__,pgm_dev);
    cputimeall= CPUtime(0);
    tottimeall= TOTALtime(0);
    strcpy(pgmname,argvÝ0¨);
    printCTM();
    Xprintf(" \n");
//--------------------------------------------------------------//
// Process parameters                                           //
//--------------------------------------------------------------//
    if (argc>7) {
     Xprintf(" \n*ERROR* Invalid number of parameters\n"
       "*** z/OS example:\n"
       "    PARMS('INSQL(DD:INSQL) TAGS(filename) OUTSQL(DD:name)"
       " LOG(file) SCAN(ON) PRINT(OFF)')\n");
      Exit(8);
    }
    strcpy(fnINSQL, get_parm(argc,argv,"INSQL(",")","DD:INSQL"));
    strcpy(fnOUTSQL,get_parm(argc,argv,"OUTSQL(",")",""));
    strcpy(fnTAGS,get_parm(argc,argv,"TAGS(",")",""));
    strcpy(word1,get_parm(argc,argv,"SCAN(",")",""));
    Xprintf("+++ Used parameters:\n"
            "                INSQL(%s)\n",fnINSQL);
    if (strlen(fnTAGS)>0)
    Xprintf("                 TAGS(%s)\n",fnTAGS);
    if (strlen(fnOUTSQL)>0)
    Xprintf("               OUTSQL(%s)\n",fnOUTSQL);
    if (strlen(fnLOG)>0)
    Xprintf("                  LOG(%s)\n",fnLOG);

    if (strlen(word1)>0)  {
    Xprintf("                 SCAN(%s)\n",word1);
     if (strcmp(word1,"ON")==EQUALS) scanFlag=ON;
    }
    if (strlen(word2)>0)
    Xprintf("                PRINT(%s)\n",word2);
    Xprintf(" \n");
//--------------------------------------------------------------//
// Open files
//--------------------------------------------------------------//

     if  ( (fpINSQL=fopen(fnINSQL,"r")) == NULL ) {
      Xprintf(" \n*ERROR* INSQL Open %s failed: %s\n",
                fnINSQL, strerror(errno));
      Exit(12);
      }


     if ((strlen(fnTAGS)>0) &&
         ((fpTAGS=fopen(fnTAGS, "r"))==NULL)) {
      Xprintf(" \n*ERROR* TAGS Open %s failed: %s\n",
                fnTAGS, strerror(errno));
      Exit(12);
     }
     if (fpTAGS)
     LOAD_TAGS_ARRAY();

     if ((strlen(fnOUTSQL)>0) &&
#if defined(__MVS__)
        ((fpOUTSQL=fopen(fnOUTSQL,"w,lrecl=80,recfm=fb"))==NULL)) {
#else
        ((fpOUTSQL=fopen(fnOUTSQL,"w"))==NULL)) {
#endif
      Xprintf(" \n*ERROR* Open file OUTSQL %s failed:\n"
                   "        %s\n", fnOUTSQL, strerror(errno));
      Exit(12);
     }

     allocSQLDA(numvars);
     resetGlobalVariables();
     memset(arrayLABEL,'\0',sizeof(arrayLABEL));
}
/*********************************************************************\
|
| replaceTags() -- replace <tags> with real table names from TAGS file
|
\*********************************************************************/
void replaceTags(void) {                                        // $fnc$
  char *s,*e;
  int i,j;

     if (fpwTAGS==NULL) return;
     rewind(fpwTAGS);
     for (j=1;j<=rowsTAGS;j++) {

        fscanf(fpwTAGS,"%s %s",word1,word2);
        if (strcmp(word1,word2)==EQUALS) continue;
        if ((strcmp(word2,"null")==EQUALS)||
            (strcmp(word2,"NULL")==EQUALS))
          memset(word2,'\0',sizeof(word2));

        s=strstr(BUF,word1);
        for (i=1;((i<50)&&(s));i++) {
          e=s+strlen(word1);
          memset(s,'\0',1);
          strcpy(word3,e);
          strcat(BUF,word2);
          strcat(BUF,word3);
          s=strstr(s,word1);
        }
     }
}
/*********************************************************************\
|
| PROCESS_FUNCTIONAL_SET() -- process "--#SET" functional comments
|
\*********************************************************************/
void PROCESS_FUNCTIONAL_SET(void)                               // $fnc$
{
int n=0;

// remove ending ';' from operand
     if ((strcmp(wordÝ1¨.str,"SQLDLM")!=EQUALS)&&
         (strcmp(wordÝ1¨.str,"TERMINATOR")!=EQUALS)&&
         (wordÝ2¨.strÝwordÝ2¨.len-1¨==';'))
          wordÝ2¨.strÝwordÝ2¨.len-1¨='\0';

// --#SET TRACE ON|OFF (default OFF)
     if (strcmp(wordÝ1¨.str,"TRACE")==EQUALS) {
       if (strcmp(wordÝ2¨.str,"ON")==EQUALS) trace=ON;
       else trace=OFF;
     } else

// --#SET PRINT ON|OFF (default ON)
     if (strcmp(wordÝ1¨.str,"PRINT")==EQUALS) {
       if (strcmp(wordÝ2¨.str,"OFF")==EQUALS) printFlag=OFF;
       else printFlag=ON;
     } else

// --#SET SCAN ON|OFF (default OFF)
     if (strcmp(wordÝ1¨.str,"SCAN")==EQUALS) {
       if (strcmp(wordÝ2¨.str,"ON")==EQUALS) scanFlag=ON;
       else scanFlag=OFF;
     } else

// --#SET SIGNPOS ON|OFF (default OFF)
     if (strcmp(wordÝ1¨.str,"SIGNPOS")==EQUALS) {
       if ((strcmp(wordÝ2¨.str,"OFF")==EQUALS)||
           (strcmp(wordÝ2¨.str,"NO")==EQUALS)) signposFlag=OFF;
       else signposFlag=ON;
     } else

// --#SET EXCEL ON|OFF (default ON)
     if (strcmp(wordÝ1¨.str,"EXCEL")==EQUALS) {
       if (strcmp(wordÝ2¨.str,"OFF")==EQUALS) excelFlag=OFF;
       else excelFlag=ON;
     } else

// --#SET LABELS ON|OFF (default ON)
     if (strcmp(wordÝ1¨.str,"LABELS")==EQUALS) {
       if (strcmp(wordÝ2¨.str,"OFF")==EQUALS) labelFlag=OFF;
       else labelFlag=ON;
     } else

// --#SET LOADNULL ON|OFF (default OFF)
     if (strcmp(wordÝ1¨.str,"LOADNULL")==EQUALS) {
       if (strcmp(wordÝ2¨.str,"ON")==EQUALS) loadnullFlag=ON;
       else loadnullFlag=OFF;
     } else

// --#SET MULTIROWS nn   (default 100, valid range 1-32767)
     if (strcmp(wordÝ1¨.str,"MULTIROWS")==EQUALS) {
       if (strlen(wordÝ2¨.str)!=0) {
         for (i=0;i<strlen(wordÝ2¨.str);i++) {
           if ((wordÝ2¨.strÝi¨<'0') || (wordÝ2¨.strÝi¨>'9'))
           {Xprintf(" \n*ERROR* Invalid digit: %s \n ",wordÝ2¨.str);
            Exit(8);}
         }
         i=atoi(wordÝ2¨.str);
         if ((i<1)||(i>32767)) {
          Xprintf(" \n*ERROR* %d is not in 1-32767 \n ",i);
          Exit(8);
         } else multiRows=i;
       } else Xprintf("*** Current MULTIROWS is %d\n",multiRows);
     } else

// --#SET NUMVARS nn     (default 256, valid range 50-32767)
     if (strcmp(wordÝ2¨.str,"NUMVARS")==EQUALS) {
       if (strlen(wordÝ2¨.str)!=0) {
         for (i=0;i<strlen(wordÝ1¨.str);i++) {
           if ((wordÝ2¨.strÝi¨<'0') || (wordÝ2¨.strÝi¨>'9'))
           {Xprintf(" \n*ERROR* Invalid digit: %s \n ",wordÝ1¨.str);
            Exit(8);}
         }
         i=atoi(wordÝ2¨.str);
         if ((i<50)||(i>32767)) {
          Xprintf(" \n*ERROR* %d is not in 50-32767 \n ",i);
          Exit(8);
         } else {
          numvars=i;
          free(pSQLDA); pSQLDA=NULL;
          pSQLDA = (struct sqlda *) malloc(SQLDASIZE(numvars));
          if (pSQLDA==NULL) Exit(999);
          memset(pSQLDA,'\0',SQLDASIZE(numvars));
          SQLn = numvars;
          Xprintf("*** Current NUMVARS is %d\n",numvars);
         }
       } else Xprintf("*** Current NUMVARS is %d\n",numvars);
     } else

// --#SET SYSRC nn       (default 4,   valid range 0-32)
     if (strcmp(wordÝ1¨.str,"SYSRC")==EQUALS) {
       if (strlen(wordÝ2¨.str)!=0) {
         for (i=0;i<strlen(wordÝ2¨.str);i++) {
           if ((wordÝ2¨.strÝi¨<'0') || (wordÝ2¨.strÝi¨>'9'))
           {Xprintf(" \n*ERROR* Invalid digit: %s \n ",wordÝ2¨.str);
            Exit(8);}
         }
         i=atoi(wordÝ2¨.str);
         if ((i<0)||(i>32)) {
          Xprintf(" \n*ERROR* %d is not in 0-32 \n ",i);
          Exit(8);
         } else sysrc=i;
       } else Xprintf("\n*** Current SYSRC is %d",sysrc);
     } else

// --#SET SQLDLM c      (default ';')
// --#SET TERMINATOR c  (default ';')
     if ((strcmp(wordÝ1¨.str,"SQLDLM")==EQUALS)||
         (strcmp(wordÝ1¨.str,"TERMINATOR")==EQUALS)) {
       if (strlen(wordÝ2¨.str)==1)
        strcpy(sqldlm,wordÝ2¨.str);
       else Xprintf("*** Current %s is '%s'\n",wordÝ1¨.str,sqldlm);
     } else
// --#SET NULLCHAR c    (default '?')
     if (strcmp(wordÝ1¨.str,"NULLCHAR")==EQUALS) {
       if ((strlen(wordÝ2¨.str)>0)) {
        if (strcmp(wordÝ2¨.str,"BLANK")==EQUALS) nullchar=' ';
        else nullchar=wordÝ2¨.strÝ0¨;
       }
       else nullchar='?';
       Xprintf("*** Current NULLCHAR is '%c'\n",nullchar);
     } else {

     Xprintf(" \n*ERROR* Unknown #SET function '%s' \n ",wordÝ1¨.str)   ;
     Exit(8);
     }
}
/*********************************************************************\
|
|  getFIFO() -- get a record from STACK FIFO stack
|
\*********************************************************************/
char* getFIFO(char *out) {                                      // $fnc$
 struct stack *pnext;

    if (pstackFIFO==NULL) {eofFIFO=YES;outÝ0¨='\0';return(NULL);}
    strcpy(out,pstackFIFO->data);
    pnext = pstackFIFO->next;
    free(pstackFIFO);
    pstackFIFO=pnext;
    if (pstackFIFO==NULL)
    plastFIFO = (struct stack * ) &pstackFIFO;

    return(out);
}
/*********************************************************************\
|
|  getLIFO() -- get a record from STACK LIFO stack
|
\*********************************************************************/
char* getLIFO(char *out) {                                      // $fnc$
 struct stack *pnext;

    if (pstackLIFO==NULL) {eofLIFO=YES;outÝ0¨='\0';return(NULL);}
    strcpy(out,pstackLIFO->data);
    pnext = pstackLIFO->next;
    free(pstackLIFO);
    pstackLIFO=pnext;
    if (pstackLIFO==NULL)
    plastLIFO = (struct stack * ) &pstackLIFO;
    return(out);
}
/*********************************************************************\
|
|  getLABEL() -- get a record from STACK LABEL stack
|
\*********************************************************************/
int  getLABEL(char *out) {
 struct stack *pnext;
  short i=indexLABEL;
  int len=0;
    if (arrayLABELÝi¨.pfirst==NULL)
     {eofLABEL=YES;foundstackLABEL=NO;
      outÝ0¨='\0';arrayLABELÝi¨.labelÝ0¨='\0';return(NULL);}
    len=arrayLABELÝi¨.pfirst->len;
    memcpy(out,arrayLABELÝi¨.pfirst->data,len);
    outÝlen¨='\0';
    pnext = arrayLABELÝi¨.pfirst->next;
    free(arrayLABELÝi¨.pfirst);
    arrayLABELÝi¨.pfirst=pnext;
    if (arrayLABELÝi¨.pfirst==NULL) {
     arrayLABELÝi¨.plast = (struct stack * ) &arrayLABELÝi¨.pfirst;
    }
    return(len);
}
/*********************************************************************\
|
|  getDATA() -- get a record from STACK DATA stack
|
\*********************************************************************/
int   getDATA(char *out) {                                      // $fnc$
 struct stack *pnext;
  int len=0;
    if (pstackDATA==NULL) {eofDATA=YES;outÝ0¨='\0';return(0);}
    len=pstackDATA->len;
    memcpy(out,pstackDATA->data,len);
    outÝlen¨='\0';
    pnext = pstackDATA->next;
    free(pstackDATA);
    pstackDATA=pnext;
    if (pstackDATA==NULL)
    plastDATA = (struct stack * ) &pstackDATA;
    return(len);
}
/*********************************************************************\
|
|  getIFDO() -- get last record from IFDO stack
|
\*********************************************************************/
void  getIFDO(void) {                                           // $fnc$
 struct cache *pback;

    if (plastIFDO==NULL) return;
    pback = plastIFDO->back;
    free(plastIFDO);
    plastIFDO=pback;
    return;
}
/*********************************************************************\
|
|  writeOUTSQLline() -- write input line to OUTSQL file
|
\*********************************************************************/
void  writeOUTSQLline() {                                       // $fnc$

     n=fprintf(fpOUTSQL,"%-80s\n",BUF);
     if (n<1) { Xprintf(" \n*ERROR* fprintf(%s,...) failed:\n%s\n",
                        fnOUTSQL, strerror(errno));
                Xprintf("BUF='%-80s'\n",BUF);
                Exit(12); }

}
/*********************************************************************\
|
|  READ_INPUT_LINE() -- read and process the INSQL file
|
\*********************************************************************/
void READ_INPUT_LINE(void)                                      // $fnc$
{
 char* ptr;
 short done=NO,fINSQL;
 int   n=0,l=0,len;

     if ((newSTMNT==NO)||(pBUF)) return;
     while (done==NO)
     {  // read an input record
        fINSQL=NO;
        // ... from FIFO stack when eofINSQL
        if (eofINSQL) {
           ptr=getFIFO(BUF);
           if (ptr==NULL) break;
        if (trace) Xprintf(" getFIFO='%s'\n",ptr);
        } else
        // ... from LIFO stack
        if (pstackLIFO) {
           ptr=getLIFO(BUF);
           if (trace) Xprintf(" getLIFO='%s'\n",ptr);
        } else
        // ... from LABEL stack
        if ((foundstackLABEL==ON)&&(arrayLABELÝindexLABEL¨.pfirst)) {
           len=getLABEL(BUF);
           if (trace) Xprintf(" getLABEL(BUF)='%s'\n",BUF);
           ptr=BUF;
        } else
        // ... from INCLUDE file
         if (eofINCLUDE==NO) {
         rc=fgetstr(fnINCLUDE,&fpINCLUDE,(char*)&BUF,
              sizeof(BUF),&eofINCLUDE,&cntINCLUDE,msg);

         if (rc!=0) { Xprintf("\n \n%s\n",msg); Exit(12); }
         if (eofINCLUDE==YES) break;
         if (trace) Xprintf(" fgetstr='%s'\n",BUF);
        }
        // ... from INSQL file
        else {
        fINSQL=YES;
        rc=fgetstr(fnINSQL,&fpINSQL,(char*)&BUF,
              sizeof(BUF),&eofINSQL,&cntINPUT,msg);

        if (rc!=0) { Xprintf("\n \n%s\n",msg); Exit(12); }
        if (eofINSQL==YES) break;
        if (trace) Xprintf(" fgetstr='%s'\n",BUF);
        }
        // substitute <tags>
        replaceTags();

        // bypass till a SKIP label if specified
        if (skipLABELÝ0¨!='\0'&&strcmp(skipLABEL,BUF)!=EQUALS)
        { if ((fpOUTSQL)&&(fINSQL))
          writeOUTSQLline(); continue; }

        // bypass lines with special comments
        ptr=findword(BUF,1,l);
        if ((ptr)&&(strncmp(ptr,"--;",3)==EQUALS)) continue;

        // suppress SAY/ECHO printing out
        if (!(((ptr)&&(SQL.Len==0)&&
               (
                (strncmp(ptr,"SAY",3)==EQUALS) ||
                (strncmp(ptr,"ECHO",4)==EQUALS)
               )
              )||
              ((ptr)&&(SQL.Len>0)&&
               (
                (strncmp(SQL.Str,"SAY",3)==EQUALS) ||
                (strncmp(SQL.Str,"ECHO",4)==EQUALS)
               )
           ) ))
        // print out input line
         Xprintf(" %s\n",BUF);

        // write out an OUTSQL line
        if ((fpOUTSQL)&&(fINSQL))
        writeOUTSQLline();

        ptr=strip(BUF,'B');                  // remove extra blanks
        if (ptr==NULL) continue;             // bypass empty line
        if (strlen(ptr)==0) continue;        // bypass blank line

        // process functional comments
        if (strncmp(ptr,"--#",3)==EQUALS) {
         getwords(ptr,3,'U');
         if (strcmp(wordÝ0¨.str,"--#SET")==EQUALS)
          PROCESS_FUNCTIONAL_SET();
         continue;
        }
        // bypass comments
        if (strncmp(ptr,"--",2)==EQUALS) continue;

        // process a label if it is
        if ((labelFlag==ON)&&(checkforLABEL()==YES)) continue;

        if (!scanFlag)
        done=YES;
     }
     if ((eofINSQL==YES)&&(fpOUTSQL))
      {fclose(fpOUTSQL);fpOUTSQL=NULL;}
}
/*********************************************************************\
|
|  APPEND_INPUT_TO_STMNT(void) -- add input to SQL buffer
|
\*********************************************************************/
void APPEND_INPUT_TO_STMNT(void)                                // $fnc$
{
  char *ptr,*s;
   int i,l;
 short nquotes=0;

        if (pBUF==NULL) ptr=strip(BUF,'L');  // bypass leading blanks
        else ptr=strip(pBUF,'L');            // continue proccesing
        s=ptr;                               // init work pointer
        l=strlen(s);

        if ((SQL.Len>0)&&(SQL.StrÝSQL.Len-1¨!=' ')) {
          SQL.StrÝSQL.Len¨=' ';
          SQL.Len++;
        }

        for (i=0;((i<l)&&(newSTMNT));i++) {

         switch (sÝi¨) {

          case '\'':                         // sum qoutes number
           nquotes++;
           break;

          case '-':                          // process ending comments
           if ( ((nquotes%2)==0) && (sÝi+1¨=='-') ) {
            pBUF=NULL;                       // ignore the rest of line
            return;                          // get next line
           }
           break;

          default:                           // process delimiter

           if (((nquotes%2)==0) &&
                (sÝi¨==sqldlmÝ0¨) ) {
            newSTMNT=NO;
            if (sÝi+1¨=='\0') pBUF=NULL;
            else pBUF=&sÝi+1¨;
           }
         } // switch
         SQL.Len++;
         if (SQL.Len>=MAXSQLSIZE) {
         Xprintf(" \n*ERROR* Too long statement: %d chars\n",SQL.Len);
         Xprintf("statement='%s'\n",SQL.Str);
           Exit(8);
         }
         if (newSTMNT==NO) {
           SQL.StrÝSQL.Len¨='\0';
           SQL.Len--;
         }
         else {
         if (((nquotes%2)==0) && (sÝi¨==' ')&&(sÝi-1¨==' ')) SQL.Len--;
           else SQL.StrÝSQL.Len-1¨=sÝi¨;
         }
        }
        if (nquotes%2>0)
         {Xprintf(" \n*ERROR* unpaired quote found\n"); Exit(8);}
}
/*********************************************************************\
|
| processEXEC() -- remove "EXEC SQL" words from SQL buffer
|
\*********************************************************************/
char* processEXEC()   {                                         // $fnc$
      if (strcmp(wordÝ1¨.str,"SQL")==EQUALS) return(wordÝ2¨.ptr);
      return(NULL);
}
/*********************************************************************\
|
| processWHENEVER() -- WHENEVER SQLERROR CONTINUE|ROLLBACK
|
\*********************************************************************/
void processWHENEVER() {                                        // $fnc$
 short rc=0;
      if (strcmp(wordÝ1¨.str,"SQLERROR")==EQUALS) {
       memset(sqlerrorLABEL,'\0',sizeof(sqlerrorLABEL));
       if (strcmp(wordÝ2¨.str,"CONTINUE")==EQUALS)
       { fSQLERROR='C'; doneSTMNT=YES; return; }
       if (strcmp(wordÝ2¨.str,"ROLLBACK")==EQUALS)
       { fSQLERROR='R'; doneSTMNT=YES; return; }
       if (strcmp(wordÝ2¨.str,"SUPPRESS")==EQUALS)
       { fSQLERROR='S'; doneSTMNT=YES; return; }
       if (strcmp(wordÝ2¨.str,"GOTO")==EQUALS)
       { rc=extractLABEL(wordÝ3¨.str,wordÝ3¨.len,sqlerrorLABEL);
         if (rc==0) {fSQLERROR='G'; doneSTMNT=YES; return; }
       }
      } else
      if (strcmp(wordÝ1¨.str,"SQLWARNING")==EQUALS) {
       memset(sqlwarningLABEL,'\0',sizeof(sqlwarningLABEL));
       if (strcmp(wordÝ2¨.str,"CONTINUE")==EQUALS)
       { fSQLWARNING='C'; doneSTMNT=YES; return; }
       if (strcmp(wordÝ2¨.str,"ROLLBACK")==EQUALS)
       { fSQLWARNING='R'; doneSTMNT=YES; return; }
       if (strcmp(wordÝ2¨.str,"SUPPRESS")==EQUALS)
       { fSQLWARNING='S'; doneSTMNT=YES; return; }
       if (strcmp(wordÝ2¨.str,"GOTO")==EQUALS)
       { rc=extractLABEL(wordÝ3¨.str,wordÝ3¨.len,sqlwarningLABEL);
         if (rc==0) {fSQLERROR='G'; doneSTMNT=YES; return; }
       }
      }
      Xprintf(" \n*ERROR* Invalid % syntax\n",wordÝ0¨.str);
      Exit(8);
}
/*********************************************************************\
|
| passwordNETRC() -- get a password from a NETRC file
|
\*********************************************************************/
void passwordNETRC() {

    eofNETRC=NO;rc=0;outBUFÝ0¨='\0';

    for (;(eofNETRC==NO)&&(rc==0);
          rc=fgetstr(fnNETRC,&fpNETRC,(char*)&outBUF,
          sizeof(outBUF),&eofNETRC,&cntNETRC,msg)     )
    {
      nwords=words(outBUF);
      if (nwords!=6) continue;
      getwords(outBUF,6,'U');
      if (strcmp(wordÝ0¨.str,"MACHINE" )!=EQUALS)  continue;
      if (strcmp(wordÝ2¨.str,"LOGIN"   )!=EQUALS)  continue;
      if (strcmp(wordÝ4¨.str,"PASSWORD")!=EQUALS)  continue;
      if (strncmp(wordÝ1¨.ptr,location,
          Max(wordÝ1¨.len,strlen(location)))!=EQUALS) continue;
      if (strncmp(wordÝ3¨.ptr,userid.str,
          Max(wordÝ3¨.len,userid.len))!=EQUALS) continue;
      if (wordÝ5¨.len>(sizeof(password.str)-1)) continue;
      break;
    }
    if (rc!=0) { Xprintf("\n \n%s\n",msg); Exit(8); }
    if (eofNETRC) {
     Xprintf(" \n*ERROR* Machine %s with Login %s not found in %s\n",
            location,userid.str,fnNETRC);
     Exit(8);
    }
    memset(password.str,'\0',sizeof(password.str));
    strncpy(password.str,wordÝ5¨.ptr,wordÝ5¨.len);
    password.len=strlen(password.str);
    memset(outBUF,'\0',sizeof(outBUF));
    memset(wordÝ5¨.str,'\0',sizeof(wordÝ5¨.str));
}
/*********************************************************************\
|
| processCONNECT() -- run CONNECT directly
|
\*********************************************************************/
void  processCONNECT() {                                        // $fnc$
   switch (nwords) {
    case 1:
          EXEC SQL CONNECT;
        break;
    case 2:
    // CONNECT RESET
        if (strcmp(wordÝ1¨.str,"RESET")==EQUALS) {
          EXEC SQL CONNECT RESET;
        }
        break;
    case 3:
    // CONNECT TO location
        if (strcmp(wordÝ1¨.str,"TO")==EQUALS) {
          memset(location,'\0',sizeof(location));
          strncpy(location,wordÝ2¨.ptr,
                  min(wordÝ2¨.len,sizeof(location)-1));
          EXEC SQL CONNECT TO :location;
        }
        break;
    case 7:
    // CONNECT TO location USER userid USING netrc-file
        if ((strcmp(wordÝ1¨.str,"TO")==EQUALS)&&
            (strcmp(wordÝ3¨.str,"USER")==EQUALS)&&
            (strcmp(wordÝ5¨.str,"USING")==EQUALS)) {
          memset(location,'\0',sizeof(location));
          strncpy(location,wordÝ2¨.ptr,
                  min(wordÝ2¨.len,sizeof(location)-1));
          memset(userid.str,'\0',sizeof(userid.str));
          strncpy(userid.str,wordÝ4¨.ptr,
                  min(wordÝ4¨.len,sizeof(userid.str)-1));
          userid.len=strlen(userid.str);
          memset(fnNETRC,'\0',sizeof(fnNETRC));
          strncpy(fnNETRC,wordÝ6¨.ptr,
                  min(wordÝ6¨.len,sizeof(fnNETRC)-1));
          passwordNETRC();
          EXEC SQL CONNECT TO :location USER :userid USING :password;
          memset(password.str,'\0',sizeof(password.str));
        break;
        }
    default:
        Xprintf(" \n*ERROR* Invalid or unsupported CONNECT syntax\n");
        Exit(8);
   }
   if (SQLCODE) {processSQLCODE("CONNECT"); return;}

         Xprintf("*** CONNECT successful");
        EXEC SQL GET DIAGNOSTICS CONDITION 1 :connect_info=SERVER_NAME,
        :server_class = DB2_SERVER_CLASS_NAME,
        :product_id=DB2_PRODUCT_ID;
         Xprintf(", SERVER_NAME='%s'",connect_info);
         Xprintf(", PRODUCT_ID='%s'\n",product_id);
         Xprintf("*** SERVER_CLASS='%s'\n",server_class);
   doneSTMNT=YES;
   return;
}
/*********************************************************************\
|
| printCONNECTinfo() -- print out SQLERRMC tokens
|
\*********************************************************************/
void printCONNECTinfo(void) {
 short i;
 unsigned char byte;
   if (sqlca.sqlerrml>0) {
    memset(connect_info,'\0',sizeof(connect_info));
    strncpy(connect_info,(char*)sqlca.sqlerrmc,sqlca.sqlerrml);
    for (i=0;i<strlen(connect_info);i++) {
     byte=connect_infoÝi¨;
     if (byte==0xFF) {connect_infoÝi¨=';'; }
    }
    Xprintf("*** CONNECT_INFO = '%s'\n",connect_info);
   }
}
/*********************************************************************\
|
| processSET() -- run SET CONNECTION location-name
|
\*********************************************************************/
char* processSET()    {                                         // $fnc$
   if (strcmp(wordÝ1¨.str,"CONNECTION")!=EQUALS) return(NULL);
   if (nwords!=3) {
 Xprintf(" \n*ERROR* Invalid or unsupported SET CONNECTION syntax\n");
    Exit(8);
   }
          memset(location,'\0',sizeof(location));
          strncpy(location,wordÝ2¨.ptr,
                  min(wordÝ2¨.len,sizeof(location)-1));
   EXEC SQL SET CONNECTION :location;
   if (SQLCODE) {processSQLCODE("SET CONNECTION"); return(NULL);}

        EXEC SQL GET DIAGNOSTICS CONDITION 1 :connect_info=SERVER_NAME;
         Xprintf("*** %-9s successful",wordÝ0¨.str);
         Xprintf(", SERVER_NAME='%s'\n",connect_info);
   doneSTMNT=YES;
   return(NULL);
}
/*********************************************************************\
|
| processRELEASE() -- run RELEASE here w/o PREPARE & EXECUTE
|
\*********************************************************************/
char* processRELEASE() {                                        // $fnc$
   if (strcmp(wordÝ1¨.str,"SAVEPOINT")==EQUALS) return(NULL);
   switch (nwords) {
    case 2:
        if (strcmp(wordÝ1¨.str,"CURRENT")==EQUALS) {
          EXEC SQL RELEASE CURRENT;
          break;
        } else
        if (strcmp(wordÝ1¨.str,"ALL")==EQUALS) {
          EXEC SQL RELEASE ALL;
          break;
        } else {
          memset(location,'\0',sizeof(location));
          strncpy(location,wordÝ1¨.ptr,
                  min(wordÝ1¨.len,sizeof(location)-1));
          EXEC SQL RELEASE :location;
          break;
        }
    case 3:
        if ((strcmp(wordÝ1¨.str,"ALL")==EQUALS)&&
            (strcmp(wordÝ2¨.str,"PRIVATE")==EQUALS)) {
          EXEC SQL RELEASE ALL PRIVATE;
          break;
        }
    default:
        Xprintf(" \n*ERROR* Invalid or unsupported RELEASE syntax\n");
        Exit(8);
   }
   if (SQLCODE) {processSQLCODE("RELEASE"); return(NULL);}
       EXEC SQL GET DIAGNOSTICS CONDITION 1 :connect_info=SERVER_NAME;
       Xprintf("*** %-9s successful",wordÝ0¨.str);
       Xprintf(", SERVER_NAME='%s'\n",connect_info);
   doneSTMNT=YES;
   return(NULL);
}
/*********************************************************************\
|
|  processWRITE() -- WRITE Ýdlm¨ FILE file SELECT|WITH ...
|
\*********************************************************************/
char* processWRITE(void)  {                                     // $fnc$
 short i=1,rc=0;
  action=actWRITE;
  fCSV=fASIS=fRPT=fAPPEND=fDATA=fLABEL=NO;
  strcpy(dlm," ");
   if ((strcmp(wordÝi¨.str,"FILE")!=EQUALS)&&
       (strcmp(wordÝi¨.str,"STACK")!=EQUALS)) {
       if (strcmp(wordÝi¨.str,"CSV"  )==EQUALS) {dlmÝ0¨=','; fCSV=YES; }
  else if (strcmp(wordÝi¨.str,"COMMA")==EQUALS) {dlmÝ0¨=',';           }
  else if (strcmp(wordÝi¨.str,"TAB"  )==EQUALS) {dlmÝ0¨='\t';          }
  else if (strcmp(wordÝi¨.str,"BAR"  )==EQUALS) {dlmÝ0¨='|';           }
  else if (strcmp(wordÝi¨.str,"RPT"  )==EQUALS) {dlmÝ0¨='|'; fRPT=YES; }
  else if (strcmp(wordÝi¨.str,"NODLM")==EQUALS) {dlmÝ0¨='\0';          }
  else if (strcmp(wordÝi¨.str,"ASIS" )==EQUALS) {dlmÝ0¨='\0';fASIS=YES;}
  else syntaxRWerror(i);
  i++;
  }
  if ((strcmp(wordÝi¨.str,"FILE")!=EQUALS)&&
      (strcmp(wordÝi¨.str,"STACK")!=EQUALS)) syntaxRWerror(i);
  // process STACK
  if  (strcmp(wordÝi¨.str,"STACK")==EQUALS) {
    i++;
    if ((strcmp(wordÝi¨.str,"DATA")!=EQUALS)&&
        (strcmp(wordÝi¨.str,"LABEL")!=EQUALS)) syntaxRWerror(i);
    if (strcmp(wordÝi¨.str,"DATA")==EQUALS) fDATA=YES;
    else {rc=prepareSTACKlabel(wordÝ++i¨.str);
          if (rc) syntaxRWerror(i);
          fLABEL=YES;
         }
    i++;
  } else {
 // process FILE name
    i++;
   if ((strcmp(wordÝi¨.str,"SELECT")==EQUALS)||
       (strcmp(wordÝi¨.str,"WITH")==EQUALS)||
       (strcmp(wordÝi¨.str,"APPEND")==EQUALS)||
       (wordÝi¨.len==0))
       syntaxRWerror(i);
   memset(fnWRITE,'\0',sizeof(fnWRITE));
   strncpy(fnWRITE,wordÝi¨.ptr,
           min(wordÝi¨.len,sizeof(fnWRITE)-1));
   i++;
  }
  if (strcmp(wordÝi¨.str,"APPEND")==EQUALS)
     {fAPPEND=YES; i++;}
  return(wordÝi¨.ptr);
}
/*********************************************************************\
|
|  createSESSION() -- declare a session table based on sqlvars
|
\*********************************************************************/
void createSESSION(char *table) {
 int i,n;
 char strÝ30¨;

    if (SQLd==0) return;
    strcpy(SELECT.Str,"DECLARE GLOBAL TEMPORARY TABLE ");
    strcat(SELECT.Str,table);
    strcat(SELECT.Str," (");

    for(i=0;i<SQLd;i++) {
      n=0;
      if (SQLNAMEL(i)==0) {
       sprintf(str,"COL%d",i+1);
       strncat(SELECT.Str,str,strlen(str));
      } else
      strncat(SELECT.Str,SQLNAMED(i),SQLNAMEL(i));
      strcat(SELECT.Str," ");

      switch (SQLTYPE(i)) {
        case sVARBINn: n=1;
        case sVARBIN:
           strcat(SELECT.Str,"VARBINARY(");
           sprintf(str,"%d)",SQLLEN(i));
           strcat(SELECT.Str,str);
           break;
        case sBINn: n=1;
        case sBIN:
           strcat(SELECT.Str,"BINARY(");
           sprintf(str,"%d)",SQLLEN(i));
           strcat(SELECT.Str,str);
           break;
        case sVCHARn:   case sLVCHARn: n=1;
        case sVCHAR:    case sLVCHAR:
           strcat(SELECT.Str,"VARCHAR(");
           sprintf(str,"%d)",SQLLEN(i));
           strcat(SELECT.Str,str);
           break;
        case sCHARn: n=1;
        case sCHAR:
           strcat(SELECT.Str,"CHAR(");
           sprintf(str,"%d)",SQLLEN(i));
           strcat(SELECT.Str,str);
           break;
        case sDATEn: n=1;     case sDATE:
           strcat(SELECT.Str,"DATE");
           break;
        case sTIMEn: n=1;      case sTIME:
           strcat(SELECT.Str,"TIME");
           break;
        case sTIMESTAMPn: n=1;case sTIMESTAMP:
           strcat(SELECT.Str,"TIMESTAMP");
           break;
        case sFLOATn:n=1;     case sFLOAT:
           if (SQLLEN(i)==4)
           strcat(SELECT.Str,"FLOAT");
           else
           strcat(SELECT.Str,"DOUBLE");
           break;
        case sBIGINTn:n=1;       case sBIGINT:
           strcat(SELECT.Str,"BIGINT");
           break;
        case sINTn:n=1;       case sINT:
           strcat(SELECT.Str,"INTEGER");
           break;
        case sSMINTn:n=1;     case sSMINT:
           strcat(SELECT.Str,"SMALLINT");
           break;
        case sDECn:n=1;       case sDEC:
           strcat(SELECT.Str,"DECIMAL(");
           parseDecSQLLEN(i);
           sprintf(str,"%d",prec);
           strcat(SELECT.Str,str);
           if (scale>0) {
            sprintf(str,",%d",scale);
            strcat(SELECT.Str,str);
           }
           strcat(SELECT.Str,")");
           break;
        case sDECFLOATn:n=1;   case sDECFLOAT:
           if (SQLLEN(i)==8)  strcat(SELECT.Str,"DECFLOAT(16)");
           else               strcat(SELECT.Str,"DECFLOAT(34)");
           break;
        default:
           Xprintf(" \n*ERROR* Unsupported SQLTYPE=%d\n",SQLTYPE(i));
           Exit(8);
      } // switch
    if (n==0) strcat(SELECT.Str," WITH DEFAULT NOT NULL");
    if (n==1) strcat(SELECT.Str," WITH DEFAULT NULL");
    if (i<SQLd-1) strcat(SELECT.Str,",");
    }  // for
    strcat(SELECT.Str,") ON COMMIT PRESERVE ROWS");
    SELECT.Len=strlen(SELECT.Str);
    if (trace) Xprintf(" SELECT.Str='%s'\n",SELECT.Str);
    EXEC SQL PREPARE STMNT2 FROM :SELECT;
    if (SQLCODE) {processSQLCODE("PREPARE SESSION"); return;}
    EXEC SQL EXECUTE STMNT2;
    if (SQLCODE) {processSQLCODE("EXECUTE SESSION"); return;}
    SQLd=0;
    Xprintf("*** Temporary table %s declared implicitly\n",table);
}
/*********************************************************************\
|
|  processSAVE() -- SAVE DATA AS table SELECT|WITH ...
|
\*********************************************************************/
char* processSAVE(void)  {                                     // $fnc$
 short i=1;
  if ((strcmp(wordÝ1¨.str,"DATA")!=EQUALS)||
      (strcmp(wordÝ2¨.str,"AS")!=EQUALS)||
      (wordÝ3¨.len==0)||
      ((strcmp(wordÝ4¨.str,"SELECT")!=EQUALS)&&
       (strcmp(wordÝ4¨.str,"WITH")==EQUALS)) )
  { Xprintf(" \n*ERROR* Invalid SAVE DATA AS syntax\n"); Exit(8);}

//                 SAVE DATA AS  -- overlay
  strncpy(SQL.Str,"INSERT INTO ",12);
  strcpy(SELECT.Str,"SELECT * FROM ");
  strcat(SELECT.Str,wordÝ3¨.str);
  SELECT.Len=strlen(SELECT.Str);
  EXEC SQL PREPARE STMNT2 FROM :SELECT;
  if (SQLCODE==0) {
   if (trace) Xprintf(" SQL.Str=%s\n",SQL.Str);
   return(NULL);
  }
  if (strncmp(wordÝ3¨.str,"SESSION.",8)!=EQUALS)
  { Xprintf(" \n*ERROR* Table %s not exists\n",wordÝ3¨.str); Exit(8);}
  // try to create a SESSION table
  strcpy(SELECT.Str,wordÝ4¨.ptr);
  SELECT.Len=strlen(SELECT.Str);
  EXEC SQL PREPARE STMNT2 FROM :SELECT;
  if (SQLCODE) {processSQLCODE("PREPARE SELECT"); return(NULL);}
  // get column description
  do {
   EXEC SQL DESCRIBE STMNT2 INTO :*pSQLDA;
   if (SQLCODE) {processSQLCODE("DESCRIBE SELECT"); return(NULL);}
  } while (checkSQLd());
  createSESSION(wordÝ3¨.str);
  return(NULL);
}
/*********************************************************************\
|
|  processDDL() -- generate DDL for a select
|
\*********************************************************************/
void processDDL(void)  {                                       // $fnc$
 short i=1,n=0;
 char strÝ30¨;
 char *p=wordÝ1¨.ptr;

  datalen=80;
  if (action==actWRITE) openWRITE();

  memset(str,'\0',sizeof(str));
  if (strcmp(wordÝ1¨.str,"TABLE")==EQUALS) {
   strncpy(str,wordÝ2¨.str,min(sizeof(str)-1,wordÝ2¨.len));
   p=wordÝ3¨.ptr;
  } else {
   sprintf(str,"SESSION.T%d",sessionNo++);
   p=wordÝ1¨.ptr;
  }

  strcpy(SELECT.Str,p);
  SELECT.Len=strlen(p);
  EXEC SQL PREPARE STMNT2 FROM :SELECT;
  if (SQLCODE) {
   Xprintf(" \n*ERROR* PREPARE '%s'\n",SELECT.Str);
   processSQLCODE("PREPARE SELECT");
   return;
  }
  // get column description
  do {
   EXEC SQL DESCRIBE STMNT2 INTO :*pSQLDA;
   if (SQLCODE) {processSQLCODE("DESCRIBE SELECT"); return;}
  } while (checkSQLd());
  if (SQLd==0) {
   Xprintf(" \n*ERROR* DDL is allowed before a SELECT only\n");
   Exit(8);
  }

  doneSTMNT=YES;
  sprintf(outBUF,"    DECLARE GLOBAL TEMPORARY TABLE %s (",str);
  outBUFrecord();

  for(i=0;i<SQLd;i++) {
      n=0;
      memset(outBUF,'\0',sizeof(outBUF));
      memset(outBUF,' ',6);
      if (SQLNAMEL(i)==0) {
       sprintf(outBUF+6,"COL%d",i+1);
      } else
       strncpy(outBUF+6,SQLNAMED(i),SQLNAMEL(i));
      strcat(outBUF," ");

      strncat(outBUF,"                       ",
              Max((short)(20+6-strlen(outBUF)),1));

      switch (SQLTYPE(i)) {
        case sVARBINn: n=1;
        case sVARBIN:
           strcat(outBUF,"VARBINARY(");
           sprintf(str,"%d)",SQLLEN(i));
           strcat(outBUF,str);
           break;
        case sBINn: n=1;
        case sBIN:
           strcat(outBUF,"BINARY(");
           sprintf(str,"%d)",SQLLEN(i));
           strcat(outBUF,str);
           break;
        case sVCHARn:   case sLVCHARn: n=1;
        case sVCHAR:    case sLVCHAR:
           strcat(outBUF,"VARCHAR(");
           sprintf(str,"%d)",SQLLEN(i));
           strcat(outBUF,str);
           break;
        case sCHARn: n=1;
        case sCHAR:
           strcat(outBUF,"CHAR(");
           sprintf(str,"%d)",SQLLEN(i));
           strcat(outBUF,str);
           break;
        case sDATEn: n=1;     case sDATE:
           strcat(outBUF,"DATE");
           break;
        case sTIMEn: n=1;      case sTIME:
           strcat(outBUF,"TIME");
           break;
        case sTIMESTAMPn: n=1;case sTIMESTAMP:
           strcat(outBUF,"TIMESTAMP");
           break;
        case sFLOATn:n=1;     case sFLOAT:
           if (SQLLEN(i)==4)
           strcat(outBUF,"FLOAT");
           else
           strcat(outBUF,"DOUBLE");
           break;
        case sBIGINTn:n=1;    case sBIGINT:
           strcat(outBUF,"BIGINT");
           break;
        case sINTn:n=1;       case sINT:
           strcat(outBUF,"INTEGER");
           break;
        case sSMINTn:n=1;     case sSMINT:
           strcat(outBUF,"SMALLINT");
           break;
        case sDECn:n=1;       case sDEC:
           strcat(outBUF,"DECIMAL(");
           parseDecSQLLEN(i);
           sprintf(str,"%d",prec);
           strcat(outBUF,str);
           if (scale>0) {
            sprintf(str,",%d",scale);
            strcat(outBUF,str);
           }
           strcat(outBUF,")");
           break;
        case sDECFLOATn:n=1;   case sDECFLOAT:
           if (SQLLEN(i)==8)
           strcat(outBUF,"DECFLOAT(16)");
           else
           strcat(outBUF,"DECFLOAT(34)");
           break;
        default:
           Xprintf(" \n*ERROR* Unsupported SQLTYPE=%d\n",SQLTYPE(i));
           Exit(8);
      } // switch
    strncat(outBUF,"                                            ",
              Max((short)(42-strlen(outBUF)),1));
    if (n==0) strcat(outBUF," WITH DEFAULT NOT NULL");
    if (n==1) strcat(outBUF," WITH DEFAULT NULL");
    if (i<SQLd-1) strcat(outBUF,",");
    outBUFrecord();
    }  // for
    strcpy(outBUF+4,") ON COMMIT PRESERVE ROWS;");
    outBUFrecord();
    if (action==actWRITE)
    {Xprintf("*** Successful WRITE of %d record(s),"
           " RECFM=FB, LRECL=%d\n",cntWRITE,lreclWRITE);RC=0;}
  return;
}
/*********************************************************************\
|
|  processDRAW() -- generate a column list for a table
|
\*********************************************************************/
void processDRAW(void) {
 short i;
 char colnnÝ10¨;
  if ((strcmp(wordÝ1¨.str,"COLNAMES")!=EQUALS) ||
      (wordÝ2¨.len==0)) {
   Xprintf(" \n*ERROR* Invalid %s syntax\n",wordÝ0¨.str);
   Exit(8);
  }

  sprintf(SELECT.Str,"SELECT * FROM %s",wordÝ2¨.str);
  SELECT.Len=strlen(SELECT.Str);
  EXEC SQL PREPARE STMNT2 FROM :SELECT;
  if (SQLCODE) {
   Xprintf(" \n*ERROR* PREPARE '%s'\n",SELECT.Str);
   processSQLCODE("PREPARE SELECT");
   return;
  }
  // get column names
  do {
   EXEC SQL DESCRIBE STMNT2 INTO :*pSQLDA;
   if (SQLCODE) {processSQLCODE("DESCRIBE SELECT"); return;}
  } while (checkSQLd());

  memset(outBUF,'\0',sizeof(outBUF));
  memset(outBUF,' ',8);
  for(i=0;i<SQLd;i++) {
    if (i>0) strcat(outBUF,", ");
    if (SQLNAMEL(i)==0) {sprintf(colnn,"COL%d",i+1);
                         strcat(outBUF,colnn);}
    else
    {
     strncat(outBUF,SQLNAMED(i),SQLNAMEL(i));
     if (strlen(outBUF)>55)
     {
      outBUFrecord();
      memset(outBUF,'\0',sizeof(outBUF));
      memset(outBUF,' ',6);
     }
    }
   }
   if (strlen(outBUF)>0) outBUFrecord();
   doneSTMNT=YES;
  return;
}
/*********************************************************************\
|
|  processINCLUDE -- open INCLUDE file with additional SQL input
|
\*********************************************************************/
void processINCLUDE(void)  {                                    // $fnc$
   if (eofINCLUDE==NO) {
     Xprintf(" \n*ERROR* Embedded INCLUDE is not allowed\n");
     Exit(8);
   }
   if (strcmp(wordÝ1¨.str,"FILE")==EQUALS) {
    if (wordÝ2¨.len==0) {
     Xprintf(" \n*ERROR* Missing file name found\n");
     Exit(8);
    }
    memset(fnINCLUDE,'\0',sizeof(fnINCLUDE));
    strncpy(fnINCLUDE,wordÝ2¨.str,min(wordÝ2¨.len,sizeof(fnINCLUDE)-1));
    if ( (fpINCLUDE=fopen(fnINCLUDE,"r")) == NULL ) {
     Xprintf(" \n*ERROR* INCLUDE Open %s failed: %s \n",
                fnINCLUDE, strerror(errno));
     Exit(12);
    }
    eofINCLUDE=NO;
    doneSTMNT=YES;
    return;
   }
   Xprintf(" \n*ERROR* Invalid syntax\n");
   Exit(8);
}
/*********************************************************************\
|
|  processREAD() -- READ Ýdlm¨ FILE file ÝDISCARD Ýfile¨¨
|                   INSERT INTO table Ý(columns)¨ VALUES(*|p1:p2,p3.l3)
|
\*********************************************************************/
char* processREAD(void)  {                                      // $fnc$
 char  *ptr;
 short i=1,error=NO;
   action=actREAD;
   fCSV=fASIS=fDISCARD=fDISCARDfn=fDATA=fLABEL=NO;
   strcpy(dlm," ");
   memset(fnDISCARD,'\0',sizeof(fnDISCARD));

   if ((strcmp(wordÝi¨.str,"FILE")!=EQUALS)&&
       (strcmp(wordÝi¨.str,"STACK")!=EQUALS)) {
      if (strcmp(wordÝi¨.str,"CSV"  )==EQUALS) {dlmÝ0¨=','  ;fCSV=YES ;}
 else if (strcmp(wordÝi¨.str,"COMMA")==EQUALS) {dlmÝ0¨=','  ;          }
 else if (strcmp(wordÝi¨.str,"TAB"  )==EQUALS) {dlmÝ0¨='\t' ;          }
 else if (strcmp(wordÝi¨.str,"BAR"  )==EQUALS) {dlmÝ0¨='|'  ;          }
 else if (strcmp(wordÝi¨.str,"NODLM")==EQUALS) {dlmÝ0¨='\0' ;          }
 else if (strcmp(wordÝi¨.str,"ASIS" )==EQUALS) {dlmÝ0¨='\0' ;fASIS=YES;}
 else syntaxRWerror(i);
     i++;
   }
   if ((strcmp(wordÝi¨.str,"FILE")!=EQUALS)&&
       (strcmp(wordÝi¨.str,"STACK")!=EQUALS)) syntaxRWerror(i);
  // process STACK
  if  (strcmp(wordÝi¨.str,"STACK")==EQUALS) {
    i++;
    if ((strcmp(wordÝi¨.str,"DATA")!=EQUALS)&&
        (strcmp(wordÝi¨.str,"LABEL")!=EQUALS)) syntaxRWerror(i);
    if (strcmp(wordÝi¨.str,"DATA")==EQUALS) fDATA=YES;
    else {rc=prepareSTACKlabel(wordÝ++i¨.str);
          if (rc||eofLABEL) syntaxRWerror(i);
          fLABEL=YES;
         }
    i++;
  } else {
 // process FILE name
    i++;
   if ((strcmp(wordÝi¨.str,"DISCARD")==EQUALS)||
       (strcmp(wordÝi¨.str,"INSERT" )==EQUALS)||
       (wordÝi¨.len==0)) syntaxRWerror(i);
       memset(fnREAD,'\0',sizeof(fnREAD));
       strncpy(fnREAD,wordÝi¨.ptr,min(wordÝi¨.len,sizeof(fnREAD)-1));
   i++;
   }
 // process DISCARD name
   if (strcmp(wordÝi¨.str,"DISCARD")==EQUALS) {
      fDISCARD=ON;
      i++;
      if (wordÝi¨.len==0) syntaxRWerror(i);
      if (strcmp(wordÝi¨.str,"INSERT")!=EQUALS) {
       strncpy(fnDISCARD,wordÝi¨.ptr,
               min(wordÝi¨.len,sizeof(fnDISCARD)-1));
       fDISCARDfn=ON;
       multiRows_save = multiRows;
       multiRows = 1;
       i++;
      }
   }
   if ((strcmp(wordÝi¨.str,"ECHO")==EQUALS)||
       (strcmp(wordÝi¨.str,"SAY")==EQUALS))
   return(wordÝi¨.ptr);

   if ((strcmp(wordÝi¨.str,"INSERT")!=EQUALS)||
       ((ptr=strstr(wordÝi¨.ptr,"VALUES"))==NULL)||
       ((ptr=strchr(ptr,'('))==NULL)||
       ((ptr=strchr(ptr,')'))==NULL)
      )
{Xprintf(" \n*ERROR* READ must be before INSERT INTO...VALUES(...);\n");
   if (trace) Xprintf(" wordÝ%d¨.ptr='%s'\n",i,wordÝi¨.ptr);
    Exit(8);}
    describeINSERT(wordÝi¨.ptr);
   return(wordÝi¨.ptr);
}
/*********************************************************************\
|
|  syntaxRWerror() -- print out READ/WRITE syntax error message
|
\*********************************************************************/
void syntaxRWerror(short i) {                                   // $fnc$
   Xprintf(" \n*ERROR* Invalid syntax on %s\n",wordÝi¨.str);
   Exit(8);
}
/*********************************************************************\
|
|  describeINSERT() -- describe INSERT columns into SQLDA
|
\*********************************************************************/
void describeINSERT(char *p) {                                  // $fnc$
 char *p1,*p2,*pv,*pt;
 int  n;

    memset(SELECT.Str,'\0',sizeof(SELECT.Str));
    // find a table name
    pt=findword(p,3,n);

    // build "SELECT *|column-list FROM table" from the INSERT stmnt
    p1=pt+n+1;                               // start of possible list
    pv=strstr(p1,"VALUES");                  // start of VALUES word
    p1=strchr(p1,'(');                       // find '('
    if (p1<pv) {                             // if '(' is before VALUES
     p1++;if (p1Ý0¨==' ') p1++;              // p1 is start
     p2=strchr(p1,')');                      // find ')'
     if (p2>pv) return;                      // if ')' is after VALUES
     strcpy(SELECT.Str,"SELECT ");           // build SELECT
     strncat(SELECT.Str,p1,p2-p1);           // with column names
    } else                                   // if there is no list
     strcpy(SELECT.Str,"SELECT *");          // use * for all columns
    strcat(SELECT.Str," FROM ");             // append FROM
    strncat(SELECT.Str,pt,n);                // append table name
    SELECT.Len=strlen(SELECT.Str);           // complete SELECT struct

    if (trace)
      Xprintf(" struct SELECT {%d,'%s'}\n",SELECT.Len,SELECT.Str);

    // Prepare & describe the SELECT into SQLDA
    EXEC SQL PREPARE STMNT2 FROM :SELECT;
     if (SQLCODE) {processSQLCODE("PREPARE SELECT"); return;}
    do {
    EXEC SQL DESCRIBE STMNT2 INTO :*pSQLDA;
     if (SQLCODE) {processSQLCODE("DESCRIBE SELECT"); return;}
    } while (checkSQLd());
    parseVALUES(pv);
}
/*********************************************************************\
|
|  parseVALUES()  -- parse column positions
|
\*********************************************************************/
void parseVALUES(char *p) {                                     // $fnc$
 char *ps,*pe,*pv;
 struct COLPOS *pc;
 int  i,rc;

    pCOLPOS=(struct COLPOS*) malloc(sizeof(struct COLPOS)*SQLd);
    if (pCOLPOS==NULL) Exit(999);
    memset(pCOLPOS,'\0',sizeof(COLPOS)*SQLd);

    pv=strchr(p,'('); pv++; ps=pv;               // point to first pos
    pe=strchr(p,')'); peÝ0¨='\0';                // kill the ')'

    while (ps=strchr(ps,' ')) {strcpy(ps,ps+1);} // remove blanks
                                                 // from positions
    ps=pv;
    if ((rc=(strcmp(ps,"*")==EQUALS))&&
        (strlen(dlm)==0)&&(!fASIS)) {
      Xprintf(" \n*ERROR* VALUES(*) is invalid for NODLM file\n");
      Exit(8);
    }
    fixposFlag=strcmp(ps,"*");                   // 0="*"
    for (i=0;(i<SQLd)&&(fixposFlag);i++) {       // if not "*"
     pc=&pCOLPOSÝi¨;
     if (pe=strchr(ps,',')) {                    // char i-pos
//    strncpy(pc->posstr,ps,min(pe-ps,sizeof(COLPOS::posstr)-1));
      strncpy(pc->posstr,ps,min(pe-ps,20));
      ps=pe+1;
      }
     else {                                       // last char pos
//    strncpy(pc->posstr,ps,min(strlen(ps),sizeof(COLPOS::posstr)-1));
      strncpy(pc->posstr,ps,min(strlen(ps),20));

      break;
     }
    }

    if ((i+1<SQLd)&&(fixposFlag))
     {Xprintf(" \n*ERROR* Number of VALUES positions is %d but "
             "the target table has %d columns",i+1,SQLd); Exit(8);}
    maxpos=0;
    for (i=0;(i<SQLd)&&(fixposFlag);i++) {         // for each column
     pc=&pCOLPOSÝi¨;
//   pc->posstr=toupper(pc->posstr);
           if (ps=strchr(pc->posstr,':')) pc->dlm=':';
      else if (ps=strchr(pc->posstr,'.')) pc->dlm='.';
      else
     {Xprintf(" \n*ERROR* Invalid syntax of positions #%d (%s): "
             "empty or bypassed ':' or '.'",i+1,pc->posstr); Exit(8); }

     strncpy(pc->pos1,pc->posstr,ps-pc->posstr);
     strcpy(pc->pos2,ps+1);
     if ((strlen(pc->pos1)==0)||
         (strlen(pc->pos2)==0)||
//       (strlen(pc->pos1)==sizeof(COLPOS::pos1)-1)||
//       (strlen(pc->pos2)==sizeof(COLPOS::pos2)-1)||
         (strlen(pc->pos1)==6)||
         (strlen(pc->pos2)==6)||
         (checkdigits(pc->pos1)!=NULL)||
         (checkdigits(pc->pos2)!=NULL)||
         (atoi(pc->pos1)==0)||(atoi(pc->pos1)>32767)||
         (atoi(pc->pos2)==0)||(atoi(pc->pos2)>32767))
     {Xprintf(" \n*ERROR* Invalid syntax of positions #%d (%s)\n",
             i+1,pc->posstr); Exit(8); }
     pc->start=atoi(pc->pos1);
     pc->len=atoi(pc->pos2);
     if ( (pc->dlm==':')&&(pc->start>pc->len) )
     {Xprintf(" \n*ERROR* Invalid positions #%d (%s), ",
             "start > end \n",i+1,pc->posstr); Exit(8); }
     if (pc->dlm==':') pc->len=pc->len-pc->start+1;
     maxpos=Max(maxpos,pc->start+pc->len-1);
    }
    ps=pv;
    for (i=0;i<SQLd;i++) {                   // for each column
     strcpy(ps,"?,");
     ps=ps+2;
     pc=&pCOLPOSÝi¨;
     strncpy(pc->sqlname,SQLNAMED(i),SQLNAMEL(i));
    }
    ps--;
    strcpy(ps,")");
    allocSQLVARarrays(multiRows);
}
/*********************************************************************\
|
|  checkdigits()
|
\*********************************************************************/
char* checkdigits(char *p) {                                    // $fnc$
  for (int i=0;i<strlen(p);i++) {
   if ((*p<'0')||(*p>'9')) return(p);
   p++;
  }
  return(NULL);
}
/*********************************************************************\
|
|  checkSQLd() -- check if SQLVARs number is too small
|
\*********************************************************************/
int checkSQLd(void) {                                           // $fnc$
 if ((SQLd+1)>SQLn) {
  numvars=SQLd+1;
  allocSQLDA(numvars);
  Xprintf(" --#SET NUMVARS %d\n",numvars);
  return(1);
 }
 return(0);
}
/*********************************************************************\
|
|  processEXPLAIN()
|
\*********************************************************************/
char* processEXPLAIN()  {                                       // $fnc$

    if ((strcmp(wordÝ1¨.str,"PLAN")==EQUALS)||
       (strcmp(wordÝ1¨.str,"ALL")==EQUALS)) return(NULL);

    strcpy(BUF,wordÝ1¨.ptr);                   // w/o EXPLAIN word
    // DELETE FROM PLAN_TABLE WHERE QUERYNO=0
    strcpy(SQL.Str,deletestr);                 // DELETE QUERYNO=0;
    SQL.Len=strlen(SQL.Str);
    EXEC SQL PREPARE STMNT2 FROM :SQL;
    if (SQLCODE) {processSQLCODE("PREPARE DELETE PLAN"); return(NULL);}

    EXEC SQL EXECUTE STMNT2;
    if ((SQLCODE!=0)&&(SQLCODE!=100))
     {processSQLCODE("EXECUTE DELETE PLAN"); return(NULL);}

    // EXPLAIN PLAN SET QUERYNO=0 FOR
    strcpy(SQL.Str,explainstr);
    strcat(SQL.Str,BUF);
    SQL.Len=strlen(SQL.Str);
    EXEC SQL PREPARE STMNT2 FROM :SQL;
    if (SQLCODE) {processSQLCODE("PREPARE EXPLAIN PLAN");return(NULL);}

    EXEC SQL EXECUTE STMNT2;
    if ((SQLCODE!=0)&&(SQLCODE!=100))
     {processSQLCODE("EXECUTE EXPLAIN PLAN"); return(NULL);}

    // SELECT fields FROM PLAN_TABLE WHERE QUERYNO=0 ORDER BY ...
    strcpy(SQL.Str,selectPlan);
    SQL.Len=strlen(SQL.Str);
    fEXPLAIN=YES;
    hold_signposFlag=signposFlag;
    hold_nullchar=nullchar;
    signposFlag=NO;
    nullchar=' ';
    return(NULL);
}
/*********************************************************************\
|
|  processSTACK()
|
\*********************************************************************/
char* processSTACK()  {                                         // $fnc$
 short i,rc=0;
    fFIFO=fLIFO=fDATA=fLABEL=NO;
         if (strcmp(wordÝ1¨.str,"DATA")==EQUALS) {fDATA=YES; i=2;}
    else if (strcmp(wordÝ1¨.str,"FIFO")==EQUALS) {fFIFO=YES; i=2;}
    else if (strcmp(wordÝ1¨.str,"LIFO")==EQUALS) {fLIFO=YES; i=2;}
    else if (strcmp(wordÝ1¨.str,"LABEL")==EQUALS) {fLABEL=YES; i=3;
             rc=prepareSTACKlabel(wordÝ2¨.str);}
    else rc=1;
    if (rc) {Xprintf(" \n*ERROR* Invalid STACK syntax\n");Exit(8);}
    action=actSTACK;
    strcpy(dlm,"\0");
    return(wordÝi¨.ptr);
}
/*********************************************************************\
|
|  prepareSTACKlabel()
|
\*********************************************************************/
short prepareSTACKlabel(char* label) {                          // $fnc$
 char  lÝsizeof(stackLABEL)¨;
 short n,i,f=0;
  n=strlen(label);
  if ((strcmp(label,"SELECT")==EQUALS)||
      (strcmp(label,"DDL"   )==EQUALS)||
      (strcmp(label,"DB2"   )==EQUALS)||
      (strcmp(label,"WITH"  )==EQUALS)) return(1);
  if (n==0||n>sizeof(stackLABEL)-2) return(1);
  memset(l,'\0',sizeof(l));
  strcpy(l,label);
  if (lÝn-1¨!=':') lÝn¨=':';
  // Check if the stack label exists already
  for (i=0;i<numLABEL;i++) {
   if (strcmp(arrayLABELÝi¨.label,l)==EQUALS) {
    indexLABEL=i;
    eofLABEL=NO;
    return(0);
   }
  }
  // Label is new, prepare a stack entry
  for (i=0;i<numLABEL;i++) {
    if (arrayLABELÝi¨.labelÝ0¨!='\0') continue;
    strcpy(arrayLABELÝi¨.label,l);
    indexLABEL=i;
    arrayLABELÝi¨.pfirst = NULL;
    arrayLABELÝi¨.plast  = (struct stack *) &arrayLABELÝi¨.pfirst;
    eofLABEL=YES;
    return(0);
  }
  Xprintf(" \n*ERROR* Max STACK LABEL number (%d) exeeded\n",numLABEL);
  Exit(8);
  return(1);
}
/*********************************************************************\
|
|  processEND()
|
\*********************************************************************/
void  processEND(void) {                                        // $fnc$
  eofINSQL=YES;          // what about the end of STACK????
  doneSTMNT=YES;
}
/*********************************************************************\
|
|  processECHO()
|
\*********************************************************************/
void  processECHO(void) {
 int n=32700,i=1;
  strcpy(outBUF,wordÝ1¨.ptr);
  multiRows_save=multiRows;
  multiRows=1;
  if (action==actWRITE) {
    datalen=80;
    openWRITE();
    outBUFrecord();
  } else
  if (action==actREAD) {
      if ((nwords>1) && (checkint(wordÝ1¨.ptr,wordÝ1¨.len,8)==0))
      { n=atoi(wordÝ1¨.ptr); i=2;}
      if (nwords>i) Xprintf("%s\n",wordÝi¨.ptr);
      fECHO=YES;
      loadSQLDATAarrays();
      for (i=0;((eofREAD==NO)&&(i<n));i++) {
        outBUFrecord();
        loadSQLDATAarrays();
      }
  } else outBUFrecord();
  multiRows=multiRows_save;
  doneSTMNT=YES;
}
/*********************************************************************\
|
|  processSAY()
|
\*********************************************************************/
void  processSAY(void) {
  printf("%s\n",wordÝ1¨.ptr);
  doneSTMNT=YES;
}
/*********************************************************************\
|
|  processRC() -- set/reset or save current RC
|
\*********************************************************************/
void  processRC(void) {                                         // $fnc$
         if (strcmp(wordÝ0¨.str,"RC=0")==EQUALS) RC=0;
    else if (strcmp(wordÝ0¨.str,"RC=4")==EQUALS) RC=4;
    else if (strcmp(wordÝ0¨.str,"RC=8")==EQUALS) RC=8;
    else if (strcmp(wordÝ0¨.str,"RC1=0")==EQUALS) RC1=0;
    else if (strcmp(wordÝ0¨.str,"RC2=0")==EQUALS) RC2=0;
    else if (strcmp(wordÝ0¨.str,"RC3=0")==EQUALS) RC3=0;
    else if (strcmp(wordÝ0¨.str,"RC4=0")==EQUALS) RC4=0;
    else if (strcmp(wordÝ0¨.str,"RC1=4")==EQUALS) RC1=4;
    else if (strcmp(wordÝ0¨.str,"RC2=4")==EQUALS) RC2=4;
    else if (strcmp(wordÝ0¨.str,"RC3=4")==EQUALS) RC3=4;
    else if (strcmp(wordÝ0¨.str,"RC4=4")==EQUALS) RC4=4;
    else if (strcmp(wordÝ0¨.str,"RC1=8")==EQUALS) RC1=8;
    else if (strcmp(wordÝ0¨.str,"RC2=8")==EQUALS) RC2=8;
    else if (strcmp(wordÝ0¨.str,"RC3=8")==EQUALS) RC3=8;
    else if (strcmp(wordÝ0¨.str,"RC4=8")==EQUALS) RC4=8;
    else if (strcmp(wordÝ0¨.str,"RC1=RC")==EQUALS) RC1=RC;
    else if (strcmp(wordÝ0¨.str,"RC2=RC")==EQUALS) RC2=RC;
    else if (strcmp(wordÝ0¨.str,"RC3=RC")==EQUALS) RC3=RC;
    else if (strcmp(wordÝ0¨.str,"RC4=RC")==EQUALS) RC4=RC;
    else { Xprintf(" \n*ERROR* Invalid syntax, "
                  "valid RCÝn¨=0|4|8,RCn=RC (n=1-4)\n");Exit(8);}
    doneSTMNT=YES;
}
/*********************************************************************\
|
|  processIF() -- IF condition ÝDO;¨ statement(s); ÝENDIF;¨
|
\*********************************************************************/
char* processIF(void) {                                         // $fnc$
 short flagIF=NO;
 struct cache *p;
         if (!strcmp(wordÝ1¨.str,"RC=0"))  {if (RC==0)  flagIF=YES;}
    else if (!strcmp(wordÝ1¨.str,"RC=4"))  {if (RC==4)  flagIF=YES;}
    else if (!strcmp(wordÝ1¨.str,"RC=8"))  {if (RC==8)  flagIF=YES;}
    else if (!strcmp(wordÝ1¨.str,"RC1=0")) {if (RC1==0) flagIF=YES;}
    else if (!strcmp(wordÝ1¨.str,"RC1=4")) {if (RC1==4) flagIF=YES;}
    else if (!strcmp(wordÝ1¨.str,"RC1=8")) {if (RC1==8) flagIF=YES;}
    else if (!strcmp(wordÝ1¨.str,"RC2=0")) {if (RC2==0) flagIF=YES;}
    else if (!strcmp(wordÝ1¨.str,"RC2=4")) {if (RC2==4) flagIF=YES;}
    else if (!strcmp(wordÝ1¨.str,"RC2=8")) {if (RC2==8) flagIF=YES;}
    else if (!strcmp(wordÝ1¨.str,"RC3=0")) {if (RC3==0) flagIF=YES;}
    else if (!strcmp(wordÝ1¨.str,"RC3=4")) {if (RC3==4) flagIF=YES;}
    else if (!strcmp(wordÝ1¨.str,"RC3=8")) {if (RC3==8) flagIF=YES;}
    else if (!strcmp(wordÝ1¨.str,"RC4=0")) {if (RC4==0) flagIF=YES;}
    else if (!strcmp(wordÝ1¨.str,"RC4=4")) {if (RC4==4) flagIF=YES;}
    else if (!strcmp(wordÝ1¨.str,"RC4=8")) {if (RC4==8) flagIF=YES;}
    else if (!strncmp(wordÝ1¨.str,"SQLCODE=",8) && wordÝ1¨.len>8 )
      {if (code==atoi(&wordÝ1¨.strÝ8¨)) flagIF=YES;}
    else { Xprintf(" \n*ERROR* Invalid IF syntax on '%s', "
           "Valid: RCÝn¨=0|4|8 (n=1-4) or SQLCODE=code\n",wordÝ1¨.str);
           Exit(8);}
    if ( (strcmp(wordÝ2¨.str,"DO")==EQUALS)
            &&  (wordÝ3¨.len==0)            )
    {
    // it is a IF ... DO;
      if ( (plastIFDO)&&(plastIFDO->flagÝ0¨=='N')) {
       plastIFDO->cntIF++;
       doneSTMNT=YES;
       return(NULL);
      }
      p = (cache*) malloc(sizeof(struct cache));
      if (p==NULL) Exit(999);
      p->back = plastIFDO;
      if (flagIF==YES) strcpy(p->flag,"Y");
      else             strcpy(p->flag,"N");
      plastIFDO=p;
      plastIFDO->cntIF=0;
      doneSTMNT=YES;
      if (flagIF==NO)
       Xprintf("*** False IF %s, statements bypassed till ENDIF\n",
                              wordÝ1¨.str);
      return(NULL);
    } else
    // it is a single IF
     if ( (plastIFDO)&&(plastIFDO->flagÝ0¨=='N') )
          { doneSTMNT=YES; return(NULL); }
     if (flagIF==YES) return(wordÝ2¨.ptr);
     Xprintf("*** False IF %s, statement bypassed\n",wordÝ1¨.str);
     doneSTMNT=YES;   return(NULL);

}
/*********************************************************************\
|
|  processENDIF() -- end of IF-DO block
|
\*********************************************************************/
void processENDIF(void) {
    if ( (plastIFDO)&&(plastIFDO->flagÝ0¨=='N')
        &&(plastIFDO->cntIF>0))
     plastIFDO->cntIF--;
     else getIFDO();
    doneSTMNT=YES;
}
/*********************************************************************\
|
|  processSKIP() -- go forward to a label
|
\*********************************************************************/
void processSKIP(void) {
 short rc=0;
    rc=extractLABEL(wordÝ1¨.str,wordÝ1¨.len,skipLABEL);
    if (rc!=0) {
     Xprintf(" \n*ERROR* Invalid %s syntax\n",wordÝ0¨.str);
     Exit(8);
    }
    doneSTMNT=YES;
}
/*********************************************************************\
|
|  checkforLABEL() -- check and process a label
|
\*********************************************************************/
short checkforLABEL(void) {
int n;
short i;
char *p;
short rc=0;
    if (BUFÝ0¨==' ' || BUFÝ1¨=='\0') return(NO);
    p=findword(BUF,1,n);
    if (p==NULL) return(NO);
    if (n==1) return(NO);
    if (pÝn-1¨!=':') return(NO);
    if (memchr(p,'\'',n)!=NULL) return(NO);
    if (skipLABELÝ0¨!='\0') skipLABELÝ0¨='\0';
    for (i=0;i<numLABEL;i++) {
     if ((arrayLABELÝi¨.labelÝ0¨!='\0') &&
         (memcmp(arrayLABELÝi¨.label,p,n)==EQUALS))
      { foundstackLABEL=ON; indexLABEL=i; break; }
    }
    return(YES);
}
/*********************************************************************\
|
|  extractLABEL() -- check and populate a label
|
\*********************************************************************/
short extractLABEL(char* str,short len, char* label) {

    if (str==NULL||len==0||len>20||label==NULL) return(1);
    memset(label,'\0',sizeof(skipLABEL));
    if (memchr(str,'\'',n)!=NULL) return(1);
    strncpy(label,str,len);
    if (labelÝlen-1¨!=':')
     labelÝlen¨=':';
    return(0);
}
/*********************************************************************\
|
|  processEXIT()
|
\*********************************************************************/
void processEXIT(void)  {                                       // $fnc$
         if (       wordÝ1¨.len==0 )          Exit(RC);
    else if (strcmp(wordÝ1¨.str,"0")==EQUALS) Exit(RC=0);
    else if (strcmp(wordÝ1¨.str,"1")==EQUALS) Exit(RC=1);
    else if (strcmp(wordÝ1¨.str,"2")==EQUALS) Exit(RC=2);
    else if (strcmp(wordÝ1¨.str,"3")==EQUALS) Exit(RC=3);
    else if (strcmp(wordÝ1¨.str,"4")==EQUALS) Exit(RC=4);
    else if (strcmp(wordÝ1¨.str,"5")==EQUALS) Exit(RC=5);
    else if (strcmp(wordÝ1¨.str,"6")==EQUALS) Exit(RC=6);
    else if (strcmp(wordÝ1¨.str,"7")==EQUALS) Exit(RC=7);
    else if (strcmp(wordÝ1¨.str,"8")==EQUALS) Exit(RC=8);
    else if (strcmp(wordÝ1¨.str,"RC")==EQUALS) Exit(RC);
    else if (strcmp(wordÝ1¨.str,"RC1")==EQUALS) Exit(RC1);
    else if (strcmp(wordÝ1¨.str,"RC2")==EQUALS) Exit(RC2);
    else if (strcmp(wordÝ1¨.str,"RC3")==EQUALS) Exit(RC3);
    else if (strcmp(wordÝ1¨.str,"RC4")==EQUALS) Exit(RC4);
  else { Xprintf(" \n*ERROR* Invalid syntax, valid 0-8,RCn\n");Exit(8);}
}
/*********************************************************************\
|
|  processPRINT()
|
\*********************************************************************/
void processPRINT(void) {
    if (strcmp(wordÝ1¨.str,"SQLERROR")==EQUALS)
    {SQLCODE=code;PrintSqlError("PRINT");}
    doneSTMNT=YES;
}
/*********************************************************************\
|
|  processSYSTEM()
|
\*********************************************************************/
void processSYSTEM() {                                          // $fnc$

  long rc=0;

   // Start timings
   cputime1 = CPUtime(0);
   tottime1 = TOTALtime(0);
   fflush(stdout);
   rc=system(wordÝ1¨.ptr);
   Xprintf("*** %s completed with RC = %d",wordÝ1¨.str,rc);
   if (rc>0) Xprintf(", (SYSRC=%d)",sysrc);
   Xprintf("\n");
   Xprintf("*** CPU time = %.4f seconds, TOTAL time = %d seconds\n",
              CPUtime(cputime1),TOTALtime(tottime1));
   if ((rc>sysrc)||(rc==-1)) Exit(12);
   RC=rc;
   doneSTMNT=YES;
}
#if defined(_AIX)
/*********************************************************************\
|
|  processDB2() -- Run a DB2 command (AIX)
|
\*********************************************************************/
void processDB2()    {                                          // $fnc$

  long rc=0;

   // Start timings
   cputime1 = CPUtime(0);
   tottime1 = TOTALtime(0);
   fflush(stdout);
   rc=system(wordÝ0¨.ptr);
   Xprintf("*** %s completed with RC = %d",wordÝ1¨.str,rc);
   if (rc>0) Xprintf(", (SYSRC=%d)",sysrc);
   Xprintf("\n");
   Xprintf("*** CPU time = %.4f seconds, TOTAL time = %d seconds\n",
              CPUtime(cputime1),TOTALtime(tottime1));
   if ((rc>sysrc)||(rc==-1)) Exit(12);
   RC=rc;
   doneSTMNT=YES;
}
#endif
#if defined(__MVS__)
/*********************************************************************\
|
|  processDB2() -- Run a DB2 command, not DSN (zOS)
|
\*********************************************************************/
void processDB2()    {                                          // $fnc$

  long rc=0;
 short int i;
 char *p=NULL;

   // Run a DB2 command
   rc=callIFI(wordÝ1¨.ptr);
   if (rc<=4) {
    datalen=80;
    if (action==actWRITE) openWRITE();
    for (i=1;;i++) {                  // Retrieve and output the report
     p=getIFIline(i,outBUF);
     if (p==NULL) break;
     if (p) outBUFrecord();
    }
   }
   if (rc>0) {
    Xprintf("*** %s completed with RC = %d",wordÝ1¨.str,rc);
    Xprintf(", (SYSRC=%d)\n",sysrc);
    if ((rc>sysrc)||(rc<0)) Exit(12);
   }
   if (action==actWRITE)
   Xprintf("*** Successful WRITE of %d record(s),"
           " RECFM=FB, LRECL=80\n",cntWRITE);
   RC=rc;
   doneSTMNT=YES;
}
#endif
#if defined(__MVS__)
/*********************************************************************\
|
|  callIFI() -- run a DB2 command via IFI interface
|               (based on SDSNSAMP(DSN8ED2))
\*********************************************************************/
int  callIFI(char* cmd) {

 short int len,i;
 long int report_bytes;
 char  *p;

   // Initialize the IFI parameters

   if (pi==NULL) pi = (ifca *) malloc( sizeof(ifca) );
   if (!pi) Exit(999);                 /* Point to IFCA structure    */

   memset(pi,'\0',sizeof(ifca));
   pi->len = sizeof(ifca);             /* Note length of IFCA area   */
   strcpy(pi->eye_catcher,"IFCA");     /* Initialize eye catcher     */
   strcpy(pi->owner_id,"LOC2");        /* DB2 Loc: 1=Local, 2=Remote */

   if (pr==NULL) pr = (return_area *) malloc( sizeof(return_area) );
   if (!pr) Exit(999);                 /* Point to IFCA structure    */
   memset(pr,' ',sizeof(return_area));
                                       /* Point to IFI return area   */
   pr->len = sizeof(return_area);      /* Length of return buffer    */

   if (po==NULL) po = (command_area *) malloc( sizeof(command_area) );
   if (!po) Exit(999);                 /* Point to IFI command area  */

   memset(po,' ',sizeof(command_area));
   po->len = strlen(cmd)+4;            /* Note length of command text*/
   strncpy(po->command,cmd,            /* Copy in command            */
    min(sizeof(command_area::command)-1,strlen(cmd)));

   // Make the IFI call via the DSNWLI macro

   dsnwli("COMMAND ",pi,pr,po );

  if (pi->reason!=0) {
    Xprintf(" *** IFI rc=%d\n",pi->rc);
    Xprintf(" *** IFI reason=%x\n",pi->reason);
    Xprintf(" *** IFI gotten bytes=%d\n",pi->gotten_bytes);
    Xprintf(" *** IFI lost bytes=%d\n",pi->lost_bytes);
    Xprintf(" *** IFI bufsize=%d\n",RETURN_LEN);
    for (i=1;;i++) {
     p=getIFIline(i,outBUF);
     if (p==NULL) break;
     Xprintf(" *** %s\n",outBUF);
    }
  }
  return(pi->rc);
}
#endif
#if defined(__MVS__)
/*********************************************************************\
|
|  getIFIline -- retrive i-th line from IFI buffer
|
\*********************************************************************/
char* getIFIline(int i,char* out) {
 short int len=0,j,k=0;
  long int report_bytes=pi->gotten_bytes;
  char    *p=pr->report;

   if (report_bytes<=0) return(NULL);

   for (k=1;((report_bytes>0)&&(k<i));k++) {
    p=p+len;
    memcpy(&len,p,2);
    report_bytes-=len;
   }
   if (k<i) return(NULL);
   memset(out,' ',80);
   memcpy(out,p+4,min(len,80));
   for (j=0;j<80;j++)
   { if ((*(out+j)=='\n')||(*(out+j)=='\t')) outÝj¨=' '; }
   outÝ80¨='\0';
   return(out);
}
#endif
/*********************************************************************\
|
|  processLOCK()
|
\*********************************************************************/
void  processLOCK() {                                           // $fnc$
#if defined(__MVS__)
  long rc=0;

  if ((strcmp(wordÝ1¨.str,"TABLE")!=EQUALS)||
      (strcmp(wordÝ2¨.str,"")==EQUALS)) return;
   getDBTSnames(wordÝ2¨.str);
   if (strlen(DBNAME)>0) {
    sprintf(cmdDIS,cmdDIStmpl,DBNAME,TSNAME);
    Xprintf("*** %s\n",cmdDIS);
    rc=callIFI(cmdDIS);
    displyTSstatus(0);
    fLOCK=YES;
   }
#endif
}
/*********************************************************************\
|
|  displyTSstatus() -- print out IFI buffer with TS lines
|
\*********************************************************************/
void displyTSstatus(int sqlcode) {
#if defined(__MVS__)
 short int i;
 char *p=NULL;
   // Retrieve and print out a TS report
   for (i=1;;i++) {
    p=getIFIline(i,outBUF);
    if (p==NULL) break;
    if (strncmp(outBUF+9,"TS  ",4)!=EQUALS) continue;
    if ((sqlcode==-911)&&
        (strncmp(outBUF+60,"H-IS,S",6)==EQUALS) ) continue;
    Xprintf("*** %s\n",outBUF);
//  fflush(stdout);
   }
#endif
}
#if defined(__MVS__)
/*********************************************************************\
|
|  processRUNSTATS()
|
\*********************************************************************/
void  processRUNSTATS() {                                       // $fnc$
char cmdÝ250¨;

  strcpy(cmd,wordÝ0¨.str);
  if (strcmp(wordÝ1¨.str,"TABLE")==EQUALS) {
   getDBTSnames(wordÝ2¨.str);
   sprintf(cmd,cmdRUNSTATStmpl,DBNAME,TSNAME,wordÝ2¨.str,wordÝ3¨.ptr);
   Xprintf("*** %s\n",cmd);
  } else {
   strcpy(cmd,wordÝ0¨.ptr);
  }
  runStatsTableSpace(pgmname,"",cmd);
//fflush(stdout);
  doneSTMNT=YES;
    rc=retCode;
     if (rc>0) {
      Xprintf("*** %s completed with RC = %d",wordÝ0¨.str,rc);
      Xprintf(", (SYSRC=%d)\n",sysrc);
      if ((rc>sysrc)||(rc<0)) Exit(12);
     }
}
/*********************************************************************\
|
|  runStatsTableSpace()
|
\*********************************************************************/
void runStatsTableSpace                // API for RUNSTATS TABLESPACE
   ( char          *iuId,               // Utility ID
     char          *irestart,           // Utility restart point
     char          *iutStmt             // Utility control statement
   )
{    DsnUtilsClearParms();
     strcpy(uId,iuId );
     strcpy(restart,irestart );
     strcpy(utility,"RUNSTATS TABLESPACE" );
     strcpy(utStmt,iutStmt );

     callDsnUtils();

}
/*********************************************************************\
|
|  callDsnUtils()
|
\*********************************************************************/
void callDsnUtils() {

       EXEC SQL
       CALL SYSPROC.DSNUTILS( :uId,      :restart,   :utStmt,
                              :retCode,  :utility,
                              :recDsn,   :recDevt,   :recSpace,
                              :discDsn,  :discDevt,  :discSpace,
                              :pnchDsn,  :pnchDevt,  :pnchSpace,
                              :copyDsn1, :copyDevt1, :copySpace1,
                              :copyDsn2, :copyDevt2, :copySpace2,
                              :rcpyDsn1, :rcpyDevt1, :rcpySpace1,
                              :rcpyDsn2, :rcpyDevt2, :rcpySpace2,
                              :workDsn1, :workDevt1, :workSpace1,
                              :workDsn2, :workDevt2, :workSpace2,
                              :mapDsn,   :mapDevt,   :mapSpace,
                              :errDsn,   :errDevt,   :errSpace,
                              :filtrDsn, :filtrDevt, :filtrSpace
                            );

       if( SQLCODE != 0  &&  SQLCODE != 466 )
       {processSQLCODE("CALL SYSPROC.DSNUTILS"); return;}

       EXEC SQL
         ASSOCIATE
         LOCATOR( :DsnUtils_rs_loc )
            WITH PROCEDURE SYSPROC.DSNUTILS;
       if( SQLCODE != 0  )
       {processSQLCODE("ASSOCIATE LOCATOR"); return;}

       EXEC SQL
       ALLOCATE DSNUTILS_RS_CSR
         CURSOR FOR RESULT SET :DsnUtils_rs_loc;
       if( SQLCODE != 0  )
       {processSQLCODE("ALLOCATE CURSOR"); return;}

       memset( text.data,'\0',254 );

       EXEC SQL
       FETCH DSNUTILS_RS_CSR
        INTO  :seqNo,
              :text;

       while( SQLCODE == 0 ) {
        strcpy(outBUF,text.data);
        outBUFrecord();
        memset( text.data,'\0',254 );

         EXEC SQL
           FETCH DSNUTILS_RS_CSR
            INTO  :seqNo,
                  :text;

       }

       if( SQLCODE != 0  &&  SQLCODE != 100 )
       {processSQLCODE("FETCH DSNUTILS_RS_CSR"); return;}

}
/*********************************************************************\
|
|  DsnUtilsClearParms()
|
\*********************************************************************/
void DsnUtilsClearParms() {
         memset( uId,      '\0'    ,17 );
         memset( restart,  '\0'    ,9 );
         memset( utStmt,   '\0'    ,32705 );
         retCode = 0;
         memset( utility,  '\0'    ,21 );

         memset( recDsn,   '\0'    ,45 );
         memset( recDevt,  '\0'    ,9 );
         recSpace = 0;

         memset( discDsn,  '\0'    ,45 );
         memset( discDevt, '\0'    ,9 );
         discSpace = 0;

         memset( pnchDsn,  '\0'    ,45 );
         memset( pnchDevt, '\0'    ,9 );
         pnchSpace = 0;

         memset( copyDsn1, '\0'    ,45 );
         memset( copyDevt1,'\0'    ,9 );
         copySpace1 = 0;

         memset( copyDsn2, '\0'    ,45 );
         memset( copyDevt2,'\0'    ,9 );
         copySpace2 = 0;

         memset( rcpyDsn1, '\0'    ,45 );
         memset( rcpyDevt1,'\0'    ,9 );
         rcpySpace1 = 0;

         memset( rcpyDsn2, '\0'    ,45 );
         memset( rcpyDevt2,'\0'    ,9 );
         rcpySpace2 = 0;

         memset( workDsn1, '\0'    ,45 );
         memset( workDevt1,'\0'    ,9 );
         workSpace1 = 0;

         memset( workDsn2, '\0'    ,45 );
         memset( workDevt2,'\0'    ,9 );
         workSpace2 = 0;

         memset( mapDsn,   '\0'    ,45 );
         memset( mapDevt,  '\0'    ,9 );
         mapSpace = 0;

         memset( errDsn,   '\0'    ,45 );
         memset( errDevt,  '\0'    ,9 );
         errSpace = 0;

         memset( filtrDsn, '\0'    ,45 );
         memset( filtrDevt,'\0'    ,9 );
         filtrSpace = 0;
}
/*********************************************************************\
|
| getDBTSnames() -- get DBNAME and TSNAME for a given table
|
\*********************************************************************/
void getDBTSnames(char* table) {
char *p;
  memset(DBNAME, '\0',sizeof(DBNAME));
  memset(TSNAME, '\0',sizeof(TSNAME));
  memset(NAME,   '\0',sizeof(NAME));
  memset(CREATOR,'\0',sizeof(CREATOR));
  p=strchr(table,'.');
  if (p==NULL) return;
  strncpy(CREATOR,table,min(p-table,sizeof(CREATOR)-1));
  strncpy(NAME,p+1,min(strlen(p+1),sizeof(NAME)-1));
  if (trace) Xprintf("*** CREATOR='%s', NAME='%s'\n",CREATOR,NAME);
        EXEC SQL
        SELECT DBNAME,TSNAME INTO :DBNAME,:TSNAME
          FROM SYSIBM.SYSTABLES
         WHERE CREATOR=:CREATOR AND NAME=:NAME;
//  if( SQLCODE != 0  )
//  {processSQLCODE("SELECT DBNAME,TSNAME FROM SYSTABLES"); return;}
    strip(DBNAME,'T');
    strip(TSNAME,'T');
}
#endif
/*********************************************************************\
|
| PREPROCESS_SQL_STMNT() -- recognize and process functional commands
|
\*********************************************************************/
void PREPROCESS_SQL_STMNT(void)                                 // $fnc$
{
 char *p;

     if (SQL.Len==0) { doneSTMNT=YES; return; }
 do {
     p=NULL;
     nwords=words(SQL.Str);
     getwords(SQL.Str,7,'U');
     strcpy(word1,wordÝ0¨.str);
          if ( strcmp(word1,"IF"     ) == EQUALS) p=processIF();
     else if ( strcmp(word1,"ENDIF"  ) == EQUALS)   processENDIF();
     else {
      if ((plastIFDO)&&(plastIFDO->flagÝ0¨=='N'))  doneSTMNT=YES;
      else if ( strcmp(word1,"EXEC"    ) == EQUALS) p=processEXEC();
      else if ( strcmp(word1,"CONNECT" ) == EQUALS)   processCONNECT();
      else if ( strcmp(word1,"SET"     ) == EQUALS) p=processSET();
      else if ( strcmp(word1,"RELEASE" ) == EQUALS) p=processRELEASE();
      else if ( strcmp(word1,"EXPLAIN" ) == EQUALS) p=processEXPLAIN();
      else if ( strcmp(word1,"WRITE"   ) == EQUALS) p=processWRITE();
      else if ( strcmp(word1,"READ"    ) == EQUALS) p=processREAD();
      else if ( strcmp(word1,"SAVE"    ) == EQUALS) p=processSAVE();
      else if ( strcmp(word1,"DDL"     ) == EQUALS)   processDDL();
      else if ( strcmp(word1,"INCLUDE" ) == EQUALS)   processINCLUDE();
      else if ( strcmp(word1,"STACK"   ) == EQUALS) p=processSTACK();
      else if (strncmp(word1,"RC"    ,2) == EQUALS)   processRC();
      else if ( strcmp(word1,"EXIT"    ) == EQUALS)   processEXIT();
      else if ( strcmp(word1,"END"     ) == EQUALS)   processEND();
      else if ( strcmp(word1,"SYSTEM"  ) == EQUALS)   processSYSTEM();
      else if ( strcmp(word1,"SYS"     ) == EQUALS)   processSYSTEM();
#if defined(__MVS__) || defined(_AIX)
      else if ( strcmp(word1,"DB2"     ) == EQUALS)   processDB2();
#endif
      else if ( strcmp(word1,"SAY"     ) == EQUALS)   processSAY();
      else if ( strcmp(word1,"ECHO"    ) == EQUALS)   processECHO();
#if defined(__MVS__)
      else if ( strcmp(word1,"RUNSTATS") == EQUALS)   processRUNSTATS();
      else if ( strcmp(word1,"LOCK"    ) == EQUALS)   processLOCK();
#endif
      else if ( strcmp(word1,"WHENEVER") == EQUALS)   processWHENEVER();
      else if ( strcmp(word1,"SKIP"    ) == EQUALS)   processSKIP();
      else if ( strcmp(word1,"GOTO"    ) == EQUALS)   processSKIP();
      else if ( strcmp(word1,"PRINT"   ) == EQUALS)   processPRINT();
      else if ( strcmp(word1,"DRAW"    ) == EQUALS)   processDRAW();
     }
     if (doneSTMNT) { SQL.Len=0; break; }
     if (p!=NULL)   { strcpy(SQL.Str,p); SQL.Len=strlen(SQL.Str); }

  } while((p!=NULL)&&(SQL.Len>0));

  if (SQL.Len==0)  doneSTMNT=YES;
  return;
}
/*********************************************************************\
|
|  parseColumnLength() -- create COLDATA array
|
\*********************************************************************/
void parseColumnLength(void) {                                  // $fnc$

 struct COLDATA *p;
 int i,m;

    if (SQLd==0) return;

    pCOLDATA= (struct COLDATA*) malloc(sizeof(struct COLDATA)*SQLd);
    if (pCOLDATA==NULL) Exit(999);

    memset(pCOLDATA,'\0',sizeof(struct COLDATA)*SQLd);

    for(i=0;i<SQLd;i++) {

      p=&pCOLDATAÝi¨;
      p->type=SQLTYPE(i);
      p->len=SQLLEN(i);

      if (i>0) datalen=datalen+strlen(dlm);

      switch (SQLTYPE(i)) {
        case sVCHAR:     case sVCHARn:
        case sLVCHAR:    case sLVCHARn:
           if (fASIS) p->clen=SQLLEN(i)+2+1;
           else p->clen=SQLLEN(i);
           p->width=p->clen+fCSV*2;
           p->align='L';
           break;
        case sCHAR:      case sCHARn:
           if (fASIS) p->clen=SQLLEN(i)+1;
           else p->clen=SQLLEN(i);
           p->width=p->clen+fCSV*2;
           p->align='L';
           break;
        case sVARBIN:    case sVARBINn:
           if (fASIS) p->clen=SQLLEN(i)+2+1;
           else p->clen=SQLLEN(i)*2;
           p->width=p->clen+fCSV*2;
           p->align='L';
           break;
        case sBIN:      case sBINn:
           if (fASIS) p->clen=SQLLEN(i)+1;
           else p->clen=SQLLEN(i)*2;
           p->width=p->clen+fCSV*2;
           p->align='L';
           break;
        case sDATE:      case sDATEn:
        case sTIME:      case sTIMEn:
        case sTIMESTAMP: case sTIMESTAMPn:
           if (fASIS) p->clen=SQLLEN(i)+1;
           else p->clen=SQLLEN(i);
           p->width=p->clen;
           p->align='C';
           break;
        case sFLOAT:     case sFLOATn:
           if (fASIS) p->clen=SQLLEN(i)+1;
           else p->clen=SQLLEN(i)*2+4;
           p->width=p->clen;
           p->align='C';
           break;
        case sBIGINT:    case sBIGINTn:
           if (fASIS) p->clen=SQLLEN(i)+1;
           else p->clen=19+signposFlag;
           p->width=p->clen;
           p->align='C';
           break;
        case sINT:       case sINTn:
           if (fASIS) p->clen=SQLLEN(i)+1;
           else p->clen=10+signposFlag;
           p->width=p->clen;
           p->align='C';
           break;
        case sSMINT:     case sSMINTn:
           if (fASIS) p->clen=SQLLEN(i)+1;
           else p->clen=5+signposFlag;
           p->width=p->clen;
           p->align='C';
           break;
        case sDEC:       case sDECn:
           parseDecSQLLEN(i);
           if (fASIS) p->clen=memory+1;
           else p->clen=prec+signposFlag+(scale>0);
           p->width=p->clen;
           p->align='C';
           break;
        case sDECFLOAT:  case sDECFLOATn:
           if (fASIS) p->clen=SQLLEN(i)+1;
           else if (SQLLEN(i)==8) p->clen=16+signposFlag+1; // ????
           else p->clen=34+signposFlag+1;                   // ????
           p->width=p->clen;
           p->align='C';
           break;
        default:
           Xprintf("\n \n*ERROR* Unsupported SQLTYPE=%d\n",SQLTYPE(i));
           Exit(8);
      } // switch
      datalen=datalen+p->width;
    }  // for
}
/*********************************************************************\
|
|  parseColumnNames() -- create COLNAME array
|
\*********************************************************************/
void parseColumnNames(void)  {                                  // $fnc$
 char *s,*e;
 struct COLNAME *p;
 int i,j;

    if (SQLd==0) return;

    colines=0;
    pCOLNAME= (struct COLNAME*) malloc(sizeof(struct COLNAME)*SQLd);
    if (pCOLNAME==NULL) Exit(999);
    memset(pCOLNAME,'\0',sizeof(struct COLNAME)*SQLd);

    for(i=0;i<SQLd;i++) {
      p=&pCOLNAMEÝi¨;
      strncpy(p->sqlname,SQLNAMED(i),30);
      s=strip(p->sqlname,'T');
      p->partmaxlen=0;

      for (j=0;j<15;j++) {
       p->partptrÝj¨=s;
       e=strchr(s,'_');
       if (e==NULL) break;
       p->partlenÝj¨=e-s;
       p->partmaxlen=Max(p->partmaxlen,p->partlenÝj¨);
       s=e+1;
      }

      e=strchr(s,'\0');
      p->partlenÝj¨=e-s;
      p->partmaxlen=Max(p->partmaxlen,p->partlenÝj¨);
      p->parts=j+1;
      colines=Max(colines,p->parts);
    }
}
/*********************************************************************\
|
|  openWRITE() -- open an output WRITE file
|
\*********************************************************************/
void openWRITE(void) {                                          // $fnc$
 char modeÝ81¨;

    lreclWRITE=datalen;
    if (fDATA||fLABEL) return;

#if defined(_WIN32) || defined(_AIX)
// Windows or AIX
    if (fAPPEND) {
     if (fASIS) strcpy(mode,"ab");
     else       strcpy(mode,"a");
    } else {
     if (fASIS) strcpy(mode,"wb");
     else       strcpy(mode,"w");
    }
#else
// zOS
    if (fAPPEND) {
     if (fASIS) strcpy(mode,"ab");
     else       sprintf(mode,modeMVSa,lreclWRITE);
    } else {
     if (fASIS) sprintf(mode,modeMVSwb,lreclWRITE);
     else       sprintf(mode,modeMVSw,lreclWRITE);
    }
#endif
    fpWRITE=fopen(fnWRITE,mode);
    if (fpWRITE==NULL) {
      Xprintf(" \n*ERROR* Open WRITE FILE %s with \"%s\" failed:\n"
             "%s\n", fnWRITE, mode, strerror(errno));
      Exit(8);
    }
}
/*********************************************************************\
|
|  openDISCARD() -- open an output DISCARD file
|
\*********************************************************************/
void openDISCARD(void) {                                        // $fnc$
 char modeÝ81¨;

#if defined(_WIN32) || defined(_AIX)
    if (fASIS) strcpy(mode,"wb");
    else       strcpy(mode,"w");
#else
    if (fASIS) sprintf(mode,modeMVSwb,lreclREAD);
    else       sprintf(mode,modeMVSw,lreclREAD);
#endif
    fpDISCARD=fopen(fnDISCARD,mode);
    if (fpDISCARD==NULL) {
      Xprintf(" \n*ERROR* Open DISCARD file %s with \"%s\" failed:\n"
             "%s\n", fnDISCARD, mode, strerror(errno));
      Exit(8);
    }
}
/*********************************************************************\
|
|  writeRecord() -- write out WRITE or DISCARD file record
|
\*********************************************************************/
long writeRecord(FILE *fp, char *fn, char *buf,// $fnc$
                 long *cnt,long lrecl) {                        // $fnc$
 long n;
    if (fASIS) n=fwrite(buf,1,lrecl,fp);
    else       n=fprintf(fp,"%s\n",buf);
    (*cnt)++;
    if (n<=0) {
      Xprintf(" \n*ERROR* Write file %s failed on record #%d:\n"
             "%s\n", fn, *cnt, strerror(errno));
      Xprintf("lrecl=%d, datalen=%d, lreclWRITE=%d, strlen(buf)=%d\n"
              "buf='%s'\n",
             lrecl,datalen,lreclWRITE,strlen(buf),buf);
      Exit(8);
    }
 return(n);
}
/*********************************************************************\
|
|  outBUFrecord() -- print/write/stack the outBUF
|
\*********************************************************************/
void outBUFrecord(void)  {                                      // $fnc$
 long n=0;
 struct stack *p;
 short i=indexLABEL;

   // SELECT
   if ((action==actSQL)||((action==actREAD)&&(fECHO==YES))) {
    Xprintf("%s\n",outBUF);
    return;
   }
   // WRITE
   if ((action==actWRITE)&&(fDATA==NO)&&(fLABEL==NO)) {
    n=writeRecord(fpWRITE,fnWRITE,outBUF,&cntWRITE,lreclWRITE);
    return;
   }
   // STACK
   if ((action==actSTACK)||(fDATA==YES)||(fLABEL==YES)) {
     if (fASIS) {
      p = (stack*) malloc(sizeof(struct stack)+datalen);
      if (p==NULL) Exit(999);
      p->len  = datalen;
      memcpy(p->data,outBUF,datalen);
     } else {
      p = (stack*) malloc(sizeof(struct stack)+strlen(outBUF));
      if (p==NULL) Exit(999);
      p->len  = strlen(outBUF);
      strcpy(p->data,outBUF);
     }
     p->next = NULL;
          if (fLIFO)  { plastLIFO->next=p;  plastLIFO=p;  eofLIFO=NO; }
     else if (fFIFO)  { plastFIFO->next=p;  plastFIFO=p;  eofFIFO=NO; }
     else if (fDATA)  { plastDATA->next=p;  plastDATA=p;  eofDATA=NO;
                        cntWRITE++;}
     else if (fLABEL) { arrayLABELÝi¨.plast->next=p;
                        arrayLABELÝi¨.plast=p;
                        eofLABEL=NO;
                        cntWRITE++;}
   }
}
/*********************************************************************\
|
|  printDashes() -- print out a line with column dashes
|
\*********************************************************************/
void printDashes(char *po,struct COLNAME *pn) {                 // $fnc$

    if (pCOLNAME==NULL) return;
    poÝ0¨='+'; po=po+1;
    for(i=0;i<SQLd;i++) {
      pn=&pCOLNAMEÝi¨;
      memset(po,'-',pn->width);
      po=po+pn->width;
      poÝ0¨='+'; po=po+1;
    }
    poÝ0¨='\0';
    outBUFrecord();
}
/*********************************************************************\
|
|  printColumnNames() -- print out column names (report header)
|
\*********************************************************************/
void printColumnNames(void)  {                                  // $fnc$
 struct COLNAME *pn;
 struct COLDATA *pd;
 char *po,*pj,*pw;
 int i,j,l;

    if (pCOLNAME==NULL) return;

    // set up widths of columns
    datalen=0;
    for(i=0;i<SQLd;i++) {
      pn=&pCOLNAMEÝi¨;
      pd=&pCOLDATAÝi¨;
      pn->width=Max(pn->partmaxlen,pd->width);
      pd->width=pn->width;
      if (pn->partmaxlen>pd->clen)
      pd->align='C';
      datalen=datalen+pn->width+strlen(dlm);
    }
    datalen++;
    if ((action==actWRITE)&&(fpWRITE==NULL)) openWRITE();
    // print out dashes
    printDashes(po=outBUF,pn);

    // print out column names
    for(l=0;l<colines;l++) {
      po=outBUF; poÝ0¨='|';po++;

      // loop for each column
      for(i=0;i<SQLd;i++) {
        pn=&pCOLNAMEÝi¨;
        pd=&pCOLDATAÝi¨;
        memset(po,' ',pn->width);

        if ((colines-(pn->parts))<=l) {
          j=l-(colines-pn->parts);
          pj=pn->partptrÝj¨;
          switch (pd->align) {
            case 'L':
             if (pn->partmaxlen<pn->width)
             pw=po+1; else pw=po;
             break;
            case 'R':
             pw=po+(pn->width)-(pn->partmaxlen);
             if (pn->partmaxlen<pn->width)
             pw=pw-1;
             break;
            case 'C':
             pw=po+((pn->width)-(pn->partmaxlen))/2;
             break;
            default: Exit(666);
          }
          strncpy(pw,pj,pn->partlenÝj¨);
        }
        po=po+pn->width;
        poÝ0¨='|'; po++;
      }
      poÝ0¨='\0';
      outBUFrecord();
    }
    // print out dashes
    printDashes(po=outBUF,pn);
}
/*********************************************************************\
|
|  checkint() -- check a string with a whole number
|
\*********************************************************************/
int checkint(char* p, short len, short maxn) {                  // $fnc$
 short n=0;
 char sign=' ';
   for (short i=0;i<len;i++) {
    switch (pÝi¨) {
      case ' ': if ((n==0)&&(sign==' ')) continue;
                else return(1);
      case '+': if ((n==0)&&(sign==' ')) {sign='+'; continue;}
                else return(2);
      case '-': if ((n==0)&&(sign==' ')) {sign='-'; continue;}
                else return(3);
      default:
        if ((pÝi¨=='0')&&(n==0)) {sign='x'; continue;}
        if ((pÝi¨<'0')||(pÝi¨>'9')) return(5);
        if (++n>maxn)               return(6);
    }
   }
   return(0);
}
/*********************************************************************\
|
|  checkdatetime() -- check a string with date/time/timestamp
|
\*********************************************************************/
int checkdatetime(char* p, short len) {                         // $fnc$

   for (short i=0;i<len;i++) {
    switch (pÝi¨) {
      case '.':  continue;
      case '-':  continue;
      case '/':  continue;
      case ':':  continue;
      default:
        if ((pÝi¨<'0')||(pÝi¨>'9')) return(5);
    }
   }
   return(0);
}
/*********************************************************************\
|
|  checkfloat() -- check a string with a float number
|
\*********************************************************************/
int checkfloat(char* p) {                                       // $fnc$
 short n=0,e=0,d=0;
 char sign=' ';
   for (short i=0;i<strlen(p);i++) {
    switch (pÝi¨) {
      case ' ': if ((n==0)&&(sign==' '))
                { continue;}                 else return(1);
      case '+': if ((sign==' ')&&((n==0)||(e==1)))
                {sign='x'; continue;}        else return(2);
      case '-': if ((sign==' ')&&((n==0)||(e==1)))
                {sign='x'; continue;}        else return(3);
      case '.': if (d==0)
                {d++ ; continue;}            else return(4);
      case 'e':
      case 'E': if (e==0)
                {sign=' ';++e;++n;continue;} else return(5);
      default:
                if (n==0) {sign='x';}
                if ((pÝi¨<'0')||(pÝi¨>'9'))       return(6);
                n++;
    }
   }
   if (n==0) return(7);
   return(0);
}
/*********************************************************************\
|
|  char2dec() -- convert char decimal to binary packed decimal
|
\*********************************************************************/
int  char2dec(char* sqldata,char* inbuf,short inlen)            // $fnc$
{
 unsigned char sign='\0';
 short whole=prec-scale;
 short memlen=memory;                            // size of memory
 short i;
 unsigned char *p=(unsigned char*)inbuf;
 unsigned char packdecÝ17¨;
 short iprec=0,iscale=-1;

    memset(packdec,'\0',sizeof(packdec));        // for packed digits
    memset(sqldata,'\0',memlen);                 // output buffer

    for (i=0;i<inlen;i++) {
      switch (pÝi¨) {
       case ' ': if (iprec==0)   continue;          else return(1);
       case '+': if (sign=='\0') {sign=0x0C;break;} else return(2);
       case '-': if (sign=='\0') {sign=0x0D;break;} else return(3);
       case '.': if (iscale==-1) {iscale=0; break;} else return(4);
       default:
        if ((pÝi¨<'0')||(pÝi¨>'9'))                      return(5);
        if ((pÝi¨=='0')&&(iprec==0)) continue;
        if ((++iprec>whole)&&(iscale==-1))               return(6);
        if ((iscale>-1)&&(++iscale>scale)) continue;
        shift4bits(packdec,16);
        packdecÝ15¨=(packdecÝ15¨)|(pÝi¨&0x0F);
      } // switch
    } // for
    if (iscale==-1) iscale=0;
    for (i=iscale;(i<scale)&&(++iprec<prec);i++) {
      shift4bits(packdec,16);
    }
    if (sign=='\0') sign=0x0c;
    shift4bits(packdec,16);
    packdecÝ15¨=packdecÝ15¨|sign;
    memcpy(sqldata,packdec+16-memlen,memlen);
    return(0);
}
/*********************************************************************\
|
|  shift4bits() -- shift a string to left on 4 bits
|
\*********************************************************************/
void  shift4bits(unsigned char *p,short len) {           // $fnc$
 for (int i=0;i<len;i++) {
     pÝi¨=(pÝi¨<<4)|((pÝi+1¨)>>4);
 }
}
/*********************************************************************\
|
|  dec2char() -- convert packed decimal to char formated number
|
\*********************************************************************/
void dec2char(char* sqldata,char* outbuf,short outlen)          // $fnc$
{
  unsigned char byte,sign;
 short i,j,k=0,jp;

    j=outlen-1;                                  // blank out
    memset(outbuf,' ',j);                        // the output buffer
    outbufÝj¨='\0';                              // add end of line
    j--;                                         // position for char
    jp=j;                                        // default for leading
                                                 // zeroes
    for (i=memory-1;i>=0;i--) {                  // unpack dec digits
      byte = sqldataÝi¨;                         // from last to first
      if (k==0) sign=((byte<<4)>>4)|0xF0;        // remember a sign
      else {                                     // add a decimal point
       if ((scale>0)&&(k==scale)) {outbufÝj--¨='.'; jp=j;}
       outbufÝj--¨=byte & 0x0F | '0';            // unpack a low digit
       k++;
      }                                          // add a decimal point
      if ((scale>0)&&(k==scale)) {outbufÝj--¨='.'; jp=j;}
      outbufÝj--¨=(byte>>4)|'0';                 // unpack a high digit
      k++;
    }
    // replace leading zeroes with blanks
    for (i=j+1;i<jp;i++) {                       // start from last
     if (outbufÝi¨!='0') break;                  // first non-0 found
     else {outbufÝi¨=' '; j++;}                  // j is a pos for sign
    }

    if (sign==0xFd) outbufÝj¨='-';               // add a minus sign
}
/*********************************************************************\
|
|  printC1rows()-- build output records from the fetched rows
|
\*********************************************************************/
void printC1rows(short n) {                                     // $fnc$
 short i,k;
  char *p1;
  char *po,*pw;
 short *p2;
  char cbufÝ34¨;
struct COLDATA *pd;
 short m,z;

   // process all fetched multi rows
   for(k=0;k<n;k++) {
    po=outBUF;
    if ( (action==actSQL)||((action==actWRITE)&&(fRPT==YES)) )
     { poÝ0¨='|';po++;}

    // process each column
    for(i=0;i<SQLd;i++) {
     p1=SQLDATA(i)+SQLLEN(i)*k;
     p2=SQLIND(i)+k;
     pd=&pCOLDATAÝi¨;
     memset(po,' ',pd->width);
     pw=po;

     // process NULL value
     if ((!fASIS)&(*p2<0)) {
        pw=po+(pd->width)/2;
       *pw=nullchar;
     } else
     // process not NULL value  or ASIS
     switch (SQLTYPE(i)) {

      case sCHAR:      case sCHARn:
           if (fASIS) { memcpy(po,(char*)p2+1,1);
                        memcpy(po+1,p1,SQLLEN(i)); break;}
           for (z=0;z<pd->clen;z++) if (isprint(p1Ýz¨)==0) p1Ýz¨=' ';
           if (fCSV) {
             poÝ0¨='"'; pw=po+1;
             for (z=0;z<pd->clen;z++) {
              if (p1Ýz¨=='"') p1Ýz¨='\'';   // replace double to single
             }
             strncpy(pw,p1,pd->clen);
             pw=pw+pd->clen; pwÝ0¨='"';
           } else {
           if (pd->align=='C')
              pw=po+((pd->width)-(pd->len))/2;
             strncpy(pw,p1,pd->clen);
           }
           break;
      case sBIN:       case sBINn:
           if (fASIS) { memcpy(po,(char*)p2+1,1);
                        memcpy(po+1,p1,SQLLEN(i)); break;}
           if (fCSV) {
             poÝ0¨='"'; pw=po+1;
             strUXcpy(pw,p1,SQLLEN(i));
             pw=pw+pd->clen; pwÝ0¨='"';
           } else {
           if (pd->align=='C')
              pw=po+((pd->width)-(pd->len))/2;
             strUXcpy(pw,p1,SQLLEN(i));
           }
           break;

      case sDATE:      case sDATEn:
      case sTIME:      case sTIMEn:
      case sTIMESTAMP: case sTIMESTAMPn:
           if (fASIS) { memcpy(po,(char*)p2+1,1);
                        memcpy(po+1,p1,SQLLEN(i)); break;}
           if (pd->align=='C')
             pw=po+((pd->width)-(pd->len))/2;
           strncpy(pw,p1,pd->clen);
           break;

      case sLVCHAR:    case sLVCHARn:
      case sVCHAR:     case sVCHARn:
           if (multiRows>1) m=SQLLEN(i)%2; else m=0;
           p1=SQLDATA(i)+(SQLLEN(i)+sizeof(short)+m)*k;
           if (fASIS) { memcpy(po,(char*)p2+1,1);
                        memcpy(po+1,p1,SQLLEN(i)+2); break;}
           for (z=0;z<*(short*)p1;z++)
            if (isprint(p1Ýz+2¨==0)) p1Ýz+2¨=' ';
           if (fCSV) {
            poÝ0¨='"'; pw=po+1;
            for (z=0;z<*(short*)p1;z++) {
             if (p1Ýz+2¨=='"') p1Ýz+2¨='\''; // replace double to single
            }
            strncpy(pw,p1+2,*(short*)p1);
            pw=pw+*(short*)p1; pwÝ0¨='"';
           } else {
            strncpy(po,p1+2,*(short*)p1);
           }
           break;

      case sVARBIN:     case sVARBINn:
           if (multiRows>1) m=SQLLEN(i)%2; else m=0;
           p1=SQLDATA(i)+(SQLLEN(i)+sizeof(short)+m)*k;
           if (fASIS) { memcpy(po,(char*)p2+1,1);
                        memcpy(po+1,p1,SQLLEN(i)+2); break;}
           if (fCSV) {poÝ0¨='"'; pw=po+1;}
           strUXcpy(pw,p1+2,*(short*)p1);
           if (fCSV) {pw=pw+*(short*)p1*2; pwÝ0¨='"';}
           break;

      case sFLOAT:     case sFLOATn:
           if (fASIS) { memcpy(po,(char*)p2+1,1);
                        memcpy(po+1,p1,SQLLEN(i)); break;}
           if (SQLLEN(i)==4)
           sprintf(cbuf,"%8.5e\0",*(float*)p1);
           else
           sprintf(cbuf,"%16.13e\0",*(double*)p1);
           pw=po+(pd->width)-strlen(cbuf);
           strncpy(pw,cbuf,strlen(cbuf));
           break;

      case sBIGINT:    case sBIGINTn:
           if (fASIS) { memcpy(po,(char*)p2+1,1);
                        memcpy(po+1,p1,SQLLEN(i)); break;}
           sprintf(cbuf,"%20lld\0",*(long long int*)p1);
           pw=po+((pd->width)-(pd->clen))/2;
           strncpy(pw,cbuf+strlen(cbuf)-(pd->clen),pd->clen);
           break;

      case sINT:       case sINTn:
           if (fASIS) { memcpy(po,(char*)p2+1,1);
                        memcpy(po+1,p1,SQLLEN(i)); break;}
           sprintf(cbuf,"%11d\0",*(int*)p1);
           pw=po+((pd->width)-(pd->clen))/2;
           strncpy(pw,cbuf+strlen(cbuf)-(pd->clen),pd->clen);
           break;

      case sSMINT:     case sSMINTn:
           if (fASIS) { memcpy(po,(char*)p2+1,1);
                        memcpy(po+1,p1,SQLLEN(i)); break;}
           sprintf(cbuf,"%6d\0",*(short*)p1);
           pw=po+((pd->width)-(pd->clen))/2;
           strncpy(pw,cbuf+strlen(cbuf)-(pd->clen),pd->clen);
           break;

      case sDEC:       case sDECn:
           parseDecSQLLEN(i);
           p1=SQLDATA(i)+memory*k;
           if (fASIS) { memcpy(po,(char*)p2+1,1);
                        memcpy(po+1,p1,memory); break;}
           dec2char(p1,cbuf,sizeof(cbuf));
           pw=po+((pd->width)-(pd->clen))/2;
           strncpy(pw,cbuf+sizeof(cbuf)-1-pd->clen,pd->clen);
           break;

      case sDECFLOAT:  case sDECFLOATn:                     // ??????
           if (fASIS) { memcpy(po,(char*)p2+1,1);
                        memcpy(po+1,p1,SQLLEN(i)); break;}
           Xprintf("\n \n*RESTRICTION* Use CHAR function to convert"
                  " DECFLOAT datatype to character string\n");
                  Exit(8);
      default:
      Xprintf(" \n*ERROR* Unsupported SQLTYPE=%d\n",SQLTYPE(i));
      Exit(8);
    } // switch
    po=po+pd->width;
    strcpy(po,dlm);                    // NODLM has a null delimeter
    po=po+strlen(dlm);
   } // for i
   po=po-strlen(dlm);
   if ( (action==actSQL)||((action==actWRITE)&&(fRPT==YES)) )
   {poÝ0¨='|';po++;}
   poÝ0¨='\0';
   outBUFrecord();
  } // for k
  if (eofC1)
  printDashes(outBUF,pCOLNAME);
}
/*********************************************************************\
|
|  freeSQLDA() -- free SQLDATA & SQLIND arrays, close files
|
\*********************************************************************/
void freeSQLDA(void) {                                          // $fnc$
 int i;
   if ((action==actREAD)&&(multiRows>1)) SQLd--;
   for(i=0;i<SQLd;i++) {
    free(SQLDATA(i));
    SQLDATA(i)=NULL;
    free(SQLIND(i));
    SQLIND(i)=NULL;
   }
   SQLd=0;
   if (pCOLNAME)  {free(pCOLNAME);    pCOLNAME=NULL; }
   if (pCOLDATA)  {free(pCOLDATA);    pCOLDATA=NULL; }
   if (fpWRITE)   {fclose(fpWRITE);   fpWRITE=NULL;  }
   if (fpREAD)    {fclose(fpREAD);    fpREAD=NULL;   }
   if (fpDISCARD) {fclose(fpDISCARD); fpDISCARD=NULL;}
   if (fpNETRC)   {fclose(fpNETRC);   fpNETRC=NULL;  }
}
/*********************************************************************\
|
|  allocSQLVARarrays() -- set SQLDA fields
|
\*********************************************************************/
void allocSQLVARarrays(short n)  {                              // $fnc$
 short i,m;
 struct bytes18 {
    int byte14;
  short byte56;
  short byte78;
 } dw;
 char *p1;
 short *p2;
 dw.byte14=0x00000000;dw.byte56=0x0001;dw.byte78=n;

   if (trace) printSQLDA();
   for(i=0;i<SQLd;i++) {
    switch (SQLTYPE(i)) {
      case sCHAR:      case sCHARn:
      case sBIN:       case sBINn:
      case sDATE:      case sDATEn:
      case sTIME:      case sTIMEn:
      case sTIMESTAMP: case sTIMESTAMPn:
      case sFLOAT:     case sFLOATn:
      case sINT:       case sINTn:
      case sSMINT:     case sSMINTn:
      case sBIGINT:    case sBIGINTn:
      case sDECFLOAT:  case sDECFLOATn:
           p1 = (char *) malloc(SQLLEN(i)*n);
           if (fASIS) maxpos+=SQLLEN(i)+1;
           break;
      case sVARBIN:    case sVARBINn:
      case sVCHAR:     case sVCHARn:
      case sLVCHAR:    case sLVCHARn:
           if (multiRows>1) m=SQLLEN(i)%2; else m=0;
           p1 = (char *) malloc((SQLLEN(i)+2+m)*n);
           if (fASIS) maxpos+=SQLLEN(i)+2+1;
           break;
      case sDEC:       case sDECn:
           parseDecSQLLEN(i);
           p1 = (char *) malloc(memory*n);
           if (fASIS) maxpos+=memory+1;
           break;
      default:
      Xprintf(" \n*ERROR* Unsupported SQLTYPE=%d, SQLNAME=%s\n",
              SQLTYPE(i),SQLNAMED(i));
      Exit(8);
    } // switch
    p2 = (short *) malloc(sizeof(short)*n);
    if ((p1==NULL)||(p2==NULL)) Exit(999);
    memset(p2,'\0',sizeof(short)*n);
    SQLDATA(i)=p1;
    SQLIND(i)=p2;
       if (n>1) {
       memcpy(SQLNAMED(i),&dw,8);
       SQLNAMEL(i)=8; }
   } // for
       if ((action==actREAD)&&(n>1)) {
        i=SQLd;
        SQLd++;
        SQLTYPE(i)=sSMINT;
        SQLLEN(i)=2;
        dw.byte14=0x00000000;dw.byte56=0x0002;dw.byte78=0x0000;
        memcpy(SQLNAMED(i),&dw,8);
        SQLDATA(i)=(char*)&builtRows;
        SQLNAMEL(i)=8;
       }
// if (trace) printSQLDA();
}
/*********************************************************************\
|
|  executeSELECT() -- execute a SELECT statement
|
|     Using a multiple-row FETCH statement with a descriptor
|
|      1. Declare an SQLDA structure.
|      2. Dynamically allocate the SQLDA and the necessary arrays
|         for the column values.
|      3. Set the fields in the SQLDA for the column values that
|         are to be retrieved.
|      4. Open the cursor.
|      5. Fetch the rows.
|
\*********************************************************************/
void executeSELECT(void) {                                      // $fnc$

   parseColumnLength();
   if ( (action==actSQL)||((action==actWRITE)&&(fRPT)) )
   parseColumnNames();

   if ( (action==actSQL)||((action==actWRITE)&&(fRPT)) )
   printColumnNames();

   if ((action==actWRITE)&&(fpWRITE==NULL))
   openWRITE();

   allocSQLVARarrays(multiRows);

       if (multiRows>1)
       EXEC SQL OPEN C1;
       else
       EXEC SQL OPEN C2;

       if  (SQLCODE)  processSQLCODE("OPEN CURSOR");
       if  (SQLCODE)  return;
   eofC1=NO;
   rowsC1=0;

   do {
       if (multiRows>1)
       EXEC SQL FETCH
                   NEXT ROWSET
                   FROM C1
                   FOR :multiRows ROWS
                   INTO
                   DESCRIPTOR :*pSQLDA;
       else
       EXEC SQL FETCH
                   FROM C2
                   INTO
                   DESCRIPTOR :*pSQLDA;

       if  (SQLCODE==100) eofC1=YES;
       else {if  (SQLCODE)  processSQLCODE("FETCH CURSOR");
             if  (SQLCODE)  return;}
       if (multiRows>1);
       else if (eofC1) SQLERRD3=0; else SQLERRD3=1;
       if (trace) Xprintf(" trace: SQLERRD3=%d\n",SQLERRD3);
       rowsC1=rowsC1+SQLERRD3;
       printC1rows(SQLERRD3);

   } while (eofC1==NO);

       if (multiRows>1)
       EXEC SQL CLOSE C1;
       else
       EXEC SQL CLOSE C2;
       if (SQLCODE) processSQLCODE("CLOSE CURSOR");
       if (SQLCODE) return;

   if (Max(rowsC1,cntWRITE)>0) {
   if (action==actWRITE)
   {Xprintf("*** Successful WRITE of %d record(s),"
           " RECFM=FB, LRECL=%d\n",cntWRITE,lreclWRITE);RC=0;}
    else
    {Xprintf("*** Successful retrieval of %d row(s)\n",rowsC1);RC=0;}
   }
   else {
    Xprintf("*** Empty selection, RC=4\n");
    RC=4;
   }
}
/*<READ>**************************************************************\
|
|  fillCOLPOSarray() -- generate positions for VALUES(*);
|
\*********************************************************************/
int fillCOLPOSarray(char *ps) {                                 // $fnc$
 struct COLPOS *pc;
   char *pe,*pw,*pf=ps;
   char wdlm=dlmÝ0¨;
  short i,m;

    maxpos=0;
    if (multiRows>1) m1=1; else m1=0;

    for(i=0;i<SQLd-m1;i++,maxpos+=pc->len) {

      pc=&pCOLPOSÝi¨;
      pc->start=ps-pf+1;
      if (i+1==SQLd-m1) wdlm='\0';
      pw=ps;

      // start ASIS
      if (fASIS) {
       switch (SQLTYPE(i)) {
        case sVCHAR:  case sVCHARn:
        case sLVCHAR: case sLVCHARn:
        case sVARBIN: case sVARBINn:
         pc->mlen=SQLLEN(i)+2;
         break;
        case sDEC: case sDECn:
         parseDecSQLLEN(i);
         pc->mlen=memory;
         break;
        default:
         pc->mlen=SQLLEN(i);
       }
       pc->len=pc->mlen+1;               // 1 is for NULL indicator
       ps=ps+pc->len;
       continue;
      } // end ASIS

      // start CSV
      if ((fCSV)&&(psÝ0¨=='\"')) {
       if ((pe=strchr(ps+1,'\"'))==NULL) return(i+1);
       pw=pe+1;
      } // end CSV

      if ((pe=strchr(pw,wdlm))==NULL) return(i+1);
      pc->len=pe-ps;
      ps=pe+1;
      if (wdlm==' ') while (psÝ0¨==' ') ps++;
    }
    // print out generated positions
    if (trace) {
     for (i=0;i<SQLd-m1;i++) {
      pc=&pCOLPOSÝi¨;
      if (i==0) Xprintf("*** VALUES(");
      Xprintf("%d.%d",pc->start,pc->len);
      if (i+1<SQLd-m1) Xprintf(","); else Xprintf(")/n");
     }
    }
    return(0);
}
/*<READ>**************************************************************\
|
|  loadSQLDATAarrays() -- read a READ file and populate SQLDATA arrays
|
\*********************************************************************/
void loadSQLDATAarrays(void) {                                  // $fnc$
  short i,j,k,l,m,*pi,w;
   long nn;
    int n,len;
 struct COLPOS *pc;
   char *po,*pd,*pw;
   char char_save;

   if (multiRows>1) m1=1; else m1=0;

   // read a group of input records
   for(k=0;k<multiRows;k++) {
    // from STACK DATA
    if (fDATA) {
     lreclREAD=getDATA(outBUF);
     if (trace) Xprintf(" getDATA(outBUF)='%s'\n",outBUF);
     eofREAD=eofDATA;
     if (eofREAD==NO) cntREAD++;
     rc=0;
    } else
    // from STACK LABEL
    if (fLABEL) {
     lreclREAD=getLABEL(outBUF);
     if (trace) Xprintf(" getLABEL(outBUF)='%s'\n",outBUF);
     eofREAD=eofLABEL;
     if (eofREAD==NO) cntREAD++;
     rc=0;
    } else {
    // from FILE
     if (fASIS) {
      if (lreclREAD==0) lreclREAD=maxpos;
      rc=freadbin(fnREAD,&fpREAD,(char*)&outBUF,          // binary
                  lreclREAD,&eofREAD,&cntREAD,msg);
     } else {
      rc=freadtxt(fnREAD,&fpREAD,(char*)&outBUF,           // text
                 sizeof(outBUF),&eofREAD,&cntREAD,msg);
      if (eofREAD==NO) lreclREAD=strlen(outBUF);
     }
    }
    if (rc!=0) { Xprintf("\n \n%s\n",msg); Exit(12); }
    if (fECHO) return;
    if (eofREAD==YES) break;
    readRows++;

    // populate COLPOS array for VALUES(*) or
    // repopulate when CSV & #SET EXCEL ON is specified
    if ((pCOLPOS->start==0)||((excelFlag)&&(fCSV))||(!fixposFlag)) {
     rc=fillCOLPOSarray(outBUF);

     if (rc>0) {
      Xprintf(" \n*ERROR* Missing delimeter found, "
             "field #%d, record #%d\n",rc,cntREAD);
      Xprintf("'%s'\n",outBUF);
      Exit(8);
     }
    }
    if ((fASIS==NO)&&(maxpos>strlen(outBUF))) {  // add trailing blanks
     memset(outBUF+strlen(outBUF),' ',maxpos-strlen(outBUF));
     outBUFÝmaxpos¨='\0';
     lreclREAD=strlen(outBUF);
    }

   // process all fields on a record
    for(i=0;i<SQLd-m1;i++) {       // bypass the last special entry
     pd=SQLDATA(i)+SQLLEN(i)*k;            // current SQLDATA entry
     pi=SQLIND(i)+k;                       // current SQLIND entry
     pc=&pCOLPOSÝi¨;                       // current COLPOS entry
     po=outBUF+pc->start-1;                // current input field
     l=pc->len;                            // and its length

     // process null char value first
     // if --#SET LOADNULL ON
     if ((fASIS==NO)&&(loadnullFlag==ON)) {
      pw=findword(po,1,n);
      if ( (pw!=NULL) && (pwÝ0¨==nullchar) &&
          ((n==1) || (pw-po+1==l)) ) {        // for "?," word
       *pi=-1;continue;}
     }

     // if READ ASIS specified:
     if (fASIS==YES) {
      if (poÝ0¨=='\0') *pi=0; else *pi=-1;    // set the null indicator
      m=0;
       switch (SQLTYPE(i)) {
        case sVCHAR:  case sVCHARn: case sLVCHAR: case sLVCHARn:
        case sVARBIN: case sVARBINn:
         if (multiRows>1) m=SQLLEN(i)%2;
        default: break;
       }
      pd=SQLDATA(i)+(pc->mlen)*k+k*m;         // ptr to SQLDATA entry
      memcpy(pd,po+1,pc->mlen);               // fill in it
      continue;                               // work is done
     } // fASIS

     // process not null char value
     *pi=0;                                   // not null indicator
     switch (SQLTYPE(i)) {

      case sDATE:      case sDATEn:
      case sTIME:      case sTIMEn:
      case sTIMESTAMP: case sTIMESTAMPn:
           if (rc=checkdatetime(po,l)) break;
           memset(pd,' ',SQLLEN(i));
           strncpy(pd,po,min(SQLLEN(i),l));
           break;

      case sCHAR:      case sCHARn:
           memset(pd,' ',SQLLEN(i));
           if ((fCSV)&&(poÝ0¨=='\"')&&(poÝl-1¨=='\"'))
           { l=l-2; po++; }
           strncpy(pd,po,min(SQLLEN(i),l));
           break;

      case sVCHAR:     case sVCHARn:
      case sLVCHAR:    case sLVCHARn:
           if (multiRows>1) m=SQLLEN(i)%2; else m=0;
           pd=SQLDATA(i)+(SQLLEN(i)+sizeof(short)+m)*k;
           memset(pd,'\0',SQLLEN(i)+sizeof(short)+m);
           if ((fCSV)&&(poÝ0¨=='\"'))
           { l--;po++; for (j=l;((j>0)&&(poÝj-1¨==' '));j--);
             if (poÝj-1¨=='\"') j--;
           } else
           for (j=l; ((j>0)&&(poÝj-1¨==' '));j--);
           j=min(SQLLEN(i),j);
           memcpy(pd,&j,sizeof(j));
           pd+=2;
           strncpy(pd,po,j);
           break;

      case sVARBIN:    case sVARBINn:
           if (multiRows>1) m=SQLLEN(i)%2; else m=0;
           pd=SQLDATA(i)+(SQLLEN(i)+sizeof(short)+m)*k;
           memset(pd,'\0',SQLLEN(i)+sizeof(short)+m);
           if ((fCSV)&&(poÝ0¨=='\"'))
           { l--;po++; for (j=l;((j>0)&&(poÝj-1¨==' '));j--);
             if (poÝj-1¨=='\"') j--;
           } else
           for (j=l; ((j>0)&&(poÝj-1¨==' '));j--);
           w=(j+1)/2;
           if (w>SQLLEN(i)) {rc=1; break;}
           memcpy(pd,&w,sizeof(short));
           pd+=2;
           rc=strPXcpy(pd,po,j);
           break;

      case sBIN:       case sBINn:
           memset(pd,'\0',SQLLEN(i));
           if ((fCSV)&&(poÝ0¨=='\"')&&(poÝl-1¨=='\"'))
           { l=l-2; po++; }
           w=(l+1)/2;
           if (w>SQLLEN(i)) {rc=1;  break;}
           rc=strPXcpy(pd,po,l);
           break;

      case sFLOAT:     case sFLOATn:
           strncpy(word2,po,min(l,sizeof(word2)-1));
           word2Ýmin(l,sizeof(word2)-1)¨='\0';
           if (rc=checkfloat(word2)) break;
           if (SQLLEN(i)==4)
           *(float*)pd=atof(word2);
           else
           *(double*)pd=atof(word2);
           break;

      case sINT:       case sINTn:
      case sSMINT:     case sSMINTn:
      case sBIGINT:    case sBIGINTn:
           if (SQLLEN(i)==8) rc=checkint(po,l,19);
           else
           if (SQLLEN(i)==4) rc=checkint(po,l,10);
           else              rc=checkint(po,l,5);
           if (rc) break;
           strncpy(word2,po,min(l,sizeof(word2)-1));
           word2Ýmin(l,sizeof(word2)-1)¨='\0';
           if (SQLLEN(i)==8)
            *(long long int*)pd=atoi(word2);
           else
           if (SQLLEN(i)==4)
            *(int*)pd=atoi(word2);
           else
            *(short*)pd=atoi(word2);
           break;

      case sDEC:       case sDECn:
           parseDecSQLLEN(i);
           pd=SQLDATA(i)+memory*k;
           if (fCSV) for (;(l>0)&&(poÝl-1¨==' ');l--);
           rc=char2dec(pd,po,l);
           break;
      case sDECFLOAT:       case sDECFLOATn:
           Xprintf(" \n*RESTRICTION* DECFLOAT is not supported yet\n");
           Exit(8);
      default:
           Xprintf(" \n*ERROR* Unsupported SQLTYPE=%d\n",SQLTYPE(i));
           Exit(8);
    } // switch
    if (rc>0) {
     char_save=poÝpc->len¨;
     poÝpc->len¨='\0';
     if (fDISCARD) {
       Xprintf("*** discard #%d, field %d (%d.%d, %s),"
              " invalid value='%s'\n",
             cntREAD,i+1,pc->start,pc->len,pc->sqlname,po);
       k--;
       if (fDISCARDfn) {
         if (fpDISCARD==NULL) openDISCARD();
         poÝpc->len¨=char_save;
         nn=writeRecord(fpDISCARD,fnDISCARD,outBUF,
                        &cntDISCARD,lreclREAD);
       } else cntDISCARD++;
       break;
     } else {
      outBUFÝpc->start+pc->len-1¨='\0';
      po=&outBUFÝpc->start-1¨;
      Xprintf(" \n*ERROR%d* Invalid input field #%d on record #%d,\n"
              "positions=%d.%d, sqlname=%s, value='%s'\n",rc,
             i+1,cntREAD,pc->start,pc->len,pc->sqlname,po);
      Exit(8);
     }
    } // rc>0
   } // for i
   if (rc==0) builtRows++;
  } // for k
}
/*********************************************************************\
|
|  processDISCARDrows() -- multi-rows INSERT failure processing
|
\*********************************************************************/
long processDISCARDrows(long code) {                            // $fnc$
 long nn; int i,k=1;
//printf("\n code=%d",code);
        EXEC SQL GET DIAGNOSTICS :row_count=ROW_COUNT
                          ,:nERROR=NUMBER;

        if (multiRows>1) {
         switch (code) {
      //-253 A NON-ATOMIC statement STATEMENT SUCCESSFULLY COMPLETED FOR
      //      SOME OF THE REQUESTED ROWS, POSSIBLY WITH WARNINGS,
      //      AND ONE OR MORE ERRORS
          case -253:
         totalSQLERRD3=totalSQLERRD3 + row_count;
      // -254 A NON-ATOMIC statement STATEMENT ATTEMPTED TO PROCESS
      //      MULTIPLE ROWS OF DATA, BUT ERRORS OCCURRED
          case -254:
               break;
          default:
               return(code);
         }
        }
        if (multiRows==1) {i=1;k=1;nERROR=1;} else {i=2;k=0;}
        for (iERROR=i;iERROR<=nERROR;iERROR++) {
         EXEC SQL GET DIAGNOSTICS CONDITION :iERROR
         :SMESSAGE = MESSAGE_TEXT
        ,:SCODE = DB2_RETURNED_SQLCODE
        ,:SSTATE = RETURNED_SQLSTATE
        ,:row_num     = DB2_ROW_NUMBER;

          if (SCODE>=0) continue;
    Xprintf("*** discard #%d, SQLCODE=%d, %s\n",
            cntREAD-builtRows+row_num+k,SCODE,SMESSAGE);

    if (fDISCARDfn) {
      if (fpDISCARD==NULL) openDISCARD();
      nn=writeRecord(fpDISCARD,fnDISCARD,outBUF,&cntDISCARD,lreclREAD);
    } else cntDISCARD++;
        }
  return(0);
}
/*********************************************************************\
|
|  executeSTATEMENT() -- execute a non-SELECT statement
|
\*********************************************************************/
void executeSTATEMENT(void) {                                   // $fnc$
   if (doneSTMNT) return;
   if (action!=actREAD)
   EXEC SQL EXECUTE STMNT2;
   else {
    // multi-rows INSERT from a READ file
    eofREAD=NO;
    totalSQLERRD3=0;
    // process each multiRows group of records
    while ((SQLCODE==0)&&(eofREAD==NO)) {
      builtRows=readRows=0;
      loadSQLDATAarrays();
      if (builtRows>0) {
       if (multiRows>1)
       EXEC SQL EXECUTE STMNT1 USING DESCRIPTOR :*pSQLDA;
       else
       EXEC SQL EXECUTE STMNT2 USING DESCRIPTOR :*pSQLDA;
       if (SQLCODE==0)  totalSQLERRD3=totalSQLERRD3+SQLERRD3;
       else if (fDISCARD) SQLCODE=processDISCARDrows(SQLCODE);
      }
    } // while
   } // else

   if  (SQLCODE<0) { processSQLerror("EXECUTE"); return; }
   if  (SQLCODE>0) { processSQLwarning("EXECUTE");SQLCODE=0;}

   if  (SQLCODE==100) {
      Xprintf("*** SQLCODE = +100, no rows found, RC=4\n");
      RC=4;
   } else
   if ((strcmp(word1,"DELETE")==EQUALS)&&(SQLERRD3==-1))
      Xprintf("*** Successful DELETE of ALL rows\n");
   else
   if ( (strcmp(word1,"DELETE")==EQUALS)||
       ((strcmp(word1,"INSERT")==EQUALS)&&(action!=actREAD))||
        (strcmp(word1,"UPDATE")==EQUALS)||
        (strcmp(word1,"SAVE")==EQUALS))
      { if (SQLERRD3>0) {
       Xprintf("*** Successful %s of %d row(s)\n",word1,SQLERRD3);
       RC=0;
      } else {
       Xprintf("*** Empty %s, %d row(s), RC=4\n",word1,SQLERRD3);
       RC=4;
      }
   } else
   if (action==actREAD) {
      if (cntREAD==0) {
       if (fDATA)
       Xprintf("*WARNING* STACK DATA is empty, RC=4\n");
       else
       if (fLABEL)
       Xprintf("*WARNING* STACK LABEL is empty, RC=4\n");
       else
       Xprintf("*WARNING* File %s is empty, RC=4\n",fnREAD);
       RC=4;
      } else
      if (cntREAD==totalSQLERRD3)
  {Xprintf("*** Successful READ & INSERT of %d row(s)\n",cntREAD);RC=0;}
      else
      if (cntREAD>totalSQLERRD3) {
       Xprintf("*** READ %d records, INSERT %d rows, DISCARD %d rows",
              cntREAD, totalSQLERRD3, cntDISCARD);
       RC=4; Xprintf(", RC=4\n");
      } else Exit(777);
   }
   else
     {Xprintf("*** %-9s successful\n",word1);RC=0;}
}
/*********************************************************************\
|
|  printHelpExplain() -- print out some info about PLAN_TABLE fields
|
\*********************************************************************/
void printHelpExplain(void) {                                   // $fnc$
Xprintf(" JOIN_METHOD indicates the join method used for the step: \n");
Xprintf(" 0  -- First, continuation of previous access, or not used\n");
Xprintf(" 1  -- Nested loop join.                                  \n");
Xprintf(" 2  -- Merge scan join.                                   \n");
Xprintf(" 3  -- Sorts needed by ORDER BY, GROUP BY, DISTINCT, ...  \n");
Xprintf(" 4  -- Hybrid join.                                       \n");
Xprintf(" ACCESS_TYPE indicates the method of accessing the table: \n");
Xprintf(" I  -- By an index                                        \n");
Xprintf(" I1 -- By a one-fetch index scan                          \n");
Xprintf(" M  -- By a multiple index scan (followed by MX,MI,or MU) \n");
Xprintf(" MI -- By an intersection of multiple indexes             \n");
Xprintf(" MU -- By a union of multiple indexes                     \n");
Xprintf(" MX -- By an index scan on the index named in ACCESSNAME  \n");
Xprintf(" N  -- By an index scan when the IN keyword is            \n");
Xprintf(" R  -- By a table space scan                              \n");
Xprintf(" RW -- By a work file scan                                \n");
Xprintf(" V  -- By buffers for an INSERT statement within a SELECT \n");
}
/*********************************************************************\
|
|  POSTPROCESS_SQL_STMNT() -- post-processing of some statements
|
\*********************************************************************/
void POSTPROCESS_SQL_STMNT(void)                                // $fnc$
{
  if (doneSTMNT) return;
  if ((plastIFDO)&&(plastIFDO->flagÝ0¨=='N')) return;
  if (fEXPLAIN) {
   printHelpExplain();
   fEXPLAIN=OFF;
   signposFlag=hold_signposFlag;
   nullchar=hold_nullchar;
  }
  if ((fDISCARD)&&(fDISCARDfn)) {
   if (fpDISCARD==NULL) openDISCARD();
   multiRows=multiRows_save;
  }
#if defined(__MVS__)
  if (fLOCK) {
   rc=callIFI(cmdDIS);
   displyTSstatus(0);
   fLOCK=NO;
  }
#endif
   Xprintf("*** CPU time = %.4f seconds, TOTAL time = %d seconds\n",
              CPUtime(cputime1),TOTALtime(tottime1));
   doneSTMNT=YES;
}
/*********************************************************************\
|
|  PROCESS_SQL_STMNT() -- prepare & describe an SQL statement
|
\*********************************************************************/
void PROCESS_SQL_STMNT(void)                                    // $fnc$
{
   if (trace) Xprintf(" SQL.Len=%d \n SQL.Str=\"%s\"\n",SQL.Len,SQL.Str);

   if ((SQL.Len==0)||(doneSTMNT==YES)) return;
   if ((plastIFDO)&&(plastIFDO->flagÝ0¨=='N')) return;

   // Prepare an SQL statement
    EXEC SQL PREPARE STMNT2 FROM :SQL;

   if (SQLCODE) {processSQLCODE("PREPARE STMNT2"); if (SQLCODE) return;}

   // Describe an SQL statement
   if (SQLd==0) {
    do {
        EXEC SQL DESCRIBE STMNT2 INTO :*pSQLDA;
    } while (checkSQLd());
   }

   // Special Prepare for multi-rows
   if ((SQLd>0)&&(multiRows>1)) {
    if (action==actREAD) {
        strcpy(attr.data,multistr);
        strcat(attr.data,notatomic);
        attr.len=strlen(attr.data);
        EXEC SQL PREPARE STMNT1
            ATTRIBUTES :attr
               FROM :SQL;
    } else
        EXEC SQL PREPARE STMNT1 FROM :SQL;
   if (SQLCODE) {processSQLCODE("PREPARE STMNT1"); if (SQLCODE) return;}
   }

   if ((trace)&&(SQLd>0)) printSQLDA();

   // Start timings
   cputime1 = CPUtime(0);
   tottime1 = TOTALtime(0);

   // Execute SQL stamenent

   if ((SQLd>0)&&(action!=actREAD))
     executeSELECT();
   else
     executeSTATEMENT();

}
//****************************************************************
//**                                                            **
//**                   M A I N  L I N E                         **
//**                                                            **
//****************************************************************
int main(int argc, char *argvÝ¨)                                // $fnc$
{
   OPEN_INIT(argc,argv);

   newSTMNT=YES;
   READ_INPUT_LINE();

   while((eofINSQL==NO)||(eofFIFO==NO))
   {
     while( (newSTMNT==YES) && ( (eofINSQL==NO)||(eofFIFO==NO) ) )
     {
        APPEND_INPUT_TO_STMNT();
        READ_INPUT_LINE();
     }
     doneSTMNT=NO;
     while(doneSTMNT==NO)
     {
        PREPROCESS_SQL_STMNT();
        PROCESS_SQL_STMNT();
        POSTPROCESS_SQL_STMNT();
     }
     newSTMNT=YES;
     resetGlobalVariables();
     READ_INPUT_LINE();
   }

   PREPROCESS_SQL_STMNT();
   PROCESS_SQL_STMNT();
   POSTPROCESS_SQL_STMNT();

  printTotalTimings();
  if (fpLOG) fclose(fpLOG);
  return(RC);
}
