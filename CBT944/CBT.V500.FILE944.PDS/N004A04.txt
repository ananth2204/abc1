Virtual route monitor


INTRODUCTION

Network performance problems are often difficult, if not
impossible, to track down using the tools generally available to
support personnel.  One particular problem which is very
difficult to diagnose is that of virtual routes which become
intermittently held or blocked.  This is a particularly difficult
problem to diagnose as there are no indications of when it is
happening, other than poor performance.  There are no
supplied tools to tell you the problem exists or to diagnose the
problem when it does occur.


VIRTUAL ROUTES

Virtual routes are logical pipelines connecting VTAMs and
NCPs.  These pipelines are used to carry sessions with similar
characteristics, such as interactive, printer, or NJE traffic.
Typically control of these pipelines is by session pacing values
in mode table entries, and by tuning the window sizes in the
VTAM and NCP PATH statements.  If the load at a virtual
route end point is excessive then VTAM and NCP modify the
status of the route to 'held' (if up to the current window size
worth of PIUs are queued) or 'blocked' (if more than the
current window size worth of PIUs are queued).

In a regrettably common situation, sessions are often unpaced
which leads to performance problems - for example, when
large volumes of SPOOL hit the VTAM I/O buffer pool.  In
fact, in early releases of VTAM the whole network could seize
up requiring a Z NET,CANCEL before VTAM could be
restarted.  Less dramatic effects can include intermittent
performance problems experienced by disparate groups of
network users (ie there appears to be no common application
that is suffering).  Often no reason can be seen for the
problems, as the network is still servicing users and VTAM
displays show no obvious bottlenecks.

The problem can be particularly severe in the case of networks
containing a large number of locally-attached SNA cluster
controllers: if even a single user is traversing a blocked or held
virtual route then all users of that cluster controller are
impacted.  This is because the only mechanism VTAM can use
to slow traffic across the virtual route is to stop polling the
cluster controller!  Obviously local non-SNA cluster controller
users are less affected as VTAM treats each terminal as a
separate device.


DIAGNOSIS THE IBM WAY

With the IBM-supplied tools, the simplest method to detect the
problem is by issuing a D NET,PATHTAB command.  If you
are very lucky, and get the command in at precisely the right
moment, the display will indicate if the route is held or blocked
but it will not give any clue to what might be overloading the
route, or which resources are affected.  If the route is impacted
for a long enough period of time, an SVC dump can be taken
and the relevant control blocks can be examined.  On-line
diagnosis at the time of the problem is all but impossible.


DIAGOSIS DONE PROPERLY - AT THE TIME

The virtual route monitor, presented here, has been designed to
make periodic checks on the status of the virtual routes. When
it detects blocked or held routes it formats diagnostic
information showing the virtual route destination; the adjacent
subarea number; the transmission priority number; the virtual
route state (eg blocked, held); the minimum, current, and
maximum window sizes; the number of resources held by this
event; and the number of PIUs queued for transmission.  It also
produces a summary of the first five resources held, including
the session partner when it is an application being held, and a
summary of the first five PIUs queued, including the origin and
destination names (or addresses if no interpretation is possible),
and the first sixteen bytes of the RU data (also interpreted if it
is a VTAM flow).

On the assumption that queued PIUs are probably more of the
same that impacted the route in the first place, the display
should give an indication of what is causing the problem (see
Figure 1).


Program components and Installation

The virtual route monitor consists of two programs.  YJP$MSG
is a general purpose message formatting program and should be
assembled first.  YJPVRMON is the actual monitor and needs
to be assembled, authorized (AC(1)), into an authorized
library.  Authorization is required for two reasons: firstly to
allow the program to set its authorization index for cross
memory services and secondly to allow it to read 'protected'
storage in the VTAM address space.  Cross memory access is
achieved using access registers.

In addition to this, we have included a NetView NPDA trap for
the VRM005I message, which will cause an alert to be
generated whenever the message is issued.  This warns us of a
possible problem as soon as it happens and allows us to
suppress VRM messages from the MVS console.  When a
problem is highlighted, we use SDSF to look at the messages
on the spool queue.

Once assembled, the monitor should be set up as a started task
to run whenever the network is loaded.  There are no DD
statements or parameters required.  All output from the
program is issued via WTOs to the MVS console.


Using the Virtual Route Monitor

Once started, the monitor can be controlled using the following
simple set of commands, issued via the MVS modify
command:

o      QUERY - Displays the current status of the monitor,
      including the current virtual route scan interval and the
      'type' of monitoring being performed.  (See SHOW command.)

o      SHOW ALL - Tells the monitor to display all virtual
      routes, whether held, blocked, or open.

o      SHOW NOPEN - Requests that the monitor display any
      virtual routes which are held or blocked, even if there are
      no impacted users.  Normally, this is an acceptable
      situation as there is no performance degradation involved.

o      SHOW HELD - This is the default, and will display
      virtual routes which are held or blocked and which have
      impacted users, ie have a TSCB queue or held HSQHs.

o      INTERVAL=hhmmss - Changes the virtual route scanning
      interval.  The new value must be given in full (6 digits)
      and can not be less than 5 seconds or longer than 24 hours.
o      HELP - Displays a short help screen of valid commands.

o      STOP - Ends the virtual route monitor.  This is equivalent
      to the MVS 'P' command.  The monitor will stop of its
      own accord if VTAM is stopped.

Assuming a started task name of VRMON, to change the
scanning interval to every minute, one would enter:

      f  vrmon,interval=000100

and to display all held/blocked routes:

      f vrmon,show nopen

If you enter an invalid command, the program will display a
short help message with the correct command format.


Release Notes

The virtual route monitor is currently running on MVS/ESA
with VTAM 3.2.  Due to the fact that there are no mapping
DSECTs supplied for the VTAM control blocks, I have coded
a series of equates for the relevant control blocks and bit
settings.  These have been taken from the VTAM 3.2 and
VTAM 3.3 manuals.  If you are running any other version of
VTAM, you should check the offsets before using the program.
I also verify that I have obtained the correct ATCVT address
by looking for the eyecatcher at the start of the control block
(VT32).  This value should also be checked and modified for
other versions of VTAM.

I would like to make one small dedication to Dave Martin, a
colleague who, through a constant barrage of whinging, forced
me to write this monitor and who constantly forces me to add
extra features.  My thanks go to him for the best week's work I
have had in a long time and for the excellent technical
assistance he has given me.  Thanks Dave.


YJP$MSG

* FUNC   Message format and display routine                           *
* MACROs #LINKAGE                                                     *
* RTNS   None                                                         *
* ATTRIB RENT,REUSE,REFR,AC(0),AMODE(24),RMODE(24)                    *
***      Savearea chaining                                            *
YJP$MSG  #LINKAGE START,AMODE=24,RMODE=24,BASE=12,DSA=13
***      Locate message                                               *
         LR    R2,R1               ->INPUT PARAMETER LIST
         L     R4,0(,R2)           ->MESSAGE TABLE
MSGLOOP2 CLC   10(2,R2),0(R4)      MATCH ON MESSAGE NUMBER?
         BE    MSGSCAN             (YES)
         SR    R1,R1               CLEAR FOR ICM
         ICM   R1,3,2(R4)          LENGTH OF CURRENT MESSAGE
         LA    R4,4(R4,R1)         ->NEXT MESSAGE
         CLC   0(4,R4),MSGHEXFF    END OF TABLE?
         BNE   MSGLOOP2            (NO )-KEEP LOOKING
         B     MSGERR1             (YES)-MESSAGE NOT FOUND
***      Start of message build and substitution                      *
MSGSCAN  LA    R5,4(,R4)           ->START OF TEXT
         SR    R1,R1               CLEAR FOR ICM
         ICM   R1,3,2(R4)          LENGTH OF CURRENT MESSAGE
         LA    R6,0(R1,R5)         ->END OF TEXT
         L     R3,16(,R2)          ->START OF VARIABLE LIST
         LA    R7,MSGBUFR          ->START OF OUTPUT BUFFER
         LA    R8,MSGBUFR+L'MSGBUFR ->END OF OUTPUT BUFFER
         B     *+8
MSGLOOP3 LA    R5,1(,R5)           ->NEXT BYTE OF MESSAGE
         CR    R5,R6               END OF TEXT?
         BE    MSGTPUT             (YES)
         CLC   0(1,R5),13(R2)      SUBSTITUTION CHARACTER?
         BE    MSGCHAR             (YES)
         MVC   0(1,R7),0(R5)       ADD FIXED TEXT TO BUFFER
         LA    R7,1(,R7)           INCREMENT OUTPUT BUFFER POINTER
         B     MSGLOOP3            PROCESS NEXT CHARACTER
***      Format substitution as character data                        *
MSGCHAR  CLI   6(R3),1             CHARACTER DISPLAY?
         BNE   MSGHEX              (NO )
         LH    R15,4(,R3)          LENGTH OF FIELD
         L     R14,0(,R3)          ->FIELD
         LA    R0,0(R7,R15)        ->END OF FIELD
         CR    R0,R8               ROOM FOR FIELD?
         BNL   MSGERR5             (NO )
         BCT   R15,*+10            ADD TO OUTPUT BUFFER :-
         MVC   0(*-*,R7),0(R14)
         EX    R15,*-6
         LA    R7,1(R15,R7)        INCREMENT OUTPUT BUFFER POINTER
         LA    R3,8(,R3)           ->NEXT VARIABLE IN LIST
         B     MSGLOOP3            PROCESS NEXT CHARACTER
***      Format substitution as hexadecimal data                      *
MSGHEX   CLI   6(R3),2             HEXADECIMAL DISPLAY?
         BNE   MSGDEC              (NO )
         LH    R15,4(,R3)          LENGTH OF FIELD
         LA    R0,0(R7,R15)
         AR    R0,R15              ->END OF FIELD
         CR    R0,R8               ROOM FOR FIELD?
         BNL   MSGERR5             (NO )
         L     R14,0(,R3)          ->FIELD
         LA    R3,8(,R3)           ->NEXT VARIABLE IN LIST
         LA    R15,0(R14,R15)      ->END OF FIELD
         B     *+12
MSGLOOP4 LA    R7,2(,R7)           ->NEXT BYTE IN OUTPUT FIELD
         LA    R14,1(,R14)         ->NEXT BYTE IN INPUT FIELD
         CR    R14,R15             END OF INPUT FIELD?
         BE    MSGLOOP3            (YES)
         UNPK  0(3,R7),0(2,R14)    CONVERT TO EBCDIC :-
         TR    0(2,R7),MSGHEXTR
         B     MSGLOOP4            PROCESS NEXT CHARACTER
***      Format substitution as decimal data                          *
MSGDEC   CLI   6(R3),3             DECIMAL DISPLAY?
         BNE   MSGBIN              (NO )
         LH    R15,4(,R3)          LENGTH OF FIELD
         LA    R0,0(R7,R15)        ->END OF FIELD
         CR    R0,R8               ROOM FOR FIELD?
         BNL   MSGERR5             (NO )
         L     R14,0(,R3)          ->FIELD
         LA    R3,8(,R3)           ->NEXT VARIABLE IN LIST
         MVC   MSGWORK,MSGMASK     ADD EDIT MASK
         ED    MSGWORK,0(R14)      FORMAT
         LA    R1,MSGWORK+16       ->END OF WORK FIELD
         SR    R1,R15              ->START OF REQD BIT OF WORK FIELD
         BCT   R15,*+10            ADD TO OUTPUT BUFFER :-
         MVC   0(*-*,R7),0(R1)
         EX    R15,*-6
         LA    R7,1(R15,R7)        INCREMENT OUTPUT BUFFER
         B     MSGLOOP3            PROCESS NEXT BYTE
***      Format substitution as binary data                           *
MSGBIN   CLI   6(R3),4             BINARY FULLWORD DISPLAY?
         BE    MSGBINW             (YES)
         CLI   6(R3),5             BINARY HALFWORD DISPLAY?
         BE    MSGBINH             (YES)
         B     MSGDUMP             TRY OTHER TYPES
MSGBINW  L     R14,0(,R3)          ->FIELD
         L     R0,0(,R14)          =FIELD
         B     *+12
MSGBINH  L     R14,0(,R3)          ->FIELD
         LH    R0,0(,R14)          =FIELD
         CVD   R0,MSGDW            CONVERT TO DECIMAL
         LH    R15,4(,R3)          LENGTH OF FIELD
         LA    R0,0(R7,R15)        ->END OF FIELD
         CR    R0,R8               ROOM FOR FIELD?
         BNL   MSGERR5             (NO )
         LA    R3,8(,R3)           ->NEXT VARIABLE IN LIST
         MVC   MSGWORK,MSGMASK     ADD EDIT MASK
         ED    MSGWORK,MSGDW       FORMAT
         LA    R1,MSGWORK+16       ->END OF WORK FIELD
         SR    R1,R15              ->START OF REQD BIT OF WORK FIELD
         BCT   R15,*+10            ADD TO OUTPUT BUFFER :-
         MVC   0(*-*,R7),0(R1)
         EX    R15,*-6
         LA    R7,1(R15,R7)        INCREMENT OUTPUT BUFFER
         B     MSGLOOP3            PROCESS NEXT BYTE
***      Format substitution as dump data                             *
MSGDUMP  CLI   6(R3),6             DUMP DISPLAY?
         BNE   MSGERR2             (NO )
         LH    R15,4(,R3)          LENGTH OF FIELD
         CH    R15,=Y(16)          TRUNCATE IF NECESSARY :-
         BNH   *+8
         LA    R15,16
         LA    R0,56(,R7)          ->END OF FIELD
         CR    R0,R8               ROOM FOR FIELD?
         BNL   MSGERR5             (NO )
         L     R14,0(,R3)          ->FIELD
         MVI   36(R7),C'*'         ADD CHARACTER TO OUTPUT :-
         BCT   R15,*+10
         MVC   38(*-*,R7),0(R14)
         EX    R15,*-6
         MVI   55(R7),C'*'
         LA    R15,1(R14,R15)      ->END OF FIELD
         MVI   MSGWORK,64          CLEAR WORK FIELD :-
         MVC   MSGWORK+1(L'MSGWORK-1),MSGWORK
         LA    R1,MSGWORK          ->START OF WORK FIELD
         B     *+12
MSGLOOP5 LA    R1,2(,R1)           ->NEXT BYTE IN OUTPUT FIELD
         LA    R14,1(,R14)         ->NEXT BYTE IN INPUT FIELD
         CR    R14,R15             END OF INPUT FIELD?
         BE    MSGDUMP1            (YES)
         UNPK  0(3,R1),0(2,R14)    CONVERT TO EBCDIC :-
         TR    0(2,R1),MSGHEXTR
         B     MSGLOOP5            PROCESS NEXT CHARACTER
MSGDUMP1 MVC   0(8,R7),MSGWORK     ADD TO OUTPUT BUFFER :-
         MVC   9(8,R7),MSGWORK+8
         MVC   18(8,R7),MSGWORK+16
         MVC   27(8,R7),MSGWORK+24
         LA    R7,56(,R7)          INCREMENT OUTPUT BUFFER
         LA    R3,8(,R3)           ->NEXT VARIABLE IN LIST
         B     MSGLOOP3            PROCESS NEXT MESSAGE BYTE
***      Display message using TPUT                                   *
MSGTPUT  CLI   12(R2),1            DISPLAY USING TPUT?
         BNE   MSGWTO              (NO )
         LA    R1,MSGBUFR          ->START OF OUTPUT BUFFER
         SR    R7,R1               =LENGTH OF OUTPUT BUFFER
         LR    R0,R7               MOVE FOR TPUT
         TPUT  (1),(0),R           DISPLAY MESSAGE
         SR    R15,R15             CLEAR RETURN CODE
         B     MSGEXIT             TERMINATE PROGRAM
***      Display message using WTO                                    *
MSGWTO   CLI   12(R2),2            DISPLAY USING WTO?
         BNE   MSGBUF              (NO )
         LA    R1,MSGBUFR          ->START OF OUTPUT BUFFER
         SR    R7,R1               =LENGTH OF OUTPUT BUFFER
         MVC   MSGEXWTO(MSGWTOL),MSGMFWTO RESET WORKAREA
         CH    R7,=Y(120)          TRUNCATE MESSAGE IF NECESSARY :-
         BNH   *+8
         LA    R7,120
         BCT   R7,*+10             ADD MESSAGE TO WORKAREA :-
         MVC   MSGEXWTO+4(*-*),0(R1)
         EX    R7,*-6
         WTO   MF=(E,MSGEXWTO)     ISSUE MESSAGE USING WTO
         SR    R15,R15             CLEAR RETURN CODE
         B     MSGEXIT             TERMINATE PROGRAM
***      Build buffer and return it to caller                         *
MSGBUF   CLI   12(R2),3            RETURN BUFFER TO CALLER?
         BNE   MSGERR3             (NO )
         LA    R8,MSGBUFR          ->START OF OUTPUT BUFFER
         SR    R7,R8               =LENGTH OF OUTPUT BUFFER
         LA    R7,7(,R7)           ROUND UP TO NEAREST DOUBLEWORD :-
         SRL   R7,3
         SLL   R7,3
         STH   R7,8(,R2)           SAVE LENGTH FOR CALLER
         GETMAIN RC,LV=(R7)        GET BUFFER FOR CALLER :-
         LTR   R15,R15             GETMAIN OK?
         BNZ   MSGERR4             (NO )
         ST    R1,4(,R2)           SAVE ADDRESS OF BUFFER FOR CALLER
         BCT   R7,*+10             ADD MESSAGE TO BUFFER :-
         MVC   0(*-*,R1),0(R8)
         EX    R7,*-6
         B     MSGEXIT             TERMINATE PROGRAM
***      Error routines                                               *
MSGERR1  LA    R15,4               SET MESSAGE NOT FOUND CODE
         B     MSGEXIT             TERMINATE PROGRAM
MSGERR2  LA    R15,8               SET FORMAT NOT RECOGNIZED CODE
         B     MSGEXIT             TERMINATE PROGRAM
MSGERR3  LA    R15,12              SET TYPE NOT RECOGNIZED CODE
         B     MSGEXIT             TERMINATE PROGRAM
MSGERR4  LA    R15,16              SET GETMAIN FAILED CODE
         B     MSGEXIT             TERMINATE PROGRAM
MSGERR5  LA    R15,20              SET MESSAGE TOO LONG CODE
         B     MSGEXIT             TERMINATE PROGRAM
***      Set return code and return to caller                         *
MSGEXIT  #LINKAGE END              EXIT, RC is in R15
         LTORG ,
MSGHEXFF DC    X'FFFFFFFF'
MSGMASK  DC    X'40202020202020202020202020202120'
         DC    C'0123456789ABCDEF'
MSGHEXTR EQU   *-256
MSGMFWTO WTO   '                                                       *
                                                                       *
                       ',ROUTCDE=11,MF=L
***      GETMAINED workarea map                                       *
         #LINKAGE DSASTART
MSGDW    DS    D
MSGBUFR  DS    CL256
MSGWORK  DS    CL16
MSGEXWTO WTO   '                                                       *
                                                                       *
                       ',ROUTCDE=11,MF=L
MSGWTOL  EQU   *-MSGEXWTO
         #LINKAGE DSAEND
         END   ,


YJPVRMON

YJPVRMON #LINKAGE START,DSA=13,AMODE=24,RMODE=24,BASE=(12,11)
         #AMODE 31                 Go 31 bit addressing
         BAL   R10,INIT            Initialize any special fields
         BAL   R10,GETASID         Find "NET" ASID
         BAL   R10,GETAUTH         Get authority for Xmemory
         BAL   R10,GETSTOR         Get storage for saved data
         #AMODE 24
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=1   Started Message
         #AMODE 31                 Go 31 bit addressing
CHKVRB   BAL   R10,CLRSTOR         Clear storage to zeros
         BAL   R10,CHKVTAM         Is VTAM shutting down ?
         BAL   R10,GETVRB          Get VRBLK information
         BAL   R10,PUTTABLE        Go print the results of the scan
         BAL   R10,WAIT            Wait for timer to expire
         B     CHKVRB              <== May be bypassed by WAIT routine
         BAL   R10,KILLSTOR        Release storage for saved data
TIDYUP   BAL   R10,KILLAUTH        Reset authorization index
         SR    R15,R15             Clear return code
ENDIT    #LINKAGE END              Return to caller
* DSA initialization - set up ECBLIST - process Stop/Modify CIB       *
INIT     LAM   0,15,KILLALET       Reset all ALETS to our addrspc
         MVC   TIMER,=C'00000500'  Time delay between VR scans (5sec)
         MVI   SHOWFLAG,SHOWHELD   Only show not-open with HSQH chain
         LA    R2,TIMERECB         ->Timer ECB
         ST    R2,ECBTIMER         Store in ECB list
         OI    ECBTIMER,X'80'      Set end of ECB list flag
         USING CIBNEXT,R2          (Command Input Area)
         USING COMLIST,R3          (Command Area)
         EXTRACT MF=(E,MFLEXT)     Locate comms area address :-
         L     R3,COMMAREA         ->Communications area
         L     R2,COMCIBPT         ->Command input buffer
         L     R0,COMECBPT         Save stop/modify address :-
         ST    R0,ECBQEDIT         Store stop/modify ECB in list
         CLI   CIBVERB,CIBSTART    Is this the start CIB ?
         BNE   NOTSTRT             (No )
         QEDIT ORIGIN=COMCIBPT,    Free start CIB                      *
               BLOCK=(2)
NOTSTRT  QEDIT ORIGIN=COMCIBPT,    Only allow 1 modify at a time       *
               CIBCTR=1
         L     R2,X'408'           ->ATCVT
         CLC   0(4,AR2),ATCVTV     Is this the VTAM ATCVT ?
         BNER  R10                 (No )-No further processing
         MVC   HOSTSA,ATCHOSTA(R2) Save our sub-area number
         MVC   HOSTE,ATCHOSTE(R2)  Save our element number
         BR    R10                 Return to caller
         DROP  R2
         DROP  R3
*                Find the ASID of the "NET" job                     *
GETASID  L     R2,X'408'           ->ATCVT
         CLC   0(4,R2),ATCVTV      Is this the VTAM ATCVT ?
         BNE   NOASID              (No )-No further processing
         MVC   ASIDSAVE,ATCASID(R2) (Yes)-Move VTAM asid
         CLC   ASIDSAVE,=H'0'      Is there an ASID ?
         BNER  R10                 (Yes)-return to caller
NOASID   #AMODE 24
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=100 ASID not found.
         #AMODE 31
         B     ENDIT
*                Get authorized for cross memory                    *
GETAUTH  MODESET MODE=SUP          Go supervisor state for AXEXT
         EPAR  R2                  Get my ASID
         STH   R2,ASIDMINE         and save for extract
         AXEXT ASID=ASIDMINE       Extract my authorization index
         LTR   R15,R15             Did I manage to get it ?
         BNZ   NOAUTH              (No )-Leave
         STH   R0,AXSAVE           Save my Authorization index
         MVC   AXSET1,=H'1'        Setup the auth.Index we want
         AXSET AX=AXSET1           Set new auth index
         MODESET MODE=PROB         Go safe again
         LAM   0,15,KILLALET       Reset all ALETS to our addrspc
         BR    R10                 Return to caller
NOAUTH   MODESET MODE=PROB         Go safe again
         B     TIDYUP              On error - run away
*                Get working storage to save VRBLK info into        *
GETSTOR  L     R2,X'408'           ->ATCVT
         CLC   0(4,AR2),ATCVTV     Is this the VTAM ATCVT ?
         BNE   NOSTOR              (No )-No further processing
         XR    R6,R6               Clear a register
         IC    R6,ATCMAXID(,R2)    Insert sub-area count
         CH    R6,=H'129'          Keep count under 128!
         BL    *+8
         LA    R6,128
         LA    R6,1(,R6)           Add 1 for terminating entry
         MH    R6,=Y(LSAVE)        Entries * entry length
         MH    R6,=Y(16)           Allow for 16 Virtual routes/SA
         GETMAIN R,LV=(R6)         Get working storage
         LTR   R15,R15             Did I get the storage
         BNE   NOSTOR              (no )
         STM   R0,R1,STORLEN       Save length/address
         A     R1,STORLEN          Add address to storage length
         S     R1,=AL4(LSAVE+1)    Minus 1 entry
         ST    R1,STOREND          Save as end of storage area
         BR    R10                 Return to caller
NOSTOR   B     ENDIT               Cancel program
*                Clear working storage to zero                      *
CLRSTOR  L     R2,STORADR          ->Working storage               R
         L     R3,STORLEN          Length of working storage       R
         XR    R4,R4                                               S
         XR    R5,R5               X'00' fill the area             S
         MVCL  R2,R4
         BR    R10
*                See if VTAM is still up                            *
CHKVTAM  L     R2,X'408'           ->ATCVT
         CLC   0(4,R2),ATCVTV      Is this the VTAM ATCVT ?
         BNE   NOVTAM              (No )-No further processing
         TM    ATCSTAT(R2),ATCACTIV  Is VTAM still active ?
         BOR   R10                   (Yes) continue processing
NOVTAM   B     ENDIT                 (No ) Terminate program
*                Scan the VRBLK's for the info we want and save     *
*                it in the "STORADR" structure.                     *
         USING VTDATA,R7
         USING VPDATA,R8
GETVRB   L     R7,STORADR          ->Getmained storage
         MVI   0(R7),X'FF'         Insert end of table flag
         TIME  DEC                 Get current time/date
         ICM   R1,B'1000',=X'00'   Convert 0CYYDDDf to 00YYDDDf
         ST    R1,CDATE            Save date for insertion into rec.
         LR    R9,R0               Copy time
         SRL   R9,4                (0hhmmsst)
         O     R9,=F'15'           (0hhmmssF)
         ST    R9,CTIME            Save time for later insertion
         MODESET KEY=ZERO          Go Key zero for VRBLK information
         LH    R2,ASIDSAVE         Get ASID of the NET job
         SSAR  R2                  And setup secondary addressing
         LAM   0,15,SETALET        Set ALETS for ALL registers
         SAC   512                 Go cross memory
***         WARNING  --  WARNING  --  WARNING  --  WARNING        ***
*   In cross memory mode here. .......                              *
*   R2, R3, R4, R5, R6 -  Address the "NET" address space !         *
*   Register usage is as follows:                                   *
*    R0                                                             *
*    R1                                                             *
*   AR2          -> VRBLK anchors                                   *
*   AR3          -> Current VRBLK                                   *
*   AR4          -> Current Transmission Priority                   *
*   AR5          Work register  (->TSCB, ->HSQH)                    *
*   AR6          Work register  (->NCB, ->ACDEB)                    *
*    R7          -> VR information save area                        *
*    R8          -> Current Transmission Priority Info save area    *
*    R9          -> HSQH save data                                  *
*    R10         Return address from routine, used as work (once).  *
*    R11         Second base register                               *
*    R12         Base register                                      *
*    R13         DSA/Save area pointer                              *
*    R14         Used as a work register(Sorry)                     *
*    R15         Used as a loop counter (Sorry, I ran out of regs.) *
         L     AR2,X'408'          ->ATCVT
         CLC   0(4,AR2),ATCVTV     Is this the VTAM ATCVT ?
         BNE   VRBDONE             (No )-Get out now
         XC    THISSUB,THISSUB     Clear subarea count
         XR    R9,R9               Clear work register
         IC    R9,ATCMAXID(,AR2)   Insert subarea count
         CH    R9,=H'128'          Keep count under 128!
         BL    *+8
         LA    R9,128
         L     AR2,ATCVRNDX(,AR2)  ->VRBLK index start
VRBNXTSA STH   R9,NUMSA            Save number of subareas to proc.
         L     AR3,0(,AR2)         ->VRBLK
         LTR   AR3,AR3             Is there a VRBLK for this subarea?
         BZ    NOVRBLK             (No )-Nothing to do - index up
*                                     Save from VRBLK :-
VRBNXTVR LA    R9,RESTAB           Initialize ptr to SA/ELE table
         ST    R9,RESSAV
         XC    0(20,R9),0(R9)      Clear out first entry
         MVC   VTDATE(4),CDATE     Insert date (00yydddF)
         MVC   VTTIME(4),CTIME     Insert Time (0hhmmssF)
         MVC   VTSUBA(2),THISSUB         Subarea number
         MVC   VTASUBA,VRBADJSA+2(AR3)   Adjacent subarea
         MVC   VTDSUBA,VRBDSTSA+2(AR3)   Destination subarea
         MVC   VTVRNO+1(1),VRBVRN(AR3)   Virtual route number
         LA    R8,VTP0                   Output save area
         LA    AR4,VRBFSTS(,AR3)         ->Path 0 status information
*                                     Save from Path info:-
VRBNXTTP MVC   VPSTATE,VRBVRFSM(AR4)     Virtual route status
         MVC   VPFCFSM,VRBPRI(AR4)       Flow control finite state
         MVC   VPACTW+1(1),VRBPALIM(AR4) Window actual size
         MVC   VPSESS(2),VRBSECNT(AR4)   Session count
         MVC   VPMINW+1(1),VRBMINWS(AR4) Minimum window size
         MVC   VPMAXW+1(1),VRBMAXWS(AR4) Maximum window size
         CLI   VPSTATE,VRBVRFAC    Is this an active route ?
         BNE   VRBNOACT            (No )-Ignore entry
         TM    VPFCFSM,VRBFCFOP    Is it open ?
         BO    VRBNOACT            (Yes)-Ignore entry
*   We have an ACTIVE, but NOT OPEN route. Store some information:- *
*   From the TSCB:     The send/receive network addresses RU data   *
         LA    R9,VPTSCB           ->TSCB saved data
         USING VTSDATA,R9          Address record layout
         LA    R1,LTSCBS(,R9)      End of area pointer
         ST    R1,VTSEND           Save for comparison later
         L     AR5,VRBRHOLD(,AR4)  ->TSCB
         LTR   AR5,AR5             Is there a TSCB ?
         BZ    DOHSQH              (No )-Go check HSQH
         ZAP   QDEPTH(3),=PL3'0'   Depth of TSCB chain
NEXTTSCB AP    QDEPTH(3),=PL3'1'   Count 1 TSCB
         CLI   0(AR5),X'99'        Is this a TSCB ?
         BNE   ENDTSCB             (No )
         MVC   VPTHDSAF,TSCTH4+TH4DSAF(AR5)  Dest subarea field
         MVC   VPTHOSAF,TSCTH4+TH4OSAF(AR5)  Origin subarea field
         MVC   VPTHDEF,TSCTH4+TH4DEF(AR5)    Dest subarea field
         MVC   VPTHOEF,TSCTH4+TH4OEF(AR5)    Origin subarea field
         MVC   VPRH(2),TSCRH+RHF0(AR5)       Move RH data
         MVC   VPRU(16),TSCRU(AR5)           Move RU data
*   Save destination/origin subarea/element so we can resolve the   *
*   real resource names later on.                                   *
         ST    R10,R10SAVE             Save ourselves a work register
         L     R10,RESSAV              ->Resource save table
         LA    R14,VPTHDNAM            ->Destination name
         STCM  R14,B'1111',6(R10)
         MVC   VPTHDNAM(8),=CL8'Unknown '
         MVC   0(4,R10),VPTHDSAF       Save dest.sub-area
         MVC   4(2,R10),VPTHDEF        Save dest.element
         LA    R10,10(,R10)            ->Next entry
         LA    R14,VPTHONAM            ->Origin name
         STCM  R14,B'1111',6(R10)
         MVC   VPTHONAM(8),=CL8'Unknown '
         MVC   0(4,R10),VPTHOSAF       Save origin.sub-area
         MVC   4(2,R10),VPTHOEF        Save origin.element
         LA    R10,10(,R10)            ->Next entry
         XC    0(20,R10),0(R10)        Clear last entry
         ST    R10,RESSAV              Save for next time thru
         L     R10,R10SAVE             restore register contents
         LA    R9,LTSSAVE(,R9)         ->Next save area
         C     R9,VTSEND               Any more room ?
         BNL   CNTTSCB                 (No )
         L     AR5,TSCNEXT(,AR5)       ->Next TSCB
         LTR   AR5,AR5                 Another TSCB?
         BNZ   NEXTTSCB                (Yes)
         B     ENDTSCB
CNTTSCB  L     AR5,TSCNEXT(,AR5)       ->Next TSCB
         LTR   AR5,AR5                 Another TSCB?
         BZ    ENDTSCB                 (No )
         AP    QDEPTH(3),=PL3'1'       Count 1 TSCB
         B     CNTTSCB
ENDTSCB  ZAP   DOUBLE(8),QDEPTH(3)     Make qdepth into a double word
         CVB   R1,DOUBLE               Make qdepth binary
         STH   R1,VTTSCBD              Save TSCB queue depth
*   We have an ACTIVE, but NOT OPEN route. Store some information:- *
*   From the HSQH:     The type of waiting resource (APPL etc)      *
*                      The name of the resource                     *
DOHSQH   LA    R9,VPHSQH           ->HSQH saved data
         USING VHSDATA,R9          Address record layout
         LA    R1,LHSQHS(,R9)      End of area pointer
         ST    R1,VTSEND           Save for comparison later
         ZAP   QDEPTH(3),=PL3'0'   Depth of HSQH chain
         L     AR5,VRBSESSQ(,AR4)  ->First HSQH
         LTR   AR5,AR5             Is there an HSQH ?
         BZ    ENDHSQH             (No )-Go finish up
NEXTHSQH MVC   HSQNEXT(4),HSQCHAIN(AR5)  Save pointer to next HSQH
         LA    R15,7               Number of entries to test
FINDHSQH LA    AR5,4(,AR5)         Next HSQH in control block
         TM    0(AR5),X'80'        Is this HSQH waiting ?
         BZ    NOTWAIT             (No )-ignore the entry
         AP    QDEPTH(3),=PL3'1'   Count 1 entry on hold queue
         L     AR6,0(,AR5)         ->??NCB
         CLI   0(AR6),FMCB         Is this an FMCB ?
         BNE   TSTFMCB             (No )-check ICNCB
*   Waiting item is an FMCB, extract the ACDEB address and copy     *
*   the name of the application.                                    *
         MVI   VHSTYPE,FMCB               Move in control type
         MVC   VHSPSA,FMCPCSA+TSPSPSA(AR6) Move partner sub-area
         MVC   VHSPEA,FMCPCSA+TSPSPEA(AR6) Move partner element addr
*   Save partner sub-area/element address so we can resolve them    *
*   into a resource name later.                                     *
         L     AR6,FMCPSSA+TSPDEBA(,AR6)  ->ACDEB
         MVC   VHSNAME,ACDUNTNM(AR6)      Move application name
         B     UNKNCB                     Return to mainline
TSTFMCB  CLI   0(AR6),ICNCB        Is this an ICNCB?
         BNE   TSTICNCM            (No )-check LDNCB
*   Waiting item is an ICNCB, extract the unit name.                *
         MVI   VHSTYPE,ICNCB              Move in control type
         L     AR6,NCBRDTE(,AR6)          ->RDT entry
         MVC   VHSNAME(8),RPRNAME(AR6)    Move the unit name
         B     UNKNCB                     Return to mainline
TSTICNCM CLI   0(AR6),LDNCB        Is this an LDNCB?
         BNE   TSTLDNCM            (No )-Can't format, so save ptrs
*   Waiting item is an LDNCB, extract the unit name.                *
         MVI   VHSTYPE,LDNCB              Move in control type
         L     AR6,NCBRDTE(,AR6)          ->RDT entry
         MVC   VHSNAME(8),RPRNAME(AR6)    Move the unit name
         B     UNKNCB                     Return to mainline
*   Unknown control type, save type byte and HSQH pointer           *
TSTLDNCM MVC   VHSTYPE(1),0(AR6)          Move in control type
         STCM  AR6,B'1111',VHSNAME        Save pointer to HSQH entry
         B     UNKNCB                     Return to mainline
UNKNCB   LA    R9,LHQSAVE(,R9)     ->Next save area
         C     R9,VTSEND           Any more room ?
         BNL   CNTHSQH             (No )-Just count entries
NOTWAIT  BCT   R15,FINDHSQH        Loop through next entry
         L     AR5,HSQNEXT         Load pointer to next in queue
         LTR   AR5,AR5             Any left to do ?
         BNZ   NEXTHSQH            (Yes)-Go scan that one then
         B     ENDHSQH             Start at end of loop
*   We've saved 5 entries, so now we just count held HSQH entries.  *
CNTNHSQH MVC   HSQNEXT(4),HSQCHAIN(AR5)  Save pointer to next HSQH
         LA    R15,7               Number of entries to test
CNTWHSQH LA    AR5,4(,AR5)         Next HSQH in control block
         TM    0(AR5),X'80'        Is this HSQH waiting ?
         BZ    CNTHSQH             (No )-bypass accumulation
         AP    QDEPTH(3),=PL3'1'   Count 1 entry on hold queue
CNTHSQH  BCT   R15,CNTWHSQH        Loop through next entry
         L     AR5,HSQNEXT         Load pointer to next in queue
         LTR   AR5,AR5             Any left to do ?
         BNZ   CNTNHSQH            (Yes)-Go scan that one then
         B     ENDHSQH             (no )-Save hold queue length
*   End of HSQH chain, save count of held HSQH's                    *
ENDHSQH  ZAP   DOUBLE(8),QDEPTH(3) Make qdepth into a double word
         CVB   R1,DOUBLE           Make qdepth binary
         STH   R1,VTHSQHD          Save HSCB held entry count
VRBNOACT LA    R8,LTPSAVE(,R8)     ->Next entry in table
         LA    AR4,32(,AR4)        Next path entry
         LA    R1,VTPEND           ->End of path entries
         CR    R8,R1               Have we finished ?
         BL    VRBNXTTP            (No )-Do next priority
         LA    R7,LSAVE(,R7)       ->Next save area in table
         MVI   0(R7),X'FF'         Flag new end of table
         C     R7,STOREND          Have we bust the buffer ?
         BH    VRBDONE             (Yes)-terminate scan
*   We may have a list of addresses to resolve. Do it now, while    *
*   we have some registers to play with. (As we are about to start  *
*   the loop again, we have      AR4, AR5, AR6, R8, R9,     R14,    *
*   R15 all free).                                                  *
SIBSCAN  L     AR4,X'408'                    ->ATCVT
         L     AR4,ATCSIBQ(,AR4)             ->SIB chain
         B     *+8                           Skip into loop
SIBNEXT  L     AR4,SIBBFWD(,AR4)             ->To next SIB in chain
         LTR   AR4,AR4                       Any more in chain ?
         BZ    SIBDONE                       (No )-Just drop out
         LA    R8,RESTAB                     Table to be searched
         CLC   0(4,R8),=F'0'                 are there any entries ?
         BE    SIBDONE                       (No )-bypass scan
         B     *+8                           Branch into loop
SIBNADDR LA    R8,10(,R8)                    ->Next address
         CLC   0(4,R8),=F'0'                 End of search table ?
         BE    SIBNEXT                       (Yes)-Do next SIB
         CLC   0(6,R8),SIBDLU+SIBRNETA(AR4)  Is this our Dest?
         BE    SIBCOPYD                      (Yes)-copy resource name
         CLC   0(6,R8),SIBOLU+SIBRNETA(AR4)  Is it our origin then?
         BNE   SIBNADDR                      (No )-do next in list
         ICM   R9,B'1111',6(R8)              Move resource name :-
         MVC   0(8,R9),SIBOLU+SIBRALNM(AR4)
         B     SIBNADDR
SIBCOPYD ICM   R9,B'1111',6(R8)              Move resource name :-
         MVC   0(8,R9),SIBDLU+SIBRALNM(AR4)
         B     SIBNADDR
*   End of CIB scan, check if we have another VR to process.        *
SIBDONE  L     AR3,VRBFXCHN(,AR3)  ->Next VRBLK for this SA
         LTR   AR3,AR3             Is there another Virtual Route?
         BNZ   VRBNXTVR            (Yes)-Go check it
NOVRBLK  LA    AR2,4(,AR2)         ->Next VRBLK address
         LH    R9,THISSUB          Load subarea number
         LA    R9,1(,R9)           Next subarea number
         STH   R9,THISSUB          and save count back
         LH    R9,NUMSA            Load subarea counter
         BCT   R9,VRBNXTSA         Loop till all subareas scanned
         DROP  R7
         DROP  R8
***         WARNING  --  WARNING  --  WARNING  --  WARNING        ***
*                   Out of cross memory mode                        *
VRBDONE  SAC   0                   Cancel cross memory mode
         EPAR  R2                  Get our ASID back
         SSAR  R2                  and reset secondary address space
         LAM   0,15,KILLALET       Reset all ALETS to our addrspc
         MODESET KEY=NZERO         Exit from supervisor mode
         BR    R10                 and return to caller
*                Print the results of the scan                      *
PUTTABLE L     R7,STORADR          ->Results of the scan
         USING VTDATA,R7
         USING VPDATA,R8
         #AMODE 24                 Go 24 bit addressing for TPUT
         XC    FORMATF,FORMATF     Clear format flag
PUTSTART CLI   0(R7),X'FF'         End of table ?
         BE    PUTEND              (Yes)-Exit
*   Do not format messages for our sub-area                         *
         CLC   VTSUBA(2),HOSTSA+2  Our sub-area ?
         BE    PUTBYPAS            (Yes)-bypass print
*   FORMAT stored information                                       *
         LA    R8,VTP0             ->Priority 0 stuff
         BAL   R6,FORMATE          Format this entry
         LA    R8,VTP1             ->Priority 1 stuff
         BAL   R6,FORMATE          Format this entry
         LA    R8,VTP2             ->Priority 2 stuff
         BAL   R6,FORMATE          Format this entry
PUTBYPAS LA    R7,LSAVE(,R7)       ->Next subarea entry
         B     PUTSTART            and loop
PUTEND   #AMODE 31                 Reset to callers mode
         BR    R10                 and return to caller
*                Format an exception entry                          *
FORMATE  TM    SHOWFLAG,SHOWALL    Are we displaying all VRs ?
         BO    DOFMT               (Yes)-Go start display
         CLI   VPSTATE,VRBVRFAC    Is this an active route ?
         BNE   NOFMT               (No )-Ignore entry
         TM    VPFCFSM,VRBFCFOP    Is it open ?
         BO    NOFMT               (Yes)-Ignore entry
         TM    SHOWFLAG,SHOWNOPN   Are we displaying all blocked VRs?
         BO    DOFMT               (Yes)-Go start display
         CLC   VTHSQHD,=H'0'       Is anyone queued ?
         BE    NOFMT               (No )-Ignore entry
DOFMT    OI    FORMATF,FMTPRT      Flag an entry has bee printed
         TM    FORMATF,FMTHDR      Have we printed the headings ?
         BO    DONEHDR1            (Yes)-do not do it again
         OI    FORMATF,FMTHDR      Flag headers produced
         UNPK  FCFSMS(5),CDATE(4)  Unpack Date
         UNPK  VSTAT(8),CTIME(4)   Unpack Time
         MVC   VSTAT(2),VSTAT+2    hh
         MVC   VSTAT+3(2),VSTAT+4  mm
         MVI   VSTAT+2,C':'
         MVI   VSTAT+5,C':'
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=800
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=2,                           *
               FIELDS=(FCFSMS,5,CHAR,VSTAT,8,CHAR)
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=3
DONEHDR1 XR    R9,R9               Clear work register
         IC    R9,VPFCFSM          Insert FCFSM flag
         N     R9,=F'3'            Isolate the bits we want
         SLL   R9,3                Status number * 8
         LA    R9,FCFSM(R9)        Point to table
         MVC   FCFSMS(8),0(R9)     Save status
         XR    R9,R9               Clear work register
         IC    R9,VPSTATE          Insert FCFSM flag
         N     R9,=F'7'            Isolate the bits we want
         SLL   R9,3                Status number * 8
         LA    R9,STATUS(R9)       Point to table
         MVC   VSTAT(8),0(R9)      Save status
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=5,                          **
               FIELDS=(VTSUBA,2,BINH,     Sub-area                    **
               VTVRNO,2,BINH,             Virtual route number        **
               =C'01',2,CHAR,             Path 0                      **
               VTASUBA,2,BINH,            Adjacent sub-area           **
               VSTAT,8,CHAR,              VR_state                    **
               FCFSMS,8,CHAR,             VR-FSM                      **
               VPMINW,3,BINH,             Window minimum size         **
               VPACTW,3,BINH,             Window maximum size         **
               VPMAXW,3,BINH,             Window actual  size         **
               VPSESS,5,BINH,             Number of sessions          **
               VTTSCBD,4,BINH,            TSCB chain queue depth      **
               VTHSQHD,4,BINH)            HSQH entries held
*   Format the TH/RH/RU data elements                               *
         LA    R9,VPTSCB           ->Saved TSCB data
         USING VTSDATA,R9          Address record layout
         LA    R2,5                Format 5 entries
FMTNEXT  CLC   VPTHDSAF,=F'0'      Is there any data ?
         BE    NODEST              (No )
*--------------------------------- Determine RU category -------------*
         MVC   DOUBLE(1),VPRH      Move RU category byte to work area
         NI    DOUBLE,255-X'9F'    Mask non-category bits
         MVC   OPRCMD(4),=C'FMD '  Assume FMData:-
         L     R3,=A(YJP$FMD)
         LA    R4,3
         CLI   DOUBLE,X'00'        FMD?
         BE    FINDRU              (Yes)
         MVC   OPRCMD(4),=C'NC  '  Assume Network Control
         L     R3,=A(YJP$NC)
         LA    R4,1
         CLI   DOUBLE,X'20'        NC?
         BE    FINDRU              (Yes)
         MVC   OPRCMD(4),=C'DFC '  Assume Data Flow Control :-
         L     R3,=A(YJP$DFC)
         LA    R4,1
         CLI   DOUBLE,X'40'        DFC?
         BE    FINDRU              (Yes)
         MVC   OPRCMD(4),=C'SC  '  Must be Session Control :-
         L     R3,=A(YJP$SC)
         LA    R4,1
*--------------------------------- Format RU description if found ----*
FINDRU   LA    R1,VPRU             ->RU data
         B     *+8
NEXTRU   LA    R3,20(,R3)          ->Next entry in lookup table
         CLC   0(3,R3),=X'FFFFFF'  End of lookup table ?
         BE    UNKRU               (Yes)-Format unknown
         LR    R15,R4              Move key length to work register
         BCT   R15,*+10
         CLC   0(*-*,R3),0(R1) Do keys match ?
         EX    R15,*-6
         BNE   NEXTRU              (No )-keep looking
UNKRU    MVC   OPRCMD+4(17),3(R3)  Move command type to message area
         TM    FORMATF,FMTHDR2     Have we printed the headings ?
         BO    DONEHDR2            (Yes)-do not do it again
         OI    FORMATF,FMTHDR2     Flag headers produced
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=800
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=6
DONEHDR2 $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=7,                          **
               FIELDS=(VPTHDSAF+2,2,HEX,  Destination subarea         **
               VPTHDEF,2,HEX,             Destination element         **
               VPTHDNAM,8,CHAR,           Destination name            **
               VPTHOSAF+2,2,HEX,          Origin subarea              **
               VPTHOEF,2,HEX,             Origin element              **
               VPTHONAM,8,CHAR,           Origin name                 **
               VPRU,16,HEX,               16 bytes of RU data         **
               OPRCMD,21,CHAR)            RU type
         LA    R9,LTSSAVE(,R9)     ->Next entry
         BCT   R2,FMTNEXT          and try again
*   Format the HQSH data elements                                   *
NODEST   NI    FORMATF,X'FF'-FMTHDR2  Reset headers printed flag
         LA    R9,VPHSQH           ->Saved HSQH data
         USING VHSDATA,R9          Address record layout
         LA    R2,5                Format 5 entries
FMTHSQH  CLI   VHSTYPE,X'00'       Is there any data ?
         BE    NOFMT               (No )
         TM    FORMATF,FMTHDR2     Have we printed the headings ?
         BO    DONEHDR3            (Yes)-do not do it again
         OI    FORMATF,FMTHDR2     Flag headers produced
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=800
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=8
DONEHDR3 CLI   VHSTYPE,FMCB
         BNE   CHKICNCB
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=11,  Format FMCB            **
               FIELDS=(=C'FMCB ',5,CHAR,       Record type (Desc)     **
               VHSTYPE,1,HEX,                  Record type (Num)      **
               VHSNAME,8,CHAR,                 Resource name          **
               VHSPSA,4,HEX,                   Partner subarea        **
               VHSPEA,2,HEX)                   Partner element
         B     FMTNHSQH
CHKICNCB CLI   VHSTYPE,ICNCB
         BNE   CHKLDNCB
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=9,   Format LDNCB           **
               FIELDS=(=C'ICNCB ',5,CHAR,      Record type (Desc)     **
               VHSTYPE,1,HEX,                  Record type (Num)      **
               VHSNAME,8,CHAR)                 Resource name
         B     FMTNHSQH
CHKLDNCB CLI   VHSTYPE,LDNCB
         BNE   UNKNCB2
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=9,   Format LDNCB           **
               FIELDS=(=C'LDNCB ',5,CHAR,      Record type (Desc)     **
               VHSTYPE,1,HEX,                  Record type (Num)      **
               VHSNAME,8,CHAR)                 Resource name
         B     FMTNHSQH
UNKNCB2  $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=10,  Unknown HSQH type      **
               FIELDS=(VHSTYPE,1,HEX,          Record type            **
               VHSNAME,4,HEX)                  HSQH address
         B     FMTNHSQH
FMTNHSQH LA    R9,LHQSAVE(,R9)            ->Next entry
         BCT   R2,FMTHSQH                 and try again
NOFMT    NI    FORMATF,X'FF'-FMTHDR2      Reset headers printed flag
         BR    R6                         Return to scan routine
         DROP  R7
         DROP  R8
*                1) Wait for a period of time (default=5secs) then  *
*                   return to the mainline to perform the next scan.*
*                2) Process any Operator commands sent via the      *
*                   Stop/Modify interface.                          *
WAIT     #AMODE 24
         STIMER REAL,TIMERP,DINTVL=TIMER
         WAIT ECBLIST=ECBLIST      Wait for timer/modify
         #AMODE 31
         TM    TIMERECB,X'40'      Was the timer posted ?
         BZ    STOPMDFY            (No )-Must be stop/modify
         XC    TIMERECB,TIMERECB
         BR    R10                 Return to caller
*   Someone knocked, let's see what they want....                   *
         USING CIBNEXT,R2          (Command Input Area)
         USING COMLIST,R3          (Command Area)
STOPMDFY L     R3,COMMAREA         ->Communications area
         L     R2,COMCIBPT         ->CIB
         CLI   CIBVERB,CIBSTOP     Was it a stop command ?
         BE    ENDPRG              (Yes)-terminate processing
         CLI   CIBVERB,CIBMODFY    Was it a modify command ?
         BNE   ENDPRG2             (No )-Don't know what it was then!
         MVI   OPRCMD,C' '         Blank out command save area :-
         MVC   OPRCMD+1(79),OPRCMD
         LA    R4,CIBDATA          ->Data buffer
         LH    R5,CIBDATLN         Load data length
         CH    R5,=H'80'           Limit buffer size to 80 bytes:-
         BL    *+8
         LA    R5,80
         BCT   R5,*+10             Length -1
         MVC   OPRCMD(*-*),0(R4)   Executed move
         EX    R5,*-6              Move data to save area
         QEDIT ORIGIN=COMCIBPT,    Dequeue this CIB, ready for next    *
               BLOCK=(2)
*   OPRCMD contains up to 80 bytes of the text of the MODIFY        *
*   command. Determine if it's a command we can process.            *
         CLC   =C'INTERVAL=',OPRCMD   Set interval command ?
         BE    CMDINT                 (Yes)
         CLC   =C'QUERY',OPRCMD       Query stats ?
         BE    CMDQUERY               (Yes)
         CLC   =C'SHOW ALL',OPRCMD    Show all virtual routes ?
         BE    CMDSALL                (Yes)
         CLC   =C'SHOW HELD',OPRCMD   Show Held Virtual Routes ?
         BE    CMDSHELD               (Yes)
         CLC   =C'SHOW NOPEN',OPRCMD  Show Not Open Virtual Routes?
         BE    CMDSNOPN               (Yes)
         CLC   =C'STOP',OPRCMD        Stop request ?
         BE    ENDPRG                 (Yes)
         CLC   =C'HELP',OPRCMD        Help request ?
         BE    CMDHELP                (Yes)
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=200,                         *
               FIELDS=(OPRCMD,20,CHAR)
         B     CMDHELP                Go display help screen
*   COMMAND:   INTERVAL=hhmmss                                      *
*   FUNCTION:  To change the time interval between VR scans         *
*   PARAMETER: The command expects to be given a new timer value    *
*              in the format:                                       *
*                        HHMMSS                                     *
*              All six digits must be entered. Validation consists  *
*              of checking:                                         *
*              a) 6 digit numeric value                             *
*              b) HH   -    Between  00 and 23                      *
*              c) MM   -    Between  00 and 59                      *
*              d) SS   -    Between  00 and 59                      *
*              e) The time value is greater than 4 seconds          *
CMDINT   LA    R2,OPRCMD+9         ->New time value
         LA    R4,TI1              Preset error reason
         SH    R5,=H'8'            Less length of keyword
         CH    R5,=H'6'            Are there more than 6 chars left
         BNE   INVINT              (Yes)-Invalid
         LA    R4,TI2              Preset error reason
CHKNUM   TM    0(R2),X'F0'         Is it a number ?
         BNO   INVINT              No - its invalid
         LA    R2,1(,R2)           ->next character
         BCT   R5,CHKNUM           Keep checking
         PACK  DOUBLE(2),OPRCMD+9(2)     Pack hours
         PACK  DOUBLE+2(2),OPRCMD+11(2)  Pack minutes
         PACK  DOUBLE+4(2),OPRCMD+13(2)  Pack Seconds
         LA    R4,TI3              Preset error reason
         CP    DOUBLE(2),=PL2'24'  Less than 24 hours ?
         BNL   INVINT              (No )-invalid
         LA    R4,TI4              Preset error reason
         CP    DOUBLE+2(2),=PL2'60' Less than 60 minutes ?
         BNL   INVINT              (No )-Invalid
         LA    R4,TI5              Preset error reason
         CP    DOUBLE+4(2),=PL2'60' Less than 60 seconds ?
         BNL   INVINT              (No )-Invalid
         CP    DOUBLE(2),=PL2'0'   Any hours specified ?
         BH    CHKTIME             (Yes)-Were OK
         CP    DOUBLE+2(2),=PL2'0' Any minutes specified ?
         BH    CHKTIME             (Yes)-Were OK
         LA    R4,TI6              Preset error reason
         CP    DOUBLE+4(2),=PL2'4' More than 4 seconds specified?
         BNH   INVINT              (No )-Zero time specified
CHKTIME  MVC   TIMER(6),OPRCMD+9   Move new timer value
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=201,                         *
               FIELDS=(TIMER,6,CHAR)
         B     WAIT                Return to wait loop
INVINT   $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=202,  Time invalid message   *
               FIELDS=(OPRCMD+9,6,CHAR,0(R4),20,CHAR)
         B     WAIT                Return to wait loop
*   COMMAND:   QUERY                                                *
*   FUNCTION:  To display the program status                        *
*   PARAMETER: None                                                 *
*              Currently displays the timer value and the current   *
*              setting of the "SHOWFLAG" flag.                      *
CMDQUERY $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=203,                         *
               FIELDS=(TIMER,6,CHAR)
         LA    R2,DISALL           Assume all VRs
         TM    SHOWFLAG,SHOWALL    Are we showing all virtual routes ?
         BO    STATMSG             (Yes)
         LA    R2,DISHELD          Assume VRs with HSQH chain
         TM    SHOWFLAG,SHOWHELD   Are we showing Not-Open, with HSQHs?
         BO    STATMSG             (Yes)
         LA    R2,DISNOPN
STATMSG  $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=208,  Show display type      *
               FIELDS=(0(R2),25,CHAR)
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=209,  Show host SA           *
               FIELDS=(HOSTSA+2,3,BINH)
         B     WAIT                Return to wait loop
*   COMMAND:   SHOW                                                 *
*   FUNCTION:  To alter which statistics are displayed              *
*   PARAMETER: ALL   - Show all virtual routes regardless of status *
*              HELD  - Show only "not open" routes which have an    *
*                      HSQH chained off them.                       *
*              NOPEN - Show "not open" routes even if they do not   *
*                      have an HQSH chain.                          *
CMDSALL  MVI   SHOWFLAG,SHOWALL
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=205
         B     WAIT                              Return to wait loop
CMDSHELD MVI   SHOWFLAG,SHOWHELD
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=206
         B     WAIT                              Return to wait loop
CMDSNOPN MVI   SHOWFLAG,SHOWNOPN
         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=207
         B     WAIT                              Return to wait loop
*   COMMAND:   HELP                                                  *
*   FUNCTION:  To display command options                            *
*   PARAMETER: None                                                  *
*   NOTE: This routine is also entered if an invalid command is given*
CMDHELP  LA    R2,HELP1                           ->Help text
         LA    R3,NHELP                          Number of lines
HELPMSGS $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=801,                         *
               FIELDS=(0(R2),L'HELP1,CHAR)
         LA    R2,L'HELP1(,R2)                   ->Next message
         BCT   R3,HELPMSGS                       Keep displaying
         B     WAIT                              Return to wait loop
*   COMMAND:   STOP                                                 *
*   FUNCTION:  To end of monitor                                    *
*   PARAMETER: None                                                 *
ENDPRG   $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=204
ENDPRG2  LA    R10,4(,R10)         Return 4 bytes on from
         BR    R10                    the calling address
         DROP  R2
         DROP  R3
*                Release working storage used for data table        *
KILLSTOR LM    R0,R1,STORLEN       Reload storage size/address
         FREEMAIN R,LV=(0),A=(1)   Free up storage
         BR    R10
*                Reset the XMEMORY authorization index              *
KILLAUTH MODESET MODE=SUP          Supervisor state for AXSET
         AXSET AX=AXSAVE           Reset authorization index value
         MODESET MODE=PROB         Back to problem state
         BR      R10               Return to caller
*         EXIT : TIMERP                                             *
*                This routine will be entered when the STIMER       *
*                expires. It will post the timer ECB and return.    *
         USING *,R15
TIMERP   LA    R2,TIMERECB         Address timer ECB
         POST  (R2)                Flag timer complete
         BR    R14                 Return to caller
         DROP  R15
*   STATIC STORAGE                                                  *
SETALET  DC    F'0'                AR0  ALET - Our address space
         DC    F'0'                AR1  ALET - Our address space
         DC    F'1'                AR2  ALET - VTAM address space
         DC    F'1'                AR3  ALET - VTAM address space
         DC    F'1'                AR4  ALET - VTAM address space
         DC    F'1'                AR5  ALET - VTAM address space
         DC    F'1'                AR6  ALET - VTAM address space
         DC    F'0'                AR7  ALET - Our address space
         DC    F'0'                AR8  ALET - Our address space
         DC    F'0'                AR9  ALET - Our address space
         DC    F'0'                AR10 ALET - Our address space
         DC    F'0'                AR11 ALET - Our address space
         DC    F'0'                AR12 ALET - Our address space
         DC    F'0'                AR13 ALET - Our address space
         DC    F'0'                AR14 ALET - Our address space
         DC    F'0'                AR15 ALET - Our address space
KILLALET DC    F'0'                AR0  ALET - Our address space
         DC    F'0'                AR1  ALET - Our address space
         DC    F'0'                AR2  ALET - Our address space
         DC    F'0'                AR3  ALET - Our address space
         DC    F'0'                AR4  ALET - Our address space
         DC    F'0'                AR5  ALET - Our address space
         DC    F'0'                AR6  ALET - Our address space
         DC    F'0'                AR7  ALET - Our address space
         DC    F'0'                AR8  ALET - Our address space
         DC    F'0'                AR9  ALET - Our address space
         DC    F'0'                AR10 ALET - Our address space
         DC    F'0'                AR11 ALET - Our address space
         DC    F'0'                AR12 ALET - Our address space
         DC    F'0'                AR13 ALET - Our address space
         DC    F'0'                AR14 ALET - Our address space
         DC    F'0'                AR15 ALET - Our address space
R10SAVE  DC    F'0'                Ran out of registers
TI1      DC    CL20'Incorrect length'   Timer value invalid reasons
TI2      DC    CL20'Not 6 numerics  '
TI3      DC    CL20'Hours invalid   '
TI4      DC    CL20'Minutes invalid '
TI5      DC    CL20'Seconds invalid '
TI6      DC    CL20'Less than 5 seconds'
DISALL   DC    CL25'ALL '
DISHELD  DC    CL25'Not-open with HSQH chain'
DISNOPN  DC    CL25'All which are NOT Open  '
STATUS   DC    CL8'Reset   '       VRBVRFSM     0
         DC    CL8'Inactive'                    1
         DC    CL8'Pnd.Inac'                    2
         DC    CL8'Flush   '                    3
         DC    CL8'Pnd.Acti'                    4
         DC    CL8'Active  '                    5
         DC    CL8'DACTVR  '                    6
FCFSM    DC    CL8'Blocked '       VRBFCFSM  x'00'
         DC    CL8'Blocked '                 x'01'
         DC    CL8'Held    '                 x'02'
         DC    CL8'Open    '                 x'03'
HELP1    DC    CL50'Command formats: '
         DC    CL50' '
         DC    CL50'  HELP        - Display this help              '
         DC    CL50'  QUERY       - Display monitor status         '
         DC    CL50'  SHOW ALL    - Display all virtual routes     '
         DC    CL50'  SHOW HELD   - Display not open VRs with HSQHs'
         DC    CL50'  SHOW NOPEN  - Display all not open VRs       '
         DC    CL50'  INTERVAL=hhmmss   Set the sampling interval  '
         DC    CL50'  STOP        - Terminate virtual route monitor'
         DC    CL50' '
NHELP    EQU   (*-HELP1)/L'HELP1
ATCVTV   DC    C'VT32'
MFLEXT   EXTRACT COMMAREA,FIELDS=(COMM),MF=L
COMMAREA DS    D                   Communications area for QEDIT
ECBLIST  DS    0F                  ECB's
ECBQEDIT DS    F     )Do Not       Stop/Modify ECB
ECBTIMER DS    F     )Separate     Timer ECB
TIMERECB DS    F'0'                Timer ECB
         LTORG ,
*   DYNAMIC STORAGE - allocated at startup by #LINKAGE              *
         #LINKAGE DSASTART
DOUBLE   DS    D                   Double word work area
TIMER    DS    D                   Time period between checks
FCFSMS   DS    CL8                 Finite state work area
VSTAT    DS    CL8                 Virtual Route status work area
CDATE    DS    F                   Date when VR scan starts
CTIME    DS    F                   Time when VR scan starts
STORLEN  DS    F     )Do           Length of getmained storage
STORADR  DS    F     )Not          Address of getmained storage
STOREND  DS    F     )Separate     End of getmained storage
VTSEND   DS    F                   End of TH/RU save area
HSQNEXT  DS    F                   ->Next HSQH control block
HOSTSA   DS    F                   Host sub-area number
HOSTE    DS    H                   Host element
ASIDMINE DS    H                   ASID of my address space
ASIDSAVE DS    H                   ASID of the VTAM job
AXSAVE   DS    H                   Current authorization index
AXSET1   DS    H                   Authorization index of 1
THISSUB  DS    H                   Currently processing subarea
NUMSA    DS    H                   Number of subareas to scan
FORMATF  DS    X                   Print formatting flag :-
FMTHDR   EQU   X'80'                 Headings have been displayed
FMTHDR2  EQU   X'40'                 Sub-section headings produced.
FMTPRT   EQU   X'20'                 One or more entries listed
SHOWFLAG DS    X                   VR display control flag :-
SHOWALL  EQU   X'80'                 Always display virtual route
SHOWHELD EQU   X'40'                 Display VRs with HSQH chain
SHOWNOPN EQU   X'20'                 Display all not open VRs
QDEPTH   DS    PL3                 TSCB and HSQH chain depths
OPRCMD   DS    CL80                Stop/Modify data save buffer
RESSAV   DS    A                   Offset into RESTAB
RESTAB   DS    16XL20              #tp * #HSQH + 1 (3*15)+1
         #LINKAGE DSAEND
*   MAPPING MACROS AND EQUATES                                      *
*                               OFFSETS INTO ATCVT :-
ATCSTAT  EQU   X'42C'              VTAM status byte 1
ATCACTIV EQU   X'40'               VTAM is active flag
ATCSIBQ  EQU   X'3F8'              CIB queue pointer
ATCHOSTA EQU   X'438'              Host sub-area number
ATCHOSTE EQU   X'43C'              Host element number
ATCMAXID EQU   X'481'              Maximum sub-areas
ATCVRNDX EQU   X'5EC'              ->VRtable anchors
ATCASID  EQU   X'68A'              VTAM ASID
*                               OFFSETS INTO VRBLK :-
VRBVRN   EQU   X'02'               Virtual route number
VRBFXCHN EQU   X'04'               ->Next VRBLK for this subarea
VRBADJSA EQU   X'08'               Adjacent subarea number
VRBFSTS  EQU   X'40'               Offset - Transmission Priorities
VRBDSTSA EQU   X'A4'               Destination subarea number
*                               OFFSETS INTO PATH INFO VRBIBASE:-
VRBVRFSM EQU   X'00'               Virtual route state
VRBPRI   EQU   X'01'               Flow control finite state
VRBPALIM EQU   X'03'               Actual window size
VRBSESSQ EQU   X'04'               ->HSQH chain
VRBRHOLD EQU   X'08'               ->TSCB on hold queue
VRBSECNT EQU   X'0C'               Session count
VRBMINWS EQU   X'18'               Window minimum size
VRBMAXWS EQU   X'19'               Window maximum size
*                               STATUS FLAGS FOR PRIORITY INFO :-
VRBVRFAC EQU   X'05'               TP is ACTIVE
VRBFCFOP EQU   X'03'               TP is OPEN
*                               OFFSETS INTO TSCB/Transmission Header
TSCNEXT  EQU   X'04'               ->Next TSCB (if any)
TSCTH4   EQU   X'27'               Transmission Header offset
TSCRU    EQU   X'44'               RU contents
TH4DSAF  EQU   X'08'               Destination subarea
TH4OSAF  EQU   X'0C'               Origin subarea
TH4DEF   EQU   X'12'               Destination element
TH4OEF   EQU   X'14'               Origin element
TSCRH    EQU   X'41'               Offset to RH data in TSCB
RHF0     EQU   X'00'               RH flag bits
*                               OFFSETS for HSQH/NCB/FMCB data
HSQCHAIN EQU   X'00'               ->next HSQH in chain
FMCPSSA  EQU   X'84'               Offset to PSSA section of FMCB
TSPDEBA  EQU   X'00'                 Offset in PSSA to ACDEB pointer
ACDUNTNM EQU   X'78'                 Offset to application in ACDEB
FMCPCSA  EQU   X'48'               Offset to TSPPCSA in FMCB
TSPSPEA  EQU   X'1A'                 Offset to partner Ele in TSPPCSA
TSPSPSA  EQU   X'1C'                 Offset to partner SA in TSPPCSA
NCBUNAME EQU   X'C0'               Offset to unitname in NCB
NCBRDTE  EQU   X'04'               ->RDT entry in NCB
RPRNAME  EQU   X'A0'                 Offset into RDT of unit name
FMCB     EQU   X'03'               NCB type code for FMCB
ICNCB    EQU   X'06'               NCB type code for ICNCB
LDNCB    EQU   X'07'               NCB type code for LDNCB
*                               OFFSETS for SIB scan
SIBBFWD  EQU   X'30'               ->Next CIB in chain
SIBOLU   EQU   X'88'               Origin entry
SIBDLU   EQU   X'C0'               Destination entry
SIBRNETA EQU   X'32'               Network addr in OLU/DLU
SIBRALNM EQU   X'08'               Resource name in OLU/DLU
*  Data records are made up of the following structure:               *
*    VTDATA structure                                                 *
*     .    Fixed header information                                   *
*     .    VPDATA structure (priority 0)                              *
*     .    .   Fixed header information                               *
*     .    .   VTSDATA structure                                      *
*     .    .   VHSDATA structure                                      *
*     .    VPDATA structure (priority 1)                              *
*     .    .   Fixed header information                               *
*     .    .   VTSDATA structure                                      *
*     .    .   VHSDATA structure                                      *
*     .    VPDATA structure (priority 2)                              *
*     .    .   Fixed header information                               *
*     .    .   VTSDATA structure                                      *
*     .    .   VHSDATA structure                                      *
*     End of record                                                   *
VTDATA   DSECT ,                Dsect for extracted data :-
VTDATE   DS    F                   Date in packed format: 0cyydddf
VTTIME   DS    F                   Time in format HHMMSSth
VTSUBA   DS    H                   Current subarea
VTASUBA  DS    H                   Adjacent subarea
VTDSUBA  DS    H                   Destination subarea
VTVRNO   DS    H                   Virtual route number
VTTSCBD  DS    H                   TSCB queue depth
VTHSQHD  DS    H                   HSQH held entries
VTP0     DS    XL315               Priority 0   )
VTP1     DS    XL315               Priority 1   )-See DSECT VPDATA
VTP2     DS    XL315               Priority 2   )
VTPEND   DS    X                   End of priority marker
LSAVE    EQU   *-VTDATA            Length of save data
VPDATA   DSECT ,                Dsect for path specific data
VPFCFSM  DS    X                   Pri/Sec flags and HOLD status
VPSTATE  DS    X                   Virtual route state
VPSESS   DS    XL2                 Number of sessions
VPMINW   DS    XL2                 Minimum window size
VPMAXW   DS    XL2                 Maximum window size
VPACTW   DS    XL2                 Actual window size
VPTSCB   DS    5XL46               Upto 5 TH/RH/RU's (VTSDATA)
LTSCBS   EQU   *-VPTSCB              Length of TSCB save area
VPHSQH   DS    5XL15               Upto 5 HSQH's     (VHSDATA)
LHSQHS   EQU   *-VPHSQH              Length of HSQH save area
LTPSAVE  EQU   *-VPDATA
VTSDATA  DSECT ,                Transmission header/RU data :-
VPTHDSAF DS    XL4                 Destination subarea
VPTHDEF  DS    XL2                 Destination element field
VPTHDNAM DS    XL8                 Destination name
VPTHOSAF DS    XL4                 Origin subarea
VPTHOEF  DS    XL2                 Origin element field
VPTHONAM DS    XL8                 Origin name
VPRH     DS    XL2                 RH data
VPRU     DS    XL16                16 bytes of RU data
LTSSAVE  EQU   *-VTSDATA
VHSDATA  DSECT ,                Half Session Queue header data :-
VHSTYPE  DS    X                   HSQH type
VHSNAME  DS    XL8                 Resource name
VHSPSA   DS    XL4                 FMCB partner subarea address
VHSPEA   DS    XL2                 FMCB partner element address
LHQSAVE  EQU   *-VHSDATA
         CVT   DSECT=YES
         IEZCIB ,
         IEZCOM ,
*        RU TYPE LOOKUP TABLES                                        *
YJP$FMD  CSECT ,
         DC    X'010201',C'CONTACT          '
         DC    X'010202',C'DISCONTACT       '
         DC    X'010203',C'IPLINIT          '
         DC    X'010204',C'IPLTEXT          '
         DC    X'010205',C'IPLFINAL         '
         DC    X'010206',C'DUMPINIT         '
         DC    X'010207',C'DUMPTEXT         '
         DC    X'010208',C'DUMPFINAL        '
         DC    X'010209',C'RPO              '
         DC    X'01020A',C'ACTLINK          '
         DC    X'01020B',C'DACTLINK         '
         DC    X'01020E',C'CONNOUT          '
         DC    X'01020F',C'ABCONN           '
         DC    X'010211',C'SETCV (CONFIG)   '
         DC    X'010214',C'ESLOW            '
         DC    X'010215',C'EXSLOW           '
         DC    X'010216',C'ACTCONNIN        '
         DC    X'010217',C'DACTCONNIN       '
         DC    X'010218',C'ABCONNOUT        '
         DC    X'010219',C'ANA              '
         DC    X'01021A',C'FNA              '
         DC    X'01021B',C'REQDISCONT       '
         DC    X'010280',C'CONTACTED        '
         DC    X'010281',C'INOP             '
         DC    X'010284',C'REQCONT          '
         DC    X'010285',C'NS_LSA           '
         DC    X'010301',C'EXECTEST         '
         DC    X'010302',C'ACTTRACE         '
         DC    X'010303',C'DACTTRACE        '
         DC    X'010311',C'SETCV (MAINT)    '
         DC    X'010331',C'DISPSTOR         '
         DC    X'010334',C'RECSTOR          '
         DC    X'010380',C'REQTEST          '
         DC    X'010381',C'RECMS            '
         DC    X'010382',C'RECTD            '
         DC    X'010383',C'RECTRD           '
         DC    X'010604',C'NSPE             '
         DC    X'010681',C'INIT_SELF (FMT0) '
         DC    X'010683',C'TERM_SELF (FMT0) '
         DC    X'410210',C'RNAA             '
         DC    X'41021C',C'DELETENR         '
         DC    X'41021D',C'ER_INOP          '
         DC    X'41021E',C'ADDLINK          '
         DC    X'410220',C'NOTIFY (SSCP-PU) '
         DC    X'410221',C'ADDLINKSTA       '
         DC    X'410223',C'VR_INOP          '
         DC    X'410235',C'INITPROC         '
         DC    X'410236',C'PROCSTAT         '
         DC    X'410237',C'LDREQD           '
         DC    X'410240',C'REQACTLU         '
         DC    X'410243',C'NS_IPL_INIT      '
         DC    X'410244',C'NS_IPL_TEXT      '
         DC    X'410245',C'NS_IPL_FINAL     '
         DC    X'410246',C'NS_IPL_ABORT     '
         DC    X'410286',C'REQFNA           '
         DC    X'410287',C'LCP              '
         DC    X'410289',C'ROUTE_INOP       '
         DC    X'41028A',C'REQACTCDRM       '
         DC    X'410304',C'REQMS            '
         DC    X'410305',C'TESTMODE         '
         DC    X'410307',C'ROUTE_TEST       '
         DC    X'410384',C'RECFMS           '
         DC    X'410385',C'RECTR            '
         DC    X'410386',C'ER_TESTED        '
         DC    X'41038D',C'NMVT             '
         DC    X'810381',C'ECHO_CHECK       '
         DC    X'810387',C'REQECHO          '
         DC    X'810389',C'ECHOTEST         '
         DC    X'810601',C'CINIT            '
         DC    X'810602',C'CTERM            '
         DC    X'810620',C'NOTIFY SSCP/LU   '
         DC    X'810629',C'CLEANUP          '
         DC    X'810680',C'INIT_OTHER       '
         DC    X'810681',C'INIT_SELF (FMT1) '
         DC    X'810682',C'TERM_OTHER       '
         DC    X'810683',C'TERM_SELF (FMT1) '
         DC    X'810685',C'BINDF            '
         DC    X'810686',C'SESSST           '
         DC    X'810687',C'UBINDF           '
         DC    X'810688',C'SESSEND          '
         DC    X'810810',C'FORWARD          '
         DC    X'810812',C'DELIVER          '
         DC    X'810814',C'CNM CONTROL      '
         DC    X'818620',C'NOTIFY SSCP/SSCP '
         DC    X'818627',C'DSRLST           '
         DC    X'818640',C'INIT_OTHER_CD    '
         DC    X'818641',C'CDINIT           '
         DC    X'818642',C'TERM_OTHER_CD    '
         DC    X'818643',C'CDTERM           '
         DC    X'818645',C'CDSESSSF         '
         DC    X'818646',C'CDSESSST         '
         DC    X'818647',C'CDSESSTF         '
         DC    X'818648',C'CDSESSEND        '
         DC    X'818649',C'CDTAKED          '
         DC    X'81864A',C'CDTAKEDC         '
         DC    X'81864B',C'CDCINIT          '
         DC    X'FFFFFF',C'Unknown type     '
YJP$NC   CSECT ,
         DC    X'020000',C'NC_IPL_FINAL     '
         DC    X'030000',C'NC_IPL_INIT      '
         DC    X'040000',C'NC_IPL_TEXT      '
         DC    X'050000',C'LSA              '
         DC    X'060000',C'NC_ER_INOP       '
         DC    X'070000',C'ANS_COMPLETE     '
         DC    X'080000',C'LOST_PATH        '
         DC    X'090000',C'NC_ER_TEST       '
         DC    X'0A0000',C'NC_ER_TEST_REPLY '
         DC    X'0B0000',C'NC_ER_ACT        '
         DC    X'0C0000',C'NC_ER_ACT_REPLY  '
         DC    X'0D0000',C'NC_ACTVR         '
         DC    X'0E0000',C'NC_DACTVR        '
         DC    X'0F0000',C'NC_ER_OP         '
         DC    X'460000',C'NC_IPL_ABORT     '
         DC    X'500000',C'NCP_INIT_COMPLETE'
         DC    X'510000',C'SWITCH_EP/NCP    '
         DC    X'520000',C'SWITCH_NCP/EP    '
         DC    X'FFFFFF',C'Unknown type     '
YJP$DFC  CSECT ,
         DC    X'040000',C'LUSTAT           '
         DC    X'050000',C'RTR              '
         DC    X'700000',C'BIS              '
         DC    X'710000',C'SBI              '
         DC    X'800000',C'QEC              '
         DC    X'810000',C'QC               '
         DC    X'820000',C'RELQ             '
         DC    X'830000',C'CANCEL           '
         DC    X'840000',C'CHASE            '
         DC    X'C00000',C'SHUTD            '
         DC    X'C10000',C'SHUTC            '
         DC    X'C20000',C'RSHUTD           '
         DC    X'C80000',C'BID              '
         DC    X'C90000',C'SIG              '
         DC    X'FFFFFF',C'Unknown type     '
YJP$SC   CSECT ,
         DC    X'0D0000',C'ACTLU            '
         DC    X'0E0000',C'DACTLU           '
         DC    X'110000',C'ACTPU            '
         DC    X'120000',C'DACTPU           '
         DC    X'140000',C'ACTCDRM          '
         DC    X'150000',C'DACTCDRM         '
         DC    X'310000',C'BIND             '
         DC    X'320000',C'UNBIND           '
         DC    X'A00000',C'SDT              '
         DC    X'A10000',C'CLEAR            '
         DC    X'A20000',C'STSN             '
         DC    X'A30000',C'RQR              '
         DC    X'C00000',C'CRV              '
         DC    X'FF3100',C'GENERIC BIND     '
         DC    X'FF3200',C'GENERIC UNBIND   '
         DC    X'FFFFFF',C'Unknown type     '
*   MESSAGE CSECT FOR THE $MSG MACRO                                *
*   NOTE: in testing, change message VRM005I to VRM005T to stop     *
*         alerts being generated in NPDA.                           *
MSGSECT  CSECT  ,
         $MSGTEXT MSG=1,TEXT='VRM001I Virtual Route monitor started'
         $MSGTEXT MSG=2,TEXT='VRM002I % %     Virtual Route          Wi*
               ndow             TSCBq  HSQHs '
         $MSGTEXT MSG=3,TEXT='VRM003I SA# VR  TP  ADJ  State       FSM *
                   Min   Cur  Max   #Sess  Depth  Held'
         $MSGTEXT MSG=5,TEXT='VRM005I  % %  %   %  %  %  %   %  %   %  *
                %  %'
         $MSGTEXT MSG=6,TEXT='VRM006I Dest Subarea/Element   Orig Subar*
               ea/Element   RU '
         $MSGTEXT MSG=7,TEXT='VRM007I %.% (%)   %.% (%)   % (%) '
         $MSGTEXT MSG=8,TEXT='VRM008I  HSQH Type    Resource'
         $MSGTEXT MSG=9,TEXT='VRM009I  % (%)   % '
         $MSGTEXT MSG=10,TEXT='VRM010I  Unknown HSQH type (%) at addres*
               s:  % '
         $MSGTEXT MSG=11,TEXT='VRM011I  % (%)   %  (PartnerSA: %  Partn*
               erEle: % ) '
*   Major disaster messages                                         *
         $MSGTEXT MSG=100,TEXT='VRM100E Unable to locate VTAM ASID '
*   Command parsing/information messages (See: WAIT)                *
         $MSGTEXT MSG=200,TEXT='VRM200E Invalid command : % '
         $MSGTEXT MSG=201,TEXT='VRM201I New timer value set to: %'
         $MSGTEXT MSG=202,TEXT='VRM202E Invalid timer value % (%)'
         $MSGTEXT MSG=203,TEXT='VRM203I Current timer value: %'
         $MSGTEXT MSG=204,TEXT='VRM204I STOP command acknowledged '
         $MSGTEXT MSG=205,TEXT='VRM205I Display changed to ALL virtual *
               routes '
         $MSGTEXT MSG=206,TEXT='VRM206I Display changed to virtual rout*
               es with an HSQH chain'
         $MSGTEXT MSG=207,TEXT='VRM207I Display changed to "Not Open" v*
               irtual routes'
         $MSGTEXT MSG=208,TEXT='VRM208I Virtual routes being displayed:*
                % '
         $MSGTEXT MSG=209,TEXT='VRM209I NOT monitoring the host subarea*
                (%) '
*   Useful blank line and useful dummy line                         *
         $MSGTEXT MSG=800,TEXT=' '
         $MSGTEXT MSG=801,TEXT='%'
         DC    X'FFFFFFFF'
         END   ,


#AMODE

*   AMODE switching macro                                             *
         MACRO
&LABEL   #AMODE &AMODE
         AIF   ('&AMODE' EQ '24').AMODE24
         AIF   ('&AMODE' EQ '31').AMODE31
         MNOTE 4,'INVALID AMODE SPECIFIED. MUST BE 24 OR 31'
         MEXIT
.AMODE24 ANOP
&LABEL   LA    15,*+6              TURN OFF 31 BIT ADDRESSING
         BSM   0,15                CHANGE MODE
         MEXIT
.AMODE31 ANOP
&LABEL   LA    15,*+10             DUMMY BRANCH ADDRESS
         O     15,=X'80000000'     SET 31 BIT MODE FLAG
         BSM   0,15                CHANGE MODE
         MEXIT
         MEND


#LINKAGE

*   Entry/exit linkage and dsa definition macro.                      *
         MACRO
&NAME    #LINKAGE &FUNC,&DSA=9,&BASE=12,&AMODE=24,&RMODE=24
         AIF   ('&FUNC' EQ 'START').START
         AIF   ('&FUNC' EQ 'END').END
         AIF   ('&FUNC' EQ 'DSASTART').DSASTRT
         AIF   ('&FUNC' EQ 'DSAEND').DSAEND
         MNOTE 8,'UNKNOWN LINKAGE FUNCTION: &FUNC '
         MEXIT
.*   PROGRAM ENTRY PROCESSING.                                *
.START   ANOP
.*   SETUP GLOBAL AND LOCAL ASSEMBLER VARIABLES, SAVE DSA REGISTER    *
.*   FOR LINKAGE END AND GENERATE THE "&LNKPASS" LOCAL VARIABLE. THIS *
.*   WILL BE USED TO BYPASS THE PROGRAM EYE CATCHER.                  *
         GBLC  &#LNKDSA            DSA REGISTER USED
         GBLB  &#LNKMDE            AMODE/RMODE SET FLAG
         LCLC  &LNKPASS            LOCAL BRANCH LABEL
         LCLC  &AMDE               AMODE VALUE
         LCLC  &RMDE               RMODE VALUE
         LCLC  &BASEREG            LIST OF BASE REGISTERS FOR USING
         LCLA  &LOOPC              USED TO GENERATE BASE REGISTERS
         LCLA  &LOOPMAX            MAXIMUM NUMBER OF BASE REGISTERS
&#LNKDSA SETC  '&DSA'              SAVE DSA REGISTER
&LNKPASS SETC  'LNK&SYSNDX'        SETUP BRANCH LABEL
.*   VERIFY AMODE AND RMODE HAVE VALID VALUES. IF NOT, THEN DEFAULT   *
.*   THE INCORRECT VALUE TO "24".                                     *
.*   IF AMODE IS SET TO 24, THE RMODE CAN NOT BE "ANY".               *
&AMDE    SETC  '&AMODE'
&RMDE    SETC  '&RMODE'
         AIF   ('&AMODE' EQ '24').AMOK
         AIF   ('&AMODE' EQ '31').AMOK
         AIF   ('&AMODE' EQ 'ANY').AMOK
         MNOTE *,'INVALID AMODE &AMODE, DEFAULTED TO AMODE 24'
&AMDE    SETC  '24'
.AMOK    ANOP
         AIF   ('&RMODE' EQ '24').RMOK
         AIF   ('&RMODE' EQ 'ANY').RMOK
         MNOTE *,'INVALID RMODE &RMODE, DEFAULTED TO RMODE 24'
&RMDE    SETC  '24'
.RMOK    ANOP
         AIF   ('&AMODE' NE '24').ARMOK
         AIF   ('&RMODE' NE 'ANY').ARMOK
         MNOTE *,'INVALID AMODE/RMODE COMBINATION. SET TO 24'
&AMDE    SETC  '24'
&RMDE    SETC  '24'
.ARMOK   ANOP
.*   VALIDATE BASE REGISTER HAS BEEN SPECIFIED                        *
         AIF   ('&BASE' NE '').NOT1
         MNOTE 8,'ERROR: BASE REGISTER MUST BE GIVEN'
         MEXIT
.NOT1    ANOP
.*   VALIDATE DSA REGISTER SPECIFIED                                  *
         AIF   ('&DSA' NE '').NOT2
         MNOTE 8,'ERROR: DSA REGISTER MUST BE GIVEN'
         MEXIT
.NOT2    ANOP
.*   IF THE AMODE AND RMODE HAVE ALREADY BEEN SET BY A PREVIOUS       *
.*   LINKAGE MACRO, WE SHOULD NOT DO IT AGAIN.  LIKEWISE, IF WE HAVE  *
.*   ALREADY EQUATED THE REGISTERS, WE SHOULD NOT DO THAT AGAIN.      *
         AIF   (&#LNKMDE).MODESET
         AMODE &AMDE
         RMODE &RMDE
&#LNKMDE SETB  1
.MODESET AIF   (D'R0 ).NOEQU
         YREGS
AR0      EQU   0
AR1      EQU   1
AR2      EQU   2
AR3      EQU   3
AR4      EQU   4
AR5      EQU   5
AR6      EQU   6
AR7      EQU   7
AR8      EQU   8
AR9      EQU   9
AR10     EQU   10
AR11     EQU   11
AR12     EQU   12
AR13     EQU   13
AR14     EQU   14
AR15     EQU   15
.NOEQU   ANOP
&NAME    CSECT
         SAVE (14,12)              SAVE CALLERS REGISTERS
.*   SETUP THE BASE REGISTER(S). SINCE WE MAY HAVE MORE THAN ONE, WE  *
.*   CODE A LOOP TO SCAN THE &BASE VARIABLE.                          *
.*   &LOOPC   IS USED TO CONTROL THE LOOP                             *
.*   &LOOPMAX IS THE NUMBER OF ITERATIONS TO MAKE (IE THE NUMBER OF   *
.*                   REGISTERS SPECIFIED FOR BASE)                    *
&LOOPMAX SETA  N'&BASE
&LOOPC   SETA  1
.*   SETUP THE FIRST BASE REGISTER, AND LOAD IT FROM REGISTER 15      *
         LR    &BASE(1),15         SETUP BASE REGISTER
         AGO   .LOOP2              GO VALIDATE THE REGISTER USED
.*   SETUP SUBSEQUENT BASE REGISTERS TO POINT 4096 BYTES ON FROM THE  *
.*   PREVIOUS BASE REGISTER.                                          *
.LOOP1   ANOP
         LA    &BASE(&LOOPC),4095(,&BASE(&LOOPC-1))  LAST BASE+4095
         LA    &BASE(&LOOPC),1(,&BASE(&LOOPC))       LAST BASE+4096
.LOOP2   AIF   ('&BASE(&LOOPC)' NE '&DSA').LOOP3
         MNOTE 8,'ERROR: BASE/DSA REGISTERS CAN NOT BE THE SAME'
         MEXIT
.LOOP3   ANOP
.*   BUILD THE REGISTER LIST FOR THE "USING" STATEMENT.               *
&BASEREG SETC  '&BASEREG,&BASE(&LOOPC)'      SETUP BASE REGISTER STRING
&LOOPC   SETA  &LOOPC+1                      COUNT 1 REGISTER USED
         AIF   (&LOOPC LE &LOOPMAX).LOOP1    LOOP TILL ALL CHECKED
.*   DROP THROUGH HERE WHEN ALL BASE REGISTERS HAVE BEEN PROCESSED.   *
         USING &NAME&BASEREG
         B     &LNKPASS
         DC    C'CSECT: &NAME  ASSEMBLED: &SYSDATE &SYSTIME'
         DS    0H
&LNKPASS LR    R2,R1               SAVE PARAMETER REGISTER
         GETMAIN R,LV=DSALEN       GET SAVE AREA STORAGE
         ST    R1,8(,R13)          STORE FORWARD POINTER
         ST    R13,4(,R1)          STORE BACKWARD POINTER
         LR    R13,R1              SETUP SAVE AREA POINTER
         LR    &DSA,R1             SETUP DSA POINTER
         USING DSA,&DSA
         LR    R1,R2               RESTORE POINTER TO PARMS
         MEXIT
.*   PROGRAM TERMINATION PROCESSING                                   *
.END     ANOP
         GBLC  &#LNKDSA            DSA REGISTER IN LAST LINKAGE
&NAME    LR    R1,&#LNKDSA         GET DSA ADDRESS
         LR    R2,R15              SAVE RETURN CODE
         L     R13,4(,R13)         RESTORE SAVE AREA POINTER
         FREEMAIN R,LV=DSALEN,A=(1)
         LR    R15,R2              RESTORE RETURN CODE
         RETURN (14,12),RC=(15)    RETURN TO CALLER
         MEXIT
.*   DSA GENERATION - GENERATES DSA DSECT NAME AND SAVE AREA          *
.DSASTRT ANOP
DSA      DSECT
         DS    18F                 REGISTER SAVE AREA
         MEXIT
.*   END OF DSA AREA - GENERATED EQUATE FOR DSA LENGTH                *
.DSAEND  ANOP
DSALEN   EQU   *-DSA
         MEXIT
         MEND


$MSG

*   Generic WTO/TPUT etc messages with substitution.                  *
         MACRO
&LABEL   $MSG  &MSG=,&EP=,&TABLE=,&TYPE,&CHAR=,&FIELDS=,&MF=I
&WORDS   SETA  5
&J       SETA  1
.DEFLOOP AIF   ('&FIELDS(&J)' EQ '').MF1
&WORDS   SETA  &WORDS+2
&J       SETA  &J+3
         AGO   .DEFLOOP
.MF1     AIF   ('&MF(1)' EQ 'I').MF5
         AIF   ('&MF(1)' EQ 'L').MF2
         AIF   ('&MF(1)' EQ 'E').MF3
         MNOTE 8,'$MSG MACRO - INVALID MF VALUE'
         MEXIT
.MF2     ANOP
&LABEL   DC    &WORDS.F'0'         WORKAREA
         MEXIT
.MF3     AIF   ('&MF(2)' NE '').MF4
         MNOTE 8,'$MSG MACRO - INVALID MF EXECUTE VALUE'
         MEXIT
.MF4     ANOP
&LABEL   IHBINNRA &MF(2)
         LR    R14,R1              ->WORKAREA
         AGO   .MSG
.MF5     ANOP
&LABEL   CNOP  0,4
         BAL   R14,*+4+(&WORDS*4)  ->WORKAREA
         DC    &WORDS.F'0'         WORKAREA
.MSG     AIF   ('&MSG' EQ '').TABLE
         IHBINNRA &MSG
         STH   R1,10(,R14)         SAVE MESSAGE NUMBER
.TABLE   AIF   ('&TABLE' EQ '').TYPE
         L     R1,=V(&TABLE)       ->MESSAGE TABLE
         ST    R1,0(,R14)          SAVE MESSAGE TABLE ADDRESS
.TYPE    AIF   ('&TYPE' EQ '').CHAR
         AIF   ('&TYPE' NE 'TPUT').TYPEWTO
         MVI   12(R14),1           SET DISPLAY TO TPUT
         AGO   .CHAR
.TYPEWTO AIF   ('&TYPE' NE 'WTO').TYPEBUF
         MVI   12(R14),2           SET DISPLAY TO WTO
         AGO   .CHAR
.TYPEBUF AIF   ('&TYPE' NE 'BUFFER').TYPERR
         MVI   12(R14),3           SET DISPLAY TO RETURN BUFFER
         AGO   .CHAR
.TYPERR  MNOTE 8,'$MSG MACRO - INVALID DISPLAY TYPE'
         MEXIT
.CHAR    AIF   ('&CHAR' NE '').CHARSET
         MVI   13(R14),C'%'        SET SUBSTITUTION CHARACTER
         AGO   .VARINIT
.CHARSET ANOP
         MVI   13(R14),C'&CHAR'    SET SUBSTITUTION CHARACTER
.VARINIT ANOP
&I       SETA  1
&ADDR    SETA  20
.VARLOOP AIF   ('&FIELDS(&I)' EQ '').CALL
         IHBINNRA &FIELDS(&I)
         ST    R1,&ADDR.(,R14)     SET VARIABLE ADDRESS
         IHBINNRA &FIELDS(&I+1)
         STH   R1,&ADDR+4(,R14)    SET VARIABLE LENGTH
         AIF   ('&FIELDS(&I+2)' NE 'CHAR').VARHEX
         MVI   &ADDR+6(R14),1      SET VARIABLE TYPE TO CHARACTER
         AGO   .VARNEXT
.VARHEX  AIF   ('&FIELDS(&I+2)' NE 'HEX').VARDEC
         MVI   &ADDR+6(R14),2      SET VARIABLE TYPE TO HEXADECIMAL
         AGO   .VARNEXT
.VARDEC  AIF   ('&FIELDS(&I+2)' NE 'DEC').VARBIN
         MVI   &ADDR+6(R14),3      SET VARIABLE TYPE TO DECIMAL
         AGO   .VARNEXT
.VARBIN  AIF   ('&FIELDS(&I+2)' NE 'BIN').VARBINH
         MVI   &ADDR+6(R14),4      SET VARIABLE TYPE TO BINARY WORD
         AGO   .VARNEXT
.VARBINH AIF   ('&FIELDS(&I+2)' NE 'BINH').VARDUMP
         MVI   &ADDR+6(R14),5      SET VARIABLE TYPE TO BINARY HALF
         AGO   .VARNEXT
.VARDUMP AIF   ('&FIELDS(&I+2)' NE 'DUMP').VARERR
         MVI   &ADDR+6(R14),6      SET VARIABLE TYPE TO HEX DUMP
         AGO   .VARNEXT
.VARERR  MNOTE 8,'$MSG MACRO - UNRECOGNIZED FIELD TYPE'
.VARNEXT ANOP
&I       SETA  &I+3
&ADDR    SETA  &ADDR+8
         AGO   .VARLOOP
.CALL    LA    R1,20(,R14)         ->VARIABLE LIST
         ST    R1,16(,R14)         SET IN PARAMETER LIST
         AIF   ('&EP' EQ '').CALL1
         IHBINNRA &EP
         LR    R15,R1
         AGO   .CALL2
.CALL1   L     R15,=V(YJP$MSG)     ->FORMAT ROUTINE
.CALL2   LR    R1,R14              ->PARAMETER LIST
         BALR  R14,R15             INVOKE FORMAT ROUTINE
         MEND


$MSGTEXT

*   Message definition macro, for use with $MSG                       *
         MACRO
&LABEL   $MSGTEXT &MSG=,&TEXT=
         LCLA  &LEN
         AIF   (T'&MSG NE 'N').BAD1
         AIF   ('&TEXT' EQ '').BAD2
&LEN     SETA  K'&TEXT-2
         DC    AL2(&MSG)           MESSAGE NUMBER
         DC    AL2(&LEN)           MESSAGE TEXT LENGTH
         DC    C&TEXT
         MEXIT
.BAD1    MNOTE 8,'INVALID MESSAGE NUMBER '
         MEXIT
.BAD2    MNOTE 8,'MESSAGE TEXT MISSING   '
         MEXIT
         MEND


Steve Barnett
Senior Technical Consultant
IMI Computing Ltd (UK)

