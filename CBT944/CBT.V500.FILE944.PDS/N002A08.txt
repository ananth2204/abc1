SNA request/response formatter

The following article describes the components of a system run
at our site that gives us an overview of the data flow to and
from a terminal.  The system consists of a batch job, a CLIST,
and a REXX EXEC.  Not all possible SNA RUs are handled by
the system.


BATCH JOB STREAM

The primary input to our system is the output from the batch
execution of IPCS (see Figure 1, pages 49-50).  This output is
then processed using ISRSUPC (SUPERC) (see Figure 2,
pages 51-52).  The output from the SUPERC stage is input to a
batch execution of the CLIST VTAMTRC producing the output
shown in Figure 3 (page 53).  The output from this step is used
as the input to the final stage, the batch execution of the
REXX, HVCFTQSH, and gives us the kind of listing shown in
Figure 4 (page 54).

//TSHVRA   JOB (EDS),'VTAMTRC',CLASS=A,MSGCLASS=X,NOTIFY=TSHVR
//* DOC: ISPF/PDF V2R3 GUIDE PG 348 (LISTING) & 371
//*      PANEL 3.13 HELP 2
//* RC=1 IS NORMAL
//DEL      EXEC PGM=IDCAMS
//SYSPRINT DD SYSOUT=X
//SYSIN    DD *
   DELETE TSHVR.VTAMTRC.@1
   IF LASTCC LE 8 THEN SET MAXCC=0
/*
//SUPERC   EXEC PGM=ISRSUPC,
//            PARM='L,SRCHCMP,NOPRTCC'
//STEPLIB  DD  DSN=ISR.V3R1M0.ISRLOAD,DISP=SHR
//* NEWDD IS OUTPUT OF BATCH IPCS 'GTFTRACE USR(FE1 FEF FF0 FF2 FE2)'
//NEWDD    DD  DSN=TSEDS.OUTPUT1,DISP=SHR
//* OUTDD : SEE NOTE3 FOR FORMAT OF OUTDD
//OUTDD    DD  DSN=TSHVR.VTAMTRC.@1,DISP=(NEW,CATLG),
//            SPACE=(TRK,(10,5),RLSE),UNIT=3380,VOL=SER=VOL001,
//            DCB=(RECFM=FB,LRECL=132,BLKSIZE=23364)
//SYSIN    DD  *
   CMPCOLM 13:25
   LSTCOLM 13:92
   SRCHFOR 'BUFF',WORD
   SRCHFOR 'VTAM',WORD
   SRCHFOR 'TIME:',WORD
   SRCHFOR '             '
/*
//* ISRSUPC MAY GIVE RC 1
//FMT1  EXEC ISPFBTCH,COND=(1,LT)
//SYSPROC DD DSN=TSHVR.TEST.CLIST,DISP=SHR
//*RECI    DD  DSN=TSHVR.VTAMTRC.@1,DISP=SHR
//*RECO    DD  DSN=TSHVR,VTAMTRC.@2,DISP=SHR
//SYSTSIN  DD  *
 ISPSTART CMD(%VTAMTRC)
/*
//* A SORT JOB COULD BE INSERTED HERE TO SORT OUT CERTAIN ITEMS
//*  IN RECO
//FMT2  EXEC ISPFBTCH,COND=(1,LT)
//SYSPROC DD DSN=TSHVR.TEST.CLIST,DISP=SHR
//*RECI    DD  DSN=TSHVR.VTAMTRC.@2,DISP=SHR
//* EXEC  HVCFTQSH
//SYSTSIN  DD  *
 ISPSTART CMD(%HVCFTQSH DSN(TSHVR.VTAMTRC.@2))
/*


CLIST VTAMTCR

PROC 0 DEBUG
IF &DEBUG = DEBUG +
  THEN CONTROL LIST CONLIST SYMLIST
CONTROL END(END0)
IF &SYSDSN(VTAMTRC.@2) = OK +
  THEN SET DISP = OLD
  ELSE SET DISP = NEW CATALOG
ALLOC DD(RECO) DA(VTAMTRC.@2) &DISP +
  DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(23440) +
  SPACE(5,2) TRACKS VOLUME(VOL002)
OPENFILE RECO OUTPUT
ALLOC DD(RECI) DA(VTAMTRC.@1) SHR REUSE
OPENFILE RECI INPUT
ERROR +
  DO
  SET &RCODE = &LASTCC
  IF &RCODE ¬= 400 +
    THEN DO
      WRITE ERROR &RCODE
      ERROR
    ENDO
  GOTO CLOS
  ENDO
SET COUNT = 0
SET ISW = 1
NEXT: +
GETFILE RECI
SET SRCH = &SUBSTR(10:13,&STR(&RECI))
IF &SRCH = BUFF +
  THEN DO
    SET DIRECT = &SUBSTR(55:62,&STR(&RECI))
    IF &DIRECT = OUTBOUND +
      THEN SET TERM = &SUBSTR(18:25,&STR(&RECI))
      ELSE SET TERM = &SUBSTR(27:34,&STR(&RECI))
  ENDO
IF &SRCH = VTAM +
  THEN DO
    SET SIZEC = &SUBSTR(75:78,&STR(&RECI))
    SET SIZE = 0
    DO &I = 1 TO 4
      SET CC = &SUBSTR(&I:&I,&SIZEC)
      SET CW = &SYSINDEX(&CC,&STR(0123456789ABCDEF)) - 1
      SET SIZE = &SIZE * 16 + &CW
    ENDO
    SET SIZEO = &STR(&SIZE)
    SET LS = &LENGTH(&SIZEO)
    DO &I = 1 TO 4 - &LS
      SET SIZEO = &STR( &SIZEO)
    ENDO
    SET RH = &SUBSTR(81:89,&STR(&RECI))
    SET ISW = 0
    SET FR = &STR( )
  ENDO
IF &SUBSTR(10:41,&STR(&RECI)) = &STR(                                ) +
  THEN DO
    IF &ISW = 1 THEN GOTO NEXT
    SET ISW = 1
    SET FR = &SUBSTR(42:49,&STR(&RECI))
    GOTO NEXT
  ENDO
IF &SRCH = &STR(    ) +
  THEN DO
    IF &SUBSTR(18:21,&STR(&RECI)) ¬= TIME THEN GOTO NEXT
    SET TIM = &SUBSTR(44:58,&STR(&RECI))
    SET RECO = &STR(&TERM     &TIM     &DIRECT     &SIZEO     +
                &RH  REQ= &FR)
    PUTFILE RECO
    SET COUNT = &COUNT + 1
    IF &COUNT = (&COUNT / 20 ) * 20 +
      THEN WRITE &COUNT
  ENDO
GOTO NEXT
CLOS: +
CLOSFILE RECI
CLOSFILE RECO
FREE DD(RECI)
FREE DD(RECO)


REXX HVCFT9SH

/******************** REXX *******************************************/
TRACE
ARG IETS
RC=0
PARSE VAR IETS . "DSN(" DSN ")"
IF DSN="*" THEN DSN="TSEDS.VTAMTRC.@2"
IF DSN="" THEN
DO
 CALL S_HVCFTQSH IETS,"SAY"
 EXIT RC
END
/* GET INFO FROM FILE */
ADDRESS TSO
"ALLOCATE FILE(RECI) DSN('"DSN"') SHR"
ADDRESS MVS
"EXECIO 1  DISKR  RECI (STEM LINES. "
DO WHILE RC=0
 PARSE VAR LINES.1 TERM TIME DIRECTION NR 'RH=' RH 'REQ= ' RU
 CALL S_HVCFTQSH STRIP(RH,'T')!!STRIP(RU,'B'),"QUEUE"
 PULL ANALYSIS
 SAY TERM TIME SUBSTR(DIRECTION,1,3) ,
       FORMAT(NR,4) ANALYSIS
 "EXECIO 1  DISKR  RECI (STEM LINES. "
END
"EXECIO 0  DISKR  RECI (STEM LINES. FINIS"
ADDRESS TSO
"FRE FILE(RECI)"
EXIT RC
S_HVCFTWSH:PROCEDURE
/***************************************/
/** FORMAT SNA REQUEST/RESPONSE HEADER                     ***********/
TRACE
RC=0
CALL ON ERROR NAME S_ERROR
TRUE=1
BYPASS_RC=0
FORMAT_ERROR=20
IF ARG()=0 THEN CALL S_ERROR(FORMAT_ERROR)
ARG QSH,OOO
IF WORDS(QSH)>1 & OOO="" THEN
DO
 PARSE VAR QSH  QSH OOO
END
IF LENGTH(QSH) <  6 THEN QSH=SUBSTR(QSH,1,6,'0')
IF DATATYPE(QSH,'X') ¬= TRUE THEN CALL S_ERROR(FORMAT_ERROR)
IF OOO="" THEN OOO="SAY"
RESPONSE="RSP";REQUEST="RQ "
SENSE_DATA=" "
REQUEST_NAME=" ";SENSE_DATA=" "
SC="SC ";FMD="FMD";DFC="DFC";NC="NC "
POS="+";NEG="-"
/*QUEUE "***********   ANALYSING REQUEST/RESPONSE HEADER *********"*/
/*QUEUE QSH */
H_X2C=X2C(SUBSTR(QSH,1,6))
/* BYTE 1 */
BYTE1=SUBSTR(H_X2C,1,1)
/*QUEUE "** BYTE  1 :" C2X(BYTE1)*/
BIT7=GET_BIT(BYTE1,7)
IF BIT7 = 0 THEN TYPE=REQUEST
            ELSE TYPE=RESPONSE
/*QUEUE "TYPE   :" BIT7 TYPE*/
BIT6_5=GET_BITS(BYTE1,6,2)
IF      BIT6_5=0 THEN RU_CATEGORY=FMD
ELSE IF BIT6_5=1 THEN RU_CATEGORY=NC
ELSE IF BIT6_5=2 THEN RU_CATEGORY=DFC
ELSE                  RU_CATEGORY=SC
/*QUEUE "RU_CATEGORY :" BIT6_5 RU_CATEGORY*/
/* BIT 4 RESERVED */
/* FORMAT INDICATOR */
FI=GET_BIT(BYTE1,3)
IF FI  THEN  REQUEST_NAME="FMD OR NS  HEADER SHOULD FOLLOW"
/*QUEUE "FORMAT IND:"  FI  */
/* SENSE DATA INCLUDED INDICATOR */
SDI=GET_BIT(BYTE1,2)
IF SIDE THEN SENSE_DATA="SENSE DATA SHOULD FOLLOW"
/*IF BIT2 = 0 THEN SDI="NOSD"
            ELSE SDI="SD"   */
/*QUEUE "SENSE DATA IND:" BIT2 SDI */
BCI=GET_BIT(BYTE1,1)
ECI=GET_BIT(BYTE1,0)
IF BCI=1 THEN
DO
 IF ECI=0 THEN CHAIN="FIC"
          ELSE CHAIN="OIC"
END
ELSE
DO
 IF ECI=0 THEN CHAIN="MIC"
          ELSE CHAIN="LIC"
END
/* BYTE 2 */
BYTE2=SUBSTR(H_X2C,2,1)
/*QUEUE "** BYTE  2 :" C2X(BYTE2) */
/* DEFINITE RESPONSE 1 INDICATOR */
DR1I=GET_BIT(BYTE2,7)
/*QUEUE "DEF RESP 1 IND: "  DR1I */
/* DEFINITE RESPONSE 2 INDICATOR */
DR1I=GET_BIT(BYTE2,5)
/*QUEUE "DEF RESP 2 IND: "  DR2I */
RTI_SYMBOL=" ";RESP_SYMBOL="  "
RTI=GET_BIT(BYTE2,4)
SELECT
 WHEN TYPE=RESPONSE THEN
  DO
   SELECT
    WHEN RTI=0 THEN RTI_SYMBOL=POS
    OTHERWISE       RTI_SYMBOL=NEG
   END
  END
 /* EXCEPTION RESPONSE INDICATOR */
 OTHERWISE DO
  ERI=RTI
  /* TYPE OF RESPONSE INDICATOR */
  RESP=DR1I!!DR2I!!ERI
  IF RESP="000" THEN RESP_SYMBOL="NR"   /* NO RESPONSE */
  ELSE IF ERI=0 THEN RESP_SYMBOL="DR"   /* DEFINITE RESPONSE */
  ELSE IF ERI=1 THEN RESP_SYMBOL="ER"   /* EXCEPTION RESPONSE */
 END
END
PI=GET_BIT(BYTE2,0)
IF PI=0 THEN PI_SYMBOL="¬PAC"
        ELSE PI_SYMBOL=" PAC"
/*QUEUE "PI:" PI  */
/* BYTE 3  ONLY RELEVANT FOR REQUESTS*/
BYTE3=SUBSTR(H_X2C,3,1)
/*QUEUE "** BYTE  3 :" C2X(BYTE3)*/
 BBI_SYM="  ";EBI_SYM="  ";CDI_SYM=" ";CSI_SYM=" ";EDI_SYM=" ";
 PDI_SYM=" ";CEBI_SYM=" "
IF TYPE=REQUEST  THEN
DO
 BBI=GET_BIT(BYTE3,7)
 IF BBI=1 THEN BBI_SYM="BB"
 EBI=GET_BIT(BYTE3,6)
 IF EBI=1 THEN EBI_SYM="EB"
 CDI=GET_BIT(BYTE3,5)
 IF CDI=1 THEN CDI_SYM="CD"
 CSI=GET_BIT(BYTE3,4)
 EDI=GET_BIT(BYTE3,2)
 PDI=GET_BIT(BYTE3,1)
 CEBI=GET_BIT(BYTE3,0)
 /*QUEUE "BBI EBI CDI CSI EDI PDI CEBI"
 QUEUE  BBI EBI CDI CSI EDI PDI CEBI  */
END
/* RU BEGINS AT BYTE 7 */
RU_X2C=X2C(SUBSTR(QSH,7))
IF RU_X2C=="" THEN  /* REG MAY CONTAIN BLANKS */
DO
 /* IS THIS ISOLATED PACING RESPONSE ? */
 IF QSH="830100" THEN REQUEST_NAME="IPR"
END
ELSE
DO
 /* BYTE 1 OF RU */
 RU1=SUBSTR(RU_X2C,1,1)
 RU1=C2X(RU1)
 /*QUEUE "** RU BYTE  1 :" RU1 */
 IF RU_CATEGORY=SC THEN
 DO
  SELECT
   WHEN RU1='11' THEN REQUEST_NAME="ACTPU"
   WHEN RU1='12' THEN REQUEST_NAME="DACTPU"
   WHEN RU1='0D' THEN REQUEST_NAME="ACTLU"
   WHEN RU1='0E' THEN REQUEST_NAME="DACTLU"
   WHEN RU1='31' THEN REQUEST_NAME="BIND"
   WHEN RU1='32' THEN REQUEST_NAME="UNBIND"
   WHEN RU1='A0' THEN REQUEST_NAME="SDT"
   OTHERWISE          REQUEST_NAME="UNKNOWN"
  END/*SELECT*/
  /*QUEUE "REQUEST_NAME :" REQUEST_NAME */
 END/*IF RU_CATEGORY=SC*/
 ELSE IF RU_CATEGORY=DFC THEN
 DO
  IF SDI   THEN
  DO
   SENSE_DATA=SUBSTR(QSH,7)
  END
  ELSE
  DO
   SELECT
    WHEN RU1='C0' THEN REQUEST_NAME="SHUTD"
    WHEN RU1='C1' THEN REQUEST_NAME="SHUTC"
    WHEN RU1='C8' THEN REQUEST_NAME="BID"
    OTHERWISE          REQUEST_NAME="UNKNOWN"
   END/*SELECT*/
   /*QUEUE "REQUEST_NAME :" REQUEST_NAME*/
  END/* IF TYPE=REQUEST */
 END/*ELSE IF RU_CATEGORY=DFC*/
 ELSE IF RU_CATEGORY=FMD THEN
 DO
  IF SDI    THEN
  DO
   SENSE_DATA=SUBSTR(QSH,7)
  END
  ELSE IF FI  THEN
  DO
   FMDNSHDR=SUBSTR(QSH,7,6)
   SELECT
    WHEN  FMDNSHDR="010683"  THEN  REQUEST_NAME="TERM-SELF"
    WHEN  FMDNSHDR="810620"  THEN  REQUEST_NAME="NOTIFY"
    WHEN  FMDNSHDR="818620"  THEN  REQUEST_NAME="NOTIFY"
    WHEN  FMDNSHDR="810681"  THEN  REQUEST_NAME="INIT-SELF"
    OTHERWISE                 REQUEST_NAME="UNKNOWN"
   END
  END/*IF FI */
  ELSE  REQUEST_NAME="USER DATA"
 END/*ELSE IF RU_CATEGORY=FMD */
END/*IF RU_X2C ¬="" */
/* EDITING OUTPUT */
IF OOO="QUEUE" THEN
DO
 QUEUE TYPE!!RTI_SYMBOL RU_CATEGORY CHAIN RESP_SYMBOL PI_SYMBOL ,
  BBI_SYM EBI_SYM CDI_SYM REQUEST_NAME SENSE_DATA
 RETURN RC
END
IF OOO="SAY" THEN
DO
 SAY  TYPE!!TRI_SYMBOL RU_CATEGORY CHAIN RESP_SYMBOL PI_SYMBOL ,
  BBI_SYM EBI_SYM CDI_SYM REQUEST_NAME SENSE_DATA
 RETURN RC
END
/*"VGET (ZTEMPF ZTEMPN)"
 ADDRESS MVS
 BYPASS_RC=1
 "EXECIO * DISKW "ZTEMPN" (STEM LINE. FINIS)"
 BYPASS_RC=1
 ADDRESS ISPEXEC
 BYPASS_RC=4
 "BROWSE DATASET('"ZTEMPF"')"
 RETURN RC  */
/* INTERNAL SUBROUTINES */
/*      */
S_ERROR:
 IF RC ¬= 0 THEN DO
  IF BYPASS_RC=RC THEN DO; RC=0;BYPASS_RC=0;RETURN;END
  IF BYPASS_RC1=RC THEN RETURN
 END
 ARG ARG_RC
 CONDITION_I=CONDITION('I')
 IF CONDITION_I = "CALL" THEN CALL OFF ERROR
                         ELSE SIGNAL OFF ERROR
  /* SAVE IN CASE HOST COMMANDS ARE USED IN S_ERROR */
 IF ARG_RC ¬="" THEN SAVE_RC=ARG_RC
  ELSE SAVE_RC=RC
 SAVE_SIGL=SIGL
 SAVE_ZERRLM=ZERRLM
 PARSE SOURCE SOURCE_STRING
 EXECNM=WORD(SOURCE_STRING,3)
 ENV=ADDRESS()
 CLAUSE_OF_ERROR=CONDITION('D')
 IF CLAUSE_OF_ERROR=" " THEN CLAUSE_OF_ERROR=SOURCELINE(SIGL)
 RC=SAVE_RC
 /*IF CONDIITON_I="CALL" THEN RETURN */
 IF CONDITION_I="CALL" THEN SIGNAL L_ERROR_EXIT
                       ELSE SIGNAL L_ERROR_EXIT
L_ERROR_EXIT:
SIGNAL OFF ERROR
SAY "*************** E R R O R ******************"
SAY "* EXEC        :" EXECNM
SAY "* ENVIRONMENT :" ENV
SAY "* LAST RC     :" SAVE_RC
SAY "* LAST SIGL   :" SAVE_SIGL
SAY "* LAST COMMAND:"
SAY CLAUSE_OF_ERROR
SAY "* LAST ZERRLM :"
SAY SAVE_ZERRLM
SAY "* LAST MESS1  :"
SAY MESS1
SAY "*************** E R R O R ******************"
ADDRESS TSO "DELSTACK"
IF SYSVAR(SYSENV)="BACK" & SYSVAR(SYSISPF)="ACTIVE" THEN
DO
 ZISPFRC=SAVE_RC
 ADDRESS ISPEXEC "VPUT (ZISPFRC) SHARED"
END
ELSE DO
 SAY "TYPE ANY CHARACTER TO CONTINUE"
 PULL
END
EXIT RC
GET_BIT:PROCEDURE
PARSE ARG HEXCHARS,BITNR  /* NO UPPERCASE TRANSLATION */
IF BITNR="" THEN BITNR=0
MASK=2**BITNR
MASK1=D2C(MASK,LENGTH(HEXCHARS))
BIT=BITAND(HEXCHARS,MASK1)
IF C2D(BIT)=MASK THEN BIT=1
                 ELSE BIT=0
RETURN(BIT)
GET_BITS:PROCEDURE
PARSE ARG HEXCHARS,BITNR,AANTAL /* NO UPPERC TRANSL */
IF BITNR="" THEN BITNR=0
IF AANTAL="" THEN AANTAL=1
SAVE_BITNR=BITNR
DO LOPER=AANTAL TO 1 BY -1
 BIT.LOPER=GET_BIT(HEXCHARS,SAVE_BITNR)
 SAVE_BITNR=SAVE_BITNR-1
END
BIT=0
DO LPER=AANTAL TO 1 BY -1
 BIT=BIT+(BIT.LOPER)*(2**(LOPER-1))
END
RETURN(BIT)


Herman Vierendeels
Systems Programmer
Kamer van Volksvertegenwoordigers (Belgium)       c Herman Vierendeels 1991

