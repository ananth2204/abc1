A debugging tool for NetView programs


INTRODUCTION

This article presents a NetView debugging tool which,
implemented as a command processor, provides the user with
two functions:

1      The ability to display 31 NetView control blocks (see the
      example in Figure 1).

2      The ability to modify one word of storage within the
      NetView address space.

These two functions are very helpful for system programmers
engaged in writing or debugging NetView's user-written
Assembler programs, such as exit routines, command
processors, and subtasks.


THE ENVIRONMENT

Adhering to the general coding guidelines published in
NetView's Customization: Using Assembler Version 1 Release
3 (SC31-6078) manual,  this 'regular' command processor,
written in Assembler language to run under an OST in
AMODE=31 and RMODE=ANY, was developed in an
MVS/XA, NetView 1.3 environment. To upgrade this
command processor to run in an MVS/XA, NetView 2.2
environment, simply re-assemble it with the corresponding
NetView MACLIB.


COMMAND SYNTAX

Based on the CMDMDL statements defined in the DSICMD
member of DSIPARM, the syntax to invoke the command
processor is shown below.

For the display function

MLST BLOCK=<controlblockname>
     (,LENGTH={<"X"length>|<length>|"*"})
     (,{TERMINAL=<resource>|OPERATOR=<taskid>})

MLST ADDRESS=<address>
     (,LENGTH={<"X"length>|<length>})

Examples

      MLST B=MVT,LE=16
      MLST B=MVT,LE=X16
      MLST BL=TVB,OPER=JOEDOE

      MLST A=8A56792,LEN=X256
      MLST A=8A56792

For the modify function

      MLST ADDRESS=<address>,
           VERIFY=<8-hex-char>,REPLACE=<8-hex-char>

Example

      MLST A=8A56792,V=F1F2F3F4,R=F5F6F7F8

These keywords are not positional and, as such, they can be
specified in any order. Also, because each keyword begins
with a unique letter, it can be abbreviated to that first letter.

To see the syntax on-line, enter:

      MLST B=HELP


EXPLANATION OF Keywords

BLOCK

There are two kinds of control blocks:

o      Global to NetView (ie one copy of control block for each NetView):

      -      ART
      -      DDT
      -      DQT
      -      MVT
      -      OIT
      -      SCT
      -      SNT
      -      SVL.

o      Global to the task (ie one copy of control block for PPT,
      OST, NNT or OPT):

      -      ACB
      -      EXSWB
      -      ICCWB
      -      ICPDB
      -      MRCWB
      -      MRPDB
      -      NCCWB
      -      NCPDB
      -      NPSWB
      -      TIB
      -      TVB.

In addition, there are some control blocks which are only
available to a particular task.

For OST only:

o      CDNIB
o      NAT
o      ORRPL
o      OSNIB
o      OSRPL
o      RARPL
o      RCRPL
o      RSRPL
o      SAT
o      SCRPL.

For PPT only:

o      PRCRPL
o      PSCRPL.

On displaying control block, there are two important messages
worth mentioning:

      POINTER TO THE REQUESTED CONTROL BLOCK = 0

means the control block doesn't exist yet.

      REQUESTED NETVIEW CONTROL BLOCK NOT AVAILABLE FOR THIS TASK

is self-explanatory.


ADDRESS

The address specified in hexadecimal where storage display or
modification is to start. Because MLST has no control over
which address will be specified, it has employed the MVS
ESPIE facility to trap an OC4 abend caused by referencing
fetch- or store-protected storage. In detecting such error, the
OC4 handler, after telling user through the message
'STORAGE PROTECTION EXCEPTION WHILE
PROCESSING REQUEST' will return control to NetView as if
nothing had happened.


LENGTH

For a BLOCK display, if LENGTH is not specified, the default
is 1024 bytes or its implicit size, whichever is the smaller. For
an ADDRESS display, if LENGTH is not specified, the default
is 4 bytes.

The LENGTH value can be specified in hexadecimal (prefixed
by 'X'), decimal, or its implicit size denoted by '*'. Because
some control blocks (eg MVT, SCT) can be very large,
specifying its '*' value may cause a long display.

To signal MLST to end the display prematurely, enter the
RESET command or press the ATTN key.

VERIFY

Use this keyword to specify an 8-byte hexadecimal value which
must match the 4-byte storage pointed at by ADDRESS.

REPLACE

Use this keyword to specify an 8-byte hexadecimal value which
will replace the 4-byte storage pointed at by ADDRESS.
Replacement will not be permitted if VERIFY fails.

TERMINAL

This specifies a NetView 'resource' which is currently in
session with PPT, OST, or NNT. Use this keyword to identify
the task which owns the control block to be displayed.

OPERATOR

This specifies a NetView 'taskid' which is currently in session
with PPT, OST, NNT, or OPT. Use this keyword to identify
the task which owns the control block to be displayed.

Both 'resource' and 'taskid' values can be displayed by using
the NetView command LIST STATUS=TASKS.


TIPS FOR DEVELOPING A COMMAND PROCESSOR

1      Define RES=Y in the CMDMDL statement,  use
      DISPMOD to locate its Entry Point Address (EPA).

2      Design re-entrant code. However, during the debugging
      mode, link-edit the program as NORENT to make full use
      of MLST. The reason for this is, because the NetView load
      library is APF-authorized, MVS will load the NORENT
      module into subpool 251, rather than the store-protected
      subpool 252. As a result, subpool 251 allows MLST to
      modify the storage (code or data) without causing an OC4.


MLST COMMAND DEFINITION

MLST     CMDMDL   MOD=MEMLIST,TYPE=R,RES=Y
         PARMSYN  ADDRESS,ADDRES
         PARMSYN  ADDRESS,ADDRE
         PARMSYN  ADDRESS,ADDR
         PARMSYN  ADDRESS,ADD
         PARMSYN  ADDRESS,AD
         PARMSYN  ADDRESS,A
         PARMSYN  BLOCK,BLOC
         PARMSYN  BLOCK,BLO
         PARMSYN  BLOCK,BL
         PARMSYN  BLOCK,B
         PARMSYN  LENGTH,LENGT
         PARMSYN  LENGTH,LENG
         PARMSYN  LENGTH,LEN
         PARMSYN  LENGTH,LE
         PARMSYN  LENGTH,L
*                                  <******************************
         PARMSYN  VERIFY,VERIF     < If for security reason, only
         PARMSYN  VERIFY,VERI      < DISPLAY is allowed;  simply
         PARMSYN  VERIFY,VER       < delete these two keywords.
         PARMSYN  VERIFY,VE        < Using DSIPAS, MLST can detect
         PARMSYN  VERIFY,V         < missing keywords from SCT.  As
         PARMSYN  REPLACE,REPLAC   < a result,  memory modification
         PARMSYN  REPLACE,REPLA    < function is disabled.
         PARMSYN  REPLACE,REPL     <      ----  or ----
         PARMSYN  REPLACE,REP      < By using KEYCLASS, it can restrict
         PARMSYN  REPLACE,RE       < these two keywords only to be
         PARMSYN  REPLACE,R        < entered by some users.
*                                  <******************************
         PARMSYN  TERMINAL,TERMINA
         PARMSYN  TERMINAL,TERMIN
         PARMSYN  TERMINAL,TERMI
         PARMSYN  TERMINAL,TERM
         PARMSYN  TERMINAL,TER
         PARMSYN  TERMINAL,TE
         PARMSYN  TERMINAL,T
         PARMSYN  OPERATOR,OPERATO
         PARMSYN  OPERATOR,OPERAT
         PARMSYN  OPERATOR,OPERA
         PARMSYN  OPERATOR,OPER
         PARMSYN  OPERATOR,OPE
         PARMSYN  OPERATOR,OP
         PARMSYN  OPERATOR,O
         CMDCLASS 1,2              < only operators with scope classes
                                   < 1 or 2 in their profiles can issue
                                   < MLST command


MEMLIST SOURCE CODE

MEMLIST  TITLE    '*** NETVIEW STORAGE COMMAND PROCESSOR ***'
* FUNCTION:-                                                          *
*   DISPLAY ON NETVIEW OST THE CONTENTS OF STORAGE ASSIGNED TO        *
*   NETVIEW CONTROL BLOCKS OR DATA AREAS WITHIN THE NETVIEW           *
*   ADDRESS SPACE.                                                    *
*   IT ALSO ALLOWS MODIFICATION OF MEMORY WITHIN THE NETVIEW          *
*   ADDRESS SPACE.                                                    *
* DESCRIPTION:-                                                       *
*   THIS PROGRAM RUNS AS A NETVIEW REGULAR COMMAND PROCESSOR.         *
*   IT ALSO USES MVS'S "ESPIE" FACILITY TO TRAP STORAGE               *
*   ACCESS PROGRAM CHECKS WHICH OCCUR WHILE ACCESSING THE STORAGE TO  *
*   BE DISPLAYED OR TO BE MODIFIED.                                   *
* ENVIRONMENT:-                                                       *
*   NETVIEW/XA VERSION 1 RELEASE 3 OR VERSION 2 RELEASE 2;            *
*   IT RUNS IN AMODE 31 AND RMODE ANY, DESIGNED AS REENTRANT          *
* LINKAGE:-                                                           *
*   NOT OS STANDARD, THE LINKAGE IS ACCORDING TO THE CONVENTIONS OF   *
*   A NETVIEW COMMAND PROCESSOR:                                      *
*     R0    - INDETERMINATE                                           *
*     R1    - ADDRESS OF A NETVIEW CWB TO DESCRIBE THE COMMAND WHICH  *
*             HAS CAUSED THE NETVIEW CP TO BE INVOKED                 *
*     R2:R12 - INDETERMINATE                                          *
*     R13   - ADDRESS OF A SAVEAREA AVAILABLE TO THIS COMMAND         *
*             PROCESSOR                                               *
*     R14   - RETURN ADDRESS                                          *
*     R15   - ADDRESS OF ENTRY POINT                                  *
MEMLIST  CSECT
MEMLIST  AMODE    31
MEMLIST  RMODE    ANY
         DSICBS                                                        *
               DSICWB,                                                 *
               DSIMVT,                                                 *
               DSIPDB,                                                 *
               DSISWB,                                                 *
               DSITIB,                                                 *
               DSITVB,                                                 *
               DEFER=ALL
MLSREG   EQU      R12               BASE REGISTER FOR PROCESSOR CODE
MVTREG   EQU      R11               BASE REGISTER FOR NETVIEW MVT
TVBREG   EQU      R10               BASE REGISTER FOR NETVIEW TVB
TIBREG   EQU      R10               BASE REGISTER FOR NETVIEW TIB
PDBREG   EQU      R9                BASE REGISTER FOR NETVIEW PDB
BUFREG   EQU      R8                BASE REGISTER FOR NETVIEW BUFFER
*   PERFORM ENTRY LINKAGE                                             *
         SAVE     (14,12),T,        SAVE CALLER'S REGISTERS            *
               'MEMLIST  &SYSDATE &SYSTIME '
         LA       MLSREG,0(,R15)    SET CODE BASE & CLEAR HIGH BIT(S)
         USING    MEMLIST,MLSREG    ESTABLISH ADDRESSABILITY
         USING    DSICWB,R1         CWB ADDRESSING
         LA       R1,CWBSAVEA       ADDRESSING CWB'S SAVEAREA
         DROP     R1
         ST       R1,8(,R13)        SAVEAREA'S HOUSEKEEPING
         ST       R13,4(,R1)
         LR       R13,R1
         USING    CWBSAVEA,R13      ADDRESSING CWB & SAVEAREA
         LA       R0,CWBADATD       PREPARE FOR MVCL (TO)
         LA       R1,L'CWBADATD     GET LENGTH FOR MVCL
         LR       R2,R0             PREPARE FOR MVCL (FROM)
         LA       R3,0              LENGTH IS NULL
         MVCL     R0,R2             CLEAR THE CWBADATD WORKAREA
         L        TIBREG,CWBTIB     GET POINTER TO TIB
         USING    DSITIB,TIBREG     ADDRESSING THE TIB
         L        TVBREG,TIBTVB     GET POINTER TO TVB
         DROP     TIBREG
         USING    DSITVB,TVBREG     ADDRESSING THE TVB
         ST       TVBREG,TVBSAVAD   SAVE TVB ADDRESS AS QUICK CELL
         L        MVTREG,TVBMVT     GET POINTER TO MVT
         USING    DSIMVT,MVTREG     ADDRESSING THE MVT
         L        TIBREG,CWBTIB     RESTORE POINTER TO TIB
         DROP     TVBREG
         USING    DSITIB,TIBREG     ADDRESSING THE TIB
         L        PDBREG,CWBPDB     GET POINTER TO PDB
         USING    DSIPDB,PDBREG     ADDRESSING PDS
*   INITIALIZE THE BUFFER HEADER AS REQ'ED BY NETVIEW                 *
         LA       BUFREG,BUFRSTOR   GET ADDRESS OF BUFFER
         USING    BUFHDR,BUFREG     ADDRESSING THE BUFFER HEADER
         ST       BUFREG,BUFRSVAD   STORE ADDRESS OF BUFFER
         LA       R15,MSGMXBFL
         STH      R15,HDRBLENG      STORE BUFFER HDR LENGTH
         MVI      HDRMTYPE,HDRTYPEU STORE BUFFER TYPE
         LA       R15,HDRTEXT-BUFHDR
         STH      R15,HDRTDISP      STORE BUFFER TEXT OFFSET
         MVC      HDRDOMID,MVTCURAN STORE NETVIEW DOMAIN ID
*   PERFORM KEYWORDS PARSING ..................................       *
*   CHECK # OF PDB ENTRIES.  IT MUST BE AN ODD NUMBER AND .GE. 3      *
*         REG 2  - POINTS TO A PDB ENTRY                              *
*         REG 3  - LENGTH OF KEYWORD IN THE BUFFER                    *
*         REG 4  - POINTS TO A KEYWORD/KEYWORD VALUE IN BUFFER        *
*         REG 5  - SEARCH LOOP CONTROL VALUE                          *
*         REG 6  - POINTS TO A GROUP OF FORMAT KEYWORDS               *
*         REG 7  - POINTS TO THE OUTPUT AREA FOR STORING KW/KW-VALUE  *
         CLI      PDBNOENT+1,X'03'  NUMBER OF PDB ENTRIES < 3 ?
         BNL      MLSL#001          NO - ENOUGH FOR A VALID COMMAND
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE
         DC       Y(BADSYNTX)       INVALID SYNTAX
         B        MLSRETRN          TERMINATING
MLSL#001 DS       0H
         TM       PDBNOENT+1,X'01'  # OF ENTRIES IS ODD NUMBER ?
         BO       MLSL#002          YES - ORPHAN KEYWORDS IMPOSSIBLE
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE
         DC       Y(BADSYNTX)       INVALID SYNTAX
         B        MLSRETRN          TERMINATING
MLSL#002 DS       0H
         MVI      FMT2SW,X'00'      INIT FMT2 SWITCH =  0
         MVI      VERIFYSW,X'00'    INIT VERIFY SWITCH =  0
         MVI      OUTAREA,C' '      INIT 32-BYTE OUTAREA = C' '
         MVC      OUTAREA+1(31),OUTAREA
         XR       R3,R3             R3 = 0
         LA       R6,KEYWDFM1       ADDRESS OF FMT 1 KEYWORDS
SRCKEYWD DS       0H                ..........................LOOP1 BEG IN--1
         LA       R7,OUTAREA        ADDRESS OF OUTPUT AREA                  1
SRCNXTKW DS       0H                ..........................LOOP2 BEG IN-21
         CLI      0(R6),C' '        LAST KEYWORD SEARCHED?                 21
         BE       SRCDONE           YES - SEARCH DONE                      21
         LH       R5,PDBNOENT       GET NUMBER OF ENTRIES IN PDB           21
         SRL      R5,1              DIVIDE BY 2 FOR LOOP CONTROL           21
         LA       R2,PDBTABLE       ADDRESS OF FIRST PDB ENTRY             21
         USING    PDBENTRY,R2       ADDRESSABILITY FOR PDBENTRY            21
*   THE FOLLOWING FORMS A LOOP TO SEARCH THE PDB FOR THE KEYWORDS.    *    21
*   IF UNRECOGNIZED KEYWORD IS FOUND, TERMINATE THE PROCESS WITH      *    21
*   ERROR MESSAGE; OTHERWISE CONTINUE THE SEARCH UNTIL END OF PDB.    *    21
PDBLOOP  DS       0H                CONTROLLED BY R5 .......LOOP3 BEGIN --321
         LA       R2,PDBENTND       ADDRESS OF NEXT PDB ENTRY.            321
         L        R4,CWBBUF         ADDRESS OF THE PASSED BUFFER          321
         AH       R4,PDBDISP        ADD DISPLACEMENT IN BUFFER            321
         IC       R3,PDBLENG        GET KW LENGTH                         321
         LTR      R3,R3             KW LENGTH = 0 ?                       321
         BNZ      MLSL#003          NO - PROCESS KW TEXT                  321
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE              321
         DC       Y(BADKEYWD)       INVALID KW LENGTH                     321
         B        MLSRETRN          TERMINATING                           321
MLSL#003 DS       0H                                                      321
         LA       R1,PDBTABLE       R1=START OF PDB ENTRIES               321
         SR       R1,R2             COMPUTE OFFSET OF CURRENT ENTRY       321
         LCR      R1,R1             -VE RESULT, MAKE IT +VE               321
         SR       R0,R0             CLEAR EVEN REG FOR DIVISION           321
         D        R0,PDBENTLN       COMPUTE POSITION OF PDB TABLE ENTRY   321
         LA       R1,1(,R1)         MAKE RESULT RELATIVE TO 1             321
         ST       R1,PDBPOSEN       STORE +VE NUMBER FOR DSIPAS CALL      321
         DSIPAS   PDB=(CWBPDB,      CALL PARAMETER/ALIAS SERVICES      *  321
               PDBPOSEN),           ENTRY # OF PARAMETER               *  321
               OUT=KEYWDTXT,        RETURN VALUE IF FOUND ON SCT       *  321
               SWB=CWBSWB                                                 321
         B        *+4(R15)          RETURN CODE FROM DSIPAS CALL          321
         B        GOODKYWD          = 0 - REGULAR PARM VALUE RETURNED     321
         B        *+4               = 4 - SAME PARM RETURNED              321
         BAS      R14,MLSERRTN      = 8 - INVALID PARAMETER               321
         DC       Y(UNDKEYWD)       UNDEFINED KEYWORD ON SCT              321
         B        MLSRETRN          TERMINATING                           321
         SPACE                                                            321
GOODKYWD DS       0H                                                      321
         LA       R2,PDBENTND       POINT TO NEXT PDB ENTRY               321
         CLC      0(2,R6),KEYWDTXT  COMPARE WITH WANTED KEYWORD ?         321
         BE       GETKWVAL          SAME - GET KW VALUE                   321
         BCT      R5,PDBLOOP        LOOP TILL PDB END REACHED ......END --321
         B        NEXTKYWD          SEARCH FOR NEXT KEYWORD.               21
*   MOVE KEYWORD VALUE TO OUTPUT AREA. ENSURE 0 < KW LENGTH < 9       *    21
*         REG 3  - LENGTH OF KEYWORD VALUE IN BUFFER                  *    21
*         REG 4  - POINTS TO THE KEYWORD VALUE IN THE BUFFER          *    21
*         REG 6  - POINTS TO APPROPRIATE SET OF FORMAT KEYWORDS       *    21
*         REG 7  - POINTS TO OUTPUT AREA                              *    21
GETKWVAL DS       0H                                                       21
         CLC      0(2,R6),=CL2'VE'  IS KEYWORD VERIFY ?                    21
         BNE      MLSL#004          NO...                                  21
         MVI      VERIFYSW,X'01'    YES, TURN ON THE VERIFY SWITCH         21
MLSL#004 DS       0H                                                       21
         L        R4,CWBBUF         ADDRESS OF THE BUFFER PASSED           21
         AH       R4,PDBDISP        ADD DISPLACEMENT                       21
         IC       R3,PDBLENG        LENGTH OF KW VALUE IN BUFFER           21
         LTR      R3,R3             LENGTH = 0 ?                           21
         BNZ      MLSL#005          NO - PROCESS ITS TEXT                  21
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE               21
         DC       Y(BADKEYWD)       INVALID LENGTH                         21
         B        MLSRETRN          TERMINATING                            21
MLSL#005 DS       0H                                                       21
         CH       R3,=H'8'          LENGTH OF OPERAND > 8 ?                21
         BNH      MLSL#006          NO - PROCESS OPERAND TEXT              21
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE               21
         DC       Y(BADKEYWD)       INVALID LENGTH                         21
         B        MLSRETRN          TERMINATING                            21
MLSL#006 DS       0H                                                       21
         BCTR     R3,0              -1 FOR EX                              21
         EX       R3,MVCFMBUF       MOVE TO OUTPUT AREA FROM BUFFER        21
         DSIKVS   SWB=CWBSWB,       CALL KEYWORD/VALUE SERVICES        *   21
               SCTADDR=PDBCMDA,     TO DETERMINE IF AN OPERATOR IS     *   21
               KEYWORD=KEYWDTXT     AUTHORIZED TO USE A GIVEN KEYWORD      21
         LTR      R15,R15           WITHIN OPERATOR'S SCOPE OF COMMAND?    21
         BZ       NEXTKYWD          YES - PROCESS NEXT KEYWORD             21
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE               21
         DC       Y(BADSCOPE)       BAD OPERATOR SCOPE                     21
         B        MLSRETRN          TERMINATING                            21
MVCFMBUF MVC      0(1,R7),0(R4)     MOVE VALUE OUT OF BUFFER               21
NEXTKYWD DS       0H                                                       21
         LA       R6,2(R6)          POINT TO NEXT KEYWORD                  21
         LA       R7,8(R7)          AREA FOR NEXT KEYWORD VALUE            21
         B        SRCNXTKW          GO FIND THIS NEW KEYWORD.       END ---21
SRCDONE  DS       0H                                                        1
         CLI      FMT2SW,X'01'      IS FORMAT 2 SWITCH ON?                  1
         BE       MLSFMT2           YES... IT IS FORMAT 2                   1
         CLI      OUTAREA,C' '      FORMAT 1 CTL BLK NAME SPECIFIED ?       1
         BNE      MLSFMT1           YES... IT IS FORMAT 1                   1
         MVI      FMT2SW,X'01'      SET FORMAT 2 SWITCH ON                  1
         LA       R6,KEYWDFM2       ADDRESS OF FORMAT 2 KEYWORDS            1
         B        SRCKEYWD          START TO SEARCH FMT2 KEYWORDS   END ----1
*   FORMAT 1 KEYWORD PROCESSING BEGINS ............................   *
*   CHECK VALUES FOR FORMAT 1 KEYWORDS.  IF NO VALUE ENTERED,         *
*   DEFAULT VALUE IS USED.                                            *
*   FOR LENGTH    - DEFAULT VALUE IS CTL BLK LENGTH OR 1K BYTES,      *
*                   WHICHEVER IS SMALLER                              *
*   IF LENGTH=*   - ACTUAL CTL BLK LENGTH IS USED, REGARDLESS OF THE  *
*                   1K BYTES LIMIT                                    *
*   FOR TERM-ID   - LU FROM WHICH COMMAND IS ENTERED                  *
*                   IF ENTERED, TVB CHAIN IS SEARCHED TO LOCATE TVB   *
*                   FOR THAT TERM-ID                                  *
*        REG 2  - POINTS TO FIRST TVB IN TVB CHAIN                    *
*        REG 4  - POINTS TO OUTPUT AREA FOR DSILCS                    *
*        REG 15 - RETURN CODE FROM DSILCS                             *
MLSFMT1  DS       0H                CHECK LU
         L        R2,MVTTVB         ADDRESS OF FIRST TVB OFF MVT
         LA       R4,TVBSAVAD       ADDRESS FOR OUTPUT FROM DSILCS
         CLI      OUTAREA+16,C' '   VALUE FOR LUNAME SPECIFIED ?
         BE       CHEKOPER          NO; CHECK OPER
         LA       R3,OUTAREA+16     ADDRESS OF LUNAME AREA.
         DSILCS   TVB=(R2),         LOCATE TVB BY LUNAME               *
               LU=(R3),CBADDR=(R4)
         LTR      R15,R15           LOCATE OK ?
         BZ       MLSL#007          YES - CONTINUE
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE
         DC       Y(BADLUID)        NO TVB LOCATED
         B        MLSRETRN          TERMINATING
*   FOR OPER-ID   - DEFAULT IS OPERATOR WHO ENTERS THE COMMAND        *
*   IF OPER-ID IS ENTERED, SEARCH TVB CHAIN FOR THAT OPER-ID.         *
*        REG 4  - ADDRESS OF OUTPUT AREA FOR DSILCS                   *
*        REG 8  - FIRST TVB IN TVB CHAIN                              *
*        REG 15 - RET CODE FROM DSILCS                                *
CHEKOPER DS     0H
         CLI      OUTAREA+24,C' '   VALUE FOR OP-ID SPECIFIED ?
         BE       MLSL#007          NO - FMT 1 IS OK AS IT IS
         LA       R3,OUTAREA+24     ADDR OF 8-BYTE OP-ID AREA
         DSILCS   TVB=(R2),         LOCATE TVB BY OPER-ID              *
               OPID=(R3),CBADDR=(R4)
         LTR      R15,R15           LOCATE OK ?
         BZ       MLSL#007          YES - START LOOKUP
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE
         DC       Y(BADOPID)        NO TVB LOCATED
         B        MLSRETRN          TERMINATING
MLSL#007 DS       0H
         L        TVBREG,TVBSAVAD   GET ADDRESS OF TVB
         DROP     TIBREG
         USING    DSITVB,TVBREG     ADDRESSING THE TVB
         L        TIBREG,TVBTIB     ADDRESSING TIB FROM TVB
         DROP     TVBREG
         USING    DSITIB,TIBREG     ADDRESSING THE TIB
         LTR      TIBREG,TIBREG     TIB EXISTS FOR OPER-ID/TERM-ID?
         BNZ      MLSL#008          YES
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE
         DC       Y(BADTIB)         NO ACTIVE TIB FOR OPERATOR/TERMINAL
         B        MLSRETRN          TERMINATING
MLSL#008 DS       0H
*   SEARCH CONTROL BLOCK NAME AGAINST THE PREDEFINED CB_LIST;         *
*   IF FOUND, STORE ITS LENGTH, IT CAN BE 4-BYTE, 2-BYTE, OR 1-BYTE.  *
         L        R3,OUTAREA        YES - GET CTL BLOCK NAME
         LA       R2,LOD2BYTE       BR TO LOAD 2-BYTE LENGTH
         LA       R6,CB_LIST        ADDRESS OF CB-NAME TABLE.
CHEKCBNM DS       0H
         LM       R4,R5,0(R6)       GET NAME AND BRANCH ADDRESS
         LTR      R4,R4             END OF TABLE WITH NO MATCH ?
         BNZ      MLSL#009          NO - START PROCESSING BLOCK
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE ABOUT
         DC       Y(BADCTLBK)       INVALID CONTROL BLOCK SPECIFIED
         B        MLSRETRN          TERMINATING
MLSL#009 DS       0H
         CR       R3,R4             NO, ARE TWO NAMES THE SAME ?
         BER      R5                YES - GET ADDRESS AND LENGTH OF CB
         LA       R6,8(R6)          NO - CHECK NEXT ENTRY IN TABLE
         B        CHEKCBNM          LOOP BACK TO CHECK AGAIN
*   DEPENDING ON THE CTL BLK NAME ENTERED, THE CTL BLK                *
*   ADDRESS IS FOUND EITHER FROM THE MVT OR THE TIB.                  *
*   MOST CONTROL BLOCKS HAVE LENGTH = 2 BYTES;  TO SAVE 2 BYTES FOR   *
*   EACH BRANCH, "BR R2" IS USED INSTEAD OF "B LOD2BYTE".             *
*        REG 4  - POINTS TO THE DESIRED CTL BLK                       *
*        REG 9  - POINTS TO MVT                                       *
*        REG 11 - POINTS TO TIB                                       *
CB_ART   DS       0H
         L        R4,MVTART         ART (4-BYTE LENGTH)
         B        LOD4BYTE          GET LENGTH
CB_DQT   DS       0H
         L        R4,MVTDQT         DQT (4-BYTE LENGTH)
         B        LOD4BYTE          GET LENGTH
CB_SCT   DS       0H
         L        R4,MVTSCT         SCT (4-BYTE LENGTH)
         B        LOD4BYTE          GET LENGTH
CB_MVT   DS       0H
         LR       R4,MVTREG         IT'S MVT, LOAD ITS ADDRESS,
         BR       R2                GET LENGTH, R2 --> LOD2BYTE
CB_SNT   DS       0H
         L        R4,MVTSNT         SNT
         BR       R2                GET LENGTH
CB_OIT   DS       0H
         L        R4,MVTOIT         OIT
         BR       R2                GET LENGTH
CB_DDT   DS       0H
         L        R4,MVTDDT         DDT
         BR       R2                GET LENGTH
CB_SVL   DS       0H
         L        R4,MVTSVL         SVL
         BR       R2                GET LENGTH
CB_TIB   DS       0H
         LR       R4,TIBREG         TIB
         BR       R2                GET LENGTH
CB_TVB   DS       0H
         L        R4,TIBTVB         TVB
         BR       R2                GET LENGTH
CB_ACB   DS       0H
         L        R4,TIBACB         ACB
         BR       R2                GET LENGTH
CB_NCCWB DS       0H
         L        R4,TIBNCCWB       NCCWB
         BR       R2                GET LENGTH
CB_ICCWB DS       0H
         L        R4,TIBICCWB       ICCWB
         BR       R2                GET LENGTH
CB_MRCWB DS       0H
         L        R4,TIBMRCWB       MRCWB
         BR       R2                GET LENGTH
CB_EXSWB DS       0H
         L        R4,TIBEXSWB       EXSWB
         BR       R2                GET LENGTH
CB_NPSWB DS       0H
         L        R4,TIBNPSWB       NPSWB
         BR       R2                GET LENGTH
CB_NCPDB DS       0H
         L        R4,TIBNCPDB       NCPDB
         BR       R2                GET LENGTH
CB_MRPDB DS       0H
         L        R4,TIBMRPDB       MRPDB
         BR       R2                GET LENGTH
CB_ICPDB DS       0H
         L        R4,TIBICPDB       ICPDB
         BR       R2                GET LENGTH
CB_ORRPL DS       0H
         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'
         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION
         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION
         L        R4,TIOORRPL       YES - IT IS OPER REC VTAM RPL
         DROP     R4
         B        LOD1BYTE          GET 1-BYTE LENGTH
CB_OSRPL DS       0H
         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'
         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION
         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION
         L        R4,TIOOSRPL       YES - IT IS OPER SEND VTAM RPL
         DROP     R4
         B        LOD1BYTE          GET LENGTH
CB_RCRPL DS       0H
         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'
         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION
         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION
         L        R4,TIORCRPL       YES - IT IS POI REC-CMD VTAM RPL
         DROP     R4
         B        LOD1BYTE          GET LENGTH
CB_SCRPL DS       0H
         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'
         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION
         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION
         L        R4,TIOSCRPL       YES - IT IS POI SEND-RCM VTAM RPL
         DROP     R4
         B        LOD1BYTE          GET LENGTH
CB_RARPL DS       0H
         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'
         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION
         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION
         L        R4,TIORARPL       YES - IT IS NNT REC ANY VTAM RPL
         DROP     R4
         B        LOD1BYTE          GET LENGTH
CB_RSRPL DS       0H
         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'
         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION
         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION
         L        R4,TIORSRPL       YES - IT IS NNT REQ SESS VTAM RPL
         DROP     R4
         B        LOD1BYTE          GET LENGTH
CB_PRRPL DS       0H
         BAS      R14,PPTTYX00      CHECK TYPE OF TIB -X'00'
         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION
         USING    TIBPPT,R4         ADDRESSING THE PPT EXTENSION
         L        R4,TIPRCRPL       YES - IT IS POI REC-CMD VTAM RPL
         DROP     R4
         B        LOD1BYTE          GET LENGTH
CB_PSRPL DS       0H
         BAS      R14,PPTTYX00      CHECK TYPE OF TIB -X'00'
         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION
         USING    TIBPPT,R4         ADDRESSING THE PPT EXTENSION
         L        R4,TIPSCRPL       YES - IT IS POI SEND-CMD VTAM RPL
         DROP     R4                POI SEND-CMD VTAM RPL
         B        LOD1BYTE          GET LENGTH
CB_OSNIB DS       0H
         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'
         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION
         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION
         L        R4,TIOOSNIB       YES - IT IS OPER STATION NIB
         DROP     R4
         B        LOD1BYTE          GET LENGTH
CB_CDNIB DS       0H
         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'
         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION
         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION
         L        R4,TIOCDNIB       YES - IT IS CROSS-DOM SESS NIB
         DROP     R4
         B        LOD1BYTE          GET LENGTH
CB_SAT   DS       0H
         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'
         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION
         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION
         L        R4,TIOSAUTH       YES - IT IS SAT
         DROP     R4
         BR       R2                GET LENGTH
CB_NAT   DS       0H
         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'
         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION
         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION
         L        R4,TIONAUTH       YES - IT IS NAT
         DROP     R4
         BR       R2                GET LENGTH
*   SAVE THE ADDRESS AND THE LENGTH OF THE WANTED CONTROL BLOCK       *
*        REG 4  - ADDRESS OF THE CONTROL BLOCK                        *
*        REG 5  - LENGTH OF THE CONTROL BLOCK                         *
LOD4BYTE DS       0H
         L        R5,4(R4)          GET LENGTH (4-BYTE)
         B        STORELEN          GO SAVE LENGTH
LOD2BYTE DS       0H
         LH       R5,2(R4)          GET LENGTH (2-BYTE)
         B        STORELEN          GO SAVE LENGTH
LOD1BYTE DS       0H
         XR       R5,R5             ZERO REGISTER
         IC       R5,3(R4)          GET LENGTH (1-BYTE)
STORELEN DS       0H
         CH       R4,=H'0'          CTL BLK ADDRESS = 0 ?
         BH       MLSL#010          NO
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE
         DC       Y(BADCBADR)       BAD CTL BLK ADDRESS
         B        MLSRETRN          TERMINATING
MLSL#010 DS       0H
         ST       R4,ADRFIELD       STORE ADDRESS OF DATA TO DISPLAY
         CLI      OUTAREA+8,C'*'    CTL BLK ACTUAL LENGTH SPECIFIED ?
         BE       MLSL#011          YES, STORE IT
         CLI      OUTAREA+8,C' '    CTL BLK REQ'D LENGTH SPECIFIED ?
         BNE      XLATLEN           NO, GO FIND ITS LENGTH
         CH       R5,=H'1024'       IS LENGTH > 1K?
         BL       MLSL#011          NO
         LH       R5,=H'1024'       YES; DISPLAY 1K AT MOST
MLSL#011 DS       0H
         STH      R5,LENFIELD       STORE LENGTH OF CTL BLK
         B        DISPLAY           GO DISPLAY CONTROL BLOCK.
MLSHELP  DS       0H                IT IS HELP. DISPLAY DIRECTIONS.
*   PRESENT THE HELP PANEL TO USERS                                   *
         LA       R2,1              GET START OF HELP MESSAGE NUMBER
         DSIMBS   MID=(R2),         MESSAGE BUFFER SERVICES            *
               BFR=BUFRSVAD,        BUILD THE FIRST LINE OF HELP TEXT  *
               MSGTBL=MSGTABAD,                                        *
               SWB=CWBSWB
         LTR      R15,R15           WAS BUFFER FILLED SUCCESSFULLY?
         BNZ      MLSABEND          NO - ISSUE A DEBUGGING ABEND
         BAS      R14,EDIT_TID      EDIT MESSAGE ID OUT OF THE BUFFER
         DSIPSS   TYPE=OUTPUT,      PRESENTATION SERVICES              *
               SWB=CWBSWB,          SEND THE FIRST LINE OF HELP TEXT   *
               OPTIONS=MSG,         AS A SINGLE MESSAGE                *
               BFR=BUFRSVAD
         LTR      R15,R15           WAS TEXT DISPLAYED SUCCESSFULLY?
         BNZ      MLSABEND          NO - ISSUE A DEBUGGING ABEND
MLSNXHLP DS       0H
         LA       R0,HDRTEXT-BUFHDR GET LENGTH OF BUFFER HEADER
         STH      R0,HDRTDISP       AND STORE IT AS TEXT OFFSET
         LA       R2,1(,R2)         INCREMENT TO THE NEXT HELP LINE
         DSIMBS   MID=(R2),         MESSAGE BUFFER SERVICES            *
               SWB=CWBSWB,          BUILD THE NEXT LINE OF HELP TEXT   *
               BFR=BUFRSVAD,                                           *
               MSGTBL=MSGTABAD
         LTR      R15,R15           WAS BUFFER FILLED SUCCESSFULLY?
         BNZ      MLSLLHLP          NO - CHECK FOR END OF HELP TEXT
         BAS      R14,EDIT_TID      EDIT MESSAGE ID OUT OF THE BUFFER
         DSIPSS   TYPE=OUTPUT,      PRESENTATION SERVICES              *
               SWB=CWBSWB,          SEND THE LINE OF HELP TEXT     *
               OPTIONS=SEG,         AS A MESSAGE SEGMENT               *
               BFR=BUFRSVAD
         LTR      R15,R15           WAS TEXT DISPLAYED SUCCESSFULLY?
         BNZ      MLSABEND          NO - ISSUE A DEBUGGING ABEND
         B        MLSNXHLP          .... GO SEND THE NEXT LINE OF HELP
MLSLLHLP DS       0H
         CH       R15,HELPRC12      WAS LAST HELP LINE ALREADY SENT?
         BNE      MLSABEND          NO - ISSUE DEBUGGING ABEND
         B        MLSRETRN          .... TERMINATE NORMALLY
*   FORMAT 2 KEYWORDS PROCESSING BEGINS ..........................    *
*   USING TRANSLATE TABLES, BOTH ADDRESS AND LENGTH ARE TRANSLATED.   *
MLSFMT2  DS       0H
         CLI      OUTAREA,C' '      ADDRESS SPECIFIED ?
         BNE      MLSL#012          YES
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE
         DC       Y(BADSYNTX)       INVALID COMMAND SYNTAX
         B        MLSRETRN          TERMINATING
MLSL#012 DS       0H
         CLI      OUTAREA+8,C' '    LENGTH SPECIFIED ?
         BNE      MLSL#013          YES
         MVI      OUTAREA+8,C'4'    NO - LENGTH 4 IS THE DEFAULT
MLSL#013 DS       0H
         TR       OUTAREA(8),XLAT_TB1 XLATE ADDRESS FOR SYNTAX CHECK
         XC       PACKAREA,PACKAREA CLEAR OUT THE PACK AREA
         XR       R6,R6             R6 TO COUNT NUMBER OF DIGITS
         LA       R7,OUTAREA        ADDRESS OF THE OUTPUT AREA
         BAS      R14,CKSYNTAX      GO CHECK THE SYNTAX
         ST       R6,ADRFIELD       SAVE START OF ADDRESS
         CLI      VERIFYSW,X'00'    VERIFY SWITCH ON ?
         BE       XLATLEN           NO; GO GET ITS LENGTH VALUE
         CLI      OUTAREA+23,C' '   VERIFY FIELD < 8 CHARS ?
         BE       MLSL#014          YES, ERROR
         CLI      OUTAREA+31,C' '   REPLACE FIELD < 8 CHARS ?
         BNE      XLATVRFY          NO; GET ITS VERIFY/REPLACE VALUES
MLSL#014 DS       0H
         BAS      R14,MLSERRTN      ISSUE ERROR MESSAGE
         DC       Y(BADVRFLD)       VERIFY/REPLACE FIELD < 8 CHARS
         B        MLSRETRN          TERMINATING
*   TRANSLATE BOTH VERIFY AND REPLACE FIELDS                          *
XLATVRFY DS       0H
         TR       OUTAREA+16(8),XLAT_TB1  VERIFY FIELD
         XC       PACKAREA,PACKAREA CLEAR OUT THE PACK AREA
         XR       R6,R6             R6  TO COUNT NUMBER OF DIGITS
         LA       R7,OUTAREA+16     ADDRESS OF THE OUTPUT AREA
         BAS      R14,CKSYNTAX      GO CHECK THE SYNTAX
         ST       R6,VERFIELD       SAVE VERIFY XLAT'ED RESULT
         TR       OUTAREA+24(8),XLAT_TB1  REPLACE FIELD
         XC       PACKAREA,PACKAREA CLEAR OUT THE PACK AREA
         XR       R6,R6             R6  TO COUNT NUMBER OF DIGITS
         LA       R7,OUTAREA+24     ADDRESS OF THE OUTPUT AREA
         BAS      R14,CKSYNTAX      GO CHECK THE SYNTAX
         ST       R6,REPFIELD       SAVE REPLACE XLAT'ED RESULT
         B        REPLACE           GO FOR REPLACE FUNCTION
XLATLEN  DS       0H                TRANSLATE LENGTH VALUE
         CLI      OUTAREA+8,C'X'    IS LENGTH SPECIFIED IN HEX ?
         BE       XLATHEX           YES - TRANSLATE IT
         TR       OUTAREA+8(6),XLAT_TB2  NO - IT IS DEC, TRANSLATE IT
         MVC      PACKAREA,OUTAREA+8
         MVI      OUTAREA+8,C'D'    PREFIX WITH 'D' TO INDICATE DEC
         MVC      OUTAREA+9(6),PACKAREA
         B        XLATDONE          GO TO CHECK SYNTAX
XLATHEX  DS       0H
         TR       OUTAREA+9(6),XLAT_TB1 TRANSLATE HEX LENGTH
XLATDONE DS       0H
         XC       PACKAREA,PACKAREA CLEAR OUT THE PACK AREA
         XR       R6,R6             R6  TO COUNT NUMBER OF DIGITS
         LA       R7,OUTAREA+9      ADDRESS OF OUTPUT AREA
         BAS      R14,CKSYNTAX      GO CHECK SYNTAX
         STH      R6,LENFIELD       SAVE LENGTH
         CLI      OUTAREA+8,C'X'    LENGTH IS SPECIFIED IN HEX ?
         BE       DISPLAY           YES - GO TO DISPLAY FUNCTION
         CVB      R6,PACKAREA       NO - CONVERT IT TO HEX
         STH      R6,LENFIELD       SAVE IT
         DROP     R2
*  DISPLAY OR REPLACE FUNCTION BEGINS ..............................  *
*  FOR DISPLAY, LINES ARE BUILT IN THE GENERAL PURPOSE NETVIEW        *
*  BUFFER FORMATTED IN THE CWB WORKAREA.                              *
*  FOR REPLACE, VERIFICATION IS DONE BEFORE REPLACING.                *
*  ADRFIELD - ADDRESS OF STORAGE TO BE DISPLAYED OR REPLACED          *
*  LENFIELD - LENGTH OF STORAGE      (DISPLAY FUNCTION)               *
*  VERFIELD - CONTENT TO BE VERIFIED (REPLACE FUNCTION)               *
*  REPFIELD - REPLACING CONTENT      (REPLACE FUNCTION)               *
*  TO TRAP OC4 CAUSED BY DISPLAY OR REPLACE FUNCTION,  AN MVS ESPIE   *
*  MACRO ISSUED.                                                      *
DISPLAY  DS       0H
REPLACE  DS       0H
         ESPIE    SET,OC4RUTIN,4,   SET UP ENVIRONMENT TO TRAP OC4     *
               MF=(E,SPIELISF)
         ST       R1,SPIEPTOK       SAVE PREVIOUS (OLD) ESPIE TOKEN
         CLI      VERIFYSW,X'01'    REPLACE FUNCTION ?
         BNE      DISPLAY1          NO, CONTINUE TO DISPLAY
         L        R3,ADRFIELD       GET ADDRESS FOR VERIFYING CONTENTS
         CLC      VERFIELD,0(R3)    VERIFY CONTENTS AGAINST VERFIELD
         BE       REPLACE1          EQUAL, GO FOR REPLACE
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE
         DC       Y(BADVERFY)       VERIFY FAIL
         B        MLSRETRN          TERMINATING
REPLACE1 DS       0H
         MVC      0(4,R3),REPFIELD  REPLACING
         BAS      R14,MLSERRTN      TELL REPLACE DONE
         DC       Y(REPLCEOK)
         B        MLSRETRN          REPLACE FUNCTION COMPLETE;RETURN
DISPLAY1 DS       0H
         MVI      HDRMTYPE,HDRTYPEU INDICATE USER GENERATED MESSAGE
         DSIMBS   MID=*HDRLINE,     MESSAGE BUFFER SERVICES            *
               BFR=BUFRSVAD,        BUILD THE DISPLAY TITLE MESSAGE    *
               MSGTBL=MSGTABAD,     LINE IN THE BUFFER                 *
               SWB=CWBSWB
         LTR      R15,R15           MESSAGE MOVED OK ?
         BNZ      MLSABEND          NO - ISSUE A DEBUGGING ABEND
         BAS      R14,EDIT_TID      EDIT MESSAGE ID OUT OF THE BUFFER
         DSIPSS   TYPE=OUTPUT,      PRESENTATION SERVICES              *
               OPTIONS=MSG,         SEND THE DISPLAY TITLE LINE        *
               BFR=BUFRSVAD,        TO THE OPERATOR'S SCREEN           *
               SWB=CWBSWB
         LTR      R15,R15           WAS TITLE WRITTEN SUCCESSFULLY?
         BNZ      MLSABEND          NO - ISSUE DEBUGGING ABEND
         LA       R0,MSGTXTLN       GET LENGTH OF DISPLAY LINE TEXT
         STH      R0,HDRMLENG       AND STORE IT IN THE HEADER
         LA       R0,HDRTEXT-BUFHDR GET LENGTH OF BUFFER HEADER
         STH      R0,HDRTDISP       STORE IT AS TEXT OFFSET
         XC       ADROFSET,ADROFSET CLEAR DISPLAY STORAGE OFFSET FIELD
NXTSEGMT DS       0H
* DISPLAY A STORAGE SEGMENT BY REUSING THE PREVIOUSLY FORMATTED       *
* BUFFER.                                                             *
         LA       R0,MSGTEXT        GET ADDRESS OF MESSAGE TEXT AREA
         LA       R1,MSGMXTXL       GET LENGTH OF MESSAGE TEXT AREA
         LR       R2,R0             DUPLICATE ADDRESS TO CLEAR TEXT
         LA       R3,BLANK          GET ' ' CHARACTER TO CLEAR AREA
         SLL      R3,SHIFT24        SHIFT LEFT 24 BITS
         MVCL     R0,R2             CLEAR OUT THE TEXT AREA
         LA       R3,ADRFIELD       POINT AT BINARY ADDRESS FIELD
         LA       R2,MSGRECAD       POINT AT RECEIVING FIELD
         LA       R1,L'ADRFIELD     GET LENGTH OF ADDRESS FIELD
         BAS      R14,CVTBINHX      CONVERT THE HEX DATA TO EBCDIC
         LA       R3,ADROFSET       POINT AT BINARY OFFSET FIELD
         LA       R2,MSGRELAD       POINT AT RECEIVING FIELD
         LA       R1,L'ADROFSET     GET LENGTH OF OFFSET FIELD
         BAS      R14,CVTBINHX      CONVERT THE HEX DATA TO EBCDIC
         L        R1,ADRFIELD       GET ADDRESS OF NEXT BYTE TO DISPLAY
         SR       R0,R0             CLEAR EVEN REGISTER FOR DIVIDE
         D        R0,MAXSEQLN       EXTRACT SEGMENT MULTIPLE AND OFFSET
         STH      R0,DSEGOFFT       SAVE SEGMENT OFFSET FOR LATER USE
         LCR      R0,R0             MAKE SEGMENT OFFSET -VE
         A        R0,MAXSEQLN       COMPUTE SEGMENT LENGTH TO DISPLAY
         CH       R0,LENFIELD       SEGMENT LENGTH ¬> STORAGE LENGTH?
         BNH      MLSL#015          YES - USE SEGMENT LENGTH TO DISPLAY
         LH       R0,LENFIELD       .... USE STORAGE LENGTH TO DISPLAY
MLSL#015 DS       0H
         STH      R0,DSEGLEN        STORE AMOUNT OF SEGMENT TO DISPLAY
         L        R3,ADRFIELD       GET ADDRESS OF STORAGE TO DISPLAY
         MVC      DBYTECTR,DSEGLEN  SAVE DISPLAY BYTE DOWN COUNTER
         MVC      DBYTEOFF,DSEGOFFT SET BYTE OFFSET IN SEGMENT
UNPKNXTU DS       0H                UNPACK NEXT STORAGE UNIT
*   FORM A LOOP TO UNPACK EACH SINGLE STORAGE UNIT OF DATA AND        *
*   CONVERT IT TO HEXADECIMAL                                         *
         SR       R0,R0             CLEAR EVEN REGISTER FOR DIVIDE
         LH       R1,DBYTEOFF       GET SEGMENT OFFSET OF NEXT BYTE
         D        R0,MAXUNTLN       EXTRACT UNIT MULTIPLE AND OFFSET
         SLL      R1,1              MAKE UNIT MULTIPLE A HALFWORD INDEX
         LH       R2,MSGUNITX(R1)   & USE IT TO PICK UP THE UNIT INDEX
         LA       R2,MSGTEXT(R2)    COMPUTE ADDRESS FOR HEX CHARACTERS
         AR       R2,R0             ADJUST ADDRESS BY UNIT OFFSET
         AR       R2,R0             MULTIPLIED BY 2 (2 BYTES/HEX CHAR)
         LCR      R1,R0             MAKE UNIT OFFSET -VE
         A        R1,MAXUNTLN       COMPUTE UNIT LENGTH TO DISPLAY
         CH       R1,DBYTECTR       UNIT LENGTH ¬> SEGMENT REMAINING?
         BNH      MLSL#016          YES - USE UNIT LENGTH FOR DISPLAY
         LH       R1,DBYTECTR       .... USE SEGMENT REMAINDER
MLSL#016 DS       0H
         BAS      R14,CVTBINHX      CONVERT HEX DATA TO DISPLAY HEX
         AR       R3,R1             BUMP STORAGE POINTER TO NEXT UNIT
         LR       R0,R1             GET COPY OF LENGTH FOR CALCULATION
         AH       R0,DBYTEOFF       INCREMENT BYTE OFFSET BY LENGTH
         STH      R0,DBYTEOFF       OF UNIT CONVERTED TO DISPLAY HEX
         LCR      R0,R1             GET COPY OF LENGTH FOR CALCULATION
         AH       R0,DBYTECTR       IS ENTIRE SEGMENT UNPACKED?
         STH      R0,DBYTECTR       STORE BACK UPDATED DOWN-COUNTER
         BNZ      UNPKNXTU          NO - GO UNPACK THE NEXT UNIT
*   AFTER CONVERTING NON-DISPLAYABLE CHARACTERS TO ITS SUBSTITUTION,  *
*   CALL PRESENTATION SERVICES TO DISPLAY THE BUFFER UNTIL ALL        *
*   SEGMENTS COMPLETE.                                                *
*   BEFORE DISPLAYING EACH SEGMENT, TVB'S "RESET" INDICATOR IS        *
*   CHECKED TO FIND OUT IF OPERATOR WANTS TO END THE DISPLAY          *
*   PREMATURELY.                                                      *
         MVI      MSGCHAD1,CHARDLIM MOVE IN LEFT CHARACTER DELIMITER
         LH       R1,DSEGOFFT       GET SEGMENT OFFSET FOR DATA
         LA       R2,MSGCHAIT(R1)   CALCULATE ADDRESS OF 1ST CHARACTER
         L        R3,ADRFIELD       GET ADDRESS OF DATA TO DISPLAY
         LH       R1,DSEGLEN        GET SEGMENT LENGTH FOR DATA
         BCTR     R1,R0             MAKE LENGTH RELATIVE TO 0
         EX       R1,MVCTOBUF       MOVE DATA TO BUFFER
         EX       R1,TRTNDCHA       TRANSLATE NONDISPLAYABLE CHARS
         MVI      MSGCHAD2,CHARDLIM MOVE IN RIGHT CHARACTER DELIMITER
         DSIPSS   TYPE=OUTPUT,      PRESENTATION SERVICES              *
               OPTIONS=SEG,         SEND THE FORMATTED LINE            *
               BFR=BUFRSVAD,        TO THE OPERATOR'S SCREEN           *
               SWB=CWBSWB
         LTR      R15,R15           DATA LINE WRITTEN OK ?
         BNZ      MLSABEND          NO - ISSUE DEBUGGING ABEND
         LH       R1,DSEGLEN        GET SEGMENT LENGTH DISPLAYED
         LR       R0,R1             GET COPY OF LENGTH FOR CALCULATION
         A        R0,ADRFIELD       UPDATE STORAGE ADDRESS FOR
         ST       R0,ADRFIELD       NEXT LINE TO BE DISPLAYED
         LR       R0,R1             GET COPY OF LENGTH FOR CALCULATION
         AH       R0,ADROFSET       UPDATE STORAGE OFFSET FOR
         STH      R0,ADROFSET       NEXT LINE TO BE DISPLAYED
         LCR      R0,R1             GET COPY OF LENGTH FOR CALCULATION
         AH       R0,LENFIELD       REDUCE LENGTH OF STORAGE FOR
         STH      R0,LENFIELD       NEXT LINE TO BE DISPLAYED
         BZ       DISPYEND          STORAGE LENGTH = 0, END OF DISPLAY
         BAS      R14,*+4           SET LINKREG FOR DEBUGGING
         BNP      MLSABEND          < 0 - ISSUE DEBUGGING ABEND
         L        R1,TIBTVB         GET POINTER TO TVB
         USING    DSITVB,R1         ADDRESSING TVB
         TM       TVBIND3,TVBRESET  ATTN KEY PRESSED ?
         DROP     R1
         BNO      NXTSEGMT          NO - GO DISPLAY NEXT SEGMENT
         MVI      HDRMTYPE,HDRTYPED INDICATE AN IMMEDIATE MESSAGE
         DSIMBS   MID=*RESETOK,     MESSAGE BUFFER SERVICES            *
               BFR=BUFRSVAD,        BUILD AN IMMEDIATE MSG             *
               MSGTBL=MSGTABAD,     ABOUT TERMINATION OF DISPLAY       *
               SWB=CWBSWB           DUE TO ATTN KEY PRESSED
         LTR      R15,R15           WAS MESSAGE MOVED TO BUFFER?
         BNZ      MLSABEND          NO - ISSUE A DEBUGGING ABEND
         DSIPSS   TYPE=IMMED,       PRESENTATION SERVICES              *
               BFR=BUFRSVAD,        SEND THE "ATTN KEY" MSG            *
               SWB=CWBSWB
         LTR      R15,R15           WAS MESSAGE WRITTEN SUCCESSFULLY?
         BNZ      MLSABEND          NO - ISSUE DEBUGGING ABEND
         MVI      HDRMTYPE,HDRTYPEU RESTORE USER MESSAGE INDICATOR
DISPYEND DS       0H
         ESPIE    RESET,SPIEPTOK    REINSTATE OLD ESPIE ENVIRONMENT
         DSIMBS   MID=*ENDLINE,     MESSAGE BUFFER SERVICES            *
               BFR=BUFRSVAD,        BUILD THE DISPLAY TRAILER MSG      *
               MSGTBL=MSGTABAD,                                        *
               SWB=CWBSWB
         LTR      R15,R15           WAS MESSAGE MOVED TO BUFFER?
         BNZ      MLSABEND          NO - ISSUE A DEBUGGING ABEND
         BAS      R14,EDIT_TID      EDIT MESSAGE ID OUT OF THE BUFFER
         DSIPSS   TYPE=OUTPUT,      PRESENTATION SERVICES              *
               OPTIONS=SEG,         SEND THE DISPLAY TRAILER LINE      *
               BFR=BUFRSVAD,        TO OPERATOR'S SCREEN               *
               SWB=CWBSWB
         LTR      R15,R15           WAS TITLE WRITTEN SUCCESSFULLY?
         BNZ      MLSABEND          NO - ISSUE DEBUGGING ABEND
         B        MLSRETRN          .... RETURN
MVCTOBUF MVC      0(*-*,R2),0(R3)   MOVE CHARACTER DATA TO BUFFER
TRTNDCHA TR       0(*-*,R2),XLAT_TB3 TRANSLATE NONDISPLAYABLE DATA
MLSRETRN DS       0H
*   RETURN TO CALLER                                                  *
         XR       R15,R15           ZERO RETURN CODE REGISTER.
         LA       R15,ZERO          GET RETURN CODE VALUE.
         L        R13,4(,R13)       POINT BACK TO RECEIVED SAVEAREA
         RETURN   (14,12),T,RC=(15) RETURN TO NETVIEW
MLSABEND DS       0H
*   COMMAND PROCESSOR ABEND ROUTINE                                   *
*   IT IS AN ABNORMAL SITUATION, HENCE A DUBUGGING DUMP IS PRODUCED.  *
*   REG14 TELLS WHERE THE LAST SERVICE REQUEST MACRO WAS ISSUED       *
*   REG15 TELLS THE RETURN CODE FROM THE REQUEST MACRO                *
         DC       Y(0)              INTENTIONAL OC1
CVTBINHX DS       0H
*   CONVERT BINARY DATA TO EBCDIC DATA.                               *
*   REG1 - LENGTH  OF BINARY DATA                                     *
*   REG2 - ADDRESS OF CONVERTED DATA                                  *
*   REG3 - ADDRESS OF BINARY DATA                                     *
         BCTR     R1,R0             MAKE BYTE COUNT RELATIVE TO 0
         EX       R1,MVCTOWKF       MOVE THE BINARY DATA TO WORK FIELD
         LA       R1,1(,R1)         RESTORE ACTUAL BYTE COUNT
         EX       R1,CVTBIZHX       UNPACK BINARY TO ZONED HEXADECIMAL
         TR       ZONHEXRF,XLAT_TB4 CONVERT ZONED HEXADECIMAL TO EBCDIC
         SLL      R1,1              2*(DATA LENGTH) = CHARACTER LENGTH
         LA       R15,L'HEXRECFD    GET LENGTH OF DISPLAY HEX FIELD
         SR       R15,R1            CALCULATE OFFSET OF 1ST CHARACTER
         LA       R15,HEXRECFD(R15) CALCULATE ADDRESS OF 1ST CHARACTER
         BCTR     R1,R0             MAKE CHARACTER COUNT RELATIVE TO 0
         EX       R1,MOVEHXBF       MOVE DISPLAY HEX TO RECEIVING FIELD
         LA       R1,1(,R1)         RESTORE ACTUAL CHARACTER COUNT
         SRL      R1,1              RESTORE ORIGINAL DATA BYTE COUNT
         BR       R14               RETURN TO THE CALLER
MVCTOWKF MVC      BDATAEXF(*-*),0(R3) MOVE BINARY DATA TO WORK FIELD
CVTBIZHX UNPK     HEXCVTFD,BDATAEXF(*-*) CONVERTS BINARY TO ZONED HEX
MOVEHXBF MVC      0(*-*,R2),0(R15)  MOVE CHARACTER DATA TO BUFFER
MLSERRTN DS       0H
*   ERROR HANDLING ROUTINE .........................................  *
*   SEND MESSAGE TO OPERATOR DESCRIBING THE PROBLEM ENCOUNTERED.      *
*   REG14 - POINTS AT A HALFWORD CONTAINING MESSAGE ID                *
         ST       R14,ERROR14       SAVE RETURN ADDRESS
         MVI      HDRMTYPE,HDRTYPED INDICATE AN IMMEDIATE MESSAGE
         LH       R2,0(,R14)        PICK UP MESSAGE ID TO ISSUE
         DSIMBS   MID=(R2),         MESSAGE BUFFER SERVICES            *
               BFR=BUFRSVAD,        GET MSG TO ISSUE FROM              *
               MSGTBL=MSGTABAD,     DSIMDS MSGTABLE                    *
               SWB=CWBSWB
         LTR      R15,R15           WAS MESSAGE BUILT SUCCESSFULLY?
         BNZ      MLSABEND          NO - ISSUE DEBUGGING ABEND
         DSIPSS   TYPE=IMMED,       PRESENTATION SERVICES              *
               BFR=BUFRSVAD,        SEND MSG                           *
               SWB=CWBSWB
         LTR      R15,R15           MESSAGE WRITTEN OK ?
         BNZ      MLSABEND          NO - ISSUE DEBUGGING ABEND
         MVI      HDRMTYPE,HDRTYPEU RESTORE USER MESSAGE INDICATOR
         L        R14,ERROR14       RETRIEVE RETURN ADDRESS
         B        2(,R14)           RETURN TO ADDRESS AFTER MID CODE
EDIT_TID DS       0H
*   THIS ROUTINE RECEIVES CONTROL WHEN A MESSAGE HAS BEEN BUILT       *
*   USING DSIMBS.  BECAUSE THE PREFIXED MESSAGE ID IS NOT WANTED,     *
*   THE BUFFER HEADER IS ADJUSTED TO CAUSE THE MESSAGE ID TO BE       *
*   IGNORED WHEN DSIPSS IS USED LATER.                                *
         LA       R1,MSGTEXT        GET ADDRESS OF START OF TEXT
         USING    MSGTEXT,R1        ADDRESSING THE TEXT IN THE BUFFER
MLSL#017 DS       0H
         CLI      MSGTEXT,BLANK     FIRST BLANK AFTER MESSAGE ID?
         LA       R1,1(,R1)         BUMP TO NEXT CHARACTER OF TEXT
         BNE      MLSL#017          NO - GO TEST NEXT CHARACTER
         SR       R1,BUFREG         CALCULATE DISPLACEMENT OF NON-BLANK
         DROP     R1
         LH       R0,HDRTDISP       SAVE OLD TEXT DISPLACEMENT
         STH      R1,HDRTDISP       SET NEW DISPLACEMENT IN HEADER
         SR       R1,R0             CALCULATE CHANGE IN DISPLACEMENT
         LCR      R1,R1             MAKE IT -VE
         AH       R1,HDRMLENG       AND USE IT TO REDUCE
         STH      R1,HDRMLENG       THE MESSAGE LENGTH
         BR       R14               RETURN TO CALLER
OC4RUTIN DS       0H
*   OC4 HANDLING ROUTINE.                                             *
*   THIS ROUTINE WILL DETERMINE IF OC4 WAS CAUSED WITHIN THIS MODULE. *
*   IF YES, THE BC MODE PSW IS MODIFIED SO THAT CONTROL WILL BE       *
*   REDIRECTED TO THE ERROR MESSAGE ROUTINE.                          *
*   OTHERWISE, PRODUCE A DEBUGGING DUMP.                              *
         USING    EPIE,R1           ADDRESSING THE RECEIVED PIE
         LA       R0,OC4RUTIN-MEMLIST GET OFFSET TO THIS EXIT ROUTINE
         LA       R15,0(,R15)       REMOVE HIGH ORDER BIT
         SR       R15,R0            COMPUTE ADDRESS OF MODULE
         CR       R15,MLSREG        IS BASE FOR MODULE SET UP?
         BE       MLSL#018          YES - WITHIN MODULE, ISSUE ERROR
         DC       Y(0)              CAUSE OC1 ABEND
MLSL#018 DS       0H
         LA       R2,OC4HNDLR       GET A(OC4 HANDLER)
         BSM      R2,R0             SET ADDRESSING MODE BIT
         ST       R2,EPIEPSW+4      MAKE IT NSI AFTER RETURN FROM EXIT
         BR       R14               RETURN TO INTERRUPT HANDLER
         DROP     R1
OC4HNDLR DS       0H                OC4 HANDLER
         BAS      R14,MLSERRTN      ISSUE MESSAGE TO SCREEN
         DC       Y(STGEXOC4)       ABOUT OC4
         B        DISPYEND          TERMINATING
*   CHECK TIB TYPE FOR THE CONTROL BLOCK ENTERED.                     *
OSTTYX02 DS       0H
         USING    DSICBH,TIBREG     ADDRESSABILITY FOR DSICBH
         CLI      CBHTYPE,X'02'     CHECK IF OST-TIB EXTENSION ?
         BER      R14               YES - RETURN
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE ABOUT
         DC       Y(MISCTLBK)       UNABLE TO FIND CONTROL BLOCK
         B        MLSRETRN          TERMINATING
PPTTYX00 DS       0H
         CLI      CBHTYPE,X'00'     CHECK IF PPT-TIB EXTENSION ?
         BER      R14               YES - RETURN AND CONTINUE.
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE ABOUT
         DC       Y(MISCTLBK)       UNABLE TO FIND CONTROL BLOCK
         B        MLSRETRN          TERMINATING
*   AFTER TRANSLATION, CHECK FOR DEC/HEX DIGITS.                      *
*        REG 7  - POINTS TO AREA CONTAINING TRANSLATED INPUT          *
CKSYNTAX DS       0H
         LA       R1,8              SET COUNTER FOR MAXIMUM LENGTH
CKSLOOP1 DS       0H
         CLI      0(R7),X'40'       IS IT C' ' (END OF DATA) ?
         BE       CKSPACK           YES - GO PACK THE DATA
         CLI      0(R7),X'00'       NO - IS IT INVALID DATA ?
         BNE      MLSL#019          NO - GO CHECK LENGTH DATA
         BAS      R14,MLSERRTN      YES, ISSUE ERROR MESSAGE ABOUT
         DC       Y(BADHXDEC)       INVALID NUMERIC DATA
         B        MLSRETRN          TERMINATING
MLSL#019 DS       0H
         LA       R6,1(R6)          NO - ADD 1 TO COUNT
         LA       R7,1(R7)          ADDRESS OF NEXT BYTE.
         BCT      R1,CKSLOOP1       GO CHECK NEXT BYTE
CKSPACK  DS       0H
         LTR      R6,R6             COUNT OF VALID CHAR = 0 ?
         BNZ      MLSL#020          NO - START PROCESSING DATA
         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE ABOUT
         DC       Y(BADKEYWD)       EXCESSIVE DATA LENGTH
         B        MLSRETRN          TERMINATING
MLSL#020 DS       0H
         SR       R7,R6             NO. POINT TO START OF OUTPUT AREA.
         BCTR     R6,0              REDUCE COUNT OF VALID CHAR BY ONE.
         EX       R6,PACKEX         GO PACK THE DATA.
         LM       R6,R7,PACKAREA    RLI
         SRDL     R6,4              GET RID OF LOW ORDER 4 BITS ON R7
         LR       R6,R7             RLI
         BR       R14               RETURN BACK.
PACKEX   PACK     PACKAREA,0(0,R7)  PACK THE DATA.
PDBENTLN DC       A(PDBENTND-PDBENTRY) LENGTH OF A PDB TABLE ENTRY
CB_LIST  DS       0F                LIST OF CTL BLK NAME AND BR ADDRESS
         DC       CL4'ACB '
         DC       A(CB_ACB)
         DC       CL4'ART '
         DC       A(CB_ART)
         DC       CL4'CDNI'
         DC       A(CB_CDNIB)
         DC       CL4'DDT '
         DC       A(CB_DDT)
         DC       CL4'DQT '
         DC       A(CB_DQT)
         DC       CL4'EXSW'
         DC       A(CB_EXSWB)
         DC       CL4'ICCW'
         DC       A(CB_ICCWB)
         DC       CL4'ICPD'
         DC       A(CB_ICPDB)
         DC       CL4'MRCW'
         DC       A(CB_MRCWB)
         DC       CL4'MRPD'
         DC       A(CB_MRPDB)
         DC       CL4'MVT '
         DC       A(CB_MVT)
         DC       CL4'NAT '
         DC       A(CB_NAT)
         DC       CL4'NCCW'
         DC       A(CB_NCCWB)
         DC       CL4'NCPD'
         DC       A(CB_NCPDB)
         DC       CL4'NPSW'
         DC       A(CB_NPSWB)
         DC       CL4'OIT '
         DC       A(CB_OIT)
         DC       CL4'ORRP'
         DC       A(CB_ORRPL)
         DC       CL4'OSNI'
         DC       A(CB_OSNIB)
         DC       CL4'OSRP'
         DC       A(CB_OSRPL)
         DC       CL4'RARP'
         DC       A(CB_RARPL)
         DC       CL4'RCRP'
         DC       A(CB_RCRPL)
         DC       CL4'RSRP'
         DC       A(CB_RSRPL)
         DC       CL4'SAT '
         DC       A(CB_SAT)
         DC       CL4'SCRP'
         DC       A(CB_SCRPL)
         DC       CL4'SCT '
         DC       A(CB_SCT)
         DC       CL4'SNT '
         DC       A(CB_SNT)
         DC       CL4'SVL '
         DC       A(CB_SVL)
         DC       CL4'TIB '
         DC       A(CB_TIB)
         DC       CL4'TVB '
         DC       A(CB_TVB)
         DC       CL4'PRCR'
         DC       A(CB_PRRPL)
         DC       CL4'PSCR'
         DC       A(CB_PSRPL)
         DC       CL4'HELP'
         DC       A(MLSHELP)
         DC       XL4'00000000'     END OF TABLE.
KEYWDFM1 DC       C'BLLETEOP  '     KEYWORDS FORMAT #1; BL LE TE OP
KEYWDFM2 DC       C'ADLEVERE  '     KEYWORDS FORMAT #2; AD LE VE RE
MAXSEQLN DC       F'16'             MAXIMUM LENGTH OF STORAGE SEGMENT
MAXUNTLN DC       F'4'              MAXIMUM LENGTH OF STORAGE UNIT
MSGUNITX DS       0H
         DC       Y(MSGUNIT1-MSGTEXT) OFFSET TO FIRST HEXADECIMAL UNIT
         DC       Y(MSGUNIT2-MSGTEXT) OFFSET TO SECOND HEXADECIMAL UNIT
         DC       Y(MSGUNIT3-MSGTEXT) OFFSET TO THIRD HEXADECIMAL UNIT
         DC       Y(MSGUNIT4-MSGTEXT) OFFSET TO FOURTH HEXADECIMAL UNIT
XLAT_TB1 DC       256X'00'          TABLE TO VALIDATE HEXADECIMAL DATA
         ORG      XLAT_TB1+C' '
         DC       C' '
         ORG      XLAT_TB1+C'A'-C' '
         DC       X'FAFBFCFDFEFF'
         ORG      XLAT_TB1+C'A'
         DC       X'FAFBFCFDFEFF'
         ORG      XLAT_TB1+C'0'
         DC       X'F0F1F2F3F4F5F6F7F8F9'
         ORG      ,
XLAT_TB2 DC       256X'00'          TABLE TO VALIDATE DECIMAL DATA
         ORG      XLAT_TB2+C' '
         DC       C' '
         ORG      XLAT_TB2+C'0'
         DC       X'F0F1F2F3F4F5F6F7F8F9'
         ORG      ,
XLAT_TB3 DC       256C'.'           TRANSLATE NONDISPLAYABLE CHARACTERS
         ORG      XLAT_TB3+C' '
         DC       1AL1(*-XLAT_TB3)  <SPACE>
         ORG      XLAT_TB3+C'Ý'
         DC       7AL1(*-XLAT_TB3)  Ý.<(+¨&
         ORG      XLAT_TB3+C'!'
         DC       8AL1(*-XLAT_TB3)  !$*);¬-/
         ORG      XLAT_TB3+C'|'
         DC       6AL1(*-XLAT_TB3)  |,%_>?
         ORG      XLAT_TB3+C'`'
         DC       7AL1(*-XLAT_TB3)  `:#@'="
         ORG      XLAT_TB3+C'A'-C' '
         DC       9AL1(*-XLAT_TB3)  ABCDEFGHI (LOWER CASE)
         ORG      XLAT_TB3+C'J'-C' '
         DC       9AL1(*-XLAT_TB3)  JKLMNOPQR (LOWER CASE)
         ORG      XLAT_TB3+C'~'
         DC       1AL1(*-XLAT_TB3)  ~
         ORG      XLAT_TB3+C'S'-C' '
         DC       8AL1(*-XLAT_TB3)  STUVWXYZ (LOWER CASE)
         ORG      XLAT_TB3+C'{'
         DC       1AL1(*-XLAT_TB3)  {
         ORG      XLAT_TB3+C'A'
         DC       9AL1(*-XLAT_TB3)  ABCDEFGHI (UPPER CASE)
         ORG      XLAT_TB3+C'}'
         DC       1AL1(*-XLAT_TB3)  }
         ORG      XLAT_TB3+C'J'
         DC       9AL1(*-XLAT_TB3)  JKLMNOPQR (UPPER CASE)
         ORG      XLAT_TB3+C'\'
         DC       1AL1(*-XLAT_TB3)  \
         ORG      XLAT_TB3+C'S'
         DC       8AL1(*-XLAT_TB3)  STUVWXYZ (UPPER CASE)
         ORG      XLAT_TB3+C'0'
         DC       10AL1(*-XLAT_TB3)
         ORG      ,
*        THIS TABLE IS USED TO TRANSLATE ZONED HEXADECIMAL TO         *
*        EBCDIC INTERPRETED HEXADECIMAL (DISPLAY) FORMAT              *
XLAT_TB4 EQU      *-C'0'
         DC       C'0123456789ABCDEF' SUBSTITUTE WITH EBCDIC CHARACTERS
MSGTABAD DC       A(MSGTABLE)       FULL ADDRESS OF MESSAGE TABLE
HELPRC12 DC       H'12'             DSIMBS RETURN CODE => "END OF HELP"
SHIFT24  EQU      24                LOW TO HIGH ORDER BYTE SHIFT COUNT
BLANK    EQU      C' '              CHARACTER USED TO CLEAR BUFFER
CHARDLIM EQU      C'+'              INTERPRETED TEXT DELIMITER
ZERO     EQU      0                 RETURN CODE TO CLEAR COMMAND AREA
BADSYNTX EQU      030               INVALID SYNTAX
BADCTLBK EQU      031               INVALID CONTROL BLOCKS
BADHXDEC EQU      032               INVALID HEX/DEC DATA
BADKEYWD EQU      033               INVALID KEYWORD/KW VALUE LENGTH
BADLUID  EQU      034               INVALID TERM-ID
BADOPID  EQU      035               INVALID OPER-ID
MISCTLBK EQU      036               CONTROL BLOCK UNAVAILABLE
BADTIB   EQU      037               NO ACTIVE TIB
UNDKEYWD EQU      038               KEYWORDS UNDEFINED
BADSCOPE EQU      039               PARMS NOT WITHIN OST SCOPE
STGEXOC4 EQU      040               OC4
HDRLINE  EQU      041               STORAGE DISPLAY HEADER LINE
ENDLINE  EQU      042               STORAGE DISPLAY TRAILER LINE
BADCBADR EQU      043               DISPLAY CTL BLOCK ADDRESS IS 0
BADVRFLD EQU      044               VERIFY/REPLACE LENGTH ¬= 8
BADVERFY EQU      045               INVALID VERIFY
REPLCEOK EQU      046               VERIFY/REPLACE DONE
RESETOK  EQU      047               "DISPLAY TERMINATED BY RESET"
MSGTABLE AMODE    31
MSGTABLE RMODE    ANY
MSGTABLE DSIMDS   MLS,TYPE=START    MESSAGE TABLE CONTROL SECTION
         DSIMDS   000,'MLS message &&1 not found in MESSAGE TABLE',    *
               TYPE=E
         DSIMDS        001,'For the display of NetView control blocks, *
               enter:',TYPE=E
         DSIMDS        002,'MLST Block=<controlblockname>(,Length=<leng*
               th>)',TYPE=E
         DSIMDS        003,'     (,{Terminal=<resource>¨Operator=<taski*
               d>})    ....OR',TYPE=E
         DSIMDS        004,'MLST Address=<address>(,Length=<length>)', *
               ,TYPE=E
         DSIMDS        005,'<length> = {X<hex>¨dec¨*} "*" is the implic*
               it length of CTL block',TYPE=E
         DSIMDS        006,'if no Length specified, default is 1K for C*
               TL block; 4 for Address',TYPE=E
         DSIMDS        007,'For OST,PPT,NNT,and OPT, <controlblockname>*
                can be:',TYPE=E
         DSIMDS     008,'     ART DDT DQT MVT OIT SCT SNT SVL (1 COPY P*
               ER NETVIEW)',TYPE=E
         DSIMDS     009,'     ACB EXSWB ICCWB ICPDB MRCWB MRPDB NCCWB N*
               CPDB NPSWB TIB TVB',TYPE=E
         DSIMDS     010,'     (1 copy per task; differentiated by Termi*
               nal or Operator ID)',TYPE=E
         DSIMDS     011,'Also, for OST only, extra <controlblockname> c*
               an be:',TYPE=E
         DSIMDS     012,'     CDNIB ORRPL OSNIB OSRPL RARPL RCRPL SCRPL*
                NAT SAT',TYPE=E
         DSIMDS     013,'Also, for PPT only, extra <controlblockname> c*
               an be:',TYPE=E
         DSIMDS     014,'     PRCRPL PSCRPL',TYPE=E
         DSIMDS     015,'e.g. MLST B=MVT,L=X32',TYPE=E
         DSIMDS     016,'     MLST B=TVB,L=32,Oper=JOHNDOE',TYPE=E
         DSIMDS     017,'               ',TYPE=E
         DSIMDS     018,'For modifying 4-byte memory within the NetView*
                address space, enter:',TYPE=E
         DSIMDS     019,'MLST Address=<address>,Verify=<4-BYTE HEX>,Rep*
               lace=<4-byte hex>',TYPE=E
         DSIMDS     020,'e.g. MLST A=8A23468,V=12345678,R=87654321  con*
               tents of A(8A23468) will',TYPE=E
         DSIMDS     021,'be verified against X"12345678" before being r*
               eplaced by X"87654321"',TYPE=E
         DSIMDS        030,'INVALID COMMAND SYNTAX, ENTER "MLST BLOCK=H*
               ELP" FOR ASSISTANCE',TYPE=E
         DSIMDS        031,'INVALID CONTROL BLOCK, ENTER "MLST B=HELP" *
               FOR ALL NAMES',TYPE=E
         DSIMDS      032,'INVALID DECIMAL/HEXADECIMAL DATA',TYPE=E
         DSIMDS      033,'INVALID KEYWORD/KEYWORD VALUE LENGTH',TYPE=E
         DSIMDS      034,'INVALID TERMINAL-ID(RESOURCE) VALUE',TYPE=E
         DSIMDS      035,'INVALID OPERATOR-ID(TASKID) VALUE',TYPE=E
         DSIMDS     036,'REQUESTED NETVIEW CONTROL BLOCK NOT AVAILABLE *
               FOR THIS TASK',TYPE=E
         DSIMDS      037,'NO ACTIVE TIB FOR TERMINAL/OPERATOR',TYPE=E
         DSIMDS       038,'KEYWORDS:BLOCK LENGTH TERMINAL OPERATOR ADDR*
               ESS VERIFY REPLACE',TYPE=E
         DSIMDS        039,'KEYWORD PARAMETER IS NOT IN YOUR SCOPE',TYP*
               E=E
         DSIMDS        040,'STORAGE PROTECTION EXCEPTION WHILE PROCESSI*
               NG REQUEST',TYPE=E
         DSIMDS        041,'--ADDR-- OFST ------------HEXADECIMAL------*
               ------  ---CHARACTERS---',TYPE=I
         DSIMDS        042,'---------------------- END OF STORAGE DISPL*
               AY ----------------------',TYPE=I
         DSIMDS        043,'POINTER TO THE REQUESTED CONTROL BLOCK = 0'*
               ,TYPE=I
         DSIMDS        044,'VERIFY/REPLACE LENGTH ¬= 8',TYPE=E
         DSIMDS        045,'VERIFY FAIL',TYPE=E
         DSIMDS        046,'REPLACE DONE',TYPE=E
         DSIMDS        047,'STORAGE DISPLAY TERMINATED BY ATTN KEY OR R*
               ESET',TYPE=I
         DSIMDS   TYPE=END
         IHAEPIE  ,                 GENERATE DEFINITION OF EPIE
MEMLIST  CSECT                      RESUME CSECT DEFINITION
MEMLIST  CSECT                      (RESUME INTERRUPTED DSECT)
         DSICBS   DEFER=INCLUDE,                                       *
               EJECT=NO,                                               *
               PRINT=NO
BUFHDR   DSECT    ,                 AUGMENT DEFINITION OF BUFFER HEADER
         ORG      HDRTEXT           REDEFINE TEXT AREA IN A BUFFER
MSGTEXT  DS       0CL(MSGMXTXL)     TEXT OF MESSAGE
MSGRECAD DS       CL(2*L'ADRFIELD)  VIRTUAL ADDRESS OF STORAGE
         DS       C
MSGRELAD DS       CL(2*L'ADROFSET)  RELATIVE ADDRESS OF STORAGE
         DS       C
MSGUNIT1 DS       CL8               FIRST HEX UNIT DISPLAY AREA
         DS       C
MSGUNIT2 DS       CL8               SECOND HEX UNIT DISPLAY AREA
         DS       C
MSGUNIT3 DS       CL8               THIRD HEX UNIT DISPLAY AREA
         DS       C
MSGUNIT4 DS       CL8               FOURTH HEX UNIT DISPLAY AREA
         DS       C
MSGCHAD1 DS       C                 FIRST CHARACTER DELIMITER
MSGCHAIT DS       CL16              CHARACTER INTERPRETATION OF DATA
MSGCHAD2 DS       C                 SECOND CHARACTER DELIMITER
MSGTXTLN EQU      *-MSGTEXT         CALCULATE LENGTH OF DISPLAY TEXT
DSICWB   DSECT                      CONTINUE DEFINING CWB.
         ORG      CWBADATD          REDEFINE DATA AREA IN CWB.
SPIEPTOK DS       A                 TOKEN OF PREVIOUSLY ACTIVE ESPIE
SPIELISF ESPIE    SET,MF=L          RESERVE STORAGE FOR ESPIE LIST-FORM
         DS       0F
OUTAREA  DS       0CL32             OUTPUT AREA FOR OPERANDS.
         DS       CL8               AREA FOR 1ST KEYWD CB/ADDR VALUE.
         DS       CL8               AREA FOR 2ND KEYWD (LENGTH) VALUE.
         DS       CL8               AREA FOR 3RD KEYWD (LUNAME) VALUE.
         DS       CL8               AREA FOR 4TH KEYWD (OPID) VALUE.
TVBSAVAD DS       A                 SAVE AREA FOR LOCATE TVB ADDRESS.
PDBPOSEN DS       F                 POSITION OF PDB ENTRY FOR PAS CALL
KEYWDTXT DS       CL8               TEXT OF KEYWORD PARAMETER
ERROR14  DS       A                 ERROR ROUTINE RETURN ADDRESS
ADRFIELD DS       A                 STORAGE ADDRESS DISPLAYED/REPLACED
VERFIELD DS       F                 VERIFY FIELD
REPFIELD DS       F                 REPLACE FIELD
LENFIELD DS       H                 LENGTH OF STORAGE TO BE DISPLAYED
ADROFSET DS       H                 OFFSET OF STORAGE BEING DISPLAYED
DSEGOFFT DS       H                 OFFSET OF START OF STORAGE SEGMENT
DSEGLEN  DS       H                 LENGTH OF STORAGE SEGMENT
DBYTEOFF DS       H                 OFFSET OF BYTES TO BE DISPLAYED
DBYTECTR DS       H                 DISPLAY BYTE DOWN COUNTER
FMT2SW   DS       C                 FORMAT 2 SWITCH
VERIFYSW DS       C                 VERIFY SWITCH
PACKAREA DS       0D                DOUBLE WORK AREA TO PACK/UNPACK.
         DS       CL8
BDATAEXF DS       BL4               BINARY DATA EXTRACTION FIELD
HEXCVTFD DS       CL9               HEXADECIMAL CONVERSION WORK FIELDS
HEXCVTFE DS       0X                END OF CONVERSION WORK FIELDS
         ORG      HEXCVTFD          REDEFINE WORK FIELD
ZONHEXRF DS       CL8               ZONED HEXADECIMAL RECEIVING FIELD
         ORG      ZONHEXRF          REDEFINE ZONED HEX FIELD
HEXRECFD DS       CL8               DISPLAY HEXADECIMAL RECEIVING FIELD
         ORG      HEXCVTFE          RESTORE LOCATION COUNTER
BUFRSVAD DS       A                 ADDRESS OF BUFFER
BUFRSTOR DS       0D                START OF BUFFER STORAGE
MSGMXBFL EQU      L'CWBADATD-(*-CWBADATD) MAXIMUM MESSAGE BUFFER LENGTH
MSGMXTXL EQU      MSGMXBFL-(HDRTEXT-BUFHDR) MAXIMUM MESSAGE TEXT LENGTH
         END


Richard Li
SNA Systems Programmer (Canada)

