{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013537000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2527798, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 19, "INMDSNAM": "CBT.V500.FILE944.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2527798, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2527798, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE944.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00)\\x03'", "DS1TRBAL": "b'\\xc4\\xb2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\xb7\\x00\\x02\\t\\xb9\\x00\\r\\x00*'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x00!\\x01\\x16\\x18\\x1f\\x01\\x16\\x18\\x1f\\x02%\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2016-06-29T00:00:00", "modifydate": "2016-06-29T02:25:21", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-491"}, "text": "REGULAR CBT TAPE - VERSION 491    FILE:  944\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT491.FILE944\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   PDS117I 78 MEMBERS COUNTED; CUMULATIVE SIZE IS 23,106 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/29/16    02:25:21    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE944": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x00\\x00\\x01\\x16\\x18\\x1f\\x01\\x16\\x18\\x1f\\x02%\\x00\\x10\\x00\\x10\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2016-06-29T00:00:00", "modifydate": "2016-06-29T02:25:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "CBT-491"}, "text": "//***FILE 944 contains articles downloaded from Xephon archives,    *   FILE 944\n//*           from SNA Update magazines, which are now supported    *   FILE 944\n//*           by www.cbttape.org, bu way of permission from Thomas  *   FILE 944\n//*           Publishing and Bob Thomas.  The Xephon company is     *   FILE 944\n//*           now defunct, the rights were given over to Thomas     *   FILE 944\n//*           publishing, who gave the support rights to us.  So    *   FILE 944\n//*           you can now use all this information and code, in     *   FILE 944\n//*           good conscience.                                      *   FILE 944\n//*                                                                 *   FILE 944\n//*           Articles in this file are from March 1991 thru        *   FILE 944\n//*           December 1992.                                        *   FILE 944\n//*                                                                 *   FILE 944\n//*           email:  sbgolob@cbttape.org                           *   FILE 944\n//*                   sbgolob@attglobal.net                         *   FILE 944\n//*                                                                 *   FILE 944\n//*                                                                 *   FILE 944\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N001A00I": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 18, "newlines": 18, "modlines": 0, "user": "SNAUPDT"}, "text": "N001 - SNA Update Issue #1  March 1991\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nN001A01   Welcome to SNA Update\nN001A02   RTM data collection\nN001A03   NCCF CLIST for switched off controllers\nN001A04   CA-ACF2 expired password exit\nN001A05   A VTAM Secondary Program Operator program\nN001A06   Using printers in SNA\nN001A07   You don't need to define CDRSCs\nN001A08   NCCF CLISTs and NetView\nN001A09   Displaying NCP pseudo-slowdown status flag\nN001A10   Locating the terminal BIND image\nN001A11   NetView VSAM administration\nN001A12   A VTAM application front-end program\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N001A01": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00,\\x00,\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 44, "newlines": 44, "modlines": 0, "user": "SNAUPDT"}, "text": "Welcome to SNA Update\n\nWelcome to the first issue of SNA Update.  While it has taken\nsome time for the original idea of a technical journal that\naddresses SNA to come to full fruition, we are confident that\nSNA Update will take its place alongside CICS Update, VM\nUpdate, and MVS Update as an indispensable part of the\nlibrary of any IBM mainframe installation.\n\nOur principal aim is to provide a vehicle for the exchange of\nhints, tips, warnings, and reports between systems\nprogrammers, technical support staff, network administrators,\nand any other personnel who require a detailed knowledge of\nSNA-related facilities.\n\nWe have broadened our interpretation of SNA to include many\naspects of mainframe data communications and networking that\nmight not otherwise be covered by a more literal definition.\nThis isdone not to upset the purists but to give SNA Update a\nwider appeal and to ensure that that the investment made by\nour subscribers is repaid as fully and as quickly as possible.\n\nThe production of SNA Update relies heavily on the input of\nour readers.  Unfortunately, a large potential source for many\narticles remains untapped.  Some of the most valuable articles\nconcern things that have gone wrong.  We, and more\nimportantly your fellow readers, would like very much to hear\ndetails of any of your SNA-related experiences where things\ndid not quite go according to plan.  While it might be a bit\nembarrassing admitting that something was your mistake, we\ncan spare your blushes, if you wish, by preserving your\nanonymity should we publish your work.  There are very few\nerrors you can make in the DP world that some other poor soul\nwould not repeat if he or she is not warned about them and\nsharing a description of any of your bloomers is a very good\nway of turning a negative event into something positive.\n\nWe pay a good competitive rate for material accepted for\npublication ($250 or \u0082120 per 1000 words) or we can offer free\n12-month subscriptions to any of our technical journals in\nexchange for using your article.  If you would like further\ndetails, please contact the editor, Steve Piggott, at any of the\naddresses shown on page 2.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N001A02": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x01p\\x01p\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 368, "newlines": 368, "modlines": 0, "user": "SNAUPDT"}, "text": "RTM data collection\n\nIn the on-line environment, most complaints from end-users are\nabout response time.  Look at the response time report from a\nsoftware package and it doesn't tell you the real response time.\nThe only thing you get is the VTAM application's internal\nresponse time.\n\nFor terminals attached to a 3x74 control unit, the following\nprogram could be set up to collect the RTM data to a VSAM\nfile, after turning on the RTM feature on the controller.\n\nDepending on how often this program is run, the report could\nbe generated from this VSAM file by hour, by date, or by PU.\n\nThe following points need to be considered before\nimplementing the program:\n\n1      PUNAME needs to be modified based on site PU naming\n      conventions.\n\n2      RTM data in the PU will be reset after it has been received\n      successfully.\n\n3      The RTMACB APPL definition in VTAMLSTs would be:\n\n      A99CNM APPL AUTH=(NVPACE,ACQ,PASS,CNM,SPO),EAS=6\n\n\nPROGRAM SOURCE CODE\n\nRTMCOLT  CSECT\n         SAVE  (14,12)\n         BALR  R2,0\n         USING *,R2\n         ST    R13,SAVEREG+4          SAVE REGISTER 13\n         LA    R12,SAVEREG            PUT MACRO USING REG 13\n         ST    R12,SAVEREG+8\n         LR    R13,R12\nPARMRTN  DS    0H                     PROCESS PARAMETER\n         L     R4,0(R1)               R1 IS PARM ADDRESS\n         CLC   0(2,R4),=X'0000'       PARM LENGTH\n         BH    MVCPARM\n         B     GETDATE\nMVCPARM  DS    0H\n         LH    R5,0(R4)\n         SH    R5,=H'1'               LEN FOR NEXT INSTRUCTION EX MVC\n         EX    R5,MVCPU               MOVE PARM TO PUNAME\n         LA    R10,PUNAME\n         AR    R10,R5\n         MVC   1(10,R10),=10C'*'      END MARKER OF PUNAME\n         B     GETDATE\nMVCPU    MVC   PUNAME(0),2(R4)\nGETDATE  DS    0H\n         TIME\n         ST    R0,TOD\n         ST    R1,YYDDDF\n         MVC   WORKD(5),=X'4021202020'\n         ED    WORKD(5),YYDDDF        YEAR\n         MVC   DATE(2),WORKD+3\n         LA    R6,DATETAB+11*4        CAL MONTH\nDATELOOP CP    YYDDDF+2(2),2(2,R6)\n         BH    MONTH\n         SH    R6,=H'4'               POINT PREVIOUS MONTH\n         CLC   0(2,R6),=C'01'         JAN MONTH\n         BH    DATELOOP\nMONTH    MVC   DATE+2(2),0(R6)        MONTH\n         SP    YYDDDF+2(2),2(2,R6)\n         MVC   WORKF(4),=X'40212020'\n         ED    WORKF(4),YYDDDFF+2      DAY\n         MVC   DATE+4(2),WORKF+2\n         B     BEGIN\nBEGIN    DS    0H\n         OPEN  (PRINT,(OUTPUT))\n         OPEN  (VSAMIN)\n         LTR   R15,R15              R15 KEEPS THE RETURN CODE\n         BZ    GETMAIN              R15 = 0 IS OK\n         WTOR  '++RTMCOLT VSAM(RTM) OPEN ERROR,,,               ',     *\n               LINE,119,ECB1\n         WAIT  ECB=ECB1             WAIT FOR WTOR THEN NEXT\n         MVC   ERRMSG(25),=C'VSAM OPEN ERROR          '\n         B     ERROR\nGETMAIN  GETMAIN RU,LV=1233         GETMAIN ,LEN=1233\n         LR    R12,R1               R1 SAVE THE GETMAIN ADDRESS\n         USING VSAMREC,R12          VSAMREC IS DUMMY SECTION\nMODRPL1  MODCB RPL=VSAMRPL,AREA=(R12),AREALEN=1233,ARG=VSAMARG\n         LTR   R15,R15\n         BZ    RTMRTN\n         MVC   ERRMSG(25),=C'VSAM MODRPL1 ERROR       '\n         B     ERROR\nRTMRTN   DS    0H\n         LA    R10,PUNAME            PU TABLE, DONT DESTROY\nRTMOPEN  OPEN  RTMACB\n         LTR   R15,R15\n         BZ    SENDREQ\n         WTOR  '++RTMCOLT CNM (RTM) OPEN ERROR,,,               ',     *\n               LINE,119,ECB1\n         WAIT  ECB=ECB1\n         MVC   ERRMSG(25),=C'RTM OPEN ERROR           '\n         B     ERROR\n*        GET  PU NEXT SHIFT IN VSAM AND SEND RTM REQUEST\nSENDREQ  DS    0H\n         CLC   0(4,R10),=C'****'  END OF PU TAB\n         BE    EOJ\n         XR    R3,R3                   RESET # OF LU CTR\nKEYSET   MVC   ARGPU(8),0(R10)        VSAM KEY =PU+DATE+HH\n         MVC   ARGDATE(6),DATE                  8 + 6  + 2\n         MVC   WORKF(4),=X'F0F02120'   CHANGE HH FORMAT\n         ED    WORKF(4),HH                    \"\n         MVC   ARGHH(2),WORKF+2               \"\n         MVC   DSTNAME(8),0(R10)     DESTINATION PU (8 BYTES)\n         MVC   TAGNAME(8),0(R10)     TARGET PU      (8 BYTES)\n         MVI   SENDSW,X'00'             RESET SWITCH\n         LA    R11,VSAMREC+18         FOR OUTPUT   AT R11\n         L     R4,RTMNIB+4            GET CID\n         SEND  RPL=RTMRPL,AREA=RTMREQ,RECLEN=44,OPTCD=(FMHDR),         *\n               ARG=(R4),RESPOND=(NEX,FME,NRRN,NQRESP)\n         LTR   R15,R15\n         BZ    RECVREQ\n         MVI   SENDSW,X'FF'           CONTINUE PROCESSING\n         MVC   ERRMSG(25),=C'RTM SEND REQUEST ERROR   '\n         B     ERROR\n*        RECEIVE RTM DATA\nRECVREQ  DS    0H\n         MVI   SENDSW,X'00'             RESET SWITCH\n         RECEIVE RPL=RTMRPL,AREA=RTMDATA,AREALEN=200\n         LTR   15,15\n         BZ    WRITE\n         MVI   SENDSW,X'FF'           CONTINUE PROCESSING\n         MVC   ERRMSG(25),=C'RTM RECEIVE ERROR        '\n         B     ERROR\n*        FORMAT EACH LU RTM DATA AND WRITE TO VSAM FILE\nWRITE    DS    0H\n         LA    R9,RTMDATA\n         MVC   LENGTH(2),6(R9)         NS RU LENGTH\n         MVC   LASTSW(1),15(R9)        LAST RECORD SEND FROM PU\n         CLC   18(2,R9),=X'0080'       RTM RESPONSE VECTOR\n         BNE   ERROR\n         TM    17(R9),X'20'             X'25' X'27' NO DATA\n         BZ    FORMAT\n         B     NEXTREC\nFORMAT   LA    R9,20(R9)                FIRST SUBVECT\nSUBVECT  CLI   1(R9),X'04'              SNA ADDR (LU ADDRESS)\n         BE    GETLU\n         CLI   1(R9),X'93'              RTM CNT\n         BE    GETCNT\n         B     NEXTFLD\nGETLU    DS    0H\n         A     R3,=F'1'                 COUNT # OF LU\n         MVC   WORKH(2),8(R9)\n         LH    R5,WORKH\n         SH    R5,=H'2'                 CONVERT TO TERMINAL ID\n         CVD   R5,WORKD                 IN THIS CASE  TERM=PU+NN\n         UNPK  0(2,R11),WORKD+6(2)      (IE FA00,FA01,IB04....)\n         OI    1(R11),X'F0'             DISPLAY FORMAT\n         LA    R11,2(R11)\n         B     NEXTFLD\nGETCNT   DS    0H\n         LA    R7,17(R9)                RTM CNT AREA ADDR\n         LA    R6,5                     RTM CNT NUMBER\nCNTLOOP  MVC   WORKH(2),0(R7)\n         LH    R5,WORKH\n         CVD   R5,WORKD\n         MVC   0(5,R11),WORKD+3\n         LA    R11,5(R11)               NEXT CNT IN VSAMREC\n         LA    R7,2(R7)                 NEXT CNT IN RTMDATA\n         BCT   R6,CNTLOOP\n         B     NEXTFLD\nNEXTFLD  DS    0H\n         XC    WORKH,WORKH              CLEAR\n         MVC   WORKH+1(1),0(R9)\n         LH    R5,WORKH\n         AR    R9,R5                    POINT TO NEXT RTM SUBVECTOR\n         LR    R6,R9\n         LA    R5,RTMDATA+8\n         SR    R6,R5\n         CH    R6,LENGTH                IF OVER LENGTH\n         BNL   NEXTREC\n         B     SUBVECT\nNEXTREC  DS    0H\n         TM    LASTSW,X'40'             B'01000000' NOT LAST RECORD\n         BO    RECVREQ                  RECEIVE NEXT RTM LU DATA\n         LA    R5,VSAMREC\n         SR    R11,R5\n         B     PUTVSAM\nPUTVSAM  DS    0H\n         LTR   R3,R3                    CHECK R3 (# OF LU)\n         BNZ   LUOK                     # LU > 0\n         MVC   LINE(15),=C' ++ RTMCOLT ++ '\n         MVC   LINE+15(08),ARGPU\n         MVC   LINE+23(25),=C': NO RTM DATA AVAILABLE  '\n         PUT   PRINT,LINE\n         MVI   LINE,C' '\n         MVC   LINE+1(131),LINE\n         B     NEXTPU\nLUOK     STH   R3,WORKH                 CONVERT # LU FMT\n         MVC   VSAMCTR(2),WORKH\nMODRPL2  MODCB RPL=VSAMRPL,RECLEN=(R11)\n         LTR   R15,R15\n         BZ    PUTRTM\n         MVC   ERRMSG(25),=C'VSAM MODRPL2 ERROR       '\n         B     ERROR\nPUTRTM   MVC   VSAMREC(16),VSAMARG\n         PUT   RPL=VSAMRPL\n         LTR   15,15\n         BNZ   PUTERR\n         MVC   LINE(14),=C'++RTMCOLT++   '\n         MVC   LINE+14(8),0(R10)\n         MVC   LINE+20(8),=C'COMPLETE'\n         PUT   PRINT,LINE\n         MVI   LINE,C' '\n         MVC   LINE+1(131),LINE\n         B     NEXTPU\nPUTERR   MVC   ERRMSG(25),=C'VSAM WRITE FAILURE        '\n         B     ERROR\nNEXTPU   LA    R10,8(R10)              NEXT PU\n         B     SENDREQ\n*        ERROR ROUTINE\nERROR    DS    0H\nSNAERR   DS    0H\n         LA    R3,RTMRPL\n         MVI   SSENSEI,0           RESET SYSTEM SENSE ERROR INPUT\n         MVC   SSENSMI(1),89(R3)   GET SSENSMI FROM RPL\nIFPATH   TESTCB AM=VTAM,RPL=(R3),SSENSEI=PATH     IF PATH ERR ?\n         BNE   IFCPM\n         LTR   R15,R15\n         BNZ   ENDTSTCB\n         MVI   SSENSEI,X'80'        SET PATH ERROR FLAG.\n         B     ENDTSTCB\nIFCPM    LTR   R15,R15\n         BNZ   ENDTSTCB\n         TESTCB AM=VTAM,RPL=(R3),SSENSEI=CPM    IF CPM ERROR ?\n         BNE   IFSTATE\n         LTR   R15,R15\n         BNZ   ENDTSTCB\n         MVI   SSENSEI,X'40'        SET CPM ERROR FLAG.\n         B     ENDTSTCB\nIFSTATE  LTR   R15,R15\n         BNZ   ENDTSTCB\n         TESTCB AM=VTAM,RPL=(R3),SSENSEI=STATE  IF STATE ERROR\n         BNE   IFFI\n         LTR   R15,R15\n         BNZ   ENDTSTCB\n         MVI   SSENSEI,X'20'        SET STATE ERROR FLAG.\n         B     ENDTSTCB\nIFFI     LTR   R15,R15\n         BNZ   ENDTSTCB\n         TESTCB AM=VTAM,RPL=(R3),SSENSEI=FI      IF RH ERROR ?\n         BNE   IFRR\n         LTR   R15,R15\n         BNZ   ENDTSTCB\n         MVI   SSENSEI,X'10'        SET FI ERROR FLAG.\n         B     ENDTSTCB\nIFRR     LTR   R15,R15\n         BNZ   ENDTSTCB\n         TESTCB AM=VTAM,RPL=(R3),SSENSEI=RR      IF REQ REJECT ?\n         BNE   ENDTSTCB\n         LTR   R15,R15\n         BNZ   ENDTSTCB\n         MVI   SSENSEI,X'08'        SET RR ERROR FLAG.\nENDTSTCB EQU   *\n         MVC   LINE(11),=C'++RTMCOLT++'\n         MVC   LINE+11(8),0(R10)\n         MVC   LINE+20(25),ERRMSG\n         ST    R15,WORKF\n         MVC   LINE+45(4),=C'R15='\n         MVC   LINE+49(4),WORKF\n         SHOWCB ACB=VSAMIN,AREA=WORKF,LENGTH=4,FIELDS=ERROR\n         MVC   LINE+53(9),=C'VSAMCODE='        ACB CODE /RPL FDBK\n         MVC   LINE+62(4),WORKF\n         MVC   LINE+66(8),=C'SNACODE='        ACB CODE /RPL FDBK\n         MVC   LINE+74(2),SENSCD\n         PUT   PRINT,LINE\n         MVC   WTOMSG+4(80),LINE\n         WTO   MF=(E,WTOMSG)\n         MVI   LINE,C' '\n         MVC   LINE+1(131),LINE\n         CLI   SENDSW,X'FF'                 IF CONTINUE PROCESSING\n         BE    NEXTPU\n         CLOSE (VSAMIN,,RTMACB,,PRINT)\n         L       13,SAVEREG+4\n         RETURN (14,12),RC=16\nEOJ      DS    0H\n         CLOSE (VSAMIN,,RTMACB,,PRINT)\n         L       13,SAVEREG+4\n         RETURN (14,12),RC=0\nSAVEREG  DS    18F\nWORKD    DS    D\nWORKF    DS    F\nWORKH    DS    H\nECB1     DS    F\nYYDDDF   DS    D\nTOD      DS    0CL8\nHH       DS    CL2\nMM       DS    CL2\nSS       DS    CL2\nSENSCD   DS    0CL2\nSSENSEI  DC    X'00'\nSSENSMI  DC    X'00'\nRTMREQ   DS    0CL44\nFWDRU1   DC    X'81081000'                   FORWARD RU HEADER\nFWDRU2   DC    X'0000'                       EMBEDDED NS RU STATE\nFWDRU3   DC    X'0010'          (16):  0     EMBEDDED NS RU LENGTH\nCNMHDR   DC    X'41038D0000000000'    (8)    CNM HEADER\nCNMVTLEN DC    X'0008'                (2)    REMAIN RU LENGTH(INCLUDE)\nCNMVTKEY DC    X'8080'                (2)    RTM REQUEST CNTL VECT\nRTMREQV  DC    X'0492C000'      (04): (4)    RTM REQEST SUB-VECTOR(92)\nDSTTYPE  DC    X'F1'                         DESTINATION PU\nDSTLEN   DC    X'08'                         DESTINATION LENGTH\nDSTNAME  DC    C'PU//    '                   DESTINATION NAME\nTAGTYPE  DC    X'F1'                         TARGET  RESOURCE TYPE\nTAGLEN   DC    X'08'                         TARGET  RESOURCE LENGTH\nTAGNAME  DC    C'PU//    '                   TARGET  RESOURCE NAME\nRTMDATA  DC    200X'00'\nLINE     DC    132C' '\nERRMSG   DC    25C' '\nDATE     DS    CL6\n         DS    0H\nVSAMARG  DS    0CL16            KEY LENGTH 16\nARGDATE  DS    CL6\nARGHH    DC    C'00'\nARGPU    DS    CL8\nSENDSW   DC    X'00'\nLASTSW   DC    X'00'\nLENGTH   DC    H'0'\nWTOMSG   WTO   '1234567891123456789212345678931234567894123456789512345X\n               6789612345678971234567890',MF=L\nDATETAB  DS    0H\n         DC    C'01',PL2'000',C'02',PL2'031',C'03',PL2'059'\n         DC    C'04',PL2'090',C'05',PL2'120',C'06',PL2'151'\n         DC    C'07',PL2'181',C'08',PL2'212',C'09',PL2'243'\n         DC    C'10',PL2'273',C'11',PL2'304',C'12',PL2'334'\nPUNAME   DS    0H                BY PU NAME ASCENDING KEY\n         DC    C'LCLPU01 LCLPU02 LCLPU03 '                      LOCAL\n         DC    C'LCLPU04 LCLPU05 LCLPU06 '\n         DC    C'LCLPU07 LCLPU08 '\n         DC    C'LCLPU09 '\n         DC    C'************************'\n         DS    0F\nA99CNM   DC    X'06'\n         DC    C'A99CNM'\n         LTORG\nSNAPDUMP DCB   DSORG=PS,DDNAME=SNAPDUMP,MACRF=W,RECFM=VBA,             *\n               LRECL=125,BLKSIZE=882\nRTMACB   ACB   AM=VTAM,APPLID=A99CNM,MACRF=NLOGON,PARMS=(NIB=RTMNIB)\nRTMRPL   RPL   AM=VTAM,ACB=RTMACB\nRTMNIB   NIB   MODE=RECORD,LISTEND=YES,SDT=SYSTEM,ENCR=NONE,           *\n               LOGMODE=0,BNDAREA=0\nVSAMIN   ACB   AM=VSAM,MACRF=(KEY,DIR,OUT)\nVSAMRPL  RPL   AM=VSAM,ACB=VSAMIN,OPTCD=(KEY,DIR,KEQ,MVE)\nPRINT    DCB   DDNAME=PRINT,DSORG=PS,MACRF=PM,RECFM=F,BLKSIZE=132\nVSAMREC  DSECT\n         DS    0F\n         DS    0CL1233\nVSAMKEY  DS    0CL16              KEY\nVSAMDATE DS    CL6\nVSAMHH   DS    CL2\nVSAMPU   DS    CL8                    PU 8 BYTE\nVSAMCTR  DS    CL2                OCCURRENCE COUNTER\nVSAMDATA DS    0CL1215            45 TIMES\nVSAMLU   DS    CL2\nVSAMCNT  DS    5PL5\nVSAMOCCR DS    44CL27\n         END\n\n\n                                                               c Reserved 1991\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N001A03": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00J\\x00J\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 74, "newlines": 74, "modlines": 0, "user": "SNAUPDT"}, "text": "NCCF CLIST for switched off controllers\n\nUsers on an SNA line on a 3725 controller with NCP\nexperienced slow response when any of the controllers on the\nline were switched off.  These switched-off controllers were\nminis or micros emulating 3274s.  A VTAM display on such a\nline would show status PCTD2 for a switched-off controller.\n\nAn NCCF CLIST was written to periodically check the line,\nvary off-line any controller with status PCTD2, and vary on-\nline any controller which had been switched on.\n\nThe CLIST loops for every controller which is likely to be\nturned off.  IST486I is the status line from a display command.\nIf ACTIV, it gets out of the loop; if PCTD2, it varies the\ncontroller off-line; otherwise it varies it on-line and checks\nwhether the controller has been switched on recently.  The\ncount loop gives extra time if 'pending connect'.  Another\ndisplay must give an active status or it is varied off-line.  The\nCLIST starts itself some time later.\n\nPENDINGS CLIST\n         &CONTROL ERR\n         AUTOWRAP FULL\n         CLEAR\n         PURGE TIMER=PENDERS\n         &PU1 = P02007A\n         &PU2 = P02007C\n         &PU3 = P02007D\n         &PU4 = P02007E\n         &PU5 = P02007F\n         &PU6 = P02007J\n         &PU7 = P02007G\n         &PU8 = P02007H\n         &PU9 = P02007I\n         &MAXPU = 9\n         &NO  = 1\n-LOOP    &PUNIT = &PU&NO\n         &WAIT 'D NET,ID=&PUNIT',IST486I=-FIRSTD\n         &EXIT\n-FIRSTD  CLEAR\n         &IF &5 EQ ACTIV &THEN &GOTO -LOOPEND\n         &IF &5 EQ PDISC &THEN &GOTO -LOOPEND\n         &IF &5 EQ PCTD2 &THEN &GOTO -VAROFF\n         &IF &5 EQ IINOP &THEN &GOTO -VARON\n         &IF &5 EQ INACT &THEN &GOTO -VARON\n         &IF &5 EQ NEVAC &THEN &GOTO -VARON\n         &IF &5 EQ PCON2 &THEN &GOTO -VARON\n         &WRITE COULD NOT RESOLVE STATUS OF IFS. &5 NOT FOUND\n         &EXIT\n-VARON   &WAIT 'V NET,ACT,SCOPE=ALL,ID=&PUNIT',IST093I=-FIRSTVA,+\n                                               *10=-FIRSTVA\n         &EXIT\n-FIRSTVA &COUNT = 0\n-COLOOP  &IF &COUNT GT 10 &THEN &GOTO -VAROFF\n         &WAIT 'D NET,ID=&PUNIT',IST486I=-SECNDD\n         &EXIT\n-SECNDD  &COUNT = &COUNT + 1\n         &IF &5 EQ PCON2 &THEN &GOTO -COLOOP\n         &IF &5 EQ ACTIV &THEN &GOTO -LOOPEND\n-VAROFF  &WAIT 'V NET,INACT,ID=&PUNIT',IST105I=-LOOPEND\n         &EXIT\n-LOOPEND CLEAR\n         &NO = &NO + 1\n         &IF &NO LE &MAXPU &THEN &GOTO -LOOP\n         EVERY 5,ID=PENDERS,PENDINGS\n         AUTOWRAP NO\n         &EXIT 4\n\n\nDerek Davidson\nSystems Programmer\nProvince of New Brunswick (Canada)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N001A04": {"ttr": 770, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\xf5\\x00\\xf5\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 245, "newlines": 245, "modlines": 0, "user": "SNAUPDT"}, "text": "CA-ACF2 expired password exit\n\nOne of the complaints we have had from staff who use the\nmultiple session capability of NetMaster is that CA-ACF2 will\noften expire their password during a multiple application\nsession.  This is because CA-ACF2 uses the time as well as the\ndate when calculating whether a password should expire.\n\nIf the user then attempts to log on to another VTAM\napplication after CA-ACF2 has expired their password,\nNetMaster enters an expired password and they are prompted\nfor a new password.  Once they have done this, the password\nbeing held internally by NetMaster is invalid.  Any further log-\nons to other applications will submit what is now an invalid\npassword and CA-ACF2 will return with an invalid password\nerror.\n\nTo overcome this problem we considered two alternatives :\n\n1       Rewrite the log-on security exit for NetMaster.\n\n2       Implement a CA-ACF2 expired password exit to\n       temporarily circumvent password expiration.\n\nWe decided on the second approach as we were more familiar\nwith this type of exit.  We hope to eventually have a security\nvalidation exit which uses CA-ACF2 log-on inheritance but\nhave postponed writing one in the hope that the supplier of\nNetMaster provides such a facility with later releases of its\nsoftware.  We believe that this type of CA-ACF2 exit could be\napplicable to any multiple application interface.\n\nOur CA-ACF2 expired password exit examines the date in the\nLIDPSTOD field, adds the MAXDAYS value, and compares\nthe result to today's date.  Unless today's date is greater than\nthe result, the exit allows the user to sign on without expiring\nhis or her password.  This will usually ensure that a user's\npassword will only expire on the first sign-on attempt of the\nday following the day upon which CA-ACF2 would normally\nexpire the password.  This normally means that users will be\nforced to change their password when they sign onto NetMaster\n(or some other appropriate multiple application software) first\nthing the following morning rather than in the middle of a\ncurrent session.\n\nThe one problem we have found with this exit is that CA-ACF2\nwill warn the user in advance that their password is going to\nexpire for the number of days specified by 'PASSWORD\nWARN DAYS', but when the exit is invoked to allow them to\nsign on despite having passed the expiration date and time, the\npassword expiration warning is no longer issued.  This can be a\nbit confusing to some users but we find that the great majority\nof users ignore these expiration warnings anyway.\n\nThis exit also does some special processing for user-ids that\nbegin with the letters GRP so that they can never be expired\nexcept by a security administrator (see the section of code\nbeginning with the label CONTINUE) but I have commented\nthis code out as it is not required for the other processing.\n\nACF2     TITLE 'EXPIRED PASSWORD EXIT'\n\n***********************************************************************\n*        MODULE NAME = CSP556                                         *\n*        DESCRIPTIVE NAME = ACF2 EXPIRED PASSWORD EXIT                *\n*        FUNCTION  = STOP LOGONIDS EXPIRING UNLESS IT IS THE FIRST    *\n*                    LOGON OF THE DAY FOLLOWING NORMAL EXPIRATION.    *\n*                    THIS IS DONE TO AVOID MOST INCIDENTS OF          *\n*                    LOGONIDS EXPIRING AFTER A USER HAS SIGNED        *\n*                    ON TO NETMASTER BUT BEFORE LOGGING ON TO OTHER   *\n*                    ACF2 CONTROLLED APPLICATIONS FORCING THEM TO     *\n*                    GET OUT OF NETMASTER AND LOG BACK ON.            *\n*        OPERATION = THE EXIT GAINS CONTROL FROM ACF2 WHEN A          *\n*                    PASSWORD EXPIRES. THIS EXIT COMPARES TODAYS      *\n*                    DATE TO THE DATE FROM THE LIDPSTOD PLUS THE      *\n*                    VALUE FROM MAXDAYS AND IF TODAY IS GREATER,      *\n*                    ALLOWS THE PASSWORD TO EXPIRE. OTHERWISE,        *\n*                    IT SIMPLY LOGS THE USER ON AND WILL NOT FORCE    *\n*                    THE USER TO CHANGE THEIR PASSWORD UNTIL THEIR    *\n*                    FIRST SIGN ON OF THE FOLLOWING DAY.              *\n*                    HOPEFULLY THIS WILL MEAN THAT ALL PASSWORDS      *\n*                    WILL BE FORCED TO EXPIRE WHEN THE USER SIGNS ON  *\n*                    TO NETMASTER FIRST THING THE NEXT MORNING.       *\n*                    THE EXIT WILL BYPASS THIS CHECKING               *\n*                    IF THE LID HAS BEEN MANUALLY EXPIRED.            *\n*                    THIS EXIT ALSO ENSURES THAT GRP USERS CANNOT     *\n*                    BE EXPIRED AS THESE USERS CANNOT CHANGE THEIR    *\n*                    PASSWORDS.                                       *\n*        REGISTER CONVENTIONS = STANDARD CONVENTIONS.                 *\n*           REGISTER  0 = NOT USED                                    *\n*           REGISTER  1 = POINTER TO PARAMETER LIST                   *\n*           REGISTER  2 = ADDRESS OF LIDLID FIELD IN LID RECORD       *\n*           REGISTER  3 = ADDRESS OF LID RECORD                       *\n*           REGISTER  4 = ADDRESS OF ACVALD CONTROL BLOCK             *\n*           REGISTER  5 = WORK REGISTER                               *\n*           REGISTER  6 = WORK REGISTER                               *\n*           REGISTER  7 = WORK REGISTER                               *\n*           REGISTER  8 = WORK REGISTER                               *\n*           REGISTER  9 = WORK REGISTER                               *\n*           REGISTER 10 = RETURN CODE AND WORK REGISTER               *\n*           REGISTER 11 = POINTER TO PARM LIST AFTER ENTRY            *\n*           REGISTER 12 = BASE REGISTER                               *\n*           REGISTER 13 = SAVE AREA POINTER                           *\n*           REGISTER 14 = RETURN ADDRESS                              *\n*           REGISTER 15 = ENTRY POINT ADDRESS                         *\n*        MODULE TYPE = EXIT                                           *\n*               PROCESSOR = ASM                                       *\n*               ATTRIBUTES = RENT, KEY 0, STEP-MUST-COMPLETE          *\n*        ENTRY POINTS = CSP556                                        *\n*               LINKAGE FROM = ACF2                                   *\n*        INPUT = REG 1 POINTS TO STANDARD PARAMETER LIST              *\n*                (SEE DOCUMENTATION IN ACF2 SYSTEM PROGRAMMER'S       *\n*                 GUIDE)                                              *\n*        OUTPUT = NONE                                                *\n*        EXIT - RETURN CODE = 0 - PASSWORD IS EXPIRED                 *\n*             - RETURN CODE = 4 - PASSWORD NOT EXPIRED, LOGON PROCEEDS*\n*        EXTERNAL REFERENCES = NONE                                   *\n*        MACROS USED =                                                *\n*                  ACVALD          ACF2.ACFMAC                        *\n*                  ACFREGS         ACF2.ACFMAC                        *\n*                  LIDREC          ACF2.ACFMAC                        *\n*        ABEND CODES = NONE                                           *\n***********************************************************************\n         TITLE 'DATA AREAS AND DSECTS'\nWORKAREA DSECT\nSAVEAREA DS    9D                           REGISTER SAVE AREA\nDIV      DS    D                            DIVIDEND\nDATE     DS    D                            DATE STORAGE\nREGS     DS    6F                           SAVE IMPORTANT REGS\n         ORG   REGS\nREG2     DS    F\nREG3     DS    F\nREG4     DS    F\nREG5     DS    F\nREG6     DS    F\nREG7     DS    F\nWORKLEN  EQU   *-WORKAREA\n         LIDREC DSECT=YES\n         ACVALD DSECT=YES\n         ACFREGS\nCSP556   CSECT\n         SAVE  (14,12),,CSP556-&SYSDATE-&SYSTIME\n         USING CSP556,R12              CSECT ADDRESSABILITY\n         LR    R12,R15                 LOAD BASE REGISTER\n         LR    R11,R1                  SAVE PARM LIST ADDR\n         GETMAIN RU,LV=WORKLEN         GETMAIN STORAGE\n         ST    R13,4(R1)               SAVE AREA CHAIN\n         ST    R1,8(R13)               STORE SAVE AREA ADDR\n         LR    R13,R1                  SET UP OUR SAVE AREA\n         USING WORKAREA,R13\n*        GET ADDRESSABILITY TO ACF2 CONTROL BLOCKS\n         L     R4,0(,R11)              LOAD PARM LIST ADDRESS\n         USING ACVALD,R4               ADDRESSABILITY TO ACVALD\n*        FIND OUT IF A 'GRP' USER\nCONTINUE DS    0H\n         L     R3,4(,R11)              LOAD LID RECORD ADDRESS\n         USING LIDREC,R3               ADDRESSABILITY FOR LID\n         LA    R2,LIDLID               POINT TO LID\n*        CLC   0(3,R2),GRP             IS THIS 'GRP' USER ?\n*        BNE   CHKEXPIR                NO, SO CHECK MANUALLY EXPIRED\n*        NI    LIDM2FLG,X'FE'          YES, SO SET TO NOT-EXPIRED\n*        NI    LIDNDAYS,X'00'          AND SET MAXDAYS TO ZERO\n*        LA    R10,4(0,0)              SET RETURN CODE 4 - NO EXPIRE\n*        B     RETURN                  AND GET OUT\n*        CHECK TO SEE IF USERID WAS MANUALLY EXPIRED\nCHKEXPIR DS    0H\n         TM    LIDM2FLG,LIDM2PXP       IS THIS LID MANUALLY EXPIRED ?\n         BNO   CHKPASSW                NO, SO CONTINUE\n         LA    R10,0                   YES, SO SET TO EXPIRE\n         B     RETURN                  AND GET OUT\n*        CHECK PASSWORD CHANGE DATE AND TIME\nCHKPASSW DS    0H\n         STM   R2,R7,REGS              STORE AWAY IMPORTANT REGS\n         LM    R4,R5,LIDPSTOD          LOAD PSWD CHANGE TOD\n         SRDL  R4,12(0)                SHIFT OUT THE SMALL AMOUNTS\n         D     R4,MICS                 DIVIDE TO GIVE MINUTES (IN R5)\n         LA    R4,0                    CLEAR REMAINDER\n         D     R4,MINS                 DIVIDE TO GIVE DAYS (IN R5)\n         LA    R8,0                    CLEAR R8\n         IC    R8,LIDNDAYS             GET MAXDAYS FROM LID\n         AR    R8,R5                   ADD MAXDAYS TO LIDPSTOD DAYS\n         LA    R9,0                    LOAD R9 WITH ZEROES\n         LA    R10,0                   LOAD R10 WITH ZEROES\n         STM   R9,R10,DIV              ENSURE DIV IS SET TO ZERO\n         STM   R9,R10,DATE             ENSURE DATE IS SET TO ZERO\n         LA    R9,1(0,0)               LOAD R9 WITH ONE FOR LATER\n         TIME  DEC                     GET TODAYS TOD\n         ST    R1,DATE+4               STORE IT IN DATE FIELD\n         DP    DATE,THOU               SEPARATE YEAR AND DAY\n         MVC   DIV+4,DATE              MOVE YEAR INTO DIVIDEND\n         LA    R4,0                    LOAD R4 WITH ZERO\n         CVB   R5,DIV                  CONVERT YEAR TO BINARY\n         LTR   R5,R5                   IS YEAR ZERO\n         BNZ   DIVIDE                  NO, SO DIVIDE AWAY\n         LA    R5,0                    YES, SO SET R5 TO ZERO\n         B     DAYSONLY                AND CALCULATE DAYS ONLY\nDIVIDE   DS    0H\n         D     R4,FOUR                 DIVIDE YEAR BY FOUR\n         LA    R6,0                    LOAD R6 WITH ZERO\n         LR    R7,R5                   LOAD R7 WITH QUOTIENT\n         M     R6,YEAR4                MULTIPLY RESULT BY (365*4)\n         LA    R2,0                    LOAD R2 WITH ZERO\n         LR    R3,R4                   LOAD R3 WITH REMAINDER YRS\n         LTR   R3,R3                   IS REMAINDER ZERO\n         BNZ   LEAP                    NO, SO CONTINUE\n         SR    R5,R9                   YES, SO NO LEAP THIS YEAR\nLEAP     DS    0H\n         M     R2,YEAR                 MULTIPLY REMAIN TO GET DAYS\n         AR    R7,R3                   ADD DAYS REMAIN TO TOTAL\n         AR    R5,R7                   ADD DAYS FOR LEAP YEARS\nDAYSONLY DS    0H\n         LA    R1,0                    LOAD R1 WITH ZERO\n         ST    R1,DATE                 CLEAR OUT YEARS\n         CVB   R4,DATE                 CONVERT DAYS INTO R4\n         SR    R4,R9                   SUBTRACT 1 FROM NO. OF DAYS\n         AR    R5,R4                   TOTAL WHOLE DAYS FROM 1900\n         CLR   R5,R8                   COMPARE TODAY WITH LIDPSTOD DAYS\n         BH    EXPOKAY                 TODAY HIGH SO EXPIRE\n         LA    R10,4(0,0)              SET RETURN CODE TO 4 - NO EXPIRE\n         B     RETURN                  GET OUT\nEXPOKAY  DS    0H\n         LA    R10,0                   EXPIRE NORMALLY\n         B     RETURN                  GET OUT\n*        RETURN\nRETURN   DS    0H\n         LR    R1,R13                  UNCHAIN SAVE AREAS\n         L     R13,4(R13)\n         FREEMAIN RU,LV=WORKLEN,A=(1)  FREE STORAGE\n         LR    R15,R10                 SET RETURN CODE INTO R15\n         RETURN (14,12),RC=(15)        GET OUT\n*        CONSTANTS.\n         DS    0F\nFOUR     DC    F'4'                         FOUR\nYEAR     DC    F'365'                       365 DAYS PER YEAR\nTHOU     DC    PL4'+1000'                   ONE THOUSAND AS PACKED\nYEAR4    DC    F'1460'                      365 DAYS * 4 YEARS\nMINS     DC    F'1440'                      MINUTES IN A DAY\nMICS     DC    F'60000000'                  MICROSECS IN A MINUTE\nGRP      DC    C'GRP'\n         END   CSP556\n\n\nDavid McGeorge\nConsultant Systems Programmer (Australia)              cDavid McGeorge 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N001A05": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\x8e\\x00\\x8e\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 142, "newlines": 142, "modlines": 0, "user": "SNAUPDT"}, "text": "A VTAM Secondary Program Operator program\n\nHow many times have you wanted to know the session load of\nthe particular applications in your shop, or  know the\navailability of certain VTAM resources (such as the number of\nunused connections on a 7171 or the status of your NJE SNA\nlinks), or get information from VTAM which didn't spew\nacross the system console and didn't disappear as fast as the\nconsole could scroll?\n\nThe VTAM Command Facility (VCF) solves all of these\nproblems.  VCF is a VTAM Secondary Program Operator\n(SPO) program which can take a command (such as 'D\nNET,ID=LINEXX'), pass it to VTAM, and receive the results,\ndisplaying them on your terminal or storing them in a file.\n\nVTAM SPOs have several desirable characteristics:\n\n1       Their command output will not clutter the console.\n\n2       The console's scrolling activity will not affect the\n       command output.\n\n3       Other VTAM command activity output will not be affected\n       (in contrast to the effect of a Primary Program Operator\n       program, which captures all VTAM messages).\n\nThe VTAM Customization manual, for Version 3 Releases 1,\n1.1, 1.2, and 2, Appendix E, Program Operator Coding\nRequirements, details how you can write a Program Operator.\n\nWhile the program here takes the command from the PARM\npassed to it, it is a trivial matter to read a series of commands\nfrom an input file.  All VTAM commands can be executed by\nVCF except the 'Z NET' command - VTAM will refuse to\nissue this command when it comes from a Program Operator\nprogram.\n\n\nVCF SOURCE CODE\n\n***PROGRAM: VCF (VTAM COMMAND FACILITY)\n*  THIS PROGRAM IS A VTAM SECONDARY PROGRAM OPERATOR (SPO).  IT\n*  ALLOWS YOU TO ISSUE VTAM COMMANDS AND TO DISPLAY THE RESULTS WITHOUT\n*  CLUTTERING THE OPERATORS SCREEN, OR TO SAVE THE RESULTS IN A FILE,\n*  ALLOWING FOR A MORE LEISURELY EXAMINATION OF THE RESULTS.\n*  YOU MUST ALLOCATE THE FILE \"RESULTS\" BEFORE RUNNING THIS PROGRAM.\n*  YOU MUST ALSO DEFINE AN APPLID WHICH THE PROGRAM WILL USE:\n*            VBUILD TYPE=APPL\n*    XXXXACB  APPL   EAS=0,AUTH=(SPO)\n*  YOU CAN ALSO DEFINE MULTIPLE APPLIDS AND HAVE THE PROGRAM PICK ONE\n*  (BASED ON TSO USER ID, FOR INSTANCE).  THIS WOULD ALLOW FOR\n***SIMULTANEOUS USAGE BY DIFFERENT PEOPLE.\n*  VTAM COMMAND FACILITY--START\nVCF      CSECT\n         STM   R14,R12,12(R13)         ADDRESSABILITY\n         LR    R12,R15\n         USING VCF,R12\n         LA    R11,SAVE\n         ST    R11,8(R13)\n         ST    R13,4(R11)\n         LR    R13,R11\n         LA    R11,NETRES              POINT AT RESULT AREA\n         USING ISTDPOHD,R11            DSECT FOR CONTROL BYTES\n         L     R1,0(R1)                GET POINTER TO PARM\n         LH    R3,0(R1)                GET PARM LENGTH\n         LTR   R3,R3                   TEST LENGTH\n         BNZ   GETCMD                  B IF LENGTH > 0\n         LA    R15,4                   NO PARM--EXIT WITH RC=4\n         B     EXIT2\nGETCMD   MVC   NETCMD2(100),BLANKS     CLEAR COMMAND BUFFER\n         BCTR  R3,R0                   DECREMENT FOR EX INSTRUCTION\n         EX    R3,MOVCMD               MOVE THE COMMAND\n         LA    R3,5(R3)                INC AFTR EX & ADD FOR 4 HDR BYTS\n*  OPEN SEQUENTIAL OUTPUT FILE AND VTAM ACB\nOPENNET  OPEN  ACB1\n         LTR   R15,R15\n         BZ    OPENFILE\n         LA    R15,12\n         B     EXIT2\nOPENFILE OPEN  (RESULTS,OUTPUT)\n*  SEND COMMAND TO VTAM\nSENDCMD1 SENDCMD RPL=RPL1,AREA=NETCMD,RECLEN=(R3),OPTCD=SYN\n         LTR   R15,R15\n         BZ    RECVCMD1                 B IF COMMAND SENT OK\n         LA    R15,16                   ELSE SET RC=16 AND EXIT\n         B     ENDNET\n*  RECEIVE A LINE OF OUTPUT FROM VTAM\nRECVCMD1 RCVCMD RPL=RPL1,AREA=NETRES,AREALEN=NETRESL,OPTCD=(SYN,TRUNC)\n         LTR   R15,R15\n         BZ    CHECKRES                 BRANCH IF WE RECEIVED A LINE\n         LA    R15,20                   ELSE SET RC=20 AND EXIT\n         B     ENDNET\n*  PERFORM COMMAND ANALYSIS\nCHECKRES PUT   RESULTS,NETRES+4         WRITE OUTPUT TO FILE\n         MVC   NETRES+11(119),BLANKS    BLANK OUT VTAM RESULT TEXT\n         TM    POHSTAT,POHEND           END LINE OF A MULTI-LINE MSG?\n         BO    ENDNET                   IF SO, EXIT\n         TM    POHSTAT,POHDATA          DATA LINE OF A MULTI-LINE MSG?\n         BO    RECVCMD1                 IF SO, CONTINUE GETTING DATA\n         TM    POHSTAT,POHLBL           LABEL LINE OF A MULTI-LINE MSG?\n         BO    RECVCMD1                 IF SO, CONTINUE GETTING DATA\n         TM    POHSTAT,POHCNTRL         CNTRL LINE OF A MULTI-LINE MSG?\n         BO    RECVCMD1                 IF SO, CONTINUE GETTING DATA\n         CLC   NETRES+4(7),=CL7'IST097I'  IS THIS AN IST097I MSG?\n         BE    RECVCMD1                   IF SO, IS PART OF ML MSG\n         B     ENDNET                     EXIT\n*  CLOSE THE ACB\nENDNET   CLOSE ACB1\n*  CLOSE RESULTS FILE AND EXIT\nEXIT1    CLOSE (RESULTS)\n         SR    R15,R15\nEXIT2    L     R13,4(R13)\n         LM    R0,R12,20(R13)\n         L     R14,12(R13)\n         BR    R14\n*  RESULTS FILE DEFINITION\nRESULTS  DCB   DDNAME=RESULTS,LRECL=126,BLKSIZE=126,RECFM=F,           X\n               MACRF=PM,DSORG=PS\nBLANKS   DC    CL130' '\n*  COMMAND TO BE SENT TO VTAM\nNETCMD   DC    X'00030000'            COMMAND HEADER\nNETCMD2  DS    CL100                  COMMAND\nNETCMDL  EQU   *-NETCMD\nNETRES   DS    CL130                  RESULT AREA\nNETRESL  EQU   *-NETRES\nRPL1     RPL   AM=VTAM,ACB=ACB1,OPTCD=SYN\nACB1     ACB   AM=VTAM,APPLID=PGMNAME,MACRF=NLOGON\n*  APPLID AREA\nPGMNAME  DC    XL1'08'\n         DC    CL8'XXXXACB '           <==REPLACE THIS WITH YOUR APPLID\nSAVE     DS    18F                     SAVE AREA\nMOVCMD   MVC   NETCMD2(0),2(R1)        MOVE PARM STRING TO COMMAND AREA\n         LTORG\n         ISTDPOHD\n         END\n\n\nDavid Saunders\nSenior Computer Systems Engineer\nUniversity of Virginia (USA)                     c University of Virginia 1991\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N001A06": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x01\\x01\\x16\\x05O\\x01\\x16\\x06/\\x12D\\x03\\x11\\x03\\x11\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T12:44:01", "lines": 785, "newlines": 785, "modlines": 0, "user": "SNAUPDT"}, "text": "Using printers in SNA\n\nThe purpose of this article is to give a clearer understanding of\nthe way printers are handled in an SNA environment and to\nassist in the development of applications to drive printers.\nSNA printer session types and protocols will be explained and\ndetails will be given of how the increasingly sophisticated\nprinter capabilities can be invoked using the Function\nManagement (FM) protocols defined by SNA.  Finally, advice\nwill be given on coping with printer problems.\n\nA printer can be defined to SNA as one of the following LU\ntypes:\n\no       LU type 0 - session protocol and printer control must be\n       agreed between the printer and the application.  There are\n       no SNA functions defined.  LU 0 is employed in SNA\n       JES2 remote printer sessions where printer control is ANSI.\n\no       LU type 1 - using SNA Character String (SCS) and SNA\n       protocol defined for a printer device (eg 3286).\n\no       LU type 3 - using 3270 data stream and SNA protocol\n       defined for a printer (eg 3287).\n\no       LU type 4 - using SCS and SNA protocol defined for a\n       printer device attached to an SNA batch LU (eg a 3770\n       RJE workstation).\n\nWe will concern ourselves primarily with LU types 1 and 3.\nTypically these will be printers attached to a cluster controller\n(eg 3174/3274).\n\n\nHOST APPLICATION PRINTER HANDLING\n\nTo establish an SNA LU session and allow data to flow, a\nprinter must first be logged on to a host application.  This can\nbe achieved in several ways:\n\n%      By being attached to a batch LU which can generate the\n       log-on request.\n\no       By an SSCP-generated log-on (V NET,LOGON=applid, ID=printer).\n\no       By VTAM configuration activation processing\n       (LOGAPPL= applid specified on the printer network\n       definition LU statement).\n\no       A host application simulating a log-on by issuing a\n       SIMLOGON request.\n\nUse of SIMLOGON is the most common method used to\nestablish a session with a printer.  An outline of the coding\nnecessary to achieve this is as follows:\n\n< Mainline code entry protocol>\n           .\n         OPEN  APPLACB                                               <note 1>\n         SETLOGON RPL=APPLRPL,ACB=APPLACB,OPTCD=START                     <2>\n           .\n         SIMLOGON RPL=LOGONRPL,ACB=APPLACB,NIB=APPLNIB,OPTCD=SYN          <3>\n         TESTCB AM=VTAM,NIB=APPLNIB,CON=YES                               <7>\n         LTR   R15,R15\n         BNZ   <error processing>\n         INQUIRE RPL=LOGONRPL,NIB=APPLNIB,OPTCD=SESSPARMS,             C  <8>\n               AREA=SESSPRMS\n         LA    6,SESSPRMS\n         USING ISTDBIND,6\n           .\n\nAPPLACB  ACB    AM=VTAM,APPLID=APPLID,EXLST=APPLIST,MACRF=LOGON\nAPPLID   DC     X'06',C'APPLID'\nAPPLIST  EXLST  AM=VTAM,LOGON=LOGONXIT\nAPPLRPL  RPL    AM=VTAM\nLOGONRPL RPL    AM=VTAM\nAPPLNIB  NIB    NAME=PRINTER1,LOGMODE=0,BNDAREA=0,LISTEND=YES\nSESSPRMS DS     100C\n           .\n         ISTDBIND\n\n         CSECT ,\nLOGONXIT DS    0H\n   < entry protocol >\n         L     2,=A(LOGONRPL)                                             <5>\n         L     3,=A(APPLNIB)\n         OPNDST RPL=(2),OPTCD=(SYN,ACCEPT,CA),NIB=(3)                     <4>\n         LTR   15,15\n         BNZ   LOGONERR\n   < exit protocol >\n         BR    14\nLOGONERR DS    0H\n   < flag mainline code >                                                  <6>\n   < exit protocol >\n         BR    14\n\n\nNotes\n\nThe following notes refer to the statements flagged in the above\nsample code.\n\n1       A VTAM major node containing a definition for the\n       application ACB must be active, for example:\n\n               VBUILD TYPE=APPL\n       APPLACB APPL  ACB=APPLACB,AUTH=(ACQ,PASS)\n\n       The AUTH parameters specify the application is able to\n       ACQUIRE printers and PASS them on to other applications.\n\n2       The ACB specifies MACRF=LOGON, which means that\n       the application is prepared to accept log-on requests, the\n       SETLOGON tells VTAM that the application is now ready\n       to handle such requests.\n\n3       The application requests a session with the printer whose\n       network name (VTAM-id) is specified in the NIB (ie\n       NAME=PRINTER1).  An INITIATE is sent to the SSCP\n       owning PRINTER1 and the SSCP generates a CINIT\n       which drives the application log-on exit LOGONXIT.\n       Coding OPTCD=SYN will cause the APPL to wait until\n       the SIMLOGON has completed (ie the log-on exit has\n       finished).  VTAM will POST an ECB in the RPL specified\n       by the SIMLOGON (LOGONRPL).\n\n4       Results in a BIND request followed by an SDT, VTAM\n       sends a +RESP (positive response) to both of these on\n       behalf of the printer.  The NIB addressed by the OPNDST\n       specifies LOGMODE=0 and BNDAREA=0 - VTAM will\n       use the defaults supplied in the CINIT RU resulting from\n       the SIMLOGON.  The session parameters cannot be\n       changed because the BIND is not negotiable for printers.\n\n5       VTAM uses SCHEDULE (SVC 6) to execute the\n        application log-on exit, therefore the register contents\n       cannot be assumed.  Addressability to the mainline code\n       must be re-established.\n\n6       Since the session establishment failed, CLSDST must not\n       be issued as this will cause a SYNAD error.  Mainline\n       code can be notified by flagging (or POSTing of an ECB).\n       Errors in the log-on exit may result in an LERAD error.\n\n7       The success of the OPNDST is checked by testing whether\n       the NIB CONnect field is set to YES\n       (NIBFLG1=NIBCON).\n\n8       VTAM copies the session parameters (ie BIND data) from\n       the CINIT RU to the area SESSPRMS, where they can be\n       examined using a standard mapping DSECT, ISTDBIND.\n\n\nPRINTER SESSION PROTOCOL\n\nProtocol rules governing the session between a host application\n(the PLU) and a printer (the SLU) are the same for both the\nLU1 and LU3 mode sessions.  Bracket protocol is used: the\nprinter begins the bracket (ie is the first speaker) but the\nbracket can only be terminated by the host application.\nWhether or not the application terminates a bracket depends\nupon whether the printer is either to be shared with another\napplication or used for local print requests.  An application can\nonly ACQUIRE a printer if the current owning application does\nnot have an open bracket.  Similarly, requests for local prints\ncan only be honoured if the printer has been configured in the\ncontroller as being shareable between brackets and the printer\ndoes not currently have an open bracket with an application.\nNote that for a local print operation it is not necessary for the\nhost session to be terminated, only the open bracket.  This is\nknown as 'between bracket sharing'.\n\nAs explained above, to request a session with a printer, a host\napplication must issue a SIMLOGON request.  VTAM will\ndetermine whether the printer is available and, if it is, drive the\napplication log-on exit.  If the printer is already in session with\nanother application and the requesting application issued\nSIMLOGON with OPTCD= (RELRQ,Q), VTAM will\nschedule the RELREQ exit (if supplied) of the other\napplication.  Assuming that a RELREQ exit was provided, this\nmust decide whether to release the printer or not, ie terminate\nthe bracket and issue a CLSDST OPTCD=PASS.  If the\nsession is continued, the SIMLOGON request is queued until\nsuch time as the printer becomes free.  The session request is\nsimilarly queued if no RELREQ exit was provided by the\napplication currently in session with the printer.\n\nPacing is the mechanism by which the rate of data flow to the\nprinter can be controlled.  Unconstrained, a printer could easily\nutilize most of the capacity of a line.  If the cluster controller to\nwhich the printer was attached also supported display\nterminals, the response time at these terminals would suffer\nnetwork delays.  Obviously this would not be a problem if the\nprinter were the only active device on the line or only printers\nwere attached to the cluster controller.  If the pacing counts are\nset to 1 in the SRCVPAC and PSNDPAC fields of the session\nBIND parameters, VTAM will pace the data flow such that:\n\no       Only one message from the controlling host application can\n       be queued ready for sending.\n\no       Further data will only be sent to the printer once the\n       previous data has been printed.\n\nIt is also possible to specify pacing for the data sent from a\nprinter to the host application (the SSNDPAC and PRCVPAC\nparameters) but the volume of this data (if any) will be very\nsmall.\n\nPRINTER FUNCTIONS\nUntil fairly recently printers in the SNA environment have been\ndumb devices capable only of accepting print streams with\nlimited control information (new line, carriage return etc).\nPrinters capable of supporting SNA sessions now have a full\nrange of print functions, including:\n\no       Colour support, normally four basic colours which can be\n       mixed to produce four more colours (eg cyan and yellow\n       makes green).\n\no       Graphics capabilities, including both graphs (eg pie charts\n       etc) and perspective view diagrams.\n\no       Variable fonts, subscripting, underlining, overprinting,\n       gothic script.\n\no       Variable print densities and qualities, the print CPI can be\n       altered to provide either fast draft quality or slow letter\n       quality.\n\no       Form control, stationery type changes etc.\n\no       Variable character sets, languages etc.\n\no       Data compression and compaction.\n\nPrinters have buffers capable of receiving fonts, characters\nsets, compression tables, etc downloaded from the host.  They\ncan also communicate back to the host the current status of\nthese buffers and the range of printer facilities available to the\nhost.\n\nThis capability is necessary to overcome the shortfall of\ninformation in the session BIND command, which simply\ndescribes the set of protocol rules to be used (ie contention\nrules, bracket protocol, request unit size, pacing, etc) and\npresentation services (ie stream type, screen size, etc).  No\ndetails are supplied in the BIND relating to the extended\nfunctions of the printer described above.\n\nSNA allows for the possibility of two-way communication\nbetween host and printer via an exchange of data at the\nFunction Management level and this capability has been\nimplemented in the IBM 4224 range of printers.\n\nTwo-way communication is achieved by an exchange of\nmessages containing data in a format understood by the printer\nto contain command codes.  These are termed 'structured data\nfields'.  A host application can send a message containing a\nQUERY code which requests information from the printer.\nInformation is returned via a message containing a QUERY\nREPLY code.\n\nIBM 4224 printers support two modes of operation:\n\no       LU type 1 mode       -       SNA Character Stream (SCS)\n                             -       Intelligent Printer Data Stream (IPDS).\n\no       LU type 3 mode       -       SNA Data Stream Emulation (DSE).\n\nFull function capabilities are available to a printer operating in\nLU 1 SCS mode.  While in this mode, FM Headers (FMHs)\ncan be used to describe and initiate print operations and as the\nmeans of host enquiries on the status and capability of a\nprinter.  A host application indicates to the printer that an FMH\nis contained in the Request Unit (RU) by setting the FMH flag\nin the SEND macro:\n\nSEND  RPL=rpl,OPTCD=(FMHDR)\n\nIt is the responsibility of the sending application to ensure that\nthe content and format of the message containing the FMH is\ncorrect.\n\n\nFUNCTION MANAGEMENT HEADERS\n\nTo indicate that FMHs are to be used, bit 1 in the BIND\nsession parameter's common protocol field (COMPROT) must\nbe set.  Which subset of FMHs is to be used, is specified in the\nsecond byte of the Presentation Services field (PSERVIC).\nWhich particular functions of the FMH subset are to be used,\nare specified in the FMH flags (bytes 3 and 4 of PSERVIC).\nFor printers, FMH subset flags can be set to indicate support\nfor the following:\n\no       Structured data fields\n\no       Query of structured fields\n\no       Use of structured fields for error recovery\n\no       Data compaction.\n\nSample BIND parameters (LOGMODE table entries) are\nsupplied at the end of this article.  The format of the\nCOMPROT and PSERVIC field are as follows (note the byte\nnumbers refer to the location within the BIND session\nparameters):\n\nCOMPROT=X'7080'\n          | |\n          | Byte 6 - Send/Receive Indicators (Half Duplex  Flip/flop)\n          Byte 5 - FMH (X'40') and Bracket (X'30') Indicators\n\nPSERVIC=X'01000000E100185000007E00'\n          |             | |   |\n          |             | |   Bytes 23,24 - Data Stream Flags\n          |             | Bytes 21,22 - FMH Flags\n          |             Byte 20 - FMH Subset and Data stream\n          |                       Profile numbers\n          Byte 13 - LU type\n\nSNA defines three types of FMH for use in SCS printer\nsessions:\n\no       FMH type 1 - selects the destination (ie target device) for a\n       session (an LU session can logically support more than one\n       device) and any handling characteristics in effect (eg data\n       compression and/or compaction, special data stream etc).\n       The range of functions that can be described by the FMH1\n       are grouped into subsets, for example subset 0 describes\n       the use of structured  fields.\n\no       FMH type 2 - specifies operations or data manipulations to\n       be carried out by the selected device.\n\no       FMH type 3 - specifies the same functions as the FMH2\n       but the operations apply to all devices.\n\nSNA requires that an FMH appears in the beginning of an RU\nbut it may span more than one RU.  Provided that this\nrestriction is observed, an RU containing FMHs can appear\nanywhere in a chain, thus enabling switching between data\nstream profiles and printer functionality during the same\nsession or bracket, for example:\n\nSEND    CHAIN=FIRST,OPTCD=(NFMHDR)       RU 1 - No FMH, BC\nSEND    CHAIN=MIDDLE,OPTCD=(NFMHDR)      RU 2 - No FMH, \u00acBC, \u00acEC\nSEND    CHAIN=MIDDLE,OPTCD=(FMHDR)       RU 3 - FMH, \u00acBC, \u00acEC\nSEND    CHAIN=MIDDLE,OPTCD=(NFMHDR)      RU 4 - No FMH, \u00acBC, \u00acEC\nSEND    CHAIN=LAST,OPTCD=(NFMHDR)        RU 5 - No FMH, EC\n\nNote that RU 3 could contain all of the FMH(s) or they could\nbe continued on to RU 4.  Any space remaining in the RU (ie\nup to the RU size agreed in the BIND) can be filled with data\nto be printed.\n\nFor most communications with a printer an RU containing an\nFMH is sent as the only message in a chain:\n\nSEND    CHAIN=ONLY,OPTCD=(FMHDR)\n\nIn fact it is mandatory with certain communications (eg\nchanging a printer to IPDS mode, see below).\n\nAll FMHs begin with the following 2-byte format:\nByte       Bits       Meaning\n0       0-7              FMH length (including this length byte)\n1       0              FM concatenation indicator:\n                     0 - No other FMHs follow this one\n                     1 - Another FMH follows\n       1-7              FMH type (1, 2, 3, 4, etc).\n\nThe content of the remainder of the FMH depends upon the type.\n\n\nSNA LU TYPE 1 PRINTER SESSION\n\nThis session operates in SCS mode and employs FMHs to\ncontrol printer operation.  An RU sent to the printer must begin\nwith a 6-byte type 1 FMH of the following format:\nByte       Content       Meaning\n0       X'06'              FMH length\n1       X'01'              FMH-1 indicator\n2       X'00'              Select, console, logical address 0\n3       X'0B'              Data stream profile, structured fields follow\n4       X'60'              FMH properties (no compression or compaction)\n5       X'00'              Reserved.\n\nByte 3 specifies DSP select as X'0B' which means that the\nremainder of the request will contain structured fields of the\nfollowing format:\n\nByte       Content       Meaning\n0-1       X'....'              Length in bytes (including length and type bytes)\n2       X'41'              Type (data)\n3       X'00'              Not used\n4-       ......              Data.\n\nThe data portion of the request (following the FMH) will\ncontain SCS codes of which there are 2 types:\n\no       Character codes which are printable characters (A-Z, 0-9, etc)\n\no       Control codes which represent printer control functions,\n       possibly one of the following:\n\nCode       Function\n05               Horizontal tab\n08              Graphic escape\n0B              Vertical tab\n0C              Form feed\n0D              Carriage return\n15              New line\n16              Back space\n25              Line feed\n28              Set attribute (data attributes, eg colour)\n2BC1              Set horizontal format (line width)\n2BC2               Set vertical format (page length)\n2BC6               Set line density (lines per inch)\n2BD2nn29       Set print density (CPI specified by nn).\n\nSCS printer-to-host communication\n\nThe functional capabilities of a printer operating in SCS (LU\ntype 1) mode can be determined by a host application sending a\nquery list request to the printer:\n\nByte       Content       Meaning\n0-1       X'0005'       Length in bytes (including length and type bytes)\n2       X'01'       ype (read partition)\n3       X'FF'       Query (partition-id)\n4       X'02'       Code for query.\n\nAn SCS printer is capable of returning data in response to the\nhost query.  In this case, byte 3 of the FMH in the in-bound\nRU is set to X'8B' to indicate in-bound transmission.  The\nstructured data field for the Summary Query Reply from an\nSCS printer (in LU type 1 mode) is as follows:\n\nByte       Content       Meaning\n0-1       X'....'       Length in bytes (including length and type bytes)\n2       X'81'       Type (Summary Query Reply)\n3       X'80'       Summary indicator\n4-       X' ',X' ',       Data (list of replies).\n\nThe list of replies describes the functions supported by the\nprinter.  These could include:\n\nReply Code       Function\n81       User area supported\n85       Multiple character sets supported\n86       Colour supported\nA0       Data streams supported (eg IPDS).\n\nNote, since the session between the host program (PLU) and\nthe printer (SLU) operates in half duplex flip-flop mode, the\nRU containing the Query List Request must have the Change\nDirection indicator set to allow the printer to send the Summary\nReply back.  The SEND must be coded with the CHNGDIR\noption:\n\nSEND   CHNGDIR=CMD\n\nIn order for this to be effective there must be an open bracket,\nie EB must not have been sent by the host application.  Failure\nto observe these conditions will result in a message reject with\nsense code X'0829'.\n\nIntelligent Print Data Stream (IPDS)\n\nPrinter graphics and image control are not supported by SCS\nbut by IPDS, which is also a structured-field data stream\ncontaining more printer control codes.  To activate IPDS an\nFMH type 1, subset 4 is sent to the printer:\n\nByte       Content       Meaning\n0       X'06'       FMH length\n1      X'01'      FMH-1 indicator\n2      X'03'      Medium select, document, logical address 0\n3      X'0D'      Data stream profile, IPDS\n4      X'40'      FMH properties, begin IPDS\n5      X'00'      Reserved\n\nTo deactivate IPDS, a similar FMH1 is sent with byte 4 set to\nX'20'.  This will cause the printer to return to the default SCS\ndata stream mode.  Termination of IPDS mode implies\ntermination of the open bracket.\n\nNote that both IPDS FMHs must be sent CHAIN=ONLY with\nno accompanying data.\n\n\n\nAs with SCS data stream the data comprises structured fields of\nthe following format:\n\nByte      Content      Meaning\n0-1      X'....'      Length in bytes (including length and type bytes)\n2-3      X'....'      Printer control code\n4      X'00'      Flag      (Bit 0 is set if printer must acknowledge)\n                  (Bit 1 is set if correlation-id included)\n5-6      X'....'      Correlation-id (if included)\n7-            Data (codes, subcommands, and print data).\n\nAgain, as with SCS a series of printer controls is included in\nthe structured data field, for example:\n\nCode      Meaning      Function\nD6E4      Sense type and model      Device control\nD697      Set home state      Device control\nD6AF      Begin page      Device control\nD6BF      End page      Device control\nD62D      Write text      Text presentation\nD64D      Write image      Image data presentation\nD685      Write graphic      Graphic data presentation\nD61E      Load symbol set      Font control\n\n\nSNA LU TYPE 3 PRINTER SESSION\n\nThis session uses 3270 data stream.  RUs contain 3270 control\ncodes followed by the control orders and data to be printed.\nOnce the session has been established there are no defined\nSNA functions to control the printer.  LU type 3 does not\nsupport FMHs and cannot therefore utilize the full range of\nprinter capabilities.\n\nA 3270 data stream write command is sent with the start print\nbit set followed by a Write Control Character (WCC) as\nfollows:\n\nByte       Content      Meaning\n0      27      Escape character\n1      F5      Write command (with start print bit set)\n2      C8      WCC\n3      11      Set Buffer Address (SBA)\n4-5      4040      Column 1, row 1\n6-            EBCDIC data and printer control\n\nRUs contain 3270 buffer control orders (eg SBA, repeat to\naddress) and print format orders (eg new line, form feed, etc).\nBuffer control orders are executed upon receipt by the control\nunit (eg 3174) and supervise the way in which the printer\nbuffer is filled.  Print format orders together with the data to be\nprinted are stored in the printer buffer as received.  The orders\nare executed and the data is printed only when the buffer has\nbeen filled.  It is possible to fill the printer buffer using a series\nof write commands (ie multiple SEND requests from the host\napplication) with SBA control codes, delaying printing until a\nfinal SEND with the start print bit set on in the WCC.\n\n\nHANDLING PRINTER ERRORS\n\nFailure of a SEND macro instruction to deliver the data\nmessage to the printer controller or failure of the printer to print\ncan be detected issuing a CHECK against the originating RPL\nwhich will cause VTAM to schedule the SYNAD exit in the\napplication.  Sample coding of such a sequence and related exit\nwould be as follows:\n\n< Mainline code entry protocol>\n           .\n< Mainline printer session set-up code>\n           .\n           .\n         SEND   RPL=SENDRPL,ACB=APPLACB,ARG=(6),                       C  <1>\n                AREA=MESSAGE,AREALEN=MSGLEN,                           C\n                CONTOL=DATA,RESPOND=(NEX,FME,NQRESP),                  C\n                CHAIN=ONLY,BRACKET=(NBB,NEB),                          C\n                OPTCD=(SYN,CA,FMHDR)\n         CHECK  RPL=SENDRPL                                               <2>\n\n   < Test for SYNAD exit posting error >\n\n         SHOWCB AM=VTAM,RPL=SENDRPL,AREA=SHOWAREA,LENGTH=24,           C  <6>\n                FIELDS=(RTNCD,FDBK2,USENSEI,SSENSEI)\n           .\n\nAPPLACB  ACB   AM=VTAM,APPLID=APPLID,EXLST=APPLIST,MACRF=LOGON\nAPPLID   DC    X'06',C'APPLID'\nAPPLIST  EXLST AM=VTAM,LOGON=LOGONXIT,SYNAD=SYNADXIT\nSENDRPL  RPL   AM=VTAM\nMESSAGE  DC    X'0601000B6000'                                            <3>\n         DC    H'23',X'4100'\n         DC    X'0C0D'\n         DC    C'PRINTER LOGGED ON'\nMSGLEN   EQU   *-MESSAGE\nSHOWAREA DS    24C\n\n\nSYNADXIT DS    0H\n   < entry protocol >\n         L     2,=A(SENDRPL)\n         SESSIONC RPL=(2),CONTROL=CLEAR,STYPE=REQ,OPTCD=SYN               <4>\n         LTR   15,15\n         BNZ   CLSDST\n   < flag mainline SYNAD tripped but recovered>\n   < exit protocol >\n         BR    14\nCLSDST   DS    0H\n         CLSDST RPL=(2)                                                   <5>\n   < flag mainline, session closed due to SYNAD>\n   < exit protocol >\n         BR    14\n\nNotes\n\nThe following notes refer to the statements flagged in the above\nsample code.\n\n\n1      The SEND message contains an FMH, the message is the\n       only one in a chain and the message flows in an already\n       open bracket (ie no begin bracket, no end bracket\n       specified).  The application will wait until the message has\n       been sent (OPTCD=SYN).\n\n2      This will force the scheduling of the SYNAD exit if there\n       had been a problem with the printer or the data sent to it.\n\n3      The message contains an FMH1 indicating that a\n       structured data field follows.  Code 41 indicates that the\n       field is SCS-type data, the SCS data follows (LF, CR, etc).\n\n4      Attempts to CLEAR the current messages on the session.\n       If this succeeds, the mainline code can be flagged to re-\n       send the messages.\n\n5      If the message flow cannot be cleared, the session should\n       be terminated.\n\n6      VTAM places in SHOWAREA the contents of the fields\n       specified.  Each field occupies 4 bytes and is placed in the\n       order specified by the FIELDS parameter.\n\nWithin the SYNAD exit it is possible to retry the failing SEND\ninstruction by using the EXECRPL macro.  This is issued\nagainst the original SEND macro RPL.  If this is used, care\nmust be taken to check for recursive scheduling of the SYNAD\nexit.  On balance it is probably safer to allow mainline\napplication code to determine whether to retry the SEND.  A\nretry could be preceded by a single chain message containing a\npage throw.  Possibly a prompt could be sent to the host\noperating system console to initiate manual intervention.\n\n\nERROR CODES AND PROBABLE CAUSES\n\nIn the course of normal message flow, RTNCD=04 is the most\nprobable error.  Any other error will relate to the session\ncontrol protocol in which case the only course of action is to\nabandon the session.  Examine the sense information returned\nfor one of the following errors relating to the message data sent\nto the printer:\n\nSense Code      Meaning      Probable cause(s)\n0802      Intervention Required      Printer has returned a\n            hardware error condition, eg\n            paper jam.\n1002      RU length error        RU containing message is\n            longer than agreed in BIND\n            parameters.\n1003      Function not supported      FMH reserved bits not zero.\n            Invalid structured field type.\n            Invalid query code field.\n            Invalid SCS control code.\n1005      Invalid parameter      Invalid structured field length.\n            Print control error (eg print\n            beyond boundary of page).\n1008      Invalid FMH      FMH does not conform to\n            standard requirements.\n2002      Chaining error      Chaining sequence is not\n            correct, eg CHAIN=\n            MIDDLE sent without a\n            CHAIN=FIRST.\n2003      Bracket error      Bracket sequence is not\n            correct, eg BRACKET=\n            (BB,NEB) sent without EB\n            first.\n2008      No Begin Bracket      Message sent to the printer\n            but there is no open bracket.\n2009      Session control or data      Either a session control request\n      flow control error      (eg change direction) or data\n            flow control request has been\n            sent but is not valid for the\n            current printer session state.\n\nSNA allows for a further two bytes of sense code to be\nprovided.  These follow immediately after the sense code (eg\nX'100808nn').  Use of this is currently limited (if used at all).\n\nIf the logical processing of errors is insufficient to determine\nthe problem, the printer hardware buffers can be examined.\nIn the controller to which the printer is attached, there is a\ncommunications buffer comprising two 4K buffers: a character\nbuffer and an attribute buffer.  The character buffer contains\ncommand codes, printer codes, and the data to be printed.  The\nattribute buffer contains additional information to describe how\neach character is to be printed.  A Printer Control Information\nArea (PCIA) is contained in the first 80 bytes of each buffer.\nBy stopping the printer and putting it into TEST mode, the\nPCIA can be printed (assuming that the printer still functions!).\nExamine the PCIA for possible errors as follows:\n\nByte      Description      Setting      Reason\nX'00'      Status register      X'40'      Data check\n            X'10'      Equipment check\nX'03'      Sense data      X'02'      Invalid control code parameter\n            X'03'      Invalid SCS code\n            X'04'      Order reject\n            X'07'      Invalid FMH\n            X'08'      Invalid structured field\nX'11'      Mode      X'05'      Data stream emulation (SNA)\n            X'06'      LU 1 mode\nX'12'      Message...            Address of the start of ...\nX'13'      ...start address              ...   the message in buffer\nX'14'      Message...            Length of ...\nX'15'      ... length             ... current message\nX'16'      Order      X'01'      Abort\n            X'03'      Printing or FMH processing\nX'17'      Order parameters      X'00'      SCS data stream\n            X'01'      FMH data stream\n            X'03'      In SCS receive state.\n\nNote that the above interpretation applies only to a printer\noperating in LU 1 (SCS) mode.\n\nWhen examining the message area in the buffer be aware that\nthe text and printer control codes will have been translated into\nprinter internal codes, for example:\n\nControl      EBCDIC      4224 Internal\n NL       X'15'       X'03'\n EM       X'19'       X'01'\n\n\nSAMPLE BIND SESSION PARAMETERS\n\nStandard SCS printer (eg 3268, 3278 in LU 1 mode)\n\n      MSCS     MODEENT LOGMODE=MSCS,\n                    FMPROF=X'03',\n                    TSPROF=X'03',\n                    PRIPROT=X'B1',\n                    SECPROT=X'90',\n                    COMPROT=X'3080',\n                    RUSIZES=X'87C6',\n                    PSNDPAC=X'01',\n                    SRCVPAC=X'01',\n                    PSERVIC=X'01000000E100000000000000'\n\n3287 Model 2 operating in 3270 data stream mode (LU 3)\n\n      M3287DS  MODEENT LOGMODE=M3287DS,\n                    FMPROF=X'03',\n                    TSPROF=X'03',\n                    PRIPROT=X'B1',\n                    SECPROT=X'90',\n                    COMPROT=X'3080',\n                    RUSIZES=X'87C6',\n                    PSNDPAC=X'01',\n                    SRCVPAC=X'01',\n                    PSERVIC=X'03800000000018501B847F00'\n\n4224 Model 2 remote attached using IPDS (LU 1)\n\n      M4224IPR MODEENT LOGMODE=M4224IPR,\n                    FMPROF=X'03',\n                    TSPROF=X'03',\n                    PRIPROT=X'B1',\n                    SECPROT=X'90',\n                    COMPROT=X'7080',  <== Note, FMH bit set\n                    RUSIZES=X'85C7',\n                    PSNDPAC=X'01',\n                    SRCVPAC=X'01',\n                    PSERVIC=X'01000000E100185000007E00'\n\n\nBrian Alford\nSystems Consultant\nAranda (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N001A07": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\xac\\x00\\xac\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 172, "newlines": 172, "modlines": 0, "user": "SNAUPDT"}, "text": "You don't need to define CDRSCs\n\n\nINTRODUCTION\n\nIn order to use VTAM cross domain communication, that is\ncommunication between two or more VTAM domains, first of\nall we must define each domain with a CDRM statement, then\nwe need to define the connections between the domains with a\nPATH statement, and then the resources that belong to each\ndomain.  Resources include applications (CICS etc) plus\nterminals and printers.  Finally, we must add the names of\nthese copy books to our ATCCON01.B copy book so that they\nare activated automatically when VTAM comes up.\n\nIn order to access a resource in a remote domain, we would\nnormally define CDRSC statements in each domain that require\na resource in a remote domain.  These book names must be\nadded to our ATCCON01.B books.\n\nIf we take as an example the simple network illustrated in\nFigure 1, in order for the terminal connected to access live\nCICS (application-id CICSL), which is sitting under CDRM2,\nand to print to the local printer, we must define CICSL in\nCDRM1 as a remote resource like this:\n\n      CATALOG  CICSL.B\n               VBUILD TYPE=CDRSC\n      CICSL    CDRSC  CDRM=CDRM2,ISTATUS=ACTIVE\n      /+\n\nIn CDRM2, our printer should be defined as a remote resource\nlike this:\n\n      CATALOG  P001.B\n               VBUILD TYPE=CDRSC\n      P001     CDRSC  CDRM=CDRM1,ISTATUS=ACTIVE\n\nWe should also change and catalogue our ATCCON01.B books\nin both domains.\n\n\nTHE PROBLEM\n\nThe trouble with this is that each time we add a new resource\nor move existing resources, besides having to remember to\ndefine or redefine the resource, we also have to remember to\nadd or change all the BUILD CDRSC books for each resource\nin each domain, and also to add or delete the names of these\nbooks in each domain's ATCCON01.B copy book.  It is not\nlong before the number of CDRSC copy books starts to get out\nof hand.\n\nContinuing with our sample configuration, say we defined\nCICSL on CDRM2 and now want to move it to CDRM3, we\nwould have to perform the following steps (assuming that the\nPATHs and CDRMs had been defined previously):\n\n1      In CDRM1, change the direction of the CDRSC book:\n      -      V NET,INACT,ID=CICSL,F\n      -      Recatalogue the CDRSC definition with\n              CDRM=CDRM3\n      -      V NET,ACT,ID=CICSL.\n\n2      In CDRM2, remove the CDRSC and APPL definitions:\n      -      V NET,INACT,ID=CICSL,F\n      -      V NET,INACT,ID=P001,F\n      -      Take down CICS\n      -      Remove P001 and CICSL from ATCCON01.B.\n\n3      In CDRM3, define CICSL and the remote printer:\n      -      Catalogue the CDRSC definition for P001\n      -      Catalogue the APPL definition for CICSL\n      -      Bring CICSL up\n      -      V NET,ACT,ID=P001\n      -      V NET,ACT,ID=CICSL\n      -      Add P001 and CICSL to the ATCCON01.B copy book.\n\nFortunately, there is a far better and easier way to accomplish\nthis.\n\n\nTHE SIMPLER WAY\n\nThe following solution works on VTAM Version 2.2 upwards.\nOur system was VSE 2.1.5 with VTAM 3.1, VSE is currently\nat 3.2.\n\nWe define our CDRMs and PATHs as usual but instead of\ndefining each CDRSC separately, all we need to do is build an\n'adjacent' book in each domain for each resource in that\ndomain that needs to access a resource in another domain, and\nto add this book to its ATCCON01.B book so that the adjacent\nnode is brought up automatically like this:\n\n      CATALOG  ADJSCP01.B\n               VBUILD  TYPE=ADJSSCP\n               NETWORK\n      CDRMx    ADJCDRM\n      CDRMy    ADJCDRM\n               .\n               etc\n               .\n      /+\n\nwhere CDRMx and CDRMy are the names of the other\nCDRMs.  Don't define the owning CDRM.  I made this\nmistake and my VTAM went haywire.\n\nBy making the above definitions, if someone tries to access a\nresource (application, printer etc) that is not defined within\nhis/her own domain with an APPL or LBUILD statement,\nVTAM will look for it in the CDRMs listed in the ADJSSCP\nbook.  Since the search is sequential, put the most frequently\nused CDRMs first.  We now have complete freedom to move\nand add applications and resources.\n\nBe careful not to use the same name for different resources\nsince VTAM will not know which one you want and will go to\nthe first one it finds in its list of adjacent CDRMs.\n\nIf a terminal connected to CDRM1 wants constant access to the\napplication TESTL in CDRM3 and occasional access to CICSL\nin CDRM, we should define ADJSCP01 as follows:\n\n      CATALOG  ADJSCP01.B\n               VBUILD  TYPE=ADJSSCP\n               NETWORK\n      CDRM3    ADJCDRM\n      CDRM2    ADJCDRM\n      /+\n\nGoing back to our original example and assuming that we have\ndefined an adjacent book in each domain and added its name to\neach domain's ATCCON01.B book, if we want to access\nCICSL in CDRM2 from a terminal connected to CDRM1 and\nwant CICSL to print on a printer in CDRM1 there is no need to\ndo anything else.\n\nTo move CICSL from CDRM2 to CDRM3 as we did\npreviously, we need to perform the following steps:\n\n1      In CDRM1, there is no need to do anything.\n\n\n2      In CDRM2, remove the APPL definition for CICSL:\n      -      V NET,INACT,ID=CICSL,F\n      -      Take down your CICS\n      -      Remove CICSL from the ATCCON01.B book.\n\n3      In CDRM3, add the APPL definition for CICSL:\n      -      Catalogue the APPL definition for CICSL\n      -      Bring CICSL up\n      -      V NET,ACT,ID=CICSL\n      -      Add CICSL to the ATCCON01.B book.\n\n\nSUMMARY\n\nOnce you have defined each domain, the connections, the\nresources, and the adjacent books; and added their names to the\nATCCON01.B book, you have complete accessibility to all\nresources automatically from every domain.  You no longer\nneed CDRSCs.\n\nTo check the ADJSSCP list, you can enter D NET,ADJSSCPS\non the console.  This will give you your search list.\n\nYechezkel Ida\nSystems Programmer\nMenora Insurance Co Ltd (Israel)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N001A08": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x01b\\x01b\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 354, "newlines": 354, "modlines": 0, "user": "SNAUPDT"}, "text": "NCCF CLISTs and NetView\n\nAttracted by the message automation facilities of NetView, we\ndecided to install release 3 to replace the NCCF 2.2 program\nwe were running.  Since no mention was made of problems\nwith CLISTs, we assumed that our NCCF CLISTs would\ncontinue to run.  This proved not to be the case.\n\n\nCLIST &WAIT PROBLEMS\n\nAny CLIST that issued an &WAIT command (issuing a\ncommand to VTAM or to NetView and then trapping the\nresponses in order to process the message replies) in most cases\nwould hang mysteriously with an outstanding wait after\ntrapping only one or two of the responses returned.  Some\nwould time out without having been driven by any of the\nmessages we knew were being received.\n\nA deeper perusal of the manuals revealed the existence of a\nsupplied program to automate the conversion of CLISTs into\nREXX.  The converted programs failed in just the same way.\n\nFurther investigation by IBM and ourselves revealed that the\nmessage processing internal to NetView was very different\nfrom that of NCCF.  Previously, message responses from\nVTAM had been passed to CLISTs individually and any one of\nthem was capable of driving the &WAIT. Under NetView, a\nwhole raft of message responses from VTAM is often passed as\na single Multi-Line Write To Operator (MLWTO) message and\nonly the very first message is capable of driving the &WAIT.\nThis meant that most of the messages that our CLISTs were\nwaiting for were simply being missed.\n\nOne answer was to rewrite most of our CLISTs using the\nGETMLINE, GETMSIZE, and PARSEL2R commands; to split\nup the messages; and then branch to the appropriate sub-\nroutines to process the messages - potentially a lengthy, error-\nprone, and rather dull task.\n\n\nA BOLT-ON SOLUTION\n\nThe better solution proved to be to develop some code which\ncould simply be bolted on to a CLIST irrespective of its logic.\nOnce the code (which is the subject of this article) was\ndeveloped, all our CLISTs were converted and functioning\nperfectly in less than 30 minutes.\n\nUse a utility to search your NCCF CLIST libraries for the\ncharacter string '&WAIT'.  Any CLIST that uses this\ncommand is a potential candidate for conversion.  Those which\nissue a command to VTAM or NetView will almost certainly\nrequire it.\n\nCopy these subroutines at the bottom of the failing CLIST.\nEnsure that the subroutine names supplied do not already exist\nelsewhere in the CLIST.\n\n\nSPLIT\n\n-SPLIT\nOVERRIDE DISPLAY=NO\nGETMSIZE MLWTOSIZE\n&MSGNUMBER = 1\n-SPL123\n&IF &MSGNUMBER > &MLWTOSIZE &THEN &GOTO -SPL124\nGETMLINE MESSAGE &MSGNUMBER\nGETMTYPE TYPE &MSGNUMBER\nPARSEL2R MESSAGE MSGID MSGSTR\n&TYPE&MSGNUMBER = &TYPE\n&ID&MSGNUMBER = &MSGID\n&STR&MSGNUMBER = &MSGSTR\n&MSG&MSGNUMBER = &MESSAGE\n&MSGNUMBER = &MSGNUMBER + 1\n??EXCMD &OPID SPLWAIT &MESSAGE\n&GOTO -SPL123\n-SPL124\nOVERRIDE DISPLAY=DEFAULT\n&WAIT CONTINUE\n\n\nSAY\n\n-SAY\nGETMSIZE MSGSIZE\nGETMLINE MESSAGX &MSGSIZE\nPARSEL2R MESSAGX &MSGID MSGSTR\n&MSGID = &SUBSTR &MSGID 2\n&IF &MSGID = 'IST097I' &THEN &GOTO -SKIP\n&WRITE '>>>> ' &MSGID &MSGSTR ' <<<<'\n-SKIP\n&WAIT CONTINUE\n\nThen, if you are trying to trap VTAM message responses, for\nexample, include this line as the first message to be trapped in\nyour &WAIT:\n\n       IST*=-SPLIT,+\n\nThis will ensure that all VTAM message responses are trapped\nand processed by the subroutines.\n\nInclude this line as the last message to be trapped in your\n&WAIT:\n\n       #*=-SAY\n\nThis ensures that if your CLIST receives any messages it is not\nexpressly designed to trap, they will be issued to the screen and\nnot simply lost.\n\nThen, prefix with '#' all the message identifiers that your\nCLIST was originally designed to trap.  For example, a line in\nthe CLIST &WAIT:\n\n       IST350I=-MAJOR,+\nwill become\n\n       #IST350I=-MAJOR,+\n\n\nEXAMPLE\n\nThe CLIST segment below has the required changes\nhighlighted as an example:\n\n&CONTROL ERR\n&CGLOBAL DOMN,SUBN,DOMD\n&WAIT SUPPRESS CONTWAIT\n&I   = 0\n&SP5 = '     '\n&SP9 = '         '\n&SEL = &1\nCLEAR\n&IF .&SEL EQ . &THEN &GOTO -MAJONLY\n&WAIT 'D NET,APPLS',+\n      IST*=-SPLIT,+\n      #IST350I=-IGNORE,+\n      #IST080I=-MINOR,+\n      #IST360I=-IGNORE,+\n      #IST089I=-MAJOR2,+\n      #IST314I=-LAST2,+\n      #%=-SAY\n&WRITE APPLS: CLIST TERMINATED DURING WAIT BY OPERATOR\n&EXIT -1\n-MAJOR2\n&FLAG1 = 0\n&IF X&1 NE X&SEL &THEN &GOTO -IGNORE\n&FLAG1 = 1\n&MAJF  = 1\n&WRITE ******************************************************\n&WRITE * APPLICATION PROGRAM MAJOR NODE &SEL\n&WRITE *=====================================================\n&WRITE * DOMAIN &DOMN - SUBAREA &SUBN\n&WRITE ******************************************************\n&WAIT CONTINUE\n-MAJONLY\n&WAIT 'D NET,APPLS',+\n       IST*=-SPLIT,+\n       #IST350I=-IGNORE,+\n       #IST080I=-IGNORE,+\n       #IST360I=-IGNORE,+\n       #IST0891=-MAJOR1,+\n       #IST314I=-LAST1,+\n       #*=-SAY\n&WRITE APPLS: CLIST TERMINATED DURING WAIT BY OPERATOR\n&EXIT -1\n-IGNORE\n&WAIT CONTINUE\n-MAJOR1\n&MAJ = &1\n&LEN = &LENGTH &MAJ\n&LEN = 9 - &LEN\n&PAD = &SUBSTR &SP9 1 &LEN\n&MAJ = &CONCAT &MAJ &PAD\n&MAJ = &CONCAT &MAJ &6\n&MAJ = &CONCAT &MAJ &SP5\n&I = &I + 1\n&MAJ&I = &MAJ\n&WAIT CONTINUE\n-MINOR\n&IF &FLAG EQ 0 &THEN &GOTO -MINLOOPE\n&NOD1 = &1\n\nThis simple editing is all that is required to convert each\nCLIST, but you also require a module which must be defined\nto NetView in the DSICMD member of the NetView\nPARMLIB.  The CMDMDL statement required is highlighted\nin the example below:\n\n* BHS CMDMDL STATEMENTS                                          *\n*----------------------------------------------------------------*\nIML2    CMDMDL   MOD=IML2\nSPLWAIT CMDMDL   MOD=SPLWAIT,RES=Y,ECHO=N,PARSE=N\n         END\n\n\nSPLWAIT\nSPLWAITA CSECT\n         DSICBS DSICWB,DSIMVT,DSIPDB,DSISVL,DSISWB,DSITIB,DSITVB,      X\n               PRINT=NO\n*  SAVE REGISTERS AND SET UP BASE REGISTER                            *\n         USING *,R15\n         B     START1\n         DC    C'SPLWAITA  &SYSDATE. AT &SYSTIME.'\nSTART1   DS    0H\n         STM   R14,R12,R12(R13)       SAVE REGISTERS\n         DROP  R15\n         LR    R12,R15                SET BASE REGISTER\n         USING SPLWAITA,R12\n*  ADDRESSABILITY                                                     *\n         LR    R11,R1                 LOAD CWB ADDR\n         USING DSICWB,R11             R11 BASE FOR COMMAND WORK BLOCK\n         LA    R1,CWBSAVEA            USE CWBSAVEA FOR SAVEAREA\n         ST    R1,8(R13)              STORE MY SA INTO CALLERS SA\n         ST    R13,4(R1)              STORE CALLERS SA IN MINE\n         LR    R13,R1                 R13 HAS MY SAVEAREA ADDRESS\n*  ADDRESSABILITY                                                     *\n         L     R10,CWBTIB             GET DSITIB ADDRESS\n         USING DSITIB,R10             ESTABLISH ADDRESSABILITY\n         L     R9,TIBTVB              GET DSITVB ADDRESS\n         USING DSITVB,R9              ESTABLISH ADDRESSABILITY\n         L     R8,TVBMVT              GET DSIMVT ADDRESS\n         USING DSIMVT,R8              ESTABLISH ADDRESSABILITY\n         XC    CWBADATD,CWBADATD      ZERO AUTODATA AREA\n         SLR   R15,R15                ZERO RETURN CODE REGISTER\n*        MAIN PROCESSING                                              *\n         DSIDATIM AREA=DATETIME,FORMAT=BINARY\n         LA    R2,MSGBUFF        SET ADDRESSABILITY TO BUFHDR\n         USING BUFHDR,R2         R2 IS BASE FOR BUFHDR\n         LA    R1,BUFLENG\n         STH   R1,HDRBLENG       SET BUFFER LENGTH\n         LA    R1,BUFHDRND-BUFHDR  OFFSET TO MSG TEXT\n         STH   R1,HDRTDISP         PUT OFFSET IN HEADER\n         MVI   HDRMTYPE,HDRTYPEL   TITLE LINE MESSAGE\n         MVC   HDRDOMID,MVTCURAN   PUT DOMAIN ID IN HEADER\n         L     R1,TIME             GET TIME\n         ST    R1,HDRTSTMP         PUT TIME IN HEADER\n         LA    R1,L'TITLE1         GET LENGTH OF 1ST TITLE LINE\n         STH   R1,HDRMLENG         PUT LENGTH IN BUFFER HEADER\n         MVI   HDRIND,HDRLNEND     INDICATE TITLE LINE\n         L     R5,CWBBUF           FIND THE MESSAGE...\n         USING MYBUF,R5\n         LH    R7,HSRMLENG         AND ITS LENGTH\n         SH    R7,SPLWAIT          MINUS LENGTH OF 'SPLWAIT ' COMMAND\n         SH    R7,EXTRAONE         ONE MORE AS WELL\n         MVC   MESSAGE,SPACES      INITIALIZE BUFFER\n         EX    R7,EX2\n         MVI   MESSAGE,C'#'  MAKE MESSAGE IDENTIFIABLE TO CLIST &WAIT\n*        MVC   MESSAGE(L'TITLE1),TITLE1  MOVE MESSAGE TO BUFFER\nSENDMSG  DSIPSS SWB=CWBSWB,TYPE=OUTPUT,BFR=(2),OPTIONS=MSG\n         B     RETURN\n*  EXECUTED INSTRUCTIONS                                              *\nEX2      MVC   MESSAGE+1(0),MSSSAGE ...AND MOVE TO BUFFER\n*  CONSTANTS                                                          *\nSPLWAIT  DC    XL2'0008'\nEXTRAONE DC    XL2'0001'\nSPACES   DC    CL72' '\nRETURN   EQU   *\n         L     R13,4(R13)             GET CALLERS SAVEAREA ADDRESS\n         L     R14,12(R13)            RESTORE REG14\n         LM    R0,R12,20(R13)         RESTORE REGS\n         BR    R14                    RETURN\n         LTORG\nTITLE1   DC    CL72'#ST097I MY FAKE MESSAGE'\nDSICWB   DSECT\n         ORG   CWBADATD               AUTODATA AREA\nDATETIME DS    0D\nDATE     DS    F\nTIME     DS    F\nMSGBUFF  DS    0F\n         DS    XL(BUFHDRND-BUFHDR)\nMESSAGE  DS    CL72\nOVERLAP  DS    CL1\nBUFLENG  EQU   *-MSGBUFF\n         DS    XL(256-(*-CWBADATD))   AUTODATA LENGTH CHECK\nMYBUF    DSECT\nMSBUF    DS    0XL44\nHSRMLENG DS    XL2\nHSBMLENG DS    XL2\nHSRIND   DS    XL1\nHSRMTYPE DS    XL1\nHSRTDISP DS    XL2\nHSRTSTMP DS    XL4\nHSRDOMID DS    XL8\nRSSERVED DS    XL4\nHSRNEXTM DS    XL4\nHSRSENDR DS    XL8\nCSMMAND  DS    XL8\nMSSSAGE  DS    XL72\n         END\n\nIt should be assembled and linked with a job and procedure\nsimilar to the following:\n\n//*  JCL TO ASSEMBLE AN NCCF LOAD MODULE.\n//ASSEM     EXEC ASMHCT,\n//          PARM.C='NODECK,OBJECT,XREF(SHORT),RENT',\n//          PARM.L='LIST,XREF,MAP,RENT'\n//*  ABOVE PARM OVERRIDES ARE VALID FOR 'SPLWAIT' ONLY\n//*  ASMHCT DIFFERS FROM ASMHCL ONLY IN THAT IT REFERENCES\n//*  THE NETVIEW MACRO LIBRARY AS WELL AS THE SYS1 ONE\n//C.SYSIN   DD   DSN=TYB.NETV.ASM(SPLWAIT),DISP=SHR\n//L.SYSLMOD DD   DSN=$NETV.USERLNK(SPLWAIT),DISP=SHR,UNIT=3380\n//* LIB: SYS1.PROCLIB(ASMHCT)\n//* GDE: MVS/SP SYSTEM IPO PROGRAM PRODUCT GUIDE\n//* DOC: THIS PROCEDURE EXECUTES ASSEMBLER H AND\n//*      LINK-EDITS THE NEWLY ASSEMBLED PROGRAM\n//C       EXEC PGM=IEV90,PARM='NODECK,OBJECT,XREF(SHORT)'\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=$NETV.MACLIB,DISP=SHR\n//SYSLIN   DD  DSN=&OBJ,SPACE=(3040,(40,40),,,ROUND),UNIT=VIO,\n//             DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n//SYSUT1   DD  DSN=&SYSUT1,SPACE=(1024,(120,120),,,ROUND),UNIT=VIO,\n//             DCB=BUFNO=1\n//L       EXEC PGM=IEWL,COND=(5,LT,C),\n//      PARM='LIST,XREF,MAP,RMODE=24,AMODE=24'\n//SYSPRINT DD  SYSOUT=*\n//SYSLMOD  DD  SPACE=(CYL,(1,1,1)),DSN=&LOD(X),DISP=(,PASS),\n//             UNIT=VIO,DCB=BUFNO=1\n//SYSUT1   DD  DSN=&SYSUT1,SPACE=(1024,(120,120),,,ROUND),UNIT=VIO,\n//             DCB=BUFNO=1\n//SYSLIN   DD  DSN=&OBJ,DISP=(OLD,PASS)\n//         DD  DDNAME=SYSIN\n\nNotice that the module must be linked as re-entrant into a load\nlibrary that is accessible to NetView, perhaps using a STEPLIB\nin the JCL for NetView start-up.\n\n\nMISCELLANEOUS PROBLEMS\n\nWe found another two minor problems in converting our\nCLISTs to run under NetView.  One was that some of the\nmessage formats for NetView messages had altered so that one\nof our CLISTs using &SUBSTR to reference a portion of a\nmessage was instead missing the relevant part of the message.\nThe other problem was that &MSGID and &MSGSTR are not\nautomatically set on receipt of a message under NetView as\nthey were under NCCF.  You must use GETMLINE and\nPARSEL2R to set them in that part of your CLIST that\nattempts any processing of this sort.  Bear in mind that the\nmessages you receive and process with these commands in the\nparts of your own CLIST will, if you have made use of the\ncontents of this article, be prefixed with '#'.\n\nRon Ellis\nSenior Systems Programmer\nStorehouse Retail Services (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N001A09": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00L\\x00L\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 76, "newlines": 76, "modlines": 0, "user": "SNAUPDT"}, "text": "Displaying NCP pseudo-slowdown status flag\n\nOften, an NCP might be performing poorly and a useful check,\nespecially on a 3725 where real storage is limited, is of\nwhether the NCP has hit pseudo-slowdown.  This occurs before\na real slowdown occurs and there is no warning when in\npseudo-slowdown.\n\nThe following NetMaster NCL procedure, which could easily\nbe adapted for NetView, checks all the active NCPs.  The first\nbyte should always be X'00' - anything greater than X'00'\nindicates that the NCP is in pseudo-slowdown.  Basically the\nXDB at offset X'6E0' offset X'4' indicates the pseudo-\nslowdown status.  The code is applicable to 3725s and upwards\nrunning NCP Version 4.2 and Net/Master.\n\n-**********************************************************************\n-* FUNCTION/PURPOSE\n-*     DISPLAY THE PSEUDO SLOWDOWN BIT STATUS IN THE XDB FOR A\n-*     SPECIFIED NCP\n-*     XDB ADDRESS IS X'6E0' AND SLOW DOWN IS BYTE X'4' = B'.1.. ....'\n-* PROC TYPE: MAINLINE\n-* METHOD OF INVOCATION: ASYNCH, USER ENTERED\n-**********************************************************************\n   CONTROL NOTRACE NOCMD NOENDMSG\n       INTCLEAR\n       INTCMD NCPS\n.NXTNCP\n* determine number of NCPs in system  (max 4 here)\n       INTREAD ARGS\n       IF . 1 NE .IST0891  THEN  GOTO .ERROR\n       NCP1 =  2\n       INTREAD ARGS\n       IF . 1 NE .IST0891  THEN  GOTO .ERROR\n       NCP2 =  2\n       INTREAD ARGS\n       IF . 1 NE .IST0891  THEN  GOTO .ERROR\n       NCP3 =  2\n       INTREAD ARGS\n       IF . 1 NE .IST0891  THEN  GOTO .ERROR\n       NCP4 =  2\n       NCPN =  NCP1\n       GOSUB .SLOWD\n       NCPN =  NCP2\n       GOSUB .SLOWD\n       NCPN =  NCP3\n       GOSUB .SLOWD\n       NCPN =  NCP4\n       GOSUB .SLOWD\n       EXIT\n.SLOWD\n   LOOPCTL 100\n* Get the address of the XDB area for the ncp\n       INTCLEAR\n       INTCMD D NET,NCPSTOR,ADDR=06E0,ID= NCPN\n.INA\n       INTREAD ARGS\n       IF . 1 NE .IST245I  THEN  GOTO .INA\n        XDBADR =  3\n* Get the XDB area for the ncp\n       INTCLEAR\n       INTCMD D NET,NCPSTOR,ADDR= XDBADR,ID= NCPN\n.INB\n       INTREAD ARGS\n       IF . 1 NE .IST245I  THEN  GOTO .INB\n* write out the fullword containing the pseudo slowdown status\n       WRITEH XDB PSEUDO SLOWDOWN STATUS =  4 FOR  NCPN\n       RETSUB\n       WRITEH *** NO RESOURCE NAMES SPECIFIED ***\n       EXIT\n\n\nBruce Bodmer\nTelecoms Specialist\nMobil (South Africa)                                   c Mobil 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N001A10": {"ttr": 1538, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00~\\x00~\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 126, "newlines": 126, "modlines": 0, "user": "SNAUPDT"}, "text": "Locating the terminal BIND image\n\nThis article details how to locate the existing BIND image for a\nTSO session.  It was originally written when I discovered that\nseveral of the VTAM LOGMODEs that existed in\nSYS1.VTAMLIB did not match the source code members that\nwere supposed to correspond to them.\n\nSome of our PC users were unable to perform successful file\ntransfers.  However, when the LOGMODE source was checked\nit appeared to be coded correctly.  We used the following\ncommand processor, QBIND, to display the BIND image at the\nuser's terminal, and found that the LOGMODEs were\nincorrect.  The information that is returned by the command\nprocessor is very simple and was used on a TSO system that\ndid not utilize ISPF.  The command processor could be\nredesigned to output the data in a formatted fashion to an ISPF\npanel.  However, it is presented here in its simplest form.  The\nsame information can be obtained from a trace of the TSO\nuser's session, but the command processor is much easier to\nuse and less time-consuming.\n\nThe code for the command processor is shown below.  The\ncomments at the start of the code detail the control block chain\nthat has to be followed to locate the BIND image for the TSO\nuser.  Figure 1 is an example of the output returned by this\ncommand processor.\n\n\nSOURCE CODE FOR QBIND TSO COMMAND PROCESSOR\n\n******************************************************\n* PROGRAM NAME: QBIND (QUERY BIND).                  *\n* PURPOSE:      TO PROVIDE AN ONLINE REPRESENTATION  *\n*               OF THE VTAM BIND IMAGE FOR A TSO     *\n*               SESSION AT THE USERS TERMINAL.       *\n* LOCATING THE BIND IMAGE.                           *\n* THE IBM MANUAL 'VTAM DATA AREAS (LY30-5584)' CAN   *\n* BE USED TO OBTAIN MAPS OF THE FOLLOWING CONTROL    *\n* BLOCKS.                                            *\n* APPENDIX F OF THE IBM VTAM PROGRAMMING MANUAL      *\n* CAN BE USED TO MAP THE BIND IMAGE IF NECESSARY.    *\n* ASCB + X'3C'-----> ASCBTSCB---                     *\n*                               |                    *\n*       ------------------------                     *\n*      |                                             *\n*       -----> TSB + X'60' -----> TSSBEXTNT ---      *\n*                                              |     *\n*       ---------------------------------------      *\n*      |                                             *\n*       -----> TSBX + X'24' ----> TSBXTVWA ----      *\n*                                              |     *\n*       ---------------------------------------      *\n*      |                                             *\n*       -----> TVWA + X'58' ----> TVWANIB -----      *\n*                                              |     *\n*       ---------------------------------------      *\n*      |                                             *\n*       -----> NIB + X'38' -----> NIBNDAR -----      *\n*                                              |     *\n*       ---------------------------------------      *\n*      |                                             *\n*       -----> ISTBIND IMAGE.                        *\n******************************************************\nQBIND      CSECT\n           USING      *,R15             /* ENTRY ADDRESS. */\n           B          SKP               /* BRANCH PAST HEADER. */\n           DC         XL1'08'           /* LENGTH OF HEADER. */\n           DC         C'QBIND'          /* TITLE. */\nSKP        DS         0H\n           STM        R14,R12,12(R13)   /* STORE REGISTERS. */\n           DROP       R15               /* DROP R15 AS BASE. */\n           BALR       R12,R0            /* SETUP R12. */\n           USING      *,R12             /* BASE PROGRAM ON R12. */\n           LR         R11,R13           /* SAVE THE SAVEAREA. */\n           LA         R13,RSAVE         /* LOAD SAVEAREA ADDR. */\n           ST         R11,4(,R13)       /* STORE ORIGINAL ADDR. */\n           ST         R13,8(,R11)       /* STORE MY SAVEAREA. */\n           MODESET    KEY=ZERO          /* GET INTO SUPERVISOR. */\n           L          R8,X'220'         /* PTR ASCB. */\n           L          R8,60(R8)         /* PTR ASCBTSB X'3C'. */\n           L          R8,96(R8)         /* PTR TSBEXTNT X'60'. */\n           L          R8,36(R8)         /* PTR TSBXTVWA X'24'. */\n           L          R8,88(R8)         /* PTR TVWANIB X'58'. */\n           L          R8,56(R8)         /* PTR NIBNDAR X'38'. */\n           LA         R9,36             /* LOAD LENGTH BIND. */\n           LA         R3,OUTFLD2        /* LOAD ADDR O/P FIELD. */\nMAIN01     EQU        *\n           LA         R1,XSTRING        /* ADDR OF HEX TABLE. */\n           SR         R4,R4             /* ZEROIZE R4. */\n           SR         R5,R5             /* ZEROIZE R5. */\n           IC         R4,0(R8)          /* INSRT CHAR FROM BIND.*/\n           IC         R5,0(R8)          /* INSRT CHAR FROM BIND.*/\n           SRL        R4,4              /* HI 2 BYTES TO LOW. */\n           N          R5,=F'15'         /* AND-OUT HI 2 BYTES. */\n           AR         R4,R1             /* ADD STRT TBL ADDR. */\n           AR         R5,R1             /* ADD STRT TBL ADDR. */\nMAIN02     EQU        *\n           MVC        0(1,R3),0(R4)     /* MOVE 1ST CHAR O/P. */\n           MVC        1(1,R3),0(R5)     /* MOVE 2ND CHAR O/P. */\n           LA         R3,2(,R3)         /* POINT TO NEXT CHAR. */\n           LA         R8,1(R8)          /* POINT NEXT IN BIND. */\n           BCT        R9,MAIN01         /* LOOP IF NOT LAST. */\nEXIT       EQU        *\n           TPUT       OUTFLD1,L'OUTFLD1 /* PUT OUT TITLE. */\n           TPUT       SPACE,L'SPACE     /* PUT OUT SPACES. */\n           TPUT       OUTFLD2,L'OUTFLD2 /* PUT OUT BIND IMAGE. */\n           SR         R15,R15           /* ZERO RETURN CODE. */\n           L          R13,4(R13)        /* RELOAD SAVEAREA. */\n           RETURN     (14,12),RC=(15)   /* RETURN TO CALLER. */\nOUTFLD1    DS         0CL72\n           DS         CL23\n           DC         CL27'BIND IMAGE FOR THIS TSOUSER'\n           DS         CL22\nOUTFLD2    DS         0CL72\n           DC         72C'F'\nRSAVE      DS         18F\nSPACE      DC         C' '\nXSTRING    DC         CL16'0123456789ABCDEF'\n           IHAASCB\n           END\n\n\nJohn Bradley\nTechnical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N001A11": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\xb2\\x00\\xb2\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 178, "newlines": 178, "modlines": 0, "user": "SNAUPDT"}, "text": "NetView VSAM administration\n\n\nNETVIEW DATABASE REORGANIZATION OR CLEAR-OUT\n\nBecause of the volume of network data that a site can capture\nand thus record, NetView session monitor databases frequently\nbecome full or require reorganizing.  This situation often\noccurs during prime shift when it is not desirable to close\nNetView to perform the required database tasks.  Normally an\nAAU022I message is issued, which covers a multitude of\ndatabase problems, being accompanied by major and minor\nreturn codes 8 and 28 respectively which indicate that the\ndatabase can no longer record session information.\n\nAt this point NetView will allow a user to switch recording to a\nsecondary database (using SWLD S), however it will not\npermit you to perform various IDCAMS functions to\nreorganize or clear it out with back-up, without closing\nNetView and then restarting it.\n\nBy utilizing the Access Method Services ALTER NEWNAME\ncommand referencing dataset names rather than DDNAMEs in\nthe JCL, which gets around NetView's original enqueue, we\ncan then perform whatever functions are required.  This is\noften a suitable case for message automation and by placing the\nnecessary statements in your message automation table (default\nis DSIMSG01) the reorganization or clear could be fired off as\na started task (this could be a batch job in Release 3).  The two\nexamples shown below detail two popular applications for this\ntechnique.  Remember to switch to the secondary database\nbefore this and to switch back after if required.\n\nExample 1: back-up and clear-out\n\nThis example backs up the database to a sequential dataset,\nwhich may be a GDG if required, and then deletes and re-\ndefines the database.  In future this 'old' data could be restored\nby IDCAMS REPRO if session history is required for that\nperiod.\n\n//BACKCLR  JOB (ACCT#),'BACKUP AND CLEAR',CLASS=?,MSGCLASS=?\n//STEP1    EXEC PGM=IDCAMS,REGION=4096\n//SYSPRINT DD  SYSOUT=U\n//SYSUDUMP DD  SYSOUT=U\n//BACKUP   DD  DSN=NETVIEW.BACKUP.DATABASE,DISP=(,CATLG),\n//            DCB=(LRECL=4090,BLKSIZE=4094,RECFM=VB),\n//            SPACE=(CYL,(nnn,nnn)),UNIT=DISK\n//SYSIN    DD  *\n ALTER 'NETVIEW.PRIMARY.DATABASE'  NEWNAME('NETVIEW.PRIMARY.OLD')\n ALTER 'NETVIEW.PRIMARY.DATABASE.DATA'  -\n          NEWNAME('NETVIEW.PRIMARY.OLD.DATA')\n ALTER 'NETVIEW.PRIMARY.DATABASE.INDEX' -\n          NEWNAME('NETVIEW.PRIMARY.OLD.INDEX')\n IF LASTCC EQ 0 THEN -\n   REPRO IDS('NETVIEW.PRIMARY.OLD') OFILE(BACKUP)\n IF LASTCC EQ 0 THEN -\n   DELETE 'NETVIEW.PRIMARY.OLD' PURGE CLUSTER\n IF LASTCC EQ 0 THEN -\n   DEFINE CLUSTER(NAME(NETVIEW.PRIMARY.NEW) -\n                  INDEXED\n                  .\n           DATA NAME(NETVIEW.PRIMARY.NEW.DATA\n                  .\n           INDEX NAME(NETVIEW.PRIMARY.NEW.INDEX\n                  .\n                  .)\n IF LASTCC EQ 0 THEN -\n   ALTER 'NETVIEW.PRIMARY.NEW' NEWNAME('NETVIEW.PRIMARY.DATABASE')\n   ALTER 'NETVIEW.PRIMARY.NEW.DATA'  -\n          NEWNAME('NETVIEW.PRIMARY.DATABASE.DATA')\n   ALTER 'NETVIEW.PRIMARY.NEW.INDEX' -\n          NEWNAME('NETVIEW.PRIMARY.DATABASE.INDEX')\n\nExample 2: re-organization\n\nThis example copies the database to a work file, deletes and re-\ndefines the database, and then copies the data back.  The work\nfile is in fact a permanent dataset and is required to be in case\nof problems re-defining the database or copying the data back,\nthus whatever happens a copy of the data will always exist.\n\n//REORG    JOB (ACCT#),'REORG',CLASS=?,MSGCLASS=?\n//STEP1    EXEC PGM=IDCAMS,REGION=4096\n//SYSPRINT DD  SYSOUT=U\n//SYSUDUMP DD  SYSOUT=U\n//BACKUP   DD  DSN=NETVIEW.BACKUP.WORKFILE,DISP=SHR\n//SYSIN    DD  *\n ALTER 'NETVIEW.PRIMARY.DATABASE'  NEWNAME('NETVIEW.PRIMARY.OLD')\n ALTER 'NETVIEW.PRIMARY.DATABASE.DATA'   -\n           NEWNAME('NETVIEW.PRIMARY.OLD.DATA')\n ALTER 'NETVIEW.PRIMARY.DATABASE.INDEX'  -\n           NEWNAME('NETVIEW.PRIMARY.OLD.INDEX')\n IF LASTCC EQ 0 THEN -\n   REPRO IDS(NETVIEW.PRIMARY.OLD) OFILE(BACKUP)\n IF LASTCC EQ 0 THEN -\n   DELETE 'NETVIEW.PRIMARY.OLD' PURGE CLUSTER\n IF LASTCC EQ 0 THEN -\n   DEFINE CLUSTER(NAME(NETVIEW.PRIMARY.NEW) -\n                  INDEXED\n                  .\n           DATA NAME(NETVIEW.PRIMARY.NEW.DATA\n                  .\n           INDEX NAME(NETVIEW.PRIMARY.NEW.INDEX\n                  .\n                  .)\n IF LASTCC EQ 0 THEN -\n   REPRO INFILE(BACKUP) ODS(NETVIEW.PRIMARY.NEW)\n IF LASTCC EQ 0 THEN -\n   ALTER 'NETVIEW.PRIMARY.NEW' NEWNAME('NETVIEW.PRIMARY.DATABASE')\n   ALTER 'NETVIEW.PRIMARY.NEW.DATA' -\n              NEWNAME('NETVIEW.PRIMARY.DATABASE.DATA')\n   ALTER 'NETVIEW.PRIMARY.NEW.INDEX' -\n              NEWNAME('NETVIEW.PRIMARY.DATABASE.INDEX')\n\n\nLOG BACK-UP\n\nNetView permits you to define two log datasets, primary and\nsecondary, when one of these becomes full NetView will\nautomatically switch to the next log.  As this switch is\nperformed, any data that existed in what is now the current log\nis lost.  To overcome this loss of data, NetView administration\npersonnel can archive or print the logs using NetView message\nautomation and utilities.\n\nThe following example shows the statements required in the\nmessage table, CLIST member, and job control required to trap\nthe relevant message and act upon it.\n\nAutomation member in PARMLIB (default DSIMSG01)\n\nIF &MSGID = 'DSI546I'\n   THEN EXECMD('LOGPRIM');\n\nThis traps a switch to the primary log, to detect the activation\nof the secondary check for message-id DSI547I.\n\nCLIST member LOGPRIM in NetView CLIST library\n\nCLIST LOGPRIM\n&CONTROL ERR\n  &SUBMIT 'NETVIEW.JOBLIB(LOGPRIM)'  /* submit job see not above    */\n  &EXIT                /* quit out of clist after submit            */\n\nThe submit command is not supported in releases prior to\nRelease 3, however it is possible to initiate a started task to do\nthis using 'MVS S procname'.\n\nJob control LOGPRIM or LOGSEC\n\n//LOGPRIM   JOB (ACCT#),'NETWORK LOG BACKUP',CLASS=?,MSGCLASS=?\n//STEP1     EXEC PGM=DSIPRT\n//PRINTLOG  DD   DSN=NETVIEW.SECONDARY.LOG,DISP=SHR,AMP=AMORG\n//DSILT     DD   DSN=NETVIEW.LOG.BACKUP(+1),DISP=(,CATLG)\n//                SPACE=(CYL,(10,10),RLSE),\n//                DCB=(RECFM=FB,LRECL=132,BLKSIZE=4096),UNIT=DISK\n//SYSPRINT  DD   SYSOUT=U\n//DSIINP    DD   DUMMY\n\nIn the above example, the log is copied to a GDG.  If you want\nto print the contents simply change the DSILT to SYSOUT=A.\nThe primary dataset has just become active, thus the secondary\nlog is the one that is copied.  In brief, the log back-up is fired\noff when the DSI546I or DSI547I message is issued - the\nmessage has the following format:\n\n       DSI546I PRIMARY NETVIEW DATASET IS NOW ACTIVE.\n\nThe message automation member DSIMSG01 is searched and a\nmatch should occur with the above 'IF' statements.  The\nEXECMD executes the CLIST specified within brackets, in\nthis case LOGPRIM, which in turn submits the job to copy or\nprint the log.\n\nS M Thomas\nConsultant (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N001A12": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00k\\x00k\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 107, "newlines": 107, "modlines": 0, "user": "SNAUPDT"}, "text": "A VTAM application front-end program\n\nWith the increasing interest in reducing the amount of operator\nintervention in the daily operation of the machine, it is rather\nannoying when applications (such as TSO) fail to start at IPL\ntime because they start before the network has initialized.  In\nmany cases (such as TSO) the operators are prompted to make\nsome kind of reply when the network is  up.  In some cases,\nthe application simply abends and the operators have to restart\nit.  With this in mind, I set about writing a simple routine\nwhich could 'front end' any VTAM application which would\nwait for VTAM to become active before allowing the\napplication to try to initialize.\n\nWAITAPPL is the result of this exercise.  It is executed with\nthe name of the VTAM ACB to be waited for as the EXEC\nPARM.  WAITAPPL will attempt to open the ACB.  If the\nACB opens, WAITAPPL closes it and then exits, allowing the\napplication to start.  If the ACB does not open, WAITAPPL\nwaits for ten seconds before retrying.  In order to stop\nWAITAPPL endlessly waiting for an ACB which  may never\nopen, I have limited the total time it will wait to ten minutes.\nThis covers the case where there is a genuine problem which\nstops the ACB ever becoming active.  In this case WAITAPPL\nends with a return code of 4.\n\nTo use WAITAPPL, you should code the following JCL\nstatement immediately before the step which will require the\nselected ACB:\n\n       //WAITAPPL  EXEC  PGM=WAITAPPL,PARM='applname'\n\nwhere applname is the name of the ACB to be waited for.  For\nexample, our TSO start-up procedure now consists of:\n\n//TSO     PROC MBR=TSOKEYP1\n//* WAIT UPTO 10 MINUTES FOR PTSOD TO BECOME AVAILABLE.\n//STEP1   EXEC PGM=WAITAPPL,PARM='PTSOD'\n//STEP2   EXEC PGM=IKTCAS00,TIME=1440,COND=EVEN\n//PARMLIB  DD  DSN=SYS1.PARMLIB(&MBR),DISP=SHR,FREE=CLOSE\n//PRINTOUT DD  SYSOUT=*,FREE=CLOSE\n//*\n\n\nWAITAPPL SOURCE CODE\n\nWAITAPPL CSECT\n         STM   R14,R12,12(R13)     Save callers registers\n         LR    R12,R15             Setup r12 as the base address\n         USING WAITAPPL,R12        and address the rest of the module\n         LA    R11,SAVEAREA        Befine our save area\n         ST    R13,4(,R11)         Store backward pointer\n         ST    R11,8(,R13)         Store forward pointer\n         LR    R13,R11             and conform to standards\n         L     R1,0(,R1)           Load pointer to EXEC parm\n         CLC   =H'0',0(R1)         Is there a parm ?\n         BE    NOPARM              no - then use default application\n         LH    R2,0(,R1)           otherwise - get parm length\n         CH    R2,=H'8'            Is parm more than 8 chars ?\n         BNH   *+8                 no - then continue round\n         LA    R2,8                otherwise - for max. length\n         STC   R2,APPLID           Save length of appl name\n         BCTR  R2,R0               -1 for move\n         EX    R2,MOVEAPPL         and move application name\n         LA    R3,60               Iteration counter. (This is the\n*                                  number of 10 second wait periods\n*                                  before we abort the job).\n*                                  eg  6 = 60 seconds or 1 minute\n*                                     60 = 360 seconds, 10 minutes\nNOPARM   MVC   OPENWTO1+44(8),APPLID+1     Add application name\n         MVC   OPENWTO2+26(8),APPLID+1     to the user messages\n         MVC   OPENWTO3+26(8),APPLID+1\n         WTO   MF=(E,OPENWTO1)     Tell 'em we're waiting\nWAITOPEN OPEN  THEACB              Try to open ACB\n         LTR   R15,R15             Did it open ?\n         BZ    OPENOK              yes - application is available\n         BCT   R3,WAIT             no - maybe wait a little\n         WTO   MF=(E,OPENWTO3)     Tell 'em we're aborting\n         L     R13,4(,R13)         Unavailable, end the prog. with\n         RETURN (14,12),RC=4       a return code of 4\nWAIT     STIMER WAIT,DINTVL=PAUSE  Wait for a while (10 seconds)\n         B      WAITOPEN           and retry the open\nOPENOK   CLOSE THEACB              Close the now open ACB\n         WTO   MF=(E,OPENWTO2)     Tell 'em it opened OK\n         L     13,4(,R13)          Return to MVS with an RC of 0\n         RETURN (14,12),RC=0\n*  Executed move - This instruction moves the application name\n*                  from the EXEC \"PARM\" field to the application\n*                  name field pointed to by the ACB.\nMOVEAPPL MVC   APPLID+1(*-*),2(R1)\nOPENWTO1 WTO   'WAITAPPL: Waiting for VTAM application: ........ ',  XXX\n               MF=L\nOPENWTO2 WTO   'WAITAPPL: Application ........ now available. ',     XXX\n               MF=L\nOPENWTO3 WTO   'WAITAPPL: Application ........ unavailable - aborting',X\n               MF=L\nSAVEAREA DC    18F'0'\nAPPLID   DC    X'03',CL8'TSO '\nTHEACB   ACB   AM=VTAM,APPLID=APPLID\nPAUSE    DC    C'00001000'           10 second pause period.\n         END\n\n\nS A Barnett\nSenior Technical Consultant\nIMI Computing Ltd (UK)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N002A00I": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 14, "newlines": 14, "modlines": 0, "user": "SNAUPDT"}, "text": "N002 -SNA Update Issue #02  June 1991\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nN002A01   Validating VTAM ACBs\nN002A02   Implementing IBM 5866 modems\nN002A03   USS tables and the buffer operand\nN002A04   An introductory look at pacing\nN002A05   A VTAM batch application-terminal interface\nN002A06   Getting started with LU6.2\nN002A07   VTAM dynamic reconfiguration\nN002A08   SNA request/response formatter\nN002A09   Network performance management tools\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N002A01": {"ttr": 1550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\xfe\\x00\\xfe\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 254, "newlines": 254, "modlines": 0, "user": "SNAUPDT"}, "text": "Validating VTAM ACBs\n\nThe following routine, ACBTEST, has been written to validate\na VTAM Access method Control Block (ACB) before allowing\na VTAM application, such as TSO, to open it.  It is intended\nthat this program is executed as the first step of a job or started\ntask before the job control required to start the application.\n\nThe program is passed the name of the ACB that is required by\nthe subsequent application.  ACBTEST, after validating that an\nACB name has been supplied, attempts to open it.  If the open\nis OK, ie register 15 is set to zero, the program terminates\nnormally and the application is started.  However, if the open\nfails, control is passed to code that determines the cause of the\nfailure.  When an open ACB macro fails, VTAM sets register\n15 accordingly and places an error code in the ACB.  By\nexecuting the SHOWCB macro one can extract the error code\nand subsequently determine the cause of the problem.\n\nACBTEST examines this error code and depending upon its\nmeaning, will behave in one of two ways:\n\n1      If the error is deemed irrecoverable (for instance if VTAM\n      is in the process of closing), the program issues a message\n      indicating the ACB name, the error code, and a brief\n      description of the failure.  It then abends the task with a\n      user code equal to the error code extracted from the ACB.\n      In this case the subsequent application does not start.\n\n2      If the error is deemed recoverable (for instance if an ACB\n      is not active), the program issues a message similar to that\n      above and executes a STIMER to wait for 15 seconds\n      before attempting to re-open.  When the open is eventually\n      successful, a message to the operator informs him of\n      success and the application is started.\n\n\nSAMPLE JCL TO EXECUTE THE PROGRAM\n\n//ACBTEST  JOB ACCT#,ACBTEST,\n//      CLASS=A,MSGCLASS=U,MSGLEVEL=(1,1)\n//TESTIT EXEC PGM=ACBTEST,PARM='ACBNAME'\n//SYSUDUMP DD SYSOUT=U\n//*\n//TSO   PROC MBR=TSOKEY00\n//STEP1 EXEC PGM=IKTCAS00,TIME=1440\n//PARMLIB DD DSN=SYS1.PARMLIB(&MBR),DISP=SHR,FREE=CLOSE\n//PRINTOUT DD SYSOUT=U,FREE=CLOSE\n\n\nACBTEST SOURCE CODE\n\nACBTEST  CSECT\n         TITLE 'ACBTEST TEST ROUTINE'\n         PUSH  USING\n         USING *,15                    TEMPORARY BASE REG\n         B     ENTRY000                LETS START THE CODE\n         POP   USING\n* PARMS   : PASS THIS PROGRAM THE NAME OF AN ACB.                     *\n* USAGE : IT IS INTENDED THAT THIS PROGRAM IS EXECUTED AS THE 1ST     *\n*         STEP IN A JOB TO CHECK THAT THE ACB FOR A SUBSEQUENT        *\n*         TP SYSTEM IS OK.                                            *\n*         THIS PROGRAM SHOULD ONLY BE EXECUTED IN BATCH OR AS PART OF *\n*         A STARTED TASK.                                             *\n* DESCRIPTION : THIS PROGRAM IS PASSED A VTAM ACB NAME TO OPEN.       *\n*               THE OPEN MACRO IS EXECUTED AND THE RETURN CODE (R15)  *\n*               IS CHECKED.  IF THE RC IS NON ZERO THEN THE PROGRAM   *\n*               BRANCHES AND EXAMINES VTAM CONTROL BLOCKS TO          *\n*               DETERMINE THE REASON.  MESSAGES ARE ISSUED TO THE     *\n*               OPERATORS CONSOLE TO REVEAL THE CAUSE OF THE ERROR.   *\n*               IF THE ERROR IS DEEMED NON RECOVERABLE THEN THE       *\n*               PROGRAM ABENDS, THE ABEND CODE IS THE HEX REASON CODE *\n*               OBTAINED FROM VTAM.  IF THE ERROR IS RECOVERABLE THEN *\n*               THE PROGRAM WAITS FOR 10 SECONDS AND ATTEMPTS TO OPEN *\n*               THE ACB AGAIN.  IF THE OPEN IS SUCCESSFUL THEN THE    *\n*               ACB IS CLOSED AND THE PROGRAM TERMINATES.             *\n* NOTE: THIS PROGRAM DOES NOT CATER FOR ALL REASON CODES. A GENERAL   *\n*        USER ABEND WILL OCCUR IF THE SPECIFIC CODE IS NOT CHECKED FOR*\n* NOTE: FOR A COMPREHENSIVE LIST OF REASON CODES REFER TO             *\n*        'OPEN - OPEN ONE OR MORE ACBS' IN VTAM PROGRAMMING           *\n*         (SC23-0115).                                                *\nACBTEST  CSECT\n*              ENTRY ROUTINE                                          *\nENTRY000 DS    0H\n         STM   R14,R12,12(R13)         SAVE CALLERS REGISTERS\n         LR    R12,R15                 LOAD BASE REGISTER\n         USING ACBTEST,R12             ESTABLISH BASE REGISTER\n         LA    R0,WORKLEN              PICK UP WORKING STORAGE LENGTH\n         LR    R9,R1                   SAVE PARM POINTER\n         GETMAIN R,LV=(R0)             GET WORK STORAGE\n         ST    R13,4(R1)               STORE ADDRESS OF CALLERS REGS\n         LR    R13,R1                  PICK UP NEW REGISTER SAVE AREA\n         USING WORKAREA,R13            ESTABLISH WORKAREA BASE REGISTER\n*              START OF USEFUL CODE                                   *\nBEGIN    EQU   *                    INITIAL PROCESSING\n         LR    R4,R9                  GET ADDRESS OF PARM LIST\n         L     R4,0(R4)               LOAD ADDRESS OF PARM LIST\n         LH    R3,0(R4)               GET LENGTH OF PARM\n         EX    R3,EXECPLAT            EXECUTE TO MOVE PARMS INTO PROG\n         SLR   R3,R3                  ZEROIZE\n         IC    R3,ACBLEN              LOAD PARM COUNT\n         CH    R3,=H'00'              HAVE THEY ENTERED AN ACB NAME\n         BNE   CONTINUE               OK? THEN CARRY ON\n         WTO   'YOU HAVE NOT ENTERED AN ACB NAME'\n         ABEND 888,DUMP               INFORM USER AND ABEND\nCONTINUE EQU   *                    CARRY ON\n         SLR   R10,R10                ZEROIZE\n         IC    R10,ACBLEN             GET LENGTH OF ACB\n         LA    R11,WTOACB1            GET ADDRESS OF WTOACB1\n         LA    R9,WTOACB              GET ADDRESS OF WTOACB\n         MVC   0(R10,R9),ACBNAME      MOVE ACB TO BOTH\n         MVC   0(R10,R11),ACBNAME           FIELDS\n         B     OPENPGM\nOK2WAIT  EQU   *                    WAIT BEFORE RETRYING OPEN\n         STIMER WAIT,DINTVL=WAITTIME\nOPENPGM  EQU   *                    TRY TO OPEN ACB\n         OPEN  INQACB                 ATTEMPT TO OPEN ACB\n         LTR   15,15                  CHECK R/C\n         BNZ   WHYNOT                 BRANCH IF NOT ABLE TO OPEN\n         WTO   RCODE,MF=(E,WTOPLAT1)  TELL OP THAT OPEN WAS OK\nCLOSE    EQU   *                    OK CLOSE AND EXIT\n         CLOSE INQACB                 ISSUE CLOSE\n*              QUIT BIT                                               *\nANEXIT   EQU   *                    RESTORE AND EXIT\n         LA    R0,WORKLEN              PICK UP WORKING STORAGE LENGTH\n         LR    R1,R13                  PICK UP WORKING STORAGE ADDRESS\n         L     R13,REGSAVE+4           PICKUP CALLER'S SAVE AREA\n         FREEMAIN R,LV=(R0),A=(R1)     FREE WORKING STORAGE\n         L     R14,12(R13)             RESTORE R14\n         LM    R0,R12,20(R13)          RESTORE R0 THROUGH R12\n         BR    R14                     RETURN TO CALLER\n*              ATTEMPT TO FIND OUT WHY THE ACB WAS NOT OPENED         *\nWHYNOT   EQU   *                    FIND OUT WHY THE OPEN FAILED\n         SHOWCB ACB=INQACB,FIELDS=ERROR,AREA=TESTAREA,LENGTH=4,        C\n               AM=VTAM                GET REASON FROM ACB\n         SLR   R3,R3                  ZEROIZE\n         L     R3,TESTAREA            PUT REASON IN REG 3\nNOVTAM   CH    R3,=H'80'            NO VTAM IN OS\n         BNE   VTAMHALT\n         MVC   RCODE,RC50         MOVE REASON CODE TO TEMPLATE\n         WTO   RCODE,MF=(E,WTOPLATE)  ISSUE THE ERROR MESSAGE\n         WTO   'VTAM HAS NOT BEEN INCLUDED AS PART OF THE'\n         WTO   'OPERATING SYSTEM'\n         ABEND 050                    ABEND WITH THE REASON CODE\nVTAMHALT CH    R3,=H'82'            VTAM HALT HAS BEEN ISSUED\n         BNE   NOTANACB\n         MVC   RCODE,RC52\n         WTO   RCODE,MF=(E,WTOPLATE)\n         WTO   'VTAM HAS RECEIVED A HALT COMMAND'\n         WTO   'AND IS NOT ACCEPTING OPENS'\n         ABEND 052\nNOTANACB CH    R3,=H'86'            NOT AN APPL\n         BNE   ANOTHACB\n         MVC   RCODE,RC56\n         WTO   RCODE,MF=(E,WTOPLATE)\n         WTO   'THE ACB SPECIFIED IS NOT AN APPL'\n         ABEND 056\nANOTHACB CH    R3,=H'88'            ANOTHER APPL HAS OPENED ACB\n         BNE   NOACB\n         MVC   RCODE,RC58\n         WTO   RCODE,MF=(E,WTOPLATE)\n         WTO   'THE ACB SPECIFIED IS ALREADY OPEN'\n         ABEND 058\nNOACB    CH    R3,=H'90'            ACB NOT ACTIVE OR DOES NOT EXIST\n         BNE   SVTAM\n         MVC   RCODE,RC5A\n         WTO   RCODE,MF=(E,WTOPLATE)\n         WTO   'THE ACB SPECIFIED IS NOT ACTIVE OR'\n         WTO   'DOES NOT EXIST'\n         WTO   'SO I AM GOING TO WAIT FOR IT'\n         B     OK2WAIT\nSVTAM    CH    R3,=H'92'            VTAM NOT STARTED\n         BNE   STRANGE\n         MVC   RCODE,RC5C\n         WTO   RCODE,MF=(E,WTOPLATE)\n         WTO   'VTAM HAS NOT BEEN STARTED'\n         WTO   'I AM GOING TO WAIT FOR IT'\n         B     OK2WAIT\nSTRANGE  CH    R3,=H'96'            SYSTEM ERROR OCCURRED\n         BNE   PPOPROB\n         MVC   RCODE,RC60\n         WTO   RCODE,MF=(E,WTOPLATE)\n         WTO   'A STRANGE SYSTEM ERROR HAS OCCURRED'\n         ABEND 060\nPPOPROB  CH    R3,=H'104'           TOO MANY PPO AUTHD APPLS\n         BNE   APPLCLOS\n         MVC   RCODE,RC68\n         WTO   RCODE,MF=(E,WTOPLATE)\n         WTO   'ONLY 1 PPO AUTHORIZED APPL MAY BE ACTIVE'\n         WTO   'AT ONE TIME'\n         ABEND 068\nAPPLCLOS CH    R3,=H'112'           APPL IS IN PROCESS OF CLOSING\n         BNE   GODKNOWS\n         MVC   RCODE,RC70\n         WTO   RCODE,MF=(E,WTOPLATE)\n         WTO   'THE ACB IS CURRENTLY BEING CLOSED'\n         B     OK2WAIT\nGODKNOWS EQU   *                    MUST BE SOMETHING ELSE!!\n         WTO   'OPEN ACB FAILED BUT I DONT KNOW WHY!!'\n         ABEND 999,DUMP\n*              CONSTANTS AND WORKING STORAGE                          *\nINQACB   ACB   AM=VTAM,                VTAM ACB                        C\n               APPLID=PARMIN,          PROGRAM NAME                    C\n               MACFR=NLOGON\n* ACB NAME TO BE OPENED POINTED TO BY ACB MACRO\nPARMIN   DS    0CL9                    ACB NAME PASSED AS A PARM\nACBLEN   DC    C'0'                    LENGTH OF ACB\nACBNAME  DC    C'        '             ACB NAME\n* TEMPLATE FOR WTO MACRO TO REFER TO\nWTOPLATE DS    0F\n          DC    AL2(57)\n          DC    B'000000000000000'\n          DC    C'OPEN FAILED WITH REASON CODE = '\nRCODE     DC    C'00'\n          DC    C'  FOR ACB = '\nWTOACB    DC    C'        '\n* TEMPLATE FOR WTO MACRO TO REFER TO\nWTOPLAT1 DS    0F\n          DC    AL2(38)\n          DC    B'000000000000000'\n          DC    C'OPEN SUCCESSFUL FOR ACB = '\nWTOACB1   DC    C'        '\n* TEMPLATE FOR EXECUTE INSTRUCTION\nEXECPLAT  MVC  PARMIN(*-*),1(R4)\nTESTAREA DS    F                       ERROR FIELD FROM SHOWCB INSTRUCT\n* ERROR CODES FOR ACB OPEN PUT OUT IN WTO\nRC00     DC    C'00'\nRC50     DC    C'50'\nRC52     DC    C'52'\nRC56     DC    C'56'\nRC58     DC    C'58'\nRC5A     DC    C'5A'\nRC5C     DC    C'5C'\nRC60     DC    C'60'\nRC68     DC    C'68'\nRC70     DC    C'70'\n* CONSTANTS FOR STIMER\nWAITTIME DS    OD                     SPECIFY TIME TO WAIT BEFORE\nWAITHOUR DC    C'00'                   RETRYING TO OPEN ACB AFTER A\nWAITMINS DC    C'00'                   FAILURE.\nWAITSECS DC    C'15'\n         DC    C'00'\n*              VARIOUS INLINE LITERALS                                *\n         LTORG ,\n* DSECT FOR REGISTERS\nWORKAREA DSECT\nREGSAVE  DS    18F                     PLACE TO STORE REGISTERS\nWORKLEN  EQU   *-WORKAREA\n         END\n\n\nDuncan A Tait\nSystems Programmer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N002A02": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x03\\x10\\x03\\x10\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 784, "newlines": 784, "modlines": 0, "user": "SNAUPDT"}, "text": "Implementing IBM 5866 modems\n\nA little while ago, I began a project to decrease network\nexpenses, while maintaining or improving the response time, at\na major wholesale distribution company.  The network\nconsisted of more than 20 remote cluster controllers on 13\ndigital 9600 BPS lines, with the primary VTAM application\nbeing IDMS DB/DC.  The cluster controllers were spread\nsparsely throughout the USA, so no effective concentration\ncould be achieved.\n\nThe first step of the project was to gather statistics on the\nmessages flowing through the network.  A program was written\nto read NPM session data records, print reports, and archive\nthe records.  NPM session data records can be collected by\nadding a SESSCOLL APPL statement for each VTAM\nAPPLID in the NPM start-up parameters.  Specifying session\ncollection by APPLID avoids the tedious task of entering a\nrecord for each LINE and PU.  The report used for this project\nlisted PIU counts and average message sizes for each PU.  The\nprogram also produced a summary report including the\nmaximum byte count for each PU on a given day.  The\nmaximum byte and PIU counts were used in the network model\nto represent peak utilization.  Another interesting report\nproduced by this program lists all the PUs with a response time\nexceeding a given threshold - a response time exception report.\n\nAn exit was written for Levi Ray and Shoup Inc's VTAM\nPrinter Support System (VPS).  The exit program, VPSSUE07,\nmoved fields JSTVBYTE (number of bytes sent) and\nJSTVSEND (number of VTAM sends) from the VPS job\nstatistics DSECT to the SMF type 6 record field SMF6UIF.\nThis field is normally initialized to blanks by VPS.  A SAS\nprogram was then written to read the SMF type 6 records\nproduced by VPS and print a report.  This data was used in the\nnetwork model to represent the amount of batch (printer) data\nversus interactive data.\n\nA SAS program was also written to analyze the task statistics\nrecords produced by IDMS to determine the message size mix\nof all the interactive traffic.  The purpose here was to\ndetermine what percentage of the messages fell into given\nmessage size categories.\n\nThe data gathered was modelled using several different\npackages.  The network that was implemented closely matched\nthe output from IBM's Topology Overview Pricing Analysis\nSystem (TOPAS).  The TOPAS program estimated line cost,\nutilization, and response time for the proposed network.  The\nmodel's predictions have proved to be correct over the last two\nyears in production.  The key, of course, is to provide the\nmodel with accurate data.\n\nA proposal was submitted to purchase IBM 14.4 KBPS model\n5866 modems.  The modems were 1.5 times faster than the\nexisting modems.  This enabled the number of multi-drop lines\nto be reduced from 13 lines to nine.  A test line was installed\nwhich performed as expected, both in line quality and response\ntime.  The network was then converted to the IBM modems\nand analogue lines in two phases.  Half of the existing circuits\nwere converted in each step.  The cancellation dates for the\nexisting circuits were two weeks after the installation dates of\nthe analogue lines.  During the two week overlap, all the\ninstallation problems were solved, without exception.  The\nproposed network paid for the line installation and overlap\ncharges and the modems in six and a half months.  The first\nyear saving was $40,000 after expenses and $60,000 the\nsecond year.\n\nThere has been no increase in network outages since going\nback to analogue from the digital network.  We do, however,\nmonitor the analogue lines closely, using NPM's on-line\ndisplays and customized NPM reports.  If the line errors\nincrease, the circuit is turned over to AT&T for line tests.  The\ndiagnostic capabilities of the IBM 5866 modems are sound.\nThis enables network control to give AT&T a good indication\nof the line problem.  An easy way to get a report of the lines\nwith excessive errors is to sort the NPM log file.  Include only\nrecords for output with the error field greater than a given\nthreshold number, then run the IBM-supplied NPM log report\nagainst the sorted output file.\n\nThe final step in implementing this network was the installation\nof dial back-up hardware and NetView CLISTs to support dial\nback-up.  A two-call dial back-up coupler was installed in each\nof the remote 5866 modems.  A pool of 5866 modems with\ndial back-up couplers installed at the host site is used to back\nup all the remote cluster controllers.\n\nThe tasks of the dial back-up CLISTs are to manage the pool of\nlocal dial back-up modems, dynamically reconfigure a dial\nback-up line to match the PU that is down, issue the modem\ndial command, activate the dial back-up PU, and deactivate the\nPU on the leased line.  It is important to deactivate the PU on\nthe leased line.  If other PUs on the line are still active, NCP\nwill send out SNRMs and wait for a response until the reply\ntimeout value has been reached.  This would tie up the line for\nproductive work.  There must also be CLISTs to bring down\nthe dial back-up PU, hang up the phone, and so forth.\n\nThe implemented CLISTs use global variables to keep track of\nthe modem pool, store the telephone numbers (the telephone\nnumbers are actually task variables), and other variables.  The\nproblem with global variables, however, is that there is no\ncheckpoint facility for the variables within NetView.  If\nNetView crashed with PUs in dial back-up, the global variables\nwould have to be set up with a recovery CLIST, requiring\nmanual intervention.  Since NetView has been very reliable\nand the system is on a UPS, I have not had this problem occur.\nI had hoped that NetView Release 3 would address this issue,\nbut it did not.  The REXX language available with release 3\ndoes allow file I/O so the variables can be written to a file and\nrecovered at start up.\n\nOne other problem I had with global variables is that they can\nonly be updated by the PPT.  The IBM method of using\nmessage automation to cause the PPT to update the variable is\nvery slow.  There is also a problem in that, if the user is an\nauthorized message receiver, the message automation method\nof setting global variables does not work.  The CLISTs,\nSETGB and SETGBPPT, eliminate the need to use message\nautomation to set the global variables.\n\nWhen the dial back-up CLISTs were written, VTAM Version\n3.2 was not available.  The CLISTs depend on a dynamic\nreconfiguration member being in a VTAMLST PDS for each\nPU, for each line in the modem pool.  It is a tedious task to set\nup and maintain all these reconfiguration members.  It is,\nhowever, very fast when the CLIST runs, much faster than\nrunning a program to look at NCP and add the members on the\nfly.  The MOVE command with VTAM Version 3.2 solves this\nproblem nicely, giving the ability to move a  PU from one line\nto another.  The CLISTs presented here have not been changed\nto take advantage of the MOVE command, however.\n\nThe dial back-up CLISTs can be used to automate the dial\nback-up process using NetView's message automation facility.\nThe CLISTs were written with this in mind even though we\nchose not to implement automatic dial back-up at this\ninstallation.  The message, BNJ146I, is issued by the hardware\nmonitor if NCP cannot establish LPDA contact with the remote\nmodem.  Make sure the hardware monitor filters are coded to\nallow the BNJ146I message to be generated.  The default for\nthe operator filter is block, which will prevent the message\nfrom being generated.  Create an entry in the message\nautomation table to invoke the dial back-up CLISTs for\nmessage BNJ146I and token nine equal '1A', passing the\nvariables needed for the CLIST execution extracted from the\nmessage text.\n\nThere are several things to be aware of when using timer\ncommands within NetView.  When a timer command is issued,\nit runs within the operator task where the command is issued,\neven if the command is issued in a CLIST, or in the PPT if\nPPT is specified in the command.  The dial back-up CLISTs\nuse timer commands to disconnect the dial back-up lines\nautomatically at a certain time.  It is necessary that this occurs\neven if the operator that started the dial back-up CLIST is no\nlonger signed on.  Running the disconnect CLIST in the PPT\nwill not work since there are commands in the CLIST which\ncannot be executed in the PPT.  It would not be desirable to\nuse the PPT even if this were not the case since the CLIST\nwould tie up the PPT and possibly cause tasks to queue,\nwaiting for the PPT.\n\nThe dial back-up CLIST uses the EXCMD command, which\nallows a CLIST to be executed under a different operator task,\nin conjunction with the timer commands when a time-related\nfunction is to be performed.  An auto-operator, AUTO3, is\ndefined specifically for dial back-up and the disconnect CLIST\nruns under this operator-id.  This id will always be logged on\nand there is not a problem with queueing since AUTO3 is used\nfor nothing but dial back-up.  The idea of using different auto\noperator-ids for different tasks is an important one.  This\nshould be done if message automation is used to automate\noperations to prevent the CLISTs from queueing under one\noperator task.\n\nThere are also CLISTs to test dial back-up for each of the\nremote modems.  The dial back-up test CLISTs are run once a\nweek and the network operator checks the log to make sure that\nall the modems are connected properly.  The tests are\nscheduled to run by the CLIST in the early morning.\n\nAll in all this project has been extremely successful.  The\nresponse time has been predictable during the two years since\nthe network was installed.  The modems have been reliable:\nthere has not been a single modem failure causing loss of\nservice.  A modem was replaced because it would lose its\noptions with a power loss but this was not a disruptive\nproblem.  The original network model has proved accurate.\nThe intent was to configure a network which would not have to\nbe changed for traffic reasons for two years - this has been\nachieved.  The network operators are pleased with the ease of\ndial back-up, modem diagnostics, etc, provided with NetView\nand the NetView CLISTs.\n\n\nIDB001\n\n* CLIST TO PUT A PU IN DIAL BACKUP\n&CONTROL ERR\n&IF .&1 NE .HELP &THEN &GOTO -NOHELP\n&WRITE\n&WRITE >>>> PLACE A BRANCH IN DIAL BACKUP\n&WRITE >>>> ENTER IDB XX OR IDB XX YY WHERE XX IS BRANCH\n&WRITE >>>> AND YY IS DB LINE. CLIST WILL PICK DB LINE IF\n&WRITE >>>> YY IS NOT ENTERED. ENTER IDI XX TO DISCONNECT.\n&WRITE\n&GOTO -END\n-NOHELP\n* DEFINE CLIST VARIABLES\n&BRANCH  = &1\n&LINEPRM = &2\n* DEFINE GLOBAL VARIABLES\n&CGLOBAL NCPNAME\n&CGLOBAL NETCNTL\n&CGLOBAL DBLNO\n* DEFINE TASK VARIABLES\n&TGLOBAL PH1\n&TGLOBAL PH2\n&IF .&NCPNAME NE . &THEN &GOTO -NCPSET\n* IF NCP NAME NOT SET SET THE GLOBAL VARIABLE\nNCPNAME\n-NCPSET\n&IF .&DBLNO NE . &THEN &GOTO -BEGIN\n* SET GLOBAL VARIABLES FOR DIAL BACKUP CLISTS\n&WAIT 'EXCMD PPT,IDB005 &OPID',+\n     DSI039I=-BEGIN,*10=-ERROR,*ERROR=-ERROR\n-BEGIN\nCLEAR\n* VALIDATE BRANCH VARIABLE\n&LN = &LENGTH &BRANCH\n&IF &LN NE 2  &THEN &GOTO -BRERR\n* DEFINE THE LINE VARIABLES AND MAKE SURE BRANCH NOT IN DB\n&LNO = 1\n-LNLP01\n&CGLOBAL DBLN&LNO\n&IF &DBLN&LNO EQ &BRANCH &THEN &GOTO -BRERR2\n&LNO = &LNO + 1\n&IF &LNO > &DBLNO &THEN &GOTO -PHONES\n&GOTO -LNLP01\n-PHONES\n* SET UP PHONE NUMBER VARIABLE\nIDB008 &BRANCH\n&IF &PH1 = ERROR &THEN &GOTO -BRERR\n&GOTO -GOTPHONE\n-BRERR\n&WRITE\n&WRITE >>>> ERROR THE FIRST PARAMETER SHOULD BE BRANCH NUMBER\n&WRITE >>>> ERROR ENTER A VALID TWO CHARACTER BRANCH NUMBER\n&WRITE\n&GOTO -END\n-BRERR2\n&WRITE\n&WRITE >>>> ERROR BRANCH &BRANCH IS ALREADY IN DIAL BACKUP\n&WRITE\n&GOTO -END\n-GOTPHONE\n&LN = &LENGTH &LINEPRM\n* SEE IF THE OPERATOR PICKED A LINE TO USE\n&IF &LN NE 0 &THEN &GOTO -LINEPRM\n* IF THE OPERATOR DIDN'T PICK A LINE FIND ONE NOT IN USE\n* WHEN A FREE LINE IS FOUND MARK IT USED WITH GLOBAL VARIABLE\n&LNO = 1\n-LNLP02\n&IF &DBLN&LNO NE N &THEN &GOTO -ADD01\nSETGB DBLN&LNO TO &BRANCH\n&LINEPRM = &LNO\n&GOTO -GOTLINE\n-ADD01\n&LNO = &LNO + 1\n&IF &LNO > &DBLNO &THEN &GOTO -BUSY\n&GOTO -LNLP02\n-BUSY\n&WRITE\n&WRITE >>>> ALL DIAL BACKUP LINES ARE BUSY\n&WRITE\n&GOTO -END\n-LINEPRM\n* VALIDATE THE LINE NUMBER FROM THE OPERATOR\n* MAKE SURE IT'S NOT IN USE AND MARK IT USED\n&IF &LN > 1 &THEN &GOTO -LNERR\n&IF &LINEPRM < 1 &THEN &GOTO -LNERR\n&IF &LINEPRM > &DBLNO &THEN &GOTO -LNERR\n&IF &DBLN&LINEPRM NE N &THEN &GOTO -INUSE\nSETGB DBLN&LINEPRM TO &BRANCH\n&GOTO -GOTLINE\n-INUSE\n&WRITE\n&WRITE >>>> LINE &LINEPRM IS IN USE PICK ANOTHER\n&WRITE\n&GOTO -END\n-LNERR\n&WRITE\n&WRITE >>>> ERROR THE SECOND PARM MUST BE LINE NUMBER OR BLANK\n&WRITE >>>> ERROR ENTER 1 - &DBLNO FOR LINE NUMBER WITH NO ZEROS\n&WRITE\n&GOTO -END\n-GOTLINE\n* BUILD VARIABLES FOR VTAM COMMANDS\n&LN = &CONCAT LINEDB &LINEPRM\n&DUMPU = &CONCAT PUDBO &LINEPRM\n&LPU = &CONCAT PU &BRANCH\n&DPU = &CONCAT &LPU I\n&DS = &CONCAT IDB &BRANCH\n&DS = &CONCAT &DS &LINEPRM\n&WRITE\n&WRITE >>>>>> START DIAL BACKUP ON &LN FOR &LPU DATE: &DATE,\n&WRITE >>>>>> TIME: &TIME, DIALING NUMBERS &PH1 AND &PH2\n&WRITE\n* KNOCK DOWN THE PU ON THE LEASED LINE\nVARY NET,INACT,ID=&LPU,F\n* ACTIVATE THE DYNAMIC RECONFIG MEMBER\n&WAIT 'V NET,DRDS,ID=&DS',+\n    IST670I=-END03,*60=-ERROR,*ERROR=-ERROR\n-END03\n* ACTIVATE THE DIAL BACKUP LINE AND PUS\n&WAIT 'V NET,ACT,ID=&LN,SCOPE=ALL',+\n   IST093I=-END04,*60=-ERROR,*ERROR=-ERROR\n-END04\n* INACT THE DUMMY PU TO STOP SNRMS\nV NET,INACT,ID=&DUMPU\n* ISSUE THE MODEM COMMAND TO DIAL THE PHONE NUMBERS\n&WAIT 'MDMCNTL ID=&NCPNAME,STATION=&DPU,CONNECT=(&PH1,&PH2)',+\n   DSI268I=-OK01,DSI421I=-BAD01,*300=-BAD01,*ERROR=-ERROR\n-BAD01\n&WRITE\n&WRITE >>>>>> DIAL BACKUP ON &LN FOR &LPU FAILED  !!!!!!!\n&WRITE\n* UNDO ALL THE DYNAMIC RECONFIGURATONS\nIDB002 &BRANCH\n&GOTO -END\n-OK01\n* START A TIMER TASK IN AUTO3 TO REMIND NET CONTROL THE\n* LINE IS IN DIAL BACKUP AND TAKE DOWN LINES AND EOD IF STILL UP\nEXCMD AUTO3 IDB007\n* MESSAGE TO NET CONTROL LINE IS IN DIAL BACKUP\nMSG &NETCNTL,>>>>> DIAL BACKUP &LPU AT: &TIME\n&GOTO -END\n-ERROR\n&WRITE\n&WRITE >>>>  ERROR IN CLIST IDB001 TIMEOUT\n&WRITE\n-END\n&WRITE COMMAND COMPLETE\n\n\nIDB002\n\n* CLIST TO TAKE PU OUT OF DIAL BACKUP\n&CONTROL ERR\n&IF .&1 NE .HELP &THEN &GOTO -NOHELP\n&WRITE\n&WRITE >>>> TAKE PU OUT OF DIAL BACKUP\n&WRITE >>>> ENTER IDI XX WHERE XX IS BRANCH NUMBER.\n&WRITE\n&GOTO -END\n-NOHELP\n* SET CLIST VARIABLES\n&BRANCH  = &1\n* DEFINE GLOBAL VARIABLES\n&CGLOBAL NCPNAME\n&CGLOBAL DBLNO\n&CGLOBAL NETCNTL\n&IF .&NETNCTL NE . &THEN &GOTO -GLOBSET\n&WRITE\n&WRITE >>>> NO ONE IN DIAL BACKUP OR NETVIEW HAS BEEN CYCLED\n&WRITE\n&GOTO -END\n-GLOBSET\n&IF .&NCPNAME NE . &THEN &GOTO -NCPSET\nNCPNAME\n-NCPSET\nCLEAR\n* VALIDATE OPERATOR INPUT (INPUT COULD BE FROM TIMER TASK)\n&LN = &LENGTH &BRANCH\n&IF &LN NE 2  &THEN &GOTO -BRERR\n* FIND THE LINE THE PU IS USING AND RESET TO NOT IN USE\n* DEFINE THE LINE VARIABLES\n&LNO = 1\n-LNLP01\n&CGLOBAL DBLN&LNO\n&IF &DBLN&LNO NE &BRANCH &THEN &GOTO -ADD01\n&LINENO = &LNO\nSETGB DBLN&LNO TO N\n&GOTO -GOTLINE\n-ADD01\n&LNO = &LNO + 1\n&IF &LNO > &DBLNO &THEN &GOTO -BRERR2\n&GOTO -LNLP01\n-GOTLINE\n* BUILD VARIABLES FOR VTAM COMMANDS\n&LN = &CONCAT LINEDB &LINENO\n&WPU = &CONCAT PU &BRANCH\n&DBPU = &CONCAT &WPU I\n&DS = &CONCAT IDI &BRANCH\n&DS = &CONCAT &DS &LINENO\n&GOTO -DISCON\n-BRERR\n&WRITE\n&WRITE >>>> ERROR THE 1ST PARM MUST BE LINE NUMBER, 2ND BRANCH\n&WRITE >>>> ERROR ENTER A VALID TWO CHARACTER BRANCH NUMBER\n&WRITE\n&GOTO -END\n-BRERR2\n&WRITE\n&WRITE >>>> ERROR PU &BRANCH IS NOT IN DIAL BACKUP\n&WRITE >>>> ERROR ENTER A VALID TWO CHARACTER BRANCH NUMBER\n&WRITE\n&GOTO -END\n-DISCON\n&WRITE\n&WRITE >>>>>> DISCONNECT DIAL BACKUP ON &LN FOR &WPU\n&WRITE >>>>>> DATE: &DATE TIME: &TIME\n&WRITE\n* ISSUE MODEM COMMAND TO DISCONNECT THE PHONE\nMDMCNTL ID=&NCPNAME,STATION=&DBPU,DISCONN\n* DEACTIVATE THE DIAL BACKUP PU AND LINE\n&WAIT 'V NET,INACT,ID=&DBPU,F',+\n   IST105I=-END03,*60=-ERROR,*ERROR=-ERROR\n-END03\n&WAIT 'V NET,INACT,ID=&LN,F',+\n    IST105I=-END04,*60=-ERROR,*ERROR=-ERROR\n-END04\n* DYNAMICALLY RECONFIGURE THE DIAL BACKUP LINE DELETE BACKUP PU\nVARY NET,DRDS,ID=&DS\n* ACTIVATE THE LEASED LINE PU\nVARY NET,ACT,ID=&WPU,SCOPE=ALL\n&WRITE COMMAND COMPLETE\nMSG &NETCNTL,>>>>> DIAL DISCONNECT &WPU AT: &TIME\n&GOTO -END\n-ERROR\n&WRITE ** ERROR IN CLIST IDB002 CONTACT SYSTEMS **\n-END\n\n\nIDB003\n\n* CLIST TO REMIND NET CNTL A PU IS IN DIAL BACKUP\n&CONTROL ERR\n&CGLOBAL MSGTIME\n&CGLOBAL NETCNTL\n&CGLOBAL DBLNO\n* FIND THE LINE IN DIAL BACKUP\n* DEFINE THE LINE VARIABLES\n&DB = N\n&LNO = 1\n-LNLP01\n&CGLOBAL DBLN&LNO\n&IF &DBLN&LNO = N &THEN &GOTO -ADD01\nMSG &NETCNTL,>>>>> PU &DBLN&LNO IN DIAL BACKUP ON LINE &LNO\n&DB = Y\n-ADD01\n&LNO = &LNO + 1\n&IF &LNO > &DBLNO &THEN &GOTO -CONT01\n&GOTO -LNLP01\n-CONT01\n* IF ANYONE IS IN DIAL BACKUP SET THE CLIST UP TO RUN AGAIN\n&IF &DB = N &THEN &GOTO -END\n&TID = &CONCAT ID3 &TIME\nEVERY &MSGTIME,PPT,ID=&TID,DELAY2 &TID 'IDB003'\n-END\n\n\nIDB005\n\n&CONTROL ERR\n* CLIST TO DEFINE DIAL BACKUP GLOBAL VARIABLES\n* CLIST MUST RUN IN PPT\n&REQSTER = &1\n* NETWORK CONTROL'S OPERATOR ID\n&CGLOBAL NETCNTL\n&NETCNTL = NETOP1\n* SET TIME INTERVALS TO REMIND NET CONTROL OF LINES IN DB\n&CGLOBAL MSGTIME\n&MSGTIME = 00:15\n* SET TIME OF DAY TO DISCONNECT DB LINES\n&CGLOBAL DISTIME\n&DISTIME = 19:30\n* SET THE NUMBER OF DIAL BACKUP LINES AVAILABLE\n&CGLOBAL DBLNO\n&DBLNO = 2\n* SET FLAG IDB007 HAS NOT BEEN RUN\n&CGLOBAL IDB007X\n&IDB007X = N\n* DEFINE LINE VARIABLES AND SET TO N\n&LNO = 1\n-LNLP01\n&CGLOBAL DBLN&LNO\n&DBLN&LNO = N\n&LNO = &LNO + 1\n&IF &LNO > &DBLNO &THEN &GOTO -CONT01\n&GOTO -LNLP01\n-CONT01\nMSG &REQSTER,VARIABLES SET BY CLIST IDB005\n\n\nIDB006\n\n* CLIST TO DISCONNECT LINES AT THE END OF THE DAY\n&CONTROL ERR\n* DEFINE THE GLOBAL VARIABLES\n&CGLOBAL NETCNTL\n&CGLOBAL DBLNO\n* TELL NETWORK CONTROL\nMSG &NETCNTL.>>>>> SCAN BACKUP LINES: &DATE &TIME\n* IF THE LINE IS IN USE RUN IDB002 TO DISCONNECT PASS PU NUMBER\n&LNO = 1\n-LNLP01\n&CGLOBAL DBLN&LNO\n&IF &DBLN&LNO = N &THEN &GOTO -ADD01\nIDB002 &DBLN&LNO\n-ADD01\n&LNO = &LNO + 1\n&IF &LNO > &DBLNO &THEN &GOTO -CONT01\n&GOTO -LNLP01\n-CONT01\n* RESET GLOBAL VARIABLE SO IDB006 CAN BE SCHEDULED TO RUN AGAIN\n&CGLOBAL IDB007X\nSETGB IDB007X TO N\n\n\nIDB007\n\n*CLIST SET UP TIMER CLISTS IN AUTO3 AND PPT\n&CONTROL ERR\n&CGLOBAL MSGTIME\n&CGLOBAL DISTIME\n&CGLOBAL IDB007X\n&WRITE STARTING DIAL BACKUP TIMER TASKS AT: &TIME\n* START A TIMER TASK TO REMIND NET CONTROL THE\n* LINE IS IN DIAL BACKUP\n&IF &IDB007X = Y &THEN &GOTO -TMRGOING\n* AFTER &MSGTIME RUN CLIST IDB003 AND PURGE TIMER\nEVERY &MSGTIME,PPT,ID=IDB003,DELAY2 IDB003 'IDB003'\n* SET TIMER TO RUN CLIST TO TAKE DOWN DIAL BACKUP LINES\nAT &DISTIME,ID=IDB006,IDB006\n* SET IDB007X TO Y ONLY START ONE MESSAGE TIMER LOOP\nSETGB IDB007X TO Y\n-TMRGOING\n\n\nIDB008\n\n&CONTROL ERR\n* CLIST TO PUT A PU IN DIAL BACKUP\n* ADD NEW BRANCHES TO THIS CLIST AND CLIST IDB900 (DIAL BACKUP TEST)\n&BRANCH = &1\n* DEFINE TASK GLOBAL VARIABLES\n&TGLOBAL PH1\n&TGLOBAL PH2\n* SET UP PHONE NUMBER VARIABLE\n&IF &BRANCH NE 01 &THEN &GOTO -NT01\n&PH1 = 19999999999\n&PH2 = 19999999998\n&GOTO -GOTPHONE\n-NT01\n&IF &BRANCH NE 02 &THEN &GOTO -NT02\n&PH1 = 19998888888\n&PH2 = 19998888887\n&GOTO -GOTPHONE\n-NT02\n&WRITE >>>> THERE IS NOT A PHONE NUMBER DEFINED FOR &BRANCH IN IDB008\n&PH1 = ERROR\n-GOTPHONE\n\n\nIDBTEST\n\n* CLIST SET TIMER TASK TO RUN DIAL BACKUP TEST\n&CONTROL ERR\n&TSTTIME = 03:00\n&IF .&1 NE .HELP &THEN &GOTO -NOHELP\n&WRITE\n&WRITE >>>> TEST DIAL BACKUP LINES\n&WRITE >>>> ENTER IDBTEST ALL LINES WILL BE TESTED AT &TSTTIME\n&WRITE >>>> ENTER IDBTEST XX AND BRANCH XX TESTED NOW\n&WRITE\n&GOTO -END\n-NOHELP\n* IF OPER ENTERS A BRANCH NUMBER TEST ONE BRANCH NOW\n&BRANCH = &1\n&IF .&BRANCH NE . &THEN &GOTO -TESTONE\n* IF PARM NOT ENTERED TEST ALL BRANCHES IN THE AM\nAT &TSTTIME,ID=IDB900,EXCMD AUTO3,IDB900\n&WRITE DIAL BACKUP TEST SCHEDULED FOR &TSTTIME\n&GOTO -END\n-TESTONE\nIDB901 &BRANCH\n-END\n\n\nIDB900\n\n* CLIST TO TEST DIAL BACKUP NUMBERS\n&CONTROL ERR\n&WRITE >>>>>> IDB900 DIAL BACKUP TEST BEGIN : &DATE &TIME\n&LN = LINEDB1\n&BRANCH = 23\nIDB901 &BRANCH\n&BRANCH = 33\nIDB901 &BRANCH\n&BRANCH = 01\nIDB901 &BRANCH\n\n      etc\n\nV NET,INACT,ID=&LN,F\n&WRITE >>>>>> DIAL BACKUP TEST COMPLETE : &DATE &TIME\n\n\nIDB901\n\n* CLIST TO TEST DIAL BACKUP...DIAL THE NUMBERS\n&CONTROL ERR\n&BRANCH = &1\n&LN = LINEDB1\n&DPU = PUDB01\n* DEFINE GLOBAL VARIABLES\n&CGLOBAL NCPNAME\n&TGLOBAL PH1\n&TGLOBAL PH2\n* GET THE PHONE NUMBERS TO DIAL\nIDB008 &BRANCH\n&IF &PH1 = ERROR &THEN &GOTO -END\n&IF .&NCPNAME NE . &THEN &GOTO -NCPSET\n* IF NCP NAME NOT SET SET THE GLOBAL VARIABLE\nNCPNAME\n-NCPSET\nCLEAR\n* ACTIVATE DIAL BACKUP LINE\n&WAIT 'V NET,ACT,ID=&LN,SCOPE=ALL',+\n   IST093I=-END01,*10=-ERROR,*ERROR=-ERROR\n-END01\n&WAIT 'MDMCNTL ID=&NCPNAME,STATION=&DPU,CONNECT=(&PH1,&PH2)',+\n   DSI268I=-OK01,DSI421I=-BAD01,*300=-BAD01,*ERROR=-ERROR\n-BAD01\n&WRITE >>>>>> ERROR DIALING BRANCH &BRANCH &PH1 &PH2\n&GOTO -END\n-OK01\n&WRITE >>>>>> TEST FOR BRANCH &BRANCH SUCCESSFUL\n&WAIT 'MDMCNTL ID=&NCPNAME,STATION=&DPU,DISCONN',+\n   DSI268I=-DS01,*300=-ERROR,*ERROR=-ERROR\n-DS01\n&GOTO -END\n-ERROR\n&WRITE\n&WRITE >>>>>>  ERROR IN CLIST IDB901 TIMEOUT\n&WRITE\n-END\n\n\nIDB999\n\n&CONTROL ERR\n* CLIST TO DEFINE DIAL BACKUP GLOBAL VARIABLES\n* CLIST MUST RUN IN PPT\n&REQSTER = &1\n* NETWORK CONTROL'S OPERATOR ID\n&CGLOBAL NETCNTL\n&NETCNTL = NETOP1\n* SET TIME INTERVALS TO REMIND NET CONTROL OF LINES IN DB\n&CGLOBAL MSGTIME\n&MSGTIME = 00:15\n* SET TIME OF DAY TO DISCONNECT DB LINES\n&CGLOBAL DISTIME\n&DISTIME = 19:30\n* SET THE NUMBER OF DIAL BACKUP LINES AVAILABLE\n&CGLOBAL DBLNO\n&DBLNO = 2\n* SET FLAG IDB007 HAS NOT BEEN RUN\n&CGLOBAL IDB007X\n&IDB007X = N\n* DEFINE LINE VARIABLES AND SET TO N\n&LNO = 1\n-LNLP01\n&CGLOBAL DBLN&LNO\n&DBLN&LNO = N\n&LNO = &LNO + 1\n&IF &LNO > &DBLNO &THEN &GOTO -CONT01\n&GOTO -LNLP01\n-CONT01\n&DBLN1 =  31\nMSG &REQSTER,VARIABLES SET BY CLIST IDB999\n\n\nSETGB\n\n&CONTROL ERR\n* CLIST TO SET A GLOBAL VARIABLE\n* THIS CLIST KEEPS YOU FROM HAVING TO USE MESSAGE AUTOMATION WHICH\n* IS SLOWER AND DOESN'T WORK FOR AUTHORIZED MESSAGE RECEIVERS.\n* COMMAND SETGB VARIABLE TO VALUE\n&VNAME = &1\n&VALUE = &3\n&WAIT 'EXCMD PPT,SETGBPPT &VNAME &VALUE &OPID',+\n     DSI039I=-END03,*10=-ERROR,*ERROR=-ERROR\n-END03\n&EXIT\n-ERROR\n&WRITE >>>>  ERROR NO RESPONSE FROM PPT TO SET VARIABLE\n&EXIT 8\n\n\nSETGBPPT\n\n&CONTROL ERR\n* CLIST TO SET A GLOBAL VARIABLE\n* THIS CLIST MUST RUN IN PPT\n&GBNAME = &1\n&VALUE = &2\n&REQSTER = &3\n&CGLOBAL &GBNAME\n&&GBNAME = &VALUE\nMSG &REQSTER,VARIABLE &GBNAME SET TO &VALUE\n\n\nNCPNAME\n\n&CONTROL ERR\n* CLIST TO SET GLOBAL VARIABLE FOR NCP NAME SO OPERATOR DOESN'T\n* HAVE TO ENTER IT AND THERE IS ONLY ONE PLACE TO CHANGE IT WHEN\n* NCP CHANGES.\n&CGLOBAL NCPNAME\nSETGB NCPNAME TO NCP002\n\n\nVTAM DEFINITIONS FOR DIAL BACKUP\n\n TITLE 'IBM DIAL BACKUP LINES DYNAMICALLY RECONFIGURED'\nLINEDB1  LINE  ADDRESS=003,                                           X\n               LPDATS=LPDA2,                                          X\n               ISTATUS=INACTIVE,                                      X\n               OWNER=MVSSA,                                           X\n               SPEED=9600,                                            X\n               MAXPU=6,                                               X\n               NEWSYNC=NO\n         SERVICE ORDER=(PUDB01),                                      X\n               MAXLIST=6\nPUDB01   PU    ADDR=D0,                                               X\n               ISTATUS=INACTIVE,                                      X\n               PUDR=YES\nLUDB01   LU    LOCADDR=02\nLINEDB2  LINE  ADDRESS=005,                                           X\n               LPDATS=LPDA2,                                          X\n               ISTATUS=INACTIVE,                                      X\n               OWNER=MVSSA,                                           X\n               SPEED=9600,                                            X\n               MAXPU=6,                                               X\n               NEWSYNC=NO\n         SERVICE ORDER=(PUDB02),                                      X\n               MAXLIST=6\nPUDB02   PU    ADDR=D1,                                               X\n               ISTATUS=INACTIVE                                       X\n\n\nIDB011\n\nIDB01DR  VBUILD TYPE=DR\n         ADD   TO=LINEDB1\nPU01I    PU    ADDR=C1                                                X\n               DLOGMOD=RMT32782,MODETAB=CMSMODET,                     X\n               USSTAB=CMSRMUS4\nCHI02I   LU    LOCADDR=02\nCHI03I   LU    LOCADDR=03\n\n      and similarly for CHI04I to CHI22I\n\nCHI23I   LU    LOCADDR=23\nCHIPRT1B LU    LOCADDR=24,VPACING=0,PACING=0,DLOGMOD=RMT328XP\nCHIPRT2B LU    LOCADDR=25,VPACING=0,PACING=0,DLOGMOD=RMT328XP\n\n\nIDI011\n\nIDI01DR  VBUILD TYPE=DR\n         DELETE FROM=LINEDB1\nPU01I    PU    ADDR=C1\n\n\nEric Roch\nLead Systems Programmer (USA)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N002A03": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00(\\x00(\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 40, "newlines": 40, "modlines": 0, "user": "SNAUPDT"}, "text": "USS tables and the buffer operand\n\nIn the past it has always been possible to define the VTAM\nUnformatted System Services (USS) tables so that a 'welcome'\nmessage is displayed when a terminal is activated.  The advent\nof software products to perform as VTAM front ends has seen\nUSS table usage decline.\n\nFor people who still use USS tables IBM has addressed\nproblems that have existed since the tables were first designed.\nIn the past you could define a single-line 'welcome' message\nthat contained the terminal name of the device where the\nmessage was displayed.  This was very useful as it meant that\nlabels did not have to be placed on terminals.  It also meant\nthat when hardware was replaced or re-plugged the new\nterminal name would automatically be displayed.  When a user\ncontacted the help desk they immediately knew what their\nterminal number was and the network operator could then\nresolve the problem quickly.  It was also possible to define a\nUSS table that issued a buffer to the terminal that it was\nassociated with.  This buffer normally consisted of some sort of\ncompany logo.  The only drawback with this method was that\nyou could not display the terminal name as part of the buffer.\nThis led to all sorts of problems when a user contacted the help\ndesk.\n\nIBM has APARs detailing PTFs that can be used to resolve this\nproblem.  The APARs in question are OY24252, OY27028,\nand OY34983.  These APARs detail how PTFs UY50226,\nUY50228, UY55731, and UY55732 can be used to allow you\nto display a terminal name as part of a USS buffer screen.\n\nWe have implemented these changes to our USS tables and\nfind that user contact with the help desk is less confusing when\ntrying to determine what terminal the user is trying to access.\n\n\nJohn Bradley\nTechnical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N002A04": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00j\\x00j\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 106, "newlines": 106, "modlines": 0, "user": "SNAUPDT"}, "text": "An introductory look at pacing\n\nPacing is an SNA mechanism for controlling the flow of data\nbetween components in the network.  Without such a\nmechanism it would be possible for the sending Logical Unit\n(LU) to inundate the receiving LU with more data than it could\neffectively handle in situations when the sender is able to\ntransmit data faster than the receiver can store or process it.\nThis can lead to serious buffer shortages and can easily impact\nthe performance of the entire network.  This article examines\nthe two major types of pacing available.  It looks at how they\nare specified and describes how they are implemented.\n\nThe two major types of pacing available are session level\npacing and virtual route pacing.  The underlying technique\nused by both is essentially the same.\n\n\nSESSION LEVEL PACING\n\nSession level pacing is normally based on using a fixed counter\nto control the data flow.  This changed to a degree with the\nintroduction of adaptive pacing in VTAM 3.2 and NCP 4.3.\nAdaptive pacing enables the pacing window size to be set\ninitially to 1 and then adjusted dynamically based on the rate of\ntraffic and the availability of network resources.  Currently,\nadaptive pacing is confined to LU6.2 sessions.\n\nFor other than LU6.2 sessions, the pacing window size is\nestablished at session initiation time and is determined,\nprimarily, by values specified in the LOGMODE table (in the\nPSNDPAC, SRCVPAC, SSNDPAC, and PRCVPAC\nparameters) or, secondly, in the PACING and VPACING\nparameters in the LU, PU, LINE, or GROUP definitions.\nValues in the LOGMODE tables override the PACING and\nVPACING settings.\n\nThere are basically two types of session level pacing: one stage\npacing and two stage pacing.  Quite simply, one stage pacing\ntakes place directly between two LUs on an end-to end basis,\nwhile in two stage pacing the data flow is regulated, firstly\nbetween one LU and an intermediate boundary node, such as\nVTAM or the NCP, and secondly between the boundary node\nand the second LU.  VTAM itself uses the network\nconfiguration to determine whether one or two stage pacing\nshould occur.\n\nOnce a pacing value has been agreed upon between the sender\nand the receiver, the sender can issue that many requests, but\nno more, without receiving a pacing response.  The pacing\nresponse is sent by the receiver when it is in a position to\naccept another series of requests.  The pacing response can be\nreturned to the sender either in a response to a previous request\nor as a special response known as an Isolated Pacing Response\n(IPR).  This of course would mean that a pacing value of 1\nwould force a response for every request sent (similar to\noperating in definite response mode) and could have very\nserious performance implications for devices that do not\nnormally run in definite response mode.\n\nIt is generally recommended that a relatively high pacing value\nshould be set between the sender and boundary function, with\nthe value between the boundary function and receiver being\ndetermined by the characteristics of the receiving device type.\nSpecifying pacing values in the LOGMODE table(s) is\npreferable since this method will override any network\ndefinitions and will greatly simplify network maintenance and\nperformance tuning by restricting the number of places in\nwhich pacing specifications can be defined.\n\n\nVIRTUAL ROUTE PACING\n\nThe values to be used to implement virtual route pacing are\nspecified as the minimum and maximum window sizes used for\ndata transmission and are coded in the VRPWSvp parameter of\nthe PATH macro, where v is the virtual route number and p\ndenotes the transmission priority (ie 0 for low priority, 1 for\nmedium, and 2 for high).  The window size is maintained\ndynamically between the specified limits.  The default for the\nminimum window size is equal to the number of Transmission\nGroups (TGs) in the Explicit Route (ER) associated with the\nVirtual Route (VR).\n\nThe current window size is initially set at the value defined by\nthe minimum window size and a counter is set equal to the\ncurrent window size.  After each message is sent, the counter is\ndecreased by 1 and transmission continues until this counter\nreaches 0 or until a normal VR pacing response is received.  In\nthe latter case, since no congestion has been detected, the\ncounter is incremented by the current window size value and a\nnew series of transmissions begins.\n\nIf congestion is detected, the fact will be signalled to the sender\nin the VR pacing response and will result in the current\nwindow size being decremented by 1 (providing it is not equal\nto the minimum window size).  This process will be repeated\nuntil the congestion is cleared or until the current window size\nequals the minimum window size.\n\nSuitable values for VRPWS are dependent on the network\nconfiguration.  An analysis of the data flow across virtual\nroutes needs to be undertaken so that the existing settings can\nbe assessed for their suitability.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N002A05": {"ttr": 2060, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x02\\x18\\x02\\x18\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 536, "newlines": 536, "modlines": 0, "user": "SNAUPDT"}, "text": "A VTAM batch application-terminal interface\n\nCommunication between a VTAM terminal (display or printer)\nand an application program is not only a task for CICS.  The\nfollowing code shows how a batch print program uses a VTAM\nprinter terminal.  The interface routine can also be used for\nother terminals.  The device-dependent data stream will and\nmust be handled from the calling program.\n\n\nINTERFACE ROUTINE\n\nVPRT     TITLE 'VBAMPRT  -  VTAM BATCH PRINT MODULE   '\n         PUNCH '   CATALR VBAMPRT  '\nVBAMPRT  CSECT\n         SAVE  (14,12)\n         LR    R3,R15\n         USING VBAMPRT,R3\n         B     BEGIN\n         DC    CL8'VBAMPRT'            PROGRAM NAME\n         DC    C' V.1.0 '              VERSION\n         DC    C'&UDATE '              DATE OF ASSEMBLY\n         DC    C'&UTIME '              TIME OF ASSEMBLY\nBEGIN    DS    0H\n         ST    R13,SAVEAREA+4          SAVE ADDR PREVIOUS SAVEAREA\n         LR    R2,R13                  SAVE REG 13\n         LA    R13,SAVEAREA            POINT TO OWN SAVEAREA\n         ST    R13,8(R2)               CHAIN TO PREVIOUS SAVEAREA\n         L     R10,0(R1)               LOAD PARAMETER ADDR\n         ST    R10,PARMADDR            SAVE PARAMETER ADDR FOR EXIT USE\n         USING VPRTUACB,R10\n         XC    VPRTERR,VPRTERR         CLEAR ERROR FIELD\n*  ANALYSE PARAMETERS      *\nPARMCHK  DS    0H\n         CLC   =C'SEND',VPRTFUNC       SEND REQUESTED\n         BE    SEND                    YES - DO IT\n         CLC   =C'OPEN',VPRTFUNC       OPEN REQUESTED\n         BE    OPEN                    YES - DO IT\n         CLC   =C'CLOS',VPRTFUNC       CLOSE REQUESTED\n         BE    CLOSE                   YES - DO IT\n*  RC  WRONG FUNCTION CODE\n         LA    R15,255\n         B     RETURN                  RETURN TO CALLER\n*  OPEN VTAM ACB AND OPNDST REQUEST FOR PRINTER (SLU)      *\nOPEN     DS    0H\n*  ANALYZE CALL PARM FOR MODCB (APPLID/PASSWD)\n         CLI   VPRTAPPL,C' '      APPLID IN URCB\n         BNH   OPENACB                 NO - SKIP MODCB ACB\n         MVC   APPLID,VPRTAPPL         MOVE APPLICATION ID\n         MVI   APPLIDL,X'08'           SET LENGTH\n         MODCB AM=VTAM,ACB=VTMACB,APPLID=APPLIDL\n         LTR   R15,R15                 TEST RETURN CODE\n         BZ    CHKPWD                  ZERO -- OK\n         MVC   VPRTMAC,=CL8'MODCB 1'\n         STC   R0,VPRTRC0              STORE ERROR CODE\n         B     RETURN                  RETURN TO CALLER\nCHKPWD   DS    0H\n         CLI   VPRTPWRD,C' '           PASSWD IN URCB\n         BNH   OPENACB                 NO - SKIP MODCB ACB\n         MVC   PASSWD,VPRTPWRD         MOVE PASSWORD\n         MVI   PASSWDL,X'08'           SET LENGTH\n         MODCB AM=VTAM,ACB=VTMACB,PASSWD=PASSWDL\n         LTR   R15,R15                 TEST RETURN CODE\n         BZ    OPENACB                 ZERO -- OK\n         MVC   VPRTMAC,=CL8'MODCB 2'\n         STC   R0,VPRTRC0              STORE ERROR CODE\n         B     RETURN                  RETURN TO CALLER\nOPENACB  DS    0H\n         OPEN  VTMACB\n         LTR   R15,R15                 TEST RETURN CODE\n         BZ    SLOGON                  ZERO -- OK\n         MVC   VPRTMAC,=CL8'OPEN'\n         MVC   VPRTRC0,VTMACB+ACBERFLG-IFGACB ERROR FLAG\n         B     RETURN                  RETURN TO CALLER\nSLOGON   DS    0H\n         SETLOGON OPTCD=START,                                         *\n               ACB=VTMACB,                                             *\n               RPL=VTMRPL\n         LTR   R15,R15                 TEST RETURN CODE\n         BZ    SLOGONOK                ZERO -- OK\n         MVC   VPRTMAC,=CL8'SETLOGON'\n         STC   R0,VPRTRC0              STORE RET CODE\n         B     RETURN                  RETURN TO CALLER\nSLOGONOK DS    0H\n*  MODIFY NIB WITH SLU-NAME FOR OPNDST\n         LA    R2,VPRTSLUN             LOAD SLU NETNAME ADDR\n         MODCB AM=VTAM,NIB=VTMNIB,NAME=(*,0(R2))\n         LTR   R15,R15                 TEST RETURN CODE\n         BZ    OPNDST                  ZERO -- OK\n         MVC   VPRTMAC,=CL8'MODCB 3'\n         STC   R0,VPRTRC0              STORE ERROR CODE\n         B     RETURN                  RETURN TO CALLER\nOPNDST   DS    0H\n* * *    OPNDST OPTCD=(ACQUIRE,SYN),                                   *\n               SIMLOGON OPTCD=(SYN,CONANY,Q,RELRQ),                    *\n               ACB=VTMACB,                                             *\n               RPL=VTMRPL,                                             *\n               NIB=VTMNIB\n         LTR   R15,R15                 TEST RETURN CODE\n         BZ    SENDBB                  ZERO -- OK\n* * *    MVC   VPRTMAC,=CL8'OPNDST'\n         MVC   VPRTMAC,=CL8'SIMLOGON'\n         STC   R0,VPRTRC0              STORE ERROR CODE\n         MVC   VPRTFDBK,VTMRPL+RPLFDBK-IFGRPL MOVE RPL FEEDBACK\n         MVC   VPRTSENS,VTMRPL+RPLFDBK2-IFGRPL MOVE RPL SENSE\n         B     RETURN                  RETURN TO CALLER\nSENDBB   DS    0H\n         WAIT  LOGONECB      WAIT FOR LOGON COMPLETE\n*  SEND BEGIN BRACKET\n         SEND  RPL=VTMRPL,                                             *\n               STYPE=REQ,                                              *\n               CONTROL=DATA,                                           *\n               AREA=BRACKMSG,                                          *\n               RECLEN=2,                                               *\n               BRACKET=(BB,NEB),                                       *\n               OPTCD=(SYN),                                            *\n               RESPOND=(NEX,FME,NRRN),      MUST BE FOR 3270 PRINTER   *\n               POST=RESP\n         LTR   R15,R15                      TEST RETURN CODE\n         BZ    RETURN                       ZERO -- OK\n         MVC   VPRTMAC,=CL8'SEND'\n         STC   R0,VPRTRC0                   STORE ERROR CODE\n         MVC   VPRTFDBK,VTMRPL+RPLFDBK-IFGRPL   MOVE RPL FEEDBACK\n         MVC   VPRTSENS,VTMRPL+RPLFDBK2-IFGRPL  MOVE RPL SENSE\n         B     RETURN                       RETURN TO CALLER\n*  SEND REQUEST UNIT TO SLU      *\nSEND     DS    0H\n         XR    R2,R2\n         LH    R2,VPRTDATL\n         MODCB AM=VTAM,                                                *\n               RPL=VTMRPL,                                             *\n               AREA=(S,VPRTDATA),                                      *\n               RECLEN=(R2)\n         LTR   R15,R15                      TEST RETURN CODE\n         BZ    SENDREQ                      ZERO -- OK\n         MVC   VPRTMAC,=CL8'MODCB 5'\n         STC   R0,VPRTRC0                   STORE ERROR CODE\n         B     RETURN                       RETURN TO CALLER\nSENDREQ  SEND  RPL=VTMRPL,                                             *\n               STYPE=REQ,                                              *\n               CONTROL=DATA,                                           *\n               BRACKET=(NBB,NEB),                                      *\n               OPTCD=(SYN),                                            *\n               RESPOND=(NEX,FME,NRRN),      MUST BE FOR 3270 PRINTER   *\n               POST=RESP\n         LTR   R15,R15                      TEST RETURN CODE\n         BZ    RETURN                       ZERO -- OK\n         MVC   VPRTMAC,=CL8'SEND'\n         STC   R0,VPRTRC0                   STORE ERROR CODE\n         MVC   VPRTFDBK,VTMRPL+RPLFDBK-IFGRPL MOVE RPL FEEDBACK\n         MVC   VPRTSENS,VTMRPL+RPLFDBK2-IFGRPL MOVE RPL SENSE\n         B     RETURN                       RETURN TO CALLER\n*  RELEASE SLU AND CLOSE VTAM ACB      *\nCLOSE    DS    0H\n         MVI   TPENDFLG,X'FF'\n*  SEND END BRACKET\n         SEND  RPL=VTMRPL,                                             *\n               STYPE=REQ,                                              *\n               CONTROL=DATA,                                           *\n               AREA=BRACKMSG,                                          *\n               RECLEN=2,                                               *\n               BRACKET=(NBB,EB),                                       *\n               OPTCD=(SYN),                                            *\n               RESPOND=(NEX,FME,NRRN),      MUST BE FOR 3270 PRINTER   *\n               POST=RESP\n         LTR   R15,R15                      TEST RETURN CODE\n         BZ    CLSDST                       ZERO -- OK\n         MVC   VPRTMAC,=CL8'SEND'\n         STC   R0,VPRTRC0                   STORE ERROR CODE\n         MVC   VPRTFDBK,VTMRPL+RPLFDBK-IFGRPL MOVE RPL FEEDBACK\n         MVC   VPRTSENS,VTMRPL+RPLFDBK2-IFGRPL MOVE RPL SENSE\n         B     RETURN                       RETURN TO CALLER\nCLSDST   CLSDST RPL=VTMRPL,                                            *\n               ACB=VTMACB,                                             *\n               NIB=VTMNIB,                                             *\n               OPTCD=(SYN,RELEASE)\n         LTR   R15,R15                      TEST RETURN CODE\n         BZ    CLOSEACB                     ZERO -- OK\n         MVC   VPRTMAC,=CL8'CLSDST'\n         MVC   VPRTRC0,VTMACB+ACBERFLG-IFGACB ERROR FLAG\n         B     RETURN                       RETURN TO CALLER\nCLOSEACB DS    0H\n         CLOSE VTMACB\n         LTR   R15,R15                      TEST RETURN CODE\n         BZ    RETURN                       ZERO -- OK\n         MVC   VPRTMAC,=CL8'CLOSE'\n         MVC   VPRTRC0,VTMACB+ACBERFLG-IFGACB  ERROR FLAG\n         B     RETURN                       RETURN TO CALLER\nRETURN   DS    0H\n         L     R13,SAVEAREA+4               GET REQUIRED SAVEAREA ADDR\n         L     R14,12(R13)                  LOAD RETURN ADDR\n         RETURN (0,12)\n*  CONSTANTS/AREAS/LITERALS      *\nAPPLIDL  DS    X\nAPPLID   DS    CL8\nPASSWDL  DS    X\nPASSWD   DS    CL8\nTPENDFLG DS    X\nBRACKMSG DC    X'F140'       COMMAND=WRITE, WCC=RESET\nPARMADDR DS    F\nLOGONECB DC    F'0'\nSAVEAREA DS    18F\n         LTORG\n*  VTAM CONTROL BLOCKS      *\n*  VTAM ACB\nVTMACB  ACB   AM=VTAM,                                                 *\n               EXLST=VTMEXLST,                                         *\n               MACRF=LOGON,                                            *\n               PARMS=(NIB=VTMNIB,USERFLD=C'VPRT')\n*  VTAM EXIT LIST\nVTMEXLST EXLST AM=VTAM,                                                *\n               TPEND=TPENDEX,                                          *\n               LOGON=LOGONEX,                                          *\n               LOSTERM=LOSTRMEX\n*  VTAM NODE INITIALIZATION BLOCK\nVTMNIB NIB                                                             *\n               MODE=RECORD,                                            *\n               USERFLD=C'VPRT',                                        *\n               LISTEND=YES\n*  VTAM REQUEST PARAMETER LIST\nVTMRPL   RPL   AM=VTAM,                                                *\n               ACB=VTMACB,                                             *\n               NIB=VTMNIB,                                             *\n               OPTCD=ANY\n***NAME = LOGON EXIT ROUTINE                                        ***\n*  EVENT = AN APPLICATION PROGRAM IS BEING REQUESTED TO               *\n*  ESTABLISH A SESSION AS A PRIMARY LOGICAL UNIT.                     *\n*  FUNCTION = ESTABLISH A SESSION AND SEND A 'LOGON ACCEPTED'         *\n*  MESSAGE TO ANY LOGICAL UNIT THAT LOGS ON CORRECTLY.                *\n*  ENTRY POINT = LOGONEX                                              *\n*  INPUT                                                              *\n*   REGS   0    = UNPREDICTABLE                                       *\n*          1    = POINTER TO A 6-WORD PARAMETER LIST                  *\n*          2-13 = UNPREDICTABLE                                       *\n*          14   = RETURN ADDRESS TO ACF/VTAM                          *\n*          15   = ENTRY ADDRESS OF THIS ROUTINE                       *\n*   PARAMETER LIST - 6 WORDS                                          *\n*          1    = ACB ADDRESS                                         *\n*          2    = POINTER TO SYMBOLIC NAME OF LOGICAL UNIT            *\n*          3    = ZEROS (USED AT SIMLOGON)                            *\n*          4    = LENGTH OF LOGON MESSAGE                             *\n*          5    = ADDRESS OF READ-ONLY RPL                            *\n*          6    = CID OF PENDING ACTIVE SESSION                       *\n*  OUTPUT                                                             *\n*   A REQUEST TO VTAM TO ACCEPT OR REJECT THE SESSION.                *\n*  EXTERNAL REFERENCES = MODCB, OPNDST, CLSDST, DUMP                  *\n*  EXIT, NORMAL = BR 14                                               *\n*  EXIT, ABNORMAL = DUMP                                              *\n***ATTRIBUTES = REENTRANT                                           ***\n         DC    C'LOGONEX'           EYECATCHER\nLOGONEX  DS    0H\n         USING *,R12  ESTABLISH ADRESSABILITY\n         LR    R12,R15              LOAD ENTRY ADDR TO BASE\n         L     R3,=V(VBAMPRT)       GET MAINLINE BASE ADDR\n         USING VBAMPRT,R3           BASE\n         TM    TPENDFLG,X'FF'       IS CLOSE ACB IN PROGRESS\n         BOR   R14                  YES, ALLOW CLOSE TO REJECT LOGONS\n         LR    R6,R1                SAVE PARAMETER LIST ADDRESS\n         L     R8,0(R6)             PICK UP ACB ADDRESS\n         LA    R13,LOGONSAV         LOAD MACRO SAVEAREA ADDRESS\n         ST    R14,LOGONR14         SAVE RETURN ADDRESS TO VTAM\n         L     R5,4(R6)             GET ADDR SLU NAME WHO LOGON\n         L     R10,PARMADDR         GET ADDR CALLERS PARAMETER\n         USING VPRTUACB,R10\n         MODCB AM=VTAM,RPL=LOGONRPL,                                   *\n               ACB=(R8)\n         LTR   R15,R15              TEST RETURN CODE\n         BNZ   LOGONDMP             NOT ZERO -- DUMP\n         LA    R9,LOGONRPL\n         LA    R7,LOGONNIB\n         USING IFGRPL,R9\n         USING ISTDNIB,R7\n         MVC   NIBSYM,0(R5)\n         MVC   NIBCID,20(R6)        SET CID IN LOGON NIB\n         MVC   RPLUSFLD,4(R5)       PUT USER FIELD IN OPNDST RPL ...\n*                                   VTAM DOES NOT SET IT ON OPNDST\n*  THE ABOVE MVC IS USEFUL IF OPTCD=ASY USED. NOTE THAT IT CANNOT\n*   BE DONE WITH MODCB.\n*  IS IT THE REQUIRED SLU\n         CLC   VPRTSLUN,0(R5)\n         BNE   DISCONN\n*  ESTABLISH A SESSION WITH THE LOGICAL UNIT\nCONNECT  OPNDST RPL=LOGONRPL,OPTCD=(SYN,ACCEPT,CA)\n** IF THE OPNDST FAILS, DO NOT ATTEMPT CLSDST AS THAT WILL DRIVE LERAD\n         POST  LOGONECB             POST FOR LOGON COMPLETE\n         LA    R9,VTMRPL\n         MODCB AM=VTAM,RPL=(R9),ARG=(*,NIBCID)         CID IN SEND RPL\n         B     LOGONRET\n*  TERMINATE THE SESSION\n*   IT MIGHT BE BETTER TO SEND A REJECTION MESSAGE TO THE VTAM\n*   OPERATOR BEFORE CLOSING.\nDISCONN  DS    0H\n         CLSDST RPL=LOGONRPL,OPTCD=SYN\n*  IF CONTROL RETURNS HERE THERE IS NO NEED TO TEST FOR SUCCESS OR\n*  FAILURE SINCE LERAD OR SYNAD COPE WITH FAILURE.\n         B     LOGONRET             IF SO, BRANCH TO RETURN\nLOGONRET DS    0H\n         L     R14,LOGONR14         RESTORE REG 14\n         BR    R14                  RETURN TO VTAM\nLOGONDMP ST    R1,LOGONR1           SAVE THE CONTENTS OF REG 1\n         DUMP\nLOGONRPL RPL   AM=VTAM,NIB=LOGONNIB\nLOGONNIB NIB   MODE=RECORD,                                            *\n               USERFLD=C'VPRT',                                        *\n               LISTEND=YES\n*  LOGON EXIT ROUTINE CONSTANTS AND AREAS\nLOGONR1  DS    F                    SAVEAREA R1 (FOR DUMP)\nLOGONR14 DS    F                    SAVEAREA R14 (RETURN ADDR)\nLOGONSAV DS    18F                  SAVEAREA FOR MACROS IN EXIT\n         LTORG\n         DROP  R3,R7,R9,R10,R12     DROP BASE\n***NAME = LOSTERM EXIT ROUTINE                                      ***\n*  EVENT = A SESSION WITH A LOGICAL UNIT HAS BEEN TEMPORARILY         *\n*  INTERRUPTED OR PERMANENTLY LOST. THE LOGICAL UNIT OR ACF/VTAM      *\n*  OPERATOR HAS REQUESTED THAT THE SESSION BE TERMINATED; OR AN       *\n*  EVENT HAS OCCURRED THAT MAY AFFECT FUTURE OPERATION OF THE         *\n*  SESSION.                                                           *\n*  FUNCTION = HANDLE SITUATIONS IN WHICH A LOGICAL UNIT HAS           *\n*  UNEXPECTEDLY BECOME UNAVAILABLE.                                   *\n*  ENTRY POINT = LOSTRMEX                                             *\n*  INPUT                                                              *\n*   REGS   0    = UNPREDICTABLE                                       *\n*          1    = POINTER TO A 4-WORD PARAMETER LIST                  *\n*          2-13 = UNPREDICTABLE                                       *\n*          14   = RETURN ADDRESS TO ACF/VTAM                          *\n*          15   = ENTRY ADDRESS OF THIS ROUTINE                       *\n*   PARAMETER LIST - 4 WORDS                                          *\n*          1    = ACB ADDRESS                                         *\n*          2    = THE CID OF THE LOGICAL UNIT                         *\n*          3    = THE CONTENTS OF THE USERFLD (FROM THE NIB           *\n*                 SPECIFIED AT OPNDST)                                *\n*          4    = A VALUE INDICATING WHY LOSTERM WAS ENTERED          *\n*  OUTPUT = TERMINATION OF THE SESSION                                *\n*  EXTERNAL REFERENCES = CLSDST, DUMP                                 *\n*  EXIT, NORMAL = BR 14                                               *\n*  EXIT, ABNORMAL = DUMP                                              *\n***ATTRIBUTES = SERIALLY REUSABLE                                   ***\n         DC    C'LOSTRMEX'\nLOSTRMEX DS    0H\n         USING *,R12                ESTABLISH ADRESSABILITY\n         LR    R12,R15              LOAD ENTRY ADDR TO BASE\n         L     R3,=V(VBAMPRT)       LOAD ADDR OF MAINLINE\n         USING VBAMPRT,R3           BASE\n         LA    R13,SAVLOSEX         PROVIDE SAVE AREA FOR MACROS\n         ST    R14,SLOSEX14         SAVE RETURN ADDRESS TO VTAM\n         TM    TPENDFLG,X'FF'       IS CLOSE ACB IN PROGRESS?\n         BOR   R14                  YES, IGNORE LOSTERM NOTIFICATION\n         LR    R6,R1                POINT TO PARMLIST\n         L     R9,=A(LOGONRPL)      POINT TO OPNDST/CLSDST RPL\n         L     R8,0(R1)             PICK UP ACB ADDRESS\n         USING IFGRPL,R9            BASE ON PRPLCONN\n         MVC   RPLUSFLD,8(R1)       MOVE USER FIELD\n         DROP  R9\n         L     R5,4(R1)             PICK UP CID OF LOST TERMINAL\n         L     R4,12(R1)            LOAD ADDR OF REASON CODE\n         CLI   0(R4),X'16'          SESSION HAS BEEN TERMINATED\n         BER   R14                  YES - IMMED RETURN\n*                                   (OR TRY TO ACQUIRE)\n         CLSDST RPL=(R9),ACB=(R8),ARG=(R5),OPTCD=(RELEASE,SYN)\n         LTR   R15,R15              TEST RET CODE\n         BNZ   LOSTRMAB             NOZERO RESULTS IN ABEND\n         L     R14,SLOSEX14         RELOAD RETURN ADDR\n         BR    R14                  RETURN TO VTAM\nLOSTRMAB DUMP\n*  LOSTERM EXIT ROUTINE CONSTANTS AND AREAS\nSLOSEX14 DS    F\nSAVLOSEX DS    18F\n         LTORG\n         DROP  R3,R12               DROP BASE\n***NAME = TPEND EXIT ROUTINE                                        ***\n*  EVENT = THE ACF/VTAM OPERATOR IS SHUTTING DOWN THE NETWORK,        *\n*  OR IS SHUTTING DOWN THIS APPLICATION PROGRAM, OR AN ABEND OF       *\n*  ACF/VTAM HAS OCCURRED.                                             *\n*  FUNCTION = SET AN INDICATOR FOR THE MAINLINE PROGRAM               *\n*  TO CLOSE THE ACB AND TERMINATE                                     *\n*  ENTRY POINT = TPENDEX                                              *\n*  INPUT                                                              *\n*   REGS   0    = UNPREDICTABLE                                       *\n*          1    = ADDRESS OF A 2-WORD PARAMETER LIST                  *\n*          2-13 = UNPREDICTABLE                                       *\n*          14   = RETURN ADDRESS                                      *\n*          15   = ENTRY ADDRESS OF THIS ROUTINE                       *\n*   PARAMETER LIST - 2 WORDS                                          *\n*          1    = ADDRESS OF THE ACB                                  *\n*          2    = A VALUE INDICATING WHY TPEND WAS ENTERED            *\n*  OUTPUT = INDICATION TO CLOSE ACB SET FOR MAIN PROGRAM              *\n*  EXTERNAL REFERENCES = NONE                                         *\n*  EXIT, NORMAL = BR 14                                               *\n*  EXIT, ABNORMAL = NONE                                              *\n*  ATTRIBUTES = SERIALLY REUSABLE                                     *\n*  REGS USED                                                          *\n***  3 = BASE OF MAINLINE                                           ***\n         DC    C'TPENDEX'\nTPENDEX  DS    0H\n         USING *,R15                ESTABLISH ADRESSABILITY\n         L     R3,=V(VBAMPRT)       GET MAINLINE BASE ADDR\n         USING VBAMPRT,R3\n         MVI   TPENDFLG,X'FF'       SET FLAG\n         BR    R14                  RETURN TO VTAM\n         LTORG\n         DROP  R3,R15               DROP BASE\n*  DUMMY SECTIONS                                                     *\n         IFGACB AM=VTAM,DSECT=YES   *  VTAM ACB\n         ISTDNIB                    *  VTAM NODE INITIALIZATION BLOCK\n         IFGRPL AM=VTAM,DSECT=YES   *  VTAM REQUEST PARAMETER LIST\n         ISTUSFBC                   *  RTNCD-FDBK2-FDBK FIELDS IN RPL\n         ISTDBIND                               *  SESSION PARAMETERS\n*  PARAMETER FROM CALLER\nVPRTUACB DSECT\nVPRTFUNC DS    CL4             FUNCTION CODE\nVPRTAPPL DS    CL8             APPLICATION ID\nVPRTPWRD DS    CL8             APPLICATION PASSWORD\nVPRTSLUN DS    CL8             SLU NAME (PRINTER NETNAME)\nVPRTERR  DS    0CL16           ERROR FIELDS\nVPRTMAC  DS    CL8             FAILING MACRO\nVPRTRC0  DS    CL1             ERROR CODE\nVPRTFDBK DS    CL3             RPL FEEDBACK\nVPRTSENS DS    CL4             RPL SENSE\nVPRTDATL DS    CL2             DATA LENGTH\nVPRTDATA DS    0C              START OF DATA\n         END   VBAMPRT\n\n\nMAIN CALLING PROGRAM\n\nVPRT     TITLE 'VBAMPTST  -  TEST VTAM BATCH PRINT'\n         PUNCH '   PHASE VBAMPTST,* '\nVBAMPTST CSECT\n         SAVE  (14,12)\n         LR    R3,R15\n         USING VBAMPTST,R3\n         B     BEGIN\n         DC    CL8'VBAMPTST'        PROGRAM NAME\n         DC    C' V.1.0 '           VERSION\n         DC    C'&UDATE '           DATE OF ASSEMBLY\n         DC    C'&UTIME '           TIME OF ASSEMBLY\nBEGIN    DS    0H\n         ST    R13,SAVEAREA+4\n         LR    R2,R13\n         LA    R13,SAVEAREA\n         ST    R13,8(R2)\n         CALL  VBAMPRT,(VBAMURCB)   OPEN\n         LTR   R15,R15              TEST RET CODE\n         BNZ   CANCEL               NONZERO - CANCEL\n         CLI   URCBERR,C' '         ERROR MESSAGE PRESENT\n         BH    CANCEL               YES - CANCEL\n         MVC   URCBFUNC,=C'SEND'\n         CALL  VBAMPRT,(VBAMURCB)\n         LTR   R15,R15              TEST RET CODE\n         BNZ   CANCEL               NONZERO - CANCEL\n         CLI   URCBERR,C' '         ERROR MESSAGE PRESENT\n         BH    CANCEL               YES - CANCEL\n         MVC   URCBFUNC,=C'CLOS'\n         CALL  VBAMPRT,(VBAMURCB)\n         LTR   R15,R15              TEST RET CODE\n         BNZ   CANCEL               NONZERO - CANCEL\n         CLI   URCBERR,C' '         ERROR MESSAGE PRESENT\n         BH    CANCEL               YES - CANCEL\n         B     PROGEND\nPROGEND  DS    0H                   PROGRAM END\n         EOJ\nCANCEL   DUMP                       CANCEL PROGRAM\n         DC    C'VBAMPTST CANCELLED'\n* CONSTANTS/LITERALS                                                *\nSAVEAREA DS    18F\n         LTORG\nVBAMURCB DS    0F\nURCBFUNC DC    C'OPEN'\n         DC    CL8'VBAMPRT'\n         DC    CL8' '\n         DC    CL8'LO024AD1'        VTAM NAU\n*         DC    CL8'LO124DB1'\nURCBERR  DS    CL12\nURCBSENS DS    CL4\nURCBDATL DC    AL2(URCBDATE-URCBDATA)\nURCBDATA DS    0C                   3270 DATA STREAM\nCOMMAND  DC    X'F5'                WRITE/ERASE\nWCC      DC    X'C8'                    RESET/START PRINT\n         DC    X'0C'                    FORMS FEED\n         DC    X'0D'                    CR\n         DC    C'TEST            SEITE 1'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    X'15'                    NEW LINE\n         DC    C'TEST     CARRIAGE RETURN'\n         DC    X'0D'                    CR\n         DC    C'TEST     CARRIAGE RETURN'\n         DC    X'0D'                    CR\n         DC    X'0C'                    FORMS FEED\n         DC    X'0D'                    CR\n         DC    C'TEST            SEITE 2'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    132C'-'\n         DC    X'15'                    NEW LINE\n         DC    X'15'                    NEW LINE\n         DC    C'TEST     END OF MESSAGE '\n         DC    X'0D'                    CR\n         DC    X'0C'                    FORMS FEED\n         DC    X'0D'                    CR\n         DC    X'19'                    END OF MESSAGE\nURCBDATE EQU   *\n         END   VBAMPTST\n\n\nWilli Kuhn\nIndependent Systems Programmer (Germany)              c Willi Kuhn 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N002A06": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x01\\x12\\x01\\x12\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 274, "newlines": 274, "modlines": 0, "user": "SNAUPDT"}, "text": "Getting started with LU6.2\n\nAs an architecture, SNA LU6.2 has been around for many\nyears but now finally IBM has committed itself to code with\nthe introduction of an Application Program Interface (API) for\nAdvanced Program to Program Communication (APPC) in\nACF/VTAM Version 3.2.  This is achieved by a new macro,\nAPPCCMD, which drives the APPC interfaces and makes\nLU6.2 available to the application programmer.  Unfortunately\nthe implementation is not the high-level interface expected and\nthough the intricacies of session control and data flow\n(chaining, bracketing, contention bidding, etc) have been\nabsorbed by VTAM, the programmer is still expected to deal\nwith ACBs, RPLs, and exits.  Those of us who have spent\nmany unhappy hours (weeks, months?) wrestling with VTAM\napplication programs using earlier LU protocols will appreciate\nthat just getting active and running is the main obstacle.  Once\nthis has been achieved the real work of the application program\ncan be introduced.  Indeed it has often proved necessary to\ndevelop prototype code to unravel the mysteries before design\nwork could commence seriously.  This article will draw from\nearly experience using the new facility to pick out the salient\nrequirements of the APPCCMD macro to enable quick and\nsimple implementations of applications that use LU6.2 - the\nreal work is then up to you.\n\nThe temptation to build never-ending interactive transactions\nshould be avoided since LU6.2 is not really intended as a real-\ntime conversational protocol and, if used as such, is complex\nand fraught with problems.  Allocate a conversation, initiate\nthe application transaction, transfer the resultant data, and\ndeallocate the conversation.  Forget expedited flows and\ncontention bidding, LU6.2 is controlled by the concept of\n'finite state machines'.  In effect an application is either the\nsender or the receiver and if an LU6.2 verb (APPCCMD\nmacro) is issued in the wrong state, the conversation is failed\nwith a state error.  Wherever possible specify OPTCD=SYN so\nthat GPR15 can be checked for errors (this check has been\nomitted from the sample code for the sake of brevity).  When\nan error is encountered (ie GPR15 is non-zero), give up.\nBecause LU6.2 acts as a front end for application-level\nprograms, it hides session control and conversational protocol,\nwhich makes diagnosing and handling errors tricky.  Recovery\nis difficult and often impossible, so for this first article we will\nassume that all is well and leave error handling for another\ntime.\n\n\nAPPLICATION PROGRAM 1\n\nThis program is the initiator of the LU6.2 conversation.  For\nease of reading, this code is not re-entrant and the comments\nare extracted as notes following the code.\n\n          Entry protocol\n\n          OPEN    LU62ACB                       note (1)\n          LA      R5,LU62FMH5                   note (2)\n          USING   ISTFMH5,R5\n          MVC     FM5TPNAM,LU62TPNM\n          MVI     FM5LNTPN,X'12'\n          MVI     FM5LENTH,X'1C'\n          APPCCMD CONTROL=ALLOC,                note (3)\n                  RPL=LU62RPL,\n                  ACB=LU62ACB,\n                  LUNAME=LU62PLU,\n                  LOGMODE=LU62MODE,\n                  AREA=LU62FMH5,\n                  AAREA=LU62RPLX,\n                  QUALITY=ALLOCD\n          LA      R6,LU62RPLX                   note (4)\n          USING   ISTRPL6,R6\n          MVC     LU62CID,RPL6CNVD\n          APPCCMD CONTROL=PREPARE_TO_RECEIVE,   note (5)\n                  RPL=LU62RPL,\n                  ACB=LU62ACB,\n                  CONVID=LU62CID\n          APPCCMD CONTROL=RECEIVE_AND_WAIT,     note (6)\n                  RPL=LU62RPL,\n                  ACB=LU62ACB,\n                  CONVID=LU62CID,\n                  AREA=TRANDATA,\n                  AREALEN=TRANDLEN,\n                  FILL=LL,\n                  QUALITY=SPEC\n\n          Data now available in TRANDATA\n\n          APPCCMD CONTROL=DEALLOC,              note (7)\n                  RPL=LU62RPL,\n                  AAREA=LU62RPLX,\n                  ACB=LU62ACB,\n                  CONVID=LU62CID,\n                  QUALITY=FLUSH,\n                  OPTCD=SYN\n\n          Exit protocol\n\nLU62RPL   RPL     AM=VTAM\nLU62RPLX  ISTRPL6\nLU62ACB   ACB     AM=VTAM,MACRF=LOGON,APPLID=LU62NAME\nLU62NAME  DC      XL1'08',C'LU62APPL'\nLU62PLU   DC      XL1'08',C'LU62PAPP'\nLU62CID   DS      XL4\nLU62FMH5  DS      XL255\nLU62TPNM  DC      C'transaction_name',XL3'00'\nTRANDATA  DS      0F\nTRANDLEN  DC      H'nnnn+2'\n          DS      XLnnnn\n\nNotes\n\n1      An OPEN to identify the APPL name must be issued.  A\n      VTAM major node containing a definition for the\n      application ACB must be active:\n\n               VBUILD TYPE=APPL\n      LU62APPL APPL   ACB=LU62APPL,APPC=YES\n\n2      LU6.2 protocol requires an exchange of a Function\n      Management Header type 5 which must contain the name\n      of the transaction to be executed by the remove\n      application.\n\n3      Requests VTAM to allocate a session with the remote\n      application and wait (QUALITY=ALLOCD) until\n      complete.  The remote partner application LU must be\n      defined as a cross-domain resource to VTAM like this:\n\n               VBUILD TYPE=CDRSC\n      LU62PAPP CDRSC  CDRM=cdrm-name,ISTATUS=ACTIVE\n\n      In essence the LU6.2 ALLOCATE is a LOGON followed\n      by a SEND with OPTCD=FMHDR.  The ALLOC\n      specifies a LOGMODE which must be defined in a suitable\n      VTAM MODETAB.  A typical entry would be as follows:\n\n      LU62MODE MODEENT LOGMODE=LU62MODE\n               FMPROF=X'40',\n               TSPROF=X'00',\n               PRIPROT=X'..',\n               COMPROT=X'4080',\n               RUSIZES=X'....',\n               PSERVIC=X'060000000000000000000000'\n\n      Since VTAM handles session control for the conversation,\n      much of the LOGMODE entry is not relevant.  What is\n      important is the RU size.\n\n4      This extracts the conversation identity allocated by VTAM.\n      This is equivalent to the Communications-id (CID) of\n      earlier LU protocols and must be supplied via the\n      CONVID parameter on all APPCCMD requests.\n\n5      By default the initiator of the conversation is in send mode,\n      therefore the conversation must be turned round to receive\n      the results of the remote transaction.\n\n6      This receives the data from the remote transaction.\n\n7      This terminates the conversation and flushes a deallocate\n      across to the remote application.\n\n\nAPPLICATION PROGRAM 2\n\nThis program represents the receiving end of the LU6.2\nconversation.\n\n           Entry protocol\n\n           OPEN     LU62ACB                        note (1)\n           WAIT     ECB=WAKECB\n           APPCCMD  CONTROL=RCVFMH5,               note (2)\n                    RPL=LU62RPL,\n                    ACB=LU62ACB,\n                    AREA=LU62FMH5,\n                    AAREA=LU62RPLX\n           LA       R5,LU62FMH5\n           USING    ISTFMH5,R5\n           MVC      LU62TPNM,FM5TPNAM\n\n           LA       R1,TRANADDR                    note (3)\n           CALL     transaction_name  (LU62TPNM)\n\n           LH       R2,TRANDLEN                    note (4)\n           APPCCMD  CONTROL=SEND,\n                    QUALITY=DATA,\n                    CONVID=LU62CID,\n                    RPL=LU62RPL,\n                    ACB=LU62ACB,\n                    AREA=TRANDATA,\n                    RECLEN=(2),\n                    OPTCD=SYN\n           APPCCMD  CONTROL=SEND,                  note (5)\n                    QUALITY=FLUSH,\n                    CONVID=LU62CID,\n                    RPL=LU62RPL,\n                    ACB=LU62ACB,\n                    OPTCD=SYN\n           APPCCMD  CONTROL=PREPARE_TO_RECEIVE,    note (6)\n                    RPL=LU62RPL,\n                    ACB=LU62ACB,\n                    CONVID=LU62CID\n           APPCCMD  CONTROL=RECEIVE_AND_WAIT,      note (7)\n                    RPL=LU62RPL,\n                    ACB=LU62ACB,\n                    CONVID=LU62CID,\n                    AREA=TRANDATA,\n                    AREALEN=TRANDLEN,\n                    FILL=LL,\n                    QUALITY=SPEC\n\n           Exit protocol\n\nLU62RPL    RPL      AM=VTAM\nLU62RPLX   ISTRPL6\nLU62ACB    ACB      AM=VTAM,APPLID=LU62PAPP,EXLST=LU62LIST\nLU62LIST   EXLST    AM=VTAM,ATTN=LU62ATTN\nLU62PLU    DS       XL1'08',C'LU62PAPP'\nLU62CID    DS       XL4\nLU62FMH5   DS       XL255\nWAKECB     DC       F'0'\nTRANADDR   DS       A(TRANDATA)\nTRANDATA   DS       0F\nTRANDLEN   DC       H'nnnn+2'\n           DS       XLnnnn\n           CSECT    ,                              note (8)\nLU62ATTN   DS       0H\n\n           Entry protocol\n\n           LR       R2,R1\n           L        R3,=A(LU62CID)\n           MVC      0(R3,4),20(R2)\n           L        R4,=A(WAKECB)\n           POST     (4)\n\n           Exit protocol\n\nNotes\n\n1      Waits for notification of the conversation to arrive.\n\n2      Receives the FMH5 from the conversation originator and\n      extracts the transaction name.  Note that the allocated\n      conversation is initially in receive mode.\n\n3      Calls the transaction program and provides an area for it to\n      return any data.\n\n4      Sends the data generated by the transaction back to the\n      conversation originator.\n\n5      This flushes the conversation to ensure that the data is sent\n      to the conversation originator, which has a receive\n      outstanding ready.\n\n6      Turns the conversation round ready to receive the\n      deallocate from the conversation originator.\n\n7      This receive will be satisfied by the deallocate flushed\n      from the conversation originator.\n\n8      The ATTN exit is scheduled when an FMH5 is received\n      for the application.  Extracts the conversation\n      identity,which is passed in a parameter list when VTAM\n      schedules the exit.  This must be supplied via the CONVID\n      parameter on all APPCCMD requests.\n\nBrian Alford\nSystems Consultant\nAranda (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N002A07": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\xd6\\x00\\xd6\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:37", "lines": 214, "newlines": 214, "modlines": 0, "user": "SNAUPDT"}, "text": "VTAM dynamic reconfiguration\n\nVTAM provides a dynamic reconfiguration facility to allow\nchanges to be made to the NCP without having to perform an\nNCP generation.  This article discusses dynamic\nreconfiguration in detail and provides examples of how to\nreconfigure an NCP and some of its associated resources\ndynamically.\n\n\nWHAT DYNAMIC RECONFIGURATION CAN OFFER\n\nA variety of operations can be performed using the dynamic\nreconfiguration commands supplied as part of the VTAM\nproduct.  You can perform all of the following functions:\n\n1      On non-switched SDLC lines, the addition and deletion of\n      type 1, type 2.0, and type 2.1 physical units.  Any LUs\n      associated with these devices can also be added or deleted\n      using dynamic reconfiguration.\n\n2      The addition and deletion of logical units on non-switched\n      SDLC lines.\n\n3      For VTAM Version 3.2 or above, the movement of a PU\n      and its associated LUs from one line to another within a\n      single NCP.\n\n4      For VTAM Version 3.2 or above, the changing of a PU's\n      SDLC address.\n\nAt present you cannot move an LU from one PU to another;\nhowever you can delete the LU and then add it as required.\nCertain rules exist pertaining to dynamic reconfiguration.  The\nfollowing table summarizes these rules.\n\nOperation      NCP      Line      PU      LU      Description\nADD PU      ACT      any      N/A      N/A      add physical unit\nADD LU      ACT      any      either      N/A      add logical unit\nDEL PU      ACT      any      INACT      INACT      delete physical unit\nDEL LU      ACT      any      either      INACT      delete logical unit\nMOVE PU      ACT      any      INACT      INACT      move physical unit\n\nObviously there will be implications on performing dynamic\nreconfiguration operations.  Installation standards and change\ncontrol procedures should be designed to allow usage of\ndynamic reconfiguration in a controlled environment.  These\nprocedures should allow dynamic reconfiguration to be\nperformed without impacting production resources.  You\nshould also be aware that any changes made using the dynamic\nreconfiguration options are only valid until VTAM is reloaded.\n\nDEFINING RECONFIGURATION MAJOR NODES\nDynamic reconfiguration is achieved by filing VTAM\ndefinition statements in special VTAM major nodes.  These are\nplaced in the VTAM dataset named SYS1.VTAMLST.  A\nspecial VTAM vary command is issued from the operator's\nconsole to activate the dynamic reconfiguration programs.\nWith VTAMVersion 3.2,and later releases, a new VTAM\nmodify command can be used to reconfigure resources\ndynamically without first having to create a special major node.\nThe format of the VTAM vary command is as follows:\n\n      VARY NET,DRDS,ID=drname\n\nTo use this command, a previously defined dynamic\nreconfiguration major node must exist in SYS1.VTAMLST.\nThe major node containing the statements required to perform\nthe dynamic reconfiguration should be placed in the command\ninstead of the drname parameter.  The format of the the new\nmodify command is:\n\nMODIFY NET,\n       DR,\n       TYPE=MOVE | DELETE,\n       FROM=puname | linename,\n       ID=puname | luname,\n       TO=linename,\n       ACTIVATE=YES | NO,\n       ADDR=char\n\nFor further details about these commands you should refer to\nthe VTAM Operation Manual SC23-0113.\n\nExamples of VTAM dynamic reconfiguration major node\ndefinitions are shown below.  These definitions should always\nbegin with the VBUILD TYPE=DR macro.\n\n\nEXAMPLE ONE: ADDING AN LU TO A PU\n\nThis example adds an LU ( VTAM001) to a PU (VTAMP0).\n\nDR1      VBUILD TYPE=DR\n         ADD    TO=VTAMP0\nVTAM001  LU     LOCADDR=6,\n**** code any other required operands here ****\n\n\nEXAMPLE TWO: ADDING A PU TO A LINE\n\nThis example adds a PU (VTAMP1) to line LVTM1.\n\nDR2      VBUILD TYPE=DR\n         ADD    TO=LVTM1\nVTAMP1   PU     ADDR=C1,\n**** code any other required operands here ****\n\n\nEXAMPLE THREE:DELETING AN LU FROM A PU\n\nThis example is used to delete the resource added in example\none.\n\nEDR3      VBUILD TYPE=DR\n         DELETE FROM=VTAMP0\nVTAM001  LU\n\n\nEXAMPLE FOUR: DELETING A PU FROM A LINE\n\nThis example is used to delete the resource added in example two.\n\nDR4      VBUILD TYPE=DR\n         DELETE FROM=LVTM1\nVTAMP1   PU\n\n\nEXAMPLE FIVE: MOVING A PU FROM ONE LINE TO ANOTHER\n\nThis example is used to move a PU (VTM01) from line\nLVTM1 to the line LVTM2.\n\nDR5      VBUILD TYPE=DR\n         MOVE   TO=LVTM2,FROM=LVTM1\nVTM01    PU\n\n\nEXAMPLE SIX: CHANGING A PU'S ADDR VALUE\n\nThis example is used to move a PU (VTM01) from LVTM1 to\nthe line  LVTM2 and change the PU's ADDR operand to C3.\nA 'MOVE' operation can only be specified for PUs.\n\nDR6      VBUILD TYPE=DR\n         MOVE   TO=LVTM2,FROM=LVTM1\nVTM01    PU     ADDR=C3\n\n\nRECOMMENDATIONS\n\nFor an ADD operation you should code PU and LU statements\nas you would normally for NCP definitions.  You should\nexplicitly code any desired operands from the GROUP, LINE,\nand PU macros as sifting of these operands does not take effect\nfor the resources being added.\n\nCode PUs and LUs in the same major node when they will be\nassociated with each other.  This is the most efficient method.\nTry and use the minimum number of dynamic reconfiguration\nmajor nodes.\n\nWhen deleting resources you do not need to code any operands\non the PU and LU macros.  You should code only the PU and\nLU names along with the associated macro for the device being\ndeleted.  If you delete a PU, any resources associated with it\nwill be deleted.\n\nTo activate the example DR major nodes you would have to\nissue the following operator commands:\n\nVARY NET,DRDS,ID=DR1\nVARY NET,DRDS,ID=DR2\nVARY NET,DRDS,ID=DR3\nVARY NET,DRDS,ID=DR4\nVARY NET,DRDS,ID=DR5\nVARY NET,DRDS,ID=DR6\n\nVTAM will respond with the relevant messages informing you\nof the outcome of the dynamic reconfiguration attempt.  You\ncan verify that the operation has completed successfully by\nissuing the relevant VTAM display commands against the\nresources that you have modified.  The devices that have been\nreconfigured will appear in the display if they have been added,\nor should not appear if they have been deleted.  The status field\nfor any devices that have been added should be suffixed with a\n'D'.  This identifies the devices as dynamically reconfigured.\nThe most important point to remember is that the change will\nonly be valid until a VTAM reload takes place.  To ensure that\nthe change is made permanently you must perform an NCP\ngeneration prior to the next VTAM reload.\n\n\nMODIFY DR COMMAND USAGE\n\nThe MODIFY DR command was introduced with VTAM\nversion 3.2.  It allows delete and move operations to be\nperformed without creating a special dynamic reconfiguration\nmajor node definition.  The last four examples presented above\ncould be performed using the following:\n\nF NET,DR,TYPE=DELETE,FROM=VTAMP0,ID=VTAM001\nF NET,DR,TYPE=DELETE,FROM=LVTM1,ID=VTAMP1\nF NET,DR,TYPE=MOVE,FROM=LVTM1,TO=LVTM2,ID=VTM01\nF NET,DR,TYPE=MOVE,FROM=LVTM2,TO=LVTM1,ID=VTM01,ADDR=C3\n\nObviously this method of performing dynamic reconfiguration\nis an improvement as you do not have to define major node\ndefinitions.  The changes made with the MODIFY DR\ncommand are still only valid until VTAM is reloaded.\n\nJohn Bradley\nTechnical Support Engineer (UK)                   c Xephon  1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N002A08": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x01\\xca\\x01\\xca\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 458, "newlines": 458, "modlines": 0, "user": "SNAUPDT"}, "text": "SNA request/response formatter\n\nThe following article describes the components of a system run\nat our site that gives us an overview of the data flow to and\nfrom a terminal.  The system consists of a batch job, a CLIST,\nand a REXX EXEC.  Not all possible SNA RUs are handled by\nthe system.\n\n\nBATCH JOB STREAM\n\nThe primary input to our system is the output from the batch\nexecution of IPCS (see Figure 1, pages 49-50).  This output is\nthen processed using ISRSUPC (SUPERC) (see Figure 2,\npages 51-52).  The output from the SUPERC stage is input to a\nbatch execution of the CLIST VTAMTRC producing the output\nshown in Figure 3 (page 53).  The output from this step is used\nas the input to the final stage, the batch execution of the\nREXX, HVCFTQSH, and gives us the kind of listing shown in\nFigure 4 (page 54).\n\n//TSHVRA   JOB (EDS),'VTAMTRC',CLASS=A,MSGCLASS=X,NOTIFY=TSHVR\n//* DOC: ISPF/PDF V2R3 GUIDE PG 348 (LISTING) & 371\n//*      PANEL 3.13 HELP 2\n//* RC=1 IS NORMAL\n//DEL      EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=X\n//SYSIN    DD *\n   DELETE TSHVR.VTAMTRC.@1\n   IF LASTCC LE 8 THEN SET MAXCC=0\n/*\n//SUPERC   EXEC PGM=ISRSUPC,\n//            PARM='L,SRCHCMP,NOPRTCC'\n//STEPLIB  DD  DSN=ISR.V3R1M0.ISRLOAD,DISP=SHR\n//* NEWDD IS OUTPUT OF BATCH IPCS 'GTFTRACE USR(FE1 FEF FF0 FF2 FE2)'\n//NEWDD    DD  DSN=TSEDS.OUTPUT1,DISP=SHR\n//* OUTDD : SEE NOTE3 FOR FORMAT OF OUTDD\n//OUTDD    DD  DSN=TSHVR.VTAMTRC.@1,DISP=(NEW,CATLG),\n//            SPACE=(TRK,(10,5),RLSE),UNIT=3380,VOL=SER=VOL001,\n//            DCB=(RECFM=FB,LRECL=132,BLKSIZE=23364)\n//SYSIN    DD  *\n   CMPCOLM 13:25\n   LSTCOLM 13:92\n   SRCHFOR 'BUFF',WORD\n   SRCHFOR 'VTAM',WORD\n   SRCHFOR 'TIME:',WORD\n   SRCHFOR '             '\n/*\n//* ISRSUPC MAY GIVE RC 1\n//FMT1  EXEC ISPFBTCH,COND=(1,LT)\n//SYSPROC DD DSN=TSHVR.TEST.CLIST,DISP=SHR\n//*RECI    DD  DSN=TSHVR.VTAMTRC.@1,DISP=SHR\n//*RECO    DD  DSN=TSHVR,VTAMTRC.@2,DISP=SHR\n//SYSTSIN  DD  *\n ISPSTART CMD(%VTAMTRC)\n/*\n//* A SORT JOB COULD BE INSERTED HERE TO SORT OUT CERTAIN ITEMS\n//*  IN RECO\n//FMT2  EXEC ISPFBTCH,COND=(1,LT)\n//SYSPROC DD DSN=TSHVR.TEST.CLIST,DISP=SHR\n//*RECI    DD  DSN=TSHVR.VTAMTRC.@2,DISP=SHR\n//* EXEC  HVCFTQSH\n//SYSTSIN  DD  *\n ISPSTART CMD(%HVCFTQSH DSN(TSHVR.VTAMTRC.@2))\n/*\n\n\nCLIST VTAMTCR\n\nPROC 0 DEBUG\nIF &DEBUG = DEBUG +\n  THEN CONTROL LIST CONLIST SYMLIST\nCONTROL END(END0)\nIF &SYSDSN(VTAMTRC.@2) = OK +\n  THEN SET DISP = OLD\n  ELSE SET DISP = NEW CATALOG\nALLOC DD(RECO) DA(VTAMTRC.@2) &DISP +\n  DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(23440) +\n  SPACE(5,2) TRACKS VOLUME(VOL002)\nOPENFILE RECO OUTPUT\nALLOC DD(RECI) DA(VTAMTRC.@1) SHR REUSE\nOPENFILE RECI INPUT\nERROR +\n  DO\n  SET &RCODE = &LASTCC\n  IF &RCODE \u00ac= 400 +\n    THEN DO\n      WRITE ERROR &RCODE\n      ERROR\n    ENDO\n  GOTO CLOS\n  ENDO\nSET COUNT = 0\nSET ISW = 1\nNEXT: +\nGETFILE RECI\nSET SRCH = &SUBSTR(10:13,&STR(&RECI))\nIF &SRCH = BUFF +\n  THEN DO\n    SET DIRECT = &SUBSTR(55:62,&STR(&RECI))\n    IF &DIRECT = OUTBOUND +\n      THEN SET TERM = &SUBSTR(18:25,&STR(&RECI))\n      ELSE SET TERM = &SUBSTR(27:34,&STR(&RECI))\n  ENDO\nIF &SRCH = VTAM +\n  THEN DO\n    SET SIZEC = &SUBSTR(75:78,&STR(&RECI))\n    SET SIZE = 0\n    DO &I = 1 TO 4\n      SET CC = &SUBSTR(&I:&I,&SIZEC)\n      SET CW = &SYSINDEX(&CC,&STR(0123456789ABCDEF)) - 1\n      SET SIZE = &SIZE * 16 + &CW\n    ENDO\n    SET SIZEO = &STR(&SIZE)\n    SET LS = &LENGTH(&SIZEO)\n    DO &I = 1 TO 4 - &LS\n      SET SIZEO = &STR( &SIZEO)\n    ENDO\n    SET RH = &SUBSTR(81:89,&STR(&RECI))\n    SET ISW = 0\n    SET FR = &STR( )\n  ENDO\nIF &SUBSTR(10:41,&STR(&RECI)) = &STR(                                ) +\n  THEN DO\n    IF &ISW = 1 THEN GOTO NEXT\n    SET ISW = 1\n    SET FR = &SUBSTR(42:49,&STR(&RECI))\n    GOTO NEXT\n  ENDO\nIF &SRCH = &STR(    ) +\n  THEN DO\n    IF &SUBSTR(18:21,&STR(&RECI)) \u00ac= TIME THEN GOTO NEXT\n    SET TIM = &SUBSTR(44:58,&STR(&RECI))\n    SET RECO = &STR(&TERM     &TIM     &DIRECT     &SIZEO     +\n                &RH  REQ= &FR)\n    PUTFILE RECO\n    SET COUNT = &COUNT + 1\n    IF &COUNT = (&COUNT / 20 ) * 20 +\n      THEN WRITE &COUNT\n  ENDO\nGOTO NEXT\nCLOS: +\nCLOSFILE RECI\nCLOSFILE RECO\nFREE DD(RECI)\nFREE DD(RECO)\n\n\nREXX HVCFT9SH\n\n/******************** REXX *******************************************/\nTRACE\nARG IETS\nRC=0\nPARSE VAR IETS . \"DSN(\" DSN \")\"\nIF DSN=\"*\" THEN DSN=\"TSEDS.VTAMTRC.@2\"\nIF DSN=\"\" THEN\nDO\n CALL S_HVCFTQSH IETS,\"SAY\"\n EXIT RC\nEND\n/* GET INFO FROM FILE */\nADDRESS TSO\n\"ALLOCATE FILE(RECI) DSN('\"DSN\"') SHR\"\nADDRESS MVS\n\"EXECIO 1  DISKR  RECI (STEM LINES. \"\nDO WHILE RC=0\n PARSE VAR LINES.1 TERM TIME DIRECTION NR 'RH=' RH 'REQ= ' RU\n CALL S_HVCFTQSH STRIP(RH,'T')!!STRIP(RU,'B'),\"QUEUE\"\n PULL ANALYSIS\n SAY TERM TIME SUBSTR(DIRECTION,1,3) ,\n       FORMAT(NR,4) ANALYSIS\n \"EXECIO 1  DISKR  RECI (STEM LINES. \"\nEND\n\"EXECIO 0  DISKR  RECI (STEM LINES. FINIS\"\nADDRESS TSO\n\"FRE FILE(RECI)\"\nEXIT RC\nS_HVCFTWSH:PROCEDURE\n/***************************************/\n/** FORMAT SNA REQUEST/RESPONSE HEADER                     ***********/\nTRACE\nRC=0\nCALL ON ERROR NAME S_ERROR\nTRUE=1\nBYPASS_RC=0\nFORMAT_ERROR=20\nIF ARG()=0 THEN CALL S_ERROR(FORMAT_ERROR)\nARG QSH,OOO\nIF WORDS(QSH)>1 & OOO=\"\" THEN\nDO\n PARSE VAR QSH  QSH OOO\nEND\nIF LENGTH(QSH) <  6 THEN QSH=SUBSTR(QSH,1,6,'0')\nIF DATATYPE(QSH,'X') \u00ac= TRUE THEN CALL S_ERROR(FORMAT_ERROR)\nIF OOO=\"\" THEN OOO=\"SAY\"\nRESPONSE=\"RSP\";REQUEST=\"RQ \"\nSENSE_DATA=\" \"\nREQUEST_NAME=\" \";SENSE_DATA=\" \"\nSC=\"SC \";FMD=\"FMD\";DFC=\"DFC\";NC=\"NC \"\nPOS=\"+\";NEG=\"-\"\n/*QUEUE \"***********   ANALYSING REQUEST/RESPONSE HEADER *********\"*/\n/*QUEUE QSH */\nH_X2C=X2C(SUBSTR(QSH,1,6))\n/* BYTE 1 */\nBYTE1=SUBSTR(H_X2C,1,1)\n/*QUEUE \"** BYTE  1 :\" C2X(BYTE1)*/\nBIT7=GET_BIT(BYTE1,7)\nIF BIT7 = 0 THEN TYPE=REQUEST\n            ELSE TYPE=RESPONSE\n/*QUEUE \"TYPE   :\" BIT7 TYPE*/\nBIT6_5=GET_BITS(BYTE1,6,2)\nIF      BIT6_5=0 THEN RU_CATEGORY=FMD\nELSE IF BIT6_5=1 THEN RU_CATEGORY=NC\nELSE IF BIT6_5=2 THEN RU_CATEGORY=DFC\nELSE                  RU_CATEGORY=SC\n/*QUEUE \"RU_CATEGORY :\" BIT6_5 RU_CATEGORY*/\n/* BIT 4 RESERVED */\n/* FORMAT INDICATOR */\nFI=GET_BIT(BYTE1,3)\nIF FI  THEN  REQUEST_NAME=\"FMD OR NS  HEADER SHOULD FOLLOW\"\n/*QUEUE \"FORMAT IND:\"  FI  */\n/* SENSE DATA INCLUDED INDICATOR */\nSDI=GET_BIT(BYTE1,2)\nIF SIDE THEN SENSE_DATA=\"SENSE DATA SHOULD FOLLOW\"\n/*IF BIT2 = 0 THEN SDI=\"NOSD\"\n            ELSE SDI=\"SD\"   */\n/*QUEUE \"SENSE DATA IND:\" BIT2 SDI */\nBCI=GET_BIT(BYTE1,1)\nECI=GET_BIT(BYTE1,0)\nIF BCI=1 THEN\nDO\n IF ECI=0 THEN CHAIN=\"FIC\"\n          ELSE CHAIN=\"OIC\"\nEND\nELSE\nDO\n IF ECI=0 THEN CHAIN=\"MIC\"\n          ELSE CHAIN=\"LIC\"\nEND\n/* BYTE 2 */\nBYTE2=SUBSTR(H_X2C,2,1)\n/*QUEUE \"** BYTE  2 :\" C2X(BYTE2) */\n/* DEFINITE RESPONSE 1 INDICATOR */\nDR1I=GET_BIT(BYTE2,7)\n/*QUEUE \"DEF RESP 1 IND: \"  DR1I */\n/* DEFINITE RESPONSE 2 INDICATOR */\nDR1I=GET_BIT(BYTE2,5)\n/*QUEUE \"DEF RESP 2 IND: \"  DR2I */\nRTI_SYMBOL=\" \";RESP_SYMBOL=\"  \"\nRTI=GET_BIT(BYTE2,4)\nSELECT\n WHEN TYPE=RESPONSE THEN\n  DO\n   SELECT\n    WHEN RTI=0 THEN RTI_SYMBOL=POS\n    OTHERWISE       RTI_SYMBOL=NEG\n   END\n  END\n /* EXCEPTION RESPONSE INDICATOR */\n OTHERWISE DO\n  ERI=RTI\n  /* TYPE OF RESPONSE INDICATOR */\n  RESP=DR1I!!DR2I!!ERI\n  IF RESP=\"000\" THEN RESP_SYMBOL=\"NR\"   /* NO RESPONSE */\n  ELSE IF ERI=0 THEN RESP_SYMBOL=\"DR\"   /* DEFINITE RESPONSE */\n  ELSE IF ERI=1 THEN RESP_SYMBOL=\"ER\"   /* EXCEPTION RESPONSE */\n END\nEND\nPI=GET_BIT(BYTE2,0)\nIF PI=0 THEN PI_SYMBOL=\"\u00acPAC\"\n        ELSE PI_SYMBOL=\" PAC\"\n/*QUEUE \"PI:\" PI  */\n/* BYTE 3  ONLY RELEVANT FOR REQUESTS*/\nBYTE3=SUBSTR(H_X2C,3,1)\n/*QUEUE \"** BYTE  3 :\" C2X(BYTE3)*/\n BBI_SYM=\"  \";EBI_SYM=\"  \";CDI_SYM=\" \";CSI_SYM=\" \";EDI_SYM=\" \";\n PDI_SYM=\" \";CEBI_SYM=\" \"\nIF TYPE=REQUEST  THEN\nDO\n BBI=GET_BIT(BYTE3,7)\n IF BBI=1 THEN BBI_SYM=\"BB\"\n EBI=GET_BIT(BYTE3,6)\n IF EBI=1 THEN EBI_SYM=\"EB\"\n CDI=GET_BIT(BYTE3,5)\n IF CDI=1 THEN CDI_SYM=\"CD\"\n CSI=GET_BIT(BYTE3,4)\n EDI=GET_BIT(BYTE3,2)\n PDI=GET_BIT(BYTE3,1)\n CEBI=GET_BIT(BYTE3,0)\n /*QUEUE \"BBI EBI CDI CSI EDI PDI CEBI\"\n QUEUE  BBI EBI CDI CSI EDI PDI CEBI  */\nEND\n/* RU BEGINS AT BYTE 7 */\nRU_X2C=X2C(SUBSTR(QSH,7))\nIF RU_X2C==\"\" THEN  /* REG MAY CONTAIN BLANKS */\nDO\n /* IS THIS ISOLATED PACING RESPONSE ? */\n IF QSH=\"830100\" THEN REQUEST_NAME=\"IPR\"\nEND\nELSE\nDO\n /* BYTE 1 OF RU */\n RU1=SUBSTR(RU_X2C,1,1)\n RU1=C2X(RU1)\n /*QUEUE \"** RU BYTE  1 :\" RU1 */\n IF RU_CATEGORY=SC THEN\n DO\n  SELECT\n   WHEN RU1='11' THEN REQUEST_NAME=\"ACTPU\"\n   WHEN RU1='12' THEN REQUEST_NAME=\"DACTPU\"\n   WHEN RU1='0D' THEN REQUEST_NAME=\"ACTLU\"\n   WHEN RU1='0E' THEN REQUEST_NAME=\"DACTLU\"\n   WHEN RU1='31' THEN REQUEST_NAME=\"BIND\"\n   WHEN RU1='32' THEN REQUEST_NAME=\"UNBIND\"\n   WHEN RU1='A0' THEN REQUEST_NAME=\"SDT\"\n   OTHERWISE          REQUEST_NAME=\"UNKNOWN\"\n  END/*SELECT*/\n  /*QUEUE \"REQUEST_NAME :\" REQUEST_NAME */\n END/*IF RU_CATEGORY=SC*/\n ELSE IF RU_CATEGORY=DFC THEN\n DO\n  IF SDI   THEN\n  DO\n   SENSE_DATA=SUBSTR(QSH,7)\n  END\n  ELSE\n  DO\n   SELECT\n    WHEN RU1='C0' THEN REQUEST_NAME=\"SHUTD\"\n    WHEN RU1='C1' THEN REQUEST_NAME=\"SHUTC\"\n    WHEN RU1='C8' THEN REQUEST_NAME=\"BID\"\n    OTHERWISE          REQUEST_NAME=\"UNKNOWN\"\n   END/*SELECT*/\n   /*QUEUE \"REQUEST_NAME :\" REQUEST_NAME*/\n  END/* IF TYPE=REQUEST */\n END/*ELSE IF RU_CATEGORY=DFC*/\n ELSE IF RU_CATEGORY=FMD THEN\n DO\n  IF SDI    THEN\n  DO\n   SENSE_DATA=SUBSTR(QSH,7)\n  END\n  ELSE IF FI  THEN\n  DO\n   FMDNSHDR=SUBSTR(QSH,7,6)\n   SELECT\n    WHEN  FMDNSHDR=\"010683\"  THEN  REQUEST_NAME=\"TERM-SELF\"\n    WHEN  FMDNSHDR=\"810620\"  THEN  REQUEST_NAME=\"NOTIFY\"\n    WHEN  FMDNSHDR=\"818620\"  THEN  REQUEST_NAME=\"NOTIFY\"\n    WHEN  FMDNSHDR=\"810681\"  THEN  REQUEST_NAME=\"INIT-SELF\"\n    OTHERWISE                 REQUEST_NAME=\"UNKNOWN\"\n   END\n  END/*IF FI */\n  ELSE  REQUEST_NAME=\"USER DATA\"\n END/*ELSE IF RU_CATEGORY=FMD */\nEND/*IF RU_X2C \u00ac=\"\" */\n/* EDITING OUTPUT */\nIF OOO=\"QUEUE\" THEN\nDO\n QUEUE TYPE!!RTI_SYMBOL RU_CATEGORY CHAIN RESP_SYMBOL PI_SYMBOL ,\n  BBI_SYM EBI_SYM CDI_SYM REQUEST_NAME SENSE_DATA\n RETURN RC\nEND\nIF OOO=\"SAY\" THEN\nDO\n SAY  TYPE!!TRI_SYMBOL RU_CATEGORY CHAIN RESP_SYMBOL PI_SYMBOL ,\n  BBI_SYM EBI_SYM CDI_SYM REQUEST_NAME SENSE_DATA\n RETURN RC\nEND\n/*\"VGET (ZTEMPF ZTEMPN)\"\n ADDRESS MVS\n BYPASS_RC=1\n \"EXECIO * DISKW \"ZTEMPN\" (STEM LINE. FINIS)\"\n BYPASS_RC=1\n ADDRESS ISPEXEC\n BYPASS_RC=4\n \"BROWSE DATASET('\"ZTEMPF\"')\"\n RETURN RC  */\n/* INTERNAL SUBROUTINES */\n/*      */\nS_ERROR:\n IF RC \u00ac= 0 THEN DO\n  IF BYPASS_RC=RC THEN DO; RC=0;BYPASS_RC=0;RETURN;END\n  IF BYPASS_RC1=RC THEN RETURN\n END\n ARG ARG_RC\n CONDITION_I=CONDITION('I')\n IF CONDITION_I = \"CALL\" THEN CALL OFF ERROR\n                         ELSE SIGNAL OFF ERROR\n  /* SAVE IN CASE HOST COMMANDS ARE USED IN S_ERROR */\n IF ARG_RC \u00ac=\"\" THEN SAVE_RC=ARG_RC\n  ELSE SAVE_RC=RC\n SAVE_SIGL=SIGL\n SAVE_ZERRLM=ZERRLM\n PARSE SOURCE SOURCE_STRING\n EXECNM=WORD(SOURCE_STRING,3)\n ENV=ADDRESS()\n CLAUSE_OF_ERROR=CONDITION('D')\n IF CLAUSE_OF_ERROR=\" \" THEN CLAUSE_OF_ERROR=SOURCELINE(SIGL)\n RC=SAVE_RC\n /*IF CONDIITON_I=\"CALL\" THEN RETURN */\n IF CONDITION_I=\"CALL\" THEN SIGNAL L_ERROR_EXIT\n                       ELSE SIGNAL L_ERROR_EXIT\nL_ERROR_EXIT:\nSIGNAL OFF ERROR\nSAY \"*************** E R R O R ******************\"\nSAY \"* EXEC        :\" EXECNM\nSAY \"* ENVIRONMENT :\" ENV\nSAY \"* LAST RC     :\" SAVE_RC\nSAY \"* LAST SIGL   :\" SAVE_SIGL\nSAY \"* LAST COMMAND:\"\nSAY CLAUSE_OF_ERROR\nSAY \"* LAST ZERRLM :\"\nSAY SAVE_ZERRLM\nSAY \"* LAST MESS1  :\"\nSAY MESS1\nSAY \"*************** E R R O R ******************\"\nADDRESS TSO \"DELSTACK\"\nIF SYSVAR(SYSENV)=\"BACK\" & SYSVAR(SYSISPF)=\"ACTIVE\" THEN\nDO\n ZISPFRC=SAVE_RC\n ADDRESS ISPEXEC \"VPUT (ZISPFRC) SHARED\"\nEND\nELSE DO\n SAY \"TYPE ANY CHARACTER TO CONTINUE\"\n PULL\nEND\nEXIT RC\nGET_BIT:PROCEDURE\nPARSE ARG HEXCHARS,BITNR  /* NO UPPERCASE TRANSLATION */\nIF BITNR=\"\" THEN BITNR=0\nMASK=2**BITNR\nMASK1=D2C(MASK,LENGTH(HEXCHARS))\nBIT=BITAND(HEXCHARS,MASK1)\nIF C2D(BIT)=MASK THEN BIT=1\n                 ELSE BIT=0\nRETURN(BIT)\nGET_BITS:PROCEDURE\nPARSE ARG HEXCHARS,BITNR,AANTAL /* NO UPPERC TRANSL */\nIF BITNR=\"\" THEN BITNR=0\nIF AANTAL=\"\" THEN AANTAL=1\nSAVE_BITNR=BITNR\nDO LOPER=AANTAL TO 1 BY -1\n BIT.LOPER=GET_BIT(HEXCHARS,SAVE_BITNR)\n SAVE_BITNR=SAVE_BITNR-1\nEND\nBIT=0\nDO LPER=AANTAL TO 1 BY -1\n BIT=BIT+(BIT.LOPER)*(2**(LOPER-1))\nEND\nRETURN(BIT)\n\n\nHerman Vierendeels\nSystems Programmer\nKamer van Volksvertegenwoordigers (Belgium)       c Herman Vierendeels 1991\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N002A09": {"ttr": 2821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\xd4\\x00\\xd4\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 212, "newlines": 212, "modlines": 0, "user": "SNAUPDT"}, "text": "Network performance management tools\n\nThis article takes a look at what products are available in the\nfield of network performance management tools and gives a\nbrief description of the main products in this area.  The\ninformation comes mainly from the suppliers' own publicity\nmaterial, personal experience, and Xephon research.  It is not\nintended to be a comprehensive buyer's guide, simply an\nintroduction to some of the products currently available.  The\nrange of facilities offered by each of the products below varies\nenormously and this will be reflected in their prices.  Some of\nthe following products compete directly with each other, while\nothers only contain a subset of the facilities of (usually) more\nexpensive products.\n\n\nBESTNET BOUNDARY PRODUCT AND BESTNET MSNF PRODUCT\n\nBESTnet Boundary Product is a set of tools for the\nperformance management of the SNA boundary network,\nBESTnet MSNF Product is a set of tools for the performance\nmanagement of the entire SNA network.  Both products consist\nof an interactive tool for the evaluation and prediction of\nnetwork performance, a batch component for data reduction\nand analysis, and a graphics module.\n\nFor further information, contact BGS Systems Inc, 128\nTechnology Center, Waltham, MA 02254-9111, USA -\ntelephone: (617) 891 0000 or BGS Systems Ltd, Iveco Ford\nHouse, Station Road, Watford, Herts WD1 1SR, UK -\ntelephone: (0923) 53555.\n\n\nCA-MAZDAMON\n\nCA-MAZDAMON is a complete network performance\nmanagement system.  It has a menu-driven real-time\ncomponent, which provides the user with NCP and host\nsubsystem statistics on-line, plus an historical reporting\nfacility.\n\nFor further information contact Computer Associates\nInternational Inc, 711 Stewart Avenue, Garden City, NY\n11530-4787, USA - telephone: (516) 227 3300 or Computer\nAssociates Ltd, Computer Associates House, 183-187 Bath\nRoad, Slough, Berks SL1 4AA, UK - telephone: (0753)\n77733.\n\n\nMICS SNA NETWORK ANALYZER\n\nMICS SNA Network Analyzer gives its users network\nmanagement, problem analysis, and network capacity planning\nfacilities by extracting the relevant information from CA-\nMAZDAMON, Net/Master, NetSpy, or NetView.\n\nFor further information contact Legent Corporation, 8615\nWestwood Center Drive, Vienna VA 22189-2215, USA -\ntelephone: (703) 734 9494 or Legent, 13-35 Grenfell Road,\nMaidenhead, Berks SL6 1YG, UK - telephone: (0628)\n777555.\n\n\nNARRS\n\nNARRS is a tool for the collection, analysis, and reporting of\ninformation on the availability of the network, its applications,\nand connected devices.\n\nFor further information contact Chicago-Soft Ltd, 738 North\nLa Salle Street, Suite 2, Chicago, IL 60610, USA - telephone:\n(312) 282 4777 or Tecfacs Ltd, Brook House, Toutley Road,\nWokingham, Berks RG11 5QN, UK - telephone: (0734)\n776645.\n\n\nNETBOSS\n\nNETBOSS monitors the status of VTAM resources and\ngraphically presents the total network in a series of full colour\nscreen displays.\n\nFor further information contact Allen Systems Group Inc, 750\n11th Street South, Naples, FL 33940, USA - telephone: (813)\n263 6700.\n\n\nNet/HELP ADVISOR\n\nNET/HELP ADVISOR is an expert system-based network\ndiagnostic tool, which enables users to identify network\nfailures and highlight potential problem areas.\n\nFor further information contact Boole and Babbage Inc, 510\nOakmead Parkway, Sunnyvale, CA 94086, USA - telephone:\n(408) 735 9500 or Boole and Babbage Europe, Burnham\nHouse, Clivemount Road, Maidenhead, Berks SL6 7BU, UK -\ntelephone: (0628) 771909.\n\n\nNet*INSIGHT\n\nNET*INSIGHT is a network performance monitor, which\ncollects information on network data flow and VTAM trace\ndata to produce an analysis report or generate console\nmessages.\n\nFor further information contact Systems Center Inc, 1800\nAlexander Bell Drive, Reston, VA 22091, USA - telephone:\n(703) 264 8000 or Systems Center 75 London Road, Reading,\nBerks RG1 5BS, UK - telephone: (0734) 391139.\n\n\nNetSpy\n\nNetSpy is a network performance monitor providing end-to-end\nresponse time measurement and analysis.  It also delivers\nstatistics on line utilization and error rates, NCP cycle\nutilization, and buffer usage.\n\nFor further information, contact Legent Corporation, Two\nAllegheny Center, Pittsburgh, PA 15212, USA - telephone:\n(412) 323 2600 or Legent, 13-35 Grenfell Road, Maidenhead,\nBerks SL6 1YG, UK - telephone: (0628) 777555.\n\n\nNetView PERFORMANCE MONITOR\n\nNetView Performance Monitor is a performance management\ntool which collects, monitors, and graphically displays\nperformance information on different components of an SNA\nnetwork.\n\nFor further information, contact your local IBM sales\nrepresentative.\n\n\nOmegamon II for VTAM\n\nOmegamon II for VTAM is an MVS VTAM performance\nmonitor and tuning tool.  It incorporates an automatic\nexception detection facility and displays recommended\nsolutions to detected problems.  In addition, users can browse\nthe VTAM log, issue VTAM commands directly, or switch to\nNetView.\n\nFor further information, contact Candle Corporation, 1999\nBundy Drive, Los Angeles, CA 90025, USA - telephone:\n(213) 207 1400 or Candle Service Ltd, Bridge House, 1\nWalnut Tree Close, Guildford, Surrey GU1 4YY, UK -\ntelephone: (0483) 303939.\n\n\nThe Monitor for VTAM\n\nThe Monitor for VTAM is a VTAM performance monitor\n(formerly Critique/VTAM from Highland Research).  It\nenables systems programmers and network managers to\nmonitor data flow in and out of the host.\n\nFor further information, contact Landmark Systems\nCorporation, 8000 Towers Crescent Drive, Vienna, VA 22180-\n2700, USA - telephone: (703) 983 9046 or Systems Resources\nLtd, 27 Spon Street, Coventry, CV1 3BA, UK - telephone:\n(0203) 630630.\n\n\nVTS (VTAM TUNING SYSTEM)\n\nVTS is a tool designed to help improve VTAM performance.\nIt provides a variety of tuning information enabling the user to\nidentify performance problems, monitor resource usage, and\nmodel any impact proposed changes to VTAM parameters\nmight have.\n\nFor further information contact Chicago-Soft Ltd, 738 North\nLa Salle Street, Suite 2, Chicago, IL 60610, USA - telephone:\n(312) 282 4777 or Tecfacs Ltd, Brook House, Toutley Road,\nWokingham, Berks RG11 5QN, UK - telephone: (0734)\n776645.\n\n\nCOMPARISONS\n\nThe October 1990 issue of Xephon's IBEX Bulletin (a regular\nseries of surveys into the IBM mainframe community) found\nthat of those sites with a network performance monitor,\nNetView PM had nearly 70% of the market and NetSpy 21%.\nNo other products showed in sufficient numbers for them to be\nassessed individually.  Ratings for the products told a different\nstory however.  NetSpy was rated considerably better than\nNetView PM in every category covered by the survey, namely:\nvalue for money, support, ease of use, reliability, performance\noverhead, and range of measurements.\n\n\nCONCLUSION\n\nIBEX also found that only 24% of all IBM mainframe sites\nhave a network performance monitor, rising to 44% for MVS\nsites, indicating that this should be a reasonably good area for\nsoftware vendors to focus their sales efforts.  We do not expect\nthe present two horse race to continue for much longer.\nOmegamon II for VTAM is a relative newcomer on the scene\nbut shows all the potential one would expect from a Candle\nproduct.  It will be interesting to see whether Landmark\nSystems can repeat the success they have had with The Monitor\nfor CICS, in this market.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N003A00I": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 13, "newlines": 13, "modlines": 0, "user": "SNAUPDT"}, "text": "N003 - SNA Update Issue #003 September 1991\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nN003A01   NetView session monitor enhancement\nN003A02   Printing CMS files on VTAM printers\nN003A03   Data flow in LU6.2\nN003A04   NetView CLIST to establish a TAF session\nN003A05   Correction to the June issue\nN003A06   Tightening Net/Master security with CA-ACF2\nN003A07   NCP and VM/VTAM\nN003A08   VTAM multi-session managers\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N003A01": {"ttr": 2828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\xa4\\x00\\xa4\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 164, "newlines": 164, "modlines": 0, "user": "SNAUPDT"}, "text": "NetView session monitor enhancement\n\nIn September 1990 IBM announced several PTFs that can be\nused to enhance the session monitor component of NetView.\nThe session monitor is the updated version of the old NLDM\nproduct.  The component is a large resource user, especially of\nCPU and DASD storage in large networks.  I decided that these\nPTFs could benefit our installation if we installed them.  The\nPTFs in question are UY59375, UY60871, UY90722,\nUY90723, UY90724.\n\nThe PTFs provide the following functionality and benefits:\n\n1      Improved VSAM file usage.  This includes compression of\n      the key size from 54 bytes to 27; the reduction, by a\n      variable amount, of the data segment of the record; and\n      combining five individual monitor VSAM records into\n      one, which IBM claims will reduce space requirements by\n      at least 20%.  Combining these records also allows you to\n      stop the collection of the AAULETIM records, providing\n      even more space savings.  The PCID recorded in the data\n      records has been reversed.  This provides optimum use of\n      these records after a purge operation.\n\n2      Messages AAU020I and AAU022I are issued by the\n      session monitor when a dataset full condition occurs.  The\n      PTFs provide you with the ability to suppress these\n      messages, preventing a message overflow from occurring.\n\n3      Sessions can now be filtered with the attribute of 'sense code'.\n\nThe PTFs can be installed using standard SMP/E job streams.\nOnce they are installed you should ensure that all the\ninstructions in the provided cover letters are performed.  The\nenhancements create new NetView messages, so you should\nregenerate the on-line message database using the following job\nstream.\n\n//SYSPJXB     JOB   (SDTS),'JOHN BRADLEY',CLASS=A,MSGCLASS=Q,\n//            MSGLEVEL=(1,1),NOTIFY=SYSPJXB,REGION=4M\n//*      *************************************************************\n//*      * JOB TO CREATE THE ONLINE NETVIEW MESSAGE DATASET.         *\n//*      * SEE NETVIEW INSTALLATION AND ADMINISTRATION GUIDE.        *\n//*      *************************************************************\n//CNMVSAM     PROC\n//REPRO1      EXEC  PGM=CNMOVSAM,REGION=500K\n//STEPLIB     DD    DSN=SYS1.CNMLINK,DISP=SHR\n//CNMIN       DD    DSN=SYS1.CNMSAMP(CNMSJ021),DISP=SHR\n//CNMOUT      DD    DSN=&&TEMP,\n//            DISP=(NEW,PASS),\n//            UNIT=WORK,\n//            SPACE=(CYL,(5,1))\n//*\n//REPRO2      EXEC  PGM=IDCAMS,REGION=500K\n//INPUT       DD    DSN=&&TEMP,DISP=(OLD,DELETE,DELETE)\n//OUTPUT      DD    DSN=CNM.CNMMSGF,DISP=SHR\n//SYSPRINT    DD    SYSOUT=*\n//SYSIN       DD    DUMMY\n//            PEND\n//*\n//STEP1       EXEC  PROC=CNMVSAM\n//REPRO2.SYSIN DD   *\n  REPRO -\n  INFILE(INPUT) -\n  OUTFILE(OUTPUT) -\n  REUSE\n/*\n\nA documentation member named CNMREAD5 is placed in the\nCNMSAMP dataset.  This member provides detailed\ninformation about the PTFs.  It should be reviewed and copies\ndistributed to all members of staff concerned with NetView.\nYou will also have to redefine the session monitor datasets to\nprovide for the new record formats.  The PTF cover letters\nguide you through this process.  IBM recommends an initial\nreduction in size of 20% for these datasets.  After a trial period\nI have managed to reduce them by 50%, which has provided us\nwith a massive DASD space saving.  The reduction in size will\ndepend on many factors, and can often be unique to your\ninstallation.\n\nA new operator command called SMDR is provided.  This\ncommand can be used to display session monitor data recording\nstatus, suspend recording, and restart recording.  The command\ncan be used in automation processes or by the operator at the\nNetView console.  Once the PTFs are installed, on-line help\nabout the command is available by typing in HELP SMDR at\nthe NetView console.\n\nThe PTFs also provide a new facility known as Sense Code\nFiltering (SCF).  This new facility allows sessions to be\nfiltered, depending on sense code.  A special program referred\nto as the SCF can be used to analyze your session monitor\ndatasets.  The information produced can be used to identify the\nfrequency of sense codes.  From this information decisions can\nbe made on which sense codes should be filtered.  To analyse\nthe session monitor datasets you should use the following job\nstream.\n\n//SYSPJXB     JOB   (SDTS),'JOHN BRADLEY',CLASS=A,MSGCLASS=Q,\n//            MSGLEVEL=(1,1),NOTIFY=SYSPJXB\n//*      **************************************************************\n//*      * NETVIEW SENSE CODE FILTER ENHANCEMENT.                     *\n//*      * CONTAINED IN SAMPLE CNMSJM10. DOCUMENTATION IN CNMREAD5.   *\n//*      * BOTH MEMBERS IN SYS1.CNMSAMP.                              *\n//*      * STEP1: CREATE A TEMP DATASET FROM SESSION MONITOR DATASET. *\n//*      * STEP2: CONCATENATES VSAM TIME RECORDS TO TEMP DATASET.     *\n//*      * STEP3: CREATE THE REPORT.                                  *\n//*      **************************************************************\n//STEP1       EXEC  PGM=IDCAMS\n//VSAMIN      DD    DSN=CNM.AAUVSPL,DISP=SHR,AMP='AMORG'\n//SEQOUT      DD    DSN=&&TEMPDS,DISP=(NEW,PASS),\n//            UNIT=WORK,SPACE=(CYL,(40,10)),\n//            DCB=(LRECL=2000,RECFM=VB,BLKSIZE=2004)\n//SYSPRINT    DD    SYSOUT=*\n//SYSIN       DD    *\n   REPRO -\n   INFILE(VSAMIN) -\n   OUTFILE(SEQOUT) -\n   FROMKEY('000DATEKEY') -\n   TOKEY('000DATEKEY')\n/*\n//STEP2       EXEC  PGM=IDCAMS\n//VSAMIN      DD    DSN=CNM.AAUVSPL,DISP=SHR,AMP='AMORG'\n//SEQOUT      DD    DSN=&&TEMPDS,DISP=MOD\n//SYSPRINT    DD    SYSOUT=*\n//SYSIN       DD    *\n   REPRO -\n   INFILE(VSAMIN) -\n   OUTFILE(SEQOUT) -\n   FROMKEY(X'0B') -\n   TOKEY(X'0B')\n/*\n//STEP3       EXEC  PGM=AAUEAVSM\n//STEPLIB     DD    DSN=SYS1.CNMLINK,DISP=SHR\n//INFILE      DD    DSN=&&TEMPDS,DISP=(OLD,DELETE)\n//OUTFILE     DD    SYSOUT=*\n//\n\nThis job stream is provided as member CNMSJM10 in the\nCNMSAMP dataset.  The job can be executed while NetView\nis active or inactive.  A report is generated similar to the one\nshown in Figure 1.  The report contains up to 200 entries and\ncontains frequency counts for sense codes (totals column) and\nthe percentage.  If more than 200 entries exist, the last entry\nwill contain counts for all sense codes that are not displayed on\nthe report.\n\nAfter reviewing the report you may decide that you would like\nto filter certain sense codes.  This requires a modification to\nmember CNMS0055 in the CNMSAMP dataset.  Full details\non how to perform this modification are contained in\nCNMREAD5.  To invoke this type of filtering, NetView has to\nbe restarted.\n\nIn conclusion, these enhancements can be beneficial in\nimproving the session monitor portion of the NetView product.\nThe main savings at our installation have been a reduction in\nDASD space and automation of session monitor operation\nusing the SMDR command.\n\nJohn Bradley\nTechnical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N003A02": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x02\\xfe\\x02\\xfe\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 766, "newlines": 766, "modlines": 0, "user": "SNAUPDT"}, "text": "Printing CMS files on VTAM printers\n\nThe following EXEC and VSE Assembler program are used at\nour installation to print CMS files on VTAM-attached printers.\n\n\nVMPRINT EXEC\n\nThe EXEC reads the input file and prepares it for input to the\nVSE program, VMPRINT.  Each record is split into two 80-\nbyte records preceded by an asterisk and a blank.  The EXEC\nis issued in the following format:\n\n      VMPRINT fname ftype fmode FF=N EJE=N L=nnn DEST=destid\n\nwhere fname is the file name, ftype is the file type, fmode is\nthe file mode, FF specifies whether a form feed should be sent\nbefore starting to print the file, EJE specifies whether a form\nfeed should be sent after printing the file, nnn specifies the\nnumber of lines per page (1 to 999 or 'NO'), and destid gives\nthe destination-id.\n\n/* VMPRINT EXEC                                                       */\nARG FNAME ARG.1 ARG.2 ARG.3 ARG.4 ARG.5 .\nIF FNAME='?' THEN SIGNAL INFO\nFTYPE = LISTING                   /* DEFAULT FILE TYPE */\nFMODE = A                         /* DEFAULT FILE MODE */\nPRINTER='TD05'                    /* DEFAULT DESTINATION PRINTER */\nFF='FF=Y'                         /* DEFAULT INITIAL FORM FEED */\nEJE='EJE=Y'                       /* DEFAULT END FORM FEED */\nLPP=66                            /* DEFAULT NUMBER OF LINES PER PAGE */\nVSEMCID='VMVSE1'                  /* DEFAULT TARGET VSE MACHINE ID */\nSPCLASS='A'                       /* DEFAULT SPOOL CLASS (CP) */\nIF FNAME='' THEN SIGNAL INFO\nPROC:IF INDEX(ARG.1,'=')\u00ac=0 THEN SIGNAL OPTIONS;FTYPE=ARG.1\nIF INDEX(ARG.2,'=')\u00ac=0 THEN SIGNAL OPTIONS;FMODE=ARG.2\nOPTIONS: DO X=1 TO 6 BY 1\nIF SUBSTR(ARG.X,1,5)='DEST=' THEN PRINTER=SUBSTR(ARG.X,6,LENGTH(ARG.X)-5)\nIF SUBSTR(ARG.X,1,4)='FF=N' THEN FF=' FF=N '\nIF SUBSTR(ARG.X,1,5)='EJE=N' THEN EJE=' EJE=N'\nIF SUBSTR(ARG.X,1,6)='L=' THEN LPP=SUBSTR(ARG.X,7,3)\nEND\nSET 'CMSTYPE RT'\nSTATE FNAME FTYPE FMODE\nIF RC\u00ac=0 THEN SIGNAL EXIT\nDESBUF\nLISTFILE FNAME FTYPE FMODE '(LABEL STACK NOHEADER'\nPULL . . . RECFM LINELEN NRECS .\nQUEUE \"* $$ JOB JNM=VMPRINT,CLASS=5,DISP=D,SYSID=1,USER='909KOD VMPRINT'\"\nQUEUE '* $$ LST CLASS=Q'\nQUEUE '// JOB VMPRINT'\nQUEUE '// LIBDEF PHASE,SEARCH=APPLIB1,SUBLIBT,TEMP'\nQUEUE \"// EXEC VMPRINT,PARM='\"PRINTER\"'\"\nQUEUE \"* $$VMPRINT \" FF EJE \"L=\"LPP \" CMS USER=\"LEFT(USERID(),8)\nCP 'SP PUN 'VSEMCID' CL 'SPCLASS\nEXECIO '6 PUNCH '\nDO X=1 TO NRECS BY 1\n     EXECIO '1 DISKR 'FNAME FTYPE FMODE '(VAR LINE'\n     LINE=LINE''COPIES(\" \",132)\n     LINEO='* 'SUBSTR(LINE,1,78)\n     EXECIO '1 PUNCH (VAR LINEO'\n     LINEO='* 'SUBSTR(LINE,79,78)\n     EXECIO '1 PUNCH (VAR LINEO'\nEND\nQUEUE '/*'\nQUEUE '/&'\nQUEUE '* $$ EOJ'\nEXECIO '3 PUNCH'\nCP 'SET IMSG OFF'\nCP 'SP PUN CLOSE'\nCP 'SP PUN SYSTEM'\nCP 'SET IMSG ON'\nEXIT 00\nINFO: SAY \"FORMAT IS:\"\n      SAY \" \"\n      SAY \"VMPRINT FNAME FTYPE FMODE DEST=XXXXXXXX FF=Y EJE=Y L=NNN\"\nEXIT\n\n\nVMPRINT ASSEMBLER PROGRAM\n\nThis program runs in a VSE batch partition.  It reads card-\nimage data and prints the output on a specified printer.  The\nprinter can print lines of 80 or 120 characters depending on the\nparameters supplied in the control card.  If a line length of 120\ncharacters is required, two input records are read to form one\noutput line.  All input records start with an asterisk and a\nspace.  This is the usual input to the program and is prepared\nby the VMPRINT EXEC.  A print line of 120 characters is\nindicated by 'CMS' on the control card.  The control card is in\nthe following format:\n\n      * $$VMPRINT FF=y/n EJE=y/n L=nnn CMS USER=userid\n\nwhere * $$VMPRINT is the control card identifier, FF\nspecifies whether a form feed is to be sent before starting a\nprint, EJE specifies whether a form feed is to be sent after the\nprint job, nnn specifies the number of lines to print before\nskipping to a new page (1 to 999 or 'NO'), CMS indicates that\na 120-character print line is to be used, and userid identifies the\nCMS user-id of the requestor (alternatively the batch job name\ncould be specified).\n\nThe program requires an entry in VTAM's application names\nbook with authority to acquire, similar to this:\n\n      VMPRINT   APPL AUTH=(ACQ)\n\nVMPRINT assumes the printer has a buffer size of 1920 bytes.\nSYSIPT should be assigned to a reader and SYSLST should be\nassigned to a printer.  The program is set up to print on printers\nattached to 3274 model A or C controllers.  If you have model\nB or D controllers, two statements must be changed.  At label\nFORMFEED, the hexadecimal constant 'F5380C' must be\nchanged to read X'05380C' and at label WCC, X'F538' should\nbe changed to read X'0538'.\n\nVMPRINT  CSECT\n         LR     12,15                   BASE REGS ARE 12 & 9\n         LA     9,4095(,12)\n         LA     9,1(,9)\n         USING  VMPRINT,12,9            ADDRESSABILITY\n         LA     10,RPL1\n         USING  IFGRPL,10               RPL DSECT\n         LA     11,NIB1\n         USING  ISTDNIB,11              NIB DSECT\n         LA     8,ACB\n         USING  IFGACB,8                ACB DSECT\n         TM     0(1),X'80'              WAS PARM= SPECIFIED ?\n         BNO    NOPRTID                 NO - WRITE ERROR\n         CR     1,15                    IS PARM LENGTH 0 ?\n         BE     NOPRTID                 YES WRITE ERROR\n         LR     6,1                     SAVE ADDRESS OF PRINTER ID\n         COMRG\n         MVC    USERID(8),24(1)         MOVE IN JOBNAME\n         OPEN   IN                      OPEN INPUT\n         OPEN   ACB                     ACB\n         TM     ACBOFLGS,X'10'          IS IT OPEN ?\n         BO     ACBOK\n         LA     8,ACBERFLG              ERROR RETURN CODE\n         LA     2,1                     LENGTH TO CONVERT\n         BAL    7,CONVERT               CONVERT TO PRINTABLE\n         DROP   8                       DROP ACB ADDRESSABILITY\n         MVC    ACBRC(2),CONDATA        MOVE INTO ERROR MESSAGE\n         MVC    ERRORMSG(LACBFAIL),ACBFAIL MOVE TO ERROR BUFFER\n         BAL    7,SAYERROR              TELL OPERATOR\n         BAL    7,PUTOUT                WRITE MESSAGE\n         OI     SWITCH2,READ2END\n         OI     SWITCH,EXITRC8\n         B      EXIT                    EXIT RC=8\n* INSERT PRINTER NAME INTO NIB FROM PARM= OPERAND OF EXEC CARD\nACBOK    SR     2,2                     CLEAR R2\n         ICM    2,7,1(6)                INSERT ADDRESS OF PARM LENGTH\n         LH     3,0(2)                  LOAD LENGTH OF PARM\n         BCTR   3,0                     LESS ONE FOR EXECUTE\n         EX     3,MVCPRTIN              MOVE INTO NIB\n         EX     3,MVCPRTID              MOVE INTO MESSAGE\n         EX     3,MVCPRTI2              MOVE INTO MESSAGE\nSETLOGON SETLOGON RPL=(10),OPTCD=START  ALLOW LOGON REQUESTS\n         LTR    15,15\n         BZ     SIMLOGON\n         OI     SWITCH2,READ2END\n         OI     SWITCH,EXITRC8\n         B      EXIT\nSIMLOGON SIMLOGON RPL=(10),NIB=(11),    HAVE PRINTER LOGON TO US       X\n               OPTCD=(RELRQ,Q,SYN)\n         LTR    15,15                   CHECK RETURN CODE\n         BZ     SETDONE\n         MVC    GENLBL(9),=CL9'SIMLOGON' WHERE THE ERROR OCCURRED\n         OI     SWITCH,EXITRC8          SET RC=8\n         OI     SWITCH2,READ2END\n         BAL    6,TESTRPL               SHOW RTNCD AND FEEDBACK CODES\n         B      EXIT                    EXIT\nSETDONE  TM     ECB1+2,X'80'            IS LOGON ECB ALREADY POSTED ?\n         BO     PASTWAIT                YES DONT WAIT\n         SETIME 30,TIMERECB             SET MAX 30 SECS FOR LOGON\n         WAITM  ECB1,TIMERECB,TPENDECB  WAIT FOR AN ECB\nPASTWAIT TM     TPENDECB+2,X'80'        IS VTAM CLOSING DOWN ?\n         BNO    *+16\n         OI     SWITCH2,READ2END\n         OI     SWITCH,EXITRC8\n         B      VTAMHALT\n         TM     TIMERECB+2,X'80'        HAS 30 SECONDS EXPIRED\n         BNO    CHKCON\n         MVC    ERRORMSG(LTIMEREX),TIMEREX SAY WERE STILL WAITING\n         BAL    7,SAYERROR              TELL OPERATOR\n         XC     TIMERECB(4),TIMERECB    CLEAR ECB\n         B      SETDONE                 GO TO WAIT\nCHKCON   TM     NIBFLG1,X'40'           CHECK SESSION ESTABLISHED\n         BO     CONOK                   YES\n         TM     SWITCH,RETRYED          HAVE WE ALREADY RETRIED CONNECT\n         BO     NOLOGO                  YES WRITE ERROR\n         OI     SWITCH,RETRYED          SIGNIFY RETRY DONE\n         L      15,=A(LOGON1)           ADDRESS OF LOGON ROUTINE\n         BALR   14,15                   RETRY CONNECTION\n         B      CHKCON                  SEE IF IT WORKED THIS TIME\nNOLOGO   MVC    GENLBL(9),=CL9'CINIT'   WHERE ERROR OCCURRED\n         BAL    6,TESTRPL               SHOW RPL ERROR FIELDS\n         OI     SWITCH,EXITRC8          SET RC=8\n         OI     SWITCH2,READ2END\n         B      EXIT                    EXIT\nCONOK    MODCB  RPL=(10),BRACKET=(BB,NEB),AM=VTAM SET NOT END BRACKET\n         GET    IN                      GET INPUT LINE\n         CLC    LINEIN(11),=C'* $$VMPRINT' IS IT THE CONTROL CARD ?\n         BNE    NOTCMS                  NO, NOT FROM VMPRINT EXEC\n         LA     4,60                    YES SCAN FOR OPTIONS\n         LA     5,LINEIN+11             START SCAN HERE\nCHKFFEED CLC    0(4,5),=CL4'FF=N'       NO INITIAL FORMFEED REQUEST ?\n         BNE    *+8                     NO SKIP NEXT INSTRUCTION\n         OI     SWITCH,NOSTRTFF         INDICATE NO FORMFEED\n         CLC    0(5,5),=CL5'EJE=N'      NO END FORMFEED?\n         BNE    *+8                     NO SKIP NEXT LINE\n         OI     SWITCH2,NOENDFF         INDICATE NO EJECT REQUEST\n         CLC    0(5,5),=CL5' CMS '      FROM VMPRINT EXEC ?\n         BNE    *+8                     NO SKIP NEXT LINE\n         OI     SWITCH2,FROMCMS         INDICATE FORMATTED BY EXEC\n         CLC    0(5,5),=CL5'USER='      USERID? (FOR EOJ TRAILER)\n         BNE    *+10                    NO SKIP NEXT LINE\n         MVC    USERID(8),5(5)          MOVE USERID\n         LA     5,1(5)                  BUMP POINTER\n         CLC    0(2,5),=CL2'L='         NO OF LINES PER PAGE SET\n         BNE    BCT                     NO, CONTINUE\n         CLC    2(2,5),=CL2'NO'         NO LINE COUNT REQUIRED ?\n         BNE    *+8                     NO, SKIP NEXT INSTRUCTION\n         OI     SWITCH2,NOLINECN        YES, TAKE A NOTE\n         TM     2(5),X'F0'              IS FIRST DIGIT NUMERIC?\n         BNO    BCT                     NO, IGNORE THIS OPERAND\n         OI     SWITCH2,LPPGIVEN        INDICATE LINES PER PAGE SET\n         TM     3(5),X'F0'              IS IT A TWO DIGIT NUMBER?\n         BNO    MOVLPP1                 NO, MOVE IN ONE DIGIT\n         TM     4,(5),X'F0'             IS IT A THREE DIGIT NUMBER?\n         BNO    MOVLPP2                 NO, MOVE IN TWO DIGITS\nMOVLPP3  MVC    DWORD+5(3),2(5)         YES, MOVE IN THREE DIGITS\n         B      BCT\nMOVLPP2  MVC    DWORD+6(2),2(5)\n         B      BCT\nMOVLPP1  MVC    DWORD+7(1),2(5)\nBCT      BCT    4,CHKFFEED              CONTINUE SCAN\n         TM     SWITCH2,LPPGIVEN        WAS LINES PER PAGE SET?\n         BNO    CHKFORM                 NO, USE DEFAULT\n         PACK   DWORD(8),DWORD(8)       YES, PACK IT\n         CVB    8,DWORD                 CONVERT TO BINARY\n         STH    8,LINESPP               STORE OVER DEFAULT\n* A LINE IN THE SEND BUFFER HAS THE FOLLOWING FORMAT\n* BYTE 1 IS EITHER A BLANK OR A LINEFEED CHARACTER(X'15')\n* BYTE 2 IS EITHER A BLANK OR A FORMFEED CHARACTER(X'0C')\n* THE REST IS DATA\nCHKFORM  TM     SWITCH2,FROMCMS         FORMATTED INPUT FROM CMS EXEC?\n         BO     CMSINPUT                YES\n         GET    IN                      MOVE FIRST DATA LINE INTO BUFF\n         B      NOTCMS                  GO PROCESS\nCMSINPUT MVI    WCC+1,X'08'             CHANGE WCC TO 132 CHARACTER LEN\n         MVI    FORMFEED+1,X'08'        DITTO\n         SR     8,8                     ZERO LINE COUNTER\nGETINP   LA     4,16                    LINES PER BLOCK OF SEND DATA\n         LA     5,BUF                   SEND BUFFER ADDRESS\n         MVI    BUF,X'40'               INITALIZE BYTE ONE AS A BLANK\n         TM     SWITCH,NOSTRTFF         FORMFEED NOT REQUIRED?\n         BO     NOFF                    YES,SKIP FORM FEED\n         MVI    0(5),X'0C'              NO,MOVE IN FORMFEED CHARACTER\n         OI     SWITCH,NOSTRTFF         INDICATE WE'VE DONE IT\nNOFF     LA     5,1(5)                  BUMP BUFFER ADDRESS\nGET      GET    IN                      GET INPUT\n         MVC    0(78,5),LINEIN+2        MOVE INTO BUFFER, IGNORE '* '\n         GET    IN                      NEXT LINE\n         MVC    78(41,5),LINEIN+2       APPEND TO THE PREVIOUS LINE\n         LA     5,118(5)                BUMP BUFFER ADDRESS\n         MVI    0(5),X'15'              INSERT LINEFEED\n         LA     8,1(8)                  BUMP LINE COUNTER\n         MVI    1(5),X'40'              INITALIZE AS BLANK\n         TM     SWITCH2,NOLINECN        NO LINE COUNT SPECIFIED ?\n         BO     GETNLINE                YES, GET A NEW LINE\n         CH     8,LINESPP               LINE COUNTER > LINES PER PAGE?\n         BL     GETNLINE                NO,GET ANOTHER LINE\n         MVI    1(5),X'0C'              YES,INSERT FORMFEED\n         CH     4,=H'1'                 IS THIS THE LAST LINE IN BLOCK?\n         BE     GETNLINE                YES,WE'LL SKIP A PAGE NEXT TIME\n         SR     8,8                     NO, RESET LINE COUNTER\nGETNLINE LA     5,1(5)                  BUMP BUFFER ADDRESS\n         BCT    4,NOFF                  GET NEXT LINE\nGOTINP   LA     4,WCC                   START OF SEND BUFFER\n         SR     5,4                     SUBTRACT FROM LAST BUFFER POS\n         LR     6,5                     SAVE LENGTH TO SEND IN R6\n         BAL    14,CHKPRTOK             CHANGE NON PRINT CHARS TO BLANK\n         LA     4,WCC                   ADDRESS OF SEND BUFFER\n         LR     5,6                     LENGTH TO SEND\n         BAL    7,SEND                  SEND TO PRINTER\n         TM     SWITCH,NBBDONE          ALREADY BETWEEN BRACKETS ?\n         BO     TESTEOF                 YES CHECK FOR EOF ON INPUT FILE\n         MODCB  RPL=(10),BRACKET=(NBB,NEB),AM=VTAM  SET BETWEEN BRACKET\n         OI     SWITCH,NBBDONE          INDICATE BETWEEN BRACKET\nTESTEOF  TM     SWITCH,EOFREACH         EOD ROUTINE ENTERED ?\n         BNO    GETINP                  NO GET NEXT LINES\n         MODCB  RPL=(10),BRACKET=(NBB,EB),AM=VTAM SET END BRACKET\n         TM     SWITCH2,NOENDFF         EJECT NOT WANTED ?\n         BO     CLOSEDST                YES NO FORMFEED\n         BAL    6,SKIPPAGE              SEND FORM FEED\n         B      CLOSEDST                CLOSE UP\n* INPUT DATA NOT PREPARED BY CMS VMPRINT EXEC - 80 CHAR PRINT LINE\nNOTCMS   LA     4,24                    NUMBER OF LINES PER SEND BLOCK\n         LA     5,BUF                   ADDRESS OF SEND BUFFER\n         SR     8,8                     COUNTER\n         MVI    BUF,C' '                INIT BYTE ONE AS BLANK\n         TM     SWITCH,NOSTRTFF         NO FORMFEED REQUESTED ?\n         BO     GET801                  YES\n         MVI    BUF,X'0C'               PERFORM FORMFEED\n         LA     5,1(5)                  BUMP POINTER\n         B      GET801                  WE'VE ALREADY READ FIRST LINE\nGETINP80 LA     4,24                    LINE COUNT PER BLOCK\n         LA     5,BUF                   OUTPUT BUFFER\n         MVI    BUF,C' '                INIT BYTE ONE\nGET80    LA     5,1(5)                  BUMP POINTER\n         GET    IN                      GET AN INPUT LINE\nGET801   MVC    0(79,5),LINEIN          MOVE INTO BUFFER\n         LA     5,79(5)                 BUMP BUFFER ADDR\n         MVI    0(5),X'15'              INSERT LINE FEED\n         LA     8,1(8)                  BUMP LINE COUNTER\n         TM     SWITCH2,NOLINECN        NO LINE COUNT SPECIFIED ?\n         BO     BCT80                   YES, GET A NEW LINE\n         CH     8,LINESPP               TIME FOR A PAGE FEED?\n         BL     BCT80                   NO, CONTINUE\n         MVI    0(5),X'0C'              YES, INSERT FORM FEED\n         CH     4,=H'1'                 LAST LINE IN BLOCK?\n         BE     BCT80                   YES, DONT RESET COUNTER\n         SR     8,8                     NO, RESET COUNTER\nBCT80    BCT    4,GET80                 GET NEXT LINE\nGOTINP81 LA     4,WCC                   START OF BUFFER\n         SR     5,4                     SUBTRACT FROM LAST BYTE ADDRESS\n         LR     6,5                     SAVE LENGTH TO SEND IN R6\n         BAL    14,CHKPRTOK             CHANGE NON PRINT CHARS TO BLANK\n         LA     4,WCC                   ADDR OF DATA TO SEND\n         LR     5,6                     LENGTH\n         BAL    7,SEND                  SEND IT TO PRINTER\n         TM     SWITCH,NBBDONE          ALREADY BETWEEN BRACKET STATE?\n         BO     TESTEOF8                YEP\n         MODCB  RPL=(10),BRACKET=(NBB,NEB),AM=VTAM  SET BETWEEN BRACKET\n         OI     SWITCH,NBBDONE          INDICATE WE'VE DONE IT\nTESTEOF8 TM     SWITCH,EOFREACH         WAS EOF ROUTINE ENTERED ?\n         BNO    GETINP80                NO GET SOME MORE LINES\n         MODCB  RPL=(10),BRACKET=(NBB,EB),AM=VTAM SET END BRACKET\n         TM     SWITCH2,NOENDFF         EJECT NOT WANTED ?\n         BO     CLOSEDST                YES\n         BAL    6,SKIPPAGE              NO - EJECT\nCLOSEDST CLSDST RPL=RPL1,ACB=ACB,OPTCD=(SYN,RELEASE) CLOSE DESTINATION\nEXIT     TM    SWITCH2,READ2END         DO WE HAVE TO READ ANY REMAINING\n         BNO   EXIT3                    INPUT ? NO\n         TM     SWITCH,EOFREACH         EOF ROUTINE ALREADY ENTERED ?\n         BO     EXIT3                   YES\nEXIT2    GET   IN                       GET INPUT TILL EOF ROUTINE\n         B     EXIT2                    ENTERED, IT BRANCHES TO EXIT3\nEXIT3    CLOSE ACB                      CLOSE ACB\n         CLOSE IN                       CLOSE INPUT\n         TM    SWITCH,OUTOPEN           DID WE OPEN OUTPUT ?\n         BNO   CHKRC8                   NO - NO NEED TO CLOSE\n         CLOSE OUT                      CLOSE OUTPUT\nCHKRC8   TM    SWITCH,EXITRC8           RC=8 WANTED  ?\n         BO    EOJRC8\n         TM    SWITCH,EXITRC12          RC=12 WANTED ?\n         BO    EOJRC12\nEOJRC0   EOJ   RC=0                     END OF JOB\nEOJRC8   EOJ   RC=8\nEOJRC12  EOJ   RC=12\nSKIPPAGE LA    4,FORMFEED               WCC WITH FORMFEED\n         LA    5,LFF                    LENGTH OF DATA\n         BAL   7,SEND                   SEND IT\n         BR    6                        RETURN\nVTAMHALT MVC   ERRORMSG(L'VTAMSTOP),VTAMSTOP  CLOSING DUE TO VTAM HALT\n         BAL   7,SAYERROR               TELL OPERATOR\n         BAL   7,PUTOUT                 SAY IT\n         B     CLOSEDST                 CLOSE UP\nSEND     SEND  RPL=RPL1,AREA=(4),RECLEN=(5),OPTCD=SYN,                 X\n               POST=RESP,CONTROL=DATA,STYPE=REQ,                       X\n               RESPOND=(NEX,FME)\n         LTR   15,15                    SEND OK?\n         BZR   7                        YES RETURN\n         ST    15,SAVE15                ST R15\n         LA    8,SAVE15                 ADDR OF DATA TO CONVERT\n         LA    2,4                      LENGTH\n         BAL   7,CONVERT                CONVERT TO PRINTABLE\n         MVC   ERRORMSG(15),=CL15'SEND ERROR R15='\n         MVC   ERRORMSG+15(8),CONDATA\n         BAL   7,SAYERROR               TELL OPERATOR\n         BAL   7,PUTOUT                 WRITE ERROR MSG\n         BAL   6,TESTRPL                SHOW RPL RTNCD & FBDK2 CODES\n         OI    SWITCH,EXITRC8           INDICATE RC=8\n         OI    SWITCH2,READ2END         READ ANY REMAINING DATA\n         B     CLOSEDST                 CLOSE SESSION\nPUTOUT   TM    SWITCH,OUTOPEN           OUTPUT FILE OPEN ?\n         BO    WRITEMSG\n         OPEN  OUT                      NO OPEN IT UP\n         OI    SWITCH,OUTOPEN           TAKE A NOTE\nWRITEMSG PUT   OUT                      WRITE MESSAGE\n         MVI   ERRORMSG,C' '            CLEAR\n         MVC   ERRORMSG+1(79),ERRORMSG        BUFFER\n         BR    7                        RETURN\nSAYERROR LA    1,CCB                    WRITE TO CONSOLE\n         EXCP  (1)\n         WAIT  (1)\n         BR    7\nCCB      CCB   SYSLOG,CCW\nCCW      CCW   X'09',ERRORMSG,X'20',50\nTESTRPL  ST    7,SAVE7                  SAVE R7\n         LA    8,RPLRTNCD               VTAM RETURN CODE\n         LA    2,1                      LENGTH\n         BAL   7,CONVERT                CONVERT TO PRINTABLE\n         MVC   GENRTNCD(2),CONDATA      MOVE INTO MESSAGE\n         LA    8,RPLFDB2                SAME FOR FEEDBACK CODE\n         LA    2,1\n         BAL   7,CONVERT\n         MVC   GENFDBK2(2),CONDATA\n         LA    8,RPLSSEI                AND SENSE INFO\n         LA    2,2\n         BAL   7,CONVERT\n         MVC   GENSENSE(4),CONDATA\n         MVC   ERRORMSG(LGENMSG),GENMSG\n         BAL   7,SAYERROR               TELL OPERATOR\n         BAL   7,PUTOUT                 WRITE MESSAGE\n         L     7,SAVE7                  RESTORE R7\n         BR    6                        RETURN\nEOD      OI    SWITCH,EOFREACH          INDICATE EOD ON INPUT\n         TM    SWITCH2,READ2END         READING FILE TO END DUE TO ERR?\n         BO    EXIT3                    YES - EXIT\n         TM    SWITCH2,FROMCMS          PRINTING A CMS FILE ?\n         BNO   GOTINP81                 NO\n         B     GOTINP                   YES\nNOPRTID  MVC   ERRORMSG(L'NOPRTIDM),NOPRTIDM  NO PRINTER ID GIVEN\n         BAL   7,SAYERROR\n         OI    SWITCH2,READ2END\n         OI    SWITCH,EXITRC8\n         B     EXIT\nCONVERT  MVI   CONDATA,C' '             CLEAR\n         MVC   CONDATA+1(39),CONDATA          BUFFER\n         LA    5,CONDATA                BUFFER ADDRESS\nCONV     SR    3,3                      CLEAR R3\n         IC    3,0(8)                   INSERT 1 HEX CHAR\n         AR    3,3                      DOUBLE FOR CHAR\n         LA    4,CHARTAB                PRINTABLE HEX TAB\n         AR    4,3                      +R3 = OFFSET IN TAB\n         MVC   0(2,5),0(4)              MOVE INTO BUFFER\n         LA    5,2(5)                   BUMP BUFFER\n         LA    8,1(8)                   POINT TO NEXT CHAR\n         BCT   2,CONV                   DO TO END\n         BR    7                        RETURN\n* TRANSLATE NONPRINTABLE CHARACTERS TO BLANKS RETURN VIA R14\nCHKPRTOK LA    4,8                      NUMBER OF 255 BYTE BLOCKS\n         LA    7,BUF                    FIRST BLOCK\n         LA    1,BUF-1                  DATA ADDRESS\nDOIT     LA    3,255                    LENGTH\n         LA    5,255(1)                 END OF BLOCK\nTPRNTABL EX    3,TRT                    XLATE BYTE\n         BC    10,ENDSCAN               END OF SCAN ?\n         STC   2,0(1)                   REPLACE INVALID BYTE BY BLANK\n         SR    5,1                      MINUS HIT ADDR = LENGTH LEFT\n         LR    3,5                      NEW STARTING POINT FOR SCAN\n         B     TPRNTABL                 GO CHECK IT\nENDSCAN  LA    7,255(7)                 NEXT BLOCK TO CHECK\n         LR    1,7                      ADDRESS IN R1\n         BCT   4,DOIT                   CHECK IT 8 TIMES\n         BR    14                       RETURN\nTRT      TRT   1(*-*,1),PRINTAB         DUMMY FOR EXECUTE\nMVCPRTIN MVC    NIBSYM(*-*),2(2)          \"    \"    \"\nMVCPRTID MVC    PRINTRID(*-*),2(2)        \"    \"    \"\nMVCPRTI2 MVC    LERADM1+23(*-*),2(2)      \"    \"    \"\n*        LOGON EXIT\nLOGON1   DS     0H\n         DROP   12,9                    DROP ADDRESSABILITY\n         USING  *,15                    ENTRY POINT\n         L      12,BASEREG              RESTORE BASE REGS\n         L      9,BASEREG2\n         DROP   15\n         USING  VMPRINT,12,9            RESTORE ADDRESSABILITY\n         LA     10,RPL1\n         USING  IFGRPL,10               RPL DSECT\n         LA     11,NIB1\n         USING  ISTDNIB,11              NIB DSECT\n         ST     13,SAVE13               SAVE SAVEAREA ADDR\n         LA     13,SAVEAREA             NEW SAVEAREA\n         ST     14,SAVE14               SAVE RETURN ADDR\n         SETLOGON RPL=RPL1,OPTCD=HOLD   NO MORE LOGONS PLEASE\n         OPNDST RPL=RPL1,OPTCD=(SYN,ACCEPT) ACCEPT LOGON FROM PRINTER\n         POST   ECB1                    TELL MAINLINE ABOUT IT\n         L      13,SAVE13               RESTORE SAVEAREA\n         L      14,SAVE14               RESTORE RET ADDR\n         BR     14                      RETURN TO VTAM\n*        TPEND EXIT ROUTINE\nTPENDEX  DS     0H                      RESTORE ADDRESSABILITY\n         DROP   12,9\n         USING  *,15\n         L      12,BASEREG\n         L      9,BASEREG2\n         DROP   15\n         USING  VMPRINT,12,9\n         LA     10,RPL1\n         USING  IFGRPL,10\n         LA     11,NIB1\n         USING  ISTDNIB,11\n         ST     14,SAVE14\n         POST   TPENDECB                TELL MAINLINE VTAM CLOSING\n         L      14,SAVE14\n         BR     14                      RETURN TO VTAM\n*        SYNAD EXIT ROUTINE\nSYNADEX  DS     0H                      RESTORE ADDRESSABILITY\n         DROP   12,9\n         USING  *,15\n         L      12,BASEREG\n         L      9,BASEREG2\n         DROP   15,\n         USING  VMPRINT,12,9\n         ST     14,SAVE14               SAVE RET ADDR\n         ST     13,SAVE13               SAVE SAVEAREA\n         STM    0,15,ABNDREGS           STORE REGS FOR DEBUGGING\n         LA     13,SAVEAREA             NEW SAVE AREA\n         LR     10,1                    VTAM READ ONLY RPL\n         LR     2,0                     RETURN CODE IN R2\n         B      *(2)                    GO TO APPLICABLE ROUTINE\n         B      EXCEPTRS                EXCEPTION RESPONSE\n         B      REISSUE                 RETRIABLE ERROR\n         B      DINTDAM                 DATA INTEGRITY ERROR\n         B      ENVERR                  ENVIRONMENT ERROR\n         B      USLOGIC                 LOGIC ERROR (LERAD)\n         B      NOTINRPL                  \"     \"   (NO INFO IN RPL)\nEXCEPTRS MVC    ERRORMSG(L'LERADM1),LERADM1  ERROR MESSAGE\n         BAL    7,SAYERROR              TELL OPERATOR\n         BAL    7,PUTOUT                     WRITE IT\n         BAL    6,TESTRPL                    SHOW RPL FIELDS\n         BAL    7,GETSENSE                   XLATE SENSE CODE INTO TEXT\n         OI     SWITCH2,READ2END\n         OI     SWITCH,EXITRC8\n         B      CLOSEDST\nREISSUE  MVC    ERRORMSG(L'LERADM2),LERADM2\n         BAL    7,SAYERROR              TELL OPERATOR\n         BAL    7,PUTOUT\n         BAL    6,TESTRPL\n         BAL    7,GETSENSE\n         TM     SWITCH,REISSUED         ALREADY RETRIED ?\n         BNO    REDO                    NO TRY AGAIN\n         OI     SWITCH2,READ2END        GET RID OF ANY REMAINING INPUT\n         OI     SWITCH, EXITRC8         INDICATE RC=8\n         B      CLOSEDST                CLOSE SESSION\nREDO     OI     SWITCH,REISSUED         INDICATE WE'VE RETRIED\n         LM     0,15,ABNDREGS           REST REGS\n         EXECRPL RPL=(1)                RETRY\n         L      13,SAVE13               REST\n         L      14,SAVE14                    REGS\n         BR     14                      RETURN TO VTAM\nDINTDAM  MVC    ERRORMSG(L'LERADM3),LERADM3\n         BAL    7,SAYERROR              TELL OPERATOR\n         BAL    7,PUTOUT\n         BAL    6,TESTRPL\n         BAL    7,GETSENSE\n         OI     SWITCH2,READ2END        GET RID OF ANY REMAINING INPUT\n         OI     SWITCH,EXITRC8          INDICATE RC=8\n         B      CLOSEDST\nENVERR   MVC    ERRORMSG(L'LERADM4),LERADM4\n         BAL    7,SAYERROR              TELL OPERATOR\n         BAL    7,PUTOUT\n         BAL    6,TESTRPL\n         BAL    7,GETSENSE\n         OI     SWITCH2,READ2END        GET RID OF ANY REMAINING INPUT\n         OI     SWITCH,EXITRC8          INDICATE RC=8\n         B      EXIT\nUSLOGIC  MVC    ERRORMSG(L'LERADM5),LERADM5\n         BAL    7,SAYERRR               TELL OPERATOR\n         BAL    7,PUTOUT\n         BAL    6,TESTRPL\n         BAL    7,GETSENSE\n         B      DUMP\nNOTINRPL MVC    ERRORMSG(L'LERADM6),LERADM6\n         BAL    7,SAYERROR              TELL OPERATOR\n         BAL    7,PUTOUT\n         BAL    6,TESTRPL\n         BAL    7,GETSENSE\n         B      DUMP\nLERADM1  DC     C'EXCEPTION CONDITION ON         '\nLERADM2  DC     C'RETRIABLE COMPLETION CODE R0=08'\nLERADM3  DC     C'DATA INTEGRITY DAMAGE R0=0C'\nLERADM4  DC     C'ENVIRONMENT ERROR R0=10'\nLERADM5  DC     C'INTERNAL LOGIC ERROR R0=14'\nLERADM6  DC     C'INTERNAL LOGIC ERROR RPL FIELDS NOT VALID R0=18'\n         DC     C'*VMPRINT R0-15 SAVE AREA*'\nABNDREGS DC     18F'0'\nDUMP     DUMP                           DUMP PARTITION\n         OI     SWITCH,EXITRC12\n         OI     SWITCH2,READ2END        GET RID OF ANY REMAINING INPUT\n         OI     SWITCH,EXITRC8          INDICATE RC=8\n         B      EXIT\nGETSENSE ST     7,SAVE7                 SAVE R7\n         L      15,=A(SENSOR)           ADDRESS OF ROUTINE\n         BALR   14,15                   BRANCH TO IT\n         MVC    ERRORMSG(50),4(2)       ERROR MESSAGE AT R2+4\n         BAL    7,SAYERROR              TELL OPERATOR\n         BAL    7,PUTOUT\n         L      7,SAVE7\n         BR     7\nECB1     DC    1F'0'                    LOGON ECB POSTED BY LOGON1\nTPENDECB DC    1F'0'                    VTAM CLOSING DOWN\nTIMERECB DC    1F'0'                    TIMER ECB\nENDLIST  DC    X'FF'\nSAVE13   DC    1F'0'                    SAVE REGS\nSAVE14   DC    1F'0'\nSAVE15   DC    1F'0'\nSAVE7    DC    1F'0'\nSAVEAREA DC    18F'0'                   SAVE AREA FOR MACROS\nRPL1     RPL   AM=VTAM,ACB=ACB,OPTCD=(SYN,CONALL,Q)\nRPL1LEN  EQU   *-RPL1\nNIB1     NIB   PROC=ORDRESP\nACB      ACB   APPLID=APPLNAME,MACRF=LOGON,AM=VTAM,EXLST=EXLST1\nEXLST1   EXLST SYNAD=SYNADEX,TPEND=TPENDEX,LOGON=LOGON1,               X\n               AM=VTAM\nIN       DTFCD TYPEFLE=INPUT,RECFORM=FIXUNB,EOFADDR=EOD,               X\n               DEVADDR=SYSIPT,BLKSIZE=80,IOAREA1=LINEIN\nOUT      DTFPR DEVADDR=SYSLST,IOAREA1=ERRORMSG,BLKSIZE=80\nAPPLNAME DC    X'08',CL8'VMPRINT '      APPL NAME\nCONDATA  DC    CL40' '                  USED BY CONVERT ROUTINE\nERRORMSG DC    CL80' '                  USED BY PUTOUT ROUTINE\nLINESPP  DC    1H'66'                   DEFAULT NUMBER LINES PER PAGE\nDWORD    DC    1D'0'                    WORK DWORD\nBASEREG  DC    A(VMPRINT)               BASEREG 1\nBASEREG2 DC    A(VMPRINT+4096)          BASEREG 2\nFORMFEED DC    X'F5080C'                ERASE/WRITE 80 CHAR+FORM FEED\n         DC    C'*** END OF CMS PRINT OPERATION FOR USER '\nUSERID   DC    CL9' ',C' ***'\nLFF      EQU   *-FORMFEED\nWCC      DC    X'F538'                  ERASE/WRITE 80 CHAR\nBUF      DC    2480C' '                 SEND BUFFER\nENDBUF   EQU   *                        END OF BUFFER\nLINEIN   DC    CL80' '                  INPUT LINE BUFFER\nSWITCH   DC    X'00'\nEXITRC12 EQU   X'01'                    EXIT WITH RC=12\nEXITRC8  EQU   X'02'                    EXIT WITH RC=8\nEOFREACH EQU   X'04'                    END OF FILE ON INPUT REACHED\nRETRYED  EQU   X'08'                    CONNECTION/RESEND TRIED ONCE\nNBBDONE  EQU   X'10'                    MODCB NOT BEGIN BRACKET DONE\nREISSUED EQU   X'20'                    RETRIABLE ERROR RETRIED ONCE\nOUTOPEN  EQU   X'40'                    OUTPUT FILE HAS BEEN OPENED\nNOSTRTFF EQU   X'80'                    NO INITIAL FORMFEED REQUIRED\nSWITCH2  DC    X'00'\nNOENDFF  EQU   X'01'                    NO EJECT AT PRINT END OF JOB\nFROMCMS  EQU   X'02'                    INPUT WAS FORMATTED  BY  CMS\nREAD2END EQU   X'04'                    DISCARD ANY  REMAINING INPUT\nLPPGIVEN EQU   X'08'                    NO OF LINES PER PAGE SUPPLIED\nNOLINECN EQU   X'10'                    NO LINE COUNTING WANTED\nGENMSG   DC    C'ERROR RTNCD='          ISSUED BY TESTRPL ROUTINE\nGENRTNCD DC    CL2'00',C' FDBK2='\nGENFDBK2 DC    CL2'00',C' SENSE='\nGENSENSE DC    CL5'0000 '\nGENLBL   DC    CL9' '\nLGENMSG  EQU   *-GENMSG\nACBFAIL  DC    C'VMPRINT01: OPEN ACB FAILED RC='\nACBRC    DC    CL2'00'\nLACBFAIL EQU   *-ACBFAIL\nLOSTTERM DC    C'VMPRINT02: COMMUNICATION FAILURE LOSTERM RC='\nLOSTERRC DC    CL8'00000000'\nLLOSTTER EQU   *-LOSTTERM\nTIMEREX  DC    C'VMPRINT03: WAITING FOR CONNECTION TO PRINTER '\nPRINTRID DC    CL8' '\nLTIMEREX EQU   *-TIMEREX\nVTAMSTOP DC    C'VMPRINT04: VMPRINT IS TERMINATING DUE TO VTAM HALT'\nNOPRTIDM DC    C'VMPRINT05: PRINTER ID NOT SPECIFIED VIA PARM= OPERAND'\nCHARTAB DC  C'000102030405060708090A0B0C0D0E0F'  HEX TO CHAR TRANSLATE\n        DC  C'101112131415161718191A1B1C1D1E1F'  TABLE\n        DC  C'202122232425262728292A2B2C2D2E2F'\n        DC  C'303132333435363738393A3B3C3D3E3F'\n        DC  C'404142434445464748494A4B4C4D4E4F'\n        DC  C'505152535455565758595A5B5C5D5E5F'\n        DC  C'606162636465666768696A6B6C6D6E6F'\n        DC  C'707172737475767778797A7B7C7D7E7F'\n        DC  C'808182838485868788898A8B8C8D8E8F'\n        DC  C'909192939495969798999A9B9C9D9E9F'\n        DC  C'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n        DC  C'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n        DC  C'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n        DC  C'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n        DC  C'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n        DC  C'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\nPRINTAB DC  X'00404040404040404040404040404040'  X'40' = INVALID CHARS\n        DC  X'40404040400040404040404040400040'  X'00' = PRINTABLE\n        DC  X'40404040404040404040404040404040'\n        DC  X'40404040404040404040404040404040'\n        DC  X'00404040404040404040000000000000'\n        DC  X'00404040404040404040000000000000'\n        DC  X'00004040404040404000000000000000'\n        DC  X'40404040404040404000000000000000'\n        DC  X'40000000000000000000404040404040'\n        DC  X'40000000000000000000404040404040'\n        DC  X'40000000000000000000404040404040'\n        DC  X'40404040404040404040404040404040'\n        DC  X'00000000000000000000404040404040'\n        DC  X'00000000000000000000404040404040'\n        DC  X'00000000000000000000404040404040'\n        DC  X'00000000000000000000404040404040'\n        LTORG\n* SNA SENSE INFO INTO A MEANINGFUL MESSAGE CALLED BY GETSENSE LABEL\nSENSOR   DS    0D\n         USING *,15                     BASE REG IS R15\n         USING IFGRPL,10                RPL ADDRESSABILITY\n         LA    2,MSGTAB                 MESSAGES\nGETMSG   CLC   0(2,2),RPLSSEI           DOES THE SENSE CODE MATCH\n         BER   14                       YES - RETURN\n         CLI   0(2),X'FF'               END OF MESSAGE TABLE ?\n         BER   14                       YES - RETURN\n         LA    2,LMSG(2)                POINT TO NEXT ENTRY\n         B     GETMSG                   GO CHECK IT\nMSGTAB   DC X'0000010C',CL50'SENSE INFORMATION NOT AVAILABLE'\nLMSG     EQU *-MSGTAB\n  DC X'8004010C',CL50'UNRECOGNIZED DAF'\n  DC X'8005010C',CL50'NO SESSION'\n  DC X'8007010C',CL50'SEGMENTING ERROR'\n  DC X'8008010C',CL50'PU NOT ACTIVE'\n  DC X'8009010C',CL50'LU NOT ACTIVE'\n  DC X'800F010C',CL50'INVALID ADDRESS COMBINATION'\n  DC X'4006010C',CL50'EXCEPTION RESPONSE NOT ALLOWED'\n  DC X'4007010C',CL50'DEFINITE RESPONSE NOT ALLOWED'\n  DC X'400A010C',CL50'NO-RESPONSE NOT ALLOWED'\n  DC X'400F010C',CL50'FORMAT INDICATOR NOT ALLOWED'\n  DC X'2001010C',CL50'SEQUENCE NUMBER ERROR'\n  DC X'2002010C',CL50'CHAINING ERROR'\n  DC X'20030008',CL50'BRACKET STATE ERROR'\n  DC X'2004010C',CL50'DIRECTION ERROR'\n  DC X'2005010C',CL50'DATA TRAFFIC RESET'\n  DC X'2009010C',CL50'SESSION CONTROL PROTOCOL VIOLATION'\n  DC X'1002010C',CL50'RU LENGTH ERROR'\n  DC X'1003010C',CL50'FUNCTION NOT SUPPORTED'\n  DC X'1005010C',CL50'PARAMETER ERROR'\n  DC X'1007010C',CL50'CATEGORY NOT SUPPORTED'\n  DC X'1008010C',CL50'INVALID FM HEADER'\n  DC X'0801010C',CL50'RESOURCE NOT AVAILABLE'\n  DC X'08020108',CL50'INTERVENTION REQUIRED - RETRYING'\n  DC X'0805010C',CL50'SESSION LIMIT EXCEEDED'\n  DC X'0807010C',CL50'SUBSIDIARY DEVICE TEMPORARILY NOT AVAILABLE'\n  DC X'080A0018',CL50'TERMINAL POWERED OFF - RETRYING'\n  DC X'080B0004',CL50'BRACKET RACE ERROR'\n  DC X'08110000',CL50'SIGNAL RECEIVED'\n  DC X'0812010C',CL50'INSUFFICIENT RESOURCE'\n  DC X'08130008',CL50'BRACKET BID REJECT'\n  DC X'08140008',CL50'BRACKET BID REJECT - RETRYING'\n  DC X'0815010C',CL50'FUNCTION ACTIVE'\n  DC X'081B0010',CL50'RECEIVER IN TRANSMIT MODE'\n  DC X'081C010C',CL50'REQUEST NOT EXECUTABLE'\n  DC X'0821010C',CL50'SESSION PARAMETERS INVALID'\n  DC X'0825010C',CL50'COMPONENT NOT AVAILABLE'\n  DC X'0829010C',CL50'CHANGE DIRECTION REQUIRED'\n  DC X'082A0000',CL50'PRESENTATION SPACE ALTERED'\n  DC X'082B0000',CL50'TERMINAL POWERED ON'\n  DC X'082D0008',CL50'DEVICE BUSY - RETRYING'\n  DC X'082E0108',CL50'INTERVENTION REQUIRED - RETRYING'\n  DC X'082F010C',CL50'NONRECOVERABLE ERROR ON SUBSIDIARY DEVICE'\n  DC X'08310108',CL50'TERMINAL POWERED OFF - RETRYING'\n  DC X'0843010C',CL50'REQUIRED FM SYNCHRONIZATION NOT SUPPLIED'\n  DC X'08450108',CL50'TERMINAL POWERED OFF - RETRYING'\n  DC X'084A0000',CL50'PRESENTATION SPACE ALTERED'\n  DC X'084C010C',CL50'RESOURCE NOT CONFIGURED'\n  DC X'0863010C',CL50'SYMBOL SET NOT LOADED'\n  DC X'0871010C',CL50'READ STATE ERROR'\n  DC X'FFFF010C',CL50'SHOULD NOT OCCUR'\n         DROP  15\n         ISTDNIB\n         IFGRPL  AM=VTAM\n         IFGACB  AM=VTAM\n         END\n\n\nRichard Keane\nSystems Programmer\nCalor Emag (Germany)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N003A03": {"ttr": 3332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x02\\xfe\\x02\\xfe\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 766, "newlines": 766, "modlines": 0, "user": "SNAUPDT"}, "text": "Data flow in LU6.2\n\nThis is the second article in a series which examines in depth\nthe LU6.2 support implemented in ACF/VTAM 3.3 via the\nAPPCCMD macro.  Getting started with LU6.2 in Issue 2 of\nSNA Update outlined two Assembler-level programs that use\nthe new LU6.2 support macros to demonstrate the comparative\nsimplicity with which APPCCMD can be used.  The second\narticle in this series will explain the complexities and subtleties\nof the data flow between the two programs.  Subsequent\narticles will consider the question of error recovery, multiple\nsession control, and various specialized features such as\nsynchronization and security.  Sample code will be given to\nillustrate key features and help simplify the design and assist\nthe development process.\n\nTo talk of data flow control in the context of what is supposed\nto be an application-level protocol may seem strange but the\nAPPCCMD implementation of LU6.2 by IBM has somewhat\nclouded the issue.  SNA defines layer 5 as Data Flow Control\n(DFC).  To those familiar with pre-LU6.2 session protocol then\nDFC protocol supports bracketing, chaining, signalling, and\nresponse synchronization.  DFC is also responsible for\nmaintaining the mode between two LUs as agreed at session\nset-up time.  The three possible modes are:\n\n1      Half duplex flip-flop, in which the LUs take turns at\n      sending data (or in SNA terms being the requestor).\n\n2      Half duplex contention, in which either LU can begin\n      sending by bidding for permission.\n\n3      Duplex, in which data can flow in either direction\n      simultaneously.\n\nDFC is supported by LU6.2 services and so removes the\nnecessity for application programs to be concerned with\nchaining and bracketing protocols as was necessary with pre-\nLU6.2 LU-LU sessions.  LU6.2 DFC also handles request and\nresponse mode and protocol, which again was the\nresponsibility of pre-LU6.2 applications.  Although the\nintricacies of data flow control may have been absorbed into\nLU6.2, the rigid requirements and constraints imposed by the\nApplication Program Interface (API) must be observed by\napplication programs.\n\nLU6.2 applications communicate via a session which is\nestablished and maintained by the VTAM LU6.2 support\nroutines.  This contrasts with pre-LU6.2 sessions which have to\nbe maintained by the application programs themselves.  LU6.2\nrefers to the dialogue between two transactions running under\ntwo applications as a conversation.  This is analogous in many\nrespects to pre-LU6.2 LU-LU sessions except the\ncommunications-id or CID now becomes the conversation-id or\nCONVID.  As with pre-LU6.2 sessions which required the\nARG parameter on VTAM macros to point to the\ncommunications-id, the APPCCMD macro requires the\nCONVID parameter to point to the conversation-id.  Session\nestablishment is very similar except that instead of a LOGON\nexit the ATTN exit is used.  Aging VTAM programmers will\nrecognize this exit as the now redundant attention exit.  The\nCONVID is extracted from a read-only RPL, the address of\nwhich is passed in word 5 of a 6-word parameter list whose\naddress is contained in General Purpose Register 1 on entry to\nthe ATTN exit.  It is unfortunate that what is claimed to be an\napplication-level protocol still requires such nitty gritty VTAM\nexit coding but fortunately this is the only mandatory one.  All\nother required exits are simulated by VTAM once the\napplication program has issued the SETLOGON macro.\nOptional additional exits include the two exits which are\napplicable to all SNA LU-LU sessions: LERAD for notification\nof RPL-based logic errors and RELREQ, which in the case of\nLU6.2 is for the notification that another application wants to\nestablish a conversation (session) with it but cannot because of\nsession limits - in other words the maximum number of\nconversations the application can support has been reached.\n\nOnce a conversation has been established between two LU6.2\napplications, they will obviously need to exchange data.  Data\nexchange uses a half duplex flip-flop protocol which means\nthat only one application can send data while the other must\nreceive.  At all times during the exchange, one LU will be the\nsender and the other the receiver.  These designated states must\nbe rigidly adhered to otherwise the conversation will fail with a\nstate error.  If the receiver application wishes to send, it can\ncoat-tail a REQUEST_TO_SEND onto the data it is sending,\nbut it must wait for the sending application to change state to\nreceiving before attempting to send data.  This protocol is\nvaguely similar to the BID and response of pre-LU6.2 session\nprotocols but is far more rigid and unforgiving.  The response\nto the REQUEST_TO_SEND (BID) may arrive after many\nother events.  Essentially, data exchange is governed by the\nconcept of Finite State Machines.  At any instant in time the\nconversation between the two applications will be one of a\nnumber of defined states.  Each finite state dictates what the\napplication can and cannot do with respect to the conversation\nand also defines which other states it can be moved to, ie what\nstate transitions are possible and under what conditions.\nSounds complex but the two finite state conditions of concern\nto us are as follows:\n\n1      An application must be in send state to send data\n\n2      An application must be in receive state to receive data.\n\nMany transitions are possible from both of these states but the\ntransitions of interest concern the reversal of roles and in\nparticular how the application becomes the sender from the\nreceiver state.  From the outset, the design of an LU6.2\napplication program must cater for state transitions arising\neither because they are necessary in the transaction logic or\nbecause they are forced by the partner application or an error\nsituation.\n\n\nSEND STATE\n\nAn application is initially in the send state if it is the initiator of\na conversation.  The send state is the most powerful of all\nstates since it is possible to issue most types of APPCCMD\nrequests.  Data in the form of logical records is sent by coding\nthe CONTROL=SEND parameter of the APPCCMD macro.\nFor each active (allocated) conversation, VTAM allocates a\nsend buffer into which the data is placed following a\nCONTROL=SEND,QUALIFY=DATA request.  The size of\nthe send buffer is determined by the maximum RU size\nspecified in the session parameters.  Though the macro\ncompletes successfully, VTAM does not actually send the data\nuntil the send buffer is full.  However there are various ways\nVTAM can be forced to send the data, the most common being\nthe use of the QUALIFY=FLUSH parameter of\nCONTROL=SEND.  This is illustrated by the following code:\n\n*\n*         SEND_DATA      RESOURCE(LU62CID)\n*                        DATA(DATABUFF)\n*                        LENGTH(DATALEN)\n*\n          LH      R2,DATALEN           Record length = Logical\n          APPCCMD CONTROL=SEND,        Length\n                  QUALIFY=DATA,\n                  CONVID=LU62CID,\n                  RPL=LU62RPL,\n                  ACB=LU62ACB,\n                  AREA=DATABUFF,\n                  RECLEN=(2),\n                  OPTCD=SYN\n          LTR     R15,R15\n          BNZ     BADSEND              Send accepted by VTAM ?\n                                       Skip Flush if not\n*\n*         FLUSH          RESOURCE(LU62CID)\n*\n          APPCCMD CONTROL=SEND,\n                 QUALIFY=FLUSH,\n                 CONVID=LU62CID,\n                 RPL=LU62RPL,\n                 ACB=LU62ACB,\n                 OPTCD=SYN\n*\nDATABUFF  DS     0F\nDATALEN   DC     H'102'\nDATA      DC     CL100' '\n\nAlternatively, the VTAM send buffer is flushed automatically\nwhen either a DEALLOCATE or PREPARE_TO_RECEIVE is\nissued while in the send state.  This is because before VTAM\ncan allow the state transition locally and post the indication of\nthe change of state request to the partner application it must\nfirst send any outstanding data.  State changes can not occur\nuntil all outstanding data exchange has been completed.\n\n\nRECEIVE STATE\n\nAn application is initially in the receive state if it is the target\nof an ALLOCATE request to initiate a conversation.  Data (in\nthe form of logical records) is received by coding the\nCONTROL=RECEIVE parameter of the APPCCMD macro.\nHowever it is not quite that simple.  It is not only data that can\nsatisfy the macro request.  Protocol, synchronization, and state\nchange requests can satisfy the macro call at the same time.\nThe RPL extension block contains a flag which indicates what\nhas actually been received.  This is the implementation of the\nSNA LU6.2 WHAT_RECEIVED indicator.  This indicator\nmust be examined following a successful\nRECEIVE_AND_WAIT to determine what action is possible\nand in some cases necessary.  Successful completion of a\nCONTROL=RECEIVE macro could actually take the\ntransaction out of the receive state.  This is illustrated by the\nfollowing code:\n\n*\n*         RECEIVE_AND_WAIT RESOURCE(LU62CID)\n*                          FILL(LL)\n*\n          APPCCMD CONTROL=RECEIVE,\n                  RPL=LU62RPL,\n                  ACB=LU62ACB,\n                  CONVID=LU62CID,\n                  AREA=DATABUFF,\n                  AAREA=LU62RPLX,\n                  AREALEN=DATALEN,\n                  FILL=LL,                note 1\n                  OPTCD=SYN,\n                  QUALIFY=SPEC\n          LTR     R15,R15                 Good request completion ?\n          BNZ     BADRCV\n*\n          LA      R6,LU62RPLX\n          USING   ISTRPL6X,R6             Address RPL ...\n          MVC     SAVERCV1,RPL6RCV1       ...  extension block\n          TM      SAVERCV1,RPL6WDAC       Save what-received field\n          BAL     R14,PROCESS\n          TM      SAVERCV1,RPL6WSND       Data complete ?\n          BAL     R14,RCVSEND             Process\n          TM      SAVERCV1,RPL6WCFM       Permission to Send ?\n          BAL     R14,RCVCNFRM            Process\n          TM      SAVERCV1,RPL6WDAL       Confirm request ?\n          BAL     R14,RCVDEALL            Process\n                                          Deallocate request ?\n                                          note 2\n*\nSAVERCV1  DS      X                       note 3\n*\n*         CONFIRM         RESOURCE(LU62CID)\n*\nRCVCNFRM  DS      0H\n          ST      R14,SAVER14             Save main-line return addr\n          APPCCMD CONTROL=SEND,\n                  QUALIFY=CONFRMD,\n                  RPL=LU62RPL,\n                  ACB=LU62ACB,\n                  CONVID=LU62CID,\n                  OPTCD=SYN\n          LTR     R15,R15\n          BNZ     ERROR\n          L       R14,SAVER14\n          BR      R14\nSAVER14   DS      A\n\nNotes\n\n1      The QUALIFY=SPEC parameter has been coded on the\n      RECEIVE_AND_WAIT macro.  This means that the\n      receive will only be satisfied for the conversation specified\n      by the CONVID parameter.  Control of multiple sessions\n      and the use of QUALIFY=ANY will be the subject of a\n      future article.\n\n2      The technique of branching to sub-routines (as\n      recommended by IBM) enables all indicators to be checked\n      by dropping through the logic.\n\n3      The original WHAT_RETURNED field must be saved\n      since the RPL and RPL extension block may be re-used by\n      subsequent APPCCMD macros before all the indicators\n      have been checked.\n\nWHAT_RECEIVED indicator\n\nKey indicators relating to data flow to be monitored in the\nWHAT_RECEIVED field (RPL6RCV1) include :\n\nRPL6RCV1=RPL6WDAC\n\nDATA_COMPLETE means that either a complete logical\nrecord has been received or the remainder of the logical record\npartially received.\n\nRPL6RCV1=RPL6WDAI\n\nDATA_INCOMPLETE means that less than a complete logical\nrecord has been received.  Further receives must be issued until\nthe DATA_COMPLETE indicator is set.  This condition can be\navoided by ensuring that the receiving buffer (specified by the\nAREA and AREALEN parameters) is large enough to contain a\ncomplete logical record.\n\nRPL6RCV1=RPL6WSND\n\nSEND means that the partner application has entered the\nreceive state and that this application is now in the SEND or\nPENDING_SEND state.\n\nRPL6RCV1=RPL6WCFM\n\nCONFIRM means that the partner application requires\nconfirmation that all is well (or not as the case may be!).\n\nRPL6RCV1=RPL6WDAL\n\nDEALLOCATE means that the partner application has\ndeallocated the confirmation.\n\nThese indicators are not mutually exclusive.  For example, the\nDEALLOCATE and CONFIRM indicators may both be set,\nimplying that the partner application wishes to deallocate the\nconversation but is open to negotiation.  The terms and\nconditions of the negotiation are at the application designer's\ndiscretion.  When trying to decide which of the\nWHAT_RECEIVED indicators to cater for, remember that they\nare not set randomly by VTAM, they are set as the result of\npartner application requests.  Design is therefore greatly\nsimplified if it is known exactly what conditions and requests\npartner application(s) could generate.\n\n\nCHANGING STATE\n\nApplications can alternate between send and receive states (that\nis flip-flop) but certain rules must be observed.  If an\napplication in the send state wants to become the receiver it can\nrequest transition to the receive state at any time by issuing an\nAPPCCMD macro with CONTROL=PREPRCV.  This will\nsend notification in the WHAT_RECEIVED indicator in the\nRPL extension block (RPL6RCV1=RPL6WSND) to the\napplication currently in the receive state which is then placed in\nthe send state.\n\n*\n*         PREPARE_TO_RECEIVE RESOURCE(LU62CID)\n*                            TYPE(FLUSH\n*\n          APPCCMD CONTROL=PREPRCV,\n                  QUALIFY=FLUSH,\n                  RPL=LU62RPL,\n                  ACB=LU62ACB,\n                  OPTCD=SYN,\n                  CONVID=LU62CID\n\nExactly when the partner application changes to the send state\ndepends upon the current activity.  If it is dormant (ie it has a\nreceive outstanding and all data flow has finished) then the\napplication can choose either to enter the send state\nimmediately or to enter the PENDING_SEND state.  This\noption is exercised by the CD=IMMED and CD=DEFER\nparameters of the APPCCMD CONTROL=RECEIVE macro.\nThe default is immediate.  Yes, CD means Change Direction\nand reflects the fact that the LU6.2 application can directly\ninfluence the underlying DFC.  The PENDING_SEND state\nenables the partner transaction to continue to behave as a\nreceiver.\n\nIf an application in the receive state wants to become the\nsender, it can request transition to the send state at any time by\nissuing an APPCCMD\nCONTROL=SEND,QUALIFY=RQSEND macro.  This\ngenerates a signal request unit to the application in the send\nstate and the RPL6RTUN=RPL6RSIG indicator is set in the\nRPL extension block upon completion of the next APPCCMD\nrequest macro.\n\n*\n*         REQUEST_TO_SEND RESOURCE(LU62CID)\n*\n          APPCCMD CONTROL=SEND,\n                  QUALIFY=RQSEND,\n                  RPL=LU62RPL,\n                  ACB=LU62ACB,\n                  CONVID=LU62CID\n                  OPTCD=SYN\n\nThe application in the send state should check the RPL6RTUN\nindicator after every APPCCMD macro to determine whether\nthe receiving application wishes to send.  This is illustrated by\nthe following code:\n\n          APPCCMD CONTROL=SEND,\n                  AAREA=LU62RPLX,......\n*\n          LTR     R15,R15                  Good request completion ?\n          BNZ     BADRCV\n          LA      R6,LU62RPLX\n          USING   ISTRPL6X,R6              Address RPL ...\n          TM      RPL6RTUN,RPL6RSIG        ...  extension block\n          BNO     CONTINUE                 Signal received ?\n                                           Proceed with process\n          APPCCMD CONTROL=PREPRCV,\n                  QUALIFY=CONFIRM,\n                  RPL=LU62RPL,\n                  ACB=LU62ACB,\n                  AAREA=LU62RPLX,\n                  OPTCD=SYN,\n                  CONVID=LU62CID\n\nChecking the RPL extension block WHAT_RECEIVED\nindicators is vital to maintaining the integrity of the finite states\nof the applications.  If the appropriate WHAT_RECEIVED\nindicator (RPL6RCV1) is set, the receiving application must be\nprepared to issue an APPCCMD\nCONTROL=SEND,QUALIFY=CONFRMD (or possibly\nQUALIFY=ERROR) if a CONFIRM request is received and\nmust cease issuing RECEIVE_AND_WAIT requests if SEND\nis received.  If the returned indicator is set (RPL6RTUN) the\nsending application must be prepared to issue an APPCCMD\nCONTROL=PREPRCV macro and cease sending.  If these\nrules are not observed then a state error will be raised and the\nconversation will be in trouble.\n\n\nDATA BUFFERING\n\nLU6.2 architecture requires that data exchange between\napplications uses logical records, which simply means that data\nmust be prefixed by a half word length count which includes\ntwo bytes for the length field itself.  The receiving application\ncan nominate to receive individual logical records by coding\nFILL=LL on the APPCCMD CONTROL=RECEIVE macro, or\nsufficient data to fill a buffer supplied by the application by\ncoding FILL=BUFF.  In the latter case the data placed in the\nbuffer may be a complete logical record, part of a logical\nrecord, or many logical records, and the application must\ndecode the buffer.  For ease of coding, it is recommended that\nFILL=LL is used - this is the default.  To simplify the coding\nlogic further, the sending application should issue an\nAPPCCMD CONTROL=SEND macro for each logical record\nand the receiving application should allocate a buffer large\nenough to contain a complete logical record.  It is possible\neither for logical records to span the VTAM send buffer or for\nmany logical records to fit into the buffer.  Both of these\nsituations require complex code to handle them.  The RECLEN\nparameter on the APPCCMD CONTROL=SEND macro has no\nfixed relationship to a logical record, it simply tells VTAM the\nlength of data to be placed in the VTAM send buffer with a\nparticular macro call.  A further design complication is the fact\nthat, if a record spans the VTAM send buffer, no other\nAPPCCMD macros can be issued until the entire logical record\nhas been passed to VTAM using\nCONTROL=SEND,QUALIFY=DATA APPCCMD macros.\n\nBy keeping the data exchange as simple as possible, the\nnumber of APPCCMD macros can be reduced with a\nconsiderable saving in overheads (early experience shows the\nVTAM API path length to be very long).  For example:\n\n          APPCCMD CONTROL=SEND,QUALIFY=DATA\n          APPCCMD CONTROL=SEND,QUALIFY=FLUSH\n\ncan be combined into a single macro, thus:\n\n          APPCCMD CONTROL=SEND,QUALIFY=DATAFLU\n\nAlso:\n\n          APPCCMD CONTROL=SEND,QUALIFY=DATA\n          APPCCMD CONTROL=SEND,QUALIFY=CONFIRM\n\ncan be combined into a single macro like this:\n\n          APPCCMD CONTROL=SEND,QUALIFY=DATACON\n\nHowever, this does mean that the receiving application must be\nintelligent enough to detect the arrival of both the DATA and\nCONFIRM in response to the same APPCCMD\nCONTROL=RECEIVE macro.\n\nCombination of function is possible to a considerable degree,\nwhich enables simple transactions to be developed.  For\nexample, a transaction that is required simply to allocate a\nconversation, send a single item of data, and deallocate the\nconversation could achieve this with two macros like this:\n\n          APPCCMD CONTROL=ALLOC,QUALIFY=ALLOCD\n          APPCCMD CONTROL=DEALLOC,QUALIFY=DATAFLU\n\n\nGDS STRUCTURES\n\nSo far, LU6.2 application conversations have been referred to\nas data exchanges with no thought as to what the shape and\nform of the data might be.  LU6.2 applications on different\nprocessors need to be able to understand the command and data\nthat is being exchanged and so must all agree on a structure for\nthe messages.  APPC implements a message and data structure\ntermed General Data Stream (GDS).   Each structured field in a\nGDS has a 4-byte header followed by the data:\n\no      Length (LL)\no      Identifier (ID)\no      Data of length LL-4 bytes.\n\nThe 2-byte LL field specifies the total length of the structure\nincluding the 4-byte LLID header.  The high-order bit (bit 0) is\nused as a continuation indicator.  Therefore, up to 32763 bytes\nof data can be contained in a GDS structure but, by using the\ncontinuation indicator (bit 0 set to 1), the total volume of data\nin the stream can be endless.  The end of the stream is\nsignalled by an LL field for which bit 0 is zero.\n\nID is a two-byte field that follows the LL field and identifies\nthe content of the data or information field.  The GDS ID is\napplication dependent and so the convention and meaning is\nleft to the application designer.  By way of illustration consider\nthe following:\nDS ID      Meaning\n0001      Start transaction\n000      Terminate transaction (normal)\n0100      Transaction name\n0200      Number of transaction parameters\n0201      Transaction parameter 1\n02nn      Transaction parameter nn\n0300      Number of returned data items\n0301      Returned data item 1\n03nn      Returned data item nn\n0900      Cancel transaction (backout)\n0999      Cancel transaction (abort).\n\nWith this convention, an exchange between two applications\nthat initiated an inquiry of the stock level of item number\n01017896 would look something like:\n\nFirst message from conversation initiator:\n\n         X'0004',X'0001'              Start transaction\n         X'0009',X'0100',C'STOCK'     Transaction name\n         X'0005',X'0200',X'02'        Number of parameters\n         X'0009',X'0201',C'LEVEL'     Parameter 1, transaction activity\n         X'000C',X'0202',C'01017896'  Parameter 2, stock number\n         X'0004',X'0002'              Terminate transaction\n\nMessage returned from conversation partner:\n\n         X'0005',X'0300',X'01'        Number of returned data items\n         X'000A',X'0301',C'   102'    Data item 1 (stock level)\n\nAs can be seen, this is a non-ambiguous and reasonably\ncompact structure.  Programming is fairly straightforward since\nthe GDS IDs can be set in a matrix.  Upon receipt, the matrix\ncan be used as an index for verification and function\ndetermination.  Once defined, the matrix can be made available\nto all participating applications and could even be updated\ndynamically by defining a matrix update GDS ID.\n\nUse of GDS has been widely implemented by IBM in such\napplications as SNA/Distribution Services, Document\nInterchange Architecture, Graphical Data Display Manager,\nIntelligent Print Data Stream (see Using printers in SNA, SNA\nUpdate Issue 1), Facsimile Architecture, etc.  It is\nrecommended that GDS structures are used in all LU6.2\napplications.  They remove ambiguity from data streams by\nclearly defining the rules for data exchange, and simplify\ntroubleshooting and debugging by making trace data easy to\ninterpret.\n\nAvoid the use of GDS IDs of the format X'12..' as these are\nused by APPC and APPN and so the potential for problems and\nconfusion is obvious.\n\nBy way of further illustration of how GDS is implemented, the\nuse of Program Initialisation Parameters (PIPs) during a\nconversation ALLOCATE will be discussed.  PIP data is an\nexample of a GDS structure which defines a data format known\nand understood by both the initiator of the conversation and the\nattached partner.\n\n\nPIP DATA\n\nThe application starting a conversation must format a Function\nManagement Header Type 5 (FMH5) and supply the address on\nthe APPCCMD CONTROL=ALLOC macro.  As a minimum,\nthe FMH5 must specify the name of the transaction to be\nexecuted at the partner application.  Optionally, transaction\ninitialization parameters can be supplied in the form of the PIP\ndata field of the FMH5.  At the partner application, the FMH5\nis made available in response to an APPCCMD\nCONTROL=RCVFMH5 macro.  Thus the transaction name\nand initialization parameters are available together.  PIP data\ncan be complex as the FMH5 supports a GDS structure with\nsubfields.  The general layout is as follows :\n\nByte       Content\n0-1      Length of PIP data including these 2 bytes\n2-3      X'12F5' the GDS ID for PIP data\n4-nn      PIP subfields.\n\nPIP subfields have the same GDS structure for each subfield -\nthe GDS ID is X'12E2'.  Use of PIP data is illustrated by the\nfollowing code:\n\n          LA      R5,LU62FMH5           Address Skeleton ...\n          USING   ISTFM5,R5             ...  FMH5\n          MVC     FM5TPNAM,LU62TPNM     Transaction name and...\n          MVI     FM5LNTPN,X'05'        ...  length in FMH5 see note\n          MVI     FM5LENTH,X'0F'\n          OI      FM5FLAG2,FM5PIPPR     Length of FMH5 header\n*                                       Set PIP=YES indicator\n          LA      R6,18(,R5)\n          USING   FM5PIPFM,R6           Address PIP data ...\n          MVC     FM5PIPGD,=X'12F5'     ...  field in FMH5\n          MVC     FM5PIPLN,=X'0019'     Set PIP data GDS ID\n*                                       Set PIP data GDS length\n          LA      R6,4(,R6)\n          USING   FM5PIPSM,R6           Address PIP subfields ...\n          MVC     FM5PIPSG,=X'12E2'     ...  in FMH5\n          MVC     FM5PIPSL,=X'0009'     Set PIP subfield GDS ID\n          MVC     FM5PIPSD,=C'LEVEL'    Set PIP subfield GDS length\n*\n          LA      R6,9(,R6)             Move data into PIP subfield\n          MVC     FM5PIPSG,=X'12E2'\n          MVC     FM5PIPSL,=X'000C'\n          MVC     FM5PIPSD,=C'01017896' Address next PIP subfield\n                                        Set PIP subfield GDS ID\n                                        Move data into PIP subfield\n*\n*         ALLOCATE       LU_NAME(PARTNER)\n*                        TPN(LU62TPNM)\n*                        TYPE(BASIC_CONVERSATION)\n*                        PIP(YES)\n          APPCCMD CONTROL=ALLOC,\n                  QUALIFY=ALLOCD,\n                  RPL=LU62RPL,\n                  ACB=LU62ACB,\n                  LUNAME=LU62PLU,\n                  LOGMODE=LU62MODE,\n                  AREA=LU62FMH5,\n                  RECLEN=63,\n                  OPTCD=SYN,\n                  AAREA=LU62RPLX\n\nLU62RPL   RPL     AM=VTAM\nLU62RPLX  ISTRPL6\nLU62ACB   ACB     AM=VTAM,MACRF=LOGON,APPLID=LU62NAME\nLU62NAME  DC      XL1'08',C'LU62APPL'\nLU62PLU   DC      XL1'07',C'PARTNER'\nLU62CID   DS      XL4\nLU62FMH5  DS      XL255\nLU62TPNM  DC      C'STOCK'\n          ISTFM5\n\nNote\n\nThis move (MVC) has an implied 3 bytes of hexadecimal zeros\nappended to the transaction name which set the access security,\nlogical unit of work, and conversation correlation subfields in\nthe FMH5 to zero.  Use of these fields will be the subject of a\nfuture article.\n\nThe partner transaction must use an identical mapping to\nextract the PIP data from the FMH5: the use of supplied\nmapping DSECTs is therefore essential.  Note that it is\nessential to ensure that the DSECTs are at the same SNA\nversion and release level.  An obvious point but remember that\nAPPC is supposed to link a number of diverse host systems\nincluding MVS, VM, and VSE.  Extraction of PIP data by the\nreceiving transaction is illustrated by the following code:\n\n          APPCCMD CONTROL=RCVFMH5,     Receive the ...\n                  RPL=LU62RPL,         ... FMH5 sent ...\n                  ACB=LU62ACB,         ...  by the ...\n                  AREA=LU62FMH5,       ...  conversation ...\n                  AAREA=LU62RPLX,      ...  initiator\n                  OPTCD=SYN\n*\n          LA      R5,LU62FMH5          Address ...\n          USING   ISTFMH5,R5           ...  FMH5\n          TM      FM5FLAG2,FM5PIPPR    Any PIP data ?\n          BNO     NOPIP                Skip receive\n*\n          APPCCMD CONTROL=RECEIVE,\n                  RPL=LU62RPL,\n                  ACB=LU62ACB,\n                  CONVID=LU62CID,\n                  AREA=PIPDATA,\n                  AREALEN=PIPDLEN,\n                  FILL=LL,\n                  QUALIFY=SPEC,\n                  OPTCD=SYN\n*\n          LA      R6,PIPDATA           Address PIP data ...\n          USING   FM5PIPFM,R6          ...  in logical record\n          CLC     FM5PIPGD,=X'12F5'    Verify valid PIP GDS id\n          BNE     BADPIP               Error if not\n          LH      R2,FM5PIPLN          PIP data length in R2\n          LA      R6,4(,R6)            Address PIP subfields ...\n          USING   FM5PIPSM,R6          ...  in logical record\n          SH      R2,=H'4'             Decrement PIP data length\n          LA      R4,PIPPARM1          Address first PIP parm\nPIPLOOP   DS      0H\n          CLC     FM5PIPSG,=X'12E2'    Valid PIP subfield GDS id ?\n          BNE     BADPIP\n          SR      R3,R3                Error if not\n          ICM     R3,3,FM5PIPSL\n          SH      R3,=H'3'             Length of PIP subfield\n          EX      R3,MOVEDATA          Prepare for execute move\n          LA      R4,20(,R4)           Move data to parm list\n          CLI     0(R4),X'FF'          Prepare to extract next parm\n          BE      TOOMANY              Too many PIP parms ?\n          SR      R2,R3\n          LTR     R2,R2                Exit loop\n          BNZ     PIPLOOP              Decrement PIP data length\n                                       End of PIP data subfields ?\n                                       Continue if not\n*\nMOVEDATA  MVC     0(0,R4),4(R6)\n*\nPIPDLEN   DC      H'48'\nPIPDATA   DC      CL44' '\nPIPPARM1  DC      CL20' '\nPIPPARM2  DC      CL20' '\n   .\n   .\nPIPPARMn  DC      CL20' '\n          DC      X'FF'\n\nNote that although the application initiating the conversation\npasses the FMH5 and PIP data together to the APPCCMD\nCONTROL=ALLOC macro, at the partner application they are\nreceived separately.  The FMH5 is made available following a\nCONTROL=FMH5RCV macro while a separate\nCONTROL=RECEIVE must be issued for the PIP data.  In\neffect the PIP data becomes the first logical record.  Take heed\nof this when designing a partner application; if in doubt always\ncheck for PIP data.\n\nThis article has concentrated on the control of data exchange\nbetween two applications.  However, as the above sample PIP\ndata code shows, such an exchange could be simplified by the\nuse of PIP data since it effectively removes the necessity for\nthe initiating application to send any data at all.  The FMH5\nshown requests execution of the transaction 'STOCK', function\n'LEVEL', for stock number '01017896'.  Such a simple\ntransaction is typical of the vast majority of commercial on-line\napplications.  The inquiry could as easily have been for a bank\naccount balance or the status of work in progress on a\nproduction line.\n\n\nDESIGN FOOTNOTE\n\nData exchange is the most likely area for problems with LU6.2\napplications.  There are many possibilities for errors and it is\nimportant to be able to debug problems easily.  The main point\nalways to bear in mind is that the application uses LU6.2\nprotocol.  To reinforce this point it may be helpful to refer to\nthe Transaction Programmer's Reference Manual For LU Type\n6.2 and add to the code the conversation verbs in the form of\ncomments.  By way of illustration this has been done in the\npreceding code examples.\n\n\nSUMMARY\n\nDesign of data flow for LU6.2 applications must take into\naccount the interaction with DFC implemented in the VTAM\nLU6.2 support logic.  This means being aware of the finite\nstates that are supported and the rules governing Finite State\nMachines and in particular state transitions.  Always check the\nWHAT_RECEIVED and RETURNED indicators in the RPL\nextension block to monitor state changes.  Use of GDS\nstructures to exchange data is strongly recommended to\nstandardize data formats across applications and assist in the\ndebugging of data traces.  The exchange of data by individual\nlogical records rather than buffers is recommended.  In this\nway, the logical sequence sends and receives can be matched.\nBe careful in the selection of the key parameters RECLEN and\nAREALEN to minimize the possibility of logical records\nspanning buffers.  These precautions should simplify coding\nand error recovery as will be explained in the next article, Error\nRecovery in LU6.2.\n\nBrian Alford\nSystems Consultant\nAranda (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N003A04": {"ttr": 3590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\xab\\x00\\xab\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 171, "newlines": 171, "modlines": 0, "user": "SNAUPDT"}, "text": "NetView CLIST to establish a TAF session\n\nThe CLIST presented in this article is an example of\nautomatically establishing a session with a CICS region using\nthe NetView Terminal Access Facility (TAF).  This particular\nCLIST allows a CICS command to be issued which enquires on\nthe status of a terminal in the network.  The CLIST can be\nexpanded to implement certain automated tasks that will\nperform tasks normally carried out by the human operator.  It is\na model CLIST that has been used in our installation to enquire\non the status of terminals, transactions, programs, and datasets.\n\nDetails on how to define the TAF environment are contained in\nthe NetView Installation and Administration Guide.  When we\nfirst attempted to establish TAF sessions we found it difficult to\nfind examples of CLISTs that could be used as a guide.\n\n&CONTROL ERR\n*        *************************************************************\n*        * PROGRAM: MODEL TAF SESSION.                               *\n*        * PURPOSE: TO PROVIDE AN EXAMPLE OF HOW TO ESTABLISH A      *\n*        *          TERMINAL ACCESS FACILITY SESSION WITH AN ONLINE  *\n*        *          CICS REGION.                                     *\n*        *************************************************************\n*        * -DISPLAY SECTION IS USED TO DETERMINE IF THE CICS REGION  *\n*        *  IN QUESTION IS ACTIVE. THIS IS DONE BY ISSUING THE MVS   *\n*        *  DISPLAY COMMAND AND INTERCEPTING THE MESSAGE THAT IS     *\n*        *  RETURNED.                                                *\n*        *************************************************************\n-DISPLAY\n&WAIT SUPPRESS CONTWAIT\n&WAIT 'MVS D A,CICS'    +\n      IEF105I=-CHKLINE2 +\n      *25=-TASKTIME     +\n      *ERROR=-TASKFAIL\n-CHKLINE2\nGETMLINE MSGTEXT 4\nPARSEL2R MSGTEXT ONE TWO REST\n&IF .&ONE = .CICS &THEN &GOTO -CHKMORE2\n&WAIT CONTINUE\n-CHKMORE2\n&IF .&TWO \u00ac= .NOT &THEN &GOTO -YESCICS\n*        *************************************************************\n*        * -NOCICS IS EXECUTED IF CICS IS NOT ACTIVE.                *\n*        *************************************************************\n-NOCICS\n&WRITE ***** CICS IS INACTIVE CLIST TERMINATED *****\n&EXIT\n*        *************************************************************\n*        * -YESCICS IS EXECUTED TO ESTABLISH THE SESSION WITH CICS   *\n*        *  THROUGH A TAF TERMINAL NAMED TAF01001. THE SESSION IS    *\n*        *  NAMED TAF01.                                             *\n*        *  DEPENDING ON THE MESSAGE RECEIVED ONE OF THE FOLLOWING   *\n*        *  SECTIONS WILL BE EXECUTED.                               *\n*        *************************************************************\n-YESCICS\nGO\n&WAIT SUPPRESS CONTWAIT\n&WAIT 'BGNSESS OPCTL,APPLID=CICS,SRCLU=TAF01001,SESSID=TAF01' +\n      DSI463I=-LOGON +\n      DSI481I=-LOGOFF +\n      DSI499I=-NOCICS1 +\n      *25=-TASKTIME +\n      *ERROR=-TASKFAIL\n&EXIT\n*        *************************************************************\n*        * -LOGON IS USED TO SEND A STANDARD CICS CSSN LOGON COMMAND *\n*        *  FOR USERID CIC01.                                        *\n*        *  DEPENDING ON THE MESSAGE RETURNED LOGON MAY CONTINUE OR  *\n*        *  A FAILURE ROUTINE WILL BE ENTERED.                       *\n*        *************************************************************\n-LOGON\nGO\n&WAIT SUPPRESS CONTWAIT\n&WAIT 'SENDSESS TAF01,CSSN LOGON,NAME=CIC01' +\n      DFH3518I=-PASSWORD +\n      *25=-TASKTIME +\n      *ERROR=-TASKFAIL\n*        *************************************************************\n*        * -LOGOFF IS USED TO ISSUE A STANDARD LOGOFF COMMAND TO     *\n*        *  CICS.                                                    *\n*        *  DEPENDING ON THE MESSAGE RETURNED LOGOFF MAY CONTINUE OR *\n*        *  A FAILURE ROUTINE WILL BE ENTERED.                       *\n*        *************************************************************\n-LOGOFF\nGO\n&WAIT SUPPRESS CONTWAIT\n&WAIT 'SENDSESS TAF01,CSSF LOGOFF' +\n      DSI496I=-SESSEND +\n      *25=-TASKTIME +\n      *ERROR=-TASKFAIL\n*        *************************************************************\n*        * -PASSWORD SENDS A PASSWORD COMMAND TO CICS ISSUING THE    *\n*        *  PASSWORD FOR USER CIC01, WHICH HAS A VALUE OF MASTER.    *\n*        *  DEPENDING ON THE MESSAGE RETURNED PROCESSING MAY         *\n*        *  CONTINUE OR A FAILURE ROUTINE WILL BE ENTERED.           *\n*        *  WE TRAP TSS MESSAGES AFTER SIGNON BECAUSE WE HAVE CICS   *\n*        *  LINKED TO THE TOP SECRET SECURITY PRODUCT. THESE WOULD   *\n*        *  HAVE TO BE REMOVED OR CHANGED IF YOU UTILIZE A DIFFERENT *\n*        *  SECURITY PRODUCT.                                        *\n*        *************************************************************\n-PASSWORD\nGO\n&WAIT SUPPRESS CONTWAIT\n&WAIT 'SENDSESS TAF01,MASTER' +\n      TSS701I=-COMPLETE +\n      TSS702I=-COMPLETE +\n      TSS703W=-COMPLETE +\n      TSS956E=-EXPIRED +\n      TSS955E=-INCORRECT +\n      DFH3504I=-COMPLETE +\n      *25=-TASKTIME +\n      *ERROR=-TASKFAIL\n*        *************************************************************\n*        * -COMPLETE SECTION IS EXECUTED WHEN SIGNON IS COMPLETE.    *\n*        *  THE CLIST ISSUES AN INQUIRY AGAINST A CICS TERMINAL.     *\n*        *************************************************************\n-COMPLETE\nGO\n&WAIT SUPPRESS CONTWAIT\n&WAIT 'SENDSESS TAF01,CEMT INQ TERM01' +\n      *25=-TASKTIME +\n      *ERROR=-TASKFAIL\n     &EXIT\n*        *************************************************************\n*        * -EXPIRED IS AN ERROR SECTION.                             *\n*        *************************************************************\n-EXPIRED\nGO\n&EXIT\n*        *************************************************************\n*        * -INCORRECT IS AN ERROR SECTION.                           *\n*        *************************************************************\n-INCORRECT\nGO\n&WAIT SUPPRESS CONTWAIT\n&WAIT 'SENDSESS TAF01,CSSF LOGOFF' +\n      DSI496I=-PASSEND +\n      *25=-TASKTIME +\n      *ERROR=-TASKFAIL\n*        *************************************************************\n*        * -PASSEND IS AN ERROR SECTION.                             *\n*        *************************************************************\n-PASSEND\nGO\n&EXIT\n*        *************************************************************\n*        * -SESSEND IS AN ERROR SECTION.                             *\n*        *************************************************************\n-SESSEND\n&WRITE NETVIEW WAS ALREADY LOGGED ONTO CICS,\n&WRITE A NEW SESSION WILL BE INITIATED\n&GOTO -YESCICS\n&EXIT\n*        *************************************************************\n*        * -TASKFAIL IS AN ERROR SECTION.                            *\n*        *************************************************************\n-TASKFAIL\nGO\n&EXIT\n*        *************************************************************\n*        * -TASKTIME IS AN ERROR SECTION.                            *\n*        *************************************************************\n-TASKTIME\nGO\n&EXIT\n\n\nJohn Bradley\nTechnical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N003A05": {"ttr": 3594, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 27, "newlines": 27, "modlines": 0, "user": "SNAUPDT"}, "text": "Correction to the June issue\n\nThere are a couple of minor corrections to the code in the\narticle Getting started with LU6.2, which appeared in the June\n1991 issue of SNA Update.  In both applications the following\nstatement should follow the OPEN LU62ACB:\n\n      SETLOGON RPL=LU62RPL,OPTCD=START\n\nIn addition, in application program 2 the code from the label\nLU62ATTN should read:\n\nLU62ATTN  DS    0H\n\n          Entry protocol\n\n          L     R6,16(,R1)\n          USING ISTRPL6,R6\n          L     R3,=A(LU62CID)\n          MVC   0(4,R3),RPL6CNVD\n          L     R4,=A(WAKECB)\n          POST  (4)\n\n          Exit protocol\n\nWe apologise for any inconvenience this may have caused.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N003A06": {"ttr": 3596, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\xac\\x00\\xac\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 172, "newlines": 172, "modlines": 0, "user": "SNAUPDT"}, "text": "Tightening Net/Master security with CA-ACF2\n\nNet/Master offers the facility to eliminate the need for users to\nenter their passwords when selecting each application under\nMAI.  This is achieved by storing the user's password in a\nNet/Master system variable called &USERPW.  This variable\nis encrypted in storage and decrypted each time an NCL\nprocedure references it.\n\nThis does, however, introduce a potential security risk.  To\neliminate this problem, we have implemented a CA-ACF2\nfacility called log-on inheritance.  Using this facility requires\nchanging the MAI exit, MAIEX02, as shown below.  Once\ninstalled, the Net/Master system parameter USERPW can be\nset to USERPW=NO.  This will stop passwords being stored.\nEach time users sign on to Net/Master they are prompted for a\nuser-id and password.  Once verified with CA-ACF2, the user\nno longer needs to enter his or her password.  When selecting\nan application, Net/Master calls the MAIEX02 exit.  At this\nstage the exit will ask CA-ACF2 for a token password by\nproviding the user-id and terminal name.\n\nThe exit formats a sign-on command for the selected\napplication, using the token in place of the user's password.\nWhen the application calls CA-ACF2 to validate the sign-on,\nCA-ACF2 compares the token against the last token it gave out\nfor that log-on-id.  If it matches, the password is considered\nvalid.  The life of an inheritance password is two minutes or\none call.\n\nThis program has been written to pass USERID/USERPW.\nThere are some applications that do not use log-on data or\nperhaps need a format different to the one shown, eg IMS and\nCICS.  These applications should be considered before\nimplementing this exit.\n\nMAIEX02  TITLE 'NET/MASTER MAI USER EXIT 2'\n***     PROGRAM:        MAIEX02                                     ***\n*       ABSTRACT:       THIS PROGRAM IS CALLED AS AN EXIT TO          *\n*                       SETUP THE CALLERS USERID AND A TOKEN PASSWORD *\n*                       IN THE LOGON USER DATA.                       *\n* MACRO LIBRARIES:                                                    *\n* NM.NMMACLIB                                                         *\n* CAI.ACF2.ACFMAC                                                     *\n* LINK-EDIT CONTROL STATEMENTS FOR THIS PROGRAM:                      *\n* INCLUDE SYSLIB($ACFGCVT)                                            *\n* NAME    MAIEX02(R)                                                  *\n* NOTE: THIS EXIT MUST BE CODED RE-ENTRANTLY, AND LINKED WITH THE     *\n*       'RENT' ATTRIBUTE. IT CAN BE PLACED IN SYS1.LPALIB IF REQUIRED.*\n*        R E G I S T E R    U S A G E.                                *\n*        R1    WORK.                                                  *\n*        R2    RETURN CODE.                                           *\n*        R3    COMMUNICATIONS WORK AREA.                              *\n*        R4    ACF2 CVT                                               *\n*        R5    ADDRESS OF USER DATA.                                  *\n*        R6    COUNTER.                                               *\n*        R8    WORK.                                                  *\n*        R11   BASE REGISTER                                          *\n*        R12   UNUSED                                                 *\n*        R13   SAVE AREA CHAIN.                                       *\n*        R14   WORK, RETURN.                                          *\n***      R15   WORK, ENTRY ADDRESS.                                 ***\nMAIEX02  CSECT\n* NOTE THAT THIS MODULE MUST BE CODED RE-ENTRANTLY.                   *\n         USING MAIEX02,R11              SET BASE ADDRESSABILITY.\n         STM   R14,R12,12(R13)          SAVE ENTRY REGISTERS.\n         LR    R11,R15                  LOAD BASE ADDRESS.\n         L     R3,0(R1)                 GET COMMUNICATION AREA ADDRESS.\n         GETMAIN R,LV=AREALEN           GETMAIN A REGISTER SAVEAREA.\n         USING WORKAREA,R13             SET AREA BASE.\n         ST    R1,8(R13)                CHAIN NEW AREA ADDRESS.\n         XC    0(AREALEN,R1),0(R1)      CLEAR GETMAINED AREA.\n         ST    R13,4(R1)                CHAIN OLD SAVEAREA.\n         LR    R13,R1                   POINT TO NEW SAVE AREA.\n* SET BASE ADDRESS OF COMMUNICATION AREA PASSED IN R1 (PUT INTO R3).  *\n         USING MAE2,R3                  SET BASE REGISTER FOR IT.\n* SET BASE ADDRESS OF ACF2 CVT                                        *\n         ACFGACVT R4,NONE=NOCVT         GET ACF2 CVT\n         USING ACCVT,R4                 ACF2 CVT ADDRESSABILITY\n* DETERMINE TYPE OF CALL.                                             *\n         L     R15,MAE2FUNC             LOAD FUNCTION CODE.\n         B     MAEX0100(R15)            BRANCH ON FUNCTION CODE.\nMAEX0100 DS    0H\n         B     MAEX1000                 0=SYSTEM STARTUP.\n         B     MAEX2000                 4=SYSTEM CLOSEDOWN.\n         B     MAEX3000                 8=MAI SESSION START.\n         B     MAEX4000                 12=MAI SESSION END.\n* SYSTEM STARTUP CALL. WE HAVE NOTHING TO DO HERE.                    *\nMAEX1000 DS    0H\n         SR    R2,R2                    SET ZERO RETURN CODE.\n         B     MAEX9000                 RETURN TO CALLER.\n* SYSTEM CLOSEDOWN CALL. WE HAVE NOTHING TO DO HERE.                  *\nMAEX2000 DS    0H\n         SR    R2,R2                    SET ZERO RETURN CODE.\n         B     MAEX9000                 RETURN TO CALLER.\n* MAI SESSION START CALL. SET MAI NODE NAME TO LUNAME FOR FULL SCREEN *\n* SESSIONS.                                                           *\nMAEX3000 DS    0H\n         SR    R2,R2                    ASSUME ZERO RETURN CODE.\n         TM    MAE2SFLG,MAE2SFS         FULL SCREEN SESSION ?\n         BNO   MAEX9000                 NO-RETURN AND ALLOW THE MAI-OC\n*                                       SESSION.\n*   SET UP ACF INHERIT\n         XC    ACINHRT(ACINLN),ACINHRT  CLEAR OUT ACINHRT STORAGE\n         MVI   ACINFCN,ACINFC0D         SET UP FUNCTION CODE\n         MVI   ACINSFCN,ACIN$ADD        INDICATE GET-INHERITANCE TOKEN\n         MVC   ACINLID,MAE2SUID         SET UP LOGON ID\n         MVC   ACINSRC,MAE2STRM         SET UP SOURCE\n         MVC   ACINRSRC,=CL40' '        BLANK FILL RESOURCE NAME\n         ACFSVC ACINHRT,TYPE=A,CVT=FIND,NONE=NOACF2\n         LTR   R15,R15                  DID IT WORK ?\n         BNZ   ERROR                    NO...GO PROCESS THE ERROR\n*   SETUP LOGON DATA\n         MVC   MAE2SUSR,MAE2SUID        MOVE IN USERID\n         LA    R5,MAE2SUSR              ADDRESS USER DATA\n         LA    R6,8                     MAX LENGTH OF FIELD\nMAEX3002 DS    0H\n         CLI   0(R5),C' '               IS IT A BLANK\n         BE    MAEX3005                 YES, BRANCH\n         LA    R5,1(R5)                 ADD ONE TO REGISTER 5\n         BCT   R6,MAEX3002              SUBTRACT 1 AND BRANCH\nMAEX3005 DS    0H\n         MVI   0(R5),C'/'               PUT A SLASH AFTER THE USERID\n         MVC   1(8,R5),ACINHID          MOVE IN TOKEN FOR PASSWORD\n         LA    R5,8                     SET R5 TO MAXIMUM LENGTH\n         SR    R5,R6                    GET LENGTH OF USERID\n         LA    R5,9(R5)                 ADD SLASH AND TOKEN\n         STH   R5,MAE2SULN              SET LENGTH OF USER DATA\n         B     MAEX9000\nNOACF2   DS    0H\n         LR    R15,8                    ACF2 IS NOT STARTED.\n         MVC   MAE2SERM,=CL78'ACF2 NOT ACTIVE, CONTACT SYSTEMS SUPPORT'\n         B     MAEX9000\nNOCVT    DS    0H\n         LR    R15,12                   ACF2 CVT NOT FOUND.\n         MVC   MAE2SERM,=CL78'UNABLE TO ESTABLISH ACF2 CVT, CONTACT SYSX\n               TEMS SUPPORT'\n         B     MAEX9000\nERROR    DS    0H\n         LA    R15,16                   ACFVALD FAILED.\n         MVC   MAE2SERM,=CL78'ACFINHRT VALIDATION FAILED, CONTACT SYSTEX\n               MS SUPPORT'\n         B     MAEX9000\n* MAI SESSION END CALL. WE HAVE NOTHING TO DO HERE.                   *\nMAEX4000 DS    0H\n         SR    R2,R2                    ZERO RETURN CODE.\n         B     MAEX9000                 RETURN TO CALLER.\n* RETURN TO CALLER.                                                   *\nMAEX9000 DS    0H\n         LR    R1,R13                   LOAD SAVE ADDRESS.\n         L     R13,4(R13)               GET OLD SAVEAREA ADDRESS.\n         FREEMAIN R,LV=AREALEN,A=(1)    FREE SAVE AREA\n         LR    R15,R2                   SET RETURN CODE IN R15.\n         L     R14,12(R13)              RELOAD R14.\n         LM    R0,R12,20(R13)           RESTORE ENTRY REGISTERS.\n         BR    R14                      RETURN TO CALLER.\n         LTORG\nMAE2     $NMMAEX2                       MACRO TO MAP PASSED\n* DSECTS:                                                             *\nWORKAREA DSECT\nSAVEAREA DS    18F'0'                   SAVEAREA.\nACINHRT  DS    0D\n         ACINHRT DSECT=WORKAREA         LOGON INHERITANCE PARAM. BLOCK\nAREALEN  EQU   *-WORKAREA               LENGTH FOR GETMAIN.\n         ACCVT                          ACF2 COMMUNICATION VECTOR TABLE\n         END\n\n\nCraig Brown\nSystems Programmer\nAustralian Paper Manufacturers (Australia)            c Craig Brown 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N003A07": {"ttr": 3844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00I\\x01\\x16\\x05O\\x01\\x16\\x06/\\x12D\\x02\\x94\\x02\\x94\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T12:44:49", "lines": 660, "newlines": 660, "modlines": 0, "user": "SNAUPDT"}, "text": "NCP and VM/VTAM\n\nWe are a VM/SP installation and run VM/VTAM to support\nour terminal network.  We also run NCP in our 3720\ncommunications controller, which is attached and running\nunder the control of our VM/VTAM system.  To support NCP\nwe also run SSP, which is the utility used to generate, load,\nand dump the communications controller, whether it be a 3705,\n3720, or 3725.\n\nTo simplify the procedure of generating, loading, and dumping\nour NCP, I have come up with the following REXX EXECs.\nMuch of the material contained in these EXECs was extracted\nfrom the IBM manual SC30-3348 Network Control Program\nand System Support Program Generation and Loading Guide.\n\nBasically, there are three EXECs: VMPEP, which assembles\nand generates the NCP load modules; LOADNCP, which uses\nthe SSP utilities to load the communications controller with the\ngenerated load modules; and DUMPNCP, which uses the SSP\nutilities to obtain a formatted dump of the NCP.\n\n\nVMPEP EXEC\n\nVMPEP takes the NCP source input file and creates the load\nlibrary and load modules necessary to load into the\ncommunications controller.  There are options in the EXEC to\nspecify the name of your input file, the model and version of\nthe NCP and communications controller (the appropriate\nsystem LOADLIBs and TXTLIBs will then be used during\ncompilation), as well as various other options.\n\n/********************************************************************/\n/*                        NCP GENERATION EXEC                       */\n/* CORRECT FORM FOR INVOKING THE EXEC:                              */\n/*     VMPEP FN=gen_fn,FT=gen_ft,FM=gen_fm,                         */\n/*           V=version,M=model,L=loadlib,T=test                     */\n/*        1. GEN_FN, GEN_FT, GEN_FM, is the Filename, Filetype,     */\n/*           and Filemode of the Source input file containing your  */\n/*           NCP/EP statements to be assembled.                     */\n/*        2. V is the Version of NCP that you are running           */\n/*           (see table below for valid options)                    */\n/*        3. M is the model of your communcications controller      */\n/*           (see table below for valid options)                    */\n/*        4. L is the Filename of the resulting NCP loadlib that    */\n/*           will be produced.                                      */\n/*        5. T is an option that will allow for assemblies only     */\n/*           to take place, no LOADLIB will be generated.  When     */\n/*           T=YES is specified, the GEN_FN is set to \"NEW\".  This  */\n/*           allows new versions of your NCP source deck to be      */\n/*           changed and assembled without affecting your existing  */\n/*           Source or Loadlib files.                               */\n/* IF NO PARAMETERS ARE SPECIFIED, THE FOLLOWING DEFAULTS ARE TAKEN */\n/*    FILENAME = DC3720                                             */\n/*    FILETYPE = VTAMLST                                            */\n/*    FILEMODE = V                                                  */\n/*    VERSION  = V4S                                                */\n/*    MODEL    = 3720                                               */\n/*    LOADLIB  = NCPLOAD                                            */\n/*    TEST     = NO                                                 */\n/* THE ASSIGNMENT OF THE MACRO AND OBJECT LIBRARY NAMES IS DERIVED  */\n/* FROM THE PARAMETERS PASSED ON THE COMMAND LINE; THEY MAY RESIDE  */\n/* ON ANY ACCESSED DISK.                                            */\n/*                           M O D E L                              */\n/*                 3705         3725         3720                   */\n/*             --------------------------------------               */\n/*     V3     |  MAC3705   |  MAC3725   |  NOT       |              */\n/*  V         |  OBJ3705   |  OBJ3725   |  SUPPORTED |              */\n/*  E         |--------------------------------------|              */\n/*  R  V4     |  NOT       |  NOT       |  NOT       |              */\n/*  S         |  SUPPORTED |  SUPPORTED |  SUPPORTED |              */\n/*  I         |--------------------------------------|              */\n/*  O  V4R2   |  NOT       |  MAC3725   |  MAC3725   |              */\n/*  N         |  SUPPORTED |  OBJ3725   |  OBJ3725   |              */\n/*            |--------------------------------------|              */\n/*     V4     |  NOT       |  NOT       |  MAC3725   |              */\n/*     SUBSET |  SUPPORTED |  SUPPORTED |  OBJ3725   |              */\n/*             --------------------------------------               */\n/********************************************************************/\n/*  Setup Work                                                  */\n   ADDRESS COMMAND                    /* ENSURE CP/CMS ENVIRONMENT  */\n   TRACE 0\n   HI = '1DE8'x\n   LO = '1D60'x\n  'CP SCREEN ALL DEFAULT NONE'\n/*  Issue the Requirements to run this exec                     */\n   VMFCLEAR\n   SAY ' '\n   SAY HI||'REQUIREMENTS to run the VMPEP exec'||LO\n   SAY HI||'--------------------------------------------------------------'||LO\n   SAY '1. This exec must be run from a TEMP disk ... Accessed as \"A\"'\n   SAY '2. TEMP disk must be at least 50 cylinders ... to hold output.'\n   SAY '3. Storage must have been defined at 16M ... then IPL''ed 190.'\n   SAY '4. After IPL, \"ACCESS (NOPROF\"  so no disks were accessed.'\n   SAY ' '\n  SAY 'Either '||HI||'ENTER'||LO||' to Continue or '||HI||'EXIT'||LO||' to Quit'\n   SAY ' '\n   PULL ANSWR\n   SELECT\n      WHEN ANSWR = 'EXIT' THEN EXIT\n      WHEN ANSWR = 'HX' THEN EXIT\n      WHEN ANSWR = 'E' THEN EXIT\n   OTHERWISE\n      NOP\n   END\n/*  Access the disks, receive the Parameters                     */\n   'ACC 35B B'                         /* NCP Run Disk               */\n   'ACC 343 K'                         /* SSP Run Disk               */\n   'ACC 298 V'                         /* VM/VTAM 191 Config Disk    */\n   VMFCLEAR\n   GEN_FN=\"\"                           /* INITIALIZE VARIABLES       */\n   GEN_FT=\"\"\n   GEN_FM=\"\"\n   VERSION=\"\"\n   MODEL=\"\"\n   LLIB=\"\"\n   TEST=\"\"\n   ARG REST                            /* GET PARAMS FROM COMMAND    */\n   REST=TRANSLATE(REST,' ',',')        /* GET RID OF COMMAS          */\n   COUNT=WORDS(REST)\n   LPCNT=1\n/*  Parse the Parameters into individual variables               */\n   DO WHILE LPCNT<=COUNT               /* LOOP THROUGH ONCE FOR EACH */\n     TEMP=WORD(REST,LPCNT)             /* WORD IN THE STRING         */\n     PARSE VALUE TEMP WITH FRONT '=' BACK\n     SELECT\n       WHEN (ABBREV(TEMP,'FN')) THEN\n         GEN_FN=BACK\n       WHEN (ABBREV(TEMP,'FT')) THEN   /* SET APPROPRIATE VARIABLE   */\n         GEN_FT=BACK                   /* ACCORDING TO THE ASSIGNMENT*/\n       WHEN (ABBREV(TEMP,'FM')) THEN   /* MADE ON THE COMMAND LINE   */\n         GEN_FM=BACK\n       WHEN (ABBREV(TEMP,'V')) THEN\n         VERSION=BACK\n       WHEN (ABBREV(TEMP,'M')) THEN\n         MODEL=BACK\n       WHEN (ABBREV(TEMP,'L')) THEN\n         LLIB=BACK\n       WHEN (ABBREV(TEMP,'T')) THEN\n         TEST=BACK\n       OTHERWISE\n         SAY TEMP\" IS NOT VALID, IGNORED\"\n     END                               /* END SELECT                 */\n     LPCNT=LPCNT+1\n   END                                 /* END DO                     */\n/*  Check for Defaults to set                                    */\n   SAY ' '\n   SAY HI||'STATUS messages'||LO\n   SAY HI||'--------------------------------------------------------------'||LO\n   IF GEN_FN=\"\" THEN DO                /* DEFAULT FILENAME           */\n      GEN_FN=\"DC3720\"                  /* IF NOT CODED               */\n   END\n   SAY \" Defaulting to Filename = \"GEN_FN\n   IF GEN_FT=\"\" THEN DO                /* DEFAULT FILETYPE           */\n      GEN_FT=\"VTAMLST\"\n   END\n   IF TEST=\"YES\" THEN DO               /* ASSEMBLY RUN ?             */\n      GEN_FT=\"NEW\"                     /* IF NOT CODED               */\n   END\n   SAY \" Defaulting to Filetype = \"GEN_FT\n   IF GEN_FM=\"\" THEN DO                /* DEFAULT FILEMODE           */\n      GEN_FM=\"V\"                       /* IF NOT CODED               */\n   END\n   SAY \" Defaulting to Filemode = \"GEN_FM\n   IF VERSION=\"\" THEN DO               /* VERSION DEFAULTS TO V3     */\n      VERSION=\"V4S\"\n   END\n   SAY \" Defaulting to Version  = \"VERSION\n   IF MODEL=\"\" THEN DO                 /* MODEL DEFAULTS TO 3720     */\n      MODEL=\"3720\"\n      SAY \" Defaulting to Model    = \"MODEL\n   END\n   IF LLIB=\"\" THEN DO                  /* MODEL DEFAULTS TO 3720     */\n      LLIB=\"NCPLOAD\"\n      say \" Defaulting to Loadlib  = \"LLIB\n   END\n   IF TEST=\"YES\" THEN DO               /* RUN ASSEMBLY ONLY       */\n      GEN_FT=\"NEW\"                     /* FIND \"NEW\" FILE            */\n      SAY HI||\"TEST\"||LO||\" run requested - will only do ASSEMBLIES\"\n      SAY \"\"\n   END\n/*  Validate that the NCP Source file exists                     */\n  'STATE' GEN_FN GEN_FT GEN_FM         /* SEE IF GEN EXISTS ON DISK  */\n   IF RC \u00ac= 0 THEN DO\n     SAY GEN_FN GEN_FT GEN_FM \"DOES NOT EXIST\"\n     EXIT RC                           /* EXIT IF GEN DOESN'T EXIST  */\n   END\n/*  Select the appropriate MACRO and OBJECT libraries            */\n   SELECT\n     WHEN (VERSION=\"V3\")&(MODEL=\"3705\") THEN DO\n         MACRO=MAC3705                 /* FOR V3 & 3705              */\n         OBJECT=OBJ3705                /*                            */\n     END\n     WHEN (VERSION=\"V3\")&(MODEL=\"3725\") THEN DO\n         MACRO=MAC3725                 /* FOR V3 & 3725              */\n         OBJECT=OBJ3725                /*                            */\n     END\n     WHEN (VERSION=\"V4R2\")&((MODEL=\"3725\")|(MODEL=\"3720\")) THEN DO\n         MACRO=MAC3725                 /* FOR V4R2 & 3725|3720       */\n         OBJECT=OBJ3725                /*                            */\n     END\n     WHEN (VERSION=\"V4S\")&(MODEL=\"3720\") THEN DO\n         MACRO=MAC3725                 /* FOR V4 SUBSET & 3720       */\n         OBJECT=OBJ3725                /*                            */\n     END\n     OTHERWISE DO\n         SAY \"VERSION = \"VERSION\" NOT VALID WITH MODEL =\"MODEL\n         SAY \"WHEN RUNNING UNDER VM\"\n         EXIT\n     END\n   END                                 /* END SELECT                 */\n/*  Validate that the libraries exist                            */\n   'ESTATE' MACRO 'MACLIB *'           /* SEE IF MACLIB EXISTS       */\n   IF RC \u00ac= 0 THEN DO\n     SAY \"ERROR IN ACCESSING\" MACRO \"MACLIB\"\n     EXIT RC                           /* EXIT IF GEN DOESN'T EXIST  */\n   END\n   'ESTATE' OBJECT 'TXTLIB *'          /* SEE IF TXTLIB EXISTS       */\n   IF RC \u00ac= 0 THEN DO\n     SAY \"ERROR IN ACCESSING\" OBJECT \"TXTLIB\"\n     EXIT RC                           /* EXIT IF GEN DOESN'T EXIST  */\n   END\n/*  Setup filedefs for all files                                 */\n /* CLEAR ALL OLD FILEDEFS                                           */\n   'FILEDEF * CLEAR'\n /* THE DBWORKFL IS NEEDED ONLY WHEN THERE IS NOT ENOUGH VIRTUAL     */\n /* MEMORY TO HOLD ALL OF NDF'S WORK DATA.  IF YOU FIND THAT YOU     */\n /* ARE RUNNING OUT OF MEMORY, UNCOMMENT THE NEXT LINE               */\n /*'FILEDEF DBWORKFL DISK DBWORKFL FILE A ( XTENT 40'                */\n /* MACRO LIBRARIES USED IN THE TABLE ASSEMBLY PHASE OF NDF          */\n   'FILEDEF SYSLIB DISK' MACRO 'MACLIB *'\n   'GLOBAL MACLIB' MACRO\n /* INPUT FILE WITH NCP/EP GENERATION STATEMENTS                     */\n   'FILEDEF GENDECK DISK' GEN_FN GEN_FT GEN_FM\n /* GENERATION VALIDATION STEP OUTPUT                                */\n   'FILEDEF SYSPRINT DISK' GEN_FN 'LISTING A'\n /* NDF SUMMARY LISTING                                              */\n   'FILEDEF PRINTER TERM'\n /* SOURCE FOR TABLE 1 ASSEMBLY - OUTPUT FROM GENERATION VALIDATION  */\n   'FILEDEF TBL1SRCE DISK TABLE1 SOURCE A'\n /* LISTING FROM THE TABLE1 ASSEMBLY                                 */\n   'FILEDEF TBL1LST DISK TABLE1 LISTING A'\n /* TEXT OUTPUT FROM THE TABLE1 ASSEMBLY                             */\n   'FILEDEF TBL1OBJ DISK TABLE1 TEXT A'\n /* SOURCE FOR TABLE 2 ASSEMBLY - OUTPUT FROM GENERATION VALIDATION  */\n   'FILEDEF TBL2SRCE DISK TABLE2 SOURCE A'\n /* LISTING FROM THE TABLE2 ASSEMBLY                                 */\n   'FILEDEF TBL2LIST DISK TABLE2 LISTING A'\n /* TEXT OUTPUT FROM THE TABLE2 ASSEMBLY                             */\n   'FILEDEF TBL2OBJ DISK TABLE2 TEXT A'\n /* LINK EDIT CARDS OUTPUT FROM THE GENERATION VALIDATION STEP       */\n   'FILEDEF LNKSTMT DISK NCPINCL TEXT A'\n /* TEMPORARY WORK FILE USED BY THE TABLE ASSEMBLIES                 */\n   'FILEDEF SYSUT1 DISK SYSUT1 TEMP A4 (BLOCK 4000'\n/*  Run the Network Definition Facility                          */\n   'ICNRTNDF'\n   IF RC \u00ac= 0 THEN DO\n       SAY \"*** ERROR IN EXECUTING NDF (ICNRTNDF) ***\"\n       SAY \"Return Code = \"RC\n       SAY \"\"\n       EXIT RC\n   END\n/*  Put TEXT output from table assemblies into a simulated PDS   */\n   'TXTLIB GEN OBJ TABLE1 TABLE2'\n   IF RC \u00ac= 0 THEN DO\n       SAY \"CANNOT FIND TABLE1 TEXT OR TABLE2 TEXT\"\n       EXIT 99\n   END\n/*  ERASE temporary work files                                   */\n   'ERASE SYSUT1 TEMP A'\n   'ERASE TABLE1 SOURCE A'\n   'ERASE TABLE2 SOURCE A'\n   'ERASE TABLE1 TEXT A'\n   'ERASE TABLE2 TEXT A'\n/*  Issue more FILEDEFs for the LINK EDITs                       */\n /* FILDEFS FOR THE LINK EDIT STEP                                   */\n   'FILEDEF SYSUT1 CLEAR'\n   'FILEDEF' OBJECT 'DISK' OBJECT 'TXTLIB *'\n /* NCP/EP TABLE TEXT                                                */\n   'FILEDEF SYSPUNCH DISK OBJ TXTLIB A'\n /* NAME OF OUTPUT LIBRARY FOR THE LOAD MODULE                       */\n   'FILEDEF SYSLMOD DISK' GEN_FN 'LOADLIB A'\n/*  Run the LINKAGE EDITOR                                       */\n   'LKED NCPINCL (MAP NCAL NOTERM LET LIST ALIGN2 SIZE 512K'\n/*  Check to see if this is ASSEMBLY only                         */\n   IF TEST=\"YES\" THEN DO            /* RUN ASSEMBLY ONLY             */\n     SAY ' '\n     SAY 'T=YES was requested, ASSEMBLY and LINK EDIT complete'\n     SAY 'Listings now reside on 191 'A' disk'\n     SAY HI||'Exiting ...........'||LO\n     SAY ' '\n     EXIT\n   END\n/*  Copy all files to the correct Production disks               */\n   VMFCLEAR\n   SAY ' '\n   SAY HI||'STATUS messages'||LO\n   SAY HI||'--------------------------------------------------------------'||LO\n   SAY 'Copying  LOADLIB, LISTING, and LKEDIT files to'\n   SAY 'NCP RUN disk (35B) as filename  ==>  'LLIB\n   SAY ' '\n /* CHANGE THE GEN_FN TO LLIB                                        */\n   'RENAME 'GEN_FN' LOADLIB A 'LLIB' = ='\n   'RENAME 'GEN_FN' LISTING A 'LLIB' = ='\n   'RENAME  NCPINCL LKEDIT  A 'LLIB' = ='\n /* COPY NECESSARY MEMBERS TO NCP RUN DISK (35B)                     */\n   'COPY 'LLIB' LOADLIB A = = B (REP'\n   'COPY 'LLIB' LISTING A = = B (REP'\n   'COPY 'LLIB' LKEDIT  A = = B (REP'\n/*  Let them know we're all DONE                                 */\n   SAY ' '\n   SAY HI||'*** NCP/EP PEP GENERATION FINISHED ***'||LO\n   SAY ' '\n   EXIT RC\n\n\nLOAD NCP EXEC\n\nOnce you have created the NCP LOADLIB with VMPEP, you\ncan use the LOADNCP program to load the communications\ncontroller.  Although most installations will load their\ncontroller through VM/VTAM and the\nVARY,ACT...,LOAD=YES command, there may be times\nwhen VM/VTAM is not up and it is necessary to load the\ncontroller.  This program will do the job.  The one-line file\nNCP LOADCARD must reside on your 191 A disk at the time\nLOADNCP is run and is required by the SSP utility that\nactually loads the box.  See the documentation at the beginning\nof program LOADNCP for an explanation of what needs to be\nchanged in file NCP LOADCARD.\n\n /********************************************************************/\n /*                        NCP LOAD EXEC                             */\n /* CORRECT FORM FOR INVOKING THE EXEC:                              */\n /*     LOADNCP VTAM=addr,L=loadlib                                  */\n /*        1. ADDR is the virtual address of your Communications     */\n /*           controller.  Your Communications controller must       */\n /*           have been previously detached from your VM/VTAM        */\n /*           service machine and attached to this machine as        */\n /*           this address.                                          */\n /*        2. LOADLIB is the name of the LOADLIB that was generated  */\n /*           from your NCP source statements (this is the L         */\n /*           parameter in the VMPEP exec)                           */\n /*        3. To run this exec, the communications controller        */\n /*           must be detached from the VTAM service machine and     */\n /*           attached to the userid running this exec.              */\n /*        4. The NCP LOADCARD file must be edited and the UNIT=     */\n /*           parameter must be changed to reflect the virtual       */\n /*           address of the controller attached to this machine.    */\n /*           This is the same value specified for ADDR.             */\n /*        5. The NCP LOADCARD file must be edited and the           */\n /*           LOADMOD= parameter must be changed to reflect which    */\n /*           member in loadlib L contains the desired NCP           */\n /*           load module (generally, this will be the filename      */\n /*           of your source NCP file).                              */\n /* IF NO PARAMETERS ARE SPECIFIED, THE FOLLOWING DEFAULTS ARE TAKEN */\n /*    ADDR     =  040                                               */\n /*    LOADLIB  =  NCPLOAD                                           */\n /********************************************************************/\n/*  Setup Work                                                   */\n   ADDRESS COMMAND                     /* ENSURE CP/CMS ENVIRONMENT  */\n   TRACE 0\n   HI = '1DE8'x\n   LO = '1D60'x\n  'CP SCREEN ALL DEFAULT NONE'\n/*  Issue the Requirements to run this exec                      */\n   VMFCLEAR\n   SAY ' '\n   SAY HI||'REQUIREMENTS to run the LOADNCP exec'||LO\n   SAY HI||'--------------------------------------------------------------'||LO\n   SAY '1. You must be linked to the disk containing your NCP LOADLIB'\n   SAY '2. The controller to be loaded must be ATTACHED to this machine'\n   SAY ' '\n  SAY 'Either '||HI||'ENTER'||LO||' to continue or '||HI||'EXIT'||LO||' to quit'\n   SAY ' '\n   PULL ANSWR\n   SELECT\n      WHEN ANSWR = 'EXIT' THEN EXIT\n      WHEN ANSWR = 'HX' THEN EXIT\n      WHEN ANSWR = 'E' THEN EXIT\n   OTHERWISE\n      NOP\n   END\n/*  Access the disks, receive the Parameters                     */\n   'SET CMSTYPE HT'\n   'ACC 35B B'                         /* NCP Run Disk               */\n   'ACC 343 K'                         /* SSP Run Disk               */\n   'SET CMSTYPE RT'\n   VMFCLEAR\n   ADDR=\"\"                             /* INITIALIZE VARIABLES       */\n   LLIB=\"\"\n   ARG REST                            /* GET PARAMS FROM COMMAND    */\n   REST=TRANSLATE(REST,' ',','         /* GET RID OF COMMAS          */\n   COUNT=WORDS(REST)\n   LPCNT=1\n/*  Parse the Parameters into individual variables               */\n   DO WHILE LPCNT<=COUNT               /* LOOP THROUGH ONCE FOR EACH */\n     TEMP=WORD(REST,LPCNT)             /* WORD IN THE STRING         */\n     PARSE VALUE TEMP WITH FRONT '=' BACK\n     SELECT\n       WHEN (ABBREV(TEMP,'VTAM')) THEN\n         ADDR=BACK\n       WHEN (ABBREV(TEMP,'L')) THEN\n         LLIB=BACK\n       OTHERWISE\n         SAY TEMP\" IS NOT VALID, IGNORED\"\n     END                               /* END SELECT                 */\n     LPCNT=LPCNT+1\n   END                                 /* END DO                     */\n/*  Check for Defaults to set                                    */\n   SAY ' '\n   SAY HI||'STATUS messages'||LO\n   SAY HI||'--------------------------------------------------------------'||LO\n   IF ADDR=\"\" THEN DO                  /* DEFAULT ADDRESS            */\n      ADDR=\"040\"                       /* IF NOT CODED               */\n   END\n   SAY \" Defaulting to Controller Address = \"ADDR\n   IF LLIB=\"\" THEN DO                  /* DEFAULT LOADLIB            */\n      LLIB=\"NCPLOAD\"                   /* IF NOT CODED               */\n   END\n   SAY \" Defaulting to NCP Loadlib = \"LLIB\n/*  Validate Arguments                                           */\n   PARSE UPPER VALUE DIAG(8,'QUERY 'ADDR) With RESULT '15'x .\n   PARSE UPPER VALUE RESULT With CTLR . . . ATTACH_ID .\n   CTLR = STRIP(CTLR)\n   ATTACH_ID = STRIP(ATTACH_ID)\n   IF CTLR \u00ac= \"CTLR\" THEN DO\n      SAY ' '\n      SAY ' Address 'ADDR' is not a valid communications controller'\n      SAY ' Exiting ....'\n      EXIT\n   End\n   IF ATTACH_ID \u00ac= USERID() THEN DO\n      SAY ' '\n      SAY ' Controller 'ADDR' is not attached to this userid'\n      SAY ' Controller 'ADDR' is currently attached to userid 'ATTACH_ID\n      SAY ' Exiting ....'\n      EXIT\n   End\n/*  Validate that the NCP LOADCARD file exists                   */\n   'STATE NCP LOADCARD A'\n    IF RC \u00ac= 0 THEN DO\n      SAY ' '\n      SAY ' NCP LOADCARD file does not exist on your A disk'\n      SAY ' EXITing......'\n      EXIT\n    END\n/*  Setup filedefs for all files                                 */\n  'FILEDEF * CLEAR'\n  'FILEDEF SYSPRINT TERMINAL'\n  'FILEDEF SYSUT1   DISK 'LLIB' LOADLIB B'\n  'FILEDEF SYSIN    DISK NCP LOADCARD A'\n/*  Begin LOADing                                                */\n  SAY ' '\n  'IFLOADRN'\n  IF RC \u00ac= 0 THEN DO\n     SAVERC = RC\n     SAY ' '\n     SAY ' ERROR Loading Communications controller'\n     SAY ' IFLOADRN Return Code = 'SAVERC\n     SAY ' Controller NOT loaded'\n     SAY ' '\n     EXIT\n  END\n  ELSE DO\n     SAY ' '\n     SAY ' Controller LOADED Successfully'\n     SAY ' '\n  END\n/*  And EXIT                                                     */\n  SAY ' '\n  EXIT\n\n\nNCP LOADCARD\n\nLOAD LOADMOD=DC3720,UNIT=040\n\n\nDUMPNCP EXEC\n\nFinally, we have DUMPNCP, which is a program to obtain a\nformatted dump of the NCP residing in your communications\ncontroller.  Several situations may require that a dump of your\nNCP is available, most occurring during problem resolution\nwith IBM support.  This program also requires a one-line file\ntitled NCP DUMPCARD to be present on your 191 A disk, and\ncontains dump options that govern how your NCP dump will\nbe taken.  These options are defined in the IBM manual\nmentioned previously.  With this and the proper NCP Data\nAreas manual, much tuning and error information can be\nextracted regarding the performance of your communications\ncontroller.\n\n /********************************************************************/\n /*                        NCP DUMP EXEC                             */\n /* CORRECT FORM FOR INVOKING THE EXEC:                              */\n /*     DUMPNCP  VTAM=addr,TEMP=cuu                                  */\n /*        1. ADDR is the virtual address of your communications     */\n /*           controller.  Your communications controller must       */\n /*           have been previously detached from your VM/VTAM        */\n /*           service machine and attached to this machine at        */\n /*           this address.                                          */\n /*        2. CUU is the address of a TEMP disk that will be used    */\n /*           to hold the dump output.  This disk should be at       */\n /*           least 20 cylinders on a 3375 DASD unit.                */\n /* IF NO PARAMETERS ARE SPECIFIED, THE FOLLOWING DEFAULTS ARE TAKEN */\n /*    ADDR     = 040                                                */\n /*    CUU      = 199                                                */\n /********************************************************************/\n/*  Setup Work                                                   */\n   ADDRESS COMMAND                     /* ENSURE CP/CMS ENVIRONMENT  */\n   TRACE O\n   HI = '1DE8'x\n   LO = '1D60'x\n  'CP SCREEN ALL DEFAULT NONE'\n/*  Issue the Requirements to run this exec                      */\n   VMFCLEAR\n   SAY ' '\n   SAY HI||'REQUIREMENTS to run the DUMPNCP exec'||LO\n   SAY HI||'--------------------------------------------------------------'||LO\n   SAY '1. You must have a TEMP disk of at least 20 cyl. to hold the dump'\n   SAY '2. The controller to be dumped must be ATTACHED to this machine'\n   SAY ' '\n  SAY 'Either '||HI||'ENTER'||LO||' to continue or '||HI||'EXIT'||LO||' to quit'\n   SAY ' '\n   PULL ANSWR\n   SELECT\n      WHEN ANSWR = 'EXIT' THEN EXIT\n      WHEN ANSWR = 'HX' THEN EXIT\n      WHEN ANSWR = 'E' THEN EXIT\n   OTHERWISE\n      NOP\n   END\n/*  Access the disks, receive the Parameters                     */\n   'SET CMSTYPE HT'\n   'ACC 35B B'                         /* NCP Run Disk               */\n   'ACC 343 K'                         /* SSP Run Disk               */\n   'SET CMSTYPE RT'\n   VMFCLEAR\n   ADDR=\"\"                             /* INITIALIZE VARIABLES       */\n   CUU=\"\"\n   ARG REST                            /* GET PARAMS FROM COMMAND    */\n   REST=TRANSLATE(RES,' ',',')         /* GET RID OF COMMAS          */\n   COUNT=WORDS(REST)\n   LPCNT=1\n/*  Parse the Parameters into individual variables               */\n   DO WHILE LPCNT<=COUNT               /* LOOP THROUGH ONCE FOR EACH */\n     TEMP=WORD(REST,LPCNT)             /* WORD IN THE STRING         */\n     PARSE VALUE TEMP WITH FRONT '=' BACK\n     SELECT\n       WHEN (ABBREV(TEMP,'VTAM')) THEN\n         ADDR=BACK\n       WHEN (ABBREV(TEMP,'TEMP')) THEN\n         CUU=BACK\n       OTHERWISE\n         SAY TEMP\" IS NOT VALID, IGNORED\"\n     END                               /* END SELECT                 */\n     LPCNT=LPCNT+1\n   END                                 /* END DO                     */\n/*  Check for Defaults to set                                    */\n   SAY ' '\n   SAY HI||'STATUS messages'||LO\n   SAY HI||'--------------------------------------------------------------'||LO\n   IF ADDR=\"\" THEN DO                  /* DEFAULT ADDRESS            */\n      ADDR=\"040\"                       '* IF NOT CODED               */\n   END\n   SAY \" Defaulting to Controller Address = \"ADDR\n   IF CUU=\"\" THEN DO                   /* DEFAULT CUU                */\n      CUU=\"199\"\n   END\n   SAY \" Defaulting to TEMP disk address  = \"CUU\n/*  Validate Arguments                                           */\n   'SET CMSTYPE HT'\n   'ACCESS ' CUU 'Z'\n   'SET CMSTYPE RT'\n   IF RC \u00ac= 0 THEN DO\n      SAY ' '\n      SAY ' Error ACCESSing TEMP disk at address ==> 'CUU\n      SAY ' Exiting ....'\n      EXIT\n   End\n   PARSE UPPER VALUE DIAG(8,'QUERY 'ADDR) With RESULT '15'x .\n   PARSE UPPER VALUE RESULT With CTLR . . . ATTACH_ID .\n   CTLR = STRIP(CTLR)\n   ATTACH_ID = STRIP(ATTACH_ID)\n   IF CTLR \u00ac= \"CTLR\" THEN DO\n      SAY ' '\n      SAY ' Address 'ADDR' is not a valid communications controller'\n      SAY ' Exiting ....'\n      EXIT\n   End\n   IF ATTACH_ID \u00ac= USERID() THEN DO\n      SAY ' '\n      SAY ' Controller 'ADDR' is not attached to this userid'\n      SAY ' Controller 'ADDR' is currently attached to userid 'ATTACH_ID\n      SAY ' Exiting ....'\n      EXIT\n   End\n/*  Validate that the NCP DUMPCARD file exists                   */\n  'STATE NCP DUMPCARD A'\n   IF RC \u00ac= 0 THEN DO\n     SAY ' '\n     SAY ' NCP DUMPCARD file does not exist on your A disk'\n     SAY ' EXITing......'\n     EXIT\n   END\n/*  Setup filedefs for all files                                 */\n  'FILEDEF * CLEAR'\n  'FILEDEF SYSPRINT DISK NCP LISTING Z'\n  'FILEDEF SYSUT2   DISK NCP DUMP Z (RECFM F BLKSIZE 512 XTENT 62500)'\n  'FILEDEF SYSIN    DISK NCP DUMPCARD A'\n/*  Begin Dumping                                                */\n  SAY ' '\n  'IFLREAD 3725 'ADDR\n  IF RC \u00ac= 0 THEN DO\n     SAVERC = RC\n     SAY ' '\n     SAY ' ERROR Dumping Communications controller'\n     SAY ' IFLREAD Return Code = 'SAVERC\n     SAY ' Controller NOT dumped'\n     SAY ' '\n     EXIT\n  END\n  ELSE DO\n     SAY ' '\n     SAY ' Controller DUMPED Successfully...Proceeding with FORMAT....'\n     SAY ' '\n  END\n/*  Begin Formatting                                             */\n  'IFLDUMP'\n  IF RC \u00ac= 0 THEN DO\n     SAVERC = RC\n     SAY ' '\n     SAY ' ERROR Formatting Communications controller'\n     SAY ' IFLDUMP Return Code = 'SAVERC\n     SAY ' Controller Dump NOT Formatted'\n     SAY ' '\n     EXIT\n  END\n  ELSE DO\n     SAY ' '\n     SAY ' Communications controller dumped and formatted successfully'\n     SAY ' '\n  END\n/*  And EXIT                                                      */\n  SAY ' '\n  EXIT\n\n\nNCP DUMPCARD\n\nDUMP FROMADDR=000,FORMAT=Y,BUF=F\n\n\nKevin Potter\nSystems Programming Manager\nDouglas County (USA)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N003A08": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01\\x16\\x05O\\x01\\x16\\x06/\\x12E\\x00\\xba\\x00\\xba\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T12:45:34", "lines": 186, "newlines": 186, "modlines": 0, "user": "SNAUPDT"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "N004A00I": {"ttr": 4105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 13, "newlines": 13, "modlines": 0, "user": "SNAUPDT"}, "text": "N004 - SNA Update Issue #4 December 1991\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nN004A01   Pre-loading NetView CLISTs into storage\nN004A02   3174 update\nN004A03   Problems with VM/VTAM\nN004A04   Virtual route monitor\nN004A05   NCP generation migration aid\nN004A06   Error recovery in LU6.2\nN004A07   IBM announcements\nN004A08   VTAM extended display command\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N004A01": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00f\\x00f\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 102, "newlines": 102, "modlines": 0, "user": "SNAUPDT"}, "text": "Pre-loading NetView CLISTs into storage\n\nTo improve the performance of our NetView system I have\nimplemented procedures at our installation to pre-load NetView\nCLISTs into storage.  These procedures use the LOADCL,\nDROPCL, and MAPCL commands.  If NetView CLISTs are\nnot pre-loaded into storage, every time a CLIST is issued it is\nretrieved from DASD storage, executed, and then dropped\nfrom storage.  For commands such as RECYCLE and DIS this\ncan occur several hundred times a day.  Pre-loading NetView\nCLISTs overcomes this problem and increases their\nperformance.  The commands that are used to achieve this\noperation and to monitor the operation are documented in the\nNetView Operation manual.\n\n\nLOADCL COMMAND\n\nThis can be used to pre-load CLISTs into storage, and to reload\na previously-loaded CLIST into storage after the CLIST has\nbeen amended.\n\nThe format of the command is:\n\n      LOADCL clistname,clistname,(REPLACE)\n\nAt our installation we issue the LOADCL command for a\nnumber of frequently-used CLISTs at NetView start-up.  I have\nprovided examples of the command below.\n\nExamples of LOADCL commands\n\n1      LOADCL DIS\n\n      Response: CNM406I COMMAND LIST DIS LOADED\n\n      The previous command will load the CLIST named DIS\n      into storage.\n\n2      LOADCL DIS\n\n      Response: CNM408I COMMAND LIST DIS ALREADY\n      LOADED - REPLACE NOT SPECIFIED\n\n      Because the CLIST DIS has already been loaded, the\n      LOADCL command should be issued as shown in the following example.\n\n3      LOADCL DIS,(REPLACE)\n\n      Response: CNM411I COMMAND LIST CNME1023\n      DROPPED CNM406I COMMAND LIST DIS LOADED\n\n      Note how the CLIST's real name appears in the CNM411I\n      message.  This format of the command should be used\n      when the CLIST has been updated.\n\n4      LOADCL START\n\n      Response: CNM414I CLIST START NOT LOADED -\n      NOT A VALID CLIST\n\n      Because START is not a CLIST the load attempt fails.\n      Only CLISTs can be pre-loaded into storage:\n\n\nDROPCL COMMAND\n\nThe DROPCL command can be used to drop all pre-loaded\nCLISTs or an individual CLIST.  It takes the format:\n\n      DROPCL *                   - drop all CLISTs from storage.\n      DROPCL clistname,clistname - drop only those CLISTs specified.\n\n\nMAPCL COMMAND\n\nThe MAPCL command provides you with the ability to\nmonitor usage of those CLISTs that have been pre-loaded into\nstorage.  Figure 1 shows a sample output display from the\nMAPCL command.\n\n\n\nOTHER INFORMATION\n\nIBM also supplies a special REXX EXEC to manipulate the\nCLISTs that have been pre-loaded into storage.  This EXEC is\ncalled AUTODROP and allows you to drop any CLISTs that\nhave been pre-loaded if they have not met a certain usage count\nover a given period of time.  This CLIST is stored as\nCNMS8003 in the NetView-supplied CLIST library.\n\nThere are also several trivial APARs related to these commands\nand CLISTs that you may want to review on Dial-IBM or\nthrough your support centre, prior to utilizing these functions.\nThey are: OY28488, OY26687, OY25535, OY24815, and\nOY24248 for LOADCL; and OY38900, OY31925, OY28484,\nOY28510 for MAPCL.\n\nJohn Bradley\nTechnical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N004A02": {"ttr": 4110, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00J\\x00J\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 74, "newlines": 74, "modlines": 0, "user": "SNAUPDT"}, "text": "3174 update\n\nThe 3174 is IBM's workhorse cluster controller and\nfunctionally has changed very little over the years.  Perhaps the\nmost significant enhancements so far have been:\n\no      The Terminal Multiplexor Adapter (TMA) hardware to\n      support multiplexors and so reduce cabling requirements.\n\no      The Response Time Monitor (RTM) hardware to provide\n      performance monitoring data.\n\no      The Token Ring Adapter hardware to provide SNA\n      gateway access to the mainframe for terminals attached to\n      a token ring.\n\nIn SNA terms, the 3174 looks like a PU type 2.0 cluster\ncontroller node, which means that it is dependent upon either a\nPU type 4 (communications controller node containing\nACF/NCP) or a PU type 5 (host node containing a Systems\nServices Control Point - SSCP - supported by ACF/VTAM or\npossibly ACF/TCAM) to support session set-up and\ncommunications between sessions.  PU type 2.0 nodes only\nsupport a single link either to a communications controller node\nfor a remotely-attached 3174 or a host node for a locally-\nattached (ie channel-attached) 3174.  PU type 2.0 nodes cannot\ncommunicate with each other and therefore any nodes or\nlogical units connected to the 3174 can talk only to the\ncommunications controller node or host node, which\neffectively limits their access simply to host-based applications.\nIn this set-up it is not possible for intelligent devices in a token\nring network to communicate with other similar devices in\nother token rings in the same SNA network, despite the fact\nthat they are architecturally capable and should be able to in\nSNA.\n\nSuch intelligent nodes are PU type 2.1 devices, which have the\ncapability of establishing LU-to-LU sessions between nodes\n(terminals, PCs, etc) that they control and nodes controlled by\nanother PU type 2.1 with which they have a communications\nlink.  The PU type 2.1 control function is known as the Single\nNode Control Point (SNCP), which is a subset of the host-\nbased SSCP.  Perhaps the key difference between SNCP and\nSSCP is that the SNCP has knowledge of only the local\nphysical network, not the entire network.  PU type 2.1 is\nsupported by such devices as PCs and AS/400s but the\nstumbling block to their directly communicating with each\nother without having to go through the host has been the 3174.\nHowever, IBM has recently announced one of its ambiguously\nnamed Request for Price Quotations (RPQs) - perhaps more\ncorrectly termed a 'chargeable optional extra' - which\naddresses this restriction.  PU2.1 Passthrough RPQ, together\nwith new 3174 configuration support software, causes the 3174\nto act as a routing device between two communicating PU type\n2.1 nodes.  The 3174 still continues to act as a PU type 2.0 but\ndoes not interfere with the PU type 2.1 traffic.  Support for the\nenhancement requires at least ACF/VTAM 3.2 and ACF/NCP\n5.2, both of which support PU type 2.1.\n\nThis move is a small piece of the jigsaw in implementing\nAdvanced Peer to Peer Networking (APPN), which uses LU6.2\nand PU2.1 and no doubt is just the first of many\ncommunications device upgrades to come.  Full details are not\nyet available of exactly how this upgrade is going to function.\nThe purpose of this update is to make network planners aware\nthat there are (overdue) developments in this vital area of SNA.\nLU6.2 and PU2.1 are the main areas of SNA development and\nactivity at present both in and outside of IBM.  Keep reading\nSNA Update for further details.\n\nBrian Alford\nSystems Consultant\nAranda (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N004A03": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\xc8\\x00\\xc8\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 200, "newlines": 200, "modlines": 0, "user": "SNAUPDT"}, "text": "Problems with VM/VTAM\n\nLike many other users, we have had problems with VM/VTAM\nsending messages only to its secondary user (usually\nOPERATOR).  If, for example, somebody from the network\ngroup wanted to do something to the network, it had to be done\nin the computer room at the operator's terminal.\n\nOur solution involved setting up a new VM/CMS machine,\ncalled VTAMSRVC, as VTAM's secondary user instead of\nOPERATOR.  This VTAM service machine is logged on as the\nnetwork console in the computer room.\n\nBy using the CMS virtual screen facility, we are able to catch\nthe console output in a normal CMS file instead of displaying it\non the console.  This file can then be routed to the user making\nthe request.  These are the components of our system.\n\no      The VTAM EXEC, which awakes VTAMSRVC with\n      SMSG and the VTAM command and displays the output\n      from the command on your console so it seems that you\n      are VTAM's secondary user.\n\no      The WACHT EXEC, which waits for the VTAM\n      commands to issue the SNDCOM EXEC, which issues the\n      VTAM command and sends the result to the user who\n      asked for it.\n\no      The V, D, and Z EXECs on VTAMSRVC's 191, so\n      VTAMSRVC can act as a normal secondary user from VTAM.\n\nTake care to define the virtual screen (the first line in the\nWACHT EXEC) large enough to hold your biggest display.  In\nour case 200 is enough.\n\nFigure 1 shows what the console output might look like if the\nuser issued the command, VTAM D NET,ID=NCP1.\n\n\nThe following procedures have run on an IBM 4381-R14 with\nVM/HPO 5.0 and VTAM/VM 3.1.2 and on a Hitachi EX33\nwith VM/HPO 5.2 and VTAM/VM 3.1.2\n\n\nWACHT EXEC\n\n/*****************************************/\n/* VTAMSRVC WACHT EXEC                   */\n/* this exec reacts on wakeup SMSG       */\n/*****************************************/\n'DEFINE VSCREEN MESSAGE 200 72 2 0'     /* define virtual screen */\ndo forever                              /* never ending story */\n     'VMFCLEAR'\nsay 'waiting for commands ......'       /* display active message on console */\n     'wakeup (smsg'\n     parse upper pull smsg wie opdracht    /* look who's talking */\n     com = subword(opdracht,1,1)           /* which command */\n     select\n     when smsg = 'STOP' then exit\n     when (wie = 'OPERATOR' & com ='D') |, /* these users */\n          (wie = 'USER2'    & com ='D') |, /* may display */\n          (wie = 'USER3'    & com ='D') |, /* something */\n          (wie = 'HERMSEN'  & com ='D') |,\n          (wie = 'USERETC'  & com ='D')\n     then 'EXEC SNDCOM' wie opdracht\n     when (wie = 'OPERATOR' & com ='V') |, /* these users */\n          (wie = 'USER2'    & com ='V') |, /* may change  */\n          (wie = 'USER3'    & com ='V') |, /* something */\n          (wie = 'HERMSEN'  & com ='V') |,\n          (wie = 'USERETC'  & com ='V')\n     then 'EXEC SNDCOM' wie opdracht\n     when (wie = 'OPERATOR' & com ='Z')/* this user may shutdown the network */\n     then 'EXEC SNDCOM' wie opdracht\n     otherwise tell wie 'You are not authorized to use command' opdracht\n     end\nend\n\n\nSNDCOM EXEC\n\n/*****************************************/\n/* VTAMSRVC SNDCOM EXEC                  */\n/* this exec sends the  commands         */\n/*****************************************/\ntrace n\nparse arg wie opdracht                     /* get command and user */\n'SET FULLSCREEN ON'                        /* make console output go */\n'ROUTE * TO MESSAGE'                       /* to cms file */\nsay 'Command' opdracht 'van' wie           /* who's talking */\n'ERASE MESSAGE LOGFILE A'                  /* get rid off the old stuff */\n'CP SEND VTAMVM81 VTAM' opdracht           /* send the command */\n'CP SLEEP 3 SEC'                           /* wait for it */\n'WAITT VSCREEN MESSAGE'                    /* wait for completion */\n/*'FINIS MESSAGE LOGFILE A'*/              /* maybe close the file */\n'SENDFILE MESSAGE LOGFILE TO ' wie '(NOLOG'/* here it is */\n'CLEAR VSCREEN MESSAGE'                    /* clean up for next */\n'CLEAR VSCREEN CMS'                        /* commands to display */\n'SET FULLSCREEN OFF'\n'CLRSCRN'\n\n\nD EXEC\n\n/*****************************************/\n/* VTAMSRVC D EXEC                       */\n/* this exec sends the D command         */\n/* when VTAMSRVC is inactive             */\n/*****************************************/\nparse arg opdracht\n'CP SEND VTAMVM81 VTAM D' opdracht\n\n\nV EXEC\n\n/*****************************************/\n/* VTAMSRVC V EXEC                       */\n/* this exec sends the V command         */\n/* when VTAMSRVC is inactive             */\n/*****************************************/\nparse arg opdracht\n'CP SEND VTAMVM81 VTAM V' opdracht\n\n\nZ EXEC\n\n/*****************************************/\n/* VTAMSRVC Z EXEC                       */\n/* this exec sends the Z command         */\n/* when VTAMSRVC is inactive             */\n/*****************************************/\nparse arg opdracht\n'CP SEND VTAMVM81 VTAM Z' opdracht\n\n\nVTAM EXEC\n\n/*****************************************/\n/* VTAM-secondary user simulation        */\n/* syntax:  VTAM  vtam command           */\n/*****************************************/\n/* see if there's something in your RDR  */\n/*****************************************/\ntrace n\nhi = '1de8'X\nlo = '1d60'X\n'Q RDR * ALL (STACK'             /* stack your rdr files */\nif queued() \u00ac= 1\nthen do\naantal_files = queued()          /* save number of files */\n     parse pull .                /* take header */\n     do until queued() = 0       /* take the rest */\n        parse pull origin file .\n        if origin = 'VTAMSRVC'\n   then do\n        'PUR RDR' file      /* purge the old ones */\n        aantal_files = aantal_files - 1 /* 1 less */\n        end\n        else reader = 'GEVULD'\n        end                      /* end do until */\n     end                         /* end then do */\nelse 'DESBUF'                    /* clear the stack */\n/*****************************************/\n/* send command to VTAMSRVC              */\n/*****************************************/\nparse upper arg tekst            /* see what the command is */\n'SM VTAMSRVC' tekst              /* and send it to VTAMSRVC */\n/*****************************************/\n/* receive VTAMSRVC console file         */\n/*****************************************/\ntake_file:\nif reader = 'GEVULD'\nthen 'SLEEP 5 SEC'               /* wait until the file is */\n'WAKEUP (RDR'                    /* in your rdr */\n'Q RDR * ALL CL T (STACK'\nif queued() > aantal_files       /* if there are any */\nthen do until queued() = 0       /* then take them */\n     parse pull origin file .\n     if origin = 'VTAMSRVC'      /* but only from VTAMSRVC */\n     then 'RECEIVE' file 'VTAMSRVC FILE A (REPL NOL'\n     end                         /* end do until */\nelse signal take_file            /* see if there are more */\n/*****************************************/\n/* read VTAMSRVC FILE                    */\n/*****************************************/\n'EXECIO * DISKR VTAMSRVC FILE A' /* read it */\n'CLRSCRN'\nsay hi copies('-',80) lo         /* display 80 dashes */\ndo index = 1 to queued()         /* and display it */\n   parse pull regel.index\n   regel.index = strip(regel.index)\n   say hi regel.index lo         /* on your console */\n   end                           /* end do */\nsay hi copies('-',80) lo         /* display 80 dashes */\n'ERASE VTAMSRVC FILE A'          /* and throw it away */\n\n\nJoop Hermsen\nSenior Systems Programmer\nVNU Dagbladengroep BV (The Netherlands)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N004A04": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x07\\x1d\\x07\\x1d\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 1821, "newlines": 1821, "modlines": 0, "user": "SNAUPDT"}, "text": "Virtual route monitor\n\n\nINTRODUCTION\n\nNetwork performance problems are often difficult, if not\nimpossible, to track down using the tools generally available to\nsupport personnel.  One particular problem which is very\ndifficult to diagnose is that of virtual routes which become\nintermittently held or blocked.  This is a particularly difficult\nproblem to diagnose as there are no indications of when it is\nhappening, other than poor performance.  There are no\nsupplied tools to tell you the problem exists or to diagnose the\nproblem when it does occur.\n\n\nVIRTUAL ROUTES\n\nVirtual routes are logical pipelines connecting VTAMs and\nNCPs.  These pipelines are used to carry sessions with similar\ncharacteristics, such as interactive, printer, or NJE traffic.\nTypically control of these pipelines is by session pacing values\nin mode table entries, and by tuning the window sizes in the\nVTAM and NCP PATH statements.  If the load at a virtual\nroute end point is excessive then VTAM and NCP modify the\nstatus of the route to 'held' (if up to the current window size\nworth of PIUs are queued) or 'blocked' (if more than the\ncurrent window size worth of PIUs are queued).\n\nIn a regrettably common situation, sessions are often unpaced\nwhich leads to performance problems - for example, when\nlarge volumes of SPOOL hit the VTAM I/O buffer pool.  In\nfact, in early releases of VTAM the whole network could seize\nup requiring a Z NET,CANCEL before VTAM could be\nrestarted.  Less dramatic effects can include intermittent\nperformance problems experienced by disparate groups of\nnetwork users (ie there appears to be no common application\nthat is suffering).  Often no reason can be seen for the\nproblems, as the network is still servicing users and VTAM\ndisplays show no obvious bottlenecks.\n\nThe problem can be particularly severe in the case of networks\ncontaining a large number of locally-attached SNA cluster\ncontrollers: if even a single user is traversing a blocked or held\nvirtual route then all users of that cluster controller are\nimpacted.  This is because the only mechanism VTAM can use\nto slow traffic across the virtual route is to stop polling the\ncluster controller!  Obviously local non-SNA cluster controller\nusers are less affected as VTAM treats each terminal as a\nseparate device.\n\n\nDIAGNOSIS THE IBM WAY\n\nWith the IBM-supplied tools, the simplest method to detect the\nproblem is by issuing a D NET,PATHTAB command.  If you\nare very lucky, and get the command in at precisely the right\nmoment, the display will indicate if the route is held or blocked\nbut it will not give any clue to what might be overloading the\nroute, or which resources are affected.  If the route is impacted\nfor a long enough period of time, an SVC dump can be taken\nand the relevant control blocks can be examined.  On-line\ndiagnosis at the time of the problem is all but impossible.\n\n\nDIAGOSIS DONE PROPERLY - AT THE TIME\n\nThe virtual route monitor, presented here, has been designed to\nmake periodic checks on the status of the virtual routes. When\nit detects blocked or held routes it formats diagnostic\ninformation showing the virtual route destination; the adjacent\nsubarea number; the transmission priority number; the virtual\nroute state (eg blocked, held); the minimum, current, and\nmaximum window sizes; the number of resources held by this\nevent; and the number of PIUs queued for transmission.  It also\nproduces a summary of the first five resources held, including\nthe session partner when it is an application being held, and a\nsummary of the first five PIUs queued, including the origin and\ndestination names (or addresses if no interpretation is possible),\nand the first sixteen bytes of the RU data (also interpreted if it\nis a VTAM flow).\n\nOn the assumption that queued PIUs are probably more of the\nsame that impacted the route in the first place, the display\nshould give an indication of what is causing the problem (see\nFigure 1).\n\n\nProgram components and Installation\n\nThe virtual route monitor consists of two programs.  YJP$MSG\nis a general purpose message formatting program and should be\nassembled first.  YJPVRMON is the actual monitor and needs\nto be assembled, authorized (AC(1)), into an authorized\nlibrary.  Authorization is required for two reasons: firstly to\nallow the program to set its authorization index for cross\nmemory services and secondly to allow it to read 'protected'\nstorage in the VTAM address space.  Cross memory access is\nachieved using access registers.\n\nIn addition to this, we have included a NetView NPDA trap for\nthe VRM005I message, which will cause an alert to be\ngenerated whenever the message is issued.  This warns us of a\npossible problem as soon as it happens and allows us to\nsuppress VRM messages from the MVS console.  When a\nproblem is highlighted, we use SDSF to look at the messages\non the spool queue.\n\nOnce assembled, the monitor should be set up as a started task\nto run whenever the network is loaded.  There are no DD\nstatements or parameters required.  All output from the\nprogram is issued via WTOs to the MVS console.\n\n\nUsing the Virtual Route Monitor\n\nOnce started, the monitor can be controlled using the following\nsimple set of commands, issued via the MVS modify\ncommand:\n\no      QUERY - Displays the current status of the monitor,\n      including the current virtual route scan interval and the\n      'type' of monitoring being performed.  (See SHOW command.)\n\no      SHOW ALL - Tells the monitor to display all virtual\n      routes, whether held, blocked, or open.\n\no      SHOW NOPEN - Requests that the monitor display any\n      virtual routes which are held or blocked, even if there are\n      no impacted users.  Normally, this is an acceptable\n      situation as there is no performance degradation involved.\n\no      SHOW HELD - This is the default, and will display\n      virtual routes which are held or blocked and which have\n      impacted users, ie have a TSCB queue or held HSQHs.\n\no      INTERVAL=hhmmss - Changes the virtual route scanning\n      interval.  The new value must be given in full (6 digits)\n      and can not be less than 5 seconds or longer than 24 hours.\no      HELP - Displays a short help screen of valid commands.\n\no      STOP - Ends the virtual route monitor.  This is equivalent\n      to the MVS 'P' command.  The monitor will stop of its\n      own accord if VTAM is stopped.\n\nAssuming a started task name of VRMON, to change the\nscanning interval to every minute, one would enter:\n\n      f  vrmon,interval=000100\n\nand to display all held/blocked routes:\n\n      f vrmon,show nopen\n\nIf you enter an invalid command, the program will display a\nshort help message with the correct command format.\n\n\nRelease Notes\n\nThe virtual route monitor is currently running on MVS/ESA\nwith VTAM 3.2.  Due to the fact that there are no mapping\nDSECTs supplied for the VTAM control blocks, I have coded\na series of equates for the relevant control blocks and bit\nsettings.  These have been taken from the VTAM 3.2 and\nVTAM 3.3 manuals.  If you are running any other version of\nVTAM, you should check the offsets before using the program.\nI also verify that I have obtained the correct ATCVT address\nby looking for the eyecatcher at the start of the control block\n(VT32).  This value should also be checked and modified for\nother versions of VTAM.\n\nI would like to make one small dedication to Dave Martin, a\ncolleague who, through a constant barrage of whinging, forced\nme to write this monitor and who constantly forces me to add\nextra features.  My thanks go to him for the best week's work I\nhave had in a long time and for the excellent technical\nassistance he has given me.  Thanks Dave.\n\n\nYJP$MSG\n\n* FUNC   Message format and display routine                           *\n* MACROs #LINKAGE                                                     *\n* RTNS   None                                                         *\n* ATTRIB RENT,REUSE,REFR,AC(0),AMODE(24),RMODE(24)                    *\n***      Savearea chaining                                            *\nYJP$MSG  #LINKAGE START,AMODE=24,RMODE=24,BASE=12,DSA=13\n***      Locate message                                               *\n         LR    R2,R1               ->INPUT PARAMETER LIST\n         L     R4,0(,R2)           ->MESSAGE TABLE\nMSGLOOP2 CLC   10(2,R2),0(R4)      MATCH ON MESSAGE NUMBER?\n         BE    MSGSCAN             (YES)\n         SR    R1,R1               CLEAR FOR ICM\n         ICM   R1,3,2(R4)          LENGTH OF CURRENT MESSAGE\n         LA    R4,4(R4,R1)         ->NEXT MESSAGE\n         CLC   0(4,R4),MSGHEXFF    END OF TABLE?\n         BNE   MSGLOOP2            (NO )-KEEP LOOKING\n         B     MSGERR1             (YES)-MESSAGE NOT FOUND\n***      Start of message build and substitution                      *\nMSGSCAN  LA    R5,4(,R4)           ->START OF TEXT\n         SR    R1,R1               CLEAR FOR ICM\n         ICM   R1,3,2(R4)          LENGTH OF CURRENT MESSAGE\n         LA    R6,0(R1,R5)         ->END OF TEXT\n         L     R3,16(,R2)          ->START OF VARIABLE LIST\n         LA    R7,MSGBUFR          ->START OF OUTPUT BUFFER\n         LA    R8,MSGBUFR+L'MSGBUFR ->END OF OUTPUT BUFFER\n         B     *+8\nMSGLOOP3 LA    R5,1(,R5)           ->NEXT BYTE OF MESSAGE\n         CR    R5,R6               END OF TEXT?\n         BE    MSGTPUT             (YES)\n         CLC   0(1,R5),13(R2)      SUBSTITUTION CHARACTER?\n         BE    MSGCHAR             (YES)\n         MVC   0(1,R7),0(R5)       ADD FIXED TEXT TO BUFFER\n         LA    R7,1(,R7)           INCREMENT OUTPUT BUFFER POINTER\n         B     MSGLOOP3            PROCESS NEXT CHARACTER\n***      Format substitution as character data                        *\nMSGCHAR  CLI   6(R3),1             CHARACTER DISPLAY?\n         BNE   MSGHEX              (NO )\n         LH    R15,4(,R3)          LENGTH OF FIELD\n         L     R14,0(,R3)          ->FIELD\n         LA    R0,0(R7,R15)        ->END OF FIELD\n         CR    R0,R8               ROOM FOR FIELD?\n         BNL   MSGERR5             (NO )\n         BCT   R15,*+10            ADD TO OUTPUT BUFFER :-\n         MVC   0(*-*,R7),0(R14)\n         EX    R15,*-6\n         LA    R7,1(R15,R7)        INCREMENT OUTPUT BUFFER POINTER\n         LA    R3,8(,R3)           ->NEXT VARIABLE IN LIST\n         B     MSGLOOP3            PROCESS NEXT CHARACTER\n***      Format substitution as hexadecimal data                      *\nMSGHEX   CLI   6(R3),2             HEXADECIMAL DISPLAY?\n         BNE   MSGDEC              (NO )\n         LH    R15,4(,R3)          LENGTH OF FIELD\n         LA    R0,0(R7,R15)\n         AR    R0,R15              ->END OF FIELD\n         CR    R0,R8               ROOM FOR FIELD?\n         BNL   MSGERR5             (NO )\n         L     R14,0(,R3)          ->FIELD\n         LA    R3,8(,R3)           ->NEXT VARIABLE IN LIST\n         LA    R15,0(R14,R15)      ->END OF FIELD\n         B     *+12\nMSGLOOP4 LA    R7,2(,R7)           ->NEXT BYTE IN OUTPUT FIELD\n         LA    R14,1(,R14)         ->NEXT BYTE IN INPUT FIELD\n         CR    R14,R15             END OF INPUT FIELD?\n         BE    MSGLOOP3            (YES)\n         UNPK  0(3,R7),0(2,R14)    CONVERT TO EBCDIC :-\n         TR    0(2,R7),MSGHEXTR\n         B     MSGLOOP4            PROCESS NEXT CHARACTER\n***      Format substitution as decimal data                          *\nMSGDEC   CLI   6(R3),3             DECIMAL DISPLAY?\n         BNE   MSGBIN              (NO )\n         LH    R15,4(,R3)          LENGTH OF FIELD\n         LA    R0,0(R7,R15)        ->END OF FIELD\n         CR    R0,R8               ROOM FOR FIELD?\n         BNL   MSGERR5             (NO )\n         L     R14,0(,R3)          ->FIELD\n         LA    R3,8(,R3)           ->NEXT VARIABLE IN LIST\n         MVC   MSGWORK,MSGMASK     ADD EDIT MASK\n         ED    MSGWORK,0(R14)      FORMAT\n         LA    R1,MSGWORK+16       ->END OF WORK FIELD\n         SR    R1,R15              ->START OF REQD BIT OF WORK FIELD\n         BCT   R15,*+10            ADD TO OUTPUT BUFFER :-\n         MVC   0(*-*,R7),0(R1)\n         EX    R15,*-6\n         LA    R7,1(R15,R7)        INCREMENT OUTPUT BUFFER\n         B     MSGLOOP3            PROCESS NEXT BYTE\n***      Format substitution as binary data                           *\nMSGBIN   CLI   6(R3),4             BINARY FULLWORD DISPLAY?\n         BE    MSGBINW             (YES)\n         CLI   6(R3),5             BINARY HALFWORD DISPLAY?\n         BE    MSGBINH             (YES)\n         B     MSGDUMP             TRY OTHER TYPES\nMSGBINW  L     R14,0(,R3)          ->FIELD\n         L     R0,0(,R14)          =FIELD\n         B     *+12\nMSGBINH  L     R14,0(,R3)          ->FIELD\n         LH    R0,0(,R14)          =FIELD\n         CVD   R0,MSGDW            CONVERT TO DECIMAL\n         LH    R15,4(,R3)          LENGTH OF FIELD\n         LA    R0,0(R7,R15)        ->END OF FIELD\n         CR    R0,R8               ROOM FOR FIELD?\n         BNL   MSGERR5             (NO )\n         LA    R3,8(,R3)           ->NEXT VARIABLE IN LIST\n         MVC   MSGWORK,MSGMASK     ADD EDIT MASK\n         ED    MSGWORK,MSGDW       FORMAT\n         LA    R1,MSGWORK+16       ->END OF WORK FIELD\n         SR    R1,R15              ->START OF REQD BIT OF WORK FIELD\n         BCT   R15,*+10            ADD TO OUTPUT BUFFER :-\n         MVC   0(*-*,R7),0(R1)\n         EX    R15,*-6\n         LA    R7,1(R15,R7)        INCREMENT OUTPUT BUFFER\n         B     MSGLOOP3            PROCESS NEXT BYTE\n***      Format substitution as dump data                             *\nMSGDUMP  CLI   6(R3),6             DUMP DISPLAY?\n         BNE   MSGERR2             (NO )\n         LH    R15,4(,R3)          LENGTH OF FIELD\n         CH    R15,=Y(16)          TRUNCATE IF NECESSARY :-\n         BNH   *+8\n         LA    R15,16\n         LA    R0,56(,R7)          ->END OF FIELD\n         CR    R0,R8               ROOM FOR FIELD?\n         BNL   MSGERR5             (NO )\n         L     R14,0(,R3)          ->FIELD\n         MVI   36(R7),C'*'         ADD CHARACTER TO OUTPUT :-\n         BCT   R15,*+10\n         MVC   38(*-*,R7),0(R14)\n         EX    R15,*-6\n         MVI   55(R7),C'*'\n         LA    R15,1(R14,R15)      ->END OF FIELD\n         MVI   MSGWORK,64          CLEAR WORK FIELD :-\n         MVC   MSGWORK+1(L'MSGWORK-1),MSGWORK\n         LA    R1,MSGWORK          ->START OF WORK FIELD\n         B     *+12\nMSGLOOP5 LA    R1,2(,R1)           ->NEXT BYTE IN OUTPUT FIELD\n         LA    R14,1(,R14)         ->NEXT BYTE IN INPUT FIELD\n         CR    R14,R15             END OF INPUT FIELD?\n         BE    MSGDUMP1            (YES)\n         UNPK  0(3,R1),0(2,R14)    CONVERT TO EBCDIC :-\n         TR    0(2,R1),MSGHEXTR\n         B     MSGLOOP5            PROCESS NEXT CHARACTER\nMSGDUMP1 MVC   0(8,R7),MSGWORK     ADD TO OUTPUT BUFFER :-\n         MVC   9(8,R7),MSGWORK+8\n         MVC   18(8,R7),MSGWORK+16\n         MVC   27(8,R7),MSGWORK+24\n         LA    R7,56(,R7)          INCREMENT OUTPUT BUFFER\n         LA    R3,8(,R3)           ->NEXT VARIABLE IN LIST\n         B     MSGLOOP3            PROCESS NEXT MESSAGE BYTE\n***      Display message using TPUT                                   *\nMSGTPUT  CLI   12(R2),1            DISPLAY USING TPUT?\n         BNE   MSGWTO              (NO )\n         LA    R1,MSGBUFR          ->START OF OUTPUT BUFFER\n         SR    R7,R1               =LENGTH OF OUTPUT BUFFER\n         LR    R0,R7               MOVE FOR TPUT\n         TPUT  (1),(0),R           DISPLAY MESSAGE\n         SR    R15,R15             CLEAR RETURN CODE\n         B     MSGEXIT             TERMINATE PROGRAM\n***      Display message using WTO                                    *\nMSGWTO   CLI   12(R2),2            DISPLAY USING WTO?\n         BNE   MSGBUF              (NO )\n         LA    R1,MSGBUFR          ->START OF OUTPUT BUFFER\n         SR    R7,R1               =LENGTH OF OUTPUT BUFFER\n         MVC   MSGEXWTO(MSGWTOL),MSGMFWTO RESET WORKAREA\n         CH    R7,=Y(120)          TRUNCATE MESSAGE IF NECESSARY :-\n         BNH   *+8\n         LA    R7,120\n         BCT   R7,*+10             ADD MESSAGE TO WORKAREA :-\n         MVC   MSGEXWTO+4(*-*),0(R1)\n         EX    R7,*-6\n         WTO   MF=(E,MSGEXWTO)     ISSUE MESSAGE USING WTO\n         SR    R15,R15             CLEAR RETURN CODE\n         B     MSGEXIT             TERMINATE PROGRAM\n***      Build buffer and return it to caller                         *\nMSGBUF   CLI   12(R2),3            RETURN BUFFER TO CALLER?\n         BNE   MSGERR3             (NO )\n         LA    R8,MSGBUFR          ->START OF OUTPUT BUFFER\n         SR    R7,R8               =LENGTH OF OUTPUT BUFFER\n         LA    R7,7(,R7)           ROUND UP TO NEAREST DOUBLEWORD :-\n         SRL   R7,3\n         SLL   R7,3\n         STH   R7,8(,R2)           SAVE LENGTH FOR CALLER\n         GETMAIN RC,LV=(R7)        GET BUFFER FOR CALLER :-\n         LTR   R15,R15             GETMAIN OK?\n         BNZ   MSGERR4             (NO )\n         ST    R1,4(,R2)           SAVE ADDRESS OF BUFFER FOR CALLER\n         BCT   R7,*+10             ADD MESSAGE TO BUFFER :-\n         MVC   0(*-*,R1),0(R8)\n         EX    R7,*-6\n         B     MSGEXIT             TERMINATE PROGRAM\n***      Error routines                                               *\nMSGERR1  LA    R15,4               SET MESSAGE NOT FOUND CODE\n         B     MSGEXIT             TERMINATE PROGRAM\nMSGERR2  LA    R15,8               SET FORMAT NOT RECOGNIZED CODE\n         B     MSGEXIT             TERMINATE PROGRAM\nMSGERR3  LA    R15,12              SET TYPE NOT RECOGNIZED CODE\n         B     MSGEXIT             TERMINATE PROGRAM\nMSGERR4  LA    R15,16              SET GETMAIN FAILED CODE\n         B     MSGEXIT             TERMINATE PROGRAM\nMSGERR5  LA    R15,20              SET MESSAGE TOO LONG CODE\n         B     MSGEXIT             TERMINATE PROGRAM\n***      Set return code and return to caller                         *\nMSGEXIT  #LINKAGE END              EXIT, RC is in R15\n         LTORG ,\nMSGHEXFF DC    X'FFFFFFFF'\nMSGMASK  DC    X'40202020202020202020202020202120'\n         DC    C'0123456789ABCDEF'\nMSGHEXTR EQU   *-256\nMSGMFWTO WTO   '                                                       *\n                                                                       *\n                       ',ROUTCDE=11,MF=L\n***      GETMAINED workarea map                                       *\n         #LINKAGE DSASTART\nMSGDW    DS    D\nMSGBUFR  DS    CL256\nMSGWORK  DS    CL16\nMSGEXWTO WTO   '                                                       *\n                                                                       *\n                       ',ROUTCDE=11,MF=L\nMSGWTOL  EQU   *-MSGEXWTO\n         #LINKAGE DSAEND\n         END   ,\n\n\nYJPVRMON\n\nYJPVRMON #LINKAGE START,DSA=13,AMODE=24,RMODE=24,BASE=(12,11)\n         #AMODE 31                 Go 31 bit addressing\n         BAL   R10,INIT            Initialize any special fields\n         BAL   R10,GETASID         Find \"NET\" ASID\n         BAL   R10,GETAUTH         Get authority for Xmemory\n         BAL   R10,GETSTOR         Get storage for saved data\n         #AMODE 24\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=1   Started Message\n         #AMODE 31                 Go 31 bit addressing\nCHKVRB   BAL   R10,CLRSTOR         Clear storage to zeros\n         BAL   R10,CHKVTAM         Is VTAM shutting down ?\n         BAL   R10,GETVRB          Get VRBLK information\n         BAL   R10,PUTTABLE        Go print the results of the scan\n         BAL   R10,WAIT            Wait for timer to expire\n         B     CHKVRB              <== May be bypassed by WAIT routine\n         BAL   R10,KILLSTOR        Release storage for saved data\nTIDYUP   BAL   R10,KILLAUTH        Reset authorization index\n         SR    R15,R15             Clear return code\nENDIT    #LINKAGE END              Return to caller\n* DSA initialization - set up ECBLIST - process Stop/Modify CIB       *\nINIT     LAM   0,15,KILLALET       Reset all ALETS to our addrspc\n         MVC   TIMER,=C'00000500'  Time delay between VR scans (5sec)\n         MVI   SHOWFLAG,SHOWHELD   Only show not-open with HSQH chain\n         LA    R2,TIMERECB         ->Timer ECB\n         ST    R2,ECBTIMER         Store in ECB list\n         OI    ECBTIMER,X'80'      Set end of ECB list flag\n         USING CIBNEXT,R2          (Command Input Area)\n         USING COMLIST,R3          (Command Area)\n         EXTRACT MF=(E,MFLEXT)     Locate comms area address :-\n         L     R3,COMMAREA         ->Communications area\n         L     R2,COMCIBPT         ->Command input buffer\n         L     R0,COMECBPT         Save stop/modify address :-\n         ST    R0,ECBQEDIT         Store stop/modify ECB in list\n         CLI   CIBVERB,CIBSTART    Is this the start CIB ?\n         BNE   NOTSTRT             (No )\n         QEDIT ORIGIN=COMCIBPT,    Free start CIB                      *\n               BLOCK=(2)\nNOTSTRT  QEDIT ORIGIN=COMCIBPT,    Only allow 1 modify at a time       *\n               CIBCTR=1\n         L     R2,X'408'           ->ATCVT\n         CLC   0(4,AR2),ATCVTV     Is this the VTAM ATCVT ?\n         BNER  R10                 (No )-No further processing\n         MVC   HOSTSA,ATCHOSTA(R2) Save our sub-area number\n         MVC   HOSTE,ATCHOSTE(R2)  Save our element number\n         BR    R10                 Return to caller\n         DROP  R2\n         DROP  R3\n*                Find the ASID of the \"NET\" job                     *\nGETASID  L     R2,X'408'           ->ATCVT\n         CLC   0(4,R2),ATCVTV      Is this the VTAM ATCVT ?\n         BNE   NOASID              (No )-No further processing\n         MVC   ASIDSAVE,ATCASID(R2) (Yes)-Move VTAM asid\n         CLC   ASIDSAVE,=H'0'      Is there an ASID ?\n         BNER  R10                 (Yes)-return to caller\nNOASID   #AMODE 24\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=100 ASID not found.\n         #AMODE 31\n         B     ENDIT\n*                Get authorized for cross memory                    *\nGETAUTH  MODESET MODE=SUP          Go supervisor state for AXEXT\n         EPAR  R2                  Get my ASID\n         STH   R2,ASIDMINE         and save for extract\n         AXEXT ASID=ASIDMINE       Extract my authorization index\n         LTR   R15,R15             Did I manage to get it ?\n         BNZ   NOAUTH              (No )-Leave\n         STH   R0,AXSAVE           Save my Authorization index\n         MVC   AXSET1,=H'1'        Setup the auth.Index we want\n         AXSET AX=AXSET1           Set new auth index\n         MODESET MODE=PROB         Go safe again\n         LAM   0,15,KILLALET       Reset all ALETS to our addrspc\n         BR    R10                 Return to caller\nNOAUTH   MODESET MODE=PROB         Go safe again\n         B     TIDYUP              On error - run away\n*                Get working storage to save VRBLK info into        *\nGETSTOR  L     R2,X'408'           ->ATCVT\n         CLC   0(4,AR2),ATCVTV     Is this the VTAM ATCVT ?\n         BNE   NOSTOR              (No )-No further processing\n         XR    R6,R6               Clear a register\n         IC    R6,ATCMAXID(,R2)    Insert sub-area count\n         CH    R6,=H'129'          Keep count under 128!\n         BL    *+8\n         LA    R6,128\n         LA    R6,1(,R6)           Add 1 for terminating entry\n         MH    R6,=Y(LSAVE)        Entries * entry length\n         MH    R6,=Y(16)           Allow for 16 Virtual routes/SA\n         GETMAIN R,LV=(R6)         Get working storage\n         LTR   R15,R15             Did I get the storage\n         BNE   NOSTOR              (no )\n         STM   R0,R1,STORLEN       Save length/address\n         A     R1,STORLEN          Add address to storage length\n         S     R1,=AL4(LSAVE+1)    Minus 1 entry\n         ST    R1,STOREND          Save as end of storage area\n         BR    R10                 Return to caller\nNOSTOR   B     ENDIT               Cancel program\n*                Clear working storage to zero                      *\nCLRSTOR  L     R2,STORADR          ->Working storage               R\n         L     R3,STORLEN          Length of working storage       R\n         XR    R4,R4                                               S\n         XR    R5,R5               X'00' fill the area             S\n         MVCL  R2,R4\n         BR    R10\n*                See if VTAM is still up                            *\nCHKVTAM  L     R2,X'408'           ->ATCVT\n         CLC   0(4,R2),ATCVTV      Is this the VTAM ATCVT ?\n         BNE   NOVTAM              (No )-No further processing\n         TM    ATCSTAT(R2),ATCACTIV  Is VTAM still active ?\n         BOR   R10                   (Yes) continue processing\nNOVTAM   B     ENDIT                 (No ) Terminate program\n*                Scan the VRBLK's for the info we want and save     *\n*                it in the \"STORADR\" structure.                     *\n         USING VTDATA,R7\n         USING VPDATA,R8\nGETVRB   L     R7,STORADR          ->Getmained storage\n         MVI   0(R7),X'FF'         Insert end of table flag\n         TIME  DEC                 Get current time/date\n         ICM   R1,B'1000',=X'00'   Convert 0CYYDDDf to 00YYDDDf\n         ST    R1,CDATE            Save date for insertion into rec.\n         LR    R9,R0               Copy time\n         SRL   R9,4                (0hhmmsst)\n         O     R9,=F'15'           (0hhmmssF)\n         ST    R9,CTIME            Save time for later insertion\n         MODESET KEY=ZERO          Go Key zero for VRBLK information\n         LH    R2,ASIDSAVE         Get ASID of the NET job\n         SSAR  R2                  And setup secondary addressing\n         LAM   0,15,SETALET        Set ALETS for ALL registers\n         SAC   512                 Go cross memory\n***         WARNING  --  WARNING  --  WARNING  --  WARNING        ***\n*   In cross memory mode here. .......                              *\n*   R2, R3, R4, R5, R6 -  Address the \"NET\" address space !         *\n*   Register usage is as follows:                                   *\n*    R0                                                             *\n*    R1                                                             *\n*   AR2          -> VRBLK anchors                                   *\n*   AR3          -> Current VRBLK                                   *\n*   AR4          -> Current Transmission Priority                   *\n*   AR5          Work register  (->TSCB, ->HSQH)                    *\n*   AR6          Work register  (->NCB, ->ACDEB)                    *\n*    R7          -> VR information save area                        *\n*    R8          -> Current Transmission Priority Info save area    *\n*    R9          -> HSQH save data                                  *\n*    R10         Return address from routine, used as work (once).  *\n*    R11         Second base register                               *\n*    R12         Base register                                      *\n*    R13         DSA/Save area pointer                              *\n*    R14         Used as a work register(Sorry)                     *\n*    R15         Used as a loop counter (Sorry, I ran out of regs.) *\n         L     AR2,X'408'          ->ATCVT\n         CLC   0(4,AR2),ATCVTV     Is this the VTAM ATCVT ?\n         BNE   VRBDONE             (No )-Get out now\n         XC    THISSUB,THISSUB     Clear subarea count\n         XR    R9,R9               Clear work register\n         IC    R9,ATCMAXID(,AR2)   Insert subarea count\n         CH    R9,=H'128'          Keep count under 128!\n         BL    *+8\n         LA    R9,128\n         L     AR2,ATCVRNDX(,AR2)  ->VRBLK index start\nVRBNXTSA STH   R9,NUMSA            Save number of subareas to proc.\n         L     AR3,0(,AR2)         ->VRBLK\n         LTR   AR3,AR3             Is there a VRBLK for this subarea?\n         BZ    NOVRBLK             (No )-Nothing to do - index up\n*                                     Save from VRBLK :-\nVRBNXTVR LA    R9,RESTAB           Initialize ptr to SA/ELE table\n         ST    R9,RESSAV\n         XC    0(20,R9),0(R9)      Clear out first entry\n         MVC   VTDATE(4),CDATE     Insert date (00yydddF)\n         MVC   VTTIME(4),CTIME     Insert Time (0hhmmssF)\n         MVC   VTSUBA(2),THISSUB         Subarea number\n         MVC   VTASUBA,VRBADJSA+2(AR3)   Adjacent subarea\n         MVC   VTDSUBA,VRBDSTSA+2(AR3)   Destination subarea\n         MVC   VTVRNO+1(1),VRBVRN(AR3)   Virtual route number\n         LA    R8,VTP0                   Output save area\n         LA    AR4,VRBFSTS(,AR3)         ->Path 0 status information\n*                                     Save from Path info:-\nVRBNXTTP MVC   VPSTATE,VRBVRFSM(AR4)     Virtual route status\n         MVC   VPFCFSM,VRBPRI(AR4)       Flow control finite state\n         MVC   VPACTW+1(1),VRBPALIM(AR4) Window actual size\n         MVC   VPSESS(2),VRBSECNT(AR4)   Session count\n         MVC   VPMINW+1(1),VRBMINWS(AR4) Minimum window size\n         MVC   VPMAXW+1(1),VRBMAXWS(AR4) Maximum window size\n         CLI   VPSTATE,VRBVRFAC    Is this an active route ?\n         BNE   VRBNOACT            (No )-Ignore entry\n         TM    VPFCFSM,VRBFCFOP    Is it open ?\n         BO    VRBNOACT            (Yes)-Ignore entry\n*   We have an ACTIVE, but NOT OPEN route. Store some information:- *\n*   From the TSCB:     The send/receive network addresses RU data   *\n         LA    R9,VPTSCB           ->TSCB saved data\n         USING VTSDATA,R9          Address record layout\n         LA    R1,LTSCBS(,R9)      End of area pointer\n         ST    R1,VTSEND           Save for comparison later\n         L     AR5,VRBRHOLD(,AR4)  ->TSCB\n         LTR   AR5,AR5             Is there a TSCB ?\n         BZ    DOHSQH              (No )-Go check HSQH\n         ZAP   QDEPTH(3),=PL3'0'   Depth of TSCB chain\nNEXTTSCB AP    QDEPTH(3),=PL3'1'   Count 1 TSCB\n         CLI   0(AR5),X'99'        Is this a TSCB ?\n         BNE   ENDTSCB             (No )\n         MVC   VPTHDSAF,TSCTH4+TH4DSAF(AR5)  Dest subarea field\n         MVC   VPTHOSAF,TSCTH4+TH4OSAF(AR5)  Origin subarea field\n         MVC   VPTHDEF,TSCTH4+TH4DEF(AR5)    Dest subarea field\n         MVC   VPTHOEF,TSCTH4+TH4OEF(AR5)    Origin subarea field\n         MVC   VPRH(2),TSCRH+RHF0(AR5)       Move RH data\n         MVC   VPRU(16),TSCRU(AR5)           Move RU data\n*   Save destination/origin subarea/element so we can resolve the   *\n*   real resource names later on.                                   *\n         ST    R10,R10SAVE             Save ourselves a work register\n         L     R10,RESSAV              ->Resource save table\n         LA    R14,VPTHDNAM            ->Destination name\n         STCM  R14,B'1111',6(R10)\n         MVC   VPTHDNAM(8),=CL8'Unknown '\n         MVC   0(4,R10),VPTHDSAF       Save dest.sub-area\n         MVC   4(2,R10),VPTHDEF        Save dest.element\n         LA    R10,10(,R10)            ->Next entry\n         LA    R14,VPTHONAM            ->Origin name\n         STCM  R14,B'1111',6(R10)\n         MVC   VPTHONAM(8),=CL8'Unknown '\n         MVC   0(4,R10),VPTHOSAF       Save origin.sub-area\n         MVC   4(2,R10),VPTHOEF        Save origin.element\n         LA    R10,10(,R10)            ->Next entry\n         XC    0(20,R10),0(R10)        Clear last entry\n         ST    R10,RESSAV              Save for next time thru\n         L     R10,R10SAVE             restore register contents\n         LA    R9,LTSSAVE(,R9)         ->Next save area\n         C     R9,VTSEND               Any more room ?\n         BNL   CNTTSCB                 (No )\n         L     AR5,TSCNEXT(,AR5)       ->Next TSCB\n         LTR   AR5,AR5                 Another TSCB?\n         BNZ   NEXTTSCB                (Yes)\n         B     ENDTSCB\nCNTTSCB  L     AR5,TSCNEXT(,AR5)       ->Next TSCB\n         LTR   AR5,AR5                 Another TSCB?\n         BZ    ENDTSCB                 (No )\n         AP    QDEPTH(3),=PL3'1'       Count 1 TSCB\n         B     CNTTSCB\nENDTSCB  ZAP   DOUBLE(8),QDEPTH(3)     Make qdepth into a double word\n         CVB   R1,DOUBLE               Make qdepth binary\n         STH   R1,VTTSCBD              Save TSCB queue depth\n*   We have an ACTIVE, but NOT OPEN route. Store some information:- *\n*   From the HSQH:     The type of waiting resource (APPL etc)      *\n*                      The name of the resource                     *\nDOHSQH   LA    R9,VPHSQH           ->HSQH saved data\n         USING VHSDATA,R9          Address record layout\n         LA    R1,LHSQHS(,R9)      End of area pointer\n         ST    R1,VTSEND           Save for comparison later\n         ZAP   QDEPTH(3),=PL3'0'   Depth of HSQH chain\n         L     AR5,VRBSESSQ(,AR4)  ->First HSQH\n         LTR   AR5,AR5             Is there an HSQH ?\n         BZ    ENDHSQH             (No )-Go finish up\nNEXTHSQH MVC   HSQNEXT(4),HSQCHAIN(AR5)  Save pointer to next HSQH\n         LA    R15,7               Number of entries to test\nFINDHSQH LA    AR5,4(,AR5)         Next HSQH in control block\n         TM    0(AR5),X'80'        Is this HSQH waiting ?\n         BZ    NOTWAIT             (No )-ignore the entry\n         AP    QDEPTH(3),=PL3'1'   Count 1 entry on hold queue\n         L     AR6,0(,AR5)         ->??NCB\n         CLI   0(AR6),FMCB         Is this an FMCB ?\n         BNE   TSTFMCB             (No )-check ICNCB\n*   Waiting item is an FMCB, extract the ACDEB address and copy     *\n*   the name of the application.                                    *\n         MVI   VHSTYPE,FMCB               Move in control type\n         MVC   VHSPSA,FMCPCSA+TSPSPSA(AR6) Move partner sub-area\n         MVC   VHSPEA,FMCPCSA+TSPSPEA(AR6) Move partner element addr\n*   Save partner sub-area/element address so we can resolve them    *\n*   into a resource name later.                                     *\n         L     AR6,FMCPSSA+TSPDEBA(,AR6)  ->ACDEB\n         MVC   VHSNAME,ACDUNTNM(AR6)      Move application name\n         B     UNKNCB                     Return to mainline\nTSTFMCB  CLI   0(AR6),ICNCB        Is this an ICNCB?\n         BNE   TSTICNCM            (No )-check LDNCB\n*   Waiting item is an ICNCB, extract the unit name.                *\n         MVI   VHSTYPE,ICNCB              Move in control type\n         L     AR6,NCBRDTE(,AR6)          ->RDT entry\n         MVC   VHSNAME(8),RPRNAME(AR6)    Move the unit name\n         B     UNKNCB                     Return to mainline\nTSTICNCM CLI   0(AR6),LDNCB        Is this an LDNCB?\n         BNE   TSTLDNCM            (No )-Can't format, so save ptrs\n*   Waiting item is an LDNCB, extract the unit name.                *\n         MVI   VHSTYPE,LDNCB              Move in control type\n         L     AR6,NCBRDTE(,AR6)          ->RDT entry\n         MVC   VHSNAME(8),RPRNAME(AR6)    Move the unit name\n         B     UNKNCB                     Return to mainline\n*   Unknown control type, save type byte and HSQH pointer           *\nTSTLDNCM MVC   VHSTYPE(1),0(AR6)          Move in control type\n         STCM  AR6,B'1111',VHSNAME        Save pointer to HSQH entry\n         B     UNKNCB                     Return to mainline\nUNKNCB   LA    R9,LHQSAVE(,R9)     ->Next save area\n         C     R9,VTSEND           Any more room ?\n         BNL   CNTHSQH             (No )-Just count entries\nNOTWAIT  BCT   R15,FINDHSQH        Loop through next entry\n         L     AR5,HSQNEXT         Load pointer to next in queue\n         LTR   AR5,AR5             Any left to do ?\n         BNZ   NEXTHSQH            (Yes)-Go scan that one then\n         B     ENDHSQH             Start at end of loop\n*   We've saved 5 entries, so now we just count held HSQH entries.  *\nCNTNHSQH MVC   HSQNEXT(4),HSQCHAIN(AR5)  Save pointer to next HSQH\n         LA    R15,7               Number of entries to test\nCNTWHSQH LA    AR5,4(,AR5)         Next HSQH in control block\n         TM    0(AR5),X'80'        Is this HSQH waiting ?\n         BZ    CNTHSQH             (No )-bypass accumulation\n         AP    QDEPTH(3),=PL3'1'   Count 1 entry on hold queue\nCNTHSQH  BCT   R15,CNTWHSQH        Loop through next entry\n         L     AR5,HSQNEXT         Load pointer to next in queue\n         LTR   AR5,AR5             Any left to do ?\n         BNZ   CNTNHSQH            (Yes)-Go scan that one then\n         B     ENDHSQH             (no )-Save hold queue length\n*   End of HSQH chain, save count of held HSQH's                    *\nENDHSQH  ZAP   DOUBLE(8),QDEPTH(3) Make qdepth into a double word\n         CVB   R1,DOUBLE           Make qdepth binary\n         STH   R1,VTHSQHD          Save HSCB held entry count\nVRBNOACT LA    R8,LTPSAVE(,R8)     ->Next entry in table\n         LA    AR4,32(,AR4)        Next path entry\n         LA    R1,VTPEND           ->End of path entries\n         CR    R8,R1               Have we finished ?\n         BL    VRBNXTTP            (No )-Do next priority\n         LA    R7,LSAVE(,R7)       ->Next save area in table\n         MVI   0(R7),X'FF'         Flag new end of table\n         C     R7,STOREND          Have we bust the buffer ?\n         BH    VRBDONE             (Yes)-terminate scan\n*   We may have a list of addresses to resolve. Do it now, while    *\n*   we have some registers to play with. (As we are about to start  *\n*   the loop again, we have      AR4, AR5, AR6, R8, R9,     R14,    *\n*   R15 all free).                                                  *\nSIBSCAN  L     AR4,X'408'                    ->ATCVT\n         L     AR4,ATCSIBQ(,AR4)             ->SIB chain\n         B     *+8                           Skip into loop\nSIBNEXT  L     AR4,SIBBFWD(,AR4)             ->To next SIB in chain\n         LTR   AR4,AR4                       Any more in chain ?\n         BZ    SIBDONE                       (No )-Just drop out\n         LA    R8,RESTAB                     Table to be searched\n         CLC   0(4,R8),=F'0'                 are there any entries ?\n         BE    SIBDONE                       (No )-bypass scan\n         B     *+8                           Branch into loop\nSIBNADDR LA    R8,10(,R8)                    ->Next address\n         CLC   0(4,R8),=F'0'                 End of search table ?\n         BE    SIBNEXT                       (Yes)-Do next SIB\n         CLC   0(6,R8),SIBDLU+SIBRNETA(AR4)  Is this our Dest?\n         BE    SIBCOPYD                      (Yes)-copy resource name\n         CLC   0(6,R8),SIBOLU+SIBRNETA(AR4)  Is it our origin then?\n         BNE   SIBNADDR                      (No )-do next in list\n         ICM   R9,B'1111',6(R8)              Move resource name :-\n         MVC   0(8,R9),SIBOLU+SIBRALNM(AR4)\n         B     SIBNADDR\nSIBCOPYD ICM   R9,B'1111',6(R8)              Move resource name :-\n         MVC   0(8,R9),SIBDLU+SIBRALNM(AR4)\n         B     SIBNADDR\n*   End of CIB scan, check if we have another VR to process.        *\nSIBDONE  L     AR3,VRBFXCHN(,AR3)  ->Next VRBLK for this SA\n         LTR   AR3,AR3             Is there another Virtual Route?\n         BNZ   VRBNXTVR            (Yes)-Go check it\nNOVRBLK  LA    AR2,4(,AR2)         ->Next VRBLK address\n         LH    R9,THISSUB          Load subarea number\n         LA    R9,1(,R9)           Next subarea number\n         STH   R9,THISSUB          and save count back\n         LH    R9,NUMSA            Load subarea counter\n         BCT   R9,VRBNXTSA         Loop till all subareas scanned\n         DROP  R7\n         DROP  R8\n***         WARNING  --  WARNING  --  WARNING  --  WARNING        ***\n*                   Out of cross memory mode                        *\nVRBDONE  SAC   0                   Cancel cross memory mode\n         EPAR  R2                  Get our ASID back\n         SSAR  R2                  and reset secondary address space\n         LAM   0,15,KILLALET       Reset all ALETS to our addrspc\n         MODESET KEY=NZERO         Exit from supervisor mode\n         BR    R10                 and return to caller\n*                Print the results of the scan                      *\nPUTTABLE L     R7,STORADR          ->Results of the scan\n         USING VTDATA,R7\n         USING VPDATA,R8\n         #AMODE 24                 Go 24 bit addressing for TPUT\n         XC    FORMATF,FORMATF     Clear format flag\nPUTSTART CLI   0(R7),X'FF'         End of table ?\n         BE    PUTEND              (Yes)-Exit\n*   Do not format messages for our sub-area                         *\n         CLC   VTSUBA(2),HOSTSA+2  Our sub-area ?\n         BE    PUTBYPAS            (Yes)-bypass print\n*   FORMAT stored information                                       *\n         LA    R8,VTP0             ->Priority 0 stuff\n         BAL   R6,FORMATE          Format this entry\n         LA    R8,VTP1             ->Priority 1 stuff\n         BAL   R6,FORMATE          Format this entry\n         LA    R8,VTP2             ->Priority 2 stuff\n         BAL   R6,FORMATE          Format this entry\nPUTBYPAS LA    R7,LSAVE(,R7)       ->Next subarea entry\n         B     PUTSTART            and loop\nPUTEND   #AMODE 31                 Reset to callers mode\n         BR    R10                 and return to caller\n*                Format an exception entry                          *\nFORMATE  TM    SHOWFLAG,SHOWALL    Are we displaying all VRs ?\n         BO    DOFMT               (Yes)-Go start display\n         CLI   VPSTATE,VRBVRFAC    Is this an active route ?\n         BNE   NOFMT               (No )-Ignore entry\n         TM    VPFCFSM,VRBFCFOP    Is it open ?\n         BO    NOFMT               (Yes)-Ignore entry\n         TM    SHOWFLAG,SHOWNOPN   Are we displaying all blocked VRs?\n         BO    DOFMT               (Yes)-Go start display\n         CLC   VTHSQHD,=H'0'       Is anyone queued ?\n         BE    NOFMT               (No )-Ignore entry\nDOFMT    OI    FORMATF,FMTPRT      Flag an entry has bee printed\n         TM    FORMATF,FMTHDR      Have we printed the headings ?\n         BO    DONEHDR1            (Yes)-do not do it again\n         OI    FORMATF,FMTHDR      Flag headers produced\n         UNPK  FCFSMS(5),CDATE(4)  Unpack Date\n         UNPK  VSTAT(8),CTIME(4)   Unpack Time\n         MVC   VSTAT(2),VSTAT+2    hh\n         MVC   VSTAT+3(2),VSTAT+4  mm\n         MVI   VSTAT+2,C':'\n         MVI   VSTAT+5,C':'\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=800\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=2,                           *\n               FIELDS=(FCFSMS,5,CHAR,VSTAT,8,CHAR)\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=3\nDONEHDR1 XR    R9,R9               Clear work register\n         IC    R9,VPFCFSM          Insert FCFSM flag\n         N     R9,=F'3'            Isolate the bits we want\n         SLL   R9,3                Status number * 8\n         LA    R9,FCFSM(R9)        Point to table\n         MVC   FCFSMS(8),0(R9)     Save status\n         XR    R9,R9               Clear work register\n         IC    R9,VPSTATE          Insert FCFSM flag\n         N     R9,=F'7'            Isolate the bits we want\n         SLL   R9,3                Status number * 8\n         LA    R9,STATUS(R9)       Point to table\n         MVC   VSTAT(8),0(R9)      Save status\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=5,                          **\n               FIELDS=(VTSUBA,2,BINH,     Sub-area                    **\n               VTVRNO,2,BINH,             Virtual route number        **\n               =C'01',2,CHAR,             Path 0                      **\n               VTASUBA,2,BINH,            Adjacent sub-area           **\n               VSTAT,8,CHAR,              VR_state                    **\n               FCFSMS,8,CHAR,             VR-FSM                      **\n               VPMINW,3,BINH,             Window minimum size         **\n               VPACTW,3,BINH,             Window maximum size         **\n               VPMAXW,3,BINH,             Window actual  size         **\n               VPSESS,5,BINH,             Number of sessions          **\n               VTTSCBD,4,BINH,            TSCB chain queue depth      **\n               VTHSQHD,4,BINH)            HSQH entries held\n*   Format the TH/RH/RU data elements                               *\n         LA    R9,VPTSCB           ->Saved TSCB data\n         USING VTSDATA,R9          Address record layout\n         LA    R2,5                Format 5 entries\nFMTNEXT  CLC   VPTHDSAF,=F'0'      Is there any data ?\n         BE    NODEST              (No )\n*--------------------------------- Determine RU category -------------*\n         MVC   DOUBLE(1),VPRH      Move RU category byte to work area\n         NI    DOUBLE,255-X'9F'    Mask non-category bits\n         MVC   OPRCMD(4),=C'FMD '  Assume FMData:-\n         L     R3,=A(YJP$FMD)\n         LA    R4,3\n         CLI   DOUBLE,X'00'        FMD?\n         BE    FINDRU              (Yes)\n         MVC   OPRCMD(4),=C'NC  '  Assume Network Control\n         L     R3,=A(YJP$NC)\n         LA    R4,1\n         CLI   DOUBLE,X'20'        NC?\n         BE    FINDRU              (Yes)\n         MVC   OPRCMD(4),=C'DFC '  Assume Data Flow Control :-\n         L     R3,=A(YJP$DFC)\n         LA    R4,1\n         CLI   DOUBLE,X'40'        DFC?\n         BE    FINDRU              (Yes)\n         MVC   OPRCMD(4),=C'SC  '  Must be Session Control :-\n         L     R3,=A(YJP$SC)\n         LA    R4,1\n*--------------------------------- Format RU description if found ----*\nFINDRU   LA    R1,VPRU             ->RU data\n         B     *+8\nNEXTRU   LA    R3,20(,R3)          ->Next entry in lookup table\n         CLC   0(3,R3),=X'FFFFFF'  End of lookup table ?\n         BE    UNKRU               (Yes)-Format unknown\n         LR    R15,R4              Move key length to work register\n         BCT   R15,*+10\n         CLC   0(*-*,R3),0(R1) Do keys match ?\n         EX    R15,*-6\n         BNE   NEXTRU              (No )-keep looking\nUNKRU    MVC   OPRCMD+4(17),3(R3)  Move command type to message area\n         TM    FORMATF,FMTHDR2     Have we printed the headings ?\n         BO    DONEHDR2            (Yes)-do not do it again\n         OI    FORMATF,FMTHDR2     Flag headers produced\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=800\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=6\nDONEHDR2 $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=7,                          **\n               FIELDS=(VPTHDSAF+2,2,HEX,  Destination subarea         **\n               VPTHDEF,2,HEX,             Destination element         **\n               VPTHDNAM,8,CHAR,           Destination name            **\n               VPTHOSAF+2,2,HEX,          Origin subarea              **\n               VPTHOEF,2,HEX,             Origin element              **\n               VPTHONAM,8,CHAR,           Origin name                 **\n               VPRU,16,HEX,               16 bytes of RU data         **\n               OPRCMD,21,CHAR)            RU type\n         LA    R9,LTSSAVE(,R9)     ->Next entry\n         BCT   R2,FMTNEXT          and try again\n*   Format the HQSH data elements                                   *\nNODEST   NI    FORMATF,X'FF'-FMTHDR2  Reset headers printed flag\n         LA    R9,VPHSQH           ->Saved HSQH data\n         USING VHSDATA,R9          Address record layout\n         LA    R2,5                Format 5 entries\nFMTHSQH  CLI   VHSTYPE,X'00'       Is there any data ?\n         BE    NOFMT               (No )\n         TM    FORMATF,FMTHDR2     Have we printed the headings ?\n         BO    DONEHDR3            (Yes)-do not do it again\n         OI    FORMATF,FMTHDR2     Flag headers produced\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=800\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=8\nDONEHDR3 CLI   VHSTYPE,FMCB\n         BNE   CHKICNCB\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=11,  Format FMCB            **\n               FIELDS=(=C'FMCB ',5,CHAR,       Record type (Desc)     **\n               VHSTYPE,1,HEX,                  Record type (Num)      **\n               VHSNAME,8,CHAR,                 Resource name          **\n               VHSPSA,4,HEX,                   Partner subarea        **\n               VHSPEA,2,HEX)                   Partner element\n         B     FMTNHSQH\nCHKICNCB CLI   VHSTYPE,ICNCB\n         BNE   CHKLDNCB\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=9,   Format LDNCB           **\n               FIELDS=(=C'ICNCB ',5,CHAR,      Record type (Desc)     **\n               VHSTYPE,1,HEX,                  Record type (Num)      **\n               VHSNAME,8,CHAR)                 Resource name\n         B     FMTNHSQH\nCHKLDNCB CLI   VHSTYPE,LDNCB\n         BNE   UNKNCB2\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=9,   Format LDNCB           **\n               FIELDS=(=C'LDNCB ',5,CHAR,      Record type (Desc)     **\n               VHSTYPE,1,HEX,                  Record type (Num)      **\n               VHSNAME,8,CHAR)                 Resource name\n         B     FMTNHSQH\nUNKNCB2  $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=10,  Unknown HSQH type      **\n               FIELDS=(VHSTYPE,1,HEX,          Record type            **\n               VHSNAME,4,HEX)                  HSQH address\n         B     FMTNHSQH\nFMTNHSQH LA    R9,LHQSAVE(,R9)            ->Next entry\n         BCT   R2,FMTHSQH                 and try again\nNOFMT    NI    FORMATF,X'FF'-FMTHDR2      Reset headers printed flag\n         BR    R6                         Return to scan routine\n         DROP  R7\n         DROP  R8\n*                1) Wait for a period of time (default=5secs) then  *\n*                   return to the mainline to perform the next scan.*\n*                2) Process any Operator commands sent via the      *\n*                   Stop/Modify interface.                          *\nWAIT     #AMODE 24\n         STIMER REAL,TIMERP,DINTVL=TIMER\n         WAIT ECBLIST=ECBLIST      Wait for timer/modify\n         #AMODE 31\n         TM    TIMERECB,X'40'      Was the timer posted ?\n         BZ    STOPMDFY            (No )-Must be stop/modify\n         XC    TIMERECB,TIMERECB\n         BR    R10                 Return to caller\n*   Someone knocked, let's see what they want....                   *\n         USING CIBNEXT,R2          (Command Input Area)\n         USING COMLIST,R3          (Command Area)\nSTOPMDFY L     R3,COMMAREA         ->Communications area\n         L     R2,COMCIBPT         ->CIB\n         CLI   CIBVERB,CIBSTOP     Was it a stop command ?\n         BE    ENDPRG              (Yes)-terminate processing\n         CLI   CIBVERB,CIBMODFY    Was it a modify command ?\n         BNE   ENDPRG2             (No )-Don't know what it was then!\n         MVI   OPRCMD,C' '         Blank out command save area :-\n         MVC   OPRCMD+1(79),OPRCMD\n         LA    R4,CIBDATA          ->Data buffer\n         LH    R5,CIBDATLN         Load data length\n         CH    R5,=H'80'           Limit buffer size to 80 bytes:-\n         BL    *+8\n         LA    R5,80\n         BCT   R5,*+10             Length -1\n         MVC   OPRCMD(*-*),0(R4)   Executed move\n         EX    R5,*-6              Move data to save area\n         QEDIT ORIGIN=COMCIBPT,    Dequeue this CIB, ready for next    *\n               BLOCK=(2)\n*   OPRCMD contains up to 80 bytes of the text of the MODIFY        *\n*   command. Determine if it's a command we can process.            *\n         CLC   =C'INTERVAL=',OPRCMD   Set interval command ?\n         BE    CMDINT                 (Yes)\n         CLC   =C'QUERY',OPRCMD       Query stats ?\n         BE    CMDQUERY               (Yes)\n         CLC   =C'SHOW ALL',OPRCMD    Show all virtual routes ?\n         BE    CMDSALL                (Yes)\n         CLC   =C'SHOW HELD',OPRCMD   Show Held Virtual Routes ?\n         BE    CMDSHELD               (Yes)\n         CLC   =C'SHOW NOPEN',OPRCMD  Show Not Open Virtual Routes?\n         BE    CMDSNOPN               (Yes)\n         CLC   =C'STOP',OPRCMD        Stop request ?\n         BE    ENDPRG                 (Yes)\n         CLC   =C'HELP',OPRCMD        Help request ?\n         BE    CMDHELP                (Yes)\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=200,                         *\n               FIELDS=(OPRCMD,20,CHAR)\n         B     CMDHELP                Go display help screen\n*   COMMAND:   INTERVAL=hhmmss                                      *\n*   FUNCTION:  To change the time interval between VR scans         *\n*   PARAMETER: The command expects to be given a new timer value    *\n*              in the format:                                       *\n*                        HHMMSS                                     *\n*              All six digits must be entered. Validation consists  *\n*              of checking:                                         *\n*              a) 6 digit numeric value                             *\n*              b) HH   -    Between  00 and 23                      *\n*              c) MM   -    Between  00 and 59                      *\n*              d) SS   -    Between  00 and 59                      *\n*              e) The time value is greater than 4 seconds          *\nCMDINT   LA    R2,OPRCMD+9         ->New time value\n         LA    R4,TI1              Preset error reason\n         SH    R5,=H'8'            Less length of keyword\n         CH    R5,=H'6'            Are there more than 6 chars left\n         BNE   INVINT              (Yes)-Invalid\n         LA    R4,TI2              Preset error reason\nCHKNUM   TM    0(R2),X'F0'         Is it a number ?\n         BNO   INVINT              No - its invalid\n         LA    R2,1(,R2)           ->next character\n         BCT   R5,CHKNUM           Keep checking\n         PACK  DOUBLE(2),OPRCMD+9(2)     Pack hours\n         PACK  DOUBLE+2(2),OPRCMD+11(2)  Pack minutes\n         PACK  DOUBLE+4(2),OPRCMD+13(2)  Pack Seconds\n         LA    R4,TI3              Preset error reason\n         CP    DOUBLE(2),=PL2'24'  Less than 24 hours ?\n         BNL   INVINT              (No )-invalid\n         LA    R4,TI4              Preset error reason\n         CP    DOUBLE+2(2),=PL2'60' Less than 60 minutes ?\n         BNL   INVINT              (No )-Invalid\n         LA    R4,TI5              Preset error reason\n         CP    DOUBLE+4(2),=PL2'60' Less than 60 seconds ?\n         BNL   INVINT              (No )-Invalid\n         CP    DOUBLE(2),=PL2'0'   Any hours specified ?\n         BH    CHKTIME             (Yes)-Were OK\n         CP    DOUBLE+2(2),=PL2'0' Any minutes specified ?\n         BH    CHKTIME             (Yes)-Were OK\n         LA    R4,TI6              Preset error reason\n         CP    DOUBLE+4(2),=PL2'4' More than 4 seconds specified?\n         BNH   INVINT              (No )-Zero time specified\nCHKTIME  MVC   TIMER(6),OPRCMD+9   Move new timer value\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=201,                         *\n               FIELDS=(TIMER,6,CHAR)\n         B     WAIT                Return to wait loop\nINVINT   $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=202,  Time invalid message   *\n               FIELDS=(OPRCMD+9,6,CHAR,0(R4),20,CHAR)\n         B     WAIT                Return to wait loop\n*   COMMAND:   QUERY                                                *\n*   FUNCTION:  To display the program status                        *\n*   PARAMETER: None                                                 *\n*              Currently displays the timer value and the current   *\n*              setting of the \"SHOWFLAG\" flag.                      *\nCMDQUERY $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=203,                         *\n               FIELDS=(TIMER,6,CHAR)\n         LA    R2,DISALL           Assume all VRs\n         TM    SHOWFLAG,SHOWALL    Are we showing all virtual routes ?\n         BO    STATMSG             (Yes)\n         LA    R2,DISHELD          Assume VRs with HSQH chain\n         TM    SHOWFLAG,SHOWHELD   Are we showing Not-Open, with HSQHs?\n         BO    STATMSG             (Yes)\n         LA    R2,DISNOPN\nSTATMSG  $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=208,  Show display type      *\n               FIELDS=(0(R2),25,CHAR)\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=209,  Show host SA           *\n               FIELDS=(HOSTSA+2,3,BINH)\n         B     WAIT                Return to wait loop\n*   COMMAND:   SHOW                                                 *\n*   FUNCTION:  To alter which statistics are displayed              *\n*   PARAMETER: ALL   - Show all virtual routes regardless of status *\n*              HELD  - Show only \"not open\" routes which have an    *\n*                      HSQH chained off them.                       *\n*              NOPEN - Show \"not open\" routes even if they do not   *\n*                      have an HQSH chain.                          *\nCMDSALL  MVI   SHOWFLAG,SHOWALL\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=205\n         B     WAIT                              Return to wait loop\nCMDSHELD MVI   SHOWFLAG,SHOWHELD\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=206\n         B     WAIT                              Return to wait loop\nCMDSNOPN MVI   SHOWFLAG,SHOWNOPN\n         $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=207\n         B     WAIT                              Return to wait loop\n*   COMMAND:   HELP                                                  *\n*   FUNCTION:  To display command options                            *\n*   PARAMETER: None                                                  *\n*   NOTE: This routine is also entered if an invalid command is given*\nCMDHELP  LA    R2,HELP1                           ->Help text\n         LA    R3,NHELP                          Number of lines\nHELPMSGS $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=801,                         *\n               FIELDS=(0(R2),L'HELP1,CHAR)\n         LA    R2,L'HELP1(,R2)                   ->Next message\n         BCT   R3,HELPMSGS                       Keep displaying\n         B     WAIT                              Return to wait loop\n*   COMMAND:   STOP                                                 *\n*   FUNCTION:  To end of monitor                                    *\n*   PARAMETER: None                                                 *\nENDPRG   $MSG  TABLE=MSGSECT,TYPE=WTO,MSG=204\nENDPRG2  LA    R10,4(,R10)         Return 4 bytes on from\n         BR    R10                    the calling address\n         DROP  R2\n         DROP  R3\n*                Release working storage used for data table        *\nKILLSTOR LM    R0,R1,STORLEN       Reload storage size/address\n         FREEMAIN R,LV=(0),A=(1)   Free up storage\n         BR    R10\n*                Reset the XMEMORY authorization index              *\nKILLAUTH MODESET MODE=SUP          Supervisor state for AXSET\n         AXSET AX=AXSAVE           Reset authorization index value\n         MODESET MODE=PROB         Back to problem state\n         BR      R10               Return to caller\n*         EXIT : TIMERP                                             *\n*                This routine will be entered when the STIMER       *\n*                expires. It will post the timer ECB and return.    *\n         USING *,R15\nTIMERP   LA    R2,TIMERECB         Address timer ECB\n         POST  (R2)                Flag timer complete\n         BR    R14                 Return to caller\n         DROP  R15\n*   STATIC STORAGE                                                  *\nSETALET  DC    F'0'                AR0  ALET - Our address space\n         DC    F'0'                AR1  ALET - Our address space\n         DC    F'1'                AR2  ALET - VTAM address space\n         DC    F'1'                AR3  ALET - VTAM address space\n         DC    F'1'                AR4  ALET - VTAM address space\n         DC    F'1'                AR5  ALET - VTAM address space\n         DC    F'1'                AR6  ALET - VTAM address space\n         DC    F'0'                AR7  ALET - Our address space\n         DC    F'0'                AR8  ALET - Our address space\n         DC    F'0'                AR9  ALET - Our address space\n         DC    F'0'                AR10 ALET - Our address space\n         DC    F'0'                AR11 ALET - Our address space\n         DC    F'0'                AR12 ALET - Our address space\n         DC    F'0'                AR13 ALET - Our address space\n         DC    F'0'                AR14 ALET - Our address space\n         DC    F'0'                AR15 ALET - Our address space\nKILLALET DC    F'0'                AR0  ALET - Our address space\n         DC    F'0'                AR1  ALET - Our address space\n         DC    F'0'                AR2  ALET - Our address space\n         DC    F'0'                AR3  ALET - Our address space\n         DC    F'0'                AR4  ALET - Our address space\n         DC    F'0'                AR5  ALET - Our address space\n         DC    F'0'                AR6  ALET - Our address space\n         DC    F'0'                AR7  ALET - Our address space\n         DC    F'0'                AR8  ALET - Our address space\n         DC    F'0'                AR9  ALET - Our address space\n         DC    F'0'                AR10 ALET - Our address space\n         DC    F'0'                AR11 ALET - Our address space\n         DC    F'0'                AR12 ALET - Our address space\n         DC    F'0'                AR13 ALET - Our address space\n         DC    F'0'                AR14 ALET - Our address space\n         DC    F'0'                AR15 ALET - Our address space\nR10SAVE  DC    F'0'                Ran out of registers\nTI1      DC    CL20'Incorrect length'   Timer value invalid reasons\nTI2      DC    CL20'Not 6 numerics  '\nTI3      DC    CL20'Hours invalid   '\nTI4      DC    CL20'Minutes invalid '\nTI5      DC    CL20'Seconds invalid '\nTI6      DC    CL20'Less than 5 seconds'\nDISALL   DC    CL25'ALL '\nDISHELD  DC    CL25'Not-open with HSQH chain'\nDISNOPN  DC    CL25'All which are NOT Open  '\nSTATUS   DC    CL8'Reset   '       VRBVRFSM     0\n         DC    CL8'Inactive'                    1\n         DC    CL8'Pnd.Inac'                    2\n         DC    CL8'Flush   '                    3\n         DC    CL8'Pnd.Acti'                    4\n         DC    CL8'Active  '                    5\n         DC    CL8'DACTVR  '                    6\nFCFSM    DC    CL8'Blocked '       VRBFCFSM  x'00'\n         DC    CL8'Blocked '                 x'01'\n         DC    CL8'Held    '                 x'02'\n         DC    CL8'Open    '                 x'03'\nHELP1    DC    CL50'Command formats: '\n         DC    CL50' '\n         DC    CL50'  HELP        - Display this help              '\n         DC    CL50'  QUERY       - Display monitor status         '\n         DC    CL50'  SHOW ALL    - Display all virtual routes     '\n         DC    CL50'  SHOW HELD   - Display not open VRs with HSQHs'\n         DC    CL50'  SHOW NOPEN  - Display all not open VRs       '\n         DC    CL50'  INTERVAL=hhmmss   Set the sampling interval  '\n         DC    CL50'  STOP        - Terminate virtual route monitor'\n         DC    CL50' '\nNHELP    EQU   (*-HELP1)/L'HELP1\nATCVTV   DC    C'VT32'\nMFLEXT   EXTRACT COMMAREA,FIELDS=(COMM),MF=L\nCOMMAREA DS    D                   Communications area for QEDIT\nECBLIST  DS    0F                  ECB's\nECBQEDIT DS    F     )Do Not       Stop/Modify ECB\nECBTIMER DS    F     )Separate     Timer ECB\nTIMERECB DS    F'0'                Timer ECB\n         LTORG ,\n*   DYNAMIC STORAGE - allocated at startup by #LINKAGE              *\n         #LINKAGE DSASTART\nDOUBLE   DS    D                   Double word work area\nTIMER    DS    D                   Time period between checks\nFCFSMS   DS    CL8                 Finite state work area\nVSTAT    DS    CL8                 Virtual Route status work area\nCDATE    DS    F                   Date when VR scan starts\nCTIME    DS    F                   Time when VR scan starts\nSTORLEN  DS    F     )Do           Length of getmained storage\nSTORADR  DS    F     )Not          Address of getmained storage\nSTOREND  DS    F     )Separate     End of getmained storage\nVTSEND   DS    F                   End of TH/RU save area\nHSQNEXT  DS    F                   ->Next HSQH control block\nHOSTSA   DS    F                   Host sub-area number\nHOSTE    DS    H                   Host element\nASIDMINE DS    H                   ASID of my address space\nASIDSAVE DS    H                   ASID of the VTAM job\nAXSAVE   DS    H                   Current authorization index\nAXSET1   DS    H                   Authorization index of 1\nTHISSUB  DS    H                   Currently processing subarea\nNUMSA    DS    H                   Number of subareas to scan\nFORMATF  DS    X                   Print formatting flag :-\nFMTHDR   EQU   X'80'                 Headings have been displayed\nFMTHDR2  EQU   X'40'                 Sub-section headings produced.\nFMTPRT   EQU   X'20'                 One or more entries listed\nSHOWFLAG DS    X                   VR display control flag :-\nSHOWALL  EQU   X'80'                 Always display virtual route\nSHOWHELD EQU   X'40'                 Display VRs with HSQH chain\nSHOWNOPN EQU   X'20'                 Display all not open VRs\nQDEPTH   DS    PL3                 TSCB and HSQH chain depths\nOPRCMD   DS    CL80                Stop/Modify data save buffer\nRESSAV   DS    A                   Offset into RESTAB\nRESTAB   DS    16XL20              #tp * #HSQH + 1 (3*15)+1\n         #LINKAGE DSAEND\n*   MAPPING MACROS AND EQUATES                                      *\n*                               OFFSETS INTO ATCVT :-\nATCSTAT  EQU   X'42C'              VTAM status byte 1\nATCACTIV EQU   X'40'               VTAM is active flag\nATCSIBQ  EQU   X'3F8'              CIB queue pointer\nATCHOSTA EQU   X'438'              Host sub-area number\nATCHOSTE EQU   X'43C'              Host element number\nATCMAXID EQU   X'481'              Maximum sub-areas\nATCVRNDX EQU   X'5EC'              ->VRtable anchors\nATCASID  EQU   X'68A'              VTAM ASID\n*                               OFFSETS INTO VRBLK :-\nVRBVRN   EQU   X'02'               Virtual route number\nVRBFXCHN EQU   X'04'               ->Next VRBLK for this subarea\nVRBADJSA EQU   X'08'               Adjacent subarea number\nVRBFSTS  EQU   X'40'               Offset - Transmission Priorities\nVRBDSTSA EQU   X'A4'               Destination subarea number\n*                               OFFSETS INTO PATH INFO VRBIBASE:-\nVRBVRFSM EQU   X'00'               Virtual route state\nVRBPRI   EQU   X'01'               Flow control finite state\nVRBPALIM EQU   X'03'               Actual window size\nVRBSESSQ EQU   X'04'               ->HSQH chain\nVRBRHOLD EQU   X'08'               ->TSCB on hold queue\nVRBSECNT EQU   X'0C'               Session count\nVRBMINWS EQU   X'18'               Window minimum size\nVRBMAXWS EQU   X'19'               Window maximum size\n*                               STATUS FLAGS FOR PRIORITY INFO :-\nVRBVRFAC EQU   X'05'               TP is ACTIVE\nVRBFCFOP EQU   X'03'               TP is OPEN\n*                               OFFSETS INTO TSCB/Transmission Header\nTSCNEXT  EQU   X'04'               ->Next TSCB (if any)\nTSCTH4   EQU   X'27'               Transmission Header offset\nTSCRU    EQU   X'44'               RU contents\nTH4DSAF  EQU   X'08'               Destination subarea\nTH4OSAF  EQU   X'0C'               Origin subarea\nTH4DEF   EQU   X'12'               Destination element\nTH4OEF   EQU   X'14'               Origin element\nTSCRH    EQU   X'41'               Offset to RH data in TSCB\nRHF0     EQU   X'00'               RH flag bits\n*                               OFFSETS for HSQH/NCB/FMCB data\nHSQCHAIN EQU   X'00'               ->next HSQH in chain\nFMCPSSA  EQU   X'84'               Offset to PSSA section of FMCB\nTSPDEBA  EQU   X'00'                 Offset in PSSA to ACDEB pointer\nACDUNTNM EQU   X'78'                 Offset to application in ACDEB\nFMCPCSA  EQU   X'48'               Offset to TSPPCSA in FMCB\nTSPSPEA  EQU   X'1A'                 Offset to partner Ele in TSPPCSA\nTSPSPSA  EQU   X'1C'                 Offset to partner SA in TSPPCSA\nNCBUNAME EQU   X'C0'               Offset to unitname in NCB\nNCBRDTE  EQU   X'04'               ->RDT entry in NCB\nRPRNAME  EQU   X'A0'                 Offset into RDT of unit name\nFMCB     EQU   X'03'               NCB type code for FMCB\nICNCB    EQU   X'06'               NCB type code for ICNCB\nLDNCB    EQU   X'07'               NCB type code for LDNCB\n*                               OFFSETS for SIB scan\nSIBBFWD  EQU   X'30'               ->Next CIB in chain\nSIBOLU   EQU   X'88'               Origin entry\nSIBDLU   EQU   X'C0'               Destination entry\nSIBRNETA EQU   X'32'               Network addr in OLU/DLU\nSIBRALNM EQU   X'08'               Resource name in OLU/DLU\n*  Data records are made up of the following structure:               *\n*    VTDATA structure                                                 *\n*     .    Fixed header information                                   *\n*     .    VPDATA structure (priority 0)                              *\n*     .    .   Fixed header information                               *\n*     .    .   VTSDATA structure                                      *\n*     .    .   VHSDATA structure                                      *\n*     .    VPDATA structure (priority 1)                              *\n*     .    .   Fixed header information                               *\n*     .    .   VTSDATA structure                                      *\n*     .    .   VHSDATA structure                                      *\n*     .    VPDATA structure (priority 2)                              *\n*     .    .   Fixed header information                               *\n*     .    .   VTSDATA structure                                      *\n*     .    .   VHSDATA structure                                      *\n*     End of record                                                   *\nVTDATA   DSECT ,                Dsect for extracted data :-\nVTDATE   DS    F                   Date in packed format: 0cyydddf\nVTTIME   DS    F                   Time in format HHMMSSth\nVTSUBA   DS    H                   Current subarea\nVTASUBA  DS    H                   Adjacent subarea\nVTDSUBA  DS    H                   Destination subarea\nVTVRNO   DS    H                   Virtual route number\nVTTSCBD  DS    H                   TSCB queue depth\nVTHSQHD  DS    H                   HSQH held entries\nVTP0     DS    XL315               Priority 0   )\nVTP1     DS    XL315               Priority 1   )-See DSECT VPDATA\nVTP2     DS    XL315               Priority 2   )\nVTPEND   DS    X                   End of priority marker\nLSAVE    EQU   *-VTDATA            Length of save data\nVPDATA   DSECT ,                Dsect for path specific data\nVPFCFSM  DS    X                   Pri/Sec flags and HOLD status\nVPSTATE  DS    X                   Virtual route state\nVPSESS   DS    XL2                 Number of sessions\nVPMINW   DS    XL2                 Minimum window size\nVPMAXW   DS    XL2                 Maximum window size\nVPACTW   DS    XL2                 Actual window size\nVPTSCB   DS    5XL46               Upto 5 TH/RH/RU's (VTSDATA)\nLTSCBS   EQU   *-VPTSCB              Length of TSCB save area\nVPHSQH   DS    5XL15               Upto 5 HSQH's     (VHSDATA)\nLHSQHS   EQU   *-VPHSQH              Length of HSQH save area\nLTPSAVE  EQU   *-VPDATA\nVTSDATA  DSECT ,                Transmission header/RU data :-\nVPTHDSAF DS    XL4                 Destination subarea\nVPTHDEF  DS    XL2                 Destination element field\nVPTHDNAM DS    XL8                 Destination name\nVPTHOSAF DS    XL4                 Origin subarea\nVPTHOEF  DS    XL2                 Origin element field\nVPTHONAM DS    XL8                 Origin name\nVPRH     DS    XL2                 RH data\nVPRU     DS    XL16                16 bytes of RU data\nLTSSAVE  EQU   *-VTSDATA\nVHSDATA  DSECT ,                Half Session Queue header data :-\nVHSTYPE  DS    X                   HSQH type\nVHSNAME  DS    XL8                 Resource name\nVHSPSA   DS    XL4                 FMCB partner subarea address\nVHSPEA   DS    XL2                 FMCB partner element address\nLHQSAVE  EQU   *-VHSDATA\n         CVT   DSECT=YES\n         IEZCIB ,\n         IEZCOM ,\n*        RU TYPE LOOKUP TABLES                                        *\nYJP$FMD  CSECT ,\n         DC    X'010201',C'CONTACT          '\n         DC    X'010202',C'DISCONTACT       '\n         DC    X'010203',C'IPLINIT          '\n         DC    X'010204',C'IPLTEXT          '\n         DC    X'010205',C'IPLFINAL         '\n         DC    X'010206',C'DUMPINIT         '\n         DC    X'010207',C'DUMPTEXT         '\n         DC    X'010208',C'DUMPFINAL        '\n         DC    X'010209',C'RPO              '\n         DC    X'01020A',C'ACTLINK          '\n         DC    X'01020B',C'DACTLINK         '\n         DC    X'01020E',C'CONNOUT          '\n         DC    X'01020F',C'ABCONN           '\n         DC    X'010211',C'SETCV (CONFIG)   '\n         DC    X'010214',C'ESLOW            '\n         DC    X'010215',C'EXSLOW           '\n         DC    X'010216',C'ACTCONNIN        '\n         DC    X'010217',C'DACTCONNIN       '\n         DC    X'010218',C'ABCONNOUT        '\n         DC    X'010219',C'ANA              '\n         DC    X'01021A',C'FNA              '\n         DC    X'01021B',C'REQDISCONT       '\n         DC    X'010280',C'CONTACTED        '\n         DC    X'010281',C'INOP             '\n         DC    X'010284',C'REQCONT          '\n         DC    X'010285',C'NS_LSA           '\n         DC    X'010301',C'EXECTEST         '\n         DC    X'010302',C'ACTTRACE         '\n         DC    X'010303',C'DACTTRACE        '\n         DC    X'010311',C'SETCV (MAINT)    '\n         DC    X'010331',C'DISPSTOR         '\n         DC    X'010334',C'RECSTOR          '\n         DC    X'010380',C'REQTEST          '\n         DC    X'010381',C'RECMS            '\n         DC    X'010382',C'RECTD            '\n         DC    X'010383',C'RECTRD           '\n         DC    X'010604',C'NSPE             '\n         DC    X'010681',C'INIT_SELF (FMT0) '\n         DC    X'010683',C'TERM_SELF (FMT0) '\n         DC    X'410210',C'RNAA             '\n         DC    X'41021C',C'DELETENR         '\n         DC    X'41021D',C'ER_INOP          '\n         DC    X'41021E',C'ADDLINK          '\n         DC    X'410220',C'NOTIFY (SSCP-PU) '\n         DC    X'410221',C'ADDLINKSTA       '\n         DC    X'410223',C'VR_INOP          '\n         DC    X'410235',C'INITPROC         '\n         DC    X'410236',C'PROCSTAT         '\n         DC    X'410237',C'LDREQD           '\n         DC    X'410240',C'REQACTLU         '\n         DC    X'410243',C'NS_IPL_INIT      '\n         DC    X'410244',C'NS_IPL_TEXT      '\n         DC    X'410245',C'NS_IPL_FINAL     '\n         DC    X'410246',C'NS_IPL_ABORT     '\n         DC    X'410286',C'REQFNA           '\n         DC    X'410287',C'LCP              '\n         DC    X'410289',C'ROUTE_INOP       '\n         DC    X'41028A',C'REQACTCDRM       '\n         DC    X'410304',C'REQMS            '\n         DC    X'410305',C'TESTMODE         '\n         DC    X'410307',C'ROUTE_TEST       '\n         DC    X'410384',C'RECFMS           '\n         DC    X'410385',C'RECTR            '\n         DC    X'410386',C'ER_TESTED        '\n         DC    X'41038D',C'NMVT             '\n         DC    X'810381',C'ECHO_CHECK       '\n         DC    X'810387',C'REQECHO          '\n         DC    X'810389',C'ECHOTEST         '\n         DC    X'810601',C'CINIT            '\n         DC    X'810602',C'CTERM            '\n         DC    X'810620',C'NOTIFY SSCP/LU   '\n         DC    X'810629',C'CLEANUP          '\n         DC    X'810680',C'INIT_OTHER       '\n         DC    X'810681',C'INIT_SELF (FMT1) '\n         DC    X'810682',C'TERM_OTHER       '\n         DC    X'810683',C'TERM_SELF (FMT1) '\n         DC    X'810685',C'BINDF            '\n         DC    X'810686',C'SESSST           '\n         DC    X'810687',C'UBINDF           '\n         DC    X'810688',C'SESSEND          '\n         DC    X'810810',C'FORWARD          '\n         DC    X'810812',C'DELIVER          '\n         DC    X'810814',C'CNM CONTROL      '\n         DC    X'818620',C'NOTIFY SSCP/SSCP '\n         DC    X'818627',C'DSRLST           '\n         DC    X'818640',C'INIT_OTHER_CD    '\n         DC    X'818641',C'CDINIT           '\n         DC    X'818642',C'TERM_OTHER_CD    '\n         DC    X'818643',C'CDTERM           '\n         DC    X'818645',C'CDSESSSF         '\n         DC    X'818646',C'CDSESSST         '\n         DC    X'818647',C'CDSESSTF         '\n         DC    X'818648',C'CDSESSEND        '\n         DC    X'818649',C'CDTAKED          '\n         DC    X'81864A',C'CDTAKEDC         '\n         DC    X'81864B',C'CDCINIT          '\n         DC    X'FFFFFF',C'Unknown type     '\nYJP$NC   CSECT ,\n         DC    X'020000',C'NC_IPL_FINAL     '\n         DC    X'030000',C'NC_IPL_INIT      '\n         DC    X'040000',C'NC_IPL_TEXT      '\n         DC    X'050000',C'LSA              '\n         DC    X'060000',C'NC_ER_INOP       '\n         DC    X'070000',C'ANS_COMPLETE     '\n         DC    X'080000',C'LOST_PATH        '\n         DC    X'090000',C'NC_ER_TEST       '\n         DC    X'0A0000',C'NC_ER_TEST_REPLY '\n         DC    X'0B0000',C'NC_ER_ACT        '\n         DC    X'0C0000',C'NC_ER_ACT_REPLY  '\n         DC    X'0D0000',C'NC_ACTVR         '\n         DC    X'0E0000',C'NC_DACTVR        '\n         DC    X'0F0000',C'NC_ER_OP         '\n         DC    X'460000',C'NC_IPL_ABORT     '\n         DC    X'500000',C'NCP_INIT_COMPLETE'\n         DC    X'510000',C'SWITCH_EP/NCP    '\n         DC    X'520000',C'SWITCH_NCP/EP    '\n         DC    X'FFFFFF',C'Unknown type     '\nYJP$DFC  CSECT ,\n         DC    X'040000',C'LUSTAT           '\n         DC    X'050000',C'RTR              '\n         DC    X'700000',C'BIS              '\n         DC    X'710000',C'SBI              '\n         DC    X'800000',C'QEC              '\n         DC    X'810000',C'QC               '\n         DC    X'820000',C'RELQ             '\n         DC    X'830000',C'CANCEL           '\n         DC    X'840000',C'CHASE            '\n         DC    X'C00000',C'SHUTD            '\n         DC    X'C10000',C'SHUTC            '\n         DC    X'C20000',C'RSHUTD           '\n         DC    X'C80000',C'BID              '\n         DC    X'C90000',C'SIG              '\n         DC    X'FFFFFF',C'Unknown type     '\nYJP$SC   CSECT ,\n         DC    X'0D0000',C'ACTLU            '\n         DC    X'0E0000',C'DACTLU           '\n         DC    X'110000',C'ACTPU            '\n         DC    X'120000',C'DACTPU           '\n         DC    X'140000',C'ACTCDRM          '\n         DC    X'150000',C'DACTCDRM         '\n         DC    X'310000',C'BIND             '\n         DC    X'320000',C'UNBIND           '\n         DC    X'A00000',C'SDT              '\n         DC    X'A10000',C'CLEAR            '\n         DC    X'A20000',C'STSN             '\n         DC    X'A30000',C'RQR              '\n         DC    X'C00000',C'CRV              '\n         DC    X'FF3100',C'GENERIC BIND     '\n         DC    X'FF3200',C'GENERIC UNBIND   '\n         DC    X'FFFFFF',C'Unknown type     '\n*   MESSAGE CSECT FOR THE $MSG MACRO                                *\n*   NOTE: in testing, change message VRM005I to VRM005T to stop     *\n*         alerts being generated in NPDA.                           *\nMSGSECT  CSECT  ,\n         $MSGTEXT MSG=1,TEXT='VRM001I Virtual Route monitor started'\n         $MSGTEXT MSG=2,TEXT='VRM002I % %     Virtual Route          Wi*\n               ndow             TSCBq  HSQHs '\n         $MSGTEXT MSG=3,TEXT='VRM003I SA# VR  TP  ADJ  State       FSM *\n                   Min   Cur  Max   #Sess  Depth  Held'\n         $MSGTEXT MSG=5,TEXT='VRM005I  % %  %   %  %  %  %   %  %   %  *\n                %  %'\n         $MSGTEXT MSG=6,TEXT='VRM006I Dest Subarea/Element   Orig Subar*\n               ea/Element   RU '\n         $MSGTEXT MSG=7,TEXT='VRM007I %.% (%)   %.% (%)   % (%) '\n         $MSGTEXT MSG=8,TEXT='VRM008I  HSQH Type    Resource'\n         $MSGTEXT MSG=9,TEXT='VRM009I  % (%)   % '\n         $MSGTEXT MSG=10,TEXT='VRM010I  Unknown HSQH type (%) at addres*\n               s:  % '\n         $MSGTEXT MSG=11,TEXT='VRM011I  % (%)   %  (PartnerSA: %  Partn*\n               erEle: % ) '\n*   Major disaster messages                                         *\n         $MSGTEXT MSG=100,TEXT='VRM100E Unable to locate VTAM ASID '\n*   Command parsing/information messages (See: WAIT)                *\n         $MSGTEXT MSG=200,TEXT='VRM200E Invalid command : % '\n         $MSGTEXT MSG=201,TEXT='VRM201I New timer value set to: %'\n         $MSGTEXT MSG=202,TEXT='VRM202E Invalid timer value % (%)'\n         $MSGTEXT MSG=203,TEXT='VRM203I Current timer value: %'\n         $MSGTEXT MSG=204,TEXT='VRM204I STOP command acknowledged '\n         $MSGTEXT MSG=205,TEXT='VRM205I Display changed to ALL virtual *\n               routes '\n         $MSGTEXT MSG=206,TEXT='VRM206I Display changed to virtual rout*\n               es with an HSQH chain'\n         $MSGTEXT MSG=207,TEXT='VRM207I Display changed to \"Not Open\" v*\n               irtual routes'\n         $MSGTEXT MSG=208,TEXT='VRM208I Virtual routes being displayed:*\n                % '\n         $MSGTEXT MSG=209,TEXT='VRM209I NOT monitoring the host subarea*\n                (%) '\n*   Useful blank line and useful dummy line                         *\n         $MSGTEXT MSG=800,TEXT=' '\n         $MSGTEXT MSG=801,TEXT='%'\n         DC    X'FFFFFFFF'\n         END   ,\n\n\n#AMODE\n\n*   AMODE switching macro                                             *\n         MACRO\n&LABEL   #AMODE &AMODE\n         AIF   ('&AMODE' EQ '24').AMODE24\n         AIF   ('&AMODE' EQ '31').AMODE31\n         MNOTE 4,'INVALID AMODE SPECIFIED. MUST BE 24 OR 31'\n         MEXIT\n.AMODE24 ANOP\n&LABEL   LA    15,*+6              TURN OFF 31 BIT ADDRESSING\n         BSM   0,15                CHANGE MODE\n         MEXIT\n.AMODE31 ANOP\n&LABEL   LA    15,*+10             DUMMY BRANCH ADDRESS\n         O     15,=X'80000000'     SET 31 BIT MODE FLAG\n         BSM   0,15                CHANGE MODE\n         MEXIT\n         MEND\n\n\n#LINKAGE\n\n*   Entry/exit linkage and dsa definition macro.                      *\n         MACRO\n&NAME    #LINKAGE &FUNC,&DSA=9,&BASE=12,&AMODE=24,&RMODE=24\n         AIF   ('&FUNC' EQ 'START').START\n         AIF   ('&FUNC' EQ 'END').END\n         AIF   ('&FUNC' EQ 'DSASTART').DSASTRT\n         AIF   ('&FUNC' EQ 'DSAEND').DSAEND\n         MNOTE 8,'UNKNOWN LINKAGE FUNCTION: &FUNC '\n         MEXIT\n.*   PROGRAM ENTRY PROCESSING.                                *\n.START   ANOP\n.*   SETUP GLOBAL AND LOCAL ASSEMBLER VARIABLES, SAVE DSA REGISTER    *\n.*   FOR LINKAGE END AND GENERATE THE \"&LNKPASS\" LOCAL VARIABLE. THIS *\n.*   WILL BE USED TO BYPASS THE PROGRAM EYE CATCHER.                  *\n         GBLC  &#LNKDSA            DSA REGISTER USED\n         GBLB  &#LNKMDE            AMODE/RMODE SET FLAG\n         LCLC  &LNKPASS            LOCAL BRANCH LABEL\n         LCLC  &AMDE               AMODE VALUE\n         LCLC  &RMDE               RMODE VALUE\n         LCLC  &BASEREG            LIST OF BASE REGISTERS FOR USING\n         LCLA  &LOOPC              USED TO GENERATE BASE REGISTERS\n         LCLA  &LOOPMAX            MAXIMUM NUMBER OF BASE REGISTERS\n&#LNKDSA SETC  '&DSA'              SAVE DSA REGISTER\n&LNKPASS SETC  'LNK&SYSNDX'        SETUP BRANCH LABEL\n.*   VERIFY AMODE AND RMODE HAVE VALID VALUES. IF NOT, THEN DEFAULT   *\n.*   THE INCORRECT VALUE TO \"24\".                                     *\n.*   IF AMODE IS SET TO 24, THE RMODE CAN NOT BE \"ANY\".               *\n&AMDE    SETC  '&AMODE'\n&RMDE    SETC  '&RMODE'\n         AIF   ('&AMODE' EQ '24').AMOK\n         AIF   ('&AMODE' EQ '31').AMOK\n         AIF   ('&AMODE' EQ 'ANY').AMOK\n         MNOTE *,'INVALID AMODE &AMODE, DEFAULTED TO AMODE 24'\n&AMDE    SETC  '24'\n.AMOK    ANOP\n         AIF   ('&RMODE' EQ '24').RMOK\n         AIF   ('&RMODE' EQ 'ANY').RMOK\n         MNOTE *,'INVALID RMODE &RMODE, DEFAULTED TO RMODE 24'\n&RMDE    SETC  '24'\n.RMOK    ANOP\n         AIF   ('&AMODE' NE '24').ARMOK\n         AIF   ('&RMODE' NE 'ANY').ARMOK\n         MNOTE *,'INVALID AMODE/RMODE COMBINATION. SET TO 24'\n&AMDE    SETC  '24'\n&RMDE    SETC  '24'\n.ARMOK   ANOP\n.*   VALIDATE BASE REGISTER HAS BEEN SPECIFIED                        *\n         AIF   ('&BASE' NE '').NOT1\n         MNOTE 8,'ERROR: BASE REGISTER MUST BE GIVEN'\n         MEXIT\n.NOT1    ANOP\n.*   VALIDATE DSA REGISTER SPECIFIED                                  *\n         AIF   ('&DSA' NE '').NOT2\n         MNOTE 8,'ERROR: DSA REGISTER MUST BE GIVEN'\n         MEXIT\n.NOT2    ANOP\n.*   IF THE AMODE AND RMODE HAVE ALREADY BEEN SET BY A PREVIOUS       *\n.*   LINKAGE MACRO, WE SHOULD NOT DO IT AGAIN.  LIKEWISE, IF WE HAVE  *\n.*   ALREADY EQUATED THE REGISTERS, WE SHOULD NOT DO THAT AGAIN.      *\n         AIF   (&#LNKMDE).MODESET\n         AMODE &AMDE\n         RMODE &RMDE\n&#LNKMDE SETB  1\n.MODESET AIF   (D'R0 ).NOEQU\n         YREGS\nAR0      EQU   0\nAR1      EQU   1\nAR2      EQU   2\nAR3      EQU   3\nAR4      EQU   4\nAR5      EQU   5\nAR6      EQU   6\nAR7      EQU   7\nAR8      EQU   8\nAR9      EQU   9\nAR10     EQU   10\nAR11     EQU   11\nAR12     EQU   12\nAR13     EQU   13\nAR14     EQU   14\nAR15     EQU   15\n.NOEQU   ANOP\n&NAME    CSECT\n         SAVE (14,12)              SAVE CALLERS REGISTERS\n.*   SETUP THE BASE REGISTER(S). SINCE WE MAY HAVE MORE THAN ONE, WE  *\n.*   CODE A LOOP TO SCAN THE &BASE VARIABLE.                          *\n.*   &LOOPC   IS USED TO CONTROL THE LOOP                             *\n.*   &LOOPMAX IS THE NUMBER OF ITERATIONS TO MAKE (IE THE NUMBER OF   *\n.*                   REGISTERS SPECIFIED FOR BASE)                    *\n&LOOPMAX SETA  N'&BASE\n&LOOPC   SETA  1\n.*   SETUP THE FIRST BASE REGISTER, AND LOAD IT FROM REGISTER 15      *\n         LR    &BASE(1),15         SETUP BASE REGISTER\n         AGO   .LOOP2              GO VALIDATE THE REGISTER USED\n.*   SETUP SUBSEQUENT BASE REGISTERS TO POINT 4096 BYTES ON FROM THE  *\n.*   PREVIOUS BASE REGISTER.                                          *\n.LOOP1   ANOP\n         LA    &BASE(&LOOPC),4095(,&BASE(&LOOPC-1))  LAST BASE+4095\n         LA    &BASE(&LOOPC),1(,&BASE(&LOOPC))       LAST BASE+4096\n.LOOP2   AIF   ('&BASE(&LOOPC)' NE '&DSA').LOOP3\n         MNOTE 8,'ERROR: BASE/DSA REGISTERS CAN NOT BE THE SAME'\n         MEXIT\n.LOOP3   ANOP\n.*   BUILD THE REGISTER LIST FOR THE \"USING\" STATEMENT.               *\n&BASEREG SETC  '&BASEREG,&BASE(&LOOPC)'      SETUP BASE REGISTER STRING\n&LOOPC   SETA  &LOOPC+1                      COUNT 1 REGISTER USED\n         AIF   (&LOOPC LE &LOOPMAX).LOOP1    LOOP TILL ALL CHECKED\n.*   DROP THROUGH HERE WHEN ALL BASE REGISTERS HAVE BEEN PROCESSED.   *\n         USING &NAME&BASEREG\n         B     &LNKPASS\n         DC    C'CSECT: &NAME  ASSEMBLED: &SYSDATE &SYSTIME'\n         DS    0H\n&LNKPASS LR    R2,R1               SAVE PARAMETER REGISTER\n         GETMAIN R,LV=DSALEN       GET SAVE AREA STORAGE\n         ST    R1,8(,R13)          STORE FORWARD POINTER\n         ST    R13,4(,R1)          STORE BACKWARD POINTER\n         LR    R13,R1              SETUP SAVE AREA POINTER\n         LR    &DSA,R1             SETUP DSA POINTER\n         USING DSA,&DSA\n         LR    R1,R2               RESTORE POINTER TO PARMS\n         MEXIT\n.*   PROGRAM TERMINATION PROCESSING                                   *\n.END     ANOP\n         GBLC  &#LNKDSA            DSA REGISTER IN LAST LINKAGE\n&NAME    LR    R1,&#LNKDSA         GET DSA ADDRESS\n         LR    R2,R15              SAVE RETURN CODE\n         L     R13,4(,R13)         RESTORE SAVE AREA POINTER\n         FREEMAIN R,LV=DSALEN,A=(1)\n         LR    R15,R2              RESTORE RETURN CODE\n         RETURN (14,12),RC=(15)    RETURN TO CALLER\n         MEXIT\n.*   DSA GENERATION - GENERATES DSA DSECT NAME AND SAVE AREA          *\n.DSASTRT ANOP\nDSA      DSECT\n         DS    18F                 REGISTER SAVE AREA\n         MEXIT\n.*   END OF DSA AREA - GENERATED EQUATE FOR DSA LENGTH                *\n.DSAEND  ANOP\nDSALEN   EQU   *-DSA\n         MEXIT\n         MEND\n\n\n$MSG\n\n*   Generic WTO/TPUT etc messages with substitution.                  *\n         MACRO\n&LABEL   $MSG  &MSG=,&EP=,&TABLE=,&TYPE,&CHAR=,&FIELDS=,&MF=I\n&WORDS   SETA  5\n&J       SETA  1\n.DEFLOOP AIF   ('&FIELDS(&J)' EQ '').MF1\n&WORDS   SETA  &WORDS+2\n&J       SETA  &J+3\n         AGO   .DEFLOOP\n.MF1     AIF   ('&MF(1)' EQ 'I').MF5\n         AIF   ('&MF(1)' EQ 'L').MF2\n         AIF   ('&MF(1)' EQ 'E').MF3\n         MNOTE 8,'$MSG MACRO - INVALID MF VALUE'\n         MEXIT\n.MF2     ANOP\n&LABEL   DC    &WORDS.F'0'         WORKAREA\n         MEXIT\n.MF3     AIF   ('&MF(2)' NE '').MF4\n         MNOTE 8,'$MSG MACRO - INVALID MF EXECUTE VALUE'\n         MEXIT\n.MF4     ANOP\n&LABEL   IHBINNRA &MF(2)\n         LR    R14,R1              ->WORKAREA\n         AGO   .MSG\n.MF5     ANOP\n&LABEL   CNOP  0,4\n         BAL   R14,*+4+(&WORDS*4)  ->WORKAREA\n         DC    &WORDS.F'0'         WORKAREA\n.MSG     AIF   ('&MSG' EQ '').TABLE\n         IHBINNRA &MSG\n         STH   R1,10(,R14)         SAVE MESSAGE NUMBER\n.TABLE   AIF   ('&TABLE' EQ '').TYPE\n         L     R1,=V(&TABLE)       ->MESSAGE TABLE\n         ST    R1,0(,R14)          SAVE MESSAGE TABLE ADDRESS\n.TYPE    AIF   ('&TYPE' EQ '').CHAR\n         AIF   ('&TYPE' NE 'TPUT').TYPEWTO\n         MVI   12(R14),1           SET DISPLAY TO TPUT\n         AGO   .CHAR\n.TYPEWTO AIF   ('&TYPE' NE 'WTO').TYPEBUF\n         MVI   12(R14),2           SET DISPLAY TO WTO\n         AGO   .CHAR\n.TYPEBUF AIF   ('&TYPE' NE 'BUFFER').TYPERR\n         MVI   12(R14),3           SET DISPLAY TO RETURN BUFFER\n         AGO   .CHAR\n.TYPERR  MNOTE 8,'$MSG MACRO - INVALID DISPLAY TYPE'\n         MEXIT\n.CHAR    AIF   ('&CHAR' NE '').CHARSET\n         MVI   13(R14),C'%'        SET SUBSTITUTION CHARACTER\n         AGO   .VARINIT\n.CHARSET ANOP\n         MVI   13(R14),C'&CHAR'    SET SUBSTITUTION CHARACTER\n.VARINIT ANOP\n&I       SETA  1\n&ADDR    SETA  20\n.VARLOOP AIF   ('&FIELDS(&I)' EQ '').CALL\n         IHBINNRA &FIELDS(&I)\n         ST    R1,&ADDR.(,R14)     SET VARIABLE ADDRESS\n         IHBINNRA &FIELDS(&I+1)\n         STH   R1,&ADDR+4(,R14)    SET VARIABLE LENGTH\n         AIF   ('&FIELDS(&I+2)' NE 'CHAR').VARHEX\n         MVI   &ADDR+6(R14),1      SET VARIABLE TYPE TO CHARACTER\n         AGO   .VARNEXT\n.VARHEX  AIF   ('&FIELDS(&I+2)' NE 'HEX').VARDEC\n         MVI   &ADDR+6(R14),2      SET VARIABLE TYPE TO HEXADECIMAL\n         AGO   .VARNEXT\n.VARDEC  AIF   ('&FIELDS(&I+2)' NE 'DEC').VARBIN\n         MVI   &ADDR+6(R14),3      SET VARIABLE TYPE TO DECIMAL\n         AGO   .VARNEXT\n.VARBIN  AIF   ('&FIELDS(&I+2)' NE 'BIN').VARBINH\n         MVI   &ADDR+6(R14),4      SET VARIABLE TYPE TO BINARY WORD\n         AGO   .VARNEXT\n.VARBINH AIF   ('&FIELDS(&I+2)' NE 'BINH').VARDUMP\n         MVI   &ADDR+6(R14),5      SET VARIABLE TYPE TO BINARY HALF\n         AGO   .VARNEXT\n.VARDUMP AIF   ('&FIELDS(&I+2)' NE 'DUMP').VARERR\n         MVI   &ADDR+6(R14),6      SET VARIABLE TYPE TO HEX DUMP\n         AGO   .VARNEXT\n.VARERR  MNOTE 8,'$MSG MACRO - UNRECOGNIZED FIELD TYPE'\n.VARNEXT ANOP\n&I       SETA  &I+3\n&ADDR    SETA  &ADDR+8\n         AGO   .VARLOOP\n.CALL    LA    R1,20(,R14)         ->VARIABLE LIST\n         ST    R1,16(,R14)         SET IN PARAMETER LIST\n         AIF   ('&EP' EQ '').CALL1\n         IHBINNRA &EP\n         LR    R15,R1\n         AGO   .CALL2\n.CALL1   L     R15,=V(YJP$MSG)     ->FORMAT ROUTINE\n.CALL2   LR    R1,R14              ->PARAMETER LIST\n         BALR  R14,R15             INVOKE FORMAT ROUTINE\n         MEND\n\n\n$MSGTEXT\n\n*   Message definition macro, for use with $MSG                       *\n         MACRO\n&LABEL   $MSGTEXT &MSG=,&TEXT=\n         LCLA  &LEN\n         AIF   (T'&MSG NE 'N').BAD1\n         AIF   ('&TEXT' EQ '').BAD2\n&LEN     SETA  K'&TEXT-2\n         DC    AL2(&MSG)           MESSAGE NUMBER\n         DC    AL2(&LEN)           MESSAGE TEXT LENGTH\n         DC    C&TEXT\n         MEXIT\n.BAD1    MNOTE 8,'INVALID MESSAGE NUMBER '\n         MEXIT\n.BAD2    MNOTE 8,'MESSAGE TEXT MISSING   '\n         MEXIT\n         MEND\n\n\nSteve Barnett\nSenior Technical Consultant\nIMI Computing Ltd (UK)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N004A05": {"ttr": 5125, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\xd1\\x00\\xd1\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 209, "newlines": 209, "modlines": 0, "user": "SNAUPDT"}, "text": "NCP generation migration aid\n\nIn the past, when I have installed a new version of the Network\nControl Program (NCP), I have had to search meticulously\nthrough the Migration Guide to identify which NCP parameters\nrequire amendment.  Depending on which release you are\ninstalling this can range from less than a dozen to more than it\nis worth mentioning here.  In the newest release of NCP, IBM\nhas provided the NCP Generation Migration Aid.  With release\n3.5 of ACF/SSP, this facility is available as a Small\nProgramming Enhancement (SPE) - PTF UR90191 (MVS),\nPTF UR90192 (VM), and PTF UR90193 (VSE).  With Version\n3.5.1 of ACF/SSP the migration aid is included as standard.\n\nThe migration aid is a new option of the NCP/EP Definition\nFacility (NDF).  The aid can be used to modify a working NCP\ngeneration definition for a 3720 or 3745 communications\ncontrol unit.  The aid will delete any statements that are no\nlonger required, amend keywords as necessary, move\nkeywords from one statement to another, and add keywords\nand statements where applicable.  The migration aid does not\nwork for X25 NPSI keywords, NPM keywords, NRF\nkeywords, NTO keywords, and user-defined keywords.\n\nThe output produced by the migration aid is in three formats.\nThese are:\n\no      A generation listing\n\no      A new definition (NEWDEFN) file\n\no      A load module.\n\nThe NEWDEFN file will contain the modified NCP generation\ndeck and consists of comment blocks, unchanged keywords,\nand modified keywords.  The file should be reviewed and then\ncan be used as input to an NCP generation.  If a keyword\ncannot be resolved, the migration aid will insert a string of\nthree question marks after the equals sign on the keyword in\nquestion.  The file can be defined as re-usable.  This means\nthat it can be used as input to VTAM and also as input to the\nNDF for re-generation.  You should use the OPTIONS\nstatement in the NCP source deck to control the re-usable\noption of the NEWDEFN file.\n\nSeveral new statements have been created to control the\nexecution of the migration aid. The migration aid will convert\nNCP source decks for NCP Version 2 onwards.  These decks\nare always converted to either NCP Versions 5.2.1 or 5.3\nupwards.  So if you have a NCP Version 3 running on a 3705\nand want to install a 3745 the aid would be useful to convert\nthe source code to work on the new controller.\n\nTo perform migration you should execute the following\nprocesses:\n\n1      Obtain an error free source NCP deck to be used as input\n      to the NDF.\n\n2      Allocate a NEWDEFN file.  The migration aid will place\n      the modified generation into the file.  Because of the\n      additional comments and statements generated by the\n      migration aid you should allocate the file at least twice as\n      large as the original source deck.  The file should be in\n      fixed block eighty-byte character format.\n\n3      You will have to choose the parameters that control the\n      migration aid.  The required parameters are TMODEL,\n      TVERSION, and TUSGTIER.  Optional parameters are\n      CHANNELS, DPU, and SAVEADDR.  These parameters\n      can be specified on the NCP OPTIONS statement or in the\n      NDF JCL as parameters on the EXEC card.  Below, I have\n      included the parameters as part of the JCL.  The comments\n      in the JCL detail how the parameters are used.  If you do\n      code the parameters in the JCL and also on the OPTIONS\n      statement in the NCP source code, the NDF programs will\n      use the latter.  In the example I am migrating an NCP to be\n      used on a 3745-210 communications controller at usage\n      tier two.  The new version of the NCP that I am installing\n      is Version 5.3.1.\n\n4      Once you have coded these statements the NDF job should\n      be submitted.\n\n5      Once the job has completed, the output should be reviewed\n      in detail.  Messages with a severity code of eight or more\n      indicate errors that could not be resolved by the migration aid.\n\n6      The NEWDEFN file will contain the new NCP source\n      deck.  The migration aid will have inserted comment\n      blocks throughout the file.  You can identify these\n      comment blocks by searching for the string of characters\n      ':MIGINFO'.  This string of characters is placed at the\n      beginning of all comment blocks.  A sample summary\n      comment block for the whole generation and the BUILD\n      statement is shown below.\n\n7      You can submit another NDF job with the NEWDEFN file\n      as input if no further changes are required.  You can\n      remove the comments added to the NEWDEFN file by\n      using the REMOVCOM=YES keyword on the parameter\n      statement in the NDF JCL.\n\nThis new facility provides useful productivity aids to the\nNetwork Systems Programmer to help migrate NCPs from\nlower to higher releases.\n\n\nSAMPLE JCL TO INVOKE THE NDF MIGRATION AID\n\n//STS01NCP    JOB   (SDTS),'J.BRADLEY',CLASS=A,MSGCLASS=Q,\n//            MSGLEVEL=(1,1),NOTIFY=STS01,REGION=8M\n//*      **************************************************************\n//*      * EXAMPLE OF USING NCP MIGRATION AID.                        *\n//*      * RELEVANT MANUAL IS:-                                       *\n//*      * NCP/SSP LIBRARY SUPPLEMENT FOR THE NCP MIGRATION AID.      *\n//*      * - SD35-0251.                                               *\n//*      * INFORMATION.                                               *\n//*      * 1) NEWDEFN FILE IS ALLOCATED AS A SEQUENTIAL FILE. IT      *\n//*      *    CAN ALSO BE A MEMBER OF A PDS TYPE DATASET. THE FILE    *\n//*      *    SHOULD BE 80 BYTE CHARACTER CARD FORMAT.                *\n//*      * 2) TMODEL=3745-210 INFORMS THE MIGRATION AID THAT THE      *\n//*      *    GENERATED NCP WILL RUN ON A MODEL 210 TYPE OF 3745      *\n//*      *    FRONT END PROCESSOR.                                    *\n//*      * 3) TUSGTIER=2 SPECIFIES USAGE TIER GROUP TWO.              *\n//*      * 4) TVERSION=V5R3.1 WILL CONVERT THE INPUT SOURCE NCP CODE  *\n//*      *    TO VERSION 5 RELEASE 3.1 SOURCE CODE.                   *\n//*      **************************************************************\n//NDF         EXEC  PGM=ICNRTNDF,REGION=8M,\n//            PARM=('TMODEL=3745-210','TUSGTIER=2','TVERSION=V5R3.1',\n//            'FASTRUN=ON')\n//STEPLIB     DD    DSN=NCP91B.SSPLIB,DISP=SHR\n//            DD    DSN=NCP91B.NPSILNK,DISP=SHR\n//GENDECK     DD    DSN=SYS1.VTAMLST(SGEN00A),DISP=SHR\n//SYSPRINT    DD    SYSOUT=*\n//PRINTER     DD    SYSOUT=*\n//DBWORKFL    DD    DSN=&WORKF,DISP=(,DELETE),UNIT=WORK,\n//            SPACE=(CYL,(5,1))\n//TBL1SRCE    DD    DSN=&SRCE1,DISP=(,DELETE),UNIT=WORK,\n//            SPACE=(CYL,(5,2)),DCB=BLKSIZE=3200\n//TBL1LIST    DD    DSN=TBL1LIST,UNIT=WORK,DISP=(NEW,PASS),\n//            SPACE=(CYL,(10,5)),DCB=BLKSIZE=21780\n//TBL1OBJ     DD    DSN=&OBJ(ICNTABL1),DISP=(,PASS),UNIT=WORK,\n//            SPACE=(CYL,(5,1,1)),DCB=BLKSIZE=3200\n//TBL2SRCE    DD    DSN=&SRCE2,DISP=(,DELETE),UNIT=WORK,\n//            SPACE=(CYL,(10,10)),DCB=BLKSIZE=3200\n//TBL2LIST    DD    DSN=TBL2LIST,UNIT=WORK,DISP=(NEW,PASS),\n//            SPACE=(CYL,(10,2))\n//TBL2OBJ     DD    DSN=&OBJ(ICNTABL2),DISP=(MOD,PASS),\n//            DCB=BLKSIZE=3200,VOL=REF=*.TBL1OBJ\n//SYSUT1      DD    UNIT=WORK,SPACE=(CYL,(10,10)),DISP=(,DELETE)\n//SYSLIB      DD    DSN=NCP91B.ANCPMAC1,DISP=SHR\n//            DD    DSN=NCP91B.ABALMAC1,DISP=SHR\n//LNKSTMT     DD    DSN=&LNKFL,DISP=(,PASS),UNIT=WORK,\n//            SPACE=(CYL,(1,1)),DCB=BLKSIZE=3120\n//NEWDEFN     DD    DSN=STS01.BD.DATA.NEWDEFN,DISP=SHR\n\n\nSAMPLE COMMENT BLOCKS\n\n*:MIGINFO**************************************************************\n* MIGRATION AID SUMMARY\n*\n* THE MIGRATION AID WAS INVOKED WITH THESE PARAMETERS SPECIFIED OR\n* DEFAULTED:\n*   TVERSION=V5R3.1\n*   TMODEL=3745-210\n*   TUSGTIER=2\n*   CHANNELS=GROUP\n*            IF CHANNEL DEFINITIONS EXISTED IN THE SOURCE GENERATION\n*            DEFINITION, THEY ARE NOW DEFINED ON THE GROUP AND LINE\n*            STATEMENTS.\n*   DPU=YES\n*            TGBXTRA, PATHEXT, AND VRPOOL(2) DEFAULT TO A VALUE\n*            GREATER THAN ZERO, MEANING THAT NCP STORAGE IS ALLOCATED\n*            FOR THE DYNAMIC PATH UPDATE FUNCTION.  SINCE DPU=YES,\n*            THE MIGRATION AID ALLOWED UNSPECIFIED VALUES OF\n*            TGBXTRA, PATHEXT, AND VRPOOL(2) TO TAKE THEIR NORMAL\n*            DEFAULTS.  THIS MEANS THAT STORAGE WILL BE ALLOCATED\n*            FOR THE DPU FUNCTION, WHETHER YOU INTEND TO USE DPU\n*            OR NOT.\n*   SAVEADDR=YES\n*            THE VALUES SPECIFIED FOR ADDRESS, AUTO, DUALCOM,\n*            DYNADMP, HICHAN, AND LOCHAN HAVE BEEN RETAINED.  THESE\n*            VALUES MAY NOT BE VALID IF YOU ARE MIGRATING TO A NEW\n*            CONTROLLER OR A LOWER USAGE TIER.\n*\n*:MIGEND***************************************************************\n*:MIGINFO**************************************************************\n* MIGRATION AID BUILD STATEMENT SUMMARY\n*\n* INFORMATIONAL\n*   MAXSUBA MAY BE REMOVED IF ALL THE NODES IN YOUR NETWORK ARE\n*   CAPABLE OF EXTENDED NETWORK ADDRESSING, BUT ONLY IF YOU REMOVE\n*   IT FROM THE GENERATION DEFINITIONS OF ALL THE OTHER NODES IN YOUR\n*   NETWORK.\n*\n* CHANGES\n*   VERSION=V5R3.1 - CHANGED FROM V5R2.1\n*      - CHANGED VIA TVERSION\n*   MODEL=3745-210 - CHANGED FROM 3745\n*      - CHANGED VIA TMODEL\n*\n*:MIGEND***************************************************************\n\n\nJohn Bradley\nTechnical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N004A06": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x02\\x03\\x02\\x03\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 515, "newlines": 515, "modlines": 0, "user": "SNAUPDT"}, "text": "Error recovery in LU6.2\n\nArticle three in this series of examinations of the fundamentals\nof the LU6.2 support offered by the APPCCMD macro in\nACF/VTAM 3.2 onwards will discuss error detection and\nrecovery.  Although the subject will be dealt with in some\ntechnical depth a large part of the article will concentrate on the\ndesign aspects of error recovery.\n\nLU6.2 support is rich with possibilities for errors and the IBM\ndocumentation contains immense detail on the many different\nerrors and how the application program is notified.  Error\nrecovery would appear to revolve around detailed examination\nof return codes and condition codes to determine what action to\ntake.  Designers and programmers familiar with other high-\nlevel interfaces such as VSAM and indeed the pre-LU6.2\nVTAM API will recognise the somewhat mystical world of the\nfeedback information and the conditional retry code.\nMercifully we are spared the EXECRPL function of VSAM\nwhich allows re-execution of a failed macro instruction and\ntherefore the potential for compounding the original error.\nHowever, as we shall see, the LU6.2 support API does allow\nfor re-issuing previously failed macros under controlled\nconditions.  Much more thought needs to be given to the design\nof error recovery for LU6.2 applications than for many other\ntypes of applications.  LU6.2 applications cross system and\nperhaps company boundaries and support transactions that\ncould interface to complex and valuable databases.  The\npotential dangers in rogue transactions, intermittent errors,\ntransient failures, etc, is enormous and should not be taken\nlightly.  This article will concentrate on the development of a\nstructured approach to error detection and recovery.\n\nThere are three categories of errors which can occur in LU6.2-\noriented applications: transaction errors, protocol errors, and\napplication errors.  Each is related to a distinct area of\nfunctionality and leads to the failure of different functions.\n\no      Transaction errors - errors in the transaction being run by\n      the application.  Such errors include invalid data, failed\n      database calls, or program logic errors.  Transaction errors\n      result in a failure of the active transaction but do not affect\n      the active conversation or the LU6.2 application.\n\no      Protocol errors - errors in the LU6.2 protocol or the\n      Application Program Interface.  Primarily these will be\n      APPCCMD macro failures caused by state errors (invalid\n      sequence of macro calls) and bad parameters such as an\n      invalid RPL or extension.  Protocol errors result in a\n      failure of the active conversation leaving the transaction in\n      doubt but having no direct effect on the application.\n\no      Application errors - errors in either the application logic or\n      the interfaces to the containing system.  This could be the\n      failure of the host system, a VTAM failure, or a logic error\n      in the application.  Application errors result in a failure of\n      the application and, by implication, the conversation.  The\n      transaction is left in doubt.\n\nFirst apply a sensible context to the subject of errors.  Most\nerrors will occur during the development of the application.  It\nis unlikely that severe errors will occur during normal\noperation, since they should have been screened out during\ntesting.  Application development and testing should have\nremoved most of the following problems:\n\no      Protocol logic errors, such as invalid macro sequences and\n      bad macro parameters or an invalid RPL or RPL extension.\n\no      Program logic errors, such as system abends (SOC4,\n      SOC1, etc), and bad logic (loops, branch errors, etc).\n\no      Transaction errors, such as invalid database calls.\n\nThis article is not concerned about program faults, protocol\nerrors, and run-time support errors.  What we are most\nconcerned about is the occurrence of errors relating to LU6.2 in\nclean code.\n\nFollowing completion of an APPCCMD macro call, VTAM\nsets a general return code in GPR15.  Currently only two codes\nare set:\n\no      GPR15=00, which means that the macro was processed\n      successfully.\n\no      GPR15=04, which means that VTAM could not process\n      the macro.\n\nIn addition, VTAM sets what is termed either a conditional\ncompletion code or recovery action code in GPR0.  Error\nrecovery decisions are based on the codes in both GPR15 and\nGPR0.  These codes approximate to what would formerly have\nbeen the RTNCD and FDBK2 codes in the RPL.  Although the\ntwo RPL fields may be set, unfortunately they do not always\nreveal the whole picture, which means that all previously\nlearned RPL error condition handling is not applicable to\nLU6.2.\n\nThe majority of RC=04 errors are due to logic faults which, as\nhas already been argued, should be filtered out during testing.\nOne condition that is worth detecting and handling is the\nrejection of the request due to an environmental problem such\nas VTAM halting.  In this case, GPR0 is set to X'10' and the\napplication should attempt to close down.  For all other\nGPR15=04 errors the application should abend to allow\ndebugging.\n\nSuccessful handling of the macro by VTAM does not\nnecessarily mean that all is well.  VTAM applies the\ncompletely illogical concept of degrees of success!  If\nGPR15=00 then GPR0 should be checked for a value of X'0B'\nwhich means that some further information is available.\n\nThis may not be a problem or it may be what is termed a\nrecoverable error condition implying that, although the macro\nworked, it did not quite work properly and that maybe some\naction is required to clean up or not, or something like that.  In\nthe RPL extension block supplied on the APPCCMD macro\ncall are two return code fields:\n\no      RPL6RCPR - the primary return code, referred to as\n      RCPRI in most documentation.  This gives the primary\n      reason for an error.\n\no      RPL6RCSC - the secondary return code, referred to as\n      RCSEC in the documentation.  This adds granularity to the\n      primary reason.\n\nThere are many combinations of values for these two fields.\nWhat values get set is a complex question depending on the\nAPPCCMD macro being issued, the parameters chosen, the\nmode of invocation (SYN or ASY), the local environment, and\npossibly feedback from the partner application.  In essence,\nRCPRI relates to the LU6.2 service being invoked and RCSEC\nindicates the error.  General guidelines are difficult to draw,\npainstaking study of all the likely conditions is the only\nanswer.\n\nTo a large extent, how much error handling is included in the\ndesign will depend upon the design of the LU6.2 applications\nto be contacted and the design of any applications that will\ncontact the one being developed.  If all nodes in the LU6.2\nnetwork have clean applications with agreed session parameters\nand limits, most of the allocate and data flow errors will not\noccur.  If the application is in fact 'shooting in the dark' and\nbeing similarly 'shot at', the entire gambit of errors is possible.\nThere are then the questions of which errors are acceptable,\nwhich are recoverable, which are re-negotiable, and what\naction to take if the error is accepted.  To cope with this, it is\nrecommended that a generalized error recovery routine is\ndeveloped.  This should have the prime aim of keeping the\napplication alive by rejecting failures, and recording sufficient\ninformation to allow either on-line interrogation or post-\nanalysis, whichever is operationally necessary.\n\n\nCALLING THE GENERAL ANALYSE ROUTINE\n\nMACALL    DS         OH\n          APPCCMD    CONTROL=.....,       < Any APPCCMD macro >\n                     ....., etc\n          LA         R1,RPLLIST           Pass RPL address list\n          LTR        R15,R15              Return code set in  GPR15\n          BNZ        ABORT                ?\n          LTR        R0,R0                Fail transaction if RC>0\n          BZ         OK                   Conditional code set ?\n          BAL        R14,ANALYSE          All OK if not\n          LTR        R15,R15              Call general analyse rout-\n          BZ         OK                   ine\n          CH         R15,=H'04'           No action required ?\n          BE         MACALL               Proceed\n          CH         R15,=H'08'           Retry possible ?\n          BE         CONVFAIL             Go retry\n          CH         R15,=H'12'           Conversation failed ?\n          BE         TRANABRT             Go tidy up\n          CH         R15,=H'16'           Transaction must abort ?\n          BE         APPLABND             Go do it\n          B          APPLABND             Application must abend ?\nOK        DS         0H                   Go do it\n                                          Should not  occur  condit-\nCONVFAIL  DS         0H                   tion\n          APPCCMD    CONTROL=REJECT,\n                     QUALIFY=CONV,\n                     RPL=LU62RPL,\n                     AAREA=LU62RPLX,\n                     CONVID=LU62CID,\n                     OPTCD=SYN\nRPLLIST   DS         0F\n          DC         A(LU62RPL)\n          DC         A(LU62RPLX)\nLU62RPL   RPL        AM=VTAM\nLU62RPLX  ISTRPL6\n\n\nSAMPLE GENERAL ANALYSE ROUTINE\n\n*  APPCCMD Macro Call General Analyse Routine\n*  On Entry : GPR1 contains the address of a  two word address list\n*                A(RPL)\n*                A(RPL Extension)\n*  On Exit  : GPR15 contains one of the following action codes :\n*              00 - acceptable error, ignore\n*              04 - retryable error, re-issue the macro\n*              08 - failed, cannot retry, conversation failed\n*              12 - transaction must be aborted\n*              16 - application must terminate\n*             LOGDATA field contains received data if available\n*             ERRORTYP contains error TYPE from partner application\nANALYSE   DS         0H\n          ST         R14,SAVER14          Save    caller     return\n          LM         R6,R7,0(R1)          address\n          USING      ISTRPL,R6            Set addressability ...\n          USING      ISTRPL6,R7           ... to RPL and ...\n          LA         R2,EMATRIX           ... RPL extension\nSCANLOOP  DS         0H                   Start of error matrix\n          CLC        RPL6RC,0(R2)\n          BE         FOUND                This RCPRI/RCSEC pair ?\n          LA         R2,5(,R2)            Error matched\n          CLI        0(R2),X'FF'          Bump R2 to next error\n          BE         UNKNOWN              End of matrix\n          B          SCANLOOP             Unknown error\n                                          Keep looking\nFOUND     DS         0H\n          TM         RPL6RTUN,RPL6RLOG    Log  received   indicator\n          BNO        EXIT                 set ?\n          APPCCMD    CONTROL=RECEIVE,     Quick exit if not\n                     QUALIFY=SPEC,\n                     RPL=(R6),\n                     AAREA=(R7),\n                     AREA=LOGDATA,\n                     AREALEN=255,\n                     FILL=LL,\n                     OPTCD=SYN\n          LTR        R15,R15\n          BZ         ANALYSE2             Log data received OK ?\n                                          Go extract data\n*  Failure to retrieve the log data is a serious protocol error,\n*  the session must be terminated immediately and the error matrix\n*  action code overridden with a transaction failure condition.\n*  Notice that the conversation id is not specified, the same RPL\n*  is used. The conversation will terminate with the session.\n          APPCCMD     CONTROL=REJECT,\n                      QUALIFY=SESSION,\n                      RPL=(R6),\n                      AAREA=(R7),\n                      OPTCD=SYN\n          LA          R15,12              Set action code = 12\n          L           R14,SAVER14         Restore   caller   return\n          BR          R14                 address\n                                          Return to caller\n*  At this point the log data can be analysed and recorded\nANALYSE2  DS         0H\n          MVC        LOGMLUNM(8),RPL6LU   LU name in log message\n          MVC        ERRORTYP,RPL6TYPE    Save error type\n          CLC        LOGDATA+2,=X'12E1'   Valid Log Data GDS id ?\n          BNE        EXIT                 Ignore if not\n          LH         R3,LOGDATA+4         Length of Product set id\n          BCTR       R3,0                 Decrement for EX MVC\n          CH         R3,=H'01'            Not specified ?\n          BE         *+8                  Skip move\n          EX         R3,MOVEPSET          Move to log message\n          LA         R4,LOGDATA+1         Point to message text ...\n          AR         R4,R3                ... in log data message\n          LH         R3,0(,R4)            Length of message text\n          BCTR       R3,0                 Decrement for EX MVC\n          CH         R3,=H'01'            No data present ?\n          BE         *+8                  Skip move\n          EX         R3,MOVETEXT          Move text to log message\n*   Record log data (Eg run-time log, MVS console etc).\nEXIT      DS         0H\n          SR         R15,R15\n          IC         R15,4(,R2)           Action code in R15\n          L          R14,SAVER14          Restore   caller   return\n          BR         R14                  address\n                                          Return to caller\nUNKNOWN   DS         0H\n          LA         R15,20               Set  \"should  not  occur\"\n          L          R14,SAVER14          code\n          BR         R14                  Restore   caller   return\n                                          address\n                                          Return to caller\nMOVEPSET  MVC        LOGMPSET(0),LOGDATA+6\nMOVETEXT  MVC        LOGMTEXT(0),0(R4)\nSAVER14   DS         A\nLOGDATA   DS         CL255\nERRORTYP  DC         X'00'\nLOGMSG    DS         0CL200\nLOGMLUNM  DC         CL8' '\nLOGMPSET  DC         CL8' '\nLOGMTEXT  DC         CL184\n*   Error matrix, action codes shown are general recommendations,\n*   they may be revised to conform with specific application\n*   requirements.\nEMATRIX  DS   0H\n*               RCPRI   RCSEC   ACTION\n         DC   X'0000',X'0000',X'00'\n         DC   X'0000',X'0001',X'00'\n         DC   X'0000',X'0002',X'00'\n         DC   X'0000',X'0003',X'08'\n         DC   X'0000',X'0004',X'00'\n         DC   X'0000',X'0005',X'08'\n         DC   X'0004',X'0000',X'08'\n         DC   X'0004',X'0001',X'04'\n         DC   X'0004',X'0002',X'08'\n         DC   X'0004',X'0003',X'08'\n         DC   X'0004',X'0004',X'08'\n         DC   X'0004',X'0005',X'08'\n         DC   X'0004',X'0006',X'00'\n         DC   X'0004',X'0007',X'00'\n         DC   X'0004',X'0008',X'08'\n         DC   X'0004',X'0009',X'0C'\n         DC   X'0004',X'000A',X'04'\n         DC   X'0004',X'000B',X'08'\n         DC   X'0004',X'000D',X'08'\n                   .\n                   .\n         DC   X'0008',X'0000',X'08'\n         DC   X'0008',X'0001',X'04'\n         DC   X'0008',X'0002',X'04'\n         DC   X'0008',X'0003',X'08'\n                   .\n                   .\n         DC   X'0050',X'0000',X'0C'\n                   .\n                   .\n         DC   X'FF'\n*  For the sake of brevity the matrix has been truncated, if you\n*  use this method then the matrix must include all possible\n*  combinations of RCPRI and RCSEC otherwise the \"should not occur\"\n*  condition with which the matrix is terminated will be raised.\n\nAt first glance this routine may not appear to be very efficient\nas it involves a large scanning loop, but remember that it will\nonly be called in the event of an error and hopefully the vast\nmajority of calls to the routine will exit after a few instructions\nas there will not have been a problem.  The key value of this\napproach is that the mainline program is not confused with an\nexcessive amount of error checking.  However, there is no\nreason why error checking for specific macros cannot be\nhandled in the main line if the analyse routine is not sensitive\nenough.\n\nA note of caution: the sample code shows APPCCMD macros\nbeing issued during error conditions.  Always remember that an\nAPPCCMD macro should only be issued if the current finite\nstate of the session or conversation allows.  Failure to observe\nthis rule will simply compound the attempted error recovery.\nFor example, it is not always possible to deallocate a\nconversation using CONTROL=DEALLOC when there has\nbeen a data flow error, instead CONTROL=REJECT,\nQUALIFY=CONV should be used.  However if the state of the\nconversation is uncertain then this too could cause an error, in\nwhich case CONTROL=REJECT,QUALIFY=SESSION should\nbe used.  This will terminate the session and any conversation\nthat it is supporting irrespective of the state of that\nconversation.\n\n\nUSE OF EXITS\n\nAnyone familiar with pre-LU6.2 VTAM application\nprogramming may be puzzled by the lack of discussion relating\nto exits.  RPL exits are supported on most APPCCMD macro\ncalls which specify OPTCD=ASY and their use is at the\ndiscretion of the application designer.  Three application level\nexits that relate to errors are still supported: LERAD, SYNAD,\nand TPEND.  Their function and the design necessary is\nidentical to pre-LU6.2 applications.  As discussed earlier,\nwhen an APPCCMD macro completes, GPR15 is set with a\ngeneral return code.  However, if LERAD and SYNAD exits\nare supplied, one of them is scheduled (usually the LERAD)\nwhen an APPCCMD macro completes with a general return\ncode of non-zero.  The exit is then responsible for setting both\nthe return code in GPR15 and the condition code in GPR0\nwhich will then be available to the NSI following the\nAPPCCMD macro.  Use of exits is a matter of personal choice.\nThis article has expressed the author's preference for not using\nexits for several reasons.  First, exits are scheduled by VTAM\nusing SVC6.  The environment under which the exit runs is not\nclearly defined and has certain restrictions.  If error recovery is\nplaced in the main line, the environment is under the control of\nthe application.  Second, the design and coding of exits is\ncomplex since addressability must be established and checks\nmade to detect recursive calls and unexpected errors.  Testing\nand debugging is also complex since VTAM must be persuaded\nto schedule the exit.  Finally, LU6.2 support is a move in the\ndirection of a higher level interface to communications\nprotocol.  It is far more productive to be able to forget tortuous\nlow-level coding and concentrate on functionality.  But the\ndecision is yours.\n\n\nUSING LOG DATA\n\nProvision has been made in the LU6.2 support to utilize LU6.2\nprotocol to allow applications to communicate errors in a\ncontrolled manner.  This is achieved via support for the LU6.2\nSEND_ERROR verb which causes a Function Management\nHeader Type 7 to flow.  FMH7 is used to send conversation or\nsession error notification from one LU to another.  In addition,\nthe LU reporting the error condition can send an error message\nprovided it conforms to the LU6.2 architecture requirements as\na formatted GDS variable.  The message is called an Error Log\nVariable and has the following format:\n\no      LL  ID  error data\n\nLL is the total length of the GDS structure (including 2 bytes\nfor the length field itself) and the GDS-id must be X'12E1'.\nError data is in two parts: the product set-id subvector followed\nby the error message text subvector.  Supplying the product\nset-id is optional but the length field must still be set to X'02'.\n\nThe following code illustrates the use of error notification:\n\n           APPCCMD    CONTROL=SEND,\n                      QUALIFY=ERROR,\n                      RPL=LU62RPL,\n                      AAREA=LU62RPLX,\n                      AREA=LOGDATA,\n                      OPTCD=SYN,\n                      TYPE=PROGRAM\nLOGDATA    DS         0F\n           DC         X'0021',X'12E1'\n           DC         X'0002'\n           DC         X'001B'\n           DC         C'INVALID TRANSACTION PARMS'\n\nThis code would cause a waiting APPCCMD macro on the\npartner system to complete and generate the data processed by\nthe general analysis routine shown earlier.  It is recommended\nthat error notification uses LU6.2 protocol via the\nCONTROL=SEND, QUALIFY=ERROR and GDS structured\nlog data.  This simplifies debugging and ensures that the\napplication has a standard that can be detected by all other applications.\n\nNotice that the APPCCMD macro has the parameter\nTYPE=PROGRAM coded.  This tells VTAM that the error\nbeing reported is in a transaction program.  Two other error\ntypes are possible:\n\no      SERVICE - for errors relating to LU6.2, services\n      supported by the application itself (eg conversation\n      mapping).  Very little short term use can be made of this.\n      In the longer term, applications that support LU6.2 service\n      functions that can be accessed by other applications can\n      use this type to notify errors in the service.\n\no      USER - for errors defined by the application design.  This\n      basically means define whatever you want with the proviso\n      that the receiving partner application(s) must be able to\n      understand it.\n\nThe error type is propagated to the partner application and\nRPL6TYPE is set in the RPL extension for the active\nconversation.  If TYPE=USER is coded then sense information\ncan be placed in the FMH7 by using the SENSE=sense-data\nparameter.  There is some confusion in the documentation as to\nthe exact role of the FMH7.  It is the protocol mechanism used\nby the VTAM LU6.2 support on one system to inform the\nequivalent VTAM LU6.2 support on the partner system that\nthere has been an error.  The FMH7 is not available to the\nLU6.2 applications (there is no equivalent of the RCVFMH5\nmacro call) although, as indicated above, they can affect the\ncontents of the FMH7 by providing log data or sense\ninformation.  Applications are made aware of the error\ncondition by bad APPCCMD return codes.  In effect error\ninformation is being transported transparently between systems\nusing LU6.2 protocol.\n\n\nABNORMALLY TERMINATING CONVERSATIONS\n\nOne possibility for an application to maintain integrity is to\nterminate a troublesome conversation.  This is achieved via the\nAPPCCMD macro\nCONTROL=DEALLOC,QUALIFY=qualifier with one of four\nqualifiers.  Three of the qualifiers correspond to the\nPROGRAM, SERVICE, and USER values of the TYPE\nparameter on the APPCCMD macro\nCONTROL=SEND,QUALIFY=ERROR,TYPE= type.  The\nfourth qualifier allows for failures caused by time-outs.  Each\nof the qualifiers maps to a sense code in the FMH7 used by the\nVTAM LU6.2 support.  At the partner application, all\nAPPCCMD macro calls issued against the conversation will\nfail with RCPRI=X'0014' for QUALIFY=ABNDPROG,\nRCPRI=X'0018' for qualify=ABNDSERV, RCPRI=X'001C'\nfor QUALIFY=ABND-TIME.\n\n\nSUMMARY\n\nDesign of error detection and recovery is important as LU6.2\napplications live in a far more dynamic environment than pre-\nLU6.2 VTAM applications.  Decide on a methodology and\napply it consistently to all errors.  Use QUALIFY=SPEC rather\nthat ANY because for some errors, in particular allocation\nfailures, the error notification is returned in APPCCMD macros\nfollowing the original CONTROL=ALLOC.  Use\nOPTCD=SYN for single threaded applications.  Check GPR15\nfollowing each APPCCMD macro call.  Do not attempt to\nrecover from GPR15=04 conditions, simply fail the application\nsince these will almost certainly be due to a program bug.  For\nGPR15=00 and GPR0=X'0B' conditions, screen the values of\nRCPRI and RCSEC in the RPL extension for the conditions\nthat require some recovery action.  Use LU6.2 protocol to\nhandle all errors - this means issuing APPCCMD macros\nconsistent with the finite state to exchange error information\nand gracefully terminate conversations and sessions.\n\nBrian Alford\nSystems Consultant\nAranda (UK)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N004A07": {"ttr": 5383, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x16\\x05O\\x01\\x16\\x06/\\x12E\\x00>\\x00>\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T12:45:46", "lines": 62, "newlines": 62, "modlines": 0, "user": "SNAUPDT"}, "text": "IBM announcements\n\nFor reasons best known to itself, IBM was apparently holding\nback on us all when it first announced Version 3.4 of VTAM\nlast year, for in September of this year it disclosed the details\nof some additional functions, which it had hitherto seen fit to\nkeep hidden under the covers.  Six new functions have been\nrevealed with particular emphasis on IBM's increasing\ncommitment to maximum system availability.\n\nQuite clearly 'Succinct' wasn't the middle name of the person\nwho dreamt up the title of the Dynamic Network Access\nSample Configuration Services Exchange Identification (XID)\nExit.  The exit is supplied in a ready-to-run form or it can be\ncustomized to meet specific installation standards.  The exit\nmakes it easier to add switched devices 'on the fly' and will be\nwarmly welcomed by network administrators.  Also making\ntheir jobs easier is the newly-provided capability of making\ndynamic, non-disruptive changes to the DLOGMOD\nspecifications of applications, independent and dependent LUs,\nand cross-domain resources.  In a similar vein, customers can\nnow add the SEGMENT and LMODADR parameters for the\nLink Problem Determination Aids (LPDA-2) facility and have\nthem passed on automatically to the NCP, obviating the need\nfor an NCPGEN.\n\nAnybody who has ever grappled with the various VTAM,\nSNA, and NCP manuals containing error messages or sense\ncodes will give their approval to the On-line Message Facility.\nAs well as providing speedy access to this information, users\ncan add their own text, incorporating, for example, details of\nany recovery actions that need to be performed by the network\noperator.\n\nAnother aspect of VTAM which benefits in this belated list of\ngoodies is security.  A new Command Verification Exit is\noffered, which can be used to screen operator commands,\nincluding those of programmed operators.  There is also\nsupport for the LU6.2 Persistent Verification function: this\ncauses identification and password security information to be\nvalidated once for a series of conversations rather than\nindividually for each separate conversation.\n\nAlso announced was ACF/NCP Version 6, although it won't be\ngenerally available for another year.  It primarily establishes\nsupport for the 3745, which in turn provides Ethernet Version 2\nand IEEE 802.3 LAN connectivity.  In addition, ACF/NCP\nVersion 6 supports the attachment of a 3745 as a DTE to a\nFrame Relay network.\n\nImprovements have also been made in the area of network\nmanagement.  An alert will now be triggered if a virtual route\nremains in the 'held' or 'congested' state for a pre-defined period\nof time.  This problem with virtual routes, which is highlighted\nin the article Virtual route monitor on page 12, has been a\nsource of irritation for some time.  Also, details of session\ntransmission priorities will be included in the data sent to NPM\nallowing network usage to be assessed more accurately and\nmore equitable methods of chargeback to be implemented.\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N004A08": {"ttr": 5385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00I\\x00I\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 73, "newlines": 73, "modlines": 0, "user": "SNAUPDT"}, "text": "VTAM extended display command\n\nWhen we installed NetView at our installation, our operators\nrequested us to write a NetView CLIST to allow more than one\nterminal to be displayed at once.  We did this for Version 1.2\nof NetView.  When we installed Version 1.3, I re-wrote the\nCLIST in REXX.  The following program allows the operators\nto display several terminals at once.  They find this useful\nwhen dealing with help desk queries relating to multi-session\nterminals.  The command should be issued in the following format:\n\n      BDISEX term1 term2\n\nwhere term1 is the first terminal to be displayed and term2 the\nlast terminal.  The command works on the principle that the\nlast two characters of the terminal's name are numeric.  For\nexample, if the operator issued BDISEX STE00012 STE00015,\nit would result in a display at the NetView console of terminals\nSTE00012, STE00013, STE00014, and STE00015.  This\ncommand could be adapted to other installations' naming\nconventions if necessary.  We have found the command to be\nvery useful for our operations and help desk personnel.\n\n/* REXX EXEC BDISEX */\nARG P1 P2\nINCR = 0\nIF P1 = '' THEN\n   DO\n    SAY 'PARAMETER ONE IS MISSING....REXX EXEC TERMINATING.'\n    EXIT\n   END\nIF P2 = '' THEN\n   DO\n    SAY 'PARAMETER TWO IS MISSING....REXX EXEC TERMINATING.'\n    EXIT\n   END\nP3 = LENGTH(P1)\nIF P3 > 8 THEN\n   DO\n    SAY 'LENGTH OF PARAMETER ONE > MAXIMUM....REXX EXEC TERMINATING.'\n    EXIT\n   END\nP3 = LENGTH(P2)\nIF P3 > 8 THEN\n   DO\n    SAY 'LENGTH OF PARAMETER TWO > MAXIMUM....REXX EXEC TERMINATING.'\n    EXIT\n   END\nSTRTFLD = SUBSTR(P1,7,2)\nENDFLD = SUBSTR(P2,7,2)\nCNT = ENDFLD - STRTFLD\nIF CNT < 0 THEN\n   DO\n    SAY 'ERROR IN SECOND PARAMETER....REXX EXEC TERMINATING.'\n    EXIT\n   END\nDO WHILE INCR \u00ac> CNT\n   ADDRESS NETVIEW \"DIS \"||P1\n   INCR = INCR + 1\n   P2 = SUBSTR(P1,7,2)\n   P2 = P2 + 1\n   IF LENGTH(P2) < 2 THEN\n      DO\n       P2 = 0||P2\n      END\n   P1 = SUBSTR(P1,1,6)||P2\nEND\nEXIT\n\n\nJohn Bradley\nTechnical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N005A00I": {"ttr": 5388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 13, "newlines": 13, "modlines": 0, "user": "SNAUPDT"}, "text": "N005 - SNA Update issue #5  March 1992\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nN005A01   Reorganizing the NetView session monitor database\nN005A02   Modifying the VTAM ISTRACON module\nN005A03   Miscellaneous LU6.2 functions\nN005A04   A VTAM front-end for automatic sign-ons\nN005A05   A NetView command processor\nN005A06   Loading the NCP through VM\nN005A07   SNA route planning\nN005A08   Tuning VTAM and NCP data flows\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N005A01": {"ttr": 5390, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x01{\\x01{\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 379, "newlines": 379, "modlines": 0, "user": "SNAUPDT"}, "text": "Reorganizing the NetView session monitor database\n\nAfter installing NetView Version 2.1, we found that the\nsession monitor would display the following message when an\noption was chosen from the primary menu:\n\n      AAU050I DATA SERVICES FAILURE IN PROCESSING LAST COMMAND\n\nThis was found to be caused by the primary database having\nreached the maximum number of extents, so reorganizing the\ndatabase using IDCAMS solved the problem.\n\nTo ease this process, the following REXX EXEC was written\nwhich stops the session monitor, frees the database, and\nperforms the reorganization. Once the reorganization is\ncomplete, the database is reallocated and the session monitor\nrestarted. The same EXEC is able to perform a reorganization\nof the primary and secondary databases of the session and\nhardware monitors.\n\nThe REXX IDCAMS command used by the EXEC requires\nthat the following DD statements are included in the NetView\nstart-up procedure:\n\nNLDMORGP DD    DSN=NETVIEW.USRJCL(NLDMORGP),DISP=SHR\nNLDMORGS DD    DSN=NETVIEW.USRJCL(NLDMORGS),DISP=SHR\nNPDAORGP DD    DSN=NETVIEW.USRJCL(NPDAORGP),DISP=SHR\nNPDAORGS DD    DSN=NETVIEW.USRJCL(NPDAORGS),DISP=SHR\n\nThe above DD statements define the members containing the\nIDCAMS statements necessary to perform a reorganization of\neach of the four databases. A listing of NLDMORGP is shown.\nThe EXEC could also be run from the Message Automation\nTable, when, for example, the session monitor primary\ndatabase runs out of extents, by including the following entry:\n\nIF MSGID = 'AAU022I' THEN\n   EXEC(CMD('REORG NLDM P') ROUTE(ONE AUTO1));\n\n\nREORG REXX EXEC\n\n/**********************************************************************/\n/* Initialize error handling.                                         */\n/**********************************************************************/\nTrace 0\n/**********************************************************************/\n/* Initialize variables.                                              */\n/**********************************************************************/\nARG SUBSYS LOG\nLOG = Strip(LOG)\nSelect\n   When SUBSYS = 'NLDM' then\n      Do\n         If LOG = 'S' then VSAM = 'AAUVSSL'\n         Else\n            Do\n               LOG = 'P'\n               VSAM = 'AAUVSPL'\n            End\n         TASK.1 = 'DSIAMLUT'\n         TASK.2 = 'AAUTCNMI'\n         TASK.3 = 'AAUTSKLP'\n      End\n   When SUBSYS = 'NPDA' then\n      Do\n         If LOG = 'S' then VSAM = 'BNJLGSE'\n         Else\n            Do\n               LOG = 'P'\n               VSAM = 'BNJLGPR'\n            End\n         TASK.1 = 'BNJMNPDA'\n         TASK.2 = 'BNJDSERV'\n         TASK.3 = 'BNJDSE36'\n      End\n   Otherwise\n      Do\n         Help REORG\n         Exit\n      End\nEnd\n/**********************************************************************/\n/* Initialize variables.                                              */\n/**********************************************************************/\nTASK.4 = 'DSICRTR'\nTASK.5 = 'CNM06LUC'\nNOTASK = 4\nSTART. = 0\nSTOP. = 0\n/**********************************************************************/\n/* Issue commands to stop tasks and wait for responses.               */\n/**********************************************************************/\nDo I = 1 to 3\n   'TRAP AND SUPPRESS MESSAGES DSI200I DSI008I'\n   'STOP TASK='TASK.I\n   'WAIT 15 SECONDS FOR MESSAGES'\n   Select\n      When EVENT() = 'M' then\n         Do\n            'MSGREAD'\n            If MSGID() = 'DSI200I' & MSGVAR(2) = TASK.I then STOP.I = 1\n            If MSGID() = 'DSI008I' & MSGSTR() = \"'\"TASK.I\"' NOT ACTIVE\"\n               then STOP.I = 1\n         End\n      When EVENT() = 'T' then\n         Do\n            Say 'Timeout waiting for 'TASK.I' to stop'\n            SIGNAL RESTART\n         End\n      Otherwise\n         Do\n            Say 'Error waiting for 'TASK.I' to stop'\n            SIGNAL RESTART\n         End\n   End\n   'TRAP NO MESSAGES'\n   'FLUSHQ'\nEnd\n/**********************************************************************/\n/* Check that all 3 tasks have stopped successfully.                  */\n/**********************************************************************/\nIf STOP.1 + STOP.2 + STOP.3 < 3 then\n   Do\n   Say SUBSYS' has not stopped - the following task(s) are still active'\n      Do I = 1 to 3\n         If STOP.I = 0 then say '                'TASK.I\n      End\n      SIGNAL RESTART\n   End\n/**********************************************************************/\n/* Issue commands to free tasks and wait for responses.               */\n/**********************************************************************/\n'TRAP AND SUPPRESS MESSAGES CNM272I'\n\"FREE DATASET('NETVIEW.SA06.\"VSAM\"')\"\n'WAIT 15 SECONDS FOR MESSAGES'\nSelect\n   When EVENT() = 'M' then\n      Do\n         'MSGREAD'\n         IF MSGSTR() \u00ac= 'NETVIEW.SA06.'VSAM' IS NOW DEALLOCATED' then\n            Do\n               Say 'Unable to deallocate NETVIEW.SA06.'VSAM\n               SIGNAL RESTART\n            End\n      End\n   When EVENT() = 'T' then\n      Do\n         Say 'Timeout waiting for 'VSAM' to be freed'\n         SIGNAL RESTART\n      End\n   Otherwise\n      Do\n         Say 'Error waiting for 'VSAM' to be freed'\n         SIGNAL RESTART\n      End\nEnd\n'TRAP NO MESSAGES'\n'FLUSHQ'\nSay '******************************************* /'\nSay '*       'SUBSYS' shut down successfully       *<=========='\nSay '******************************************* \\'\n/**********************************************************************/\n/* Reorg the VSAM file.                                               */\n/**********************************************************************/\n'TRAP AND SUPPRESS MESSAGES CNM270I'\n'IDCAMS 'SUBSYS'ORG'LOG\n'WAIT 60 SECONDS FOR MESSAGES'\nSelect\n   When EVENT() = 'M' then\n      Do\n         'MSGREAD'\n         If MSGVAR(9) \u00ac= '00' then\n            Do\n               Say '******************************************* /'\n               Say\n'*      'SUBSYS'ORG'LOG'unsuccessful (RC='MSGVAR(9)')      *<=========='\n               SAY '******************************************* \\'\n               SIGNAL REALLOC\n            End\n      End\n   When EVENT() = 'T' then\n      Do\n         Say 'Timeout waiting for reply from 'SUBSYS'ORG'LOG\n         SIGNAL REALLOC\n      End\n   Otherwise\n      Do\n         Say 'Error waiting for reply from 'SUBSYS'ORG'LOG\n         SIGNAL REALLOC\n      End\nEnd\n'TRAP NO MESSAGES'\n'FLUSHQ'\nSay '******************************************* /'\nSay '* 'SUBSYS'ORG'LOG' completed successfully (RC=00) *<=========='\nSay '******************************************* \\'\n/**********************************************************************/\n/* Reallocate dataset 'NETVIEW.SA06.xxxxxxx' to NetView (xxxxxxx).    */\n/**********************************************************************/\nREALLOC:\n   'TRAP AND SUPPRESS MESSAGES CNM272I'\n   \"ALLOC DATASET('NETVIEW.SA06.'\"VSAM\"') DDNAME(\"VSAM\") SHR\"\n   'WAIT 15 SECONDS FOR MESSAGES'\n   Select\n      When EVENT() = 'M' then\n         Do\n            'MSGREAD'\n            If MSGSTR() \u00ac= VSAM' IS NOW ALLOCATED' then\n               Do\n                  Say 'Unable to allocate NETVIEW.SA06.'VSAM\n                  SIGNAL QUIT\n               End\n         End\n      When EVENT() = 'T' then\n         Do\n            Say 'Timeout waiting for 'VSAM' to be allocated'\n            SIGNAL QUIT\n         End\n      Otherwise\n         Do\n            Say 'Error waiting for 'VSAM' to be allocated'\n            SIGNAL QUIT\n         End\n   End\n   'TRAP NO MESSAGES'\n   'FLUSHQ'\n/**********************************************************************/\n/* Issue commands to start tasks and wait for responses.              */\n/**********************************************************************/\nRESTART:\n   If SUBSYS = 'NPDA' then\n      Do\n         NOTASK = 3\n         TASK.3 = TASK.4\n         START.4 = 1\n      End\n   Do I = 1 to NOTASK\n      'TRAP AND SUPPRESS MESSAGES DSI530I DSI041I BNJ014I'\n      'START TASK='TASK.I\n      'WAIT 15 SECONDS FOR MESSAGES'\n      Select\n         When EVENT() = 'M' then\n            Do\n               'MSGREAD'\n               If MSGID() = 'DSI530I' & MSGVAR(1) = TASK.I then\n                  START.I = 1\n               If MSGID() = 'DSI041I' & MSGVAR(1) = TASK.I then\n                  START.I = 1\n               If MSGID() = 'BNJ014I' & MSGVAR(1) = SUBSYS then\n                  START.I = 1\n            End\n         When EVENT() = 'T' then\n            Do\n               Say 'Timeout waiting for 'TASK.I' to start'\n               SIGNAL QUIT\n            End\n         Otherwise\n            Do\n               Say 'Error waiting for 'TASK.I' to start'\n               SIGNAL QUIT\n            End\n      End\n      'TRAP NO MESSAGES'\n      'FLUSHQ'\n   End\n/**********************************************************************/\n/* Check that all 4 tasks have started successfully.                  */\n/**********************************************************************/\n   If START.1 + START.2 + START.3 + START.4 < 4 then\n      Do\n      Say SUBSYS' has not started - the following task(s) are inactive'\n         Do I = 1 to 4\n            If START.I = 0 then say '                'TASK.I\n         End\n         SIGNAL QUIT\n      End\n   'START TASK='TASK.5\n   Say '******************************************* /'\n   Say '*      'SUBSYS' re-started successfully       *<=========='\n   Say '******************************************* \\'\n   Exit\n/**********************************************************************/\n/* Quit without starting if file has not been reallocated.            */\n/**********************************************************************/\nQUIT:\n   Say '******************************************* /'\n   Say '*         Unable to re-start 'SUBSYS'         *<=========='\n   Say '******************************************* \\'\n   Exit\n\n\nHELP PANEL FOR REORG EXEC\n\nHELP=CNM5HCCL\n***\n\u00acLAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS\n\u00acA+EUYREG00                         %REORG                        +Page 1 of 1\u00ac\n\u00acS                                                                            \u00acL\n\u00ac $REORG                                                                      \u00acA\n\u00acL                                                                            \u00acS\n\u00acA$The REORG command list reorganizes the NLDM and NPDA VSAM clusters.        \u00ac\n\u00acS                                                                            \u00acL\n\u00ac $The format of the REORG command is:                                        \u00acA\n\u00acL                                                                            \u00acS\n\u00acA$---------------------------------------------------------------------------\u00ac\n\u00acS                                                                            \u00acL\n\u00ac $REORG NLDM|NPDA P|S                                                        \u00acA\n\u00acL                                                                            \u00acS\n\u00acA$---------------------------------------------------------------------------\u00ac\n\u00acS                                                                            \u00acL\n\u00ac \\WHERE:$ NLDM | NPDA   Selects Session or Hardware monitor.                 \u00acA\n\u00acL                                                                            \u00acS\n\u00acA        \\P$| S         Selects Primary or Secondary cluster.                \u00ac\n\u00acS                                                                            \u00acL\n\u00ac                                                                             \u00acA\n\u00acLAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS LAS\n%Action===>~&CUR\n$          PF1= Help   PF2= End  %PF3= Return$\n\n\nIDCAMS STATEMENTS TO REORGANIZE THE SESSION MONITOR\n\nSET MAXCC = 0\nVERIFY                                     -\n        DATASET(NETVIEW.SA06.AAUVSPL)\nIF MAXCC = 0 THEN DO\nDEFINE                                     -\n    CLUSTER                                -\n        (NAME (NETVIEW.REORG.AAUVSPL)      -\n        MODEL (NETVIEW.SA06.AAUVSPL) )\nEND\nIF MAXCC = 0 THEN DO\nREPRO                                      -\n        INDATASET (NETVIEW.SA06.AAUVSPL)   -\n        OUTDATASET (NETVIEW.REORG.AAUVSPL)\nEND\nIF MAXCC = 0 THEN DO\nDELETE                                     -\n        NETVIEW.SA06.AAUVSPL CLUSTER\nEND\nIF MAXCC = 0 THEN DO\nDEFINE                                     -\n    CLUSTER                                -\n        (NAME (NETVIEW.SA06.AAUVSPL)       -\n        INDEXED                            -\n        SHAREOPTIONS (2)                   -\n        VOLUMES (SMP369)                   -\n        CYLINDERS (3 1)                    -\n        KEYS (27 0)                        -\n        RECORDSIZE (102 4086)              -\n        REUSE                              -\n        FREESPACE (5 5) )                  -\n    DATA                                   -\n        (CONTROLINTERVALSIZE (8192) )      -\n    INDEX                                  -\n        (CONTROLINTERVALSIZE (2048)        -\n        IMBED)\nEND\nIF MAXCC = 0 THEN DO\nREPRO                                      -\n        INDATASET (NETVIEW.REORG.AAUVSPL)  -\n        OUTDATASET (NETVIEW.SA06.AAUVSPL)\nEND\nIF MAXCC = 0 THEN DO\nDELETE                                     -\n        NETVIEW.REORG.AAUVSPL CLUSTER\nEND\nIF MAXCC = 0 THEN DO\nLISTCAT                                    -\n        ENTRIES (NETVIEW.SA06.AAUVSPL)     -\n        ALL\nEND\n\n\nJohn  Cameron\nTechnical Specialist\nThe Life Association of Scotland (UK)       c Life Association of Scotland 1992\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N005A02": {"ttr": 5639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\x90\\x00\\x90\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 144, "newlines": 144, "modlines": 0, "user": "SNAUPDT"}, "text": "Modifying the VTAM ISTRACON module\n\nIBM has recently introduced an enhancement to the VTAM\nconstants module, ISTRACON. This module resides in load\nmodule format in SYS1.VTAMLIB and contains a number of\nfields which can be modified to control various VTAM\nfacilities. Modifications are normally made using the\nAMASPZAP program.\n\nThe enhancements that I describe here pertain to a particular\nfield within this module. This field was previously known as\nthe RACSMSG but is now called RACMSGS. The field\ncontrols how messages are issued when a 087D0001 sense code\nis set.\n\nNormally what would happen is that the following messages\nwould be issued to all SSCPs where a connection was\nattempted under various circumstances:\n\nIST663I\nIST664I\nIST889I\nIST890I\nIST891I\nIST892I\nIST893I\nIST894I\nIST895I\nIST896I\n\nThe new constant controls where these messages will be issued\nwhen a session initiation request is unsuccessful. In most cases\nit is not sensible to issue these messages in every SSCP. By\nchanging the bit settings in this one-byte field you can control\nexactly where the messages are issued. Below is a table of\npossible values for these bit settings.\n\nMessage      Field      Bit value\nIST663I     RACFLMSG    XX.. ....\nIST664I\nIST889I                 '00'B  -  Message suppressed in all SSCPs.\n                        '01'B  -  Message issued in originating logical\n                                  unit SSCP.\n                        '10'B  -  Message issued in all SSCPs.\nIST890I     RACALMSG    ..XX ....\nIST896I                 '00'B  -  Message suppressed in all SSCPs.\n                        '01'B  -  Message issued in originating logical\n                                  unit SSCP.\n                        '10'B  -  Message issued in all SSCPs.\nIST891I     RACESMSG    .... XX..\nIST892I\nIST893I                 '00'B  -  Message suppressed in all SSCPs.\n                        '01'B  -  Message issued in originating logical\n                                  unit SSCP.\n                        '10'B  -  Message issued in all SSCPs.\nIST894I     RACSSMSG    .... ..XX\nIST895I                 '00'B  -  Message suppressed in all SSCPs.\n                        '01'B  -  Message issued in originating logical\n                                  unit SSCP.\n                        '10'B  -  Message issued in all SSCPs.\n\nThe default for RACMSGS is X'99' or B'10011001'. The\nZAPs to this module should be performed using SMP/E user\nmodifications. Below are two sample SMP/E job streams to\nRECEIVE the user modification and then to APPLY the ZAPs\nto the RACMSGS field.\n\n\n RECEIVE SMP/E USER MODIFICATION TO ZAP ISTRACON\n\n//STS01B      JOB   (SDTS),'JOHN BRADLEY',CLASS=A,MSGCLASS=Q,\n//            MSGLEVEL=(1,1),NOTIFY=STS01\n//*      **************************************************************\n//*      * THIS JOB IS USED TO RECEIVE THE USERMOD REQUIRED TO ZAP    *\n//*      * THE VTAM ISTRACON ZAPPABLE CONSTANTS MODULE.               *\n//*      **************************************************************\n//SMPE        EXEC  PGM=GIMSMP,REGION=4096K\n//SMPCSI      DD    DSN=MVS89D.GLOBAL.CSI,DISP=OLD\n//SMPLIST     DD    SYSOUT=Q\n//SMPOUT      DD    SYSOUT=Q\n//SMPRPT      DD    SYSOUT=Q\n//SYSPRINT    DD    SYSOUT=Q\n//SMPWRK1     DD    UNIT=DISK,SPACE=(CYL,(5,1,15)),DCB=BLKSIZE=3360\n//SMPWRK2     DD    UNIT=DISK,SPACE=(CYL,(5,1,15)),DCB=BLKSIZE=3360\n//SMPWRK3     DD    UNIT=DISK,SPACE=(CYL,(3,1,15)),DCB=BLKSIZE=3200\n//SMPWRK4     DD    UNIT=DISK,SPACE=(CYL,(4,1,15)),DCB=BLKSIZE=3200\n//SMPWRK6     DD    UNIT=DISK,SPACE=(CYL,(3,1,15)),DCB=BLKSIZE=7294\n//SYSUT1      DD    UNIT=DISK,SPACE=(CYL,(2,2))\n//SYSUT2      DD    UNIT=DISK,SPACE=(CYL,(2,2))\n//SYSUT3      DD    UNIT=DISK,SPACE=(CYL,(2,2))\n//SYSUT4      DD    UNIT=DISK,SPACE=(TRK,(1))\n//SMPHOLD     DD    DUMMY\n//SMPCNTL     DD    *\n SET BOUNDARY(GLOBAL).\n RECEIVE S(JXB0001).\n/*\n//SMPPTFIN    DD    DATA,DLM=@@\n++USERMOD(JXB0001).\n++VER(Z038) FMID(HVT3205) PRE(UY61128).\n++ZAP(ISTRACON) .\n NAME ISTRACON\n VER 001C 99\n REP 001C 85\n@@\n\n\nAPPLY SMP/E USER MODIFICATION TO ZAP ISTRACON\n\n//STS01A      JOB   (SDTS),'JOHN BRADLEY',CLASS=A,MSGCLASS=Q,\n//            MSGLEVEL=(1,1),NOTIFY=STS01\n//*      **************************************************************\n//*      * THIS JOB IS USED TO APPLY THE USERMOD REQUIRED TO ZAP      *\n//*      * THE VTAM ISTRACON ZAPPABLE CONSTANTS MODULE.               *\n//*      **************************************************************\n//SMPE        EXEC  PGM=GIMSMP,REGION=4096K\n//SMPCSI      DD    DSN=MVS89D.GLOBAL.CSI,DISP=OLD\n//SMPLIST     DD    SYSOUT=Q\n//SMPOUT      DD    SYSOUT=Q\n//SMPRPT      DD    SYSOUT=Q\n//SYSPRINT    DD    SYSOUT=Q\n//SMPWRK1     DD    UNIT=DISK,SPACE=(CYL,(5,1,15)),DCB=BLKSIZE=3360\n//SMPWRK2     DD    UNIT=DISK,SPACE=(CYL,(5,1,15)),DCB=BLKSIZE=3360\n//SMPWRK3     DD    UNIT=DISK,SPACE=(CYL,(3,1,15)),DCB=BLKSIZE=3200\n//SMPWRK4     DD    UNIT=DISK,SPACE=(CYL,(4,1,15)),DCB=BLKSIZE=3200\n//SMPWRK6     DD    UNIT=DISK,SPACE=(CYL,(3,1,15)),DCB=BLKSIZE=7294\n//SYSUT1      DD    UNIT=DISK,SPACE=(CYL,(2,2))\n//SYSUT2      DD    UNIT=DISK,SPACE=(CYL,(2,2))\n//SYSUT3      DD    UNIT=DISK,SPACE=(CYL,(2,2))\n//SYSUT4      DD    UNIT=DISK,SPACE=(TRK,(1))\n//SMPHOLD     DD    DUMMY\n//SMPCNTL     DD    *\n SET BOUNDARY(CAD89DT).\n APPLY S(JXB0001) CHECK.\n/*\n\nFurther information related to the new usage of this field can be\nobtained by viewing APAR OY35308 and related PTF\nUY61095. Further information about the ISTRACON module\nis available in the VTAM Customization manual.\n\n\nJohn Bradley\nSenior Technical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N005A03": {"ttr": 5643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x02?\\x02?\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 575, "newlines": 575, "modlines": 0, "user": "SNAUPDT"}, "text": "Miscellaneous LU6.2 functions\n\nThis next article in the series which examines the LU6.2\nimplementation of ACF/VTAM Version 3.3 will explore some\nof the more intricate aspects of the LU6.2 protocol, in\nparticular, synchronization, security and data mapping.\nBecause LU6.2 is an application-level protocol it is to be\nexpected that there will be application-level functions and\nfacilities within the protocol. However, support for these\nfunctions lies with the application program itself. Using LU6.2\nprotocol, applications negotiate with each other which\nfunctions are to be in effect across the sessions between them,\nand VTAM records the information. To a large extent, the\nLU6.2 functions implemented by the user application pass\ntransparently through VTAM: the VTAM LU6.2 support\nroutines simply verify that what is being passed complies with\nthe LU6.2 protocol requirements.\n\n\nSecurity\n\nSecurity is supported at two levels: session and conversation.\nSession-level security relates to the interaction between the\nVTAM applications that are maintaining the LU6.2\nconversations. Conversation-level security relates to the\ninteraction between the transactions being supported by the\napplications. In other words, session-level security is\nresponsible for controlling one application accessing another\nwhile conversation-level security is responsible for controlling\naccess to transactions.\n\nTo implement session-level security, a new RACF class,\nAPPCLU, must be activated and the LUs of all applications\nthat are to be allowed to establish sessions must be defined.\nThe required identification information is carried in the\nexpanded BIND image which means that checking and\nvalidation can be performed by VTAM when a session request\nis received. Session-level security is the mechanism by which\ninstallations can prevent access to an application by\nunauthorized applications and so need not concern the LU6.2\napplication directly.\n\nConversation-level security is supported via the FMH5 used\nduring conversation allocation. Following the variable length\ntransaction name in the FMH5, various optional subfields can\nbe specified, the first of which is the access security\ninformation. A typical access security subfield structure would\nlook something like:\n\n      DC    X'12'                 Total length of subfields\n      DC    X'08'                 Length of user-id subfield\n      DC    X'02'                 Subfield type = user-id\n      DC    C'USER001'            User-id\n      DC    X'09'                 Length of password sub-field\n      DC    X'01'                 Sub-field type = password\n      DC    C'QWERTY  '           Password\n\nTo implement conversation-level security, either the SECACPT\noperand on the APPL statement can be coded or the\nCONVSEC profile added to the APPCLU RACF class. (A\nthird possibility exists via use of APPCCMD\nCONTROL=OPRCNTL,QUALIFY=CNOS macros but this is\nmuch trickier to code and unnecessarily complex.) Three\noptions are possible:\n\no      NONE - security access information not supported (default).\n\no      CONV - security access information allowed.\n\no      ALREADYV - security access information allowed and\n      additionally the user-id can be pre-verified by the\n      conversation initiator.\n\nIt is necessary to tell VTAM that conversation-level security is\nin effect so that it can determine whether the security access\nsubfields will be present in the FMH5 and therefore require\nverification. If the partner LU does not support security\nsubfields, VTAM will remove the subfields from the FMH5.\nThe already verified option allows the initiator of the\nconversation to tell the partner that the user-id has already been\nverified locally. If this is used then FM5FLAG2=FM5UIDAV\nmust be set in the FMH5, in which case it is not necessary to\nsupply the password. Sample code illustrating the use of\nsecurity access is shown at the end of this article - it consists of\na rather strange mixture of VTAM and application security.\nThere is much debate concerning peer-to-peer security and\nwhether the application layer is the correct position for it. IBM\ncurrently have little option since the RACF databases reside on\nthe mainframe, however PU type 2.1 supports some security\nfeatures which suggests that the function could possibly be\nmoved out more into the network. Until this debate is resolved,\nan alternative (and possibly more secure) method worth\nconsidering is to format the user-id and password into the PIP\ndata specified in the FMH5 and remove VTAM from the game.\n\n\nSynchronization\n\nSynchronization is the process by which two transactions agree\non a defined point during processing. It is a form of\ncheckpointing co-ordinated on two separate systems. The most\ncommon reason for synchronization is to enable positioning for\ntransaction back-out in the event of problems but there are\nmany other possible reasons such as logging or log switches,\nfreeing of locked resources, and implementation of two-phase\ncommit protocol. LU6.2 architecture protocol specification\nallows for the synchronization of application and transaction\nactivity and reference to the Transaction Programmers\nReference manual for LU6.2 shows that the level of\nsynchronization can be negotiated during conversation\nallocation and actioned by the CONFIRM, SYNCPT, and\nBACKOUT verbs. However, VTAM LU6.2 protocol support\ndoes not itself implement sync point services: it offers what is\ncolourfully termed 'pass-through support', which loosely\ntranslated means \"do it yourself and I promise not to get in the\nway\". Although the requirement for synchronization can be\nspecified by setting the FM5FLAG3 flag in the FMH5 during\nconversation allocation, the significance of this is left to the\napplication and there is no implementation of the SYNCPT and\nBACKOUT verbs. In essence VTAM has been positioned to\nsupport sync point services but does not deliver - yet. Without\ndoubt the sync point function will become available at some\npoint but whether or how this will be in VTAM is not clear - it\nmay be a separate MVS/ESA-level function.\n\nThree levels of synchronization are defined by LU6.2\narchitecture:\n\no      NONE - sync point not supported\n      (FM5FLAG3=FM5NONE this is the default setting in the FMH5).\n\no      CONFIRM - sync points are supported by\n      CONFIRM/CONFIRMED protocol\n      (FM5FLAG3=FM5CONFM).\n\no      SYNCPT - full sync point support including SYNCPT,\n      BACKOUT, and CONFIRM (FM5FLAG3=FM5CSB).\n\nIn effect the only readily available synchronization is the use of\nCONFIRM and CONFIRMED together with the ability to\nFLUSH the conversation buffer maintained by VTAM.\nAlthough VTAM performs no synchronization activity when\nthese options are used (apart from buffer flushing) it does\npolice their use by resetting the conversation state if necessary.\nA confirm request from send state leaves the state unchanged\nbut any pending state (receive, send, deallocate etc) is set to a\ndefinite state (subject of course to errors).\n\nConfirm, confirmed, and flush are qualifiers of the\nCONTROL=SEND parameter of the APPCCMD macro. An\nillustration of how these are used follows.\n\n\nApplication program 1\n\nCHKSYNC  DS    0H\n         APPCCMD CONTROL=OPRCNTL,    Request information ...\n               QUALIFY=DISPLAY,       ... relating to partner ...\n               RPL=LU62RPL,           ... application to check ...\n               AREA=LU62DISP,         ... whether confirm level ...\n               AREALEN=100,           ... synchronization is ...\n               AAREA=LU62RPLX,        ... in effect\n               LUNAME=LU62PART,\n               LUMODE=LU62MODE,\n               OPTCD=SYN\n*\n         LA    R5,LU62DISP           Set addressability ...\n         USING ISTSLD,R5             ... to display block\n         TM    SLDLU1,SLDCONF        Confirm supported ?\n         BNO   SKIPCNFM              Skip confirm\n\n*\n*            CONFIRM RESOURCE(LU62CID) ;\n*\n         APPCCMD CONTROL=SEND,       Send request for ...\n               QUALIFY=CONFIRM,       ... confirmation to ...\n               RPL=LU62RPL,           ... partner application\n               AAREA=LU62RPLX,\n               CONVID=LU62CID,\n               OPTCD=SYN\n*\n* Check macro return codes to determine if confirmation was received.\n* If all was OK then GPR15 and GPR0 will contain 0000. If the partner\n* transaction returned SEND_ERROR then GPR0 will contain X'0B' and the\n* RPL6RC(RPL6PRI) field of the RPL extension block will contain a reason\n* code\n*\n         LTR   R15,R15               Macro completed OK ?\n         BNZ   ABEND                 Disastrous error if not\n         LTR   R0,R0                 Conditional completion ?\n         BZ    CONFRMOK              Confirm successful\n         LA    R6,LU62RPLX           Set addressability ...\n         USING ISTRPL6X,R6           ... to RPL extension\n         CLC   RPL6PRI,=X'0030'      SEND_ERROR TYPE(PROG) ?\n         BE    SENDERRP\n         CLC   RPL6PRI,=X'0034'      SEND_ERROR TYPE(Program) ?\n         BE    SENDERRP\n         CLC   RPL6PRI,=X'0038'      SEND_ERROR TYPE(Program) ?\n         BE    SENDERRP\n         CLC   RPL6PRI,=X'003C'      SEND_ERROR TYPE(Service) ?\n         BE    SENDERRS\n         CLC   RPL6PRI,=X'0040'      SEND_ERROR TYPE(Service) ?\n         BE    SENDERRS\n         CLC   RPL6PRI,=X'0044'      SEND_ERROR TYPE(Service) ?\n         BE    SENDERRS\n          .        .\n          .        .\nLU62RPL  RPL   AM=VTAM\nLU62RPLX ISTRPL6\nLU62DISP DS    XL100\nLU62DATA DS    CL256\n         ISTSLD\n\nIf an attempt is made to send a confirmation request for a\nsession which does not support synchronization, ie one that has\nSYNC_LEVEL(NONE) specified, then a parameter check error\nis raised. Therefore a check is made on the sync level by\nrequesting a copy of the display block for the partner\napplication LU. For LU6.2 applications, VTAM maintains an\nLU mode table or LM table, which associates partner LU\nnames and the various modes, characteristics, and features that\nare in effect. Information relating to partner applications can be\nextracted from the LM table via an APPCCMD\nCONTROL=OPRCNTL,QUALIFY=DISPLAY macro\nspecifying the partner LU name and mode name as shown in\nthe above code. The information is returned in a formatted\nblock known as the DEFINE/DISPLAY block and this can be\nchecked for the options that are in effect such as the negotiated\nsynchronization level. The\nCONTROL=SEND,QUALIFY=CONFIRM is flushed\nimmediately to the partner application together with any data\nthat may be waiting to be sent .\n\n\nPartner Program 2\n\n         APPCCMD CONTROL=RECEIVE,    Outstanding receive ...\n               QUALIFY=SPEC,          ... for conversation ...\n               RPL=LU62RPL,           ... with other application\n               AREA=LU62DATA,\n               AAREA=LU62RPLX,\n               CONVID=LU62CID,\n               OPTCD=SYN\n*\n         LA    R6,LU62RPLX           Set addressability ...\n         USING ISTRPL6X,R6           ... to RPL extension\n         TM    RPL6RCV1,RPL6WCFM     Confirm received ?\n         BNO   SKIPCNFM              Skip confirm\n*\n*   If all is well return a CONFIRMED response\n*\n*            CONFIRMED RESOURCE(LU62CID)\n*\n         APPCCMD CONTROL=SEND,       Send confirmation ...\n               QUALIFY=CONFRMD,       ... response to ...\n               RPL=LU62RPL,           ... partner application\n               AAREA=LU62RPLX,\n               CONVID=LU62CID,\n               RECLEN=0,\n               CONMODE=CS,\n               OPTCD=SYN\n*\n*   If all is not well return a SEND_ERROR response\n*\n*            SEND_ERROR RESOURCE(LU62CID)\n*                       TYPE(PROG)\n*\n         APPCCMD CONTROL=SEND,       Send an error ...\n               QUALIFY=ERROR,         ... response to ...\n               RPL=LU62RPL,           ... partner application\n               AAREA=LU62RPLX,\n               CONVID=LU62CID,\n               TYPE=PROGRAM,\n               RECLEN=0,\n               OPTCD=SYN\n\nThe WHAT_RECEIVED field of the RPL extension must be\nexamined for confirmation request\n(RPL6RCV1=RPL6WCFM). When set, the active transaction\nmust carry out whatever synchronization activity is necessary\nand respond to the initiating transaction with either\nCONTROL=CONFRMD if all is well or CONTROL=ERROR\nif there is a problem. The error type could either be\nTYPE=PROGRAM, which the initiating transaction translates\nas meaning a sync failure, or TYPE=USER with a supplied\nsense code if a more sensitive response is required (ie exactly\nwhat failed). Since synchronization is effectively an LU6.2\nfunction implemented by the application it is arguable that\nTYPE=SERVICE should be the response since a\nsynchronization failure is a service failure. For simplicity,\nTYPE=PROGRAM with accompanying LOG data is\nrecommended.\n\nImplementation of more sophisticated sync point control must\nbe coded in the application. A previous article in this series\nstrongly recommended the use of GDS for all conversation\nexchanges. If this recommendation is followed, sync point\ncontrol can flow easily in the normal data flow if a set of GDS-\nids which correspond to sync point control and response is\ndefined. The partner applications must contain logic to detect\nthese GDS-ids and act accordingly. This brings us neatly onto\nanother LU6.2 function which is only nominally supported.\n\n\nConversation Mapping\n\nData flow normally consists of logical records and, with a basic\nconversation, the receiving transaction must interpret the\nstructure and format of the data. The LU6.2 architecture\nsupports the concept of mapped conversations. Data flow in a\nmapped conversation is formatted by data formatting services\nin what is effectively an SNA presentation services layer\nimplementation. That at least is the theory and the SNA\nTransaction Programmers Reference manual for LU6.2\nexpands on mapped conversations at great length. However,\ndocumentation relating to the APPCCMD macro interface to\nthe VTAM LU6.2 support routines is quite explicit that the API\ndoes not support mapped conversations. Rather, it is suggested\nthat the application must provide its own API to translate\nmapped conversation requests into APPCCMD macros. The\nonly concession is that the standard FMH5 contains a flag\n(FM5RSCTP) which can be set to enable agreement between\napplications on whether conversation mapping is to be used:\n\no      FM5RSCTP=FM5BASIC - basic conversation\n\no      FM5RSCTP=FM5MAPED - mapped conversation.\n\nApart from that it is up to you. VTAM only supports basic\nconversations. Mapped conversations are probably only of\nvalue when fixed format data is involved such as when screen\nimages are being exchanged in a query/response transaction.\nApart from that, there is a vague hint that sync point control\nmay be placed in mapped conversations. This is probably\nbecause synchronization control is a function of the\npresentation services layer in the ISO network model.\n\nAs stated earlier, conversation-level security, synchronization,\nand mapping agreement are implemented via the FMH5 during\nconversation allocation. The following code illustrates how this\nis achieved (note that for completeness the full formatting of\nthe FMH5 is shown - this includes merging details from coding\nexamples in previous articles):\n\nConversation initiator\n\n         LA    R5,LU62FMH5           Address Skeleton ...\n         USING ISTFM5,R5             ... FMH5\n         MVI   FM5LENTH,X'0F'        Length of FMH5 header\n         OI    FM5FLAG1,FM5TYPE5     Set FMH type 5\n         MVC   FM5TYPE,X'02FF'       Set FMH5 type=attach\n*\n         OI    FM5RSCTP,FM5MAPED     Indicate mapped conversation\n*\n         OI    FM5FLAG3,FM5CSB       Indicate full sync support\n*\n         MVC   FM5TPNAM,LU62TPNM     Transaction name and...\n         MVI   FM5LNTPN,X'05'        ... length in FMH5\n*\n         OI    FM5FLAG2,FM5UIDAV     Show userid verified\n         LA    R6,18(,R5)            Address access security ...\n         USING FM5ASI,R6             ... information subfields\n         MVI   FM5LNASI,X'09'        Set ASI subfields length\n         LA    R6,FM5ASEC            Point to ASI subfields\n         DROP  R6                     Drop ASI addressability\n         USING FM5ACCSE,R6           Address ASI subfield\n         MVI   FM5ASLL,X'08'         Set length of subfield\n         OI    FM5ASTY,FM5ASIID      Set subfield type = userid\n         MVC   FM5ASDA(7),LU62USER   Set userid in subfield\n*\n         DROP  R6                    Drop ASI addressability\n         LA    R6,9(,R6)             Skip past ASI fields\n         USING FM5LUOW1,R6           Address LUW identifier field\n         MVI   FM5LNLUW,X'00'        Set LUW length to zero\n*\n         DROP  R6                    Drop LUW addressability\n         LA    R6,1(,R6)             Skip past LUW fields\n         USING FM5CVCOR,R6           Address correlator field\n         MVI   FM5LNCCS,X'00'        Set length to zero\n*\n         DROP  R6\n         OI    FM5FLAG2,FM5PIPPR     Set PIP=YES indicator\n         LA    R6,1(,R6)             Address PIP data ...\n         USING FM5PIPFM,R6           ... field in FMH5\n         MVC   FM5PIPGD,=X'12F5'     Set PIP data GDS ID\n         MVC   FM5PIPLN,=X'0019'     Set PIP data GDS length\n*\n         LA    R6,4(,R6)             Address PIP subfields ...\n         USING FM5PIPSM,R6           ... in FMH5\n         MVC   FM5PIPSG,=X'12E2'     Set subfield GDS ID\n         MVC   FM5PIPSL,=X'0009'     Set subfield GDS length\n         MVC   FM5PIPSD,=C'LEVEL'    Move data to PIP subfield\n*\n         LA    R6,9(,R6)             Address next PIP subfield\n         MVC   FM5PIPSG,=X'12E2'     Set subfield GDS ID\n         MVC   FM5PIPSL,=X'000C'     Set subfield GDS length\n         MVC   FM5PIPSD,=C'01017896' Move data to PIP subfield\n*\n*        ALLOCATE   LU_NAME(PARTNER)\n*                   TPN(LU62TPNM)\n*                   SECURITY(PGM(USER_ID(user-id)))\n*                   SYNC_LEVEL(SYNCPT)\n*                   TYPE(BASIC_CONVERSATION)\n*                   PIP(YES)\n*\n         APPCCMD CONTROL=ALLOC,\n               QUALIFY=ALLOCD,\n               RPL=LU62RPL,\n               ACB=LU62ACB,\n               LUNAME=LU62PLU,\n               LOGMODE=LU62MODE,\n               AREA=LU62FMH5,\n               RECLEN=63,\n               OPTCD=SYN,\n               AAREA=LU62RPLX\nLU62RPL  RPL    AM=VTAM\nLU62RPLX ISTRPL6\nLU62ACB  ACB   AM=VTAM,MACRF=LOGON,APPLID=LU62NAME\nLU62NAME DC    XL1'08',C'LU62APPL'\nLU62PLU  DC    XL1'07',C'PARTNER'\nLU62USER DC    C'USER001'\nLU62CID  DS    XL4\nLU62FMH5 DS    XL255\nLU62TPNM DC    C'STOCK'\n         ISTFM5\n\nNow a word of caution: there is a wonderful inconsistency in\nthe formatting of the data areas of the FMH5. Each data\nstructure begins with a length field which shows how much\ndata is present. For all cases except the PIP data field and\nsubfields, this length does not include the length field itself.\nThe PIP data is different because it is delivered  as a GDS data\nstructure to the partner application.\n\nConversation partner ATTN exit\n\nATTN     DS    0H\n         Entry protocol\n         CLC   12(4,R1),=C'FMH5'     ATTN driven for FMH5 ?\n         BE    ATTNFMH5\n         .\n         .\n*\nATTNFMH5 DS    0H\n         APPCCMD CONTROL=RCVFMH5,    Receive the ...\n               RPL=LU62RPL,           ... FMH5 sent ...\n               ACB=LU62ACB,           ... by the ...\n               AREA=LU62FMH5,         ... conversation ...\n               AAREA=LU62RPLX,        ... initiator\n               AREALEN=255,\n               OPTCD=SYN\n         LA    R6,LU62RPLX           Set addressability ...\n         USING ISTRPL6X,R6           ... to RPL extension\n         MVC   LU62LUNM,RPL6LU       Extract LU name ...\n         MVC   LU62MODE,RPL6MODE     ... session mode ...\n         MVC   LU62CID,RPL6CNVD      ... and conversation id\n         DROP  R6\n*\n         LA    R5,LU62FMH5           Set addressability ...\n         USING ISTFM5,R5             ... to FMH5\n         TM    FM5RSCTP,FM5MAPED     Mapped conversation ?\n\n         TM    FM5FLAG3,FM5CSB       Sync support ?\n\n         SR    R6,R6                 Length of FMH5 fixed ...\n         IC    R6,FM5LENTH           ... portion in R6\n         AR    R6,R5                 Point R6 to ASI\n         USING FM5ASI,R6             Address ASI in FMH5\n         CLI   FM5LNASI,X'00'        ASI fields present ?\n         BE    SKIPASI\n         .\n         .\nSKIPASI  DS    0H\n         SR    R2,R2                 Skip past ...\n         IC    R2,FM5LNASI           ... ASI fields ...\n         LA    R2,1(,R2)             ... in FMH5\n         AR    R6,R2\n         DROP  R6\n         USING FM5LUOW1,R6\n         CLI   FM5LNLUW,X'00'        LUW present ?\n         BE    SKIPLUW\n         .\n         .\nSKIPLUW  DS    0H\n         IC    R2,FM5LNLUWI          Skip past ...\n         LA    R2,1(,R2)             ... LUW fields ...\n         AR    R6,R2                 ... in FMH5\n         DROP  R6\n         USING FM5CVCOR,R6\n         CLI   FM5LNCCS,X'00'        Correlator field present ?\n         BE    SKIPCOR\n         .\n         .\nSKIPCOR  DS    0H\n         TM    FM5FLAG2,FM5PIPPR     PIP data present ?\n         BNO   SKIPPIP\n         LA    R2,DATABUFF\nPIPRCV   DS    0H\n         APPCCMD CONTROL=RECEIVE,    Receive PIP data\n               RPL=LU62RPL,\n               ACB=LU62ACB,\n               CONVID=LU62CID,\n               AREA=(2),\n               AREALEN=PIPDLEN,\n               FILL=LL,\n               QUALIFY=SPEC,\n               OPTCD=SYN\n         TM    RPL6RCV1,RPL6WDAC     Complete PIP record ?\n         BO    ALLPIP                Proceed\n         TM    RPL6RCV1,RPL6WDAI     More PIP data to come ?\n         BNO   ERROR                 Must be a problem\n         LA    R2,24(,R2)            Move area along buffer\n         B     PIPRCV                Go receive some more\nALLPIP   DS    0H\n         LA    R6,DATABUFF           Address PIP data ...\n         USING FM5PIPFM,R6           ... in logical record\n         CLC   FM5PIPGD,=X'12F5'     Verify valid PIP GDS id\n         BNE   BADPIP                Error if not\n         LH    R2,FM5PIPLN           PIP data length in R2\n         LA    R6,4(,R6)             Address PIP subfields ...\n         USING FM5PIPSM,R6           ... in logical record\n         SH    R2,=H'4'              Decrement PIP data length\n         LA    R4,PIPPARM1           Address first PIP parm\nPIPLOOP  DS    0H\n         CLC   FM5PIPSG,=X'12E2'    Valid PIP subfield GDS id ?\n         BNE   BADPIP               Error if not\n         SR    R3,R3\n         ICM   R3,3,FM5PIPSL        Length of PIP subfield\n         SH    R3,=H'3'             Prepare for execute move\n         EX    R3,MOVEDATA          Move data to parm list\n         LA    R4,20(,R4)           Prepare to extract next parm\n         CLI   0(R4),X'FF'          Too many PIP parms ?\n         BE    TOOMANY              Exit loop\n         SR    R2,R3                Decrement PIP data length\n         LTR   R2,R2                End of PIP data subfields ?\n         BNZ   PIPLOOP              Continue if not\n*\nSKIPPIP  DS    0H\n         .     .\n*\nMOVEDATA MVC   0(0,R4),4(R6)\n*\nPIPDLEN  DC    H'48'\nPIPPARM1 DC    CL20' '\nPIPPARM2 DC    CL20' '\n    .     .       .\n    .     .       .\nPIPPARMn DC    CL20' '\n         DC    X'FF'\nDATABUFF DS    4000X\n\nThe partner transaction issues a CONTROL=RCVFMH5 to\nobtain the FMH5. The maximum possible length of the FMH5\nis 255 bytes so always allow for this; the actual length will be\nin the FMH5 itself (FM5LENTH) or it can be found in the\nRECLEN field of the RPL. Use should be made of an identical\nmapping DSECT to extract the formatted data from the FMH5\n- the code will obviously be the reverse of the originating\napplication that formatted the FMH5. Note that it is essential to\nensure that the DSECTs are at the same SNA version and\nrelease level. Remember that the PIP data must be obtained by\na subsequent CONTROL=RECEIVE as it is not logically part\nof the FMH5 - the FMH5 simply contains an indicator that PIP\ndata is available.\n\nIt is highly likely that there will be a rapid expansion in the\nnumber and scope of the functions and facilities of LU6.2 - the\ncurrent level of support in VTAM is fairly basic but provides a\nplatform on which to build.\n\n\nBrian Alford\nSystems Consultant\nAranda (UK)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N005A04": {"ttr": 5897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x16\\x05O\\x01\\x16\\x06/\\x12F\\x01\\xfb\\x01\\xfb\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T12:46:02", "lines": 507, "newlines": 507, "modlines": 0, "user": "SNAUPDT"}, "text": "A VTAM front-end for automatic sign-ons\n\nOur shop recently developed a public information system using\nCA-ROSCOE. While the development was made very easy\nusing the RPF language, we had a problem with sign-ons to the\nsystem: CA-ROSCOE will not allow a particular user-id to be\nsigned on more than once to a particular CA-ROSCOE region.\n\nTo overcome this problem, I created a VTAM application\nfront-end to assign a user-id and password and pass this\ninformation (and the terminal) to a particular CA-ROSCOE\nregion. The information is passed in the terminal's log-on\nmessage: CA-ROSCOE will interpret 'xxxxxxxx/yyyyyyyy' as\na user-id/password combination and attempt a sign-on for that\nuser-id.\n\nThe VTAM front-end, called PUBLIC, receives terminals via a\nlog-on exit. It then scans an array of potential user-ids. When\nan entry of binary zeros (each entry being 8 bytes) is found, the\nterminal LU name is placed in the entry to mark its use. A\nuser-id is then generated from the current array position and the\nterminal is passed with the right log-on message to a CA-\nROSCOE region.\n\nThe array table contains 100 8-byte entries, and the generated\nuser-ids will have a suffix ranging from '00' to '99'. Since\nmultiple CA-ROSCOE regions can share the same libraries,\nvirtually unlimited (concurrent) use of the original 100 user-ids\ncan be made, if the array table is enlarged for each potential\nCA-ROSCOE region. (Each region needs space for 100 8-byte\nentries.)\n\nWhen a user logs off one of the CA-ROSCOE regions, an exit\ninside the region is driven and a system command is issued,\nnotifying PUBLIC that a particular terminal has logged off\nfrom a CA-ROSCOE region. PUBLIC will find the LU name\nin its user-id table and zeroize the entry.\n\nOne minor problem with PUBLIC is that it does not perform an\nOPNDST on terminals it receives - only a CLSDST with PASS\nto the appropriate CA-ROSCOE region. This may cause other\nVTAM applications which passed the terminal to PUBLIC in\nthe first place (such as CL/MENU) to complain about the\nterminal not being picked up by PUBLIC. If desired, an\nOPNDST can be inserted into PUBLIC's log-on exit to stop\nthis.\n\nAnother problem concerns terminals which suffer hardware\nproblems and which are marked in VTAM tables as having a\ndefault owner of PUBLIC. It is possible for terminals to rapidly\nfail and come back on-line - this will cause PUBLIC to fill up\nits user-id table very fast. One possible solution might be to\nscan the table completely just to see if the LU is already in the\ntable. Of course, the larger the table, the more the CPU will be\nutilized performing this task.\n\nWith some modifications, this code could be used for other\nVTAM applications. It might be useful for other situations\nwhere several identical servers are first examined and the user\nis then transferred to the least-busy environment.\n\n\nPUBLIC SOURCE CODE\n\n*  THIS CODE HAS BEEN DEVELOPED USING ASSEMBLER H UNDER VTAM 3.2,\n*  IN AN MVS/XA 2.2.0 ENVIRONMENT.\n*  THE FOLLOWING VTAM INITIALIZATION STATEMENTS ARE NEEDED IN\n*  SOME MEMBER IN SYS1.VTAMLST:\n*                VBUILD TYPE=APPL\n*        PUBLIC  APPL   EAS=10,AUTH=(ACQ,PASS)\n*  THE APPLID SHOULD BE AVAILABLE WHEN THIS PROGRAM STARTS UP.  YOU CAN\n*  CHANGE THE NAME \"PUBLIC\" TO WHATEVER YOU WANT BUT YOU MUST ALSO\n*  CHANGE THE NAME IN THE DATA AREAS PORTION OF THIS CODE.  OTHER\n*  SECTIONS OF THIS PROGRAM MAY NEED TO BE CHANGED FOR YOUR USE,\n*  SO EXAMINE IT CAREFULLY.\n*  THIS PGM MUST BE IN AN APF LIBRARY FOR IT TO BE NON-SWAPPABLE\n*  (RECOMMENDED).  SPECIFY IN SCHEDXX.  THE PGM SHOULD BE LINKED AC=0.\n*  INCLUDE SYS1.MACLIB AND SYS1.AMODGEN IN THE SYSLIB CARD DURING\n*  ASSEMBLY.\nPUBLIC   CSECT\n         STM   R14,R12,12(R13)         SAVE REGISTERS\n         LR    R12,R15                 ESTABLISH ADDRESSABILITY\n         USING PUBLIC,R12\n         LA    R11,SAVEAREA            SET UP OUR SAVE AREA\n         ST    R13,4(R11)\n         ST    R11,8(R13)\n         LR    R13,R11\n*  GET USERID STORAGE\n         LH    R3,ROSNUM      GET NUMBER OF ADDRESS SPACES\n         MH    R3,=H'800'     MULTIPLY BY SPACE NEEDED FOR 100 USERIDS\n         LR    R0,R3                     GETMAIN SPACE\n         GETMAIN RC,LV=(0),BNDRY=DBLWD\n         LTR   R15,R15                   TEST RESULTS\n         BZ    GMOK\n         WTO   'GETMAIN FAILURE--EXITING',ROUTCDE=11\n         B     EXIT\nGMOK     ST    R1,USERIDS                SAVE ADDRESS TO USERID ARRAY\n*  OPEN VTAM ACB\n         OPEN  PUBACB\n         LTR   R15,R15                   TEST RESULTS\n         BZ    OPENOK\n         WTO   'PUBLIC ACB OPEN FAILURE',ROUTCDE=11,DESC=11\n         B     EXIT\n*  ENABLE LOGONS\nOPENOK   SETLOGON RPL=PUBRPL1,ACB=PUBACB,OPTCD=(SYN,START)\n         LTR   R15,R15                   TEST RESULTS\n         BZ    GETCOMM\n         WTO   'SETLOGON FAILED FOR PUBLIC',ROUTCDE=11,DESC=11\n         B     EXIT\n*  SETUP PROGRAM ANSWER AREA\nGETCOMM  LA    R3,ANSWER                 POINT AT ANSWER WORD\n         EXTRACT (3),FIELDS=COMM\n         L     R3,ANSWER                 GET COMLIST ADDRESS\n         USING COMLIST,R3\n         L     R4,COMCIBPT               GET POINTER TO CIB\n         USING CIBNEXT,R4\n*  REMOVE START CIB & SETUP FOR 100 SIMULTANEOUS OPER CMDS (OVERKILL!)\n         CLI   CIBVERB,CIBSTART          IS THIS A START CIB?\n         BNE   SETMOD                    IF NOT, IGNORE; ELSE REMOVE\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(4)\n         LTR   R15,R15                   TEST RESULTS\n         BZ    SETMOD\n         WTO   'PUBLIC START CIB STILL ON CHAIN',ROUTCDE=11,DESC=11\nSETMOD   QEDIT ORIGIN=COMCIBPT,CIBCTR=100\n         L     R5,COMECBPT               GET ADDR OF CMD ECB PROVIDED\n         ST    R5,LISTECBS               STORE IN WAIT LIST\n* MAIN LOOP.  HERE WE WAIT ON TWO EVENTS--EITHER THE POPPING OF TIMER,\n*             OR THE RECEPTION OF A MODIFY OR STOP COMMAND FROM THE\n*             OPERATOR.  WE NEED THE TIMER WHEN THERE ARE LONG PERIODS\n*             OF INACTIVITY--OTHERWISE, MVS MAY ABEND THE PROGRAM.\nWAITLOOP STIMER REAL,TIMEEXIT,BINTVL=WAIT5\nWAITCIB  WAIT  1,ECBLIST=LISTECBS\n         CLC   WAITECB(4),=F'0'          WAIT OVER-IS THIS A TIMER POP?\n         BE    CHKCMD                    IF NOT, CHECK FOR CMD\n         XC    WAITECB,WAITECB           ELSE IT WAS TIMER-CLEAR & REDO\n         B     WAITLOOP\nCHKCMD   L     R4,COMCIBPT               GET THE ADDR TO THE CMD VERB\n         CLI   CIBVERB,CIBMODFY          IS THIS A MODIFY VERB?\n         BNE   TESTSTOP                  IF NOT, CHECK FOR STOP VERB\n         LH    R6,CIBDATLN               GET MODIFY COMMAND LENGTH\n         C     R6,=F'8'                  IS LENGTH < 8?\n         BL    FREECIB                   IF SO, IGNORE THIS COMMAND\n*                                        (INSERT NEW CMD TESTS HERE)\n         CLC   CIBDATA(8),=CL8'SIGNOFF'  IS THIS A \"SIGNOFF\" COMMAND?\n         BNE   FREECIB                   IF NOT, IGNORE COMMAND\n         C     R6,=F'24'                 SIGNOFF CMD CORRECT LENGTH?\n         BL    FREECIB                   IF NOT, IGNORE CMD\n         L     R7,USERIDS                GET PTR TO USERID ARRAY\n         LH    R8,ROSNUM                 GET # OF CA-ROSCOE ADDR SPACES\n         MH    R8,=H'100'                MUL BY MAX # OF IDS IN EACH AS\nFREELOOP CLC   0(8,R7),CIBDATA+16        SEARCH FOR MATCH OF LU NAMES\n         BE    FREELOO2                  BRANCH IF LU NAME MATCHED\n         LA    R7,8(R7)                  INCREMENT ID POINTER\n         BCT   R8,FREELOOP               CONTINUE LOOPING\n         B     FREECIB                   IGNORE CMD IF LU NOT MATCHED\nFREELOO2 MVC   0(8,R7),=D'0'             ZERO LUNAME (CAN NOW REUSE)\n         L     R7,CURRENT                GET CURRENT LOGON COUNT\n         BCTR  R7,R0                     DECREMENT CURRENT LOGON COUNT\n         ST    R7,CURRENT                SAVE CURRENT LOGON COUNT\n*                                        FREE THE MODIFY CIB\nFREECIB  QEDIT ORIGIN=COMCIBPT,BLOCK=(4)\n         B     WAITCIB                   GO WAIT FOR NEXT EVENT\nTESTSTOP CLI   CIBVERB,CIBSTOP           STOP COMMAND?\n         BNE   ERROR                     IF NOT, WE HAVE AN ERROR\n*                                        IF STOP CIB, FREE IT AND EXIT\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(4)\n*  CLOSE VTAM ACB\nCLOSEACB CLOSE PUBACB\n*                                        CANCEL THE TIMER\n         TTIMER CANCEL\n* STATISTICS ARE NOW WRITTEN TO THE SYSTEM LOG (A LOG FILE MIGHT\n* BE BETTER)\n         L     R7,HISIGNON               ISSUE HIGH WATER MARK MESSAGE\n         CVD   R7,DECIMAL\n         UNPK  WTOMSG+8(4),DECIMAL+6(2)\n         OI    WTOMSG+11,X'F0'\nWTOMSG   WTO 'XXXX PUBLIC IDS WERE THE HIGHEST CONCURRENT NUMBER USED',X\n               ROUTCDE=11\n         L     R7,LOGCOUNT               ISSUE TOTAL LOGON MESSAGE\n         CVD   R7,DECIMAL\n         UNPK  WTOMSG2+8(6),DECIMAL+4(4)\n         OI    WTOMSG2+13,X'F0'\nWTOMSG2  WTO   'XXXXXX TOTAL LOGONS OCCURRED',ROUTCDE=11\nEXIT     L     R13,4(R13)                RESTORE REGISTERS\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         SR    R15,R15                   SET RETURN CODE\n         BR    R14                       RETURN\n*  ERROR MESSAGE FOR BAD CIBVERB\nERROR    WTO   'PUBLIC CIBVERB NOT MODIFY OR STOP',ROUTCDE=11,DESC=11\n         B     CLOSEACB\n         DROP  R12\n*  LOGONEXIT--THIS EXIT WILL BE INVOKED ASYNCHRONOUSLY TO THE MAIN\n*             PROGRAM, WITH A HIGHER PRIORITY.  LOGONS WILL NOT BE\n*             ACQUIRED, WHICH MAY GENERATE ERROR MESSAGES FROM\n*             OTHER VTAM APPLICATIONS.  TO AVOID THIS, UNCOMMENT\n*             THE OPNDST CODE NEAR THE START OF THIS EXIT.\nLOGONEX  DS    0H\n         USING LOGONEX,R12               ADDRESSABILITY\n         LR    R12,R15\n         LR    R10,R1                    GET ENTRY PARMS\n         L     R4,16(R1)                 GET READ-ONLY RPL\n         USING IFGRPL,R4\n         LR    R9,R14                    SAVE RET ADDR\n         LA    R13,EXITSAVE              ESTABLISH SAVE AREA FOR EXIT\n         L     R7,LOGCOUNT               INCREMENT LOGON COUNT\n         LA    R7,1(R7)\n         ST    R7,LOGCOUNT\n         L     R8,20(R10)                GET CID\n         L     R10,4(R10)                GET PTR TO LU NAME\n*  MODIFY NIB TO HAVE LUNAME\n         MODCB NIB=PUBNIB,AM=VTAM,NAME=(*,0(R10))\n*  GET SESSION PARMS ASSOCIATED WITH THIS LU\n         INQUIRE RPL=PUBRPL,OPTCD=SESSPARM,NIB=PUBNIB,AREA=BINDAR,     X\n               AREALEN=100\n*  UPDATE NIB TO HAVE THE SAME SESSION PARMS\n         MODCB NIB=PUBNIB,AM=VTAM,BNDAREA=BINDAR\n         LA    R10,PUBNIB                POINT TO NIB\n         USING ISTDNIB,R10\n*  UNCOMMENT THIS CODE TO DO \"EMPTY\" OPNDST TO KEEP OTHER VTAM APPLS\n*  FROM SQUAWKING.\n*        OPNDST RPL=PUBRPL,NIB=PUBNIB,OPTCD=(SYN,ACCEPT,SPEC)\n*        TESTCB NIB=PUBNIB,AM=VTAM,CON=YES\n*        BNE   CONFAIL\n*   NOW FIND LOGMODE NAME AND INSERT INTO NIB\nGETLMODE L     R3,RPLAREA                GET RPLAREA FROM READ-ONLY RPL\n         LR    R2,R3\n         A     R2,RPLRLEN                ADD LENGTH\n         DROP  R4\n         ST    R2,CINITEND\n         LA    R4,12(R3)                 START OF BIND IMAGE\n         SR    R2,R2\n         ICM   R2,3,10(R3)               GET BIND LENGTH\n         AR    R4,R2                     PAST BIND/START OF SLU TYPE\n         LA    R3,2(R4)                  START OF SLU SYMBOL NAME\n         SR    R2,R2\n         IC    R2,1(R4)                  LENGTH OF SLU SYMBOL NAME\n         AR    R3,R2                     POINT PAST SLU SYM NAME\n         LA    R3,2(R3)                  POINT PAST RETIRED FIELDS\n         LA    R4,1(R3)                  POINT AT START OF USER DATA\n         SR    R2,R2\n         IC    R2,0(R3)                  GET LENGTH OF USER DATA\n         AR    R4,R2                     POINT PAST USER DATA\n         LA    R3,2(R4)                  POINT AT STRT OF DEV CHAR INFO\n         SR    R2,R2\n         ICM   R2,3,0(R4)                GET LENGTH OF DEV CHAR INFO\n         AR    R3,R2                     POINT PAST USER DATA\n         LA    R4,1(R3)                  PNT AT STRT OF SESS CRYPT DATA\n         SR    R2,R2\n         IC    R2,0(R3)                  GET LENGTH OF SESS CRYPT DATA\n         AR    R4,R2                     PNT PAST C DATA TO CTRL VECS\n         C     R4,CINITEND\n         BNL   NOVECTOR\n*                                        FIND THE VECTOR\nCHECKVEC CLI   0(R4),X'0D'               (AND THE ASSOC LOGMODE)\n         BNE   NEXTVECT                  B IF NOT RIGHT VECTOR\n         MODCB AM=VTAM,NIB=PUBNIB,LOGMODE=(*,2(R4))\n         B     VECFOUND                  NIB NOW UPDATED W/ RIGHT LMODE\nNEXTVECT LA    R3,2(R4)                  GO TO NEXT VECTOR IF IT EXISTS\n         SR    R2,R2\n         IC    R2,1(R4)\n         AR    R3,R2\n         LR    R4,R3\nENDCHECK C     R4,CINITEND\n         BL    CHECKVEC                  B IF THERE ARE MORE VECTORS\n*                                        NO LOGMODE--TAKE DEFAULT\nNOVECTOR MODCB AM=VTAM,NIB=PUBNIB,LOGMODE=LMDUMMY\n* LOOK FOR TERMID (IN NIB) IN OUR ARRAY--IF NO HIT, WE\n* SHOULD CLSDST,PASS AND SAVE TERMID TO MARK USERID AS USED.\n* IF THERE'S A HIT, SOMETHING'S WRONG AND\n* WE SHOULD RELEASE USERID AND CLSDST,NOPASS.\nVECFOUND EQU   0H\n*  OPTIONAL SEND TO LU TO CONFIRM IT HAS BEEN ACQUIRED\n*        SEND RPL=PUBRPL,CHAIN=ONLY,BRACKET=(BB,EB),ACB=PUBACB,       X\n*              OPTCD=(SYN),RESPOND=(NEX,NFME,NRRN),STYPE=REQ,         X\n*              CONTROL=DATA,AREA=WAITMSG,RECLEN=39,ARG=(R8)\n         L     R2,USERIDS                POINT AT \"USERID\" AREA\n         LR    R3,R2                     DUPLICATE POINTER\n         LH    R7,ROSNUM                 GET NUMBER OF ADDRESS SPACES\nU2LOOP0  LA    R4,100                    SET LOOP CNT FOR MAX # PER AS\nU2LOOP   CLC   0(8,R3),=D'0'             TEST FOR FREE \"USERID\"\n         BE    U2LOOPF                   BRANCH IF FOUND\n         LA    R3,8(R3)                  POINT TO NEXT USERID\n         BCT   R4,U2LOOP                 CONTINUE TILL DONE FOR AS\n         A     R2,=F'800'                POINT TO NEXT BANK OF USERIDS\n         BCT   R7,U2LOOP0                CONTINUE TILL DONE FOR ALL AS\n         B     NOPASSLU                  EXIT-DO NOT PASS LU-CODE COULD\n*                                    DO AN OPNDST AND DISPLAY ERRORMSG\nU2LOOPF  LR    R6,R7              GET ADDRESS SPACE (AS) \"NUMBER\"\n         MH    R6,=H'8'           MULTIPLY BY LENGTH OF AS NAME\n         A     R6,=AL4(ROSTABL)   ADD AS NAME TABLE START ADDRESS\n*                                 SET NIB TO HAVE NAME OF TARGET AS\n         MODCB NIB=PUBNIB1,NAME=(*,0(R6))\n*                                 IS THIS AS UP AND AVAILABLE?\n         INQUIRE RPL=PUBRPL,ACB=PUBACB,OPTCD=APPSTAT,NIB=PUBNIB1\n         TESTCB  RPL=PUBRPL,FDBK=0\n         BE    U2LOOPG            IF SO, CALC LOGDATA AND PASS LU TO IT\n         LR    R3,R2              A PARTICULAR AS ISN'T AVAILABLE, SO\n         A     R3,=F'800'           JUMP PAST USERIDS FOR IT AND TRY TO\n         LR    R2,R3                ASSIGN A USERID FROM ANOTHER\n         BCT   R7,U2LOOP0           ADDRESS SPACE FOR THIS LU\n         B     NOPASSLU           NO IDS LEFT--ABANDON THIS LU\n*  CALCULATE THE USERID/PASSWORD TO BE USED AND PASS THE LU TO THE\n*  ADDRESS SPACE.  NOTE--THE CALCULATED USERID/PASSWORD COMBINATION\n*  IS FORMATTED FOR CA-ROSCOE ENVIRONS.  TSO ALSO ALLOWS FOR AUTOMATIC\n*  SIGNONS, BUT USES A DIFFERENT FORMAT.\n*  THE CA-ROSCOE FORMAT IS \"USERID/PASSWORD\".  A \"SIGNON PROCEDURE\" CAN\n*  BE ESTABLISHED FOR A PARTICULAR USERID AND THE USERID CAN THEN BE\n*  RESTRICTED.\nU2LOOPG  LA    R5,100                   GET MAX NUMBER OF IDS PER AS\n         SR    R5,R4                    SUBTRACT IDS ALREADY PASSED OUT\n         SR    R4,R4                    CLEAR R4 FOR DIVISION\n         D     R4,=F'10'                / BY 10 TO GET 10S & 1S DIGITS\n         O     R4,=F'240'               OR EACH DIGIT WITH X'F0'\n         O     R5,=F'240'               ... DIGITS NOW READABLE\n*  WE NOW HAVE THE CORRECT USERID NUMBER (00 THROUGH 99).  THIS WILL\n*  BE SUFFIXED TO THE GENERIC NAME FOR ALL USERIDS.  TOTAL LENGTH FOR\n*  MY USERIDS IS 4 CHARACTERS, WITH A COMMON PREFIX OF 2 CHARACTERS.\n*  YOUR IDS CAN HAVE A COMMON PREFIX OF BETWEEN 1 AND 6 CHARACTERS.\n*  THE COMMON PASSWORD IS THE SAME FOR ALL ID'S.\n         MVC   LOGMSG(2),=CL2'ZZ'       WRITE COMMON PREFIX\n         STC   R5,LOGMSG+2              WRITE 10S DIGIT\n         STC   R4,LOGMSG+3              WRITE 1S DIGIT\n         MVI   LOGMSG+4,C'/'               WRITE SEPERATOR\n         MVC   LOGMSG+5(8),=CL8'ZZZZZZZZ'  WRITE COMMON PASSWORD\n         MVC   LOGMSG+13(87),=XL87'00'     NULL REST OF LOGON MESSAGE\n         MVC   0(8,R3),NIBSYM           MOVE LUNAME INTO \"USERID\" SLOT\nINCLOG   L     R7,CURRENT\n         LA    R7,1(R7)           INCREMENT CURRENT LOGIN COUNT\n         ST    R7,CURRENT\n         C     R7,HISIGNON        IF THIS IS A NEW HIGH WATER MARK,\n         BL    PASSLU\n         ST    R7,HISIGNON        SAVE NEW NUMBER & TEST THRESHOLDS\nTEST50   L     R5,=F'50'\n         MH    R5,ROSNUM          CALCULATE 50% OF POSSIBLE USERIDS\n         CR    R7,R5              COMPARE HIGH WATER MARK\n         BL    PASSLU             PASS THE LU IF HWM < 50% THRESHOLD\n         CLI   P50FLAG,C'Y'       50% THRESHOLD ALREADY PASSED?\n         BE    TEST85             IF SO, TEST FOR 85% THRESHOLD\n         WTO   '50% OF THE PUBLIC IDS ARE IN USE--NOTIFY TSG',         X\n               ROUTCDE=11,DESC=11\n         MVI   P50FLAG,C'Y'       SET 50% THRESHOLD MESSAGE FLAG\n         B     PASSLU             GO PASS THE LU\nTEST85   L     R5,=F'85'\n         MH    R5,ROSNUM          CALCULATE 85% OF POSSIBLE USERIDS\n         CR    R7,R5              COMPARE WITH HIGH WATER MARK\n         BL    PASSLU             PASS THE LU IF HWM < 85% THRESHOLD\n         CLI   P85FLAG,C'Y'       85% THRESHOLD ALREADY PASSED?\n         BE    PASSLU             IF SO, JUST PASS LU\n         WTO   '85% OF THE PUBLIC IDS ARE IN USE--NOTIFY TSG',         X\n               ROUTCDE=11,DESC=11\n         MVI   P85FLAG,C'Y'       SET 85% THRESHOLD MESSAGE FLAG\n*  PASS THE LU TO THE APPROPRIATE CA-ROSCOE REGION, WITH THE RIGHT\n*  LOGON INFORMATION IN THE LOGON MESSAGE.\n*  CHANGE THE RECLEN PARM TO MATCH YOUR LOGON MESSAGE LENGTH.\nPASSLU   CLSDST RPL=PUBRPL,OPTCD=(SYN,PASS),NIB=PUBNIB,                X\n               RECLEN=13,AREA=LOGMSG,AAREA=(R6)\n         B     EXITLOGE\n*  DON'T PASS THE LU TO A CA-ROSCOE REGION--JUST LET VTAM HAVE IT BACK\nNOPASSLU CLSDST RPL=PUBRPL,OPTCD=(SYN,RELEASE),NIB=PUBNIB\nEXITLOGE BR    R9                 EXIT THE LOGON EXIT\n         DROP  R12\n*  STIMER EXIT--THIS EXIT WILL BE TAKE WHEN THE TIMER POPS\nTIMEEXIT DS    0H\n         LR    R12,R15                   ADDRESSABILITY\n         USING TIMEEXIT,R12\n         LR    R8,R14                    SAVE RETURN ADDRESS\n         POST  WAITECB                   POST THE TIMER ECB\n         BR    R8                        RETURN FROM EXIT\n         DROP  R12\n*  DATA AREAS\nEXITSAVE DS    18F                       EXIT SAVE AREA\nSAVEAREA DS    18F                       MAIN PGM SAVE AREA\nCINITEND DS    F\nBINDAR   DS    CL100                     BIND DATA AREA\nWAIT5    DC    F'30000'                  CONSTANT FOR 5 MINUTE WAIT\nLMDUMMY  DC    XL8'0000000000000000'     DUMMY LOGMODE NAME\n*  THE FOLLOWING AREAS SHOULD BE CHANGED/ELIMINATED TO MATCH CONDITIONS\n*  AT YOUR SITE.  ALSO,\n*  PLEASE CHANGE THE RECLEN PARM AT LABEL \"PASSLU\" FOR THE CORRECT\n*  LOGON MESSAGE LENGTH.\nPGMNAME  DC    XL1'08'                   APPLID NAME LENGTH\n         DC    CL8'PUBLIC'               APPLID NAME\n*  CA-ROSCOE APPLID NAME ARRAY.  FIRST ELEMENT IS ALWAYS 8 BLANKS.\n*  LUS WILL BE PASSED TO THE LOWEST ADDRESS SPACE NAMED IN THE ARRAY,\n*  UNTIL ITS CAPACITY IS EXAUSTED, AND THEN USE THE NEXT HIGHEST\n*  ADDRESS SPACE.\n*  NOTE!  THESE NAMES ARE THE VTAM APPLIDS--NOT THE STARTED TASK NAMES.\nROSTABL  DC    CL8' '\n         DC    CL8'ROSRGN2'              2ND CA-ROSCOE AS APPLID\n         DC    CL8'ROSRGN1'              1ST CA-ROSCOE AS APPLID\nROSNUM   DC    H'2'                      NUMBER OF CA-ROSCOE AS'S\nLOGMSG   DS    CL100                     LOGON MESSAGE\n*                                        NIB TO CHECK APPL AVAILABILITY\n*                                        CHANGE INITIAL NAME\nPUBNIB1  NIB   NAME=ROSRGN1\n*                                        NIB FOR LUS\nPUBNIB   NIB   MODE=RECORD\nPUBRPL1  RPL   AM=VTAM,ACB=PUBACB,OPTCD=SYN\nPUBRPL   RPL   AM=VTAM,ACB=PUBACB,OPTCD=SYN\nPUBACB   ACB   AM=VTAM,APPLID=PGMNAME,MACRF=LOGON,EXLST=PUBEXLST\nPUBEXLST EXLST AM=VTAM,LOGON=LOGONEX\n*                                        OPTIONAL MSG AFTER OPNDST\nWAITMSG  DC    X'F5C3114EC71DE0',C'Logging on ... please be patient'\nP50FLAG  DC    C'N'                      THRESHOLD FLAGS\nP85FLAG  DC    C'N'\nDECIMAL  DS    D                         WORK AREA\nHISIGNON DC    F'0'                      HIGH WATER MARK FIELD\nCURRENT  DC    F'0'                      CURRENT NUMBER OF SIGNONS\nLOGCOUNT DC    F'0'                      TOTAL COUNT OF LOGONS\nANSWER   DS    F                         EXTRACT PTR\nLISTECBS DS    A                         THIS WILL PT TO THE CIB ECB\n         DC    X'80',AL3(WAITECB)        THIS WILL PT TO THE TIMER ECB\nWAITECB  DC    F'0'\nUSERIDS  DS    F                         PTR TO USERID STORAGE\n         LTORG\n         DSECT\n         IEZCOM\n         DSECT\n         IEZCIB\n         IFGRPL\n         ISTDNIB\n         END\n\n\nSample CA-ROSCOE SMF exit\n\n*  THE FOLLOWING IS A SAMPLE CS-ROSCOE \"SMF\" EXIT.  THIS EXIT IS\n*  DRIVEN WHEN A USER LOGS OFF OR IS KNOCKED OFF OF A CA-ROSCOE\n*  ADDRESS SPACE.  THE EXIT WILL CONSTRUCT AN OPERATOR COMMAND\n*  WHICH WILL NOTIFY THE FRONT END (\"PUBLIC\") THAT A PARTICULAR\n*  LU HAS LEFT A PARTICULAR CA-ROSCOE REGION:\n*         F PUBLIC,SIGNOFF REGNAME LUNAME\n*  PUBLIC WILL SCAN ITS TABLE OF USERIDS, FIND THE LUNAME AND\n*  RELEASE THAT ID FOR ANOTHER LOGON.\n*  FOR THE ASSEMBLY STEP, THE FILES SYS1.MACLIB, SYS1.AMODGEN AND\n*  THE CA-ROSCOE MACLIB FILE SHOULD BE CONCATENATED TO THE SYSLIB\n*  DD STATEMENT.  THE CA-ROSCOE MACLIB FILE SHOULD BE FIRST.\n*  THIS EXIT MUST BE LINK EDITED \"AC=1\".\n*  THIS EXIT HAS BEEN DEVELOPED UNDER CA-ROSCOE 5.6, ASSEMBLER H,\n*  VTAM 3.2 AND MVS/XA 2.2.0.\nSMFEXIT  CSECT\n         USING *,R12                    R12 WILL BE BASE REGISTER\n         STM   R14,R12,12(R13)          SAVE REGISTERS\n         LR    R12,R15                  INIT BASE REG FOR EXIT\n         SR    R7,R7                    CLEAR RETURN CODE\n         LTR   R1,R1                    CHECK PARMLIST\n         BZ    RETURN\nPOSTINIT L     R11,0(R1)                INIT BASE REG FOR UXDSECT\n         USING UXDSECT,R11\n         L     R10,UXCODE\n         L     R3,0(R10)\n         L     R10,UXSCBADR             GET SCB ADDRESS\n         USING SCB,R10\n         L     R9,UXROTADR              GET ROT ADDRESS\n         USING ROT,R9\n         CLC   ROTAPPL(6),=CL6'ROSRGN'  IS THIS AN APPROPRIATE REGION?\n         BNE   RETURN\n         LA    R7,0                     SET CA-ROSCOE RETURN CODE\n         C     R3,=F'4'                 IS THIS A SIGNOFF?\n         BNE   RETURN                   BRANCH IF NOT\n         CLC   SCBFKEY(2),=CL2'ZZ'      PUBLIC ID?\n         BNE   RETURN                   BRANCH IF NOT\n*  BUILD THE MVS MODIFY COMMAND\n         GETMAIN RC,LV=MODLEN,BNDRY=DBLWD\n         LR    R8,R1\n         USING MODIFY,R8\n         MVC   MLENGTH(2),=H'37'\n         MVC   MNULL(2),=H'0'\n         MVC   MCOMMAND(17),=CL17'F PUBLIC,SIGNOFF '\n         MVC   MAPPLID(8),ROTAPPL\n         MVC   MTERMINL(8),SCBTRMNM\n*  ISSUE THE MVS COMMAND\n         MODESET KEY=ZERO,MODE=SUP\n         SR    R0,R0\n         MGCR  MODIFY\n         MODESET KEY=NZERO,MODE=PROB\n         FREEMAIN RC,LV=MODLEN,A=(R8)\nRETURN   EQU   *                        GO BACK TO CA-ROSCOE\n         L     R14,12(R13)              RESTORE R14\n         LR    R15,R7                   SET RETURN CODE\n         C     R3,=F'20'\n         BNE   RETURN2\n         SR    R15,R15\nRETURN2  LM    R2,R12,28(R13)           RESTORE R2 -> R12\n         BR    R14                      GO BACK TO CA-ROSCOE\n         LTORG\n         UXDSECT EXIT=(SMF)\nMODIFY   DSECT\n*                       SAMPLE DATA:\nMLENGTH  DS    H        '37'\nMNULL    DS    H        '0'\n         DS   0CL33\nMCOMMAND DS    CL17     'F PUBLIC,SIGNOFF '\nMAPPLID  DS    CL8      'ROSRGN1 '\nMTERMINL DS    CL8      'TERMNAME'\nMODLEN   EQU   *-MODIFY\n         DS   0H\n         SCB\n         ROT\n         END\n\n\nDavid R Saunders\nSenior Computer System Engineer\nUniversity of Virginia (USA)          c University of Virginia 1992\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N005A05": {"ttr": 6152, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\x97\\x00\\x97\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 151, "newlines": 151, "modlines": 0, "user": "SNAUPDT"}, "text": "A NetView command processor\n\nSince we installed NetView at our installation many of the\ncommand processors that we originally used under TSO have\nbeen converted so that they can be used under NetView. The\nfollowing command processor is used by our Operations\ndepartment to ensure that changes to the MVS LINKLIST\nconcatenation are successful. This command is issued\nautomatically when changes are made to the LINKLIST. The\noperator then checks the output against a list supplied by\nTechnical Support. In the past we have had failures because a\nlibrary was not placed in the LINKLIST and the operators did\nnot realize. We IPL once a month now so this has caused us\nsome problems. The NetView command processor overcomes\nthe problems previously experienced.\n\nIf you require further details about NetView command\nprocessors, the NetView Customization (SC31-6016) and\nNetView Customization Using Assembler  (SC31-6078)\nmanuals will be of use to you.\n\nBLNKLST  CSECT\n*        **************************************************************\n*        * PROGRAM NAME: BLNKLST.                                     *\n*        * PURPOSE:      TO LIST LLA DATASETS AT NETVIEW SCREEN.      *\n*        **************************************************************\n         DSICBS    DSICWB,DSIMVT,DSIPDB,DSISVL,DSISWB,DSITIB,          X\n               DSITVB,PRINT=NO\n         USING     *,R15\n         B         BLNK0010\n         DC        C'BLNKLST  &SYSDATE. AT &SYSTIME.'\nBLNK0010 EQU       *\n         STM       R14,R12,12(R13)     /* SAVE REGISTERS.            */\n         DROP      R15                 /* DROP TEMP BASE.            */\n         LR        R12,R15             /* SET BASE REGISTER.         */\n         USING     BLNKLST,R12         /* ADDRESS R12.               */\n         LR        R11,R1              /* LOAD CWB ADDR.             */\n         USING     DSICWB,R11          /* BASE FOR CWB.              */\n         LA        R1,CWBSAVEA         /* USE CWBSAVEA FOR SAVEAREA. */\n         ST        R1,8(R13)           /* STORE INTO CALLERS SAREA.  */\n         ST        R13,4(R1)           /* STORE CALLERS SA IN MINE.  */\n         LR        R13,R1              /* R13 HAS MY SAVEAREA ADDR.  */\n*        **************************************************************\n*        * ADDRESSABILITY TO THE TASK INFORMATION BLOCK (TIB), THE    *\n*        * TASK VECTOR BLOCK (TVB), AND THE MAIN VECTOR BLOCK (MVT).  *\n*        **************************************************************\n         L          R10,CWBTIB         /* GET DSITIB ADDRESS.        */\n         USING      DSITIB,R10         /* ESTABLISH ADDRESSABILITY.  */\n         L          R9,TIBTVB          /* GET DSITVB ADDRESS.        */\n         USING      DSITVB,R9          /* ESTABLISH ADDRESSABILITY.  */\n         L          R8,TVBMVT          /* GET DSIMVT ADDRESS.        */\n         USING      DSIMVT,R8          /* ESTABLISH ADDRESSABILITY.  */\n         L          R3,16              /* GET ADDRESS OF CVT.        */\n         USING      CVT,R3             /* ADDRESS CVT.               */\n         L          R3,CVTLLTA         /* LOAD CVT FIELD FOR LLA.    */\n         USING      LLAT,R3            /* ESTABLISH ADDR TO LLT.     */\n         LA         R7,LLATDSN         /* POINT TO 1ST DATASET NAME. */\n         SR         R4,R4              /* ZEROIZE REGISTER 4.        */\n*        **************************************************************\n*        * BUILD NETVIEW BUFHDR:-                                     *\n*        * HDRBLENG - TOTAL LENGTH OF BUFFER.                         *\n*        * HDRMLENG - LENGTH OF MESSAGE TEXT.                         *\n*        * HDRTDISP - OFFSET FROM START OF BUFHDR TO START OF MSG     *\n*        *            TEXT.                                           *\n*        * HDRDOMID - CURRENT DOMAIN ID (MVTCURAN).                   *\n*        * HDRMTPE  - MESSAGE TYPE (SET TO USER TYPE MESSAGE).        *\n*        * HDRTSTMP - TIME STAMP.                                     *\n*        **************************************************************\n         USING     BUFHDR,R2           /* ADDRESS IT.                */\n         LA        R2,MSGBUFF          /* GET ADDRESS OF BUFFER.     */\n         MVC       HDRMLENG,=AL2(MSG00L) /* MOVE MSG LENGTH TO BUF.  */\n         LA        R1,BUFHDRND-BUFHDR  /* GET OFFSET TO MSG TEXT.    */\n         STH       R1,HDRTDISP         /* MOVE MSG OFFSET TO BUFFER. */\n         MVC       HDRDOMID,MVTCURAN   /* DOMAIN ID.                 */\n         MVI       HDRMTYPE,HDRTYPEU   /* USER MSG.                  */\n         AH        R1,HDRMLENG         /* MSG LEN+HDRTDISP.          */\n         STH       R1,HDRBLENG         /* STORE BUFFER LEN.          */\nBLNK0020 EQU       *\n         LA        R4,1(R4)            /* INCREMENT COUNTER.         */\n         C         R4,LLATCNT          /* COMPARE NUMBER OF ENTRIES. */\n         BH        BLNKEXIT            /* IF HIGHER BLNKEXIT.        */\n*        **************************************************************\n*        * BUILD THE MESSAGE.                                         *\n*        **************************************************************\n         MVC       MSG,MSG00           /* INIT RE-ENTRANT MSG AREA.  */\n         MVC       MSG+9(44),0(R7) /* MOVE IN DATASET NAME.      */\n         LA        R7,45(R7)           /* INCREMENT POINTER TO NEXT. */\n*        **************************************************************\n*        * DISPLAY THE MESSAGE USING DSIPSS TYPE=OUTPUT.              *\n*        **************************************************************\n         DSIPSS    SWB=CWBSWB,TYPE=OUTPUT,BFR=(R2)\n         B         BLNK0020            /* GO GET NEXT ONE.           */\nBLNKEXIT EQU       *\n         L         R13,4(R13)          /* GET CALLERS SAVEAREA ADDR. */\n         L         R14,12(R13)         /* RESTORE RETURN ADDRESS.    */\n         LM        R0,R12,20(R13)      /* RESTORE REGS.              */\n         BR        R14                 /* RETURN.                    */\n         LTORG\nMSG00    DC    C'BLNK001I                                            '\nMSG00L   EQU       *-MSG00\nDSICWB   DSECT\n         ORG       CWBADATD\nMSGBUFF  DS        0XL((BUFHDRND-BUFHDR)+MSG00L)\n         DS        XL(BUFHDRND-BUFHDR)\nMSG      DS        CL(MSG00L)\n         DS        XL(256-(*-CWBADATD)) /* AUTODATA LENGTH CHECK.    */\n         CVT       DSECT=YES           /* CVT DSECT.                 */\nLLAT     DSECT                         /* DSECT TO MAP STORAGE.      */\nHEADER   DS        CL4'LLT '           /* DSECT LABEL.               */\nLLATCNT  DS        F                   /* NUMBER OF ENTRIES IN TBL.  */\nLLATDSLN DS        X                   /* DATASET LENGTH.            */\nLLATDSN  DS        CL44' '             /* DATASET NAME.              */\n         END\n\n\nASSEMBLY AND LINK-EDIT JCL\n\n//STS01V      JOB   (SDTS),'J.BRADLEY',CLASS=A,MSGCLASS=Q,\n//            MSGLEVEL=(1,1),NOTIFY=STS01\n//*      **************************************************************\n//*      * JOB TO ASSEMBLE AND LINK EDIT COMMAND PROCESSORS IN        *\n//*      * NETVIEW.                                                   *\n//*      **************************************************************\n//ASM1        EXEC  PGM=IEV90,PARM='OBJ,NODECK,XREF(SHORT)'\n//SYSLIB      DD    DSN=SYS1.MACLIB,DISP=SHR\n//            DD    DSN=SYS1.AMODGEN,DISP=SHR\n//            DD    DSN=STS01.BD.MACLIB,DISP=SHR\n//            DD    DSN=SYS1.HASPSRC,DISP=SHR\n//            DD    DSN=SYS1.ATSOMAC,DISP=SHR\n//SYSUT1      DD    UNIT=SYSDA,SPACE=(1700,(600,100))\n//SYSUT2      DD    UNIT=SYSDA,SPACE=(1700,(300,50))\n//SYSUT3      DD    UNIT=SYSDA,SPACE=(1700,(300,50))\n//SYSPRINT    DD    SYSOUT=*\n//SYSLIN      DD    UNIT=SYSDA,SPACE=(80,(200,50)),DISP=(,PASS)\n//SYSIN       DD    DSN=STS01.BD.DATA(BLNKLST),DISP=SHR\n//*\n//LKED1       EXEC  PGM=IEWL,PARM=('MAP,LET,LIST,NCAL,RENT'),\n//            COND=(0,NE,ASM1)\n//SYSUT1      DD    UNIT=SYSDA,SPACE=(1024,(50,20))\n//SYSPRINT    DD    SYSOUT=*\n//SYSLMOD     DD    DSN=CNM.V1R3.USERLNK,DISP=SHR\n//SYSLIB      DD    DSN=*.ASM1.SYSLIN,DISP=(OLD,DELETE)\n//SYSLIN      DD    *\n INCLUDE SYSLIB\n NAME    BLNKLST(R)\n/*\n\n\nJohn Bradley\nSenior Technical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N005A06": {"ttr": 6156, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\xb3\\x00\\xb3\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 179, "newlines": 179, "modlines": 0, "user": "SNAUPDT"}, "text": "Loading NCP through VM\n\nI have read several articles that address problems in loading\nand activating the NCP in VM/VSE environments. Our\nconfiguration consists of VM/SP 1.5 (ACF/VTAM 3.1.1,\nACF/NCP 4.3.1, ACF/SSP 3.5.1, and RSCS 2.3.0) and\nVSE/SP 4.1.1 (ACF/VTAM 3.2.1 and CICS 1,7). Most of our\nremote users are CICS users with some remote printers shared\nbetween CICS and RSCS. Because our 3725 has only one\nchannel adapter and we don't have NCP/SSP in VSE, we need\nto generate and load the 3725 from VM/CMS and activate the\nlines from VSE/VTAM. To do this we have the following\nprocedures.\n\n\nNCP GENERATION\n\nTo generate NCP we use the following EXEC:\n\n/* Provide proper access order for NCP generation */\n'desbuf *'\n'q v stor (fifo'\npull lixo lixo size\nsize = left(size,5)\nif size < 4096 then\n   do\n     say 'At least 4MB machine is necessary to build NCP'\n     say 'A new IPL is necessary (DEF STOR 4MB'\nexit\nend\n'vmfclear'\n'release b'\n'release c'\n'release d'\n'release e'\n'release f'\n'release g'\n'access 343 a'     /* run disk ssp */\n'access 342 b/a'   /* zap disk ssp */\n'access 341 c/a'   /* merge disk ssp */\n'access 340 d/a'   /* delta disk ssp */\n'access 33f e/a'   /* base disk ssp */\n'access 355 f/a'   /* run disk ncp /*\n'access 191 g'     /* maint 191 disk */\n'vmfclear'\nsay 'New access order is:'\nsay\n'QUERY DISK'\nsay\nsay\nsay 'To check NCP syntax enter: VMFAST FN=xxx FT=xxx FM=x'\nSAY 'To build NCP enter: VMNCP FN=xxx FT=xxx FM=x V=V4R3.1 Model=3725'\nexit\n\n\nAlterations to VMNCP EXEC\n\nIn the VMNCP EXEC, the following line:\n\n      'ERASE TABLE2 TEXT'\n\nshould be commented out, preventing the erasure of the file\nTABLE2 TEXT at the end of the NCP generation. This file is\nthe RRT. It will be necessary to link-edit it in VSE to permit\nline activation by VSE/VTAM. This text will be found in the\nrun disk of SSP (343) and should contain the following JCLto\nbe catalogued in the VSE library:\n\n* $$ JOB JNM ...\n// JOB CATRRT\n// LIBDEF *,CATALOG=sublibrary.name\n// EXEC LIBR\n   ACC S=sublibrary.name\n   CATALR xxxx (should be equal parm 'NEWNAME' in BUILD)\n.... put here the table2 text ....\n.... first card is 'esd' ....\n.... last card is 'txt' followed by 'end' card\n/*\n// OPTION CATAL\n// LIBDEF *,SEARCH=sublibrary.name\n// LIBDEF *,CATALOG=sublibrary.name\n PHASE xxxxR,+0,NOAUTO  (xxx should equal NEWNAME\n                       parm in BUILD and be followed by 'R')\n INCLUDE xxxx (equals 'NEWNAME parm in BUILD)\n// EXEC LNKEDT,SIZE=128K\n/*\n/&\n* $$ EOJ\n\nAfter execution of the above job, erase or rename the file\nTABLE2 TEXT, or you will get an error in your next NCP\ngeneration. The error will occur in the NCP load (timestamp\nmismatch).\n\n\nB BOOK GENERATION IN VSE\n\nTo generate the B book in VSE use the file used in your NCP\ngeneration and the following JCL.\n\n* $$ JOB JNM ...\n// JOB CATBOOK\n// EXEC LIBR\nACC S=sublibrary.name\nCATALOG xxx.B  REP=YES (xxx equal to 'NEWNAME' in BUILD)\n... PCCU ..... (should be the first card)\n    .\n    etc\n    .\n    GENEND\n    END\n/+\n/*\n* $$ EOJ\n\n\nHow to utilize the NCP with VM and VSE\n\nAlter the ATCCON member of VTAM/VM to perform an\nautomatic load of the NCP. At this time the 3725 should be\nattached to your VM/VTAM machine. All lines in our case are\ngenerated with the parameter 'ISTATUS=INACTIVE' in the\nLINE macro. After the load is complete, deactivate the NCP in\nVTAM/VM, wait for the message saying NCP is inactive to\ndetach the 3725 from VTAM/VM, and attach it to your VSE\nmachine. In the ATCCON member of your VSE machine, the\nNCP should not appear. After the attach has been performed,\nissue the following command at the VSE console:\n\n      V NET,ID=xxxx,ACT,LOAD=NO,SCOPE=ALL\n\nwhere xxxx is the NEWNAME. This command will activate\nthe NCP in VSE and all lines.\n\n\nTHINGS TO BEAR IN MIND\n\no      Always execute the complete process described above (ie\n      the NCPGEN, the RRT, and the B book in VSE) because\n      VTAM checks the timestamp for the RRT against the NCP\n      and, if a mismatch occurs, NCP will not be activated in\n      VM or VSE.\n\no      It will be necessary to define two PCCU macros (one for\n      VM and another for VSE). The PCCU macro in VSE\n      should have the parameter SYSLUB, which should reflect\n      the SYSxxx used in the VTAM start-up to assign the 3725.\n\no      Two HOST macros should be defined too (one for VM and\n      one for VSE).\n\no      To use RSCS with a remote printer shared with CICS, you\n      should pay particular attention to the PATH macro. Figure\n      1 shows a schematic representation of our network. The\n      printer is defined in VTAM/VSE and used by RSCS using\n      cross domain.\n\nPATH macro definition in VTAM/VSE\n\nPATH1112 DESTSA=12,ER0=(12,1),VR0=0\nPATH1114 DESTSA=14,ER0=(14,1),VR0=0\n\nPATH macro in the NCP\n\nPATH1411 DESTSA=11,ER0=(11,1),VR0=0\nPATH1412 DESTSA=12,ER0=(11,1),VR0=0,ER1=(12,1),\n                   VR0=0,VR1=1\n\nPATH macro definition in VTAM/VM\n\nPATH1211 DESTSA=11,ER0=(11,1),VR0=0\nPATH1214 DESTSA=14,ER0=(11,1),VR0=0,ER1=(14,1),\n                   VR0=0,VR1=1\n\n\nCarlos Alberto Bodra Becher\nTechnical Support\nRolamentos Schaeffler do Brasil (Brazil)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N005A07": {"ttr": 6404, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x02\\xca\\x02\\xca\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 714, "newlines": 714, "modlines": 0, "user": "SNAUPDT"}, "text": "SNA route planning\n\nThe following REXX EXEC automates the process of route\nplanning and the definition of ACF products in small to\nmedium networks. It is not intended as a substitute for the IBM\nspecialist programs for network planning such as RTG and\nNETDA. With this EXEC, versions of which have been written\nfor CMS and TSO, you are able to:\n\no      Generate PATH macros for VTAM and NCP nodes\n\no      Generate routing tables describing the network.\n\nThe input file (fnPARM) contains a description of all the\nsubareas and links in the network. The output files (fnPATH\nand fnRPRT) contain the PATH macros ready for insertion into\nthe VTAM and NCP nodes and the routing tables that help in\nCOS table design and in any recovery actions when a link fails.\n\nThe program permits the customization of three values:\n\n1      VRMAX - the maximum number of virtual routes that you\n      want to design.\n\n2      ERMAX - the maximum number of explicit routes\n      permitted by ACF products (be sure of this!).\n\n3      TGMAX - the maximum number of transmission groups\n      crossed by any routes (to limit the route length).\n\n\nSRPEXEC REXX\n\n/*REXX*/\n/*********************************************************************/\n/* SNA ROUTE PLANNING - (TSO VERSION )                               */\n/* FORMAT IS : SRP <PARMMP>                                          */\n/* PARMMP : PARMS MEMBER-NAME PREFIX (MAX. 4 CHARS.)                 */\n/* (EXAMPLE : PARMMP = NET1 --> PARMS MEMBER NAME = NET1PARM         */\n/*                              PATH MACROS       = NET1PATH         */\n/*                              SUMMARY REPORTS   = NET1RPRT         */\n/* THE SRP EXEC AUTOMATES THE PROCESS OF SMALL-MEDIUM NETWORK ROUTES */\n/* PLANNING AND DEFINITION.                                          */\n/* IT GENERATES THE PATH MACROS FOR VTAM AND NCP NODES, AND A SERIES */\n/* OF TABLES CONTAINING THE SUBAREAS DESCRIPTION, THE LINKS          */\n/* DESCRIPTION, THE VIRTUAL ROUTE SUMMARY, AND THE TRASMISSION GROUP */\n/* SUMMARY.                                                          */\n/*********************************************************************/\nTRACE\n/* THESE THREE VALUES MAY BE CUSTOMIZED                              */\nVRMAX=8           /* MAX. NUMBER OF VIRTUAL ROUTES TO DESIGN         */\nERMAX=8           /* MAX. NUMBER OF EXPLICIT ROUTES PERMITTED        */\nTGMAX=8           /* MAX. NUMBER OF T.G. CROSSED BY ANY ROUTES       */\nPARSE UPPER ARG PARMMP\nIF PARMMP=\"\" THEN DO\n  SAY \"MISSING ARGUMENT : PARAMETERS MEMBER-NAME PREFIX\"\n  EXIT 12\nEND\n/* FILES SETTING                                                     */\nPARMFILE=PARMMP||\"PARM\"   /* PARAMETERS       */\nOUTFILE=PARMMP||\"PATH\"    /* PATH MACROS      */\nRPTFILE=PARMMP||\"RPRT\"    /* REPORTS          */\nXPARM=\"'OLICOMP.FRM.CNTL(\"PARMFILE\")'\"\nX=SYSDSN(XPARM)\nIF X<>\"OK\" THEN DO\n  SAY \"MISSING MEMBER : \" PARMFILE\n  EXIT 8\nEND\n\"ALLOC DA('OLICOMP.FRM.CNTL(\"||PARMFILE||\")') F(\"PARMFILE\") SHR\"\nIF RC\u00ac=0 THEN SAY \"FILE \" PARMFILE \" MISSING\"\n\"ALLOC DA('OLICOMP.FRM.CNTL(\"||OUTFILE||\")') F(\"OUTFILE\") SHR REUSE\"\nIF RC\u00ac=0 THEN SAY \"FILE \" OUTFILE \" MISSING\"\n\"ALLOC DA('OLICOMP.FRM.CNTL(\"||RPTFILE||\")') F(\"RPTFILE\") SHR REUSE\"\nIF RC\u00ac=0 THEN SAY \"FILE \" RPTFILE \" MISSING\"\nER.=\"\"\nVR.=\"\"\nERVR.=\"\"\nVRER.=\"\"\nSAY \"++++++++++++++++++++++++++++++++++++++++\"\nSAY \"+        SNA ROUTE PLANNING            +\"\nSAY \"++++++++++++++++++++++++++++++++++++++++\"\nSAY\nSAY \"READING PARAMETERS...\"\nSAY\n/* READ PARAMETERS FILE                                              */\n\"EXECIO * DISKR \" PARMFILE \" (FINIS STEM PARMS.\"\nP=1\n/* VALIDATE PARAMETERS - SA AND LINK DEFINITION                      */\nHOSTSA=0;NCPSA=0;TOTSA=0;LNUM=0;CLNUM=0;LLNUM=0;MATRIX=\"\"\nDO FOREVER\n  CALL READ\n  IF PARM=\"END\" THEN LEAVE\n  SELECT\n    WHEN STRIP(LEFT(PARM,2))=\"SA\" THEN DO\n      PARSE VAR PARM . \"=\" SAID \",\" \"=\" SAT .\n      IF SAT=\"HOST\" THEN DO\n        HOSTSA=HOSTSA+1\n        TOTSA=TOTSA+1\n        SA.TOTSA=SAID\n        SANAME.TOTSA=\"H\"||HOSTSA\n        SATYPE.TOTSA=\"HOST\"\n        MATRIX = MATRIX||SAID||\" \"\n      END\n      ELSE\n        IF SAT=\"NCP\" THEN DO\n          NCPSA=NCPSA+1\n          TOTSA=TOTSA+1\n          SA.TOTSA=SAID\n          SANAME.TOTSA=\"N\"||NCPSA\n          SATYPE.TOTSA=\"NCP\"\n          MATRIX = MATRIX||SAID||\" \"\n        END\n        ELSE SAY PARM \"** INVALID CARD **\"\n    END\n    WHEN STRIP(LEFT(PARM,2))=\"LI\" THEN DO\n      PARSE VAR PARM . \"(\" OSA \",\" DSA \")\" \"=\" TG \",\" \"=\" LTYPE .\n      IF FIND(MATRIX,OSA)=0 | FIND(MATRIX,DSA)=0 THEN DO\n        SAY PARM \"** INVALID SUBAREA **\"\n      END\n      IF TG<1 | TG>255 THEN DO\n        SAY PARM \"** INVALID TG **\"\n      END\n      IF LTYPE\u00ac=\"C\" THEN DO\n        IF LTYPE\u00ac=\"L\" THEN DO\n          SAY PARM \"** INVALID LINK TYPE **\"\n        END\n      END\n      LNUM=LNUM+1\n      OSA=RIGHT(OSA,3,\"0\")\n      DSA=RIGHT(DSA,3,\"0\")\n      LINK.LNUM=OSA||\".\"||TG||\".\"||DSA\n      IF LTYPE=\"C\" THEN DO\n        CLNUM=CLNUM+1\n        LNAME.LNUM=LTYPE||CLNUM\n        LTYPE.LNUM=\"CHANNEL\"\n      END\n      ELSE DO\n        LLNUM=LLNUM+1\n        LNAME.LNUM=LTYPE||LLNUM\n        LTYPE.LNUM=\"LINE\"\n      END\n    END\n    OTHERWISE SAY PARM \"** INVALID CARD **\"\n  END\nEND\n/* SA TABLE CREATION                                                 */\nHSA.=\"\"\nDSA.=\"\"\nDO I=1 TO HOSTSA\n  HSA.I=SA.I\n  II=VALUE(HSA.I)\n  HSAFLAG.II=1\n  DSA.I=HSA.I\nEND\nDO I=HOSTSA+1 TO TOTSA\n  DSA.I=SA.I\nEND\nSAY \"CONTINUE ? (Y/N)\"\nPULL ANS\nIF ANS<>\"Y\" THEN EXIT\nSAY \"ROUTES SEARCH IN PROGRESS...\"\n/* SEARCH ALL POSSIBLE ROUTES BETWEEN SUBAREAS                       */\nDO CUR=1 TO LNUM\n  J=LNUM+CUR\n  PARSE VAR LINK.CUR ORIG \".\" TG \".\" DEST\n  LINK.J=DEST||\".\"||TG||\".\"||ORIG\nEND\nLNUM=LNUM*2\n/* START FROM LEVEL 1                                                */\nL=1\nI=1\nDO CUR=1 TO LNUM\n  PARSE VAR LINK.CUR ORIG.CUR \".\" TG.CUR \".\" DEST.CUR\n  ROUTE.I.L=ORIG.CUR||\".\"||TG.CUR||\".\"||DEST.CUR\n  I=I+1\nEND\nCT.L=I-1\n/* CONTINUE ON NEXT LEVELS UNTIL ALL ROUTES ARE EXHAUSTED            */\nNL=L+1\nDO FOREVER\n  I=1\n  DO J=1 TO CT.L\n    DO SCAN=1 TO LNUM\n      PARSE VAR LINK.SCAN ORIG.SCAN \".\" TG.SCAN \".\" DEST.SCAN\n      IF RIGHT(ROUTE.J.L,3)=ORIG.SCAN THEN DO\n        TGDEST.SCAN=TG.SCAN||\".\"||DEST.SCAN\n        IF INDEX(ROUTE.J.L,TGDEST.SCAN)=0  THEN DO\n          IF INDEX(ROUTE.J.L,DEST.SCAN)=0  THEN DO\n            ROUTE.I.NL=ROUTE.J.L||\".\"||TGDEST.SCAN\n            I=I+1\n          END\n        END\n      END\n    END\n  END\n  CT.NL=I-1\n  IF CT.NL=0 THEN LEAVE\n  L=L+1;NL=NL+1\nEND\nSAY \"VIRTUAL ROUTES ASSIGNMENT IN PROGRESS...\"\n/* ASSIGN TO EVERY ROUTE THE VIRTUAL ROUTE NUMBER STARTING FROM      */\n/* THE SHORTEST ROUTE THAT WILL BE ASSIGNED TO VR0                   */\nVR.=\"\";TG.=\"\"\nDO I=1 TO L\n  DO J=1 TO CT.I\n    OSA=STRIP(LEFT(ROUTE.J.I,3),'L',0)\n    DSA=STRIP(RIGHT(ROUTE.J.I,3),'L',0)\n    DO VV=1 TO VRMAX\n      VR#=VV-1\n      IF VR.OSA.DSA.VR#=\"\"\n      THEN DO\n        VR.OSA.DSA.VR#=ROUTE.J.I\n        VR.DSA.OSA.VR#=INV(ROUTE.J.I)\n        LEAVE\n      END\n      ELSE\n      IF VR.OSA.DSA.VR#=ROUTE.J.I | VR.DSA.OSA.VR#=ROUTE.J.I THEN LEAVE\n    END\n  END\nEND\nSAY \"EXPLICIT ROUTES SEARCH IN PROGRESS...\"\nVRER.=\"\"\n/* FIND ALL EXPLICIT ROUTES RESOLVING CONFLICT                       */\nDO J=1 TO TOTSA\n  DSA=VALUE(DSA.J)\n  NEXTER#=1\n  DO I=1 TO TOTSA\n    OSA=VALUE(DSA.I)\n    IF DSA=OSA THEN ITERATE\n    DO KK=VRMAX TO 1 BY -1\n/*  DO KK=1 TO NVR+1         */\n      VR#=KK-1\n      IF VR.OSA.DSA.VR#=\"\" THEN DO\n        ITERATE\n      END\n      ADSA=(LENGTH(VR.OSA.DSA.VR#)-3)/6\n      IF ADSA>TGMAX THEN ITERATE\n      ER#=0\n      NAFLAG.=0;AUFLAG.=0;ADFLAG.=0;GFLAG=0\n/* CHECK CONFLICT                                                    */\n      DO E=1 TO NEXTER#\n        WOSA=OSA\n        EE=E-1\n        DO W=1 TO ADSA\n          IF ER.DSA.WOSA.EE=\"\"\n          THEN DO\n            NAFLAG.EE=1\n          END\n          ELSE DO\n            IF ER.DSA.WOSA.EE=SUBSTR(VR.OSA.DSA.VR#,((W-1)*6+5),5)\n            THEN DO\n              AUFLAG.EE=1\n            END\n            ELSE DO\n              ADFLAG.EE=1\n            END\n          END\n          WOSA=STRIP(SUBSTR(VR.OSA.DSA.VR#,((W-1)*6+7),3),'L',0)\n        END\n      END\n/* CHECK E.R. NUMBER                                                 */\n      CNEXTER#=NEXTER#\n      DO FF=1 TO CNEXTER#\n        F=FF-1\n        IF (NAFLAG.F=1 | AUFLAG.F=1) & ADFLAG.F=0\n        THEN DO\n          ER#=F;GFLAG=1;LEAVE\n        END\n        IF ADFLAG.F=1 THEN DO\n          IF FF=CNEXTER# THEN DO\n            ER#=NEXTER#;NEXTER#=NEXTER#+1;NAFLAG.ER#=1;LEAVE\n          END\n        END\n      END\n      IF ER#<ERMAX THEN DO\n        ERVR.OSA.DSA.VR#=ER#\n        VRER.DSA.OSA.ER#=VR#\n/* E.R. NUMBER ASSIGNMENT                                            */\n        WOSA=OSA\n        DO W=1 TO ADSA\n         IF NAFLAG.ER#=1 | ADFLAG.ER#=1 | GFLAG=1\n         THEN DO\n     ER.DSA.WOSA.ER#=STRIP(SUBSTR(VR.OSA.DSA.VR#,((W-1)*6+5),5),'L',0)\n           WOSA=STRIP(RIGHT(ER.DSA.WOSA.ER#,3),'L',0)\n         END\n        END\n      END\n    END\n  END\nEND\nSAY \"PATH REPORT GENERATION IN PROGRESS...\"\nOUT.=\"\";O=0\nCALL WRITE (\"***********************************\")\nCALL WRITE (\"*     SNA  ROUTE  PLANNING        *\")\nCALL WRITE (\"***********************************\")\nCALL WRITE (\"\")\nCALL WRITE (\"\")\nDO I=1 TO TOTSA\n  OSA=VALUE(DSA.I)\n  CALL WRITE (\"****************** SUBAREA \" OSA)\n  DO J=1 TO TOTSA\n    DSA=VALUE(DSA.J)\n    IF DSA=OSA THEN ITERATE\n    CALL WRITE (\"\")\n    CALL WRITE (\"PATH     DESTSA = \" DSA)\n    DO V=1 TO ERMAX\n      ER#=V-1\n      WVR=VRER.DSA.OSA.ER#\n      IF WVR=\"\" | ERVR.OSA.DSA.WVR=\"\" | ERVR.DSA.OSA.WVR=\"\"\n        THEN ITERATE\n      ADJSA=STRIP(RIGHT(ER.DSA.OSA.ER#,3),'L',0)\n      TG=LEFT(ER.DSA.OSA.ER#,1)\n      CALL WRITE (\"         ER\"||ER# \"= (\"||ADJSA||\",\"||TG||\")\")\n    END\n    IF HSAFLAG.OSA=1 THEN\n    DO V=1 TO VRMAX\n      VR#=V-1\n      IF ERVR.OSA.DSA.VR#<>\"\" & ERVR.DSA.OSA.VR#<>\"\" THEN DO\n      CALL WRITE (\"         VR\"||VR# \"=\" ERVR.OSA.DSA.VR#)\n      END\n    END\n  END\n  CALL WRITE (\"\")\nEND\n\"EXECIO \" O \" DISKW \" OUTFILE \" (FINIS STEM OUT.\"\n\"FREE F(\" OUTFILE \")\"\nSAY \"SUMMARY REPORT GENERATION IN PROGRESS...\"\nOUT.=\"\";O=0\nCALL WRITE (\"***********************************\")\nCALL WRITE (\"*     SNA  ROUTE  PLANNING        *\")\nCALL WRITE (\"***********************************\")\nCALL WRITE (\"\")\nCALL WRITE (\"VRMAX = \" VRMAX \" - ERMAX = \" ERMAX \" - TGMAX = \" TGMAX)\nCALL WRITE (\"\")\nCALL WRITE (\"\")\nCALL WRITE (\"***********************************\")\nCALL WRITE (\"*         SUBAREA TABLE           *\")\nCALL WRITE (\"***********************************\")\nCALL WRITE (\"\")\nCALL WRITE (\"----------------------------\")\nCALL WRITE (\"|   SA   |  TYPE  |  NAME  |\")\nCALL WRITE (\"|        |        |        |\")\nCALL SASORT\nDO I=1 TO TOTSA\nSA.I=RIGHT(SA.I,5);SAT.I=LEFT(SATYPE.I,4);SAN.I=CENTER(SANAME.I,4)\nCALL WRITE (\"|\" SA.I \" | \" SAT.I \" | \" SAN.I \" |\")\nEND\nCALL WRITE (\"----------------------------\")\nCALL WRITE (\"\")\nCALL WRITE (\"\")\nCALL WRITE (\"***********************************\")\nCALL WRITE (\"*         LINK    TABLE           *\")\nCALL WRITE (\"***********************************\")\nCALL WRITE (\"\")\nCALL WRITE (\"-----------------------------------\")\nCALL WRITE (\"|  OSA-DSA  |  TYPE   | TG | NAME |\")\nCALL WRITE (\"|           |         |    |      |\")\nCALL LKSORT\nDO I=1 TO LNUM/2\n  PARSE VAR LINK.I OSA \".\" TG \".\" DSA\n  OSA=STRIP(OSA,'L',0)\n  DSA=STRIP(DSA,'L',0)\n  ODSA=CENTER(OSA||\"-\"||DSA,9);LT.I=LEFT(LTYPE.I,7);LN.I=LEFT(LNAME.I,4)\nCALL WRITE (\"|\" ODSA \"|\" LT.I \"| \" TG \"|\" LN.I \"|\")\nEND\nCALL WRITE (\"-----------------------------------\")\nCALL WRITE (\"\")\nCALL WRITE (\"\")\nCALL WRITE (\"***********************************\")\nCALL WRITE (\"*     VIRTUAL ROUTE TABLE         *\")\nCALL WRITE (\"***********************************\")\nDO I=1 TO TOTSA\n  OSA=VALUE(DSA.I)\n  DO J=1 TO TOTSA\n    DSA=VALUE(DSA.J)\n    IF OSA=DSA THEN ITERATE\n    IF HSAFLAG.OSA\u00ac=1 & HSAFLAG.DSA\u00ac=1 THEN ITERATE\n    CALL WRITE (\"\")\n    CALL WRITE (\"    OSA=\" OSA \"   DSA=\" DSA)\n    CALL WRITE (\"------------------------------------\")\n    CALL WRITE (\"| VRN | ERN | RERN |       ROUTE    \")\n    CALL WRITE (\"|     |     |      |                \")\n    DO K=1 TO VRMAX\n      VR#=K-1\n      IF VR.OSA.DSA.VR#<>\"\" & ERVR.OSA.DSA.VR#<>\"\",\n      & ERVR.DSA.OSA.VR# <>\"\" THEN DO\n        VR=CENTER(VR#,3)\n        ER=CENTER(ERVR.OSA.DSA.VR#,3)\n        RER=CENTER(ERVR.DSA.OSA.VR#,4)\n        ROUTE=CONV(VR.OSA.DSA.VR#)\n        CALL WRITE (\"|\" VR \"|\" ER \"|\" RER \"|\" ROUTE)\n      END\n    END\n    CALL WRITE (\"------------------------------------\")\n  END\nEND\nCALL WRITE (\"\")\nCALL WRITE (\"\")\nCALL WRITE (\"***********************************\")\nCALL WRITE (\"*     T. G.         TABLE         *\")\nCALL WRITE (\"***********************************\")\nDO L=1 TO LNUM/2\n  CALL WRITE (\"\")\n  CALL WRITE (\"------------------------------------\")\n  CALL WRITE (\"| SA  | SA  | TGN | (SA,SA,VRN)    |\")\n  CALL WRITE (\"|     |     |     |                |\")\n  DO I=1 TO TOTSA\n    OSA=VALUE(DSA.I)\n    DO J=1 TO TOTSA\n      DSA=VALUE(DSA.J)\n      IF OSA=DSA THEN ITERATE\n      IF HSAFLAG.OSA\u00ac=1 & HSAFLAG.DSA\u00ac=1 THEN ITERATE\n      DO E=1 TO VRMAX\n        VR#=E-1\n        IF VR.OSA.DSA.VR#=\"\" THEN ITERATE\n        ELSE IF INDEX(VR.OSA.DSA.VR#,LINK.L)\u00ac=0 THEN DO\n          SA1=CENTER(STRIP(LEFT(LINK.L,3),'L',0),3)\n          SA2=CENTER(STRIP(RIGHT(LINK.L,3),'L',0),3)\n          TG=CENTER(SUBSTR(LINK.L,5,1),3)\n          TRIP=LEFT(\"(\"||OSA||\",\"||DSA||\",\"||VR#||\")\",12)\n          CALL WRITE (\"|\" SA1 \"|\" SA2  \"|\" TG \"|\" TRIP \"  |\")\n        END\n      END\n    END\n  END\n  CALL WRITE (\"------------------------------------\")\nEND\n\"EXECIO \" O \" DISKW \" RPTFILE \" (FINIS STEM OUT.\"\n\"FREE F(\" RPTFILE \")\"\nSAY \"SRP EXEC ENDED SUCCESSFULLY.\"\nEXIT RC\n/* ************************************** */\nCONV:\nPARSE ARG ROU\nCROU=\"\"\nCNLI=(LENGTH(ROU)-3)/6\nDO CL=1 TO CNLI+1\n  CSA=SUBSTR(ROU,(CL-1)*6+1,3)\n  CTG=SUBSTR(ROU,(CL-1)*6+5,1)\n  DO CI=1 TO TOTSA\n    IF CSA=SA.CI THEN DO\n      CROU=CROU||STRIP(SANAME.CI)\n      LEAVE\n    END\n  END\n  IF CTG\u00ac=\"\" THEN CROU=CROU||\".TG\"||CTG||\".\"\nEND\nRETURN CROU\n\n/* ************************************** */\nREAD:\nDO FOREVER\n IF LEFT(PARMS.P,1)<>\"*\" THEN LEAVE\n ELSE P=P+1\nEND\nPARM=STRIP(PARMS.P)\nP=P+1\nRETURN PARM\n/* ************************************** */\nSASORT:\nDO J=TOTSA TO 1 BY -1\n  DO I=1 TO J\n    IF SANAME.I>SANAME.J THEN DO\n      SAW=SA.I;SA.I=SA.J;SA.J=SAW\n      SATYPEW=SATYPE.I;SATYPE.I=SATYPE.J;SATYPE.J=SATYPEW\n      SANAMEW=SANAME.I;SANAME.I=SANAME.J;SANAME.J=SANAMEW\n    END\n  END\nEND\nRETURN\n/* ************************************** */\nLKSORT:\nDO J=LNUM/2 TO 1 BY -1\n  DO I=1 TO J\n    IF LNAME.I>LNAME.J THEN DO\n      LINKW=LINK.I;LINK.I=LINK.J;LINK.J=LINKW\n      LTYPEW=LTYPE.I;LTYPE.I=LTYPE.J;LTYPE.J=LTYPEW\n      LNAMEW=LNAME.I;LNAME.I=LNAME.J;LNAME.J=LNAMEW\n    END\n  END\nEND\nRETURN\n/* ************************************** */\nINV:\nPARSE ARG ROUTE\nINVROUTE=RIGHT(ROUTE,3)\nINSA=(LENGTH(ROUTE)-3)/6\nDO Q=INSA TO 1 BY -1\n  INVROUTE=INVROUTE||SUBSTR(ROUTE,(Q-1)*6+4,3)\n  INVROUTE=INVROUTE||SUBSTR(ROUTE,(Q-1)*6+1,3)\nEND\nRETURN INVROUTE\n/* ************************************** */\nWRITE:\nPARSE ARG OUTPUT\nO=O+1\nOUT.O=OUTPUT\nRETURN\n\n\nSAMPLE INPUT\n\n* input parameters of SRP EXEC\n* all parms start from col. 1\n* this is a comment\n*\n* host subarea description\n* SA=xxx,TYPE=HOST ------- xxx : subarea number\n*\nSA=1,TYPE=HOST\n*\n* ncp subarea description\n* SA=xxx,TYPE=NCP -------- xxx : subarea number\n*\nSA=2,TYPE=NCP\nSA=3,TYPE=NCP\nSA=4,TYPE=NCP\n*\n* link description\n* LINK=(xxx,yyy) ------- (xxx,yyy) : link adjacent subarea numbers\n* TG=zzz --------------- zzz : link transmission group number\n* TYPE=C|L ------------- C=channel link - L=line link\n*\nLINK=(1,2),TG=1,TYPE=C\nLINK=(2,3),TG=1,TYPE=L\nLINK=(2,4),TG=1,TYPE=L\nLINK=(2,4),TG=2,TYPE=L\n*\n* must be the last card\nEND\n\n\nSAMPLE OUTPUT\n\nGenerated PATH macros\n\n***********************************\n*     SNA  ROUTE  PLANNING        *\n***********************************\n\n\n****************** SUBAREA  1\n\nPATH     DESTSA =  2\n         ER0 = (2,1)\n         VR0 = 0\n\nPATH     DESTSA =  3\n         ER0 = (2,1)\n         VR0 = 0\n\nPATH     DESTSA =  4\n         ER0 = (2,1)\n         ER1 = (2,1)\n         VR0 = 1\n         VR1 = 0\n\n****************** SUBAREA  2\n\nPATH     DESTSA =  1\n         ER0 = (1,1)\n\nPATH     DESTSA =  3\n         ER0 = (3,1)\n\nPATH     DESTSA =  4\n         ER0 = (4,2)\n         ER1 = (4,1)\n\n****************** SUBAREA  3\n\nPATH     DESTSA =  1\n         ER0 = (2,1)\n\nPATH     DESTSA =  2\n         ER0 = (2,1)\n\nPATH     DESTSA =  4\n         ER0 = (2,1)\n         ER1 = (2,1)\n\n****************** SUBAREA  4\n\nPATH     DESTSA =  1\n         ER0 = (2,2)\n         ER1 = (2,1)\n\nPATH     DESTSA =  2\n         ER0 = (2,2)\n         ER1 = (2,1)\n\nPATH     DESTSA =  3\n         ER0 = (2,2)\n         ER1 = (2,1)\n\nSample report\n\n***********************************\n*     SNA  ROUTE  PLANNING        *\n***********************************\n\n\n***********************************\n*         SUBAREA TABLE           *\n***********************************\n\n----------------------------  THIS TABLE SUMMARIZES THE CHARACTERISTICS\n|   SA   |  TYPE  |  NAME  |  OF ANY SUBAREA\n|        |        |        |\n|     1  |  HOST  |   H1   |  SA : SUBAREA NUMBER\n|     2  |  NCP   |   N1   |  TYPE : SUBAREA TYPE\n|     3  |  NCP   |   N2   |  NAME : SUBAREA NAME (ASSIGNED BY EXEC)\n|     4  |  NCP   |   N3   |\n----------------------------\n\n\n***********************************\n*         LINK    TABLE           *\n***********************************\n\n-----------------------------------  THIS TABLE SUMMARIZES THE\n|  OSA-DSA  |  TYPE   | TG | NAME |  CHARACTERISTICS OF ANY LINK\n|           |         |    |      |\n|    1-2    | CHANNEL |  1 | C1   |  OSA-DSA : COUPLE OF SUBAREAS\n|    2-3    | LINE    |  1 | L1   |            CONNECTED BY THIS LINK\n|    2-4    | LINE    |  1 | L2   |  TYPE : LINK TYPE\n|    2-4    | LINE    |  2 | L3   |  TG : LINK TRANSMISSION GROUP NUMBER\n-----------------------------------  NAME : LINK NAME (ASSIGNED BY EXEC)\n\n\n***********************************\n*     VIRTUAL ROUTE TABLE         *\n***********************************\n\n    OSA= 1    DSA= 2\n------------------------------------  THIS TABLE DESCRIBES THE ROUTE\n| VRN | ERN | RERN |       ROUTE      ASSOCIATED WITH ANY VIRTUAL ROUTE\n|     |     |      |                  WITH ITS EXPLICIT ROUTE AND\n|  0  |  0  |  0   | H1.TG1.N1        REVERSE EXPLICIT ROUTE NUMBER\n------------------------------------\n                                      OSA : ORIGIN SUBAREA OF THIS ROUTE\n    OSA= 1    DSA= 3                  DSA : DESTINATION SUBAREA OF THIS\n------------------------------------        ROUTE\n| VRN | ERN | RERN |       ROUTE      VRN : VIRTUAL ROUTE NUMBER\n|     |     |      |                  ERN : EXPLICIT ROUTE NUMBER\n|  0  |  0  |  0   | H1.TG1.N1.TG1.N2 RERN : REVERSE EXPLICIT ROUTE\n------------------------------------         NUMBER\n                                      ROUTE : ROUTE DESCRIPTION\n    OSA= 1    DSA= 4\n------------------------------------\n| VRN | ERN | RERN |       ROUTE\n|     |     |      |\n|  0  |  1  |  1   | H1.TG1.N1.TG1.N3\n|  1  |  0  |  0   | H1.TG1.N1.TG2.N3\n------------------------------------\n\n    OSA= 2    DSA= 1\n------------------------------------\n| VRN | ERN | RERN |       ROUTE\n|     |     |      |\n|  0  |  0  |  0   | N1.TG1.H1\n------------------------------------\n\n    OSA= 3    DSA= 1\n------------------------------------\n| VRN | ERN | RERN |       ROUTE\n|     |     |      |\n|  0  |  0  |  0   | N2.TG1.N1.TG1.H1\n------------------------------------\n\n    OSA= 4    DSA= 1\n------------------------------------\n| VRN | ERN | RERN |       ROUTE\n|     |     |      |\n|  0  |  1  |  1   | N3.TG1.N1.TG1.H1\n|  1  |  0  |  0   | N3.TG2.N1.TG1.H1\n------------------------------------\n\n\n***********************************\n*     T. G.         TABLE         *\n***********************************\n\n------------------------------------  THIS TABLE SUMMARIZES THE T.G.\n| SA  | SA  | TGN | (SA,SA,VRN)    |  NUMBER AND ALL VIRTUAL ROUTES\n|     |     |     |                |  USING THIS T.G.\n|  1  |  2  |  1  | (1,2,0)        |\n|  1  |  2  |  1  | (1,3,0)        |  SA : SUBAREA CONNECTED TO THIS\n|  1  |  2  |  1  | (1,4,0)        |       TRANSMISSION GROUP\n|  1  |  2  |  1  | (1,4,1)        |  TGN : TRANSMISSION GROUP NUMBER\n------------------------------------  VRN : VIRTUAL ROUTE NUMBER USING\n                                            THIS TRANSMISSION GROUP\n------------------------------------\n| SA  | SA  | TGN | (SA,SA,VRN)    |\n|     |     |     |                |\n|  2  |  3  |  1  | (1,3,0)        |\n------------------------------------\n\n------------------------------------\n| SA  | SA  | TGN | (SA,SA,VRN)    |\n|     |     |     |                |\n|  2  |  4  |  1  | (1,4,0)        |\n------------------------------------\n\n------------------------------------\n| SA  | SA  | TGN | (SA,SA,VRN)    |\n|     |     |     |                |\n|  2  |  4  |  2  | (1,4,1)        |\n------------------------------------\n\n\nFerrero Regis Maurizio\nSystems Engineer (Italy)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N005A08": {"ttr": 6662, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x01\\x19\\x01\\x19\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 281, "newlines": 281, "modlines": 0, "user": "SNAUPDT"}, "text": "Tuning VTAM and NCP data flows\n\nThe flow of data between ACF/VTAM and a channel-attached\nfront-end processor running ACF/NCP is greatly affected by\nthe parameters chosen in the VTAM start-up and NCPGEN\ndecks. In particular, the choice of values for IOBUF\n(subparameters), DELAY, and MAXBFRU parameters will\naffect the number of CPU cycles, channel program read/writes,\nand quantity of storage used by VTAM.\n\nSpecific recommendations are almost impossible since values\nare dependent directly upon the type, size, and volume of data,\nwhich will obviously vary greatly from system to system. It is\nfor this reason that these parameters are still user-specified.\nThis article will attempt to offer some guidelines to assist in\nchosing values for the key parameters and determining whether\nthe values chosen are correct.\n\nBuffer pools used for I/O operations between VTAM and an\nNCP are specified at start-up in the ATCSTR00 member of the\ndataset specified by the VTAMLST DD card on the VTAM\nstart procedure:\n\n      IOBUF=(baseno,bufsize,slowpt,F,xpanno,xpanpt)\n\nwhere baseno specifies the initial number of buffers to be\nallocated by VTAM during start-up, bufsize specifies the size\nof the buffer to be used for I/O operations, slowpt specifies the\npoint (number of free buffers) at which VTAM is to enter slow-\ndown mode, xpanno specifies the number of pages to be added\nto the VTAM buffer pool by an expansion operation to be used\nfor buffers, and xpanpt specifies the number of free buffers\nbelow which VTAM is to initiate a buffer expansion.\n\nSelection of values for the I/O buffer pool will affect not only\nthe usage of the storage allocated to the buffers but could also\nhave some impact on VTAM CPU usage. When a message (or\nPIU) is either to be sent to an NCP or is being read from the\nNCP, it is assembled in as many I/O buffers as necessary.\nChoosing an optimum size is therefore potentially a case of\npainstaking measurement of message sizes for your particular\nsystem.\n\nHowever, as will be explained later, this can be simplified by a\nprocess of trial, monitoring, and refinement. Buffer size is\nimportant. A large size will enable messages to be stored easily\nbut storage is wasted since VTAM dedicates buffers\nexclusively and does not reuse any spare space. A small size\nutilizes storage more efficiently but could result in frequent\nbuffer pool manipulations. Cycles of buffer pool expansions\nand contractions consume CPU and can result in delays since\nVTAM will not issue any reads to the NCP nor service any\napplication requests for queueing data during such activity. On\nbalance it is better to select too large a value (say the\nmaximum, 4096) unless storage constraint is a real problem,\nbearing in mind that IOBUF is a fixed buffer pool and not in\npageable storage.\n\nReferring back to the IOBUF parameter and sub-parameters,\nVTAM initially allocates buffers according to the baseno value.\nOnce the number of free buffers falls below the value specified\nby xpannt, VTAM will allocate an additional number of buffers\nspecified by the value of xpanno. Buffer usage and expansion\nactivity can be observed via the D NET,BFRUSE command\nand trial and error may be sufficient to optimize the various\nvalues.\n\nA note of caution, however: xpanpt should be at least as large\nas MAXBFRU for the NCP otherwise it is possible for each\ninteraction with the NCP to result in an expansion followed\nimmediately by a contraction. The consequences for\nperformance are obvious.\n\nBefore describing how to monitor and evaluate the data flow\nbetween VTAM and NCP, a brief overview of channel\noperations may be useful. 'Coat-tailing' is a method use by\nVTAM to reduce the number of channel operation requests.\nThis simply means that once a channel operation has started,\nmessages can flow between VTAM and the NCP in either\ndirection by utilizing the active channel. This means that,\ninstead of messages being sent between VTAM and the NCP\nimmediately on being received, they can be queued and sent in\nblocks at intervals specified by the NCP DELAY parameter.\n\nWhen sending data to the NCP, VTAM issues a channel write\nand appends a status modifier, which means that the NCP can\nuse the same channel operation to transfer data back to VTAM.\nWhen the DELAY interval is reached and the NCP has data\nwaiting, it raises attention, which VTAM intercepts and issues\na read to allow the data to flow.\n\nA simple method of assessing the values of the key tuning\nparameters can be developed by collecting tuning statistics.\nVTAM collection of tuning statistics is activated by including\nthe TNSTAT parameter in the VTAM start-up parameters\n(member ATCSTR00 on the dataset specified by the\nVTAMLST DD card in the VTAM start-up procedure), for\nexample:\n\n      TNSTAT,CNSL|NOCNSL,TIME=mm\n\nOnly the TNSTAT keyword is necessary. CNSL specifies that\nthe statistics are to be displayed on the operator console and\nNOCNSL specifies that they are to be recorded. For MVS the\nrecording is to SMF, for VSE the recording is to the VTAM\ntrace file, and for VM the recording is to the TUNSTATS  file\non VTAM's A-disk. TIME specifies the recording interval in\nminutes. The default is 60 minutes; a shorter period may not be\nof much value since the period must be long enough to smooth\nout the effect of PC file transfers and NJE transmissions.\n\nThe objective is to set key values to provide good performance\nover an extended period, not to tune particular activities or\noperations.\n\nFor a first analysis, it will probably be sufficient simply to note\ndown the console display either as it happens or by reviewing\nthe system log later. Recording statistics to a file is of use more\nin watching for trends indicating changes in network traffic.\nAlso, it is likely that data will only be required for the short\n'busy periods'. Once the tuning statistics have been gathered,\nkey values to be observed include:\n\no      ATTN - the number of attention interrupts raised by the\n      NCP. The NCP raises an attention interrupt when there is\n      data waiting to be sent to VTAM and no channel operation\n      is active.\n\no      CHRD - the number of VTAM channel read programs executed.\n\no      CHWR - the number of VTAM channel write programs executed.\n\no      IPIU - the number of PIUs (messages) read from the NCP.\n\no      RDATTN - the number of read attentions raised by the\n      NCP. This is a count of the  number of times a VTAM\n      read operation failed to empty the waiting NCP buffers completely.\n\no      RDBUF - the number of VTAM buffers used for NCP data transfer.\n\no      SLODN - the number of times the NCP has entered slow\n      down. This state is entered when the NCP buffer pool is\n      nearly depleted and prevents acceptance of any further\n      messages, either from the network or from VTAM.\n\nThe effectiveness of the values for the three key parameters,\nIOBUF, MAXBFRU, and DELAY, can be assessed as\nfollows.\n\n\nIOBUF\n\nCompare the values for RDBUF and IPIU. If RDBUF is much\nlarger than IPIU (3 or 4 times, or more), IOBUF is too small.\nA large number of buffers are being used in holding the\nmessages, which means that the messages are typically much\nlarger than the size specified by IOBUF. However, if the\nvalues are about equal and the number of read attentions raised\nby the NCP (RDATTN) is zero, the IOBUF is too large.\n\nThere are recommendations relating to how many I/O buffers a\ntypical message should occupy for optimum VTAM\nperformance, but a value between 3 and 8 is acceptable. The\neffect of varying the value of IOBUF parameters can be\nobserved by displaying buffer usage and by using RMF to\nmeasure the VTAM working set and fixed frame count.\n\n\nMAXBFRU\n\nMAXBFRU specifies the maximum number of buffers VTAM\nwill allocate for each read or write of NCP data and so\neffectively sets a limit to the amount of data that is transferred\nbetween NCP and VTAM during a channel operation. This\nenables a balance to be struck between inbound and outbound\ntraffic and restricts the number of I/O buffers that will be used.\n\nIf the number of buffers actually used (RDBUF) is significantly\nless than MAXBFRU multiplied by CHRD (the number of\nVTAM channel reads), then MAXBFRU is too large. This\nwould also be indicated if the number of read attentions raised\nby the NCP (RDATTN) is zero. Too small a MAXBFRU value\nwould be indicated by a large value for RDATTN. This implies\nthat, at frequent intervals, not all the data was transferred from\nNCP to VTAM during a VTAM read and that NCP was forced\nto append a read attention to request VTAM to issue another\nread for the remaining data. The data still remaining in the\nNCP buffers will be experiencing a significant delay and\nVTAM will not handle any application-generated requests until\nthe second read has completed.\n\n\nDELAY\n\nIf a significant number of NCP slow-downs has been recorded\n(ie SLODN > 0) then the DELAY value in the NCP is too\nlarge. If the number of attention interrupts raised by the NCP\n(ATTN) is significantly greater than the number of channel\nreads actually raised by VTAM (CHRD) then the DELAY\nvalue is too small.\n\nIdeally the raising of attention by NCP should be avoided since\nintercepting and processing of the attention by VTAM is\ninefficient and time-consuming. However, increasing the value\nof DELAY to achieve this would significantly degrade NCP\nthroughput.\n\nA further effect of the DELAY parameter can be seen by\ncomparing the values of OPIU (the number of PIUs sent by\nVTAM to the NCP) and CHWR (the number of channel write\noperations initiated). If OPIU is significantly larger than\nCHWR then VTAM is blocking and so delaying messages.\nBlocking requires VTAM to consume CPU performing\nunproductive work.\n\nA DELAY value should be set such that the number of VTAM\nwrite operations issued keeps pace with the rate at which\nmessages are being queued by applications. A balance must be\nstruck between the optimum value for DELAY for NCP and\nthe optimum value for DELAY for VTAM. Determination of\nthis is a complex process which involves measuring the\ninbound and outbound message (PIU) rates and calculating the\noptimum number of channel operations (CHRD and CHWR) to\nprocess the traffic. The trade-off is whether the cumulative\ndelay for a group of messages is less than the channel operation\nrequired to process each message individually.\n\nIf DELAY is set to zero then each message will require a\nchannel operation (ie OPIU=CHWR and IPIU=CHRD), which\nis obviously not very efficient. Introducing a delay forces\nmessages to queue for, at most, the period of the delay, and\nresults in a decrease in channel operations but greater\nthroughput for each operation.\n\nUnfortunately, the picture is not quite this simple because of\nthe 'coat-tailing' activity, which decreases the elapsed time for\nsome channel operations. A value of 0.2 seconds is generally\nfound to be a good starting point. Decreasing this would enable\nthe NCP to process messages faster but will increase the\nchannel activity generated by VTAM. Increasing the delay\nvalue would decrease the channel activity but increase\nqueueing times, which would have a direct impact on response\ntimes. The effect of varying the value for DELAY can be\nobserved by monitoring channel activity using RMF.\n\nRemember that these notes are only a guide: there are complex\nrelationships between the parameters and they will need to be\nexamined in parallel, not just in isolation.\n\nAlthough this article has been written specifically to address\nVTAM-NCP channel operations, NetView statistics gathering\nroutines and bulk data transmission software (NJE, BDT etc)\nmay have an effect on VTAM buffer usage and should not be\ndiscounted in arriving at the final parameter values.\n\nTo summarize, varying the values of IOBUF, MAXBFRU, and\nDELAY will affect the throughput across the channel between\nVTAM and NCP and so have a direct impact on network\nresponse times. Begin by looking at RMF II and III. Assuming\nthat the overall system is not stressed, problems with the values\nof these parameters is implied if VTAM is experiencing\nprocessor or storage delays, has a large fixed frame count, or if\nchannel activity is high. Activate VTAM tuning statistics\ncollection and check the various key values using the\nguidelines above.\n\nA final note of caution: collecting VTAM tuning statistics\nintroduces some VTAM and NCP overheads and so should\nonly be used for brief sampling. To deactivate the recording\nenter the command:\n\n      F NET,NOTNSTAT\n\nCollection can be restarted again by entering:\n      F NET,TNSTAT,CNSL=YES\n\n\nBrian Alford\nSystems Consultant\nAranda (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N006A00I": {"ttr": 6668, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 14, "newlines": 14, "modlines": 0, "user": "SNAUPDT"}, "text": "N006 - SNA Update Issue #6  June 1992\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nN006A01   An enhancement to the NetView Status Monitor\nN006A02   NCP status display\nN006A03   A debugging tool for NetView programs\nN006A04   LANs and SNA networks - a recent survey\nN006A05   SNA NJE performance\nN006A06   Recent APPN announcements\nN006A07   SNA-X25 gateway performance\nN006A08   Bypassing NetView's timer restrictions\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N006A01": {"ttr": 6670, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x01g\\x01g\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 359, "newlines": 359, "modlines": 0, "user": "SNAUPDT"}, "text": "An enhancement to the NetView Status Monitor\n\n\nINTRODUCTION\n\nThe NetView Status Monitor can be used to activate failing\nresources automatically after a temporary error. Unfortunately,\nif the resource has failed with a more permanent condition, a\nsituation can arise where the Status Monitor issues repeated\nactivate commands, leading to a network log full of spurious\nmessages and a screen full of alerts.\n\nThe NetView user exit and associated command lists shown in\nthis article form the basis of a system to control this problem\nwithout going to the extreme of disabling the Status Monitor.\n\nThe system is based on the assumption that when a network\nresource such as a line or cluster controller fails it will generate\none of the following events:\n\no      A Record Maintenance Statistics (RECMS) Request Unit\n      (RU), which will be seen by the Hardware Monitor.\n\no      Message IST105I, indicating that the resource has gone\n      inactive.\n\no      Message IST259I, indicating that the resource has gone\n      inoperative.\n\nWhen five of these events have occurred in five minutes, the\nsystem issues an inactivate force command which should\npermanently disable the resource and prevent the Status\nMonitor from activating it again.\n\nThe messages can be handled with standard message table\nautomation techniques but earlier versions of NetView do not\nallow the automation of alert data. The user exit below is given\ncontrol by the Hardware Monitor for every RU on its\nCommunications Network Management (CNM) interface. It\nperforms some simple analysis on the RU passed to it and\ngenerates a message which can then be used in the normal way\nby message automation.\n\n\nINSTALLATION\n\nTo install this system the following steps should be followed:\n\no      Assemble and link-edit the user exit YJPXITCI. Ensure\n      that the NetView macro library is included in the SYSLIB\n      concatenation. The module should be link-edited as re-\n      entrant and placed in a NetView STEPLIB library.\n\no      Copy the IST105I and IST105C command lists to a library\n      in your NetView DSICLD concatenation.\n\no      Modify your Message Automation Table to include the\n      following statements:\n\n      IF MSGID='IST105I' & TEXT=MESSAGE\n       THEN EXEC(CMD('IST105I ' MESSAGE) ROUTE(ONE AUTO1));\n      IF MSGID='IST259I' & TEXT=MESSAGE\n       THEN EXEC(CMD('IST105I ' MESSAGE) ROUTE(ONE AUTO1));\n      IF MSGID='NET720I' & TEXT=MESSAGE\n       THEN EXEC(CMD('IST105I ' MESSAGE) ROUTE(ONE AUTO1));\n\no      Add the following statement to your NetView DSIPARM\n      library member BNJMBDST:\n      DSTINIT XITCI=YJPXITCI\n\no      Add a timed event to run the command list IST105I near\n      midnight. This is necessary to clear down variables used\n      by the system as the IST105I command list gets confused\n      with day changes!\n\no      Finally, restart NetView.\n\n\nFINAL COMMENTS\n\no      Obviously the user exit can be called anything you like -\n      just remember to change the BNJMBDST statement.\n\no      You can change the message number issued by the user\n      exit but remember to change the message automation table\n      entry as well.\n\no      The IST105I command list issues an inactivate force\n      command after five failures in five minutes. You may want\n      to review those figures, and consider putting out an alert,\n      message, etc.\n\no      The message table routes the command list execution to\n      user AUTO1. This can be changed to any valid\n      disconnected NetView user.\n\n\nYJPXITCI SOURCE CODE\n\n         TITLE 'YJPXITCI - NetView 1.3.0 CNM interface input user exit'\n***********************************************************************\n*                         - COMMENT -                                 *\n*---------------------------------------------------------------------*\n* XITCI is invoked by the Data Services Task (DST) after Communicat-  *\n* -ions Network Management (CNM) data is received.                    *\n* This exit scans for RECMS RUs indicating errors (as opposed to      *\n* statistics) and issues a message for the resource affected so       *\n* that it can be processed using message automation.                  *\n***********************************************************************\n*                      - REGISTER USAGE -                             *\n* R0 - MACROs/work                 R8  ->Input or DSIMQS buffer       *\n* R1 - MACROs/work                 R9  ->Main Vector Table            *\n* R2 - Work                        R10 - *Unused*                     *\n* R3 - Work                        R11 - *Unused*                     *\n* R4 - Work                        R12 - Base                         *\n* R5 - *Unused*                    R13 ->GETMAINed area ($ENTERR)     *\n* R6 ->Task Information Block      R14 - MACROs/work                  *\n* R7 ->Task Vector Table           R15 - MACROs/work                  *\n***********************************************************************\n*                        - DEPENDENCY -                               *\n* Executes as a user exit under NetView 1.3.0 .                       *\n* NPDA start-up parameters must specify :                             *\n* DSTINIT XITCI=YJPXITCI .                                            *\n***********************************************************************\n*                    - EXTERNAL ROUTINES -                            *\n* None .                                                              *\n***********************************************************************\n*                         - MACROS -                                  *\n* NCCF  - DSICBS, DSIMQS.                                             *\n***********************************************************************\n*                   - ENVIRONMENT -                                   *\n* Reentrant, serially reusable, authorization code 0.                 *\n* I/O to master NCCF operator via DSIMQS MACRO.                       *\n***********************************************************************\n         TITLE 'YJPXITCI - MACROS'\n***********************************************************************\nYJPXITCI CSECT ,\n         DSICBS DSICWB,DSIMVT,DSIPDB,DSISVL,DSISWB,DSITIB,DSITVB,DSIUSE\n         REGEQU ,\n***********************************************************************\n         TITLE 'YJPXITCI - GETMAINED WORKAREA'\n***********************************************************************\nSAVEAREA DSECT ,\n*--------------------------------- REGISTER SAVEAREA -----------------*\n         DS    18F\n*--------------------------------- DOUBLEWORDS -----------------------*\nDW       DS    D                   WORKAREA\n*--------------------------------- BUFFER FOR DSIMQS MACRO -----------*\nCMDHDR   DS    XL24                COMMAND HEADER\nCMDEXT   DS    XL12                COMMAND EXTENSION\nCMDTEXT  DS    XL100               COMMAND DATA\n***********************************************************************\n         TITLE 'YJPXITCI - SAVEAREA CHAINING; INITIALIZATION'\n***********************************************************************\nYJPXITCI CSECT ,\n         USING YJPXITCI,R15\n         STM   R14,R12,12(R13)\n         LA    R11,0(,R15)\n         GETMAIN R,LV=4096\n         DROP  R15\n         ST    R0,0(,R1)\n         ST    R1,8(,R13)\n         ST    R13,4(,R1)\n         LM    R13,1,8(R13)\n         XC    8(64,R13),8(R13)\n         USING YJPXITCI,R11\n*---------------------------------------------------------------------*\n         USING SAVEAREA,R13        (GETMAINED WORKAREA)\n         USING DSIUSE,R12          (INPUT PARAMETER LIST)\n         USING DSIMVT,R9           (MAIN VECTOR TABLE)\n         USING BUFHDR,R8           (BUFFER HEADER)\n         USING DSITVB,R7           (TASK VECTOR TABLE)\n         USING DSITIB,R6           (TASK INFORMATION BLOCK)\n*---------------------------------------------------------------------*\n         LR    R12,R1              ->INPUT PARAMETER LIST\n         L     R7,USERTVB          ->TASK VECTOR BLOCK (TVB)\n         L     R9,TVBMVT           ->MAIN VECTOR TABLE (MVT)\n         L     R6,TVBTIB           ->TASK INFORMATION BLOCK (TIB)\n***********************************************************************\n         TITLE 'YJPXITCI - ISSUE MESSAGE FOR ERROR RECMS'\n***********************************************************************\n*--------------------------------- LOCATE INPUT BUFFER ---------------*\n         L     R8,USERMSG          ->INPUT BUFFER\n*--------------------------------- CHECK FOR CORRECT RU TYPES --------*\n         LH    R2,HDRTDISP         INPUT BUFFER MESSAGE OFFSET\n         LA    R2,0(R2,R8)         ->INPUT BUFFER DATA\n         LH    R3,HDRMLENG         INPUT BUFFER DATA LENGTH\n         CLC   0(3,R2),=X'810812'  DELIVER RU?\n         BNE   EXITASIS            (NO )\n         CLC   8(3,R2),=X'010381'  RECMS?\n         BNE   EXITASIS            (NO )\n         CLI   15(R2),X'80'        BSC/SS DEVICE LINE ERRORS?\n         BE    XITMSG              (YES)\n         CLI   15(R2),X'82'        SNA LINK PERMANENT ERRORS?\n         BE    XITMSG              (YES)\n         CLI   15(R2),X'83'        SNA STATION PERMANENT ERRORS?\n         BE    XITMSG              (YES)\n         B     EXITASIS            EXIT WITHOUT MESSAGE\n*--------------------------------- EXTRACT RESOURCE NAME -------------*\nXITMSG   SR    R4,R4\n         ICM   R4,3,6(R2)          LENGTH OF RECMS RU\n         LA    R4,8(R4,R2)         ->START OF HIERARCHY\n         CLI   0(R4),0             ANY HIERARCHY?\n         BE    EXITASIS            (NO )\n         SR    R1,R1\n         IC    R1,1(,R4)           LENGTH OF REPORTING STATION\n         LA    R4,2(R4,R1)         ->NEXT ENTRY IN HIERARCHY\n         CLI   0(R4),0             END OF HIERARCHY?\n         BE    EXITASIS            (YES)\n         MVC   DW,BLANKS           CLEAR WORKAREA\n         IC    R1,1(,R4)           LENGTH OF FIRST ENTRY IN HIERARCHY\n         BCT   R1,*+10             MOVE TO WORKAREA :-\n         MVC   DW(*-*),2(R4)\n         EX    R1,*-6\n*--------------------------------- ISSUE INFORMATION MESSAGE ---------*\n         LA    R8,CMDHDR           ->NEW BUFFER\n         MVC   HDRMLENG,=Y(L'M001)\n         MVC   HDRBLENG,=Y(136)\n         MVI   HDRMTYPE,C'U'\n         MVC   HDRTDISP,=Y(36)\n         MVC   CMDTEXT(L'M001),M001\n         MVC   CMDTEXT+M001NAME(8),DW\n         MVC   HDRDOMID,MVTCURAN\n         DSIMQS SWB=USERSWB,                                          *\n               BFR=(8),AUTHRCV=YES\n         B     EXITASIS\n***********************************************************************\n         TITLE 'YJPXITCI - RETURN TO CALLER'\n***********************************************************************\n*--------------------------------- ALLOW MESSAGE TO BE DISPLAYED -----*\nEXITASIS LA    R15,USERASIS\n         B     YJP$EXIT\n*--------------------------------- SUPPRESS MESSAGE DISPLAY ----------*\nEXITDROP LA    R15,USERDROP\n         B     YJP$EXIT\n*--------------------------------- RETURN TO CALLER ------------------*\nYJP$EXIT L     R13,4(,R13)\n         LR    R14,R15\n         L     R1,8(,R13)\n         L     R0,0(,R1)\n         FREEMAIN R,LV=(0),A=(1)\n         LR    R15,R14\n         L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         OI    15(R13),X'01'\n         BR    R14\n***********************************************************************\n         TITLE 'YJPXITCI - CONSTANTS'\n***********************************************************************\nZEROS    DC    D'0'\nBLANKS   DC    CL8' '\nM001     DC    C'NET720I Error RECMS received for ********'\nM001NAME EQU   33,8,C'C'\n***********************************************************************\n         END   ,\n\n\nIST105I CLIST\n\n/*********************************************************************/\n/* FUNCTION        Count occurrences of 'resource INACTIVE' or 'INOP'*/\n/*                 type messages so that when STATMON keeps          */\n/*                 activating a dead resource it can be disabled.    */\n/* DEPENDENCY      Entry in message table for IST105I, IST259I,      */\n/*                 and NET720I                                       */\n/*                 CNM user exit YJPXITCI                            */\n/* ENVIRONMENT     NetView V1R3+REXX+VTAM320                         */\n/* SYNTAX          IST105I text_of_message_IST105I/IST259I/NET720I   */\n/* RETURN CODES    None                                              */\n/*********************************************************************/\narg w1 w2 .  . w5 w6 .\nselect\n   when w1 = 'IST105I' then resource = w2\n   when w1 = 'IST259I' then resource = w5\n   when w1 = 'NET720I' then resource = w6\n   otherwise do\n      say 'NET740I Invalid message; msgid='w1\n      exit\n   end\nend\nif resource = 'ABCDEFG' then exit /* Ignore this resource            */\n'globalv getc ist105i.0'          /* Get table counter               */\nif ist105i.0 = '' then ist105i.0 = 0 /* Initialize if necessary      */\nctime = time(s)                   /* Get current time                */\ncount = resource'.#'              /* Set number of hits              */\n'globalv getc 'count              /* Get number of hits              */\nftime = resource'.t'              /* Set time of first hit           */\n'globalv getc 'ftime              /* Get time of first hit           */\nif value(count) = '' then do      /* If it is a first time hit :     */\n interpret count'=1'              /* -set hit count                  */\n interpret ftime'=ctime'          /* -set time                       */\n 'globalv putc 'count             /* -update global variable         */\n 'globalv putc 'ftime             /* -update global variable         */\n ist105i.0 = ist105i.0 + 1        /* -increment table counter        */\n i         = ist105i.0            /*                                 */\n name = 'IST105I.'i               /* -build new variable name        */\n interpret name'=resource'        /* -add resource name to variable  */\n 'globalv putc ist105i.0'         /* -update table counter           */\n 'globalv putc 'name              /* -add new table variable         */\n exit                             /* -exit                           */\nend                               /*                                 */\ndtime = ctime - value(ftime)      /* Get time difference             */\nif dtime > 600 then do            /* If time limit exceeded :        */\n interpret ftime'=ctime'          /* -set new first time             */\n interpret count'=1'              /* -set hits to zero               */\nend                               /* -exit                           */\nelse do                           /* If within time limit :          */\n if value(count) >= 5 then do     /* -and if hits exceeds limit :    */\n  'INACTF 'resource               /*  -inactivate resource           */\n  interpret ftime'=ctime'         /*  -set new first time            */\n  interpret count'=1'             /*  -set hits to zero              */\n end                              /*  -exit                          */\n else do                          /* -if hits within limit :         */\n  interpret count'=value(count)+1'/*  -increment hit count           */\n end                              /*  -exit                          */\nend                               /* -exit                           */\n'globalv putc 'count              /* Update global variable          */\n'globalv putc 'ftime              /* Update global variable          */\nexit                              /* Exit                            */\n\n\nIST105C CLIST\n\n/*********************************************************************/\n/* FUNCTION        Clear global variables used by IST105I            */\n/* DEPENDENCY      None                                              */\n/* ENVIRONMENT     NetView V1R3+REXX                                 */\n/* SYNTAX          IST105C                                           */\n/* RETURN CODES    None                                              */\n/*********************************************************************/\n'globalv getc ist105i.0'               /* Get number of variables    */\nif ist105i.0 = '' then do              /* Any?                       */\n   say 'NET730I No resources to clear' /*  -no                       */\n   exit                                /*  -exit                     */\nend                                    /*                            */\ndo j = 1 to ist105i.0                  /* Start of clear loop        */\n   name = 'IST105I.'j                  /* Set table name             */\n   'globalv getc 'name                 /* Acquire it                 */\n   res = value(name)                   /* Get its contents           */\n   count = res'.#'                     /* Build count name           */\n   'globalv getc 'count                /* Get its contents           */\n   interpret count\"=''\"                /* Clear it                   */\n   'globalv putc 'count                /* Update it                  */\n   ftime = res'.t'                     /* Build first_time name      */\n   'globalv getc 'ftime                /* Get its contents           */\n   interpret ftime\"=''\"                /* Clear it                   */\n   'globalv putc 'ftime                /* Update it                  */\n   interpret name\"=''\"                 /* Clear table name           */\n   'globalv putc 'name                 /* Update it                  */\nend                                    /* End of clear loop          */\nist105i.0 = ''                         /* Clear number of variables  */\n'globalv putc ist105i.0'               /* Update it                  */\nexit                                   /* Return to caller           */\n\n\nDave Martin\nConsultant Systems Programmer\nIMI Computing Ltd (UK)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N006A02": {"ttr": 6919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x01I\\x01I\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 329, "newlines": 329, "modlines": 0, "user": "SNAUPDT"}, "text": "NCP status display\n\nAt our installation we have three 3745s (one local and two\nremote), each of which has the current and previous NCPs\nstored on its disk. Changes to an NCP are carried out on the\nolder NCP, which is then loaded into the 3745 and activated\nfor testing.\n\nThe following REXX EXEC was developed to allow the status\nof all NCPs and 3745 disk contents to be monitored while\nchanges were taking place. Commands can be issued from the\npanel, and their effect on the 3745/NCP can be seen when the\npanel is refreshed.\n\nThe EXEC issues a NetView 'DIS' command for each NCP to\nfind the status of each NCP. It then issues a NetView 'DISK'\ncommand for each active NCP to find the status of the 3745\ndisk. This EXEC could easily be adapted to match other\ninstallations' naming conventions and a different number of\n3745/NCPs. If more than two NCP names are used for each\n3745, modification to the loop which obtains the status of 3745\ndisks will be required.\n\n\nNCP STATUS DISPLAY EXEC (NCPDIS)\n\n/**********************************************************************/\n/* NCPDIS     :- REXX EXEC to display status of NCPs and 3745s        */\n/**********************************************************************/\n/* Initialize error handling.                                         */\n/**********************************************************************/\nTrace E\n/**********************************************************************/\n/* Initialize static panel field attributes.                          */\n/**********************************************************************/\n$NCP. = 'FA CY'\n$COMMAND = 'FI UY'\n$DIS = 'FI'\n/**********************************************************************/\n/* Initialize static panel variables.                                 */\n/**********************************************************************/\nVER = '1.0'\nNCP.1 = 'NCPEDIA'\nNCP.2 = 'NCPEDIB'\nNCP.3 = 'NCPMANA'\nNCP.4 = 'NCPMANB'\nNCP.5 = 'NCPREAA'\nNCP.6 = 'NCPREAB'\nCOMMAND = ' '\nDIS = 'NO'\n/**********************************************************************/\n/* Initialize variables.                                              */\n/**********************************************************************/\nNUMNCP = 6\n/**********************************************************************/\n/* Get information on NCPs from VTAM for display.                     */\n/**********************************************************************/\nCall GETINFO\n/**********************************************************************/\n/* MAIN LOOP                                                          */\n/**********************************************************************/\nDo forever\n   /*******************************************************************/\n   /* Display main panel.                                             */\n   /*******************************************************************/\n   'VIEW NCPAPPL NCPDISP INPUT'\n   /*******************************************************************/\n   /* Convert input fields to upper case.                             */\n   /*******************************************************************/\n   Upper COMMAND\n   Upper DIS\n   If substr(DIS,1,1) = 'Y' then DIS = 'YES'\n   Else DIS = 'NO'\n   /*******************************************************************/\n   /* Process panel responses.                                        */\n   /*******************************************************************/\n   Select\n      When viewaid = PF3 then exit\n      When viewaid = PF5 then call GETINFO\n      When viewaid = PF6 then CMD HIGH ROLL\n      When viewaid = ENTER then\n         Select\n            When COMMAND \u00ac= ' ' then\n               Do\n                  If DIS = 'NO' then 'TRAP AND SUPPRESS MESSAGES IST*'\n                  'CMD HIGH' COMMAND\n                  COMMAND = ' '\n                  'TRAP NO MESSAGES'\n                  'FLUSHQ'\n                  Call GETINFO\n               End\n            Otherwise nop\n         End\n      Otherwise nop\n   End\nEnd\nExit\n/**********************************************************************/\n/* Subroutine GETINFO = Get information on NCPs from VTAM.            */\n/**********************************************************************/\nGETINFO:\n   'OVERRIDE DISPLAY=NO'\n/**********************************************************************/\n/* Reset panel field attributes to defaults.                          */\n/**********************************************************************/\n   $STATV. = 'FA CP'\n   $STAT3. = 'FA CP'\n   $ADL. = 'FA CP'\n/**********************************************************************/\n/* Reset panel variables to defaults.                                 */\n/**********************************************************************/\n   STATV. = 'UNKNOWN'\n   STAT3. = 'UNKNOWN'\n   ADL. = ' ?'\n/**********************************************************************/\n/* Loop to get status of NCPs.                                        */\n/**********************************************************************/\n   Do I = 1 to NUMNCP\n      'TRAP AND SUPPRESS MESSAGES IST453I IST075I'\n      'DIS 'NCP.I\n      'WAIT 20 SECONDS FOR MESSAGES'\n      Select\n         When EVENT() = 'M' then\n            Do\n               'MSGREAD'\n               Select\n                  When (MSGID() = 'IST453I') then\n                     Do\n                        STATV.I = 'INACTIVE'\n                        $STATV.I = 'FA CR'\n                     End\n                  When (MSGID() = 'IST075I') then\n                     Do\n                        'GETMLINE LINE 2'\n                        PARSE VAR LINE V1 V2 STAT REST\n                        Select\n                           When STAT = 'ACTIV' then\n                              Do\n                                 STATV.I = ' ACTIVE '\n                                 $STATV.I = 'FA CG'\n                              End\n                           When STAT = 'PLOAD' then\n                              Do\n                                 STATV.I = 'LOADING '\n                                 $STATV.I = 'FA CY'\n                              End\n                           Otherwise\n                              Do\n                                 STATV.I = ' 'STAT\n                                 $STATV.I = 'FA CP'\n                              End\n                        End\n                     End\n                  Otherwise Say MSGID()\n               End\n            End\n         When EVENT() = 'T' then\n            Do\n               STATV.I = 'TIMEOUT'\n               $STATV.I = 'FA CP'\n            End\n         When EVENT() = 'E' then\n         Otherwise\n            Do\n               STATV.I = ' ERROR '\n               $STATV.I = 'FA CP'\n            End\n         Otherwise nop\n      End\n      'TRAP NO MESSAGES'\n      'FLUSHQ'\n   End\n/**********************************************************************/\n/* Loop to get status of 3745 disks via ACTIVE NCPs.                  */\n/**********************************************************************/\n   Do I = 1 to NUMNCP\n      Select\n         When Value('STATV.'I) = ' ACTIVE ' then\n            Do\n               J = ((I + 1) % 2) * 4 - 1 - I\n               'TRAP AND SUPPRESS MESSAGES IST951I'\n               'DISK 'NCP.I\n               'WAIT 20 SECONDS FOR MESSAGES'\n               Select\n                  When EVENT() = 'M' then\n                     Do\n                        'MSGREAD'\n                        Select\n                           When (MSGID() = 'IST951I') then\n                              Do\n                                 'GETMSIZE SIZE'\n                                 Do K = 1 to SIZE\n                                    'GETMLINE MLINE 'K\n                                    'PARSEL2R MLINE V0 V1 V2 V3 V4 V5'\n                                    Select\n                                    When V0 = 'IST955I' then\n                                       Do\n                                          Select\n                                       When V1 = 'NCPEDIA' then LOC = 1\n                                       When V1 = 'NCPEDIB' then LOC = 2\n                                       When V1 = 'NCPMANA' then LOC = 3\n                                       When V1 = 'NCPMANB' then LOC = 4\n                                       When V1 = 'NCPREAA' then LOC = 5\n                                       When V1 = 'NCPREAB' then LOC = 6\n                                             Otherwise nop\n                                          End\n                                          IF V4 = 'STORED' then\n                                             Do\n                                                STAT3.LOC = ' STORED'\n                                                $STAT3.LOC = 'FA CY'\n                                                ADL.LOC = ' NO'\n                                                $ADL.LOC = 'FA CR'\n                                             End\n                                          IF V4 = 'STORING' then\n                                             Do\n                                                STAT3.LOC = 'STORING'\n                                                $STAT3.LOC = 'FA CY'\n                                                ADL.LOC = ' NO'\n                                                $ADL.LOC = 'FA CR'\n                                             End\n                                          IF V5 = 'YES' then\n                                             Do\n                                                STAT3.LOC = ' LOADED'\n                                                $STAT3.LOC = 'FA CG'\n                                             End\n                                       End\n                                    When V0 = 'IST965I' then\n                                       Do\n        If V3 = 'YES' & Value('STAT3.'I) = 'LOADED' then\n                                             Do\n                                                ADL.I = 'YES'\n                                                $ADL.I = 'FA CG'\n                                             End\n        If V3 = 'YES' & Value('STAT3.'J) = 'LOADED' then\n                                             Do\n                                                ADL.J = 'YES'\n                                                $ADL.J = 'FA CG'\n                                             End\n                                       End\n                                    Otherwise nop\n                                    End\n                                 End\n                              End\n                           Otherwise Say MSGID()\n                        End\n                     End\n                  When EVENT() = 'T' then\n                     Do\n                        STAT3.I = 'TIMEOUT'\n                        $STAT3.I = 'FA CP'\n                     End\n                  When EVENT() = 'E' then\n                     Do\n                        STAT3.I = ' ERROR '\n                        $STAT3.I = 'FA CP'\n                     End\n                  Otherwise nop\n               End\n               'TRAP NO MESSAGES'\n               'FLUSHQ'\n            End\n         Otherwise nop\n      End\n   End\n/**********************************************************************/\n/* Reset 3745 disk status of module to PURGED if it has not been found*/\n/**********************************************************************/\n   Do I = 1 to NUMNCP\n      J = ((I + 1) % 2) * 4 - 1 - I\n   If Value('STAT3.'I) = 'UNKNOWN' & Value('STAT3.'J) \u00ac= 'UNKNOWN' then\n         Do\n            STAT3.I = ' PURGED'\n            $STAT3.I = 'FA CR'\n            ADL.I = ' NO'\n            $ADL.I = 'FA CR'\n         End\n   End\n/**********************************************************************/\n/* Interpret stem variables into panel variables.                     */\n/**********************************************************************/\n   Do I = 1 to NUMNCP\n      Interpret('NCP'I) '= NCP.I'\n      Interpret('STATV'I) '= STATV.I'\n      Interpret('STAT3'I) '= STAT3.I'\n      Interpret('ADL'I) '= ADL.I'\n      Interpret('$NCP'I) '= $NCP.I'\n      Interpret('$STATV'I) '= $STATV.I'\n      Interpret('$STAT3'I) '= $STAT3.I'\n      Interpret('$ADL'I) '= $ADL.I'\n   End\n   'OVERRIDE DISPLAY=YES'\nReturn\n\n\nNCP STATUS DISPLAY PANEL (NCPDISP)\n\n/**********************************************************************/\n/* NCPDISP :- MAIN DISPLAY PANEL FOR NCP CLIST                        */\n/**********************************************************************/\n*** AT1\n+NCPDISP             %N C P   S T A T U S   D I S P L A Y          +Version &VER\n$\n$                            VTAM              3745               AUTO\n$      \\NCP NAME+          \\STATUS+          \\STATUS+          \\DUMP/LOAD+\n$\n$       &NCP1             &STATV1           &STAT31               &ADL1\n$       &NCP2             &STATV2           &STAT32               &ADL2\n$\n$       &NCP3             &STATV3           &STAT33               &ADL3\n$       &NCP4             &STATV4           &STAT34               &ADL4\n$\n$       &NCP5             &STATV5           &STAT35               &ADL5\n$       &NCP6             &STATV6           &STAT36               &ADL6\n$\n$\n$\n$\n$\n%Command==>&COMMAND\n$\n%Message Display==>&DIS$\n$                       PF3= Return    PF5= Refresh\n$           PF6= Roll\n\n\nJohn Cameron\nTechnical Specialist\nThe Life Association of Scotland (UK)       c Life Association of Scotland 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N006A03": {"ttr": 7170, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x05\\x99\\x05\\x99\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 1433, "newlines": 1433, "modlines": 0, "user": "SNAUPDT"}, "text": "A debugging tool for NetView programs\n\n\nINTRODUCTION\n\nThis article presents a NetView debugging tool which,\nimplemented as a command processor, provides the user with\ntwo functions:\n\n1      The ability to display 31 NetView control blocks (see the\n      example in Figure 1).\n\n2      The ability to modify one word of storage within the\n      NetView address space.\n\nThese two functions are very helpful for system programmers\nengaged in writing or debugging NetView's user-written\nAssembler programs, such as exit routines, command\nprocessors, and subtasks.\n\n\nTHE ENVIRONMENT\n\nAdhering to the general coding guidelines published in\nNetView's Customization: Using Assembler Version 1 Release\n3 (SC31-6078) manual,  this 'regular' command processor,\nwritten in Assembler language to run under an OST in\nAMODE=31 and RMODE=ANY, was developed in an\nMVS/XA, NetView 1.3 environment. To upgrade this\ncommand processor to run in an MVS/XA, NetView 2.2\nenvironment, simply re-assemble it with the corresponding\nNetView MACLIB.\n\n\nCOMMAND SYNTAX\n\nBased on the CMDMDL statements defined in the DSICMD\nmember of DSIPARM, the syntax to invoke the command\nprocessor is shown below.\n\nFor the display function\n\nMLST BLOCK=<controlblockname>\n     (,LENGTH={<\"X\"length>|<length>|\"*\"})\n     (,{TERMINAL=<resource>|OPERATOR=<taskid>})\n\nMLST ADDRESS=<address>\n     (,LENGTH={<\"X\"length>|<length>})\n\nExamples\n\n      MLST B=MVT,LE=16\n      MLST B=MVT,LE=X16\n      MLST BL=TVB,OPER=JOEDOE\n\n      MLST A=8A56792,LEN=X256\n      MLST A=8A56792\n\nFor the modify function\n\n      MLST ADDRESS=<address>,\n           VERIFY=<8-hex-char>,REPLACE=<8-hex-char>\n\nExample\n\n      MLST A=8A56792,V=F1F2F3F4,R=F5F6F7F8\n\nThese keywords are not positional and, as such, they can be\nspecified in any order. Also, because each keyword begins\nwith a unique letter, it can be abbreviated to that first letter.\n\nTo see the syntax on-line, enter:\n\n      MLST B=HELP\n\n\nEXPLANATION OF Keywords\n\nBLOCK\n\nThere are two kinds of control blocks:\n\no      Global to NetView (ie one copy of control block for each NetView):\n\n      -      ART\n      -      DDT\n      -      DQT\n      -      MVT\n      -      OIT\n      -      SCT\n      -      SNT\n      -      SVL.\n\no      Global to the task (ie one copy of control block for PPT,\n      OST, NNT or OPT):\n\n      -      ACB\n      -      EXSWB\n      -      ICCWB\n      -      ICPDB\n      -      MRCWB\n      -      MRPDB\n      -      NCCWB\n      -      NCPDB\n      -      NPSWB\n      -      TIB\n      -      TVB.\n\nIn addition, there are some control blocks which are only\navailable to a particular task.\n\nFor OST only:\n\no      CDNIB\no      NAT\no      ORRPL\no      OSNIB\no      OSRPL\no      RARPL\no      RCRPL\no      RSRPL\no      SAT\no      SCRPL.\n\nFor PPT only:\n\no      PRCRPL\no      PSCRPL.\n\nOn displaying control block, there are two important messages\nworth mentioning:\n\n      POINTER TO THE REQUESTED CONTROL BLOCK = 0\n\nmeans the control block doesn't exist yet.\n\n      REQUESTED NETVIEW CONTROL BLOCK NOT AVAILABLE FOR THIS TASK\n\nis self-explanatory.\n\n\nADDRESS\n\nThe address specified in hexadecimal where storage display or\nmodification is to start. Because MLST has no control over\nwhich address will be specified, it has employed the MVS\nESPIE facility to trap an OC4 abend caused by referencing\nfetch- or store-protected storage. In detecting such error, the\nOC4 handler, after telling user through the message\n'STORAGE PROTECTION EXCEPTION WHILE\nPROCESSING REQUEST' will return control to NetView as if\nnothing had happened.\n\n\nLENGTH\n\nFor a BLOCK display, if LENGTH is not specified, the default\nis 1024 bytes or its implicit size, whichever is the smaller. For\nan ADDRESS display, if LENGTH is not specified, the default\nis 4 bytes.\n\nThe LENGTH value can be specified in hexadecimal (prefixed\nby 'X'), decimal, or its implicit size denoted by '*'. Because\nsome control blocks (eg MVT, SCT) can be very large,\nspecifying its '*' value may cause a long display.\n\nTo signal MLST to end the display prematurely, enter the\nRESET command or press the ATTN key.\n\nVERIFY\n\nUse this keyword to specify an 8-byte hexadecimal value which\nmust match the 4-byte storage pointed at by ADDRESS.\n\nREPLACE\n\nUse this keyword to specify an 8-byte hexadecimal value which\nwill replace the 4-byte storage pointed at by ADDRESS.\nReplacement will not be permitted if VERIFY fails.\n\nTERMINAL\n\nThis specifies a NetView 'resource' which is currently in\nsession with PPT, OST, or NNT. Use this keyword to identify\nthe task which owns the control block to be displayed.\n\nOPERATOR\n\nThis specifies a NetView 'taskid' which is currently in session\nwith PPT, OST, NNT, or OPT. Use this keyword to identify\nthe task which owns the control block to be displayed.\n\nBoth 'resource' and 'taskid' values can be displayed by using\nthe NetView command LIST STATUS=TASKS.\n\n\nTIPS FOR DEVELOPING A COMMAND PROCESSOR\n\n1      Define RES=Y in the CMDMDL statement,  use\n      DISPMOD to locate its Entry Point Address (EPA).\n\n2      Design re-entrant code. However, during the debugging\n      mode, link-edit the program as NORENT to make full use\n      of MLST. The reason for this is, because the NetView load\n      library is APF-authorized, MVS will load the NORENT\n      module into subpool 251, rather than the store-protected\n      subpool 252. As a result, subpool 251 allows MLST to\n      modify the storage (code or data) without causing an OC4.\n\n\nMLST COMMAND DEFINITION\n\nMLST     CMDMDL   MOD=MEMLIST,TYPE=R,RES=Y\n         PARMSYN  ADDRESS,ADDRES\n         PARMSYN  ADDRESS,ADDRE\n         PARMSYN  ADDRESS,ADDR\n         PARMSYN  ADDRESS,ADD\n         PARMSYN  ADDRESS,AD\n         PARMSYN  ADDRESS,A\n         PARMSYN  BLOCK,BLOC\n         PARMSYN  BLOCK,BLO\n         PARMSYN  BLOCK,BL\n         PARMSYN  BLOCK,B\n         PARMSYN  LENGTH,LENGT\n         PARMSYN  LENGTH,LENG\n         PARMSYN  LENGTH,LEN\n         PARMSYN  LENGTH,LE\n         PARMSYN  LENGTH,L\n*                                  <******************************\n         PARMSYN  VERIFY,VERIF     < If for security reason, only\n         PARMSYN  VERIFY,VERI      < DISPLAY is allowed;  simply\n         PARMSYN  VERIFY,VER       < delete these two keywords.\n         PARMSYN  VERIFY,VE        < Using DSIPAS, MLST can detect\n         PARMSYN  VERIFY,V         < missing keywords from SCT.  As\n         PARMSYN  REPLACE,REPLAC   < a result,  memory modification\n         PARMSYN  REPLACE,REPLA    < function is disabled.\n         PARMSYN  REPLACE,REPL     <      ----  or ----\n         PARMSYN  REPLACE,REP      < By using KEYCLASS, it can restrict\n         PARMSYN  REPLACE,RE       < these two keywords only to be\n         PARMSYN  REPLACE,R        < entered by some users.\n*                                  <******************************\n         PARMSYN  TERMINAL,TERMINA\n         PARMSYN  TERMINAL,TERMIN\n         PARMSYN  TERMINAL,TERMI\n         PARMSYN  TERMINAL,TERM\n         PARMSYN  TERMINAL,TER\n         PARMSYN  TERMINAL,TE\n         PARMSYN  TERMINAL,T\n         PARMSYN  OPERATOR,OPERATO\n         PARMSYN  OPERATOR,OPERAT\n         PARMSYN  OPERATOR,OPERA\n         PARMSYN  OPERATOR,OPER\n         PARMSYN  OPERATOR,OPE\n         PARMSYN  OPERATOR,OP\n         PARMSYN  OPERATOR,O\n         CMDCLASS 1,2              < only operators with scope classes\n                                   < 1 or 2 in their profiles can issue\n                                   < MLST command\n\n\nMEMLIST SOURCE CODE\n\nMEMLIST  TITLE    '*** NETVIEW STORAGE COMMAND PROCESSOR ***'\n* FUNCTION:-                                                          *\n*   DISPLAY ON NETVIEW OST THE CONTENTS OF STORAGE ASSIGNED TO        *\n*   NETVIEW CONTROL BLOCKS OR DATA AREAS WITHIN THE NETVIEW           *\n*   ADDRESS SPACE.                                                    *\n*   IT ALSO ALLOWS MODIFICATION OF MEMORY WITHIN THE NETVIEW          *\n*   ADDRESS SPACE.                                                    *\n* DESCRIPTION:-                                                       *\n*   THIS PROGRAM RUNS AS A NETVIEW REGULAR COMMAND PROCESSOR.         *\n*   IT ALSO USES MVS'S \"ESPIE\" FACILITY TO TRAP STORAGE               *\n*   ACCESS PROGRAM CHECKS WHICH OCCUR WHILE ACCESSING THE STORAGE TO  *\n*   BE DISPLAYED OR TO BE MODIFIED.                                   *\n* ENVIRONMENT:-                                                       *\n*   NETVIEW/XA VERSION 1 RELEASE 3 OR VERSION 2 RELEASE 2;            *\n*   IT RUNS IN AMODE 31 AND RMODE ANY, DESIGNED AS REENTRANT          *\n* LINKAGE:-                                                           *\n*   NOT OS STANDARD, THE LINKAGE IS ACCORDING TO THE CONVENTIONS OF   *\n*   A NETVIEW COMMAND PROCESSOR:                                      *\n*     R0    - INDETERMINATE                                           *\n*     R1    - ADDRESS OF A NETVIEW CWB TO DESCRIBE THE COMMAND WHICH  *\n*             HAS CAUSED THE NETVIEW CP TO BE INVOKED                 *\n*     R2:R12 - INDETERMINATE                                          *\n*     R13   - ADDRESS OF A SAVEAREA AVAILABLE TO THIS COMMAND         *\n*             PROCESSOR                                               *\n*     R14   - RETURN ADDRESS                                          *\n*     R15   - ADDRESS OF ENTRY POINT                                  *\nMEMLIST  CSECT\nMEMLIST  AMODE    31\nMEMLIST  RMODE    ANY\n         DSICBS                                                        *\n               DSICWB,                                                 *\n               DSIMVT,                                                 *\n               DSIPDB,                                                 *\n               DSISWB,                                                 *\n               DSITIB,                                                 *\n               DSITVB,                                                 *\n               DEFER=ALL\nMLSREG   EQU      R12               BASE REGISTER FOR PROCESSOR CODE\nMVTREG   EQU      R11               BASE REGISTER FOR NETVIEW MVT\nTVBREG   EQU      R10               BASE REGISTER FOR NETVIEW TVB\nTIBREG   EQU      R10               BASE REGISTER FOR NETVIEW TIB\nPDBREG   EQU      R9                BASE REGISTER FOR NETVIEW PDB\nBUFREG   EQU      R8                BASE REGISTER FOR NETVIEW BUFFER\n*   PERFORM ENTRY LINKAGE                                             *\n         SAVE     (14,12),T,        SAVE CALLER'S REGISTERS            *\n               'MEMLIST  &SYSDATE &SYSTIME '\n         LA       MLSREG,0(,R15)    SET CODE BASE & CLEAR HIGH BIT(S)\n         USING    MEMLIST,MLSREG    ESTABLISH ADDRESSABILITY\n         USING    DSICWB,R1         CWB ADDRESSING\n         LA       R1,CWBSAVEA       ADDRESSING CWB'S SAVEAREA\n         DROP     R1\n         ST       R1,8(,R13)        SAVEAREA'S HOUSEKEEPING\n         ST       R13,4(,R1)\n         LR       R13,R1\n         USING    CWBSAVEA,R13      ADDRESSING CWB & SAVEAREA\n         LA       R0,CWBADATD       PREPARE FOR MVCL (TO)\n         LA       R1,L'CWBADATD     GET LENGTH FOR MVCL\n         LR       R2,R0             PREPARE FOR MVCL (FROM)\n         LA       R3,0              LENGTH IS NULL\n         MVCL     R0,R2             CLEAR THE CWBADATD WORKAREA\n         L        TIBREG,CWBTIB     GET POINTER TO TIB\n         USING    DSITIB,TIBREG     ADDRESSING THE TIB\n         L        TVBREG,TIBTVB     GET POINTER TO TVB\n         DROP     TIBREG\n         USING    DSITVB,TVBREG     ADDRESSING THE TVB\n         ST       TVBREG,TVBSAVAD   SAVE TVB ADDRESS AS QUICK CELL\n         L        MVTREG,TVBMVT     GET POINTER TO MVT\n         USING    DSIMVT,MVTREG     ADDRESSING THE MVT\n         L        TIBREG,CWBTIB     RESTORE POINTER TO TIB\n         DROP     TVBREG\n         USING    DSITIB,TIBREG     ADDRESSING THE TIB\n         L        PDBREG,CWBPDB     GET POINTER TO PDB\n         USING    DSIPDB,PDBREG     ADDRESSING PDS\n*   INITIALIZE THE BUFFER HEADER AS REQ'ED BY NETVIEW                 *\n         LA       BUFREG,BUFRSTOR   GET ADDRESS OF BUFFER\n         USING    BUFHDR,BUFREG     ADDRESSING THE BUFFER HEADER\n         ST       BUFREG,BUFRSVAD   STORE ADDRESS OF BUFFER\n         LA       R15,MSGMXBFL\n         STH      R15,HDRBLENG      STORE BUFFER HDR LENGTH\n         MVI      HDRMTYPE,HDRTYPEU STORE BUFFER TYPE\n         LA       R15,HDRTEXT-BUFHDR\n         STH      R15,HDRTDISP      STORE BUFFER TEXT OFFSET\n         MVC      HDRDOMID,MVTCURAN STORE NETVIEW DOMAIN ID\n*   PERFORM KEYWORDS PARSING ..................................       *\n*   CHECK # OF PDB ENTRIES.  IT MUST BE AN ODD NUMBER AND .GE. 3      *\n*         REG 2  - POINTS TO A PDB ENTRY                              *\n*         REG 3  - LENGTH OF KEYWORD IN THE BUFFER                    *\n*         REG 4  - POINTS TO A KEYWORD/KEYWORD VALUE IN BUFFER        *\n*         REG 5  - SEARCH LOOP CONTROL VALUE                          *\n*         REG 6  - POINTS TO A GROUP OF FORMAT KEYWORDS               *\n*         REG 7  - POINTS TO THE OUTPUT AREA FOR STORING KW/KW-VALUE  *\n         CLI      PDBNOENT+1,X'03'  NUMBER OF PDB ENTRIES < 3 ?\n         BNL      MLSL#001          NO - ENOUGH FOR A VALID COMMAND\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE\n         DC       Y(BADSYNTX)       INVALID SYNTAX\n         B        MLSRETRN          TERMINATING\nMLSL#001 DS       0H\n         TM       PDBNOENT+1,X'01'  # OF ENTRIES IS ODD NUMBER ?\n         BO       MLSL#002          YES - ORPHAN KEYWORDS IMPOSSIBLE\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE\n         DC       Y(BADSYNTX)       INVALID SYNTAX\n         B        MLSRETRN          TERMINATING\nMLSL#002 DS       0H\n         MVI      FMT2SW,X'00'      INIT FMT2 SWITCH =  0\n         MVI      VERIFYSW,X'00'    INIT VERIFY SWITCH =  0\n         MVI      OUTAREA,C' '      INIT 32-BYTE OUTAREA = C' '\n         MVC      OUTAREA+1(31),OUTAREA\n         XR       R3,R3             R3 = 0\n         LA       R6,KEYWDFM1       ADDRESS OF FMT 1 KEYWORDS\nSRCKEYWD DS       0H                ..........................LOOP1 BEG IN--1\n         LA       R7,OUTAREA        ADDRESS OF OUTPUT AREA                  1\nSRCNXTKW DS       0H                ..........................LOOP2 BEG IN-21\n         CLI      0(R6),C' '        LAST KEYWORD SEARCHED?                 21\n         BE       SRCDONE           YES - SEARCH DONE                      21\n         LH       R5,PDBNOENT       GET NUMBER OF ENTRIES IN PDB           21\n         SRL      R5,1              DIVIDE BY 2 FOR LOOP CONTROL           21\n         LA       R2,PDBTABLE       ADDRESS OF FIRST PDB ENTRY             21\n         USING    PDBENTRY,R2       ADDRESSABILITY FOR PDBENTRY            21\n*   THE FOLLOWING FORMS A LOOP TO SEARCH THE PDB FOR THE KEYWORDS.    *    21\n*   IF UNRECOGNIZED KEYWORD IS FOUND, TERMINATE THE PROCESS WITH      *    21\n*   ERROR MESSAGE; OTHERWISE CONTINUE THE SEARCH UNTIL END OF PDB.    *    21\nPDBLOOP  DS       0H                CONTROLLED BY R5 .......LOOP3 BEGIN --321\n         LA       R2,PDBENTND       ADDRESS OF NEXT PDB ENTRY.            321\n         L        R4,CWBBUF         ADDRESS OF THE PASSED BUFFER          321\n         AH       R4,PDBDISP        ADD DISPLACEMENT IN BUFFER            321\n         IC       R3,PDBLENG        GET KW LENGTH                         321\n         LTR      R3,R3             KW LENGTH = 0 ?                       321\n         BNZ      MLSL#003          NO - PROCESS KW TEXT                  321\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE              321\n         DC       Y(BADKEYWD)       INVALID KW LENGTH                     321\n         B        MLSRETRN          TERMINATING                           321\nMLSL#003 DS       0H                                                      321\n         LA       R1,PDBTABLE       R1=START OF PDB ENTRIES               321\n         SR       R1,R2             COMPUTE OFFSET OF CURRENT ENTRY       321\n         LCR      R1,R1             -VE RESULT, MAKE IT +VE               321\n         SR       R0,R0             CLEAR EVEN REG FOR DIVISION           321\n         D        R0,PDBENTLN       COMPUTE POSITION OF PDB TABLE ENTRY   321\n         LA       R1,1(,R1)         MAKE RESULT RELATIVE TO 1             321\n         ST       R1,PDBPOSEN       STORE +VE NUMBER FOR DSIPAS CALL      321\n         DSIPAS   PDB=(CWBPDB,      CALL PARAMETER/ALIAS SERVICES      *  321\n               PDBPOSEN),           ENTRY # OF PARAMETER               *  321\n               OUT=KEYWDTXT,        RETURN VALUE IF FOUND ON SCT       *  321\n               SWB=CWBSWB                                                 321\n         B        *+4(R15)          RETURN CODE FROM DSIPAS CALL          321\n         B        GOODKYWD          = 0 - REGULAR PARM VALUE RETURNED     321\n         B        *+4               = 4 - SAME PARM RETURNED              321\n         BAS      R14,MLSERRTN      = 8 - INVALID PARAMETER               321\n         DC       Y(UNDKEYWD)       UNDEFINED KEYWORD ON SCT              321\n         B        MLSRETRN          TERMINATING                           321\n         SPACE                                                            321\nGOODKYWD DS       0H                                                      321\n         LA       R2,PDBENTND       POINT TO NEXT PDB ENTRY               321\n         CLC      0(2,R6),KEYWDTXT  COMPARE WITH WANTED KEYWORD ?         321\n         BE       GETKWVAL          SAME - GET KW VALUE                   321\n         BCT      R5,PDBLOOP        LOOP TILL PDB END REACHED ......END --321\n         B        NEXTKYWD          SEARCH FOR NEXT KEYWORD.               21\n*   MOVE KEYWORD VALUE TO OUTPUT AREA. ENSURE 0 < KW LENGTH < 9       *    21\n*         REG 3  - LENGTH OF KEYWORD VALUE IN BUFFER                  *    21\n*         REG 4  - POINTS TO THE KEYWORD VALUE IN THE BUFFER          *    21\n*         REG 6  - POINTS TO APPROPRIATE SET OF FORMAT KEYWORDS       *    21\n*         REG 7  - POINTS TO OUTPUT AREA                              *    21\nGETKWVAL DS       0H                                                       21\n         CLC      0(2,R6),=CL2'VE'  IS KEYWORD VERIFY ?                    21\n         BNE      MLSL#004          NO...                                  21\n         MVI      VERIFYSW,X'01'    YES, TURN ON THE VERIFY SWITCH         21\nMLSL#004 DS       0H                                                       21\n         L        R4,CWBBUF         ADDRESS OF THE BUFFER PASSED           21\n         AH       R4,PDBDISP        ADD DISPLACEMENT                       21\n         IC       R3,PDBLENG        LENGTH OF KW VALUE IN BUFFER           21\n         LTR      R3,R3             LENGTH = 0 ?                           21\n         BNZ      MLSL#005          NO - PROCESS ITS TEXT                  21\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE               21\n         DC       Y(BADKEYWD)       INVALID LENGTH                         21\n         B        MLSRETRN          TERMINATING                            21\nMLSL#005 DS       0H                                                       21\n         CH       R3,=H'8'          LENGTH OF OPERAND > 8 ?                21\n         BNH      MLSL#006          NO - PROCESS OPERAND TEXT              21\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE               21\n         DC       Y(BADKEYWD)       INVALID LENGTH                         21\n         B        MLSRETRN          TERMINATING                            21\nMLSL#006 DS       0H                                                       21\n         BCTR     R3,0              -1 FOR EX                              21\n         EX       R3,MVCFMBUF       MOVE TO OUTPUT AREA FROM BUFFER        21\n         DSIKVS   SWB=CWBSWB,       CALL KEYWORD/VALUE SERVICES        *   21\n               SCTADDR=PDBCMDA,     TO DETERMINE IF AN OPERATOR IS     *   21\n               KEYWORD=KEYWDTXT     AUTHORIZED TO USE A GIVEN KEYWORD      21\n         LTR      R15,R15           WITHIN OPERATOR'S SCOPE OF COMMAND?    21\n         BZ       NEXTKYWD          YES - PROCESS NEXT KEYWORD             21\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE               21\n         DC       Y(BADSCOPE)       BAD OPERATOR SCOPE                     21\n         B        MLSRETRN          TERMINATING                            21\nMVCFMBUF MVC      0(1,R7),0(R4)     MOVE VALUE OUT OF BUFFER               21\nNEXTKYWD DS       0H                                                       21\n         LA       R6,2(R6)          POINT TO NEXT KEYWORD                  21\n         LA       R7,8(R7)          AREA FOR NEXT KEYWORD VALUE            21\n         B        SRCNXTKW          GO FIND THIS NEW KEYWORD.       END ---21\nSRCDONE  DS       0H                                                        1\n         CLI      FMT2SW,X'01'      IS FORMAT 2 SWITCH ON?                  1\n         BE       MLSFMT2           YES... IT IS FORMAT 2                   1\n         CLI      OUTAREA,C' '      FORMAT 1 CTL BLK NAME SPECIFIED ?       1\n         BNE      MLSFMT1           YES... IT IS FORMAT 1                   1\n         MVI      FMT2SW,X'01'      SET FORMAT 2 SWITCH ON                  1\n         LA       R6,KEYWDFM2       ADDRESS OF FORMAT 2 KEYWORDS            1\n         B        SRCKEYWD          START TO SEARCH FMT2 KEYWORDS   END ----1\n*   FORMAT 1 KEYWORD PROCESSING BEGINS ............................   *\n*   CHECK VALUES FOR FORMAT 1 KEYWORDS.  IF NO VALUE ENTERED,         *\n*   DEFAULT VALUE IS USED.                                            *\n*   FOR LENGTH    - DEFAULT VALUE IS CTL BLK LENGTH OR 1K BYTES,      *\n*                   WHICHEVER IS SMALLER                              *\n*   IF LENGTH=*   - ACTUAL CTL BLK LENGTH IS USED, REGARDLESS OF THE  *\n*                   1K BYTES LIMIT                                    *\n*   FOR TERM-ID   - LU FROM WHICH COMMAND IS ENTERED                  *\n*                   IF ENTERED, TVB CHAIN IS SEARCHED TO LOCATE TVB   *\n*                   FOR THAT TERM-ID                                  *\n*        REG 2  - POINTS TO FIRST TVB IN TVB CHAIN                    *\n*        REG 4  - POINTS TO OUTPUT AREA FOR DSILCS                    *\n*        REG 15 - RETURN CODE FROM DSILCS                             *\nMLSFMT1  DS       0H                CHECK LU\n         L        R2,MVTTVB         ADDRESS OF FIRST TVB OFF MVT\n         LA       R4,TVBSAVAD       ADDRESS FOR OUTPUT FROM DSILCS\n         CLI      OUTAREA+16,C' '   VALUE FOR LUNAME SPECIFIED ?\n         BE       CHEKOPER          NO; CHECK OPER\n         LA       R3,OUTAREA+16     ADDRESS OF LUNAME AREA.\n         DSILCS   TVB=(R2),         LOCATE TVB BY LUNAME               *\n               LU=(R3),CBADDR=(R4)\n         LTR      R15,R15           LOCATE OK ?\n         BZ       MLSL#007          YES - CONTINUE\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE\n         DC       Y(BADLUID)        NO TVB LOCATED\n         B        MLSRETRN          TERMINATING\n*   FOR OPER-ID   - DEFAULT IS OPERATOR WHO ENTERS THE COMMAND        *\n*   IF OPER-ID IS ENTERED, SEARCH TVB CHAIN FOR THAT OPER-ID.         *\n*        REG 4  - ADDRESS OF OUTPUT AREA FOR DSILCS                   *\n*        REG 8  - FIRST TVB IN TVB CHAIN                              *\n*        REG 15 - RET CODE FROM DSILCS                                *\nCHEKOPER DS     0H\n         CLI      OUTAREA+24,C' '   VALUE FOR OP-ID SPECIFIED ?\n         BE       MLSL#007          NO - FMT 1 IS OK AS IT IS\n         LA       R3,OUTAREA+24     ADDR OF 8-BYTE OP-ID AREA\n         DSILCS   TVB=(R2),         LOCATE TVB BY OPER-ID              *\n               OPID=(R3),CBADDR=(R4)\n         LTR      R15,R15           LOCATE OK ?\n         BZ       MLSL#007          YES - START LOOKUP\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE\n         DC       Y(BADOPID)        NO TVB LOCATED\n         B        MLSRETRN          TERMINATING\nMLSL#007 DS       0H\n         L        TVBREG,TVBSAVAD   GET ADDRESS OF TVB\n         DROP     TIBREG\n         USING    DSITVB,TVBREG     ADDRESSING THE TVB\n         L        TIBREG,TVBTIB     ADDRESSING TIB FROM TVB\n         DROP     TVBREG\n         USING    DSITIB,TIBREG     ADDRESSING THE TIB\n         LTR      TIBREG,TIBREG     TIB EXISTS FOR OPER-ID/TERM-ID?\n         BNZ      MLSL#008          YES\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE\n         DC       Y(BADTIB)         NO ACTIVE TIB FOR OPERATOR/TERMINAL\n         B        MLSRETRN          TERMINATING\nMLSL#008 DS       0H\n*   SEARCH CONTROL BLOCK NAME AGAINST THE PREDEFINED CB_LIST;         *\n*   IF FOUND, STORE ITS LENGTH, IT CAN BE 4-BYTE, 2-BYTE, OR 1-BYTE.  *\n         L        R3,OUTAREA        YES - GET CTL BLOCK NAME\n         LA       R2,LOD2BYTE       BR TO LOAD 2-BYTE LENGTH\n         LA       R6,CB_LIST        ADDRESS OF CB-NAME TABLE.\nCHEKCBNM DS       0H\n         LM       R4,R5,0(R6)       GET NAME AND BRANCH ADDRESS\n         LTR      R4,R4             END OF TABLE WITH NO MATCH ?\n         BNZ      MLSL#009          NO - START PROCESSING BLOCK\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE ABOUT\n         DC       Y(BADCTLBK)       INVALID CONTROL BLOCK SPECIFIED\n         B        MLSRETRN          TERMINATING\nMLSL#009 DS       0H\n         CR       R3,R4             NO, ARE TWO NAMES THE SAME ?\n         BER      R5                YES - GET ADDRESS AND LENGTH OF CB\n         LA       R6,8(R6)          NO - CHECK NEXT ENTRY IN TABLE\n         B        CHEKCBNM          LOOP BACK TO CHECK AGAIN\n*   DEPENDING ON THE CTL BLK NAME ENTERED, THE CTL BLK                *\n*   ADDRESS IS FOUND EITHER FROM THE MVT OR THE TIB.                  *\n*   MOST CONTROL BLOCKS HAVE LENGTH = 2 BYTES;  TO SAVE 2 BYTES FOR   *\n*   EACH BRANCH, \"BR R2\" IS USED INSTEAD OF \"B LOD2BYTE\".             *\n*        REG 4  - POINTS TO THE DESIRED CTL BLK                       *\n*        REG 9  - POINTS TO MVT                                       *\n*        REG 11 - POINTS TO TIB                                       *\nCB_ART   DS       0H\n         L        R4,MVTART         ART (4-BYTE LENGTH)\n         B        LOD4BYTE          GET LENGTH\nCB_DQT   DS       0H\n         L        R4,MVTDQT         DQT (4-BYTE LENGTH)\n         B        LOD4BYTE          GET LENGTH\nCB_SCT   DS       0H\n         L        R4,MVTSCT         SCT (4-BYTE LENGTH)\n         B        LOD4BYTE          GET LENGTH\nCB_MVT   DS       0H\n         LR       R4,MVTREG         IT'S MVT, LOAD ITS ADDRESS,\n         BR       R2                GET LENGTH, R2 --> LOD2BYTE\nCB_SNT   DS       0H\n         L        R4,MVTSNT         SNT\n         BR       R2                GET LENGTH\nCB_OIT   DS       0H\n         L        R4,MVTOIT         OIT\n         BR       R2                GET LENGTH\nCB_DDT   DS       0H\n         L        R4,MVTDDT         DDT\n         BR       R2                GET LENGTH\nCB_SVL   DS       0H\n         L        R4,MVTSVL         SVL\n         BR       R2                GET LENGTH\nCB_TIB   DS       0H\n         LR       R4,TIBREG         TIB\n         BR       R2                GET LENGTH\nCB_TVB   DS       0H\n         L        R4,TIBTVB         TVB\n         BR       R2                GET LENGTH\nCB_ACB   DS       0H\n         L        R4,TIBACB         ACB\n         BR       R2                GET LENGTH\nCB_NCCWB DS       0H\n         L        R4,TIBNCCWB       NCCWB\n         BR       R2                GET LENGTH\nCB_ICCWB DS       0H\n         L        R4,TIBICCWB       ICCWB\n         BR       R2                GET LENGTH\nCB_MRCWB DS       0H\n         L        R4,TIBMRCWB       MRCWB\n         BR       R2                GET LENGTH\nCB_EXSWB DS       0H\n         L        R4,TIBEXSWB       EXSWB\n         BR       R2                GET LENGTH\nCB_NPSWB DS       0H\n         L        R4,TIBNPSWB       NPSWB\n         BR       R2                GET LENGTH\nCB_NCPDB DS       0H\n         L        R4,TIBNCPDB       NCPDB\n         BR       R2                GET LENGTH\nCB_MRPDB DS       0H\n         L        R4,TIBMRPDB       MRPDB\n         BR       R2                GET LENGTH\nCB_ICPDB DS       0H\n         L        R4,TIBICPDB       ICPDB\n         BR       R2                GET LENGTH\nCB_ORRPL DS       0H\n         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'\n         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION\n         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION\n         L        R4,TIOORRPL       YES - IT IS OPER REC VTAM RPL\n         DROP     R4\n         B        LOD1BYTE          GET 1-BYTE LENGTH\nCB_OSRPL DS       0H\n         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'\n         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION\n         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION\n         L        R4,TIOOSRPL       YES - IT IS OPER SEND VTAM RPL\n         DROP     R4\n         B        LOD1BYTE          GET LENGTH\nCB_RCRPL DS       0H\n         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'\n         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION\n         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION\n         L        R4,TIORCRPL       YES - IT IS POI REC-CMD VTAM RPL\n         DROP     R4\n         B        LOD1BYTE          GET LENGTH\nCB_SCRPL DS       0H\n         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'\n         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION\n         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION\n         L        R4,TIOSCRPL       YES - IT IS POI SEND-RCM VTAM RPL\n         DROP     R4\n         B        LOD1BYTE          GET LENGTH\nCB_RARPL DS       0H\n         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'\n         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION\n         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION\n         L        R4,TIORARPL       YES - IT IS NNT REC ANY VTAM RPL\n         DROP     R4\n         B        LOD1BYTE          GET LENGTH\nCB_RSRPL DS       0H\n         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'\n         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION\n         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION\n         L        R4,TIORSRPL       YES - IT IS NNT REQ SESS VTAM RPL\n         DROP     R4\n         B        LOD1BYTE          GET LENGTH\nCB_PRRPL DS       0H\n         BAS      R14,PPTTYX00      CHECK TYPE OF TIB -X'00'\n         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION\n         USING    TIBPPT,R4         ADDRESSING THE PPT EXTENSION\n         L        R4,TIPRCRPL       YES - IT IS POI REC-CMD VTAM RPL\n         DROP     R4\n         B        LOD1BYTE          GET LENGTH\nCB_PSRPL DS       0H\n         BAS      R14,PPTTYX00      CHECK TYPE OF TIB -X'00'\n         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION\n         USING    TIBPPT,R4         ADDRESSING THE PPT EXTENSION\n         L        R4,TIPSCRPL       YES - IT IS POI SEND-CMD VTAM RPL\n         DROP     R4                POI SEND-CMD VTAM RPL\n         B        LOD1BYTE          GET LENGTH\nCB_OSNIB DS       0H\n         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'\n         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION\n         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION\n         L        R4,TIOOSNIB       YES - IT IS OPER STATION NIB\n         DROP     R4\n         B        LOD1BYTE          GET LENGTH\nCB_CDNIB DS       0H\n         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'\n         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION\n         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION\n         L        R4,TIOCDNIB       YES - IT IS CROSS-DOM SESS NIB\n         DROP     R4\n         B        LOD1BYTE          GET LENGTH\nCB_SAT   DS       0H\n         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'\n         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION\n         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION\n         L        R4,TIOSAUTH       YES - IT IS SAT\n         DROP     R4\n         BR       R2                GET LENGTH\nCB_NAT   DS       0H\n         BAS      R14,OSTTYX02      CHECK TYPE OF TIB-X'02'\n         L        R4,TIBEXPTR       GET ADDRESS OF EXTENSION\n         USING    TIBOST,R4         ADDRESSING THE OST EXTENSION\n         L        R4,TIONAUTH       YES - IT IS NAT\n         DROP     R4\n         BR       R2                GET LENGTH\n*   SAVE THE ADDRESS AND THE LENGTH OF THE WANTED CONTROL BLOCK       *\n*        REG 4  - ADDRESS OF THE CONTROL BLOCK                        *\n*        REG 5  - LENGTH OF THE CONTROL BLOCK                         *\nLOD4BYTE DS       0H\n         L        R5,4(R4)          GET LENGTH (4-BYTE)\n         B        STORELEN          GO SAVE LENGTH\nLOD2BYTE DS       0H\n         LH       R5,2(R4)          GET LENGTH (2-BYTE)\n         B        STORELEN          GO SAVE LENGTH\nLOD1BYTE DS       0H\n         XR       R5,R5             ZERO REGISTER\n         IC       R5,3(R4)          GET LENGTH (1-BYTE)\nSTORELEN DS       0H\n         CH       R4,=H'0'          CTL BLK ADDRESS = 0 ?\n         BH       MLSL#010          NO\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE\n         DC       Y(BADCBADR)       BAD CTL BLK ADDRESS\n         B        MLSRETRN          TERMINATING\nMLSL#010 DS       0H\n         ST       R4,ADRFIELD       STORE ADDRESS OF DATA TO DISPLAY\n         CLI      OUTAREA+8,C'*'    CTL BLK ACTUAL LENGTH SPECIFIED ?\n         BE       MLSL#011          YES, STORE IT\n         CLI      OUTAREA+8,C' '    CTL BLK REQ'D LENGTH SPECIFIED ?\n         BNE      XLATLEN           NO, GO FIND ITS LENGTH\n         CH       R5,=H'1024'       IS LENGTH > 1K?\n         BL       MLSL#011          NO\n         LH       R5,=H'1024'       YES; DISPLAY 1K AT MOST\nMLSL#011 DS       0H\n         STH      R5,LENFIELD       STORE LENGTH OF CTL BLK\n         B        DISPLAY           GO DISPLAY CONTROL BLOCK.\nMLSHELP  DS       0H                IT IS HELP. DISPLAY DIRECTIONS.\n*   PRESENT THE HELP PANEL TO USERS                                   *\n         LA       R2,1              GET START OF HELP MESSAGE NUMBER\n         DSIMBS   MID=(R2),         MESSAGE BUFFER SERVICES            *\n               BFR=BUFRSVAD,        BUILD THE FIRST LINE OF HELP TEXT  *\n               MSGTBL=MSGTABAD,                                        *\n               SWB=CWBSWB\n         LTR      R15,R15           WAS BUFFER FILLED SUCCESSFULLY?\n         BNZ      MLSABEND          NO - ISSUE A DEBUGGING ABEND\n         BAS      R14,EDIT_TID      EDIT MESSAGE ID OUT OF THE BUFFER\n         DSIPSS   TYPE=OUTPUT,      PRESENTATION SERVICES              *\n               SWB=CWBSWB,          SEND THE FIRST LINE OF HELP TEXT   *\n               OPTIONS=MSG,         AS A SINGLE MESSAGE                *\n               BFR=BUFRSVAD\n         LTR      R15,R15           WAS TEXT DISPLAYED SUCCESSFULLY?\n         BNZ      MLSABEND          NO - ISSUE A DEBUGGING ABEND\nMLSNXHLP DS       0H\n         LA       R0,HDRTEXT-BUFHDR GET LENGTH OF BUFFER HEADER\n         STH      R0,HDRTDISP       AND STORE IT AS TEXT OFFSET\n         LA       R2,1(,R2)         INCREMENT TO THE NEXT HELP LINE\n         DSIMBS   MID=(R2),         MESSAGE BUFFER SERVICES            *\n               SWB=CWBSWB,          BUILD THE NEXT LINE OF HELP TEXT   *\n               BFR=BUFRSVAD,                                           *\n               MSGTBL=MSGTABAD\n         LTR      R15,R15           WAS BUFFER FILLED SUCCESSFULLY?\n         BNZ      MLSLLHLP          NO - CHECK FOR END OF HELP TEXT\n         BAS      R14,EDIT_TID      EDIT MESSAGE ID OUT OF THE BUFFER\n         DSIPSS   TYPE=OUTPUT,      PRESENTATION SERVICES              *\n               SWB=CWBSWB,          SEND THE LINE OF HELP TEXT     *\n               OPTIONS=SEG,         AS A MESSAGE SEGMENT               *\n               BFR=BUFRSVAD\n         LTR      R15,R15           WAS TEXT DISPLAYED SUCCESSFULLY?\n         BNZ      MLSABEND          NO - ISSUE A DEBUGGING ABEND\n         B        MLSNXHLP          .... GO SEND THE NEXT LINE OF HELP\nMLSLLHLP DS       0H\n         CH       R15,HELPRC12      WAS LAST HELP LINE ALREADY SENT?\n         BNE      MLSABEND          NO - ISSUE DEBUGGING ABEND\n         B        MLSRETRN          .... TERMINATE NORMALLY\n*   FORMAT 2 KEYWORDS PROCESSING BEGINS ..........................    *\n*   USING TRANSLATE TABLES, BOTH ADDRESS AND LENGTH ARE TRANSLATED.   *\nMLSFMT2  DS       0H\n         CLI      OUTAREA,C' '      ADDRESS SPECIFIED ?\n         BNE      MLSL#012          YES\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE\n         DC       Y(BADSYNTX)       INVALID COMMAND SYNTAX\n         B        MLSRETRN          TERMINATING\nMLSL#012 DS       0H\n         CLI      OUTAREA+8,C' '    LENGTH SPECIFIED ?\n         BNE      MLSL#013          YES\n         MVI      OUTAREA+8,C'4'    NO - LENGTH 4 IS THE DEFAULT\nMLSL#013 DS       0H\n         TR       OUTAREA(8),XLAT_TB1 XLATE ADDRESS FOR SYNTAX CHECK\n         XC       PACKAREA,PACKAREA CLEAR OUT THE PACK AREA\n         XR       R6,R6             R6 TO COUNT NUMBER OF DIGITS\n         LA       R7,OUTAREA        ADDRESS OF THE OUTPUT AREA\n         BAS      R14,CKSYNTAX      GO CHECK THE SYNTAX\n         ST       R6,ADRFIELD       SAVE START OF ADDRESS\n         CLI      VERIFYSW,X'00'    VERIFY SWITCH ON ?\n         BE       XLATLEN           NO; GO GET ITS LENGTH VALUE\n         CLI      OUTAREA+23,C' '   VERIFY FIELD < 8 CHARS ?\n         BE       MLSL#014          YES, ERROR\n         CLI      OUTAREA+31,C' '   REPLACE FIELD < 8 CHARS ?\n         BNE      XLATVRFY          NO; GET ITS VERIFY/REPLACE VALUES\nMLSL#014 DS       0H\n         BAS      R14,MLSERRTN      ISSUE ERROR MESSAGE\n         DC       Y(BADVRFLD)       VERIFY/REPLACE FIELD < 8 CHARS\n         B        MLSRETRN          TERMINATING\n*   TRANSLATE BOTH VERIFY AND REPLACE FIELDS                          *\nXLATVRFY DS       0H\n         TR       OUTAREA+16(8),XLAT_TB1  VERIFY FIELD\n         XC       PACKAREA,PACKAREA CLEAR OUT THE PACK AREA\n         XR       R6,R6             R6  TO COUNT NUMBER OF DIGITS\n         LA       R7,OUTAREA+16     ADDRESS OF THE OUTPUT AREA\n         BAS      R14,CKSYNTAX      GO CHECK THE SYNTAX\n         ST       R6,VERFIELD       SAVE VERIFY XLAT'ED RESULT\n         TR       OUTAREA+24(8),XLAT_TB1  REPLACE FIELD\n         XC       PACKAREA,PACKAREA CLEAR OUT THE PACK AREA\n         XR       R6,R6             R6  TO COUNT NUMBER OF DIGITS\n         LA       R7,OUTAREA+24     ADDRESS OF THE OUTPUT AREA\n         BAS      R14,CKSYNTAX      GO CHECK THE SYNTAX\n         ST       R6,REPFIELD       SAVE REPLACE XLAT'ED RESULT\n         B        REPLACE           GO FOR REPLACE FUNCTION\nXLATLEN  DS       0H                TRANSLATE LENGTH VALUE\n         CLI      OUTAREA+8,C'X'    IS LENGTH SPECIFIED IN HEX ?\n         BE       XLATHEX           YES - TRANSLATE IT\n         TR       OUTAREA+8(6),XLAT_TB2  NO - IT IS DEC, TRANSLATE IT\n         MVC      PACKAREA,OUTAREA+8\n         MVI      OUTAREA+8,C'D'    PREFIX WITH 'D' TO INDICATE DEC\n         MVC      OUTAREA+9(6),PACKAREA\n         B        XLATDONE          GO TO CHECK SYNTAX\nXLATHEX  DS       0H\n         TR       OUTAREA+9(6),XLAT_TB1 TRANSLATE HEX LENGTH\nXLATDONE DS       0H\n         XC       PACKAREA,PACKAREA CLEAR OUT THE PACK AREA\n         XR       R6,R6             R6  TO COUNT NUMBER OF DIGITS\n         LA       R7,OUTAREA+9      ADDRESS OF OUTPUT AREA\n         BAS      R14,CKSYNTAX      GO CHECK SYNTAX\n         STH      R6,LENFIELD       SAVE LENGTH\n         CLI      OUTAREA+8,C'X'    LENGTH IS SPECIFIED IN HEX ?\n         BE       DISPLAY           YES - GO TO DISPLAY FUNCTION\n         CVB      R6,PACKAREA       NO - CONVERT IT TO HEX\n         STH      R6,LENFIELD       SAVE IT\n         DROP     R2\n*  DISPLAY OR REPLACE FUNCTION BEGINS ..............................  *\n*  FOR DISPLAY, LINES ARE BUILT IN THE GENERAL PURPOSE NETVIEW        *\n*  BUFFER FORMATTED IN THE CWB WORKAREA.                              *\n*  FOR REPLACE, VERIFICATION IS DONE BEFORE REPLACING.                *\n*  ADRFIELD - ADDRESS OF STORAGE TO BE DISPLAYED OR REPLACED          *\n*  LENFIELD - LENGTH OF STORAGE      (DISPLAY FUNCTION)               *\n*  VERFIELD - CONTENT TO BE VERIFIED (REPLACE FUNCTION)               *\n*  REPFIELD - REPLACING CONTENT      (REPLACE FUNCTION)               *\n*  TO TRAP OC4 CAUSED BY DISPLAY OR REPLACE FUNCTION,  AN MVS ESPIE   *\n*  MACRO ISSUED.                                                      *\nDISPLAY  DS       0H\nREPLACE  DS       0H\n         ESPIE    SET,OC4RUTIN,4,   SET UP ENVIRONMENT TO TRAP OC4     *\n               MF=(E,SPIELISF)\n         ST       R1,SPIEPTOK       SAVE PREVIOUS (OLD) ESPIE TOKEN\n         CLI      VERIFYSW,X'01'    REPLACE FUNCTION ?\n         BNE      DISPLAY1          NO, CONTINUE TO DISPLAY\n         L        R3,ADRFIELD       GET ADDRESS FOR VERIFYING CONTENTS\n         CLC      VERFIELD,0(R3)    VERIFY CONTENTS AGAINST VERFIELD\n         BE       REPLACE1          EQUAL, GO FOR REPLACE\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE\n         DC       Y(BADVERFY)       VERIFY FAIL\n         B        MLSRETRN          TERMINATING\nREPLACE1 DS       0H\n         MVC      0(4,R3),REPFIELD  REPLACING\n         BAS      R14,MLSERRTN      TELL REPLACE DONE\n         DC       Y(REPLCEOK)\n         B        MLSRETRN          REPLACE FUNCTION COMPLETE;RETURN\nDISPLAY1 DS       0H\n         MVI      HDRMTYPE,HDRTYPEU INDICATE USER GENERATED MESSAGE\n         DSIMBS   MID=*HDRLINE,     MESSAGE BUFFER SERVICES            *\n               BFR=BUFRSVAD,        BUILD THE DISPLAY TITLE MESSAGE    *\n               MSGTBL=MSGTABAD,     LINE IN THE BUFFER                 *\n               SWB=CWBSWB\n         LTR      R15,R15           MESSAGE MOVED OK ?\n         BNZ      MLSABEND          NO - ISSUE A DEBUGGING ABEND\n         BAS      R14,EDIT_TID      EDIT MESSAGE ID OUT OF THE BUFFER\n         DSIPSS   TYPE=OUTPUT,      PRESENTATION SERVICES              *\n               OPTIONS=MSG,         SEND THE DISPLAY TITLE LINE        *\n               BFR=BUFRSVAD,        TO THE OPERATOR'S SCREEN           *\n               SWB=CWBSWB\n         LTR      R15,R15           WAS TITLE WRITTEN SUCCESSFULLY?\n         BNZ      MLSABEND          NO - ISSUE DEBUGGING ABEND\n         LA       R0,MSGTXTLN       GET LENGTH OF DISPLAY LINE TEXT\n         STH      R0,HDRMLENG       AND STORE IT IN THE HEADER\n         LA       R0,HDRTEXT-BUFHDR GET LENGTH OF BUFFER HEADER\n         STH      R0,HDRTDISP       STORE IT AS TEXT OFFSET\n         XC       ADROFSET,ADROFSET CLEAR DISPLAY STORAGE OFFSET FIELD\nNXTSEGMT DS       0H\n* DISPLAY A STORAGE SEGMENT BY REUSING THE PREVIOUSLY FORMATTED       *\n* BUFFER.                                                             *\n         LA       R0,MSGTEXT        GET ADDRESS OF MESSAGE TEXT AREA\n         LA       R1,MSGMXTXL       GET LENGTH OF MESSAGE TEXT AREA\n         LR       R2,R0             DUPLICATE ADDRESS TO CLEAR TEXT\n         LA       R3,BLANK          GET ' ' CHARACTER TO CLEAR AREA\n         SLL      R3,SHIFT24        SHIFT LEFT 24 BITS\n         MVCL     R0,R2             CLEAR OUT THE TEXT AREA\n         LA       R3,ADRFIELD       POINT AT BINARY ADDRESS FIELD\n         LA       R2,MSGRECAD       POINT AT RECEIVING FIELD\n         LA       R1,L'ADRFIELD     GET LENGTH OF ADDRESS FIELD\n         BAS      R14,CVTBINHX      CONVERT THE HEX DATA TO EBCDIC\n         LA       R3,ADROFSET       POINT AT BINARY OFFSET FIELD\n         LA       R2,MSGRELAD       POINT AT RECEIVING FIELD\n         LA       R1,L'ADROFSET     GET LENGTH OF OFFSET FIELD\n         BAS      R14,CVTBINHX      CONVERT THE HEX DATA TO EBCDIC\n         L        R1,ADRFIELD       GET ADDRESS OF NEXT BYTE TO DISPLAY\n         SR       R0,R0             CLEAR EVEN REGISTER FOR DIVIDE\n         D        R0,MAXSEQLN       EXTRACT SEGMENT MULTIPLE AND OFFSET\n         STH      R0,DSEGOFFT       SAVE SEGMENT OFFSET FOR LATER USE\n         LCR      R0,R0             MAKE SEGMENT OFFSET -VE\n         A        R0,MAXSEQLN       COMPUTE SEGMENT LENGTH TO DISPLAY\n         CH       R0,LENFIELD       SEGMENT LENGTH \u00ac> STORAGE LENGTH?\n         BNH      MLSL#015          YES - USE SEGMENT LENGTH TO DISPLAY\n         LH       R0,LENFIELD       .... USE STORAGE LENGTH TO DISPLAY\nMLSL#015 DS       0H\n         STH      R0,DSEGLEN        STORE AMOUNT OF SEGMENT TO DISPLAY\n         L        R3,ADRFIELD       GET ADDRESS OF STORAGE TO DISPLAY\n         MVC      DBYTECTR,DSEGLEN  SAVE DISPLAY BYTE DOWN COUNTER\n         MVC      DBYTEOFF,DSEGOFFT SET BYTE OFFSET IN SEGMENT\nUNPKNXTU DS       0H                UNPACK NEXT STORAGE UNIT\n*   FORM A LOOP TO UNPACK EACH SINGLE STORAGE UNIT OF DATA AND        *\n*   CONVERT IT TO HEXADECIMAL                                         *\n         SR       R0,R0             CLEAR EVEN REGISTER FOR DIVIDE\n         LH       R1,DBYTEOFF       GET SEGMENT OFFSET OF NEXT BYTE\n         D        R0,MAXUNTLN       EXTRACT UNIT MULTIPLE AND OFFSET\n         SLL      R1,1              MAKE UNIT MULTIPLE A HALFWORD INDEX\n         LH       R2,MSGUNITX(R1)   & USE IT TO PICK UP THE UNIT INDEX\n         LA       R2,MSGTEXT(R2)    COMPUTE ADDRESS FOR HEX CHARACTERS\n         AR       R2,R0             ADJUST ADDRESS BY UNIT OFFSET\n         AR       R2,R0             MULTIPLIED BY 2 (2 BYTES/HEX CHAR)\n         LCR      R1,R0             MAKE UNIT OFFSET -VE\n         A        R1,MAXUNTLN       COMPUTE UNIT LENGTH TO DISPLAY\n         CH       R1,DBYTECTR       UNIT LENGTH \u00ac> SEGMENT REMAINING?\n         BNH      MLSL#016          YES - USE UNIT LENGTH FOR DISPLAY\n         LH       R1,DBYTECTR       .... USE SEGMENT REMAINDER\nMLSL#016 DS       0H\n         BAS      R14,CVTBINHX      CONVERT HEX DATA TO DISPLAY HEX\n         AR       R3,R1             BUMP STORAGE POINTER TO NEXT UNIT\n         LR       R0,R1             GET COPY OF LENGTH FOR CALCULATION\n         AH       R0,DBYTEOFF       INCREMENT BYTE OFFSET BY LENGTH\n         STH      R0,DBYTEOFF       OF UNIT CONVERTED TO DISPLAY HEX\n         LCR      R0,R1             GET COPY OF LENGTH FOR CALCULATION\n         AH       R0,DBYTECTR       IS ENTIRE SEGMENT UNPACKED?\n         STH      R0,DBYTECTR       STORE BACK UPDATED DOWN-COUNTER\n         BNZ      UNPKNXTU          NO - GO UNPACK THE NEXT UNIT\n*   AFTER CONVERTING NON-DISPLAYABLE CHARACTERS TO ITS SUBSTITUTION,  *\n*   CALL PRESENTATION SERVICES TO DISPLAY THE BUFFER UNTIL ALL        *\n*   SEGMENTS COMPLETE.                                                *\n*   BEFORE DISPLAYING EACH SEGMENT, TVB'S \"RESET\" INDICATOR IS        *\n*   CHECKED TO FIND OUT IF OPERATOR WANTS TO END THE DISPLAY          *\n*   PREMATURELY.                                                      *\n         MVI      MSGCHAD1,CHARDLIM MOVE IN LEFT CHARACTER DELIMITER\n         LH       R1,DSEGOFFT       GET SEGMENT OFFSET FOR DATA\n         LA       R2,MSGCHAIT(R1)   CALCULATE ADDRESS OF 1ST CHARACTER\n         L        R3,ADRFIELD       GET ADDRESS OF DATA TO DISPLAY\n         LH       R1,DSEGLEN        GET SEGMENT LENGTH FOR DATA\n         BCTR     R1,R0             MAKE LENGTH RELATIVE TO 0\n         EX       R1,MVCTOBUF       MOVE DATA TO BUFFER\n         EX       R1,TRTNDCHA       TRANSLATE NONDISPLAYABLE CHARS\n         MVI      MSGCHAD2,CHARDLIM MOVE IN RIGHT CHARACTER DELIMITER\n         DSIPSS   TYPE=OUTPUT,      PRESENTATION SERVICES              *\n               OPTIONS=SEG,         SEND THE FORMATTED LINE            *\n               BFR=BUFRSVAD,        TO THE OPERATOR'S SCREEN           *\n               SWB=CWBSWB\n         LTR      R15,R15           DATA LINE WRITTEN OK ?\n         BNZ      MLSABEND          NO - ISSUE DEBUGGING ABEND\n         LH       R1,DSEGLEN        GET SEGMENT LENGTH DISPLAYED\n         LR       R0,R1             GET COPY OF LENGTH FOR CALCULATION\n         A        R0,ADRFIELD       UPDATE STORAGE ADDRESS FOR\n         ST       R0,ADRFIELD       NEXT LINE TO BE DISPLAYED\n         LR       R0,R1             GET COPY OF LENGTH FOR CALCULATION\n         AH       R0,ADROFSET       UPDATE STORAGE OFFSET FOR\n         STH      R0,ADROFSET       NEXT LINE TO BE DISPLAYED\n         LCR      R0,R1             GET COPY OF LENGTH FOR CALCULATION\n         AH       R0,LENFIELD       REDUCE LENGTH OF STORAGE FOR\n         STH      R0,LENFIELD       NEXT LINE TO BE DISPLAYED\n         BZ       DISPYEND          STORAGE LENGTH = 0, END OF DISPLAY\n         BAS      R14,*+4           SET LINKREG FOR DEBUGGING\n         BNP      MLSABEND          < 0 - ISSUE DEBUGGING ABEND\n         L        R1,TIBTVB         GET POINTER TO TVB\n         USING    DSITVB,R1         ADDRESSING TVB\n         TM       TVBIND3,TVBRESET  ATTN KEY PRESSED ?\n         DROP     R1\n         BNO      NXTSEGMT          NO - GO DISPLAY NEXT SEGMENT\n         MVI      HDRMTYPE,HDRTYPED INDICATE AN IMMEDIATE MESSAGE\n         DSIMBS   MID=*RESETOK,     MESSAGE BUFFER SERVICES            *\n               BFR=BUFRSVAD,        BUILD AN IMMEDIATE MSG             *\n               MSGTBL=MSGTABAD,     ABOUT TERMINATION OF DISPLAY       *\n               SWB=CWBSWB           DUE TO ATTN KEY PRESSED\n         LTR      R15,R15           WAS MESSAGE MOVED TO BUFFER?\n         BNZ      MLSABEND          NO - ISSUE A DEBUGGING ABEND\n         DSIPSS   TYPE=IMMED,       PRESENTATION SERVICES              *\n               BFR=BUFRSVAD,        SEND THE \"ATTN KEY\" MSG            *\n               SWB=CWBSWB\n         LTR      R15,R15           WAS MESSAGE WRITTEN SUCCESSFULLY?\n         BNZ      MLSABEND          NO - ISSUE DEBUGGING ABEND\n         MVI      HDRMTYPE,HDRTYPEU RESTORE USER MESSAGE INDICATOR\nDISPYEND DS       0H\n         ESPIE    RESET,SPIEPTOK    REINSTATE OLD ESPIE ENVIRONMENT\n         DSIMBS   MID=*ENDLINE,     MESSAGE BUFFER SERVICES            *\n               BFR=BUFRSVAD,        BUILD THE DISPLAY TRAILER MSG      *\n               MSGTBL=MSGTABAD,                                        *\n               SWB=CWBSWB\n         LTR      R15,R15           WAS MESSAGE MOVED TO BUFFER?\n         BNZ      MLSABEND          NO - ISSUE A DEBUGGING ABEND\n         BAS      R14,EDIT_TID      EDIT MESSAGE ID OUT OF THE BUFFER\n         DSIPSS   TYPE=OUTPUT,      PRESENTATION SERVICES              *\n               OPTIONS=SEG,         SEND THE DISPLAY TRAILER LINE      *\n               BFR=BUFRSVAD,        TO OPERATOR'S SCREEN               *\n               SWB=CWBSWB\n         LTR      R15,R15           WAS TITLE WRITTEN SUCCESSFULLY?\n         BNZ      MLSABEND          NO - ISSUE DEBUGGING ABEND\n         B        MLSRETRN          .... RETURN\nMVCTOBUF MVC      0(*-*,R2),0(R3)   MOVE CHARACTER DATA TO BUFFER\nTRTNDCHA TR       0(*-*,R2),XLAT_TB3 TRANSLATE NONDISPLAYABLE DATA\nMLSRETRN DS       0H\n*   RETURN TO CALLER                                                  *\n         XR       R15,R15           ZERO RETURN CODE REGISTER.\n         LA       R15,ZERO          GET RETURN CODE VALUE.\n         L        R13,4(,R13)       POINT BACK TO RECEIVED SAVEAREA\n         RETURN   (14,12),T,RC=(15) RETURN TO NETVIEW\nMLSABEND DS       0H\n*   COMMAND PROCESSOR ABEND ROUTINE                                   *\n*   IT IS AN ABNORMAL SITUATION, HENCE A DUBUGGING DUMP IS PRODUCED.  *\n*   REG14 TELLS WHERE THE LAST SERVICE REQUEST MACRO WAS ISSUED       *\n*   REG15 TELLS THE RETURN CODE FROM THE REQUEST MACRO                *\n         DC       Y(0)              INTENTIONAL OC1\nCVTBINHX DS       0H\n*   CONVERT BINARY DATA TO EBCDIC DATA.                               *\n*   REG1 - LENGTH  OF BINARY DATA                                     *\n*   REG2 - ADDRESS OF CONVERTED DATA                                  *\n*   REG3 - ADDRESS OF BINARY DATA                                     *\n         BCTR     R1,R0             MAKE BYTE COUNT RELATIVE TO 0\n         EX       R1,MVCTOWKF       MOVE THE BINARY DATA TO WORK FIELD\n         LA       R1,1(,R1)         RESTORE ACTUAL BYTE COUNT\n         EX       R1,CVTBIZHX       UNPACK BINARY TO ZONED HEXADECIMAL\n         TR       ZONHEXRF,XLAT_TB4 CONVERT ZONED HEXADECIMAL TO EBCDIC\n         SLL      R1,1              2*(DATA LENGTH) = CHARACTER LENGTH\n         LA       R15,L'HEXRECFD    GET LENGTH OF DISPLAY HEX FIELD\n         SR       R15,R1            CALCULATE OFFSET OF 1ST CHARACTER\n         LA       R15,HEXRECFD(R15) CALCULATE ADDRESS OF 1ST CHARACTER\n         BCTR     R1,R0             MAKE CHARACTER COUNT RELATIVE TO 0\n         EX       R1,MOVEHXBF       MOVE DISPLAY HEX TO RECEIVING FIELD\n         LA       R1,1(,R1)         RESTORE ACTUAL CHARACTER COUNT\n         SRL      R1,1              RESTORE ORIGINAL DATA BYTE COUNT\n         BR       R14               RETURN TO THE CALLER\nMVCTOWKF MVC      BDATAEXF(*-*),0(R3) MOVE BINARY DATA TO WORK FIELD\nCVTBIZHX UNPK     HEXCVTFD,BDATAEXF(*-*) CONVERTS BINARY TO ZONED HEX\nMOVEHXBF MVC      0(*-*,R2),0(R15)  MOVE CHARACTER DATA TO BUFFER\nMLSERRTN DS       0H\n*   ERROR HANDLING ROUTINE .........................................  *\n*   SEND MESSAGE TO OPERATOR DESCRIBING THE PROBLEM ENCOUNTERED.      *\n*   REG14 - POINTS AT A HALFWORD CONTAINING MESSAGE ID                *\n         ST       R14,ERROR14       SAVE RETURN ADDRESS\n         MVI      HDRMTYPE,HDRTYPED INDICATE AN IMMEDIATE MESSAGE\n         LH       R2,0(,R14)        PICK UP MESSAGE ID TO ISSUE\n         DSIMBS   MID=(R2),         MESSAGE BUFFER SERVICES            *\n               BFR=BUFRSVAD,        GET MSG TO ISSUE FROM              *\n               MSGTBL=MSGTABAD,     DSIMDS MSGTABLE                    *\n               SWB=CWBSWB\n         LTR      R15,R15           WAS MESSAGE BUILT SUCCESSFULLY?\n         BNZ      MLSABEND          NO - ISSUE DEBUGGING ABEND\n         DSIPSS   TYPE=IMMED,       PRESENTATION SERVICES              *\n               BFR=BUFRSVAD,        SEND MSG                           *\n               SWB=CWBSWB\n         LTR      R15,R15           MESSAGE WRITTEN OK ?\n         BNZ      MLSABEND          NO - ISSUE DEBUGGING ABEND\n         MVI      HDRMTYPE,HDRTYPEU RESTORE USER MESSAGE INDICATOR\n         L        R14,ERROR14       RETRIEVE RETURN ADDRESS\n         B        2(,R14)           RETURN TO ADDRESS AFTER MID CODE\nEDIT_TID DS       0H\n*   THIS ROUTINE RECEIVES CONTROL WHEN A MESSAGE HAS BEEN BUILT       *\n*   USING DSIMBS.  BECAUSE THE PREFIXED MESSAGE ID IS NOT WANTED,     *\n*   THE BUFFER HEADER IS ADJUSTED TO CAUSE THE MESSAGE ID TO BE       *\n*   IGNORED WHEN DSIPSS IS USED LATER.                                *\n         LA       R1,MSGTEXT        GET ADDRESS OF START OF TEXT\n         USING    MSGTEXT,R1        ADDRESSING THE TEXT IN THE BUFFER\nMLSL#017 DS       0H\n         CLI      MSGTEXT,BLANK     FIRST BLANK AFTER MESSAGE ID?\n         LA       R1,1(,R1)         BUMP TO NEXT CHARACTER OF TEXT\n         BNE      MLSL#017          NO - GO TEST NEXT CHARACTER\n         SR       R1,BUFREG         CALCULATE DISPLACEMENT OF NON-BLANK\n         DROP     R1\n         LH       R0,HDRTDISP       SAVE OLD TEXT DISPLACEMENT\n         STH      R1,HDRTDISP       SET NEW DISPLACEMENT IN HEADER\n         SR       R1,R0             CALCULATE CHANGE IN DISPLACEMENT\n         LCR      R1,R1             MAKE IT -VE\n         AH       R1,HDRMLENG       AND USE IT TO REDUCE\n         STH      R1,HDRMLENG       THE MESSAGE LENGTH\n         BR       R14               RETURN TO CALLER\nOC4RUTIN DS       0H\n*   OC4 HANDLING ROUTINE.                                             *\n*   THIS ROUTINE WILL DETERMINE IF OC4 WAS CAUSED WITHIN THIS MODULE. *\n*   IF YES, THE BC MODE PSW IS MODIFIED SO THAT CONTROL WILL BE       *\n*   REDIRECTED TO THE ERROR MESSAGE ROUTINE.                          *\n*   OTHERWISE, PRODUCE A DEBUGGING DUMP.                              *\n         USING    EPIE,R1           ADDRESSING THE RECEIVED PIE\n         LA       R0,OC4RUTIN-MEMLIST GET OFFSET TO THIS EXIT ROUTINE\n         LA       R15,0(,R15)       REMOVE HIGH ORDER BIT\n         SR       R15,R0            COMPUTE ADDRESS OF MODULE\n         CR       R15,MLSREG        IS BASE FOR MODULE SET UP?\n         BE       MLSL#018          YES - WITHIN MODULE, ISSUE ERROR\n         DC       Y(0)              CAUSE OC1 ABEND\nMLSL#018 DS       0H\n         LA       R2,OC4HNDLR       GET A(OC4 HANDLER)\n         BSM      R2,R0             SET ADDRESSING MODE BIT\n         ST       R2,EPIEPSW+4      MAKE IT NSI AFTER RETURN FROM EXIT\n         BR       R14               RETURN TO INTERRUPT HANDLER\n         DROP     R1\nOC4HNDLR DS       0H                OC4 HANDLER\n         BAS      R14,MLSERRTN      ISSUE MESSAGE TO SCREEN\n         DC       Y(STGEXOC4)       ABOUT OC4\n         B        DISPYEND          TERMINATING\n*   CHECK TIB TYPE FOR THE CONTROL BLOCK ENTERED.                     *\nOSTTYX02 DS       0H\n         USING    DSICBH,TIBREG     ADDRESSABILITY FOR DSICBH\n         CLI      CBHTYPE,X'02'     CHECK IF OST-TIB EXTENSION ?\n         BER      R14               YES - RETURN\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE ABOUT\n         DC       Y(MISCTLBK)       UNABLE TO FIND CONTROL BLOCK\n         B        MLSRETRN          TERMINATING\nPPTTYX00 DS       0H\n         CLI      CBHTYPE,X'00'     CHECK IF PPT-TIB EXTENSION ?\n         BER      R14               YES - RETURN AND CONTINUE.\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE ABOUT\n         DC       Y(MISCTLBK)       UNABLE TO FIND CONTROL BLOCK\n         B        MLSRETRN          TERMINATING\n*   AFTER TRANSLATION, CHECK FOR DEC/HEX DIGITS.                      *\n*        REG 7  - POINTS TO AREA CONTAINING TRANSLATED INPUT          *\nCKSYNTAX DS       0H\n         LA       R1,8              SET COUNTER FOR MAXIMUM LENGTH\nCKSLOOP1 DS       0H\n         CLI      0(R7),X'40'       IS IT C' ' (END OF DATA) ?\n         BE       CKSPACK           YES - GO PACK THE DATA\n         CLI      0(R7),X'00'       NO - IS IT INVALID DATA ?\n         BNE      MLSL#019          NO - GO CHECK LENGTH DATA\n         BAS      R14,MLSERRTN      YES, ISSUE ERROR MESSAGE ABOUT\n         DC       Y(BADHXDEC)       INVALID NUMERIC DATA\n         B        MLSRETRN          TERMINATING\nMLSL#019 DS       0H\n         LA       R6,1(R6)          NO - ADD 1 TO COUNT\n         LA       R7,1(R7)          ADDRESS OF NEXT BYTE.\n         BCT      R1,CKSLOOP1       GO CHECK NEXT BYTE\nCKSPACK  DS       0H\n         LTR      R6,R6             COUNT OF VALID CHAR = 0 ?\n         BNZ      MLSL#020          NO - START PROCESSING DATA\n         BAS      R14,MLSERRTN      .... ISSUE ERROR MESSAGE ABOUT\n         DC       Y(BADKEYWD)       EXCESSIVE DATA LENGTH\n         B        MLSRETRN          TERMINATING\nMLSL#020 DS       0H\n         SR       R7,R6             NO. POINT TO START OF OUTPUT AREA.\n         BCTR     R6,0              REDUCE COUNT OF VALID CHAR BY ONE.\n         EX       R6,PACKEX         GO PACK THE DATA.\n         LM       R6,R7,PACKAREA    RLI\n         SRDL     R6,4              GET RID OF LOW ORDER 4 BITS ON R7\n         LR       R6,R7             RLI\n         BR       R14               RETURN BACK.\nPACKEX   PACK     PACKAREA,0(0,R7)  PACK THE DATA.\nPDBENTLN DC       A(PDBENTND-PDBENTRY) LENGTH OF A PDB TABLE ENTRY\nCB_LIST  DS       0F                LIST OF CTL BLK NAME AND BR ADDRESS\n         DC       CL4'ACB '\n         DC       A(CB_ACB)\n         DC       CL4'ART '\n         DC       A(CB_ART)\n         DC       CL4'CDNI'\n         DC       A(CB_CDNIB)\n         DC       CL4'DDT '\n         DC       A(CB_DDT)\n         DC       CL4'DQT '\n         DC       A(CB_DQT)\n         DC       CL4'EXSW'\n         DC       A(CB_EXSWB)\n         DC       CL4'ICCW'\n         DC       A(CB_ICCWB)\n         DC       CL4'ICPD'\n         DC       A(CB_ICPDB)\n         DC       CL4'MRCW'\n         DC       A(CB_MRCWB)\n         DC       CL4'MRPD'\n         DC       A(CB_MRPDB)\n         DC       CL4'MVT '\n         DC       A(CB_MVT)\n         DC       CL4'NAT '\n         DC       A(CB_NAT)\n         DC       CL4'NCCW'\n         DC       A(CB_NCCWB)\n         DC       CL4'NCPD'\n         DC       A(CB_NCPDB)\n         DC       CL4'NPSW'\n         DC       A(CB_NPSWB)\n         DC       CL4'OIT '\n         DC       A(CB_OIT)\n         DC       CL4'ORRP'\n         DC       A(CB_ORRPL)\n         DC       CL4'OSNI'\n         DC       A(CB_OSNIB)\n         DC       CL4'OSRP'\n         DC       A(CB_OSRPL)\n         DC       CL4'RARP'\n         DC       A(CB_RARPL)\n         DC       CL4'RCRP'\n         DC       A(CB_RCRPL)\n         DC       CL4'RSRP'\n         DC       A(CB_RSRPL)\n         DC       CL4'SAT '\n         DC       A(CB_SAT)\n         DC       CL4'SCRP'\n         DC       A(CB_SCRPL)\n         DC       CL4'SCT '\n         DC       A(CB_SCT)\n         DC       CL4'SNT '\n         DC       A(CB_SNT)\n         DC       CL4'SVL '\n         DC       A(CB_SVL)\n         DC       CL4'TIB '\n         DC       A(CB_TIB)\n         DC       CL4'TVB '\n         DC       A(CB_TVB)\n         DC       CL4'PRCR'\n         DC       A(CB_PRRPL)\n         DC       CL4'PSCR'\n         DC       A(CB_PSRPL)\n         DC       CL4'HELP'\n         DC       A(MLSHELP)\n         DC       XL4'00000000'     END OF TABLE.\nKEYWDFM1 DC       C'BLLETEOP  '     KEYWORDS FORMAT #1; BL LE TE OP\nKEYWDFM2 DC       C'ADLEVERE  '     KEYWORDS FORMAT #2; AD LE VE RE\nMAXSEQLN DC       F'16'             MAXIMUM LENGTH OF STORAGE SEGMENT\nMAXUNTLN DC       F'4'              MAXIMUM LENGTH OF STORAGE UNIT\nMSGUNITX DS       0H\n         DC       Y(MSGUNIT1-MSGTEXT) OFFSET TO FIRST HEXADECIMAL UNIT\n         DC       Y(MSGUNIT2-MSGTEXT) OFFSET TO SECOND HEXADECIMAL UNIT\n         DC       Y(MSGUNIT3-MSGTEXT) OFFSET TO THIRD HEXADECIMAL UNIT\n         DC       Y(MSGUNIT4-MSGTEXT) OFFSET TO FOURTH HEXADECIMAL UNIT\nXLAT_TB1 DC       256X'00'          TABLE TO VALIDATE HEXADECIMAL DATA\n         ORG      XLAT_TB1+C' '\n         DC       C' '\n         ORG      XLAT_TB1+C'A'-C' '\n         DC       X'FAFBFCFDFEFF'\n         ORG      XLAT_TB1+C'A'\n         DC       X'FAFBFCFDFEFF'\n         ORG      XLAT_TB1+C'0'\n         DC       X'F0F1F2F3F4F5F6F7F8F9'\n         ORG      ,\nXLAT_TB2 DC       256X'00'          TABLE TO VALIDATE DECIMAL DATA\n         ORG      XLAT_TB2+C' '\n         DC       C' '\n         ORG      XLAT_TB2+C'0'\n         DC       X'F0F1F2F3F4F5F6F7F8F9'\n         ORG      ,\nXLAT_TB3 DC       256C'.'           TRANSLATE NONDISPLAYABLE CHARACTERS\n         ORG      XLAT_TB3+C' '\n         DC       1AL1(*-XLAT_TB3)  <SPACE>\n         ORG      XLAT_TB3+C'\u00dd'\n         DC       7AL1(*-XLAT_TB3)  \u00dd.<(+\u00a8&\n         ORG      XLAT_TB3+C'!'\n         DC       8AL1(*-XLAT_TB3)  !$*);\u00ac-/\n         ORG      XLAT_TB3+C'|'\n         DC       6AL1(*-XLAT_TB3)  |,%_>?\n         ORG      XLAT_TB3+C'`'\n         DC       7AL1(*-XLAT_TB3)  `:#@'=\"\n         ORG      XLAT_TB3+C'A'-C' '\n         DC       9AL1(*-XLAT_TB3)  ABCDEFGHI (LOWER CASE)\n         ORG      XLAT_TB3+C'J'-C' '\n         DC       9AL1(*-XLAT_TB3)  JKLMNOPQR (LOWER CASE)\n         ORG      XLAT_TB3+C'~'\n         DC       1AL1(*-XLAT_TB3)  ~\n         ORG      XLAT_TB3+C'S'-C' '\n         DC       8AL1(*-XLAT_TB3)  STUVWXYZ (LOWER CASE)\n         ORG      XLAT_TB3+C'{'\n         DC       1AL1(*-XLAT_TB3)  {\n         ORG      XLAT_TB3+C'A'\n         DC       9AL1(*-XLAT_TB3)  ABCDEFGHI (UPPER CASE)\n         ORG      XLAT_TB3+C'}'\n         DC       1AL1(*-XLAT_TB3)  }\n         ORG      XLAT_TB3+C'J'\n         DC       9AL1(*-XLAT_TB3)  JKLMNOPQR (UPPER CASE)\n         ORG      XLAT_TB3+C'\\'\n         DC       1AL1(*-XLAT_TB3)  \\\n         ORG      XLAT_TB3+C'S'\n         DC       8AL1(*-XLAT_TB3)  STUVWXYZ (UPPER CASE)\n         ORG      XLAT_TB3+C'0'\n         DC       10AL1(*-XLAT_TB3)\n         ORG      ,\n*        THIS TABLE IS USED TO TRANSLATE ZONED HEXADECIMAL TO         *\n*        EBCDIC INTERPRETED HEXADECIMAL (DISPLAY) FORMAT              *\nXLAT_TB4 EQU      *-C'0'\n         DC       C'0123456789ABCDEF' SUBSTITUTE WITH EBCDIC CHARACTERS\nMSGTABAD DC       A(MSGTABLE)       FULL ADDRESS OF MESSAGE TABLE\nHELPRC12 DC       H'12'             DSIMBS RETURN CODE => \"END OF HELP\"\nSHIFT24  EQU      24                LOW TO HIGH ORDER BYTE SHIFT COUNT\nBLANK    EQU      C' '              CHARACTER USED TO CLEAR BUFFER\nCHARDLIM EQU      C'+'              INTERPRETED TEXT DELIMITER\nZERO     EQU      0                 RETURN CODE TO CLEAR COMMAND AREA\nBADSYNTX EQU      030               INVALID SYNTAX\nBADCTLBK EQU      031               INVALID CONTROL BLOCKS\nBADHXDEC EQU      032               INVALID HEX/DEC DATA\nBADKEYWD EQU      033               INVALID KEYWORD/KW VALUE LENGTH\nBADLUID  EQU      034               INVALID TERM-ID\nBADOPID  EQU      035               INVALID OPER-ID\nMISCTLBK EQU      036               CONTROL BLOCK UNAVAILABLE\nBADTIB   EQU      037               NO ACTIVE TIB\nUNDKEYWD EQU      038               KEYWORDS UNDEFINED\nBADSCOPE EQU      039               PARMS NOT WITHIN OST SCOPE\nSTGEXOC4 EQU      040               OC4\nHDRLINE  EQU      041               STORAGE DISPLAY HEADER LINE\nENDLINE  EQU      042               STORAGE DISPLAY TRAILER LINE\nBADCBADR EQU      043               DISPLAY CTL BLOCK ADDRESS IS 0\nBADVRFLD EQU      044               VERIFY/REPLACE LENGTH \u00ac= 8\nBADVERFY EQU      045               INVALID VERIFY\nREPLCEOK EQU      046               VERIFY/REPLACE DONE\nRESETOK  EQU      047               \"DISPLAY TERMINATED BY RESET\"\nMSGTABLE AMODE    31\nMSGTABLE RMODE    ANY\nMSGTABLE DSIMDS   MLS,TYPE=START    MESSAGE TABLE CONTROL SECTION\n         DSIMDS   000,'MLS message &&1 not found in MESSAGE TABLE',    *\n               TYPE=E\n         DSIMDS        001,'For the display of NetView control blocks, *\n               enter:',TYPE=E\n         DSIMDS        002,'MLST Block=<controlblockname>(,Length=<leng*\n               th>)',TYPE=E\n         DSIMDS        003,'     (,{Terminal=<resource>\u00a8Operator=<taski*\n               d>})    ....OR',TYPE=E\n         DSIMDS        004,'MLST Address=<address>(,Length=<length>)', *\n               ,TYPE=E\n         DSIMDS        005,'<length> = {X<hex>\u00a8dec\u00a8*} \"*\" is the implic*\n               it length of CTL block',TYPE=E\n         DSIMDS        006,'if no Length specified, default is 1K for C*\n               TL block; 4 for Address',TYPE=E\n         DSIMDS        007,'For OST,PPT,NNT,and OPT, <controlblockname>*\n                can be:',TYPE=E\n         DSIMDS     008,'     ART DDT DQT MVT OIT SCT SNT SVL (1 COPY P*\n               ER NETVIEW)',TYPE=E\n         DSIMDS     009,'     ACB EXSWB ICCWB ICPDB MRCWB MRPDB NCCWB N*\n               CPDB NPSWB TIB TVB',TYPE=E\n         DSIMDS     010,'     (1 copy per task; differentiated by Termi*\n               nal or Operator ID)',TYPE=E\n         DSIMDS     011,'Also, for OST only, extra <controlblockname> c*\n               an be:',TYPE=E\n         DSIMDS     012,'     CDNIB ORRPL OSNIB OSRPL RARPL RCRPL SCRPL*\n                NAT SAT',TYPE=E\n         DSIMDS     013,'Also, for PPT only, extra <controlblockname> c*\n               an be:',TYPE=E\n         DSIMDS     014,'     PRCRPL PSCRPL',TYPE=E\n         DSIMDS     015,'e.g. MLST B=MVT,L=X32',TYPE=E\n         DSIMDS     016,'     MLST B=TVB,L=32,Oper=JOHNDOE',TYPE=E\n         DSIMDS     017,'               ',TYPE=E\n         DSIMDS     018,'For modifying 4-byte memory within the NetView*\n                address space, enter:',TYPE=E\n         DSIMDS     019,'MLST Address=<address>,Verify=<4-BYTE HEX>,Rep*\n               lace=<4-byte hex>',TYPE=E\n         DSIMDS     020,'e.g. MLST A=8A23468,V=12345678,R=87654321  con*\n               tents of A(8A23468) will',TYPE=E\n         DSIMDS     021,'be verified against X\"12345678\" before being r*\n               eplaced by X\"87654321\"',TYPE=E\n         DSIMDS        030,'INVALID COMMAND SYNTAX, ENTER \"MLST BLOCK=H*\n               ELP\" FOR ASSISTANCE',TYPE=E\n         DSIMDS        031,'INVALID CONTROL BLOCK, ENTER \"MLST B=HELP\" *\n               FOR ALL NAMES',TYPE=E\n         DSIMDS      032,'INVALID DECIMAL/HEXADECIMAL DATA',TYPE=E\n         DSIMDS      033,'INVALID KEYWORD/KEYWORD VALUE LENGTH',TYPE=E\n         DSIMDS      034,'INVALID TERMINAL-ID(RESOURCE) VALUE',TYPE=E\n         DSIMDS      035,'INVALID OPERATOR-ID(TASKID) VALUE',TYPE=E\n         DSIMDS     036,'REQUESTED NETVIEW CONTROL BLOCK NOT AVAILABLE *\n               FOR THIS TASK',TYPE=E\n         DSIMDS      037,'NO ACTIVE TIB FOR TERMINAL/OPERATOR',TYPE=E\n         DSIMDS       038,'KEYWORDS:BLOCK LENGTH TERMINAL OPERATOR ADDR*\n               ESS VERIFY REPLACE',TYPE=E\n         DSIMDS        039,'KEYWORD PARAMETER IS NOT IN YOUR SCOPE',TYP*\n               E=E\n         DSIMDS        040,'STORAGE PROTECTION EXCEPTION WHILE PROCESSI*\n               NG REQUEST',TYPE=E\n         DSIMDS        041,'--ADDR-- OFST ------------HEXADECIMAL------*\n               ------  ---CHARACTERS---',TYPE=I\n         DSIMDS        042,'---------------------- END OF STORAGE DISPL*\n               AY ----------------------',TYPE=I\n         DSIMDS        043,'POINTER TO THE REQUESTED CONTROL BLOCK = 0'*\n               ,TYPE=I\n         DSIMDS        044,'VERIFY/REPLACE LENGTH \u00ac= 8',TYPE=E\n         DSIMDS        045,'VERIFY FAIL',TYPE=E\n         DSIMDS        046,'REPLACE DONE',TYPE=E\n         DSIMDS        047,'STORAGE DISPLAY TERMINATED BY ATTN KEY OR R*\n               ESET',TYPE=I\n         DSIMDS   TYPE=END\n         IHAEPIE  ,                 GENERATE DEFINITION OF EPIE\nMEMLIST  CSECT                      RESUME CSECT DEFINITION\nMEMLIST  CSECT                      (RESUME INTERRUPTED DSECT)\n         DSICBS   DEFER=INCLUDE,                                       *\n               EJECT=NO,                                               *\n               PRINT=NO\nBUFHDR   DSECT    ,                 AUGMENT DEFINITION OF BUFFER HEADER\n         ORG      HDRTEXT           REDEFINE TEXT AREA IN A BUFFER\nMSGTEXT  DS       0CL(MSGMXTXL)     TEXT OF MESSAGE\nMSGRECAD DS       CL(2*L'ADRFIELD)  VIRTUAL ADDRESS OF STORAGE\n         DS       C\nMSGRELAD DS       CL(2*L'ADROFSET)  RELATIVE ADDRESS OF STORAGE\n         DS       C\nMSGUNIT1 DS       CL8               FIRST HEX UNIT DISPLAY AREA\n         DS       C\nMSGUNIT2 DS       CL8               SECOND HEX UNIT DISPLAY AREA\n         DS       C\nMSGUNIT3 DS       CL8               THIRD HEX UNIT DISPLAY AREA\n         DS       C\nMSGUNIT4 DS       CL8               FOURTH HEX UNIT DISPLAY AREA\n         DS       C\nMSGCHAD1 DS       C                 FIRST CHARACTER DELIMITER\nMSGCHAIT DS       CL16              CHARACTER INTERPRETATION OF DATA\nMSGCHAD2 DS       C                 SECOND CHARACTER DELIMITER\nMSGTXTLN EQU      *-MSGTEXT         CALCULATE LENGTH OF DISPLAY TEXT\nDSICWB   DSECT                      CONTINUE DEFINING CWB.\n         ORG      CWBADATD          REDEFINE DATA AREA IN CWB.\nSPIEPTOK DS       A                 TOKEN OF PREVIOUSLY ACTIVE ESPIE\nSPIELISF ESPIE    SET,MF=L          RESERVE STORAGE FOR ESPIE LIST-FORM\n         DS       0F\nOUTAREA  DS       0CL32             OUTPUT AREA FOR OPERANDS.\n         DS       CL8               AREA FOR 1ST KEYWD CB/ADDR VALUE.\n         DS       CL8               AREA FOR 2ND KEYWD (LENGTH) VALUE.\n         DS       CL8               AREA FOR 3RD KEYWD (LUNAME) VALUE.\n         DS       CL8               AREA FOR 4TH KEYWD (OPID) VALUE.\nTVBSAVAD DS       A                 SAVE AREA FOR LOCATE TVB ADDRESS.\nPDBPOSEN DS       F                 POSITION OF PDB ENTRY FOR PAS CALL\nKEYWDTXT DS       CL8               TEXT OF KEYWORD PARAMETER\nERROR14  DS       A                 ERROR ROUTINE RETURN ADDRESS\nADRFIELD DS       A                 STORAGE ADDRESS DISPLAYED/REPLACED\nVERFIELD DS       F                 VERIFY FIELD\nREPFIELD DS       F                 REPLACE FIELD\nLENFIELD DS       H                 LENGTH OF STORAGE TO BE DISPLAYED\nADROFSET DS       H                 OFFSET OF STORAGE BEING DISPLAYED\nDSEGOFFT DS       H                 OFFSET OF START OF STORAGE SEGMENT\nDSEGLEN  DS       H                 LENGTH OF STORAGE SEGMENT\nDBYTEOFF DS       H                 OFFSET OF BYTES TO BE DISPLAYED\nDBYTECTR DS       H                 DISPLAY BYTE DOWN COUNTER\nFMT2SW   DS       C                 FORMAT 2 SWITCH\nVERIFYSW DS       C                 VERIFY SWITCH\nPACKAREA DS       0D                DOUBLE WORK AREA TO PACK/UNPACK.\n         DS       CL8\nBDATAEXF DS       BL4               BINARY DATA EXTRACTION FIELD\nHEXCVTFD DS       CL9               HEXADECIMAL CONVERSION WORK FIELDS\nHEXCVTFE DS       0X                END OF CONVERSION WORK FIELDS\n         ORG      HEXCVTFD          REDEFINE WORK FIELD\nZONHEXRF DS       CL8               ZONED HEXADECIMAL RECEIVING FIELD\n         ORG      ZONHEXRF          REDEFINE ZONED HEX FIELD\nHEXRECFD DS       CL8               DISPLAY HEXADECIMAL RECEIVING FIELD\n         ORG      HEXCVTFE          RESTORE LOCATION COUNTER\nBUFRSVAD DS       A                 ADDRESS OF BUFFER\nBUFRSTOR DS       0D                START OF BUFFER STORAGE\nMSGMXBFL EQU      L'CWBADATD-(*-CWBADATD) MAXIMUM MESSAGE BUFFER LENGTH\nMSGMXTXL EQU      MSGMXBFL-(HDRTEXT-BUFHDR) MAXIMUM MESSAGE TEXT LENGTH\n         END\n\n\nRichard Li\nSNA Systems Programmer (Canada)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N006A04": {"ttr": 7685, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00%\\x00%\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 37, "newlines": 37, "modlines": 0, "user": "SNAUPDT"}, "text": "LANs and SNA networks - a recent survey\n\nSNA's inability to transport LAN protocols has forced many\nusers to run separate networks to connect remote LANs. This\npoint was one of several findings by Xephon's IBEX research\nproject, a continuous series of surveys of over 1000 IBM and\nPCM mainframe installations all over the world.\n\nVirtually all the mainframe sites surveyed had one or more\nLANs. A third of all LANs were connected to other LANs at\nthe same location, while about one in five were connected\nremotely to LANs at other locations.\n\nJust over 60% of all the sites surveyed had an SNA WAN, with\nlarger sites up to twice as likely to have one as smaller sites.\nThe LAN architecture made virtually no difference (although\none would have imagined that sites opting for an SNA WAN\nwould also tend to opt for IBM's Token Ring).\n\nUsers were asked whether they used different networks for\nSNA and LAN interconnection. Of those who reported remote\nLAN interconnection, 39% used separate networks and 61%\nused a single network. LAN interconnection across an SNA\nnetwork is not straightforward, as the recent phenomenal\ndemand for multi-protocol routers testifies, so we were a little\nsurprised to find quite so many organizations apparently\nmanaging with a single SNA WAN.\n\nOf those with separate networks, 33% blamed the inability to\ntransport LAN protocols across SNA, 18% the lack of ports on\n37xxs, and 15% the lack of bandwidth on the SNA network. A\nvariety of other reasons were also given for having separate\nnetworks, including cost, greater vendor choice, the need for\nalternative paths, security, and historical accident.\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N006A05": {"ttr": 7687, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x01\"\\x01\"\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 290, "newlines": 290, "modlines": 0, "user": "SNAUPDT"}, "text": "SNA NJE performance\n\n\nINTRODUCTION\n\nNetwork Job Entry (NJE) provides a mechanism for systems to\ntransfer jobs and job output between each other. Jobs can be\nsubmitted on one system, transmitted to another system for\nexecution, and any resulting output transmitted back to the\noriginal system.\n\nNJE uses SNA to establish sessions between application\nLogical Units supported by job entry/spooling or file transfer\nsoftware (eg JES2, BDT, RSCS, POWER, etc) on different\nsystems connected by an SNA network.\n\nFor many companies, NJE represents a fairly secure method of\nallowing access to a system without any complex security\nprocedures. However, one of the drawbacks of NJE is that all\ntoo often it either fails to work and a job or output remains on\nspool, defying all attempts to transmit it, or, more frequently,\ntransmission is slow and appears to be at random intervals.\n\nJobs or output can appear to spend a long time on the queue\nbefore transmission occurs. Often an NJE network crosses\ncompany and corporate boundaries and so is at the mercy of\nunrelated support groups. Node names and connections must be\nagreed and maintained consistently across the NJE network.\n\n\nMONITORING NJE PERFORMANCE\n\nMonitoring the performance of NJE and diagnosing problems is\ndifficult for several reasons.\n\no      NJE draws on features and facilities supported by other key\ncomponents, primarily JES2 (also JES3 or POWER) and SNA.\n\no      NJE runs as a pseudo subtask of JES, activating separate\n      transmitters and receivers for jobs and job output\n      (SYSOUT). Therefore NJE activity is interleaved with\n      other JES activity.\n\no      Since NJE uses SNA for communication, performance is\n      dependent upon the response from the supporting\n      mainframe system and communications network.\n\nAlthough it is necessary to ensure that NJE runs effectively,\nproblems concerning NJE performance tend to be concerned\nnot so much with how to make NJE run as fast as possible but\nrather how to ensure that NJE activity does not cause problems\neither with the system on which it is active or the one(s) with\nwhich it is communicating.\n\nQuite often NJE itself can be responsible for, or at least a\ncontributor to, the performance problem it is experiencing. It is\ncertainly possible for one system running NJE to swamp\nanother system.\n\nLarge volumes of NJE data may cause VTAM buffer shortages\non the receiving system, which may also be spending an\nexcessive amount of JES processing time handling the NJE\ntraffic, to the detriment of other work.\n\nMost installations run JES at a high priority and therefore allow\nit to accrue almost unlimited service.\n\nUncontrolled NJE traffic could also stress the connecting\nnetwork either by monopolizing the SDLC link(s) or by\ndepleting NCP buffers and so causing NCP to enter slow-\ndown.\n\nAll of these problems have been observed, particularly when\none system is more powerful than another in terms of CPU\npower or front-end processor capacity, and so can swamp the\nless powerful partner system.\n\nA similar effect could be experienced if the receiving NJE\nsystem has a large active processing load and therefore only\nlimited available capacity - the NJE traffic may be the last\nstraw!\n\nCertain guidelines can be drawn to ensure that NJE runs\ncorrectly. In essence this means configuring NJE so that it\nbehaves in a manner that is optimal for all concerned. First,\nNJE must be correctly set up to interface to the\ncommunications network efficiently. In particular, attention\nshould be paid to network buffers and pacing.\n\n\nNJE BUFFERS\n\nBuffers maintained by JES for NJE operations (and all other TP\noperations) are determined by the BUFSIZE and BUFNUM\nvalues specified on the TPDEF initialization parameter. JES\nprefixes a 268-byte RPL to each TP buffer used for SNA and\nattempts to fit as many buffers as possible onto a page of\nstorage with the condition that a buffer cannot span a page\nboundary.\n\nThe value of BUFSIZE should therefore be chosen carefully to\navoid excessive virtual storage usage and fragmentation. For\noptimum storage usage one of the following values should be\nspecified for BUFSIZE:\n\no      3828 for 1 buffer per page\n\no      1780 for 2 buffers per page\n\no      1092 for 3 buffers per page\n\no      756 for 4 buffers per page.\n\nThe actual value chosen will depend upon the nature of the\nNJE data traffic. If NJE is being used primarily to route jobs to\nother systems, then only a small buffer is required: if the main\nload comprises large print volumes, then larger buffers would\nbe more efficient. Note that whatever size is chosen, it must be\nless than or equal to the buffer size specified in the IOBUF\ndefinition of the VTAM start-up parameters, ie:\n\n      IOBUF=(,bufsize,,,)\n\n\nPACING\n\nPacing is the mechanism employed in SNA to control the rate\nat which data is sent from one node to another. Two nodes in\nsession agree on a pacing value, which determines how many\npackets of data will flow before a response is raised confirming\nreceipt (for more details see the article, An introductory look at\npacing,  in SNA Update, Issue 2, 1991).\n\nIt is possible to deactivate the pacing mechanism by specifying\na pacing value of zero, and in many installations this is either\nspecified or defaulted for NJE. However, pacing should never\nbe zero for NJE at it can result in excessive VTAM buffer\nusage, flooded lines, and NCP slow-down problems mentioned\nearlier.\n\nTo satisfy SNA logic requirements, the system on which the\n$SN,A=node-name command is issued is deemed the Primary\nLogical Unit (PLU) and the responding system becomes the\nSecondary Logical Unit (SLU). NJE uses one-stage pacing in\nboth the receiving and transmitting directions, which means\nthat:\n\no      The primary sending pacing (PSNDPAC) value equals the\n      secondary receiving pacing (SRCVPAC) value.\n\no      The secondary sending pacing (SSNDPAC) value equals\n      the primary receiving pacing (PRCVPAC) value.\n\nPacing is activated for NJE by specifying a value for\nVPACING on the APPL definitions for the NJE nodes and\nsupplying SSNDPAC in a MODETAB definition at the SLU.\n\nFor example:\n\n          VBUILD TYPE=APPL\nnodename  APPL   AUTH=(PASS,ACQ),\n                 MODETAB=mode-table,\n                 DLOGMOD=log-mode,\n                 VPACING=nn\n\ndefines the NJE PLU application node to VTAM.\n\nThe associated MODETAB is along these lines:\n\nmode-table  MODETAB\n            MODEENT  LOGMODE=log-mode,\n                     PSNDPAC=X'nn',\n                     PRCVPAC=X'nn',\n                     SSNDPAC=X'nn'\n\nNote that the value chosen for nn must be the same for all\ndefinitions.\n\nAs a minimum, the pacing value should be the number of lines\nin the transmission group representing a communications link\nbetween the NJE systems, otherwise not all lines in the group\nwill be used. Beyond that, choose a value which reflects the\ntotal number of active NJE sessions such that the sum of all the\nsessions can be comfortably accommodated by VTAM and the\nintermediate NCPs.\n\nFor a large number of NJE connections, a pacing value of 3 or\n4 is suggested: for only a few connections, this value can be\nhigher.\n\nNJE determines the values for the pacing parameters during\nsession set-up by examining the bind image sent from the SLU\nto the PLU, the LOGMODE entry, and the APPL entry. If any\nconflict or inconsistencies are found then it is probable that\npacing values of zero will be assumed by NJE.\n\nWhether or not pacing is in effect for NJE can be determined\nvia the NetView Session Monitor session parameter's panel.\n\n\nINVESTIGATING POOR PERFORMANCE\n\nAssuming that NJE has been configured correctly and NJE\nperformance is not acceptable, several areas can be\ninvestigated.\n\nFirst, in a large NJE configuration it is possible that NJE data\nwill arrive at a much faster rate than output generated by batch\nprograms, so check whether the size and number of spool\nbuffers is adequate for the volume of NJE traffic.\n\nNext, check that the response times for the DASD containing\nthe spool and checkpoint datasets are acceptable. In normal\noperations a poor response time for the volume(s) containing\nthe spool datasets may be acceptable but this will slow down\nthe rate at which NJE data can be handled. Do not forget to\ncheck the duplex datasets if duplexing is active.\n\nFinally, check the relative dispatching priorities and\nperformance specifications of JES2 and VTAM. VTAM should\ntake a higher priority than JES2 to allow it to process requests\nas soon as they are queued.\n\nStorage and domain isolation via IPS parameters should be\nconsidered for VTAM to allow it to retain real storage when\nNJE activity becomes high. Whether the working set\nspecification (WPSS parameter) or paging limits (PPGRT\nparameter) are used will depend upon the storage constraints of\nyour system.\n\nNo sensible evaluation of performance can be undertaken\nwithout some form of measurement, but, as mentioned earlier,\nthis is difficult for NJE.\n\nTracing is one possibility. Start GTF specifying TRACE=USR\nto record user-generated GTRACE requests. Activate VTAM\nexternal tracing for the line(s) supporting the NJE link by\nissuing the following command:\n\n      F NET,TRACE,ID=line-name,TYPE=LINE,MODE=EXT\n\nGTF data must then be formatted and printed. The trace will\nhave recorded the data flow and protocol in effect. This can be\nexamined for problems relating to pacing or network\nperformance. Some caution should be exercised using tracing\nsince a large amount of data could be produced for a busy NJE\nnetwork.\n\nSome IBM publications suggest the use of SMF records to\nanalyse performance - such an approach is not recommended.\nIt is complex since it involves the collecting and merging of\nrecords from all nodes and the development of an analysis\nprogram or utility. Collection of records from other nodes may\nnot be possible if the nodes are at sites belonging to other\ncompanies. If collection is accomplished, the analysis only\nreveals the symptoms of the problem and gives little clue as to\nthe cause.\n\nSince there is little to do to implement NJE beyond the addition\nof a few parameters to the JES2 initialization parameters and\nthe VTAM customization described above, problems with NJE\nusually relate either to parameter errors or to communications.\nTo verify that communications are active perform the\nfollowing:\n\n1      Check all APPLication nodes are active\n2      Check the NCPs connecting the NJE nodes are active\n3      Check the line connecting the NJE nodes is active\n4      Issue the $SN,A=node-name command.\n\nNJE supports inter-node communication via the $M command.\nThis can be used to attempt to contact another NJE node to\nverify availability, for example:\n\n      $Mnode-number,'hello message'\n\nwhere node-number is the number assigned to the node in the\nJES2 initialization parameters. A response of 'NOT\nCONNECTED' to this command implies that there is a\nproblem with the CONNECT statements in the initialization\nparameters and these should be checked. A common practice is\nto define permanent connections between NJE nodes rather\nthan allowing NJE to dynamically set up connections. If one\nNJE node defines a permanent connection via a CONNECT\nstatement, all nodes must have a similar definition.\n\nBrian Alford\nSystems Consultant\nAranda (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N006A06": {"ttr": 7693, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00d\\x00d\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 100, "newlines": 100, "modlines": 0, "user": "SNAUPDT"}, "text": "Recent APPN announcements\n\nIBM has recently pushed APPN very much to the forefront of\nits enterprise networking strategy with a rash of product\nannouncements and official statements of direction, even going\nso far as describing APPN as an architecture in its own right\nrather than a mere extension to SNA. APPN made its debut in\nJune 1986 but, until now, has been confined mainly to the\nAS/400 and PS/2. Its appearance in the mainframe arena\nincreases its importance considerably and it cries out to be\ntaken seriously.\n\nIBM is pushing APPN as a powerful protocol that operates\nacross  both pure IBM and multi-vendor networks. APPN\noffers routing, networking, and directory mechanisms which\nmonitor and manage network resources. Its dynamic, peer-to-\npeer oriented nature allows it to greatly improve system and\napplication availability, reduce network outages, and increase\nend-user productivity.\n\n\nNEW VERSION OF ACF/VTAM\n\nProbably the most significant of IBM's recent networking\nannouncements was the list of enhancements planned for the\nMVS/ESA version of ACF/VTAM. Support is promised which\nwould allow VTAM nodes and VTAM/NCP composite nodes\nto be dynamic participants in an APPN network and provide\naccess to mainframe servers from applications distributed on\nother APPN environments as well as enabling use of the SNA\nbackbone as a transport between APPN nodes.\n\nThe new VTAM will include support for end node, network\nnode, and central directory server. There will also be support\nfor dependent  LUs in APPN and the integration of APPN and\nsubarea networks. All the APIs of the new VTAM would be\nupwardly compatible with those of Version 3.\n\n\nOPEN APPN\n\nIBM also proffers APPN as an 'open' protocol by licensing its\nAPPN network node specifications to vendors who want to\ninclude their routers in APPN networks. Novell Inc, 3Com\nCorporation, Network Equipment Technologies Inc, and\nSystems Strategies Inc are among the first to take up this offer.\nCisco Systems Inc is a notable absentee although IBM claims\nthat the two companies are in discussions. Openness is given a\nfurther boost with IBM's promises to support SNA, OSI,\nTCP/IP, NetBIOS, and IPX traffic transparently on networks\nby interposing yet another layer of software - the Common\nTransport Semantics Layer - between the network and the\napplication.\n\n\nOTHER APPN ANNOUNCEMENTS\n\nOther important APPN-related announcements made by IBM\ninclude:\n\no      A planned new version of NetView for MVS/ESA and\n      MVS/XA. New functions would include a dynamic\n      graphical display of APPN topology, remote and\n      automated operations for distributed APPN nodes, and the\n      centralized collection of APPC accounting information.\n\no      A new product, Network Services/DOS, which allows\n      DOS and Windows applications to access APPN resources\n      via LU6.2 without incurring the massive memory overhead\n      that currently applies.\n\no      A promise to provide improved APPN support for the\n      RS/6000 through AIX SNA Services/6000, a program that\n      runs with AIX 3.2.\n\no      IBM's intention to offer international APPN support on its\n      Information Network by increasing the managed\n      networking capabilities of its Network Services product.\n\no      IBM has announced its intention to extend the\ngeographical\n      scope of the 6611 multi-protocol router (currently only\n      destined for North America and Japan) to other countries,\n      but has not elaborated on the where or when.\n\n\nCONCLUSION\n\nIBM seems to have pulled together a set of program\nspecifications, statements of direction, and actual applications\nand presented them as a complete networking strategy. Exactly\nhow much hard code all this represents, remains a matter of\nspeculation but, in the absence of so few firm delivery dates, it\nis very unlikely to amount to much at this stage. Nevertheless,\nIBM is making a bold (or is it desperate) bid to maintain its\ndominant position in networking while at the same time bowing\nto customer pressure in its support for mixed and peer-to-peer\nnetworks.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N006A07": {"ttr": 7938, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x01\\x06\\x01\\x06\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 262, "newlines": 262, "modlines": 0, "user": "SNAUPDT"}, "text": "SNA-X25 gateway performance\n\n\nINTRODUCTION\n\nThe use of X25 as the standard protocol for backbone carrier\nnetworks is expanding rapidly. X25 is the recommendation for\nOpen Systems Interconnection (OSI) in the same way that SNA\nis the recommendation for Advanced Peer to Peer Networking\n(APPN), IBM's answer to OSI. Any IBM site that has\nambitions to become part of the global network community\nmust encounter X25 networks.\n\nHowever if there is considerable investment in SNA and\ncontinued commitment to its use then somehow an IBM site\nmust be able to connect its own internal SNA network to the\nexternal X25 networks. For most IBM sites there is still only\none simple answer, the NCP Packet Switching Interface\n(NPSI).\n\nNPSI runs under ACF/NCP on the 37x5 communications\ncontrollers and supports a gateway between SNA and X25. On\nthe SNA side of the gateway, terminals are supported using\nstandard PU and LU protocol while on the X25 side of the\ngateway, packet switching Virtual Circuits and terminals are\nsupported. NPSI performs the required protocol conversion\nbetween the two - more or less.\n\nPrivate Virtual Circuit (PVC) support is reasonably stable but\nthere are still some problems with Switched Virtual Circuits\n(SVCs) relating to difficulties with call set-up and lost calls.\nThese problems are indicative of the incompatibilities between\nSNA and X25 in the areas of session establishment and error\nnotification.\n\nAt the remote cluster on the other side of the X25 network\nthere are two gateways which are a combination of hardware\nand software. A network adapter for the 3174 terminal\ncontroller is available to connect directly to the X25 network.\nThis requires appropriate configuration support software in the\n3174. Alternatively a stand-alone device, the Network Interface\nAdapter, can connect between the X25 network port which can\ntherefore remain unchanged.\n\nNPSI has been established long enough (ten years) as a product\nto have had all the bugs removed and the installation process is\nnow much simplified. However anyone who has had the\nmisfortune to install NPSI will know that trying to determine\nthe performance characteristics of the resultant network is like\nlooking for a needle in a haystack.\n\nOne thing is usually certain, the X25-linked terminal response\nis much poorer than the SNA equivalent. This article explores\nsome of the areas to consider and makes some\nrecommendations which should go some way to addressing this\nproblem.\n\n\nBUFFERS\n\nAs with most SNA network performance problems,\nperformance of the SNA-X25 gateway is greatly affected by\nthe various buffer sizes chosen. In order that sensible decisions\ncan be made regarding buffer sizes an understanding of the\nhow the message data is handled is useful.\n\nA message generated on the host and queued to VTAM\nundergoes two encapsulation processes.\n\nFirst the message (termed the Request Unit once in VTAM's\nhands) is converted to a Path Information Unit (PIU). An SNA\nPIU requires:\n\no      A 6-byte transmission header\n\no      A 3-byte request/response header\n\no      And possibly (optionally) a Function Management Header\n      (FMH), which could be between 4 and 20 bytes in length.\n\nThe PIU is transmitted across to the NCP running NPSI where\nit is then converted to X25 format by a second encapsulation\nwhich adds 3 header bytes (flag, control, and address bytes)\nand 3 trailer bytes (2 framecheck sequence bytes and a flag\nbyte).\n\nTherefore a minimum of 15 bytes is added to the original\nmessage data (RU) by the encapsulation; this figure would\nobviously be larger if an FMH is included. An FMH can be\nused to set both the response mode in effect and to indicate\nwhether or not chaining is allowed: use of both of these\nprotocol characteristics is discussed later.\n\nWith normal SNA flow, a PIU is transmitted without change\nbut, for the X25 flow, if the PIU exceeds the maximum packet\nsize specified then it must be split or segmented into several\npackets before transmission.\n\nThis would obviously result in a processing overhead and\ntherefore introduce a delay. It is therefore important to attempt\nto determine an optimum value for the X25 packet size and\nmatch this with the value of NCP MAXDATA so that there\nwill normally be a fit.\n\n\nX25 PACKET SIZES\n\nThe X25 packet size is not as flexible as SNA and must be one\nof four fixed values: 128, 256, 512, or 1024 bytes, which\nobviously limits choice.\n\nTypical SNA terminal activity generates data messages or\nRequest Units of the order of 200 bytes for a screen modify.  A\npacket size of 128 would mean that with encapsulation only\nabout 100 bytes of actual data would be contained in each\npacket and that each message will therefore result in more than\none X25 packet.\n\nA packet size of 1024 would mean that PIUs fit comfortably\ninto each packet. However space will be wasted and, if storage\nin the communications controller is constrained, performance\nwill be degraded.\n\nA simple rule to apply is: the more interactive the traffic, the\nsmaller the packet size to use. VTAM tracing can be activated\nto monitor the actual size of the messages being handled.\n\nA recommendation for a starting point is to chose a packet size\nof 256 and set MAXDATA to 250. This should be effective for\ninteractive traffic where the typical message size is less than\n200 bytes. Obviously 'typical message size' will depend on the\napplications generating the data.\n\n\nCHAINING\n\nRemember that the host application will think that it is talking\nto an SNA device (even if a somewhat dumb SNA device) and\nso may be chaining. Chaining is a method of segmenting a long\nmessage into several small messages. For example, if a real\nmessage is 1000 bytes in length then it may be segmented into\n4 actual messages of 256 bytes for transmission.\n\nFor applications generating data for transmission across the\nSNA-X25 gateway, it is recommended that the use of chaining\nis forced. Chaining increases the mainframe and mainframe to\ncommunication controller overhead for message handling but\nutilizes the X25 network more efficiently. This is because the\nX25 protocol allows several packets to be transmitted before an\nacknowledgement is required, therefore an acknowledgement\ncan be returned to the mainframe immediately. The mainframe\nwill then continue to process the remainder of the message\nstraight away.\n\nChaining can be forced by adjusting application buffer sizes\neither in the MODETAB definitions or the application terminal\ndefinitions (as in the case of the CICS and IMS terminal tables\nfor example). This is done very simply by making sure that the\nbuffer size is less than the average expected message length.\n\n\nPACING\n\nLarge data movements such as print streams or file transfers\nshould be isolated and pacing used to control the traffic flow.\nPacing values of 3 or 4 should be tried and the effect observed.\n\nThe effect of pacing can be gauged simply by observing the\nprinter, if it prints continuously then the pacing is correct, if\nthere are pauses then the pacing value is probably still too low\nand should be reviewed.\n\nIf possible use SCS for printing since the protocol overheads\nare much less than for any other type of print stream. This is\nbecause SCS works using exception response and does not\nrequire a definite response between each message. It is\nrecommended that, wherever possible, exception response is\nused in preference to definite response. It is, after all, the job\nof the X25 network to guarantee delivery of the data which\nshould make the requirement for definite response unnecessary.\n\nIf you are having problems with the reliability of the X25\nnetwork, don't try to handle it in the SNA-X25 interface,\ncontact the network supplier! Use of exception response rather\nthan definite response may require a change to VTAM\napplications accessed by terminals using the X25 route but it is\nworth the effort of the comparatively simple conversion.\n\n\nTHE NCP\n\nNPSI is a heavy user of the communications controller\nprocessor and storage. If normal SNA traffic must share the\ncontroller with the X25 traffic, it is recommended that use is\nmade of the ability of the 3745 to run two NCPs\nsimultaneously to separate the X25 and SNA traffic. Not only\ndoes this make performance monitoring simpler but it enables\ndifferent NCP buffer sizes to be selected for optimum X25\ntraffic.\n\n\nX25 PARAMETERS\n\nDetailed bit-by-bit recommendations relating to X25\nparameters have been avoided so far since manipulating these\nis usually time-consuming and quite often unproductive as they\nare dependent upon too many unknowns (for example, traffic\nlevels, message sizes, outboard packet network characteristics,\ncircuit quality, etc). Indeed parameter manipulation could\nactually be counter-productive.\n\nIf, however, reviewing and implementing the preceding\nrecommendations has not yielded any performance benefits\nthen a more in-depth study will be necessary and for this a\nmore intimate knowledge of the X25 network may be required.\nHaving gained this knowledge some guidelines can be applied.\n\nFor example, if the network is actually several interconnected\nX25 networks or the distances involved are large then the\nnetwork propagation delay may be significant and use of\nmodulo 128 should be considered.\n\nCircuit quality has been a major problem in the past though\nmuch has been and is being done to improve this. If the\nnetwork quality is poor and there is frequent error correction\nactivity in the form of re-transmissions or transmission time-\nouts then the retransmission value, N2, should be set to a high\nvalue, the re-transmission time-out value, T1, should be set\nhigh (at least 4-5 seconds) and the window size should be\nreduced say to 2 or 3. If the circuit quality is good then\nobviously the reverse applies, set N2 and T1 low and increase\nthe window size.\n\n\nCONCLUSION\n\nIn summary, the SNA-X25 gateway is very slow as it\nintroduces considerable overheads because of the effects of\nbuffering and protocol conversion, and the inability of the\nsoftware to utilize fully the X25 network capabilities. The\nincreasing power and capacity of the communications\ncontroller is slowly addressing the performance of the gateway\nbut in the meantime or pending an unlikely rewrite of the\ngateway the effect can be minimized by ensuring that the SNA\napplications accessed by X25-linked terminals are correctly\nconfigured and that the X25 network is of good quality.\n\nOne last caution: X25 networks consist of a series of store and\nforward nodes in which the packets are held before onward\ntransmission. The capacity of these nodes is obviously limited\nand it is possible that heavy use of the network will deplete the\nstorage capabilities of a node. Such a problem is likely to be\nindicated by a sudden, rather than gradual, drop in response\ntimes at high levels of usage. Determining if this is a problem\nmust be undertaken in partnership with the network supplier\n(which could be tricky) and will almost certainly result in\nhigher network costs for someone.\n\nBrian Alford\nSystems Consultant\nAranda (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N006A08": {"ttr": 7943, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00m\\x00m\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 109, "newlines": 109, "modlines": 0, "user": "SNAUPDT"}, "text": "Bypassing NetView's timer restrictions\n\n\nTHE PROBLEM\n\nWe have developed several REXX EXECs to perform\nmaintenance tasks (for example reorganizing the session\nmonitor database) that run under NetView 2.1. Ideally we\nwould like to run this type of EXEC overnight at regular\nintervals to perform routine maintenance.\n\nThe normal method of doing this is by using the AT, AFTER,\nand EVERY timer commands with the PPT and SAVE options.\n\nFor example, to issue a command weekly at 01.00 am on a\nspecific morning can be achieved by issuing the following\ntimer command some time during the previous day:\n\n      AT 01:00:00,PPT EVERY 0007 00:00:00,PPT,SAVE command\n\nUnfortunately, if the command procedure contains certain\nstatements (eg &WAIT in a CLIST or TRAP/WAIT in a\nREXX EXEC) it is unable to run under the primary program\noperator interface task (PPT). This was the case with our\nEXECs that use message trapping, so the following solution\nwas devised.\n\n\nTHE SOLUTION\n\nA REXX EXEC called INVOKE was created, whose function\nis solely to act as a vehicle for passing on the command to be\nexecuted for processing by the Message Automation Table\n(MAT). This EXEC could, in effect, do nothing, but in this\ncase it issues a message to the NETLOG.\n\nINVOKE REXX EXEC\n\n/************************************/\n/*                                  */\n/* INVOKE REXX exec                 */\n/*                                  */\n/************************************/\n/* Initialize error handling.       */\n/************************************/\nTrace E\n/************************************/\n/* Get input variable (COMMAND).    */\n/************************************/\nArg COMMAND\n/************************************/\n/* Issue message to NETLOG          */\n/************************************/\n'MSG LOG,COMMAND 'COMMAND' ISSUED'\nExit\n\nThus a command to be executed later would be entered as\nfollows:\n\n      AT 01:00:00,PPT EVERY 007 00:00:00,PPT,SAVE INVOKE \"command\"\n\nNote that double quotes are necessary around the command to\nbe issued.\n\nThe following entry was set up in the MAT:\n\n      IF MSGID = 'DSI208I' & TEXT = .'INVOKE \"'COMMAND'\"'. THEN\n         EXEC(CMD('ISSUE ' COMMAND) ROUTE(ONE AUTO1));\n\nThis will extract the command to be executed from the timer\nexpiration message (DSI208I) and pass it as an argument to a\nsecond REXX EXEC called ISSUE. This is necessary as the\nMAT will not allow a variable to be used as the command or\nEXEC to be executed. This EXEC (ISSUE) will be routed to\nthe AUTO1 task for execution.\n\nISSUE REXX EXEC\n\nA REXX EXEC called ISSUE, was created, whose function\nwas to issue the command passed to it as an argument by the\nMAT.\n\n/************************************/\n/*                                  */\n/* ISSUE REXX exec                  */\n/*                                  */\n/************************************/\n/* Initialize error handling.       */\n/************************************/\nTrace E\n/************************************/\n/* Get input variable (COMMAND).    */\n/************************************/\nArg COMMAND\n/************************************/\n/* Issue command.                   */\n/************************************/\nCOMMAND\nExit\n\nIn order that saved timers are made available after NetView has\nbeen closed and re-started, it is necessary to include the\nRESTORE TIMER command in the NetView initialization\nCLISTs (CNME1034 or CNME1035).\n\nJohn Cameron\nTechnical Specialist\nThe Life Association of Scotland (UK)       c Life Association of Scotland 1992\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N007A00I": {"ttr": 7946, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 13, "newlines": 13, "modlines": 0, "user": "SNAUPDT"}, "text": "N007 - SNA Update issue 7 September 1992\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nN007A01   LU6.2 mapped conversations using APPCCMD\nN007A02   Extending NetView commands\nN007A03   Displaying the Network Name Table\nN007A04   Printer test program\nN007A05   LAN to mainframe connectivity via APPN\nN007A06   NetView application development using VIEW\nN007A07   Session control in LU6.2\nN007A08   6611 delays create third-party opportunities\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N007A01": {"ttr": 7948, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x02\\x0e\\x02\\x0e\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 526, "newlines": 526, "modlines": 0, "user": "SNAUPDT"}, "text": "LU6.2 mapped conversations using APPCCMD\n\nThe following article expands on the article Miscellaneous\nLU6.2 functions, which appeared in the March 1992 issue of\nSNA Update.\n\nAPPCCMD in VTAM does not support mapped conversations\n(mapped conversation verbs are supported as pass-through\nfunctions according to VTAM Programming for LU6.2),\nalthough there are ways in which the VTAM programmer may\nimplement them. There can be some confusion over the\ndifference between option set 246 (data mapping) and option\nset 291 (mapped conversation LU services component).\n\nAppendix A in the Transaction Programmer's Reference for\nLU Type 6.2 describes these option sets. The mapped\nconversation LU services component option set (291) allows\nimplementation of a mapped conversation LU services\ncomponent program, which processes mapped conversation\nverbs. This option can be used on what the manual describes as\n'basic conversations' only (this wording is rather unfortunate: it\nwould be better to refer to the 'basic conversation protocol\nboundary' - see below) and relates to the TYPE parameter of\nthe ALLOCATE, DEALLOCATE, and SEND_ERROR verbs.\nData mapping option set (246) allows a program using mapped\nconversations to request mapping of the data by the local and\nremote LUs. This option set relates to the MAP_NAME\nparameter of the MC_SEND_DATA,\nMC_RECEIVE_AND_WAIT, MC_RECEIVE_ IMMEDIATE,\nand DEFINE_LOCAL_LU verbs and to the DATA_MAPPING\nparameter of the DEFINE_TP and DISPLAY_TP verbs.\n\nIf you want your VTAM program to support both basic and\nmapped conversations, you have to implement option set 291\nor at least accept and initiate mapped conversations and use the\nGDS format structure that flows on mapped conversations. If,\non mapped conversations, you want to implement something\nlike the Abstract Syntax Notation of the OSI Reference Model,\noption set 246 could be implemented to convey the name of the\ndata structure and encoding/decoding rules to be used.\n\nIn the LU6.2 architecture, there are two sets of verbs that\ncorrespond to two protocol boundaries: basic and mapped. The\nmapped conversation protocol boundary supports mapped\nconversations and the basic conversation protocol boundary\nsupports both basic and mapped conversations (with option\n291). When you allocate the conversation, the TYPE parameter\nof the ALLOCATE verb specifies either\nBASIC_CONVERSATION or MAPPED_CONVERSATION.\nThis is implemented in your VTAM program by coding MVI\nFM5RSCTP,FM5BASIC or MVI FM5RSCTP,FM5MAPED\ninto FMH5 before performing the APPCCMD\nCONTROL=ALLOC. If your VTAM program is the target\ntransaction program, you look at FM5RSCTP to see if the\nconversation is basic (X'D0') or mapped (X'D1').\n\nAt the basic conversation protocol boundary, the data is sent\nand received as logical records, ie:  ll,data, where ll is a two-\nbyte length field and data is anything and is transparent to the\nprotocol boundary. However, if you are implementing option\n291, for mapped conversations, all data transferred at the basic\nconversation protocol boundary should be represented as GDS\nvariables with SNA-defined formats. The Presentation Services\ncomponent PS.MC at the other end of the conversation requires\nthis so that it can support the remote Transaction Program (TP)\nat the mapped conversation protocol boundary and transform\nGDS variables into mapped conversation records and vice\nversa. If this is not done or you make an error, you will\ntypically get RCPRI=X'0044' (service error truncating). The\nremote mapped conversation LU services component (PS.MC)\nhas issued a SEND_ERROR TYPE(SVC). If you are\ncommunicating with a mapped CICS TP, PS.MC would be\nCICS.\n\nThe SNA LU6.2 Reference: Peer Protocols, SC31-6808 in\nChapter 7 about PS-mapped conversation verbs, explains how\nto construct these GDS variables. The following types of GDS\nvariables (with GDS-id) flow on mapped conversations:\napplication data (12FF), null data (12F1), user control data\n(12F2), error data (12F4), error log (12E1), and, if data\nmapping (option 246) is implemented, map name (12F3).\n\nThe easiest way to learn how to build and use these GDS\nvariables is to make some CICS prototype TPs, activate VTAM\ntracing, and study the traces.\n\nIt might be a good idea to use these GDS variables (implement\noption 291) even if you just intend to use basic conversations.\nYour programs should be more consistent and easier to trace\nand debug. Also, if it should be necessary to support mapped\nconversations, this could be done by just performing a MVI\nFM5RSCTP,FM5MAPED.\n\nCICS APPC, APPC/MVS, and CPI-C all support mapped and\nbasic conversations. However, you can not have a mapped\nconversation at the basic conversation protocol boundary as\nyou can with APPCCMD. A mapped conversation must be at\nthe mapped conversation protocol boundary and a basic\nconversation must be at the basic conversation protocol\nboundary.\n\nThe programs that follow, LU62RECV and LU62SEND, can\nhave a basic or mapped conversation against each other. The\nprograms are for an existing mapped front-end CICS TP to\nback-end CA-IDMS/DC TP conversations so that LU62SEND\ncan have a conversation against the CA-IDMS/DC TP and\nLU62RECV can have a conversation against the CICS TP.\n\nThe LOGMODE table and APPL definitions are also included.\nPARSESS=YES is specified; however, the programs are not\nmade to support parallel sessions.\n\n\nLOGMODE TABLE\n\nMSLU62T  MODETAB\nLU62EVIT MODEENT LOGMODE=LU62EVIT,                                    X\n               COS=MEDIUM,                                            X\n               FMPROF=X'13',                                          X\n               TSPROF=X'07',                                          X\n               PRIPROT=X'B0',                                         X\n               SECPROT=X'B0',                                         X\n               COMPROT=X'50B1',                                       X\n               RUSIZES=X'8787',                                       X\n               ENCR=B'0000',                                          X\n               PSERVIC='060200000000000000102F00'                     X\n         MODEEND\n         END\n\n\nAPPL DEFINITIONS\n\nMA1EVIT  VBUILD TYPE=APPL\nLU62SEND APPL ACBNAME=LU62SEND,APPC=YES,MODETAB=MSLU62T,              X\n              DLOGMOD=LU62EVIT,EAS=2,DSESLIM=2,DMINWNL=1,DMINWNR=1,   X\n              PARSESS=YES\nLU62RECV APPL ACBNAME=LU62RECV,APPC=YES,MODETAB=MSLU62T,              X\n              DLOGMOD=LU62EVIT,EAS=2,DSESLIM=2,DMINWNL=1,DMINWNR=1,   X\n              PARSESS=YES\n\n\nLU62RECV SOURCE CODE\n\n***********************************************************************\n*  THIS IS A QUICK (AND DIRTY) AND INCOMPLETE (NO ERRROR HANDLING)    *\n*  PROTOTYPE VTAM APPC PROGRAM TO DO SOME LU6.2 TESTING               *\n*  IT HAS ALSO BEEN USED AS A BACKEND PROGRAM TO A FRONTEND MAPPED    *\n*  CICS TRANSACTION PROGRAM.                                          *\n***********************************************************************\nLU62RECV AMODE 31\nLU62RECV RMODE 24\nLU62RECV CSECT\n         SAVE  (14,12)\n         LR    R2,R15\n         USING LU62RECV,R2\n         LR    R11,R13\n         LA    R13,SAVE\n         ST    R11,SAVE+4\n         ST    R13,SAVE+8\n         LA    R4,RPL1\n         USING IFGRPL,R4\n         LA    R5,RPLX\n         USING ISTRPL6X,R5\n         OPEN  (SNAP,(OUTPUT))\n         OPEN  ACB1\n         LTR   R8,R15\n         BZ    OPENOK\n         SHOWCB AM=VTAM,ACB=ACB1,FIELDS=ERROR,AREA=OPNERR,LENGTH=4\n         L     R9,OPNERR           OPEN ERROR CODE\n         DC    F'1'                ABEND\nOPENOK   DS    0H\n         SETLOGON RPL=RPL1,ACB=ACB1,OPTCD=START\n         LTR   R8,R15\n         BZ    SETLOK\n         ICM   R9,15,RPLRTNCD\n         L     R10,RPLSSEI\n         DC    F'2'\nSETLOK   DS    0H\n         INQUIRE RPL=RPL1,ACB=ACB1,NIB=NIB1,OPTCD=APPSTAT\n         CLI   RPLFDB3,0           PARTNER READY TO ESTABLISH SESSION?\n         BE    INQOK\n         WTO   'PARTNER NOT READY',ROUTCDE=11\n         STIMER WAIT,BINTVL=SEC20  WAIT A BIT AND INQUIRE AGAIN\n         B     SETLOK\nINQOK    DS    0H\n         CLI   CNOS,0              ATTN EXIT DRIVEN FOR CNOS?\n         BE    CNOSDO              THEN DO NOT DO AN APPCCMD CNOS\n         MVI   CNOS,0              CLEAR FLAG\n         LM    R8,R9,SLCNS         CNOS SESSION LIMITS DATA STRUCTURE\n         SNAP  DCB=SNAP,PDATA=REGS,ID=1   LET US LOOK AT IT\n         B     CNOSOK\nCNOSDO   DS    0H    NEGOTIATE SESSION LIMITS, USE VALUES FROM APPL\n         APPCCMD CONTROL=OPRCNTL,                                      *\n               QUALIFY=CNOS,                                           *\n               RPL=RPL1,                                               *\n               ACB=ACB1,                                               *\n               AAREA=RPLX,                                             *\n               LOGMODE=LU62EVIT,                                       *\n               LUNAME=LU62SEND\n         LTR   R8,R15\n         BZ    CNOSOK\n         ICM   R9,15,RPLRTNCD\n         L     R10,RPL6RC\n         L     R11,RPL6RCV1\n         L     R12,RPL6SNSI\n         DC    F'3'\nCNOSOK   DS    0H\n         SNAP  DCB=SNAP,STORAGE=(RPL1,END1),PDATA=REGS,ID=2\nNEXT     WAIT  ECB=ECB1             WAIT FOR POST FROM ATTN OR TPEND\n         MVC   WECB1,ECB1           SAVE ECB\n         XC    ECB1,ECB1            CLEAR ECBL\n         CLI   WECB1+3,2            TPEND EXIT?\n         BE    CLOSEDO\n         APPCCMD CONTROL=RCVFMH5,                                      *\n               RPL=RPL1,                                               *\n               ACB=ACB1,                                               *\n               AREA=ATTNFMH5,                                          *\n               AAREA=RPLX,                                             *\n               AREALEN=255,                                            *\n               OPTCD=SYN\n         LTR   R8,R15\n         BZ    FMH5OK\n         ICM   R9,15,RPLRTNCD\n         L     R10,RPL6RC\n         L     R11,RPL6RCV1\n         L     R12,RPL6SNSI\n         DC    F'4'\nFMH5OK   DS    0H\n         MVC   CONVID1,RPL6CNVD\n         SNAP  DCB=SNAP,STORAGE=(RPL1,END1),PDATA=REGS,ID=3\n         APPCCMD CONTROL=RECEIVE,                                      *\n               QUALIFY=SPEC,                                           *\n               RPL=RPL1,                                               *\n               ACB=ACB1,                                               *\n               CONVID=CONVID1,                                         *\n               AREA=AREA1,                                             *\n               AAREA=RPLX,                                             *\n               AREALEN=L'AREA1,                                        *\n               FILL=LL,                                                *\n               OPTCD=SYN\n         LTR   R8,R15\n         BZ    RECVOK\n         ICM   R9,15,RPLRTNCD\n         L     R10,RPL6RC\n         L     R11,RPL6RCV1\n         L     R12,RPL6SNSI\n         DC    F'5'\nRECVOK   DS    0H\n         SNAP  DCB=SNAP,STORAGE=(RPL1,END1),PDATA=REGS,ID=4\n         APPCCMD CONTROL=DEALLOC,                                      *\n               QUALIFY=DATACON,                                        *\n               RPL=RPL1,                                               *\n               ACB=ACB1,                                               *\n               CONVID=CONVID1,                                         *\n               AREA=AREA2,                                             *\n               AAREA=RPLX,                                             *\n               RECLEN=AREA2LN,                                         *\n               OPTCD=SYN\n         LTR   R8,R15\n         BZ    DEALOK\n         ICM   R9,15,RPLRTNCD\n         L     R10,RPL6RC\n         L     R11,RPL6RCV1\n         L     R12,RPL6SNSI\n         DC    F'6'\nDEALOK   DS    0H\n         SNAP  DCB=SNAP,STORAGE=(RPL1,END1),PDATA=REGS,ID=6\n         B     NEXT\nCLOSEDO  DS    0H\n         CLOSE ACB1\n         CLOSE SNAP\n         L     R13,4(,R13)\n         RETURN (14,12),RC=0\nOPNERR   DC    F'0'\nECB1     DC    F'0'\nWECB1    DC    F'0'\nSEC20    DC    F'2000'\nCONVID1  DC    F'0'\nSAVE     DS    18F\n         LTORG\n         DS    0D\nACB1     ACB   AM=VTAM,MACRF=LOGON,APPLID=LU62NAME,EXLST=ATEXLST\nATEXLST  EXLST AM=VTAM,ATTN=ATTN1,TPEND=TPEND\nNIB1     NIB   MODE=RECORD,NAME=LU62SEND\nLU62NAME DC    AL1(8),C'LU62RECV'\n         DS    0D\nRPL1     RPL   AM=VTAM\nRPLX     ISTRPL6\n         DC    C'FMH5'\nATTNFMH5 DC    XL255'00'\n         DC    C'RECV'\nAREA1    DC    XL255'FF'\nEND1     DC    C'SEND'\nAREA2    DC    Y(AREA2LN),X'12FF'       LLID   (GDS VARIABLE)\n         DC    C'DATA FROM LU62RECV'\nAREA2LN  EQU   *-AREA2\nSNAP     DCB   DDNAME=SNAP,DSORG=PS,MACRF=(W),LRECL=125,BLKSIZE=1632,  *\n               RECFM=VBA\nTPEND    DS    0H\n         LR    R2,R15\n         USING TPEND,R2\n         LR    R3,R14\n         L     R4,=A(ECB1)\n         POST  (R4),2             POST MAINLINE\n         LR    R14,R3\n         BR    R14\n         LTORG\nATTN1    DS    0H\n         LR    R2,R15\n         USING ATTN1,R2\n         L     R7,AATTNID            ADDR TRACE TABLE\n         MVC   0(4,R7),12(R1)        SAVE NAME OF EVENT IN TRACE TABLE\n         LA    R7,4(,R7)             NEXT ENTRY IN TRACE TABLE\n         ST    R7,AATTNID            STORE ADDR OF NEXT ENTRY\n         CLC   =C'FMH5',12(R1)       FMH5 RECEIVED?\n         BE    FMH5DO\n         CLC   =C'LOSS',12(R1)       SESSION LOST?\n         BE    LOSSDO\n         CLC   =C'CNOS',12(R1)       CNOS RECEIVED?\n         BNER  R14\n         L     R4,16(,R1)            READ-ONLY RPL\n         L     R6,RPLAREA            POINTER TO SES.LIMIT.DATA.STRUCT.\n         MVC   SLCNS(7),0(R6)        ISTSLCNS\n         MVI   CNOS,255              FLAG FOR CNOS RECEIVED\n         BR    R14\nFMH5DO   LR    R3,R14\n         L     R4,=A(ECB1)\n         POST  (R4),0                POST MAINLINE, FMH5 PENDING\n         LR    R14,R3\n         BR    R14\nLOSSDO   BR    R14                   SESSION(S) LOST (APPL ATTNLOSS=)\nCNOS     DC    X'00'\nSLCNS    DC    D'0'\nAATTNID  DC    A(ATTNID)\nATTNID   DC    CL64' '\n         LTORG\n         IFGACB AM=VTAM\n         IFGRPL AM=VTAM\n         YREGS\n         END\n\n\nLU62SEND SOURCE CODE\n\n***********************************************************************\n*  THIS IS A QUICK (AND DIRTY) AND INCOMPLETE (NO ERRROR HANDLING)    *\n*  PROTOTYPE VTAM APPC PROGRAM TO DO SOME LU6.2 TESTING               *\n*  IT HAS ALSO BEEN USED AS A FRONTEND PROGRAM TO A BACKEND MAPPED    *\n*  IDMS-DC TRANSACTION PROGRAM.                                       *\n***********************************************************************\nLU62SEND AMODE 31\nLU62SEND RMODE 24\nLU62SEND CSECT\n         SAVE  (14,12)\n         LR    R2,R15\n         USING LU62SEND,R2\n         LR    R11,R13\n         LA    R13,SAVE\n         ST    R11,SAVE+4\n         ST    R13,SAVE+8\n         LA    R4,RPL1\n         USING IFGRPL,R4\n         LA    R5,RPLX\n         USING ISTRPL6X,R5\n         OPEN  (SNAP,(OUTPUT))\n         OPEN  ACB1\n         LTR   R8,R15\n         BZ    OPENOK\n         SHOWCB AM=VTAM,ACB=ACB1,FIELDS=ERROR,AREA=OPNERR,LENGTH=4\n         L     R9,OPNERR           OPEN ERROR CODE\n         DC    F'1'                ABEND\nOPENOK   DS    0H\n         SETLOGON RPL=RPL1,ACB=ACB1,OPTCD=START\n         LTR   R8,R15\n         BZ    SETLOK\n         ICM   R9,15,RPLRTNCD\n         L     R10,RPLSSEI\n         DC    F'2'\nSETLOK   DS    0H\n         INQUIRE RPL=RPL1,ACB=ACB1,NIB=NIB1,OPTCD=APPSTAT\n         CLI   RPLFDB3,0     PARTNER READY TO ESTABLISH SESSION?\n         BE    INQOK\n         WTO   'PARTNER NOT READY',ROUTCDE=11\n         STIMER WAIT,BINTVL=SEC20  WAIT A BIT AND INQUIRE AGAIN\n         B     SETLOK\nINQOK    DS    0H\n         CLI   CNOS,0              ATTN EXIT DRIVEN FOR CNOS?\n         BE    CNOSDO              THEN DO NOT DO AN APPCCMD CNOS\n         MVI   CNOS,0              CLEAR FLAG\n         LM    R8,R9,SLCNS         CNOS SESSION LIMITS DATA STRUCTURE\n         SNAP  DCB=SNAP,PDATA=REGS,ID=1   LET US LOOK AT IT\n         B     CNOSOK\nCNOSDO   DS    0H    NEGOTIATE SESSION LIMITS, USE VALUES FROM APPL\n         APPCCMD CONTROL=OPRCNTL,                                      *\n               QUALIFY=CNOS,                                           *\n               RPL=RPL1,                                               *\n               ACB=ACB1,                                               *\n               AAREA=RPLX,                                             *\n               LOGMODE=LU62EVIT,                                       *\n               LUNAME=LU62RECV\n         LTR   R8,R15\n         BZ    CNOSOK\n         ICM   R9,15,RPLRTNCD\n         L     R10,RPL6RC\n         L     R11,RPL6RCV1\n         L     R12,RPL6SNSI\n         DC    F'3'\nCNOSOK   DS    0H\n         SNAP  DCB=SNAP,STORAGE=(RPL1,END1),PDATA=REGS,ID=2\n         APPCCMD CONTROL=ALLOC,                                        *\n               QUALIFY=ALLOCD,                                         *\n               LUNAME=LU62RECV,                                        *\n               RPL=RPL1,                                               *\n               ACB=ACB1,                                               *\n               AAREA=RPLX,                                             *\n               LOGMODE=LU62EVIT,                                       *\n               AREA=FMH5,                                              *\n               RECLEN=LFMH5\n         LTR   R8,R15\n         BZ    FMH5OK\n         ICM   R9,15,RPLRTNCD\n         L     R10,RPL6RC\n         L     R11,RPL6RCV1\n         L     R12,RPL6SNSI\n         DC    F'4'\nFMH5OK   DS    0H\n         MVC   CONVID1,RPL6CNVD\n         SNAP  DCB=SNAP,STORAGE=(RPL1,END1),PDATA=REGS,ID=3\n         APPCCMD CONTROL=SEND,                                         *\n               QUALIFY=DATA,                                           *\n               RPL=RPL1,                                               *\n               ACB=ACB1,                                               *\n               CONVID=CONVID1,                                         *\n               AREA=AREA2,                                             *\n               AAREA=RPLX,                                             *\n               RECLEN=AREA2LN,                                         *\n               OPTCD=SYN\n         LTR   R8,R15\n         BZ    SENDOK\n         ICM   R9,15,RPLRTNCD\n         L     R10,RPL6RC\n         L     R11,RPL6RCV1\n         L     R12,RPL6SNSI\n         DC    F'5'\nSENDOK   DS    0H\n         SNAP  DCB=SNAP,STORAGE=(RPL1,END1),PDATA=REGS,ID=4\n         APPCCMD CONTROL=RECEIVE,                                      *\n               QUALIFY=SPEC,                                           *\n               RPL=RPL1,                                               *\n               ACB=ACB1,                                               *\n               CONVID=CONVID1,                                         *\n               AREA=AREA1,                                             *\n               AAREA=RPLX,                                             *\n               AREALEN=L'AREA1,                                        *\n               FILL=LL,                                                *\n               OPTCD=SYN\n         LTR   R8,R15\n         BZ    RECVOK\n         ICM   R9,15,RPLRTNCD\n         L     R10,RPL6RC\n         L     R11,RPL6RCV1\n         L     R12,RPL6SNSI\n         DC    F'6'\nRECVOK   DS    0H\n         SNAP  DCB=SNAP,STORAGE=(RPL1,END1),PDATA=REGS,ID=5\n         APPCCMD CONTROL=SEND,                                         *\n               QUALIFY=CONFRMD,                                        *\n               RPL=RPL1,                                               *\n               ACB=ACB1,                                               *\n               CONVID=CONVID1,                                         *\n               AAREA=RPLX,                                             *\n               OPTCD=SYN\n         LTR   R8,R15\n         BZ    CONFOK\n         ICM   R9,15,RPLRTNCD\n         L     R10,RPL6RC\n         L     R11,RPL6RCV1\n         L     R12,RPL6SNSI\n         DC    F'7'\nCONFOK   DS    0H\n         SNAP  DCB=SNAP,STORAGE=(RPL1,END1),PDATA=REGS,ID=6\nCLOSEDO  DS    0H\n         CLOSE ACB1\n         CLOSE SNAP\n         L     R13,4(,R13)\n         RETURN (14,12),RC=0\nCNOS     DC    X'00'\nSLCNS    DC    D'0'\nSEC20    DC    F'2000'\nOPNERR   DC    F'0'\nCONVID1  DC    F'0'\nSAVE     DS    18F\n         LTORG\n         DS    0D\nACB1     ACB   AM=VTAM,MACRF=LOGON,APPLID=LU62NAME\nNIB1     NIB   MODE=RECORD,NAME=LU62RECV\nLU62NAME DC    AL1(8),C'LU62SEND'\n         DS    0D\nRPL1     RPL   AM=VTAM\nRPLX     ISTRPL6\n         DC    C'FMH5'\nFMH5     DC    AL1(LFMH5)\n         DC    X'0502FF0003D10040'    MAPPED, SYNCLEVEL 1\n*                         IF YOU WANT BASIC, CODE D0 INSTEAD OF D1\n         DC    AL1(L'TPN)\nTPN      DC    CL8'TPNRECV'           TRANSACTION PROGRAM NAME\n         DC    XL3'00'\nLFMH5    EQU   *-FMH5\n         DC    C'RECV'\nAREA1    DC    XL255'FF'\nEND1     DC    C'SEND'\nAREA2    DC    Y(AREA2LN),X'12FF'     LLID  (GDS VARIABLE)\n         DC    C'DATA FROM LU62SEND'\nAREA2LN  EQU   *-AREA2\nSNAP     DCB   DDNAME=SNAP,DSORG=PS,MACRF=(W),LRECL=125,BLKSIZE=1632,  *\n               RECFM=VBA\n         IFGACB AM=VTAM\n         IFGRPL AM=VTAM\n         YREGS\n         END\n\n\nEdvin Vik\nSystems Engineer Specialist\nAmdahl (Norway)                                                  c Amdahl 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N007A02": {"ttr": 8199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00}\\x00}\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 125, "newlines": 125, "modlines": 0, "user": "SNAUPDT"}, "text": "Extending NetView commands\n\nHaving found the article VTAM extended display command in\nthe December 1991 issue useful, I have extended the idea to\nallow a wide range of NetView commands to be issued against\na group of terminals.\n\nUsage of the GROUP command is explained in the help panel\nbelow. It is not essential to enter the lower terminal address\nfirst. The terminal-ids specified to this command must be\nbetween 3 and 8 characters in length, the last 3 characters\nbeing a hexadecimal address. Different terminal-id structures\ncan be catered for by adjusting the HEXLEN variable.\nMessages that result from the command being issued against a\nnon-existent terminal are suppressed.\n\n\nGROUP REXX EXEC\n\n/**********************************************************************/\n/* GROUP      :- REXX EXEC issue commands to groups of terminals.     */\n/**********************************************************************/\n/* Initialize error handling.                                          /\n/**********************************************************************/\nTrace E\nHEXLEN = 3\n/**********************************************************************/\n/* Get input variables (P1 - low addr / P2 - high addr).              */\n/**********************************************************************/\nCOMMAND = MSGVAR(1)\nP1 = MSGVAR(2)\nP2 = MSGVAR(3)\n/**********************************************************************/\n/* Checks for valid input variables.                                  */\n/**********************************************************************/\nSelect\n   When COMMAND = '?' then SIGNAL HELP\n   When P1 = '' then SIGNAL HELP\n   When P2 = '' then SIGNAL HELP\n   When Length(P1) > 8 then\n      Do\n         Say \"Length of name 1 ('P1') > 8 chars. - GROUP terminating.'\n         Exit\n      End\n   When Length(P1) < 3 then\n      Do\n         Say 'Length of name 1 ('P1') < 3 chars. - GROUP terminating.'\n         Exit\n      End\n   When Length(P2) > 8 then\n      Do\n         Say 'Length of name 2 ('P2') > 8 chars. - GROUP terminating.'\n         Exit\n      End\n   When Length(P2) < 3 then\n      Do\n         Say 'Length of name 2 ('P2') < 3 chars. - GROUP terminating.'\n         Exit\n      End\n   Otherwise\n      Do\n         ADDR = Length(P1) - (HEXLEN - 1)\n         LOADD = Substr(P1,ADDR,HEXLEN)\n         If Datatype(LOADD,'X') = 0 then\n            Do\nSay 'Unable to get address from name 1 ('P1') - GROUP terminating.'\n               Exit\n            End\n         TERMID = Substr(P1,1,ADDR - 1)\n         If length(P2) = HEXLEN then\n            Do\n               HIADD = P2\n               If Datatype(HIADD,'X') = 0 then\n                  Do\nSay 'Unable to get address from name 2 ('P2') - GROUP terminating.'\n                     Exit\n                  End\n            End\n         Else\n            Do\n               HIADD = Substr(P2,ADDR,HEXLEN)\n               If Datatype(HIADD,'X') = 0 then\n                  Do\nSay 'Unable to get address from name 2 ('P2') - GROUP terminating.'\n                     Exit\n                  End\n               TERMID2 = Substr(P2,1,ADDR - 1)\n               If TERMID \u00ac= TERMID2 then\n                  Do\n Say 'Mismatch in names ('TERMID'/'TERMID2') - GROUP terminating.'\n                     Exit\n                  End\n            End\n/**********************************************************************/\n/* Issue command for each terminal address in the specified range     */\n/* and trap error messages for all terminals that do not exist.       */\n/**********************************************************************/\n         LOADD = X2D(LOADD)\n         HIADD = X2D(HIADD)\n         COUNT = HIADD - LOADD\n         If COUNT < 0 then\n            Do\n               TEMP = HIADD\n               HIADD = LOADD\n               LOADD = TEMP\n               COUNT = HIADD - LOADD\n            End\n         'TRAP AND SUPPRESS MESSAGES IST453I IST097I'\n         Do I = 0 to COUNT\n            ADDR = D2X(LOADD + I,HEXLEN)\n            COMMAND TERMID||ADDR\n         End\n         'TRAP NO MESSAGES'\n         'FLUSHQ'\n      End\nEnd\nExit\nHELP:\n   HELP GROUP\nExit\n\nJohn Cameron\nTechnical Specialist\nThe Life Association of Scotland (UK)     c Life Association of Scotland 1992\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N007A03": {"ttr": 8202, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x03>\\x03>\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:38", "lines": 830, "newlines": 830, "modlines": 0, "user": "SNAUPDT"}, "text": "Displaying the Network Name Table\n\n\nINTRODUCTION\n\nWhen my company converted from 3725s to 3745s last year,\nwe encountered an interesting problem with a new control\nblock introduced at the NCP Version 5 level, the Network\nName Table (NNT). The available IBM documentation was\nunclear on when we would require an entry in the NNT.\nDuring the conversion process, we encountered an SNA sense\ncode of 0812000E, signifying insufficient space in the NNT.\n\nThe size of the NNT is determined by the NAMTAB operand\nof the NCP BUILD macro. In order to determine exactly what\ntypes of entry need to be stored in the NNT, we wrote the\nCLIST listed below. The CLIST command should be entered\nfrom a NetView console in the following format:\n\n      NNT <ncpname>\n\nwhere <ncpname> is the name of the NCP whose NNT is to be\ninterrogated. The command was developed under NetView\nVersion 1.3 and NCP Version 5.3 and was written in the\nNetView CLIST language.\n\nWhen an SSCP name needs to be added to the NNT and\ninsufficient table space is available, the above failed sense is\nissued and no cross domain/network communications will be\npossible with that SSCP. We have found this CLIST to be very\nhelpful in avoiding such situations.\n\nNNT      CLIST\n&CONTROL ERR\n&IF &PARMCNT EQ 0 &THEN &GOTO -HELP\n&IF .&1 EQ .? &THEN &GOTO -HELP\n&GOTO -START\n-HELP\n&BEGWRITE -ENDHELP\n********************************************************************\n*    NETVIEW CLIST NNT:                                            *\n*    DESCRIPTION:                                                  *\n*THIS CLIST WILL LIST ALL THE ENTRIES IN THE NNT FOR A GIVEN NCP.  *\n*COMMAND:                                                          *\n* NNT    (NCPNAME)                                                 *\n*EXAMPLE:                                                          *\n* NNT     NCP21                                                    *\n**-----------------------------------------*                       *\n*|   NNT    |    NAME      |  NNT  | Usage |                       *\n*|  NAME    |    TYPE      | FLAGS | Count |                       *\n*|----------|--------------|-------|-------|                       *\n*| NETA     | NETWORK NAME |  0010 |   16  |                       *\n*| NETB     | NETWORK NAME |  0013 |   19  |                       *\n*| NETC     | NETWORK NAME |  0005 |    5  |                       *\n*| A01M     | SSCP/CP NAME |  4005 |    5  |                       *\n**----------|--------------|-------|-------*                       *\n*TOTAL #NNTS IN USE =                                              *\n*TOTAL #NNTS AVAILABLE =      NNTAVENT                             *\n*MINIMUM #NNTS AVAILABLE =    NNTMNAVE                             *\n*TOTAL #NNTS DEFINED =        NNTENTRS                             *\n*TOTAL #NETWORKS DEFINED =    NNTUSES0                             *\n**** END OF NETWORK NAME TABLE *                                   *\n*N N T   H E A D E R                                               *\n*            NNTUSES0 - THE NUMBER OF NETWORKS DEFINED IN THIS NCP.*\n*                       (THIS NUMBER INCLUDES THE NATIVE NETWORK.) *\n*            NNTENTRS - THE NUMBER OF NNT ENTRIES DEFINED.THIS IS  *\n*                       THE NAMTAB OPERAND OF THE NCP BUILD MACRO. *\n*            NNTAVENT - THE NUMBER OF AVAILABLE NNT ENTRIES.       *\n*            NNTMNAVE - THE MINIMUM NUMBER OF AVAILABLE NNT ENTRIES*\n*            NNTLIUSE - THE INDEX OF THE LAST IN-USE NNT ENTRY.    *\n*N N T   E N T R Y                                                 *\n*NNT NAME    NNTNAME  - THIS IS THE NETWORK NAME                   *\n*NAME TYPE   NNTNDATA - BYTE 0                                     *\n*                       XX.. .... WHERE                            *\n*                       00 = NETWORK IDENTIFIER                    *\n*                       01 = CONTROL POINT NAME                    *\n*USE COUNT   NNTNDATA   BYTE 1                                     *\n*                       NUMBER OF USES OF THIS NAME                *\n*    NOTE: FLAG VALUES ARE REPRESENTED IN HEX NOT DECIMAL.         *\n********************************************************************\n* HERE ARE THE EXPECTED MESSAGES FROM DISPLAY NCPSTOR:             *\n*IST097I (5A97I) NCPSTOR ACCEPTED                                  *\n*IST244I (5C44I) NCP STORAGE FOR ID = (NCP)                        *\n*IST245I (5C45I) 000260 00000000 00000000 00000000 00000000        *\n*IST314I (5D14I) END                                               *\n*IST241I (5C41I) NCPSTOR COMMAND COMPLETE FOR ID = (NCP)           *\n*            OR                                                    *\n*IST242I (5C42I) NCPSTOR COMMAND FAILED FOR ID =(NCP) SENSE = 0806 *\n*CONTROL BLOCKS                                                    *\n*  (06E8) ---> XDA                      WORD DIRECT ADDRESSABLE    *\n*  XDA + X'5C'(92) ---> HWX             HWE EXTENSION              *\n*  HWX + X'6C'(108) ---> NNT            NETWORK NAMES TABLE        *\n********************************************************************\n-ENDHELP\n&EXIT\n-START\n**********************************************************\n* THIS CODE CHECKS TO SEE IF VTAM IS UP\n**********************************************************\n&IF .&VTAM NE . &THEN &GOTO -GOODY\nMESSAGE 385I,NNT\n&EXIT\n-GOODY\n&NCP = &1\n-CHKDONE\n*           SET UP VARIABLE TO CONVERT HEX TO DEC\n&H1B0 = 0\n&H1B  = 0\n&H1B1 = 1\n&H1B2 = 2\n&H1B3 = 3\n&H1B4 = 4\n&H1B5 = 5\n&H1B6 = 6\n&H1B7 = 7\n&H1B8 = 8\n&H1B9 = 9\n&H1BA = 10\n&H1BB = 11\n&H1BC = 12\n&H1BD = 13\n&H1BE = 14\n&H1BF = 15\n&H2B0 = 0\n&H2B  = 0\n&H2B1 = 16\n&H2B2 = 32\n&H2B3 = 48\n&H2B4 = 64\n&H2B5 = 80\n&H2B6 = 96\n&H2B7 = 112\n&H2B8 = 128\n&H2B9 = 144\n&H2BA = 160\n&H2BB = 176\n&H2BC = 192\n&H2BD = 208\n&H2BE = 224\n&H2BF = 240\n&H3B  = 0\n&H3B0 = 0\n&H3B1 = 256\n&H3B2 = 512\n&H3B3 = 768\n&H3B4 = 1024\n&H3B5 = 1280\n&H3B6 = 1536\n&H3B7 = 1792\n&H3B8 = 2048\n&H3B9 = 2304\n&H3BA = 2560\n&H3BB = 2816\n&H3BC = 3072\n&H3BD = 3328\n&H3BE = 3584\n&H3BF = 3840\n&H4B  = 0\n&H4B0 = 0\n&H4B1 = 4096\n&H4B2 = 8192\n&H4B3 = 12288\n&H4B4 = 16384\n&H4B5 = 20480\n&H4B6 = 24576\n&H4B7 = 28672\n&H4B8 = 32768\n&H4B9 = 36864\n&H4BA = 40960\n&H4BB = 45056\n&H4BC = 49152\n&H4BD = 53248\n&H4BE = 57344\n&H4BF = 61440\n&H5B  = 0\n&H5B0 = 0\n&H5B1 = 65536\n&H5B2 = 131072\n&H5B3 = 196608\n&H5B4 = 262144\n&H5B5 = 327680\n&H5B6 = 393216\n&H5B7 = 458752\n&H5B8 = 524288\n&H5B9 = 589824\n&H5BA = 655360\n&H5BB = 720896\n&H5BC = 786432\n&H5BD = 851968\n&H5BE = 917504\n&H5BF = 983040\n&H6B  = 0\n&H6B0 = 0\n&H6B1 = 1048576\n&H6B2 = 2097152\n&H6B3 = 3145728\n&H6B4 = 4194304\n&H6B5 = 5242880\n&H6B6 = 6291456\n&H6B7 = 7340032\n&H6B8 = 8388608\n&H6B9 = 9437184\n&H6BA = 10485760\n&H6BB = 11534336\n&H6BC = 12582812\n&H6BD = 13631488\n&H6BE = 14680064\n&H6BF = 15728640\n*   TABLE TO CONVERT EBCDIC TO CHARACTERS\n&CC1 = A\n&CC2 = B\n&CC3 = C\n&CC4 = D\n&CC5 = E\n&CC6 = F\n&CC7 = G\n&CC8 = H\n&CC9 = I\n&CD1 = J\n&CD2 = K\n&CD3 = L\n&CD4 = M\n&CD5 = N\n&CD6 = O\n&CD7 = P\n&CD8 = Q\n&CD9 = R\n&CE2 = S\n&CE3 = T\n&CE4 = U\n&CE5 = V\n&CE6 = W\n&CE7 = X\n&CE8 = Y\n&CE9 = Z\n&C40 = ' '\n&C5B = '$'\n&C7C = '@'\n&C7B = '#'\n&CF0 = 0\n&CF1 = 1\n&CF2 = 2\n&CF3 = 3\n&CF4 = 4\n&CF5 = 5\n&CF6 = 6\n&CF7 = 7\n&CF8 = 8\n&CF9 = 9\n*         ASSIGN DECIMAL ARRAY\n&H0 = 0\n&H1 = 1\n&H2 = 2\n&H3 = 3\n&H4 = 4\n&H5 = 5\n&H6 = 6\n&H7 = 7\n&H8 = 8\n&H9 = 9\n&H10 = 10\n&H11 = 11\n&H12 = 12\n&H13 = 13\n&H14 = 14\n&H15 = 15\n&H16 = 16\n&H17 = 32\n&H18 = 48\n&H19 = 64\n&H20 = 80\n&H21 = 96\n&H22 = 112\n&H23 = 128\n&H24 = 144\n&H25 = 160\n&H26 = 176\n&H27 = 192\n&H28 = 208\n&H29 = 224\n&H30 = 240\n&H31 = 256\n&H32 = 512\n&H33 = 768\n&H34 = 1024\n&H35 = 1280\n&H36 = 1536\n&H37 = 1792\n&H38 = 2048\n&H39 = 2304\n&H40 = 2560\n&H41 = 2816\n&H42 = 3072\n&H43 = 3328\n&H44 = 3584\n&H45 = 3840\n&H46 = 4096\n&H47 = 8192\n&H48 = 12288\n&H49 = 16384\n&H50 = 20480\n&H51 = 24576\n&H52 = 28672\n&H53 = 32768\n&H54 = 36864\n&H55 = 40960\n&H56 = 45056\n&H57 = 49152\n&H58 = 53248\n&H59 = 57344\n&H60 = 61440\n&H61 = 65536\n&H62 = 131072\n&H63 = 196608\n&H64 = 262144\n&H65 = 327680\n&H66 = 393216\n&H67 = 458752\n&H68 = 524288\n&H69 = 589824\n&H70 = 655360\n&H71 = 720896\n&H72 = 786432\n&H73 = 851968\n&H74 = 917504\n&H75 = 983040\n&H76 = 1048576\n&H77 = 2097152\n&H78 = 3145728\n&H79 = 4194304\n&H80 = 5242880\n&H81 = 6291456\n&H82 = 7340032\n&H83 = 8388608\n&H84 = 9437184\n&H85 = 10485760\n&H86 = 11534336\n&H87 = 12582912\n&H88 = 13631488\n&H89 = 14680064\n&H90 = 15728640\n*         ASSIGN HEX ARRAY\n&HEX1 = 1\n&HEX2 = 2\n&HEX3 = 3\n&HEX4 = 4\n&HEX5 = 5\n&HEX6 = 6\n&HEX7 = 7\n&HEX8 = 8\n&HEX9 = 9\n&HEX10 = A\n&HEX11 = B\n&HEX12 = C\n&HEX13 = D\n&HEX14 = E\n&HEX15 = F\n&HEX16 = 10\n&HEX17 = 20\n&HEX18 = 30\n&HEX19 = 40\n&HEX20 = 50\n&HEX21 = 60\n&HEX22 = 70\n&HEX23 = 80\n&HEX24 = 90\n&HEX25 = A0\n&HEX26 = B0\n&HEX27 = C0\n&HEX28 = D0\n&HEX29 = E0\n&HEX30 = F0\n&HEX31 = 100\n&HEX32 = 200\n&HEX33 = 300\n&HEX34 = 400\n&HEX35 = 500\n&HEX36 = 600\n&HEX37 = 700\n&HEX38 = 800\n&HEX39 = 900\n&HEX40 = A00\n&HEX41 = B00\n&HEX42 = C00\n&HEX43 = D00\n&HEX44 = E00\n&HEX45 = F00\n&HEX46 = 1000\n&HEX47 = 2000\n&HEX48 = 3000\n&HEX49 = 4000\n&HEX50 = 5000\n&HEX51 = 6000\n&HEX52 = 7000\n&HEX53 = 8000\n&HEX54 = 9000\n&HEX55 = A000\n&HEX56 = B000\n&HEX57 = C000\n&HEX58 = D000\n&HEX59 = E000\n&HEX60 = F000\n&HEX61 = 10000\n&HEX62 = 20000\n&HEX63 = 30000\n&HEX64 = 40000\n&HEX65 = 50000\n&HEX66 = 60000\n&HEX67 = 70000\n&HEX68 = 80000\n&HEX69 = 90000\n&HEX70 = A0000\n&HEX71 = B0000\n&HEX72 = C0000\n&HEX73 = D0000\n&HEX74 = E0000\n&HEX75 = F0000\n&HEX76 = 100000\n&HEX77 = 200000\n&HEX78 = 300000\n&HEX79 = 400000\n&HEX80 = 500000\n&HEX81 = 600000\n&HEX82 = 700000\n&HEX83 = 800000\n&HEX84 = 900000\n&HEX85 = A00000\n&HEX86 = B00000\n&HEX87 = C00000\n&HEX88 = D00000\n&HEX89 = E00000\n&HEX90 = F00000\n*   END   ASSIGN HEX ARRAY\n*     INDEX BOUNDS ARRAY FOR STARTING POINT OF SCAN\n&C1   = 9\n&C2   = 22\n&C3   = 34\n&C4   = 48\n&C5   = 62\n&C6   = 76\n&C7   = 85\n&C8   = 90\n***********************************************************************\n* ROUTINE TO GET THE HWX ADDRESS\n*NCP 8.3(3725) L'6E4' POINTS TO THE XDA\n*              XDA+X'58'(88) POINTS TO THE HWE\n***********************************************************************\n&DISADDR = 6E0\n&DISLEN  = 12\n&DISVAR  = WD\n&DISRET  = LOWCOR\n&GOTO -DIS\n-LOWCOR\n&NNTLAST = 12\n&HWEA = 7D8\n&XDH = &SUBSTR &WD2 3 6\n*     TEST FOR PRE- 8.3 3725    L'6E0' = 00000000\n&IF &WD1 EQ 00000000 &THEN &GOTO -HAVHWE\n*     TEST FOR 3705            L'6E0' = 00C80000\n&IF &WD1 EQ 00C80000 &THEN &GOTO -HAVHWE\n*     THE ADDRESS OF THE XDA IS IN L'6E8'\n&XDA = &SUBSTR &WD3 3 6\n&NNTLAST = 12\n***********************************************************************\n&DISADDR = &XDA\n&DISLEN  = 96\n&DISVAR  = WD\n&DISRET  = ENDXDAA\n&GOTO -DIS\n************************************************************************\n*      THE ADDRESS OF THE HWX IS X'5C'(92) INTO THE XDA\n*      THIS WILL BE IN THE LAST WORD OF THE LAST DISPLAY\n***********************************************************************\n-ENDXDAA\n&HWE  = &SUBSTR &DISLAST 3 6\n&GOTO -STRHWE\n-HAVHWE\n***********************************************************************\n&DISADDR = &HWEA\n&DISLEN  = 4\n&DISVAR  = WD\n&DISRET  = AHWE\n&GOTO -DIS\n***********************************************************************\n-AHWE\n&HWE = &SUBSTR &DISLAST 3 6\n-STRHWE\n***********************************************************************\n&DISADDR = &HWE\n&DISLEN  = 112\n&DISVAR  = WD\n&DISRET  = HWENNTA\n&GOTO -DIS\n***********************************************************************\n*      THE ADDRESS OF THE NNT IS X'6C (108) INTO THE HWE\n*      THIS WILL BE IN THE LAST WORD OF THE LAST DISPLAY\n-HWENNTA\n&NNTA = &SUBSTR &DISLAST 3 6\n************************************************\n* IF NNT = 0 THEN THIS IS NOT A V4.3 OR V5 BOX\n************************************************\n&IF &NNTA NE 000000 &THEN &GOTO -UPLEVEL\n&BEGWRITE SUB -DNLEVEL\n*** NCP MUST BE VERSION 4.3(3725)/VERSION 5(3745) OR LATER TO RUN NNT\n*** END OF N.N.T. FOR &NCP\n-DNLEVEL\n&EXIT\n-UPLEVEL\n***********************************************************************\n* DISPLAY THE NNT HEADER                                              *\n***********************************************************************\n-HAVEPSB\n&DISADDR = &NNTA\n&DISLEN = 10\n&DISVAR = NNTHD\n&DISRET = ANNTHD\n&GOTO -DIS\n-ANNTHD\n&CVDPARM = &SUBSTR &NNTHD1 1 4\n&CVDRET = HDENT\n&GOTO -CVD\n-HDENT\n&NETS = &CVDNUM\n&CVDPARM = &SUBSTR &NNTHD1 5 4\n&CVDRET = HDENT1\n&GOTO -CVD\n-HDENT1\n&ENTS = &CVDNUM\n&CVDPARM = &SUBSTR &NNTHD2 1 4\n&CVDRET = HDSIZ\n&GOTO -CVD\n-HDSIZ\n&ANNTSZ = &CVDNUM\n&CVDPARM = &SUBSTR &NNTHD2 5 4\n&CVDRET = HDSIZ1\n&GOTO -CVD\n-HDSIZ1\n&MAENTS = &CVDNUM\n&CVDPARM = &SUBSTR &NNTHD3 1 4\n&CVDRET = HDSIZ2\n&GOTO -CVD\n-HDSIZ2\n&INUSEN = &CVDNUM\n&NUMNNT = &CVDNUM\n&NNTSIZ = 10\n&II = 0\n&XX = &NNTSIZ\n&YY = 4\n-DIVIDE\n&XX = &XX - &YY\n&II = &II + 1\n&IF &XX GT 0 &THEN &GOTO -DIVIDE\n&NNTLAST = &II\n&NNTLAST = &INUSEN\n&III = 1\n&OUTL&III = '*-----------------------------------------*'\n&III = 2\n&OUTL&III = '|   NNT    |     Name     |  NNT  | Usage |'\n&III = 3\n&OUTL&III = '|   NAME   |     Type     | Flags | Count |'\n&III = 4\n&OUTL&III = '|----------|--------------|-------|-------|'\n&NNTOFFS = 248\n&CVDPARM = &NNTA\n&CVDRET = NNTCVD\n&GOTO -CVD\n-NNTCVD\n&NNTDEC = &CVDNUM\n&NNTDEC = &NNTDEC + 10\n&DECIN = &NNTDEC\n&DECRET = FSTNNT\n&GOTO -DECHEX\n-FSTNNT\n&LCLNNTA = &HEXVAL\n-ANNTA\n&DISADDR = &LCLNNTA\n&DISLEN = &NNTSIZ\n&DISVAR = NNT\n&DISRET = ONENNT\n&GOTO -DIS\n***********************************************************\n* DECODE ONE FULL NNT CONTROL BLOCK AND PRINT IT OUT\n***********************************************************\n-ONENNT\n***********************************************************\n*   EXTRACT  NETWORK ID NAME\n***********************************************************\n&NWID =\n&NHEX = &CONCAT &NNT1 &NNT2\n&NHEX = &CONCAT &NHEX &NNT3\n&NTFLG = &SUBSTR &NHEX 1 4\n&NHEX = &SUBSTR &NHEX 5 16\n&NTTYP = 'NETWORK NAME'\n&IF &SUBSTR &NTFLG 1 1 GE 4 &THEN &NTTYP = 'SSCP/CP NAME'\n&CVDPARM = &SUBSTR &NTFLG 2 3\n&CVDRET = NNTUSE\n&GOTO -CVD\n-NNTUSE\n&NTUSE = &CVDPARM\n*WRITE  &NTFLG -- &NHEX $$$$ -- HEX &NTUSE\n&H = 15\n***** CONVERT EBCDIC TO CHARACTER *************************\n-CONV\n&CHAR = &SUBSTR &NHEX &H 2\n&CHAR = &CONCAT C &CHAR\n&NWID = &CONCAT &&CHAR &NWID\n&H = &H - 2\n&IF &H GT 0 &THEN &GOTO -CONV\n&LENNWID = &LENGTH &NWID\n&LENPAD = 8 - &LENNWID\n&PADNWID = &SUBSTR '        ' 1 &LENPAD\n&NWID = &CONCAT &NWID &PADNWID\n***********************************************************\n*   EXTRACT LOCAL NETWORK ID\n***********************************************************\n&III = &III + 1\n&OUTL&III = &CONCAT &OUTL&III '| '\n&OUTL&III = &CONCAT &OUTL&III &NWID\n&OUTL&III = &CONCAT &OUTL&III ' | '\n&OUTL&III = &CONCAT &OUTL&III &NTTYP\n&OUTL&III = &CONCAT &OUTL&III ' |  '\n&OUTL&III = &CONCAT &OUTL&III &NTFLG\n&OUTL&III = &CONCAT &OUTL&III ' |  '\n&OUTL&III = &CONCAT &OUTL&III &NTUSE\n&OUTL&III = &CONCAT &OUTL&III ' |'\n***********************************************************\n*   POINT TO NEXT NNT ENTRY AND REPEAT\n***********************************************************\n&INUSEN = &INUSEN - 1\n&IF &INUSEN LE 0 &THEN &GOTO -NNTDONE\n&NNTDEC = &NNTDEC + &NNTSIZ\n&DECIN = &NNTDEC\n&DECRET = NNTHEXR\n&GOTO -DECHEX\n-NNTHEXR\n&LCLNNTA = &HEXVAL\n&GOTO -ANNTA\n-NNTDONE\n&CVDPARM = &HEXVAL\n&CVDRET = TOTAL\n&GOTO -CVD\n-TOTAL\n&III = &III + 1\n&OUTL&III = '*-----------------------------------------*'\n&III = &III + 1\n&OUTL&III = &CONCAT 'TOTAL #NNTS IN USE                =   ' &NUMNNT\n&III = &III + 1\n&OUTL&III = &CONCAT 'TOTAL #NNTS AVAILABLE             =   ' &ANNTSZ\n&III = &III + 1\n&OUTL&III = &CONCAT 'MINIMUM #NNTS AVAILABLE           =   ' &MAENTS\n&III = &III + 1\n&OUTL&III = &CONCAT 'TOTAL #NNTS DEFINED               =   ' &ENTS\n&III = &III + 1\n&OUTL&III = &CONCAT 'TOTAL #NETWORKS DEFINED           =   ' &NETS\n&III = &III + 1\n&OUTL&III = '*** END OF NNT ***'\n&JJJ = 1\n-WRITEIT\n&WRITE &OUTL&JJJ\n&JJJ = &JJJ + 1\n&IF &JJJ LE &III &THEN &GOTO -WRITEIT\n&EXIT\n******************************************************************\n* SUBROUTINE TO CONVERT HEX TO DECIMAL AND THEN PAD WITH BLANKS  *\n*    INPUT:  CVDPARM 1 TO  6 NIBBLES IN HEX                      *\n*            CVDRET  LABEL OF RETURN                             *\n*                    AND BASE VARIABLE FOR OUTPUT                *\n*    OUTPUT: CVDPARM DECIMAL NUMBER RIGHT JUSTIFIED              *\n*                    OUTPUT LENGTH = LENGTH OF CVDPARM + 1       *\n*                    ALSO PUT IN CVDRET VARIABLE                 *\n*            CVDNUM  DECIMAL NUMBER NOT PADDED WITH BLANKS       *\n*                    IN CVDRET VARIABLE WITH N APPENDED          *\n******************************************************************\n-CVD\n&CVDLEN = &LENGTH &CVDPARM\n&OUTLEN = &CVDLEN + 1\n&POS = 1\n&CVDNUM = 0\n-CVDLOOP\n &IF &CVDLEN = 0 &THEN &GOTO -PADS\n &E = &SUBSTR &CVDPARM &POS 1\n &P = &CONCAT H&CVDLEN B\n &P = &CONCAT &P &E\n &CVDNUM = &CVDNUM + &&P\n &CVDLEN = &CVDLEN - 1\n &POS = &POS + 1\n &GOTO -CVDLOOP\n*     ENTRY POINT JUST TO PAD WITH BLANKS\n-PADS\n&ELEN = &LENGTH &CVDNUM\n&ELEN = &OUTLEN - &ELEN\n&PAD = &SUBSTR '        ' 1 &ELEN\n&CVDPARM = &CONCAT &PAD &CVDNUM\n&&CVDRET = &CVDPARM\n* APPEND A CHARACTER N TO END OF INPUT VARIABLE\n&VN = &CONCAT &CVDRET N\n&&VN = &CVDNUM\n&GOTO -&CVDRET\n********************** END OF CVD *************************************\n***********************************************************************\n*   D I S   S U B R O U T I N E                                       *\n* FUNCTION: DISPLAY NCP STORAGE WITH VTAM NCPSTOR COMMANDS            *\n* INPUT:                                                              *\n*   DISADDR = HEX ADDRESS TO BE DISPLAYED                             *\n*   NCP     = NCP TO BE DISPLAYED                                     *\n*   DISLEN  = LENGTH OF STORAGE DISPLAY                               *\n*   DISRET  = RETURN ADDRESS FROM DIS ROUTINE                         *\n*   DISVAR  = VARIABLE PREFIX FOR OUTPUT ARRAY                        *\n* OUTPUT:                                                             *\n*   DISLAST = VALUE OF LAST WORD OF STORAGE DISPLAY                   *\n*   DISVAR1.= ARRAY OF WORDS FROM 1 TO N WITH OUTPUT OF DISPLAY       *\n***********************************************************************\n-DIS\n&D = 0\n&WAIT CONTWAIT  SUPPRESS\n&WAIT 'D NET,NCPSTOR,ID=&NCP,LENGTH=&DISLEN,ADDR=&DISADDR' +\nIST097I=-NOPVER IST244I=-VER IST245I=-VER IST314I=-NOPVER +\n5A97I=-NOPVER   5C44I=-VER   5C45I=-VER   5D14I=-NOPVER +\nIST241I=-ENDVER  IST242I=-REJECT +\n5C41I=-ENDVER    5C42I=-REJECT +\n*ERROR=-ERROR *ENDWAIT=-STRVER  *60=-ERROR\n***********************************************************************\n* IST245I (5C45I) 000260 00000000 00000000 00000000 00000000\n***********************************************************************\n-VER\n&MSZI = 1\nGETMSIZE MSZ\n-NEWMSG\n&I = 2\nGETMLINE MSGTXT &MSZI\nPARSEL2R MSGTXT MSID XX1 XX2 XX3 XX4 XX5 DUMMY\n&IF &MSID EQ 5C45I   &THEN &GOTO -FOUNDMSG\n&IF &MSID NE IST245I &THEN &GOTO -NXTMSG\n-FOUNDMSG\n&WORD = &XX&I\n-VERLOOP\n&D = &D + 1\n&A = &CONCAT &DISVAR &D\n&&A = &WORD\n&I = &I + 1\n&WORD = &XX&I\n&IF .&WORD NE . &THEN &GOTO -VERLOOP\n-NXTMSG\n&MSZI = &MSZI + 1\n&IF &MSZI LE &MSZ &THEN &GOTO -NEWMSG\n&WAIT CONTINUE\n***********************************************************************\n* IGNORE THESE MESSAGES\n* IST097I (5A97I) NCPSTOR ACCEPTED\n* IST244I (5C44I) NCP STORAGE FOR ID = (NCP)\n* IST314I (5D14I) END\n***********************************************************************\n-NOPVER\n&WAIT CONTINUE\n***********************************************************************\n* IST241I (5C41I) NCPSTOR COMMAND COMPLETE FOR ID = (NCP)\n***********************************************************************\n-ENDVER\nGO\n-STRVER\n&LASTNCP = &NCP\n&DISLAST  = &&A\n&GOTO -&DISRET\n************************************************************************\n* IST242I (5C42I) NCPSTOR COMMAND FAILED FOR ID = (NCP) SENSE = 08060000\n************************************************************************\n-REJECT\n* NCP STORAGE DISPLAY COMMAND REJECTED WITH MSG IST242I (5C42I)\n&IF &&MSGCNT NE '08060000' &THEN &GOTO -NOT0806\n&BEGWRITE SUB -REJ0806\n*** NCP &NCP IS AN UNKNOWN RESOURCE\n*** N.N.T. ENDED\n-REJ0806\n&GOTO -REJEXIT\n-NOT0806\n&BEGWRITE SUB -NOID\n*** INFORMATION IS NOT AVAILABLE FOR NCP &NCP\n*** N.N.T.  ENDED\n-NOID\n-REJEXIT\n&EXIT\n-ERROR\n&BEGWRITE\n*** CLIST NNT  HAS TIMED OUT, EXPECTED RESULTS WERE NOT RECEIVED\n&EXIT\n***********************************************************************\n*    OPERATOR TYPE CANCEL WHILE IN PENDING STATE.\n-CANCEL\nMESSAGE 317I,NNT\n&EXIT\n-TIMEOUT\n&WAIT DISPLAY\nMESSAGE 314I,NNT,60,SECONDS\n&EXIT\n*******************( END OF D I S )************************************\n***********************************************************************\n* DECHEX SUBROUTINE\n* ROUTINE TO CONVERT DECIMAL TO HEXADECIMAL\n* THE ONLY INPUT IS THE DECIMAL NUMBER UP TO 16777215\n* DECIN = DECIMAL INPUT\n* HEXVAL = HEX OUTPUT\n* DECRET = RETURN LOCATION\n***********************************************************************\n-DECHEX\n&HEXVAL =\n&VAL =\n&NUM = &DECIN\n-INRANGE\n&I = &LENGTH &NUM\n&I = &C&I\n&I = &I + 1\n-DLOOP\n&I = &I - 1\n&IF &NUM <  &H&I &THEN &GOTO -DLOOP\n&NUM = &NUM - &H&I\n&IF .&HEXVAL = . &THEN &GOTO -INITVAL\n&HLEN = &LENGTH &HEXVAL\n&LEN = &LENGTH &HEX&I\n&LEN = &HLEN - &LEN\n&VAL = &SUBSTR &HEXVAL 1 &LEN\n-INITVAL\n&HEXVAL = &CONCAT &VAL &HEX&I\n&IF &NUM > 0 &THEN &GOTO -INRANGE\n&GOTO -&DECRET\n\n\nAnthony J Cieri IV\nSenior Network Consultant\nSEI Corporation (USA)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N007A04": {"ttr": 8707, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x01\\xb1\\x01\\xb1\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:39", "lines": 433, "newlines": 433, "modlines": 0, "user": "SNAUPDT"}, "text": "Printer test program\n\nTESTPR was written to help in the set up and maintenance of\nour installation's printers. It started off as an exercise in writing\na simple VTAM application program to write some data to a\nprinter and has evolved into a useful tool for testing printers\nand diagnosing problems.\n\nThe program has been written to perform all the steps required\nto write a test pattern to a printer, one after another, checking\nfor errors at each step. The VTAM code is entirely\nsynchronous to avoid the problems of determining exactly\nwhere and when a problem is detected. If an error occurs,\nrelevant diagnostic information is formatted, such as the\ncontents of registers 15 and 0 and the RPL return code,\nfeedback 2, and sense bytes. With this information, it should\nbe possible to determine what the problem is.\n\nHaving diagnosed the problem, the TESTPR program offers a\nway of doing further testing. Typically, problems will fall into\ntwo general areas: hardware problems, which you can't do\nmuch about, and LOGMODE problems, which can generally\nbe patched. In this instance, TESTPR can be used to test your\n'standard' printer LOGMODE tables to determine which entry\nis most suitable. This is done by using the basic format of the\nTESTPR command (from the TSO command line), ie:\n\n      TESTPR  printer-name  LOGMODE(name) APPLID(name)\n\nThe APPLID and LOGMODE parameters are optional, the \u00a8\ndefault values being specified in the program.\n\nShould you find that none of your existing LOGMODE entries\nwork, you can use the BIND image specified in the program,\nwhich should work for just about any printer. Since buffer sizes\nare fairly dynamic, these may be overridden on the command\nline to give various sizes. To do this, use the second format of\nthe TESTPR command, ie:\n\n      TESTPR  printer-name  QUERY  SLUBUFF(buffer size)\n                  PLUBUFF(buffer size) LUTYPE(lutype)\n                  APPLID(name)\n\nAs with the first format, all parameters are optional except the\nprinter name. If any of the other values are specified, they will\nbe plugged into the BIND image hard-coded into the program.\n\nIn all but a few very rare cases this should be enough to solve\nany printer problems.\n\n**********************************************************************\n*   This program will attempt to acquire a named printer and send    *\n*   a test print to it. Should any step in the acquire/print fail,   *\n*   diagnostic information will be displayed.                        *\n*   On entry, R1 points to the CPPL.                                 *\n**********************************************************************\nTESTPR   CSECT ,\n         USING *,R15\n         B     HERE\n         DC    C'TESTPR  &SYSDATE &SYSTIME'\nHERE     SAVE  (14,12)\n         DROP   R15\n         LR    R12,R15\n         USING SABTPR,R12\n         LA    R11,SAVEAREA\n         ST    R13,4(,R11)\n         ST    R11,8(,R13)\n         LR    R13,R11\n**********************************************************************\n*   Set up globally available addresses and map them with the        *\n*   relevant DSECTs.                                                 *\n**********************************************************************\n         LA    R2,RPL              ->Request Parameter List\n         USING IFGRPL,R2\n         LA    R3,NIB              ->Node Information Block\n         USING ISTDNIB,R3\n         LA    R6,ACB              ->Access method Control Block\n         USING IFGACB,R6\n**********************************************************************\n*   Parse the input parameters for the printer name and either the   *\n*   logmode, or alterations to the internal BIND image. The command  *\n*   format is:                                                       *\n*    SABTPR printer-name    LOGMODE(logmode-entry)                   *\n*                           APPLID(application-name)                 *\n*    --- or -----------------------------------------------------    *\n*    SABTPR printer-name    QUERY                                    *\n*                           SLUBUFF(buffer size)                     *\n*                           PLUBUFF(buffer size)                     *\n*                           LUTYPE(lutype)                           *\n*                           APPLID(application-name)                 *\n*   If any of the second block options (QUERY etc...) are specified  *\n*   we will use the internal BIND image, and ignore the LOGMODE      *\n*   name. Otherwise, we will use the logmode name specified. If no   *\n*   logmode has been given, we use the default of SCS .              *\n**********************************************************************\n         USING CPPL,R1             (Command Processor Parameter List)\n         USING PPL,R4              (Parse Parameter List)\n*--------------------------------- Initialize PPL --------------------*\n         LA    R4,PPLAREA          ->Parse parameter list\n         MVC   PPLUPT,CPPLUPT      ->User profile table (UPT)\n         MVC   PPLECT,CPPLECT      ->Environment control table (ECT)\n         MVC   PPLCBUF,CPPLCBUF    ->Command buffer\n         LA    R15,ECBPARS         ->Event control block (ECB)\n         ST    R15,PPLECB\n         L     R15,=A(SABPCL)      ->Parameter control list (PCL)\n         ST    R15,PPLPCL\n         LA    R15,PDLADDR         ->Parameter descriptor list (PDL)\n         ST    R15,PPLANS\n*--------------------------------- Save caller's userid in message ---*\n         USING PSCB,R4             (Protected Step Control Block)\n         L     R4,CPPLPSCB         ->PSCB\n         SR    R15,R15             Clear for IC\n         IC    R15,PSCBUSRL        Length of userid\n         BCT   R15,*+10            Save for userid :-\n         MVC   PRTUSER(*-*),PSCBUSER\n         EX    R15,*-6\n*--------------------------------- Invoke Parse service routine ------*\n         LA    R4,PPLAREA          ->Parse parameter list\n         CALLTSSR EP=IKJPARS,MF=(E,(4))\n         LTR   R15,R15\n         BNZ   RETURN\n*--------------------------------- Extract printer name --------------*\n         MVC   NIBSYM(8),=CL8' '   Clear area in case it's .lt. 8 chars\n         USING CMDSECT,R4          (Parse descriptor list)\n         L     R4,PDLADDR          ->Parse descriptor list\n         L     R14,PCE1            ->Printer name\n         LH    R15,PCE1+4          Length of printer name\n         BCT   R15,*+10\n         MVC   NIBSYM(*-*),0(R14)  Move to NIB\n         EX    R15,*-6\n*--------------------------------- Extract logmode name --------------*\n         MVC   NIBLMODE(8),=CL8' ' Clear area in case it's .lt. 8 chars\n         L     R14,PCE222          ->Logmode name\n         LH    R15,PCE222+4        Length of logmode name\n         TM    PCE222+6,X'80'      Did we get one ?\n         BO    *+12                (yes)\n         LA    R14,DFLTMODE        (no ) Use our default\n         LA    R15,8\n         BCT   R15,*+10            Move to work area\n         MVC   NIBLMODE(*-*),0(R14)\n         EX    R15,*-6\n         MVC   PRTLOGM,NIBLMODE    Move logmode name to print message\n*--------------------------------- Extract application name ----------*\n         L     R14,PCE777          ->application name\n         LH    R15,PCE777+4        Length of application name\n         TM    PCE777+6,X'80'      Did we get one ?\n         BZ    TESTSLU             (no )\n         XC    APPLIDN,APPLIDN     Clear application name field\n         STC   R15,APPLID          Save application name length\n         BCT   R15,*+10            Move to work area\n         MVC   APPLIDN(*-*),0(R14)\n         EX    R15,*-6\n*--------------------------------- Extract SLU buffer size -----------*\nTESTSLU  TM    PCE333+6,X'80'      Was the SLU buffer size specified ?\n         BZ    TESTPLU             (no )\n         L     R14,PCE333          ->SLU buffer size\n         MVC   SLUBUFR(1),0(R14)   Move SLU buffer parm to BIND image\n         OI    FLAGS,NOLMODE       Do not use logmode entry\n*--------------------------------- Extract PLU buffer size -----------*\nTESTPLU  TM    PCE444+6,X'80'      Was the PLU buffer size specified ?\n         BZ    TESTLUT             (no )\n         L     R14,PCE444          ->PLU buffer size\n         MVC   PLUBUFR(1),0(R14)   Move PLU buffer parm to BIND image\n         OI    FLAGS,NOLMODE       Do not use logmode entry\n*--------------------------------- Extract LU type -------------------*\nTESTLUT  TM    PCE555+6,X'80'      Was the LU type specified ?\n         BZ    TESTQRY             (no )\n         L     R14,PCE555          ->LU type\n         MVC   LUTYPE(1),0(R14)    Move LU type to BIND image\n         OI    FLAGS,NOLMODE       Do not use logmode entry\n*--------------------------------- Extract QUERY flag ----------------*\nTESTQRY  LH    R15,PCE6            Was the \"query\" option specified?\n         LTR   R15,R15\n         BZ    TESTEND             (no )\n         OI    BNDQUERY,X'80'      Set the queryable flag\n         OI    FLAGS,NOLMODE       Do not use logmode entry\n*--------------------------------- Command parsing complete ----------*\nTESTEND  TM    FLAGS,NOLMODE       Do we need to clear logmode ?\n         BZ    OPENACB             (no )\n         MVC   NIBLMODE(8),=CL8' ' Clear LOGMODE specified by user\n         LA    R0,LUBIND           ->our bind image\n         ST    R0,NIBNDAR          Stuff into NIB\n*--------------------------------- Open our ACB to VTAM --------------*\nOPENACB  OPEN  ((R6))              Open VTAM ACB\n         LTR   R15,R15             Did it open ?\n         BNZ   OPNERR              (no )\n*--------------------------------- Acquire the requested printer -----*\n         OPNDST RPL=(R2),          Go acquire the printer.             *\n               ACB=(R6),                                               *\n               NIB=(R3),                                               *\n               OPTCD=(SYN,ACQUIRE)\n         LTR   R15,R15             Did we get control of the printer\n         BNZ   ACQERR              (no )\n**********************************************************************\n*   Send a few lines of test data to the printer. Carriage control   *\n*   has been limited to issuing \"new-line\" (x'15') and \"form-feed\"   *\n*   (X'0C') commands, which all printers should respond to.          *\n**********************************************************************\n         MVC   PRTNAME,NIBSYM      Save printer name in message\n         LA    R7,MSGBUFF          Point to message test\n         LA    R8,LMSGBUFF         Get its length\n         SEND RPL=(R2),            Send message to printer             *\n               ACB=(R6),                                               *\n               AREA=(R7),                                              *\n               RECLEN=(R8),                                            *\n               BRACKET=(BB,EB),                                        *\n               OPTCD=(SYN)\n         LTR   R15,R15             Did the message go ?\n         BNZ   SNDERR              (no )\n*--------------------------------- Printed OK, release the printer ---*\nCLOSEDST CLSDST RPL=(R2),                                              *\n               ACB=(R6),                                               *\n               OPTCD=(SYN,RELEASE)\n         LTR   R15,R15             Did we release it OK ?\n         BNZ   RELERR              (no )\n*--------------------------------- Close ACB and issue end message ---*\nCLOSEACB CLOSE ((R6))              Close the ACB\n         LTR   R15,R15             Did the ACB close ?\n         BNZ   CLOERR              (no )\n         TM    FLAGS,NOLMODE       Did we use the internal BIND image?\n         BZ    *+10                (no )\n         MVC   NIBLMODE(8),=CL8'not-used'\n         MVC   M200NAME,NIBSYM\n         MVC   M200MODE,NIBLMODE\n         TPUT  M200,L'M200\nRETURN   LA    R4,PPLAREA          ->Parse parameter list\n         L     R4,PPLANS-PPL(,R4)  ->Answer area\n         LTR   R4,R4               Null?\n         BZ    EXITRC              (yes)\n         IKJRLSA (4)               (no )\nEXITRC   L     R13,4(,R13)\n         RETURN (14,12),RC=0\n**********************************************************************\n*   Various error routines.                                          *\n**********************************************************************\n*--------------------------------- Can't open the ACB ----------------*\nOPNERR   STM   R15,R0,REGERR\n         TPUT  M010,L'M010\n         BAL   R11,FMTREGS\n         BAL   R11,FMTACB\n         B     RETURN\n*--------------------------------- Can't acquire printer -------------*\nACQERR   STM   R15,R0,REGERR\n         TPUT  M011,L'M011\n         BAL   R11,FMTREGS\n         BAL   R11,FMTRPL\n         BAL   R11,FMTNIB\n         B     CLOSEACB\n*--------------------------------- Can't release printer -------------*\nRELERR   STM   R15,R0,REGERR\n         TPUT  M012,L'M012\n         BAL   R11,FMTREGS\n         BAL   R11,FMTRPL\n         BAL   R11,FMTNIB\n         B     CLOSEACB\n*--------------------------------- Can't close the ACB ---------------*\nCLOERR   STM   R15,R0,REGERR\n         TPUT  M013,L'M013\n         BAL   R11,FMTREGS\n         BAL   R11,FMTACB\n         B     RETURN\n*--------------------------------- Can't send data to printer --------*\nSNDERR   STM   R15,R0,REGERR\n         TPUT  M014,L'M014\n         BAL   R11,FMTREGS\n         BAL   R11,FMTRPL\n         B     CLOSEACB\n*--------------------------------- Format R15 and R0 at error --------*\nFMTREGS  UNPK  M101R15(9),REGERR(5)\n         TR    M101R15(8),TBLHEX\n         MVI   M101R15+8,C''''\n         UNPK  M101R00(9),REGERR+4(5)\n         TR    M101R00(8),TBLHEX\n         MVI   M101R00+8,C''''\n         TPUT  M100,L'M100\n         TPUT  M101,L'M101\n         BR    R11\n*--------------------------------- Format ACB error flag -------------*\nFMTACB   UNPK  M103ERR(3),ACBERFLG(2)\n         TR    M103ERR(2),TBLHEX\n         MVI   M103ERR+2,C''''\n         TPUT  M102,L'M102\n         TPUT  M103,L'M103\n         BR    R11\n*--------------------------------- Format RPL return/feedback codes --*\nFMTRPL   UNPK  M105RTN(3),RPLRTNCD(2)\n         TR    M105RTN(2),TBLHEX\n         MVI   M105RTN+2,C''''\n         UNPK  M105FDB(3),RPLFDB2(2)\n         TR    M105FDB(2),TBLHEX\n         MVI   M105FDB+2,C''''\n         UNPK  M105SEN(9),RPLSSEI(5)\n         TR    M105SEN(8),TBLHEX\n         MVI   M105SEN+8,C''''\n         TPUT  M104,L'M104\n         TPUT  M105,L'M105\n         BR    R11\n*--------------------------------- Format NIB connection flag --------*\nFMTNIB   UNPK  M107CON(3),NIBCON(2)\n         TR    M107CON(2),TBLHEX\n         MVI   M107CON+2,C''''\n         TPUT  M106,L'M106\n         TPUT  M107,L'M107\n         BR    R11\n**********************************************************************\n*   Data areas and constants                                         *\n**********************************************************************\nDW       DC    D'0'                WORKAREA\nREGERR   DC    2F'0'               R15, R0 AT TIME OF ERROR\nSAVEAREA DC    18F'0'              REGISTER SAVEAREA\nPPLAREA  DC    7A(0)               PARSE PARAMETER LIST (PPL)\nPDLADDR  DC    A(0)                ->PARSE DESCRIPTOR LIST (PDL)\nECBPARS  DC    A(0)                PARSE SERVICE ECB\nFLAGS    DC    X'00'               FLAGS :-\nNOLMODE  EQU   X'80'                USE DEFAULT LOGMODE\nAPPLID   DC    AL1(6)              APPLICATION NAME :-\nAPPLIDN  DC    CL8'WATPR   '\nDFLTMODE DC    CL8'SCS     '       DEFAULT LOGMODE NAME\nNL       EQU   21                  EQUATE FOR NEW LINE\nFF       EQU   12                  EQUATE FOR FORM FEED\nMSGBUFF  DC    AL1(NL,NL)          MESSAGE FOR PRINTER :-\n         DC    C'+--------------------------------+',AL1(NL)\n         DC    C'       THIS IS A TEST MESSAGE     ',AL1(NL)\n         DC    C'          ISSUED TO PRINTER       ',AL1(NL)\nPRTNAME  EQU   *+13,8,C'C'\n         DC    C'                                  ',AL1(NL)\n         DC    C'                BY                ',AL1(NL)\nPRTUSER  EQU   *+13,8,C'C'\n         DC    C'                                  ',AL1(NL)\n         DC    C'           USING LOGMODE          ',AL1(NL)\nPRTLOGM  EQU   *+13,8,C'C'\n         DC    C'                                  ',AL1(NL)\n         DC    C'+--------------------------------+',AL1(NL,FF)\nLMSGBUFF EQU   *-MSGBUFF\n         DC    C'0123456789ABCDEF'\nTBLHEX   EQU   *-256\n*                                  BIND IMAGE :-\nLUBIND   DC    X'01'                NON NEGOTIABLE BIND\n         DC    X'03'                FM PROFILE\n         DC    X'03'                TS PROFILE\n         DC    X'B1'                PRIMARY PROTOCOL\n         DC    X'90'                SECONDARY PROTOCOL\n         DC    X'70'                COMMON PROTOCOL\n         DC    X'80'\n         DC    X'00'                NO SECONDARY SEND PACING\n         DC    X'00'                NO SECONDARY RECEIVE PACING\nSLUBUFR  DC    X'85'                MAXRU\nPLUBUFR  DC    X'C7'                MAXRU\n         DC    X'07'                NO PRIMARY SEND PACING\n         DC    X'00'                NO PRIMARY RECEIVE PACING\nLUTYPE   DC    X'01'                PSERVIC :\nBNDQUERY DC    X'00'                 DEVICE QUERYABLE FLAG\n         DC    X'0001E100000000000000'\n         DC    F'0'\nACB      ACB   AM=VTAM,APPLID=APPLID\nRPL      RPL   AM=VTAM\nNIB      NIB   LISTEND=YES\nM010     DC    C'TPR010E Unable to OPEN VTAM ACB'\nM011     DC    C'TPR011E Unable to ACQUIRE selected printer'\nM012     DC    C'TPR012E Unable to RELEASE selected printer'\nM013     DC    C'TPR013E Unable to CLOSE VTAM ACB'\nM014     DC    C'TPR014E Send data failure'\nM100     DC    C'TPR100I Registers at time of failure:'\nM101     DC    C'TPR101I     R15: X''********''  R0: X''********'''\nM101R15  EQU   M101+19,9,C'X'\nM101R00  EQU   M101+36,9,C'X'\nM102     DC    C'TPR102I ACB error fields:'\nM103     DC    C'TPR103I     ACBERFLG: X''**'''\nM103ERR  EQU   M103+24,3,C'X'\nM104     DC    C'TPR104I RPL error fields:'\nM105     DC    C'TPR105I     RTNCD: X''**''   FDBK2: X''**''   SENSE: X*\n               ''********'''\nM105RTN  EQU   M105+21,3,C'X'\nM105FDB  EQU   M105+36,3,C'X'\nM105SEN  EQU   M105+51,9,C'X'\nM106     DC    C'TPR104I NIB connect flag:'\nM107     DC    C'TPR107I     NIBCON: X''**''  (X''40''  -  CON=YES)'\nM107CON  EQU   M107+22,3,C'X'\nM200     DC    C'TPR200I Program completed. (Printer: ******** Logmode *\n               ********)'\nM200NAME EQU   M200+37,8,C'C'\nM200MODE EQU   M200+54,8,C'C'\n***********************************************************************\n*   Parse control list - parse command line parameters.               *\n***********************************************************************\nSABPCL   IKJPARM DSECT=CMDSECT\nPCE1     IKJPOSIT JOBNAME,UPPERCASE,                                   *\n               PROMPT='name of printer to be tested',                  *\n               HELP=('name of a printer to which you wish to send a tes*\n               t print','a 1-8 alphameric character string ')\nPCE2     IKJKEYWD\n         IKJNAME 'LOGMODE',SUBFLD=PCE22,ALIAS='MODE'\nPCE3     IKJKEYWD\n         IKJNAME 'SLUBUFF',SUBFLD=PCE33\nPCE4     IKJKEYWD\n         IKJNAME 'PLUBUFF',SUBFLD=PCE44\nPCE5     IKJKEYWD\n         IKJNAME 'LUTYPE',SUBFLD=PCE55\nPCE6     IKJKEYWD\n         IKJNAME 'QUERY'\nPCE7     IKJKEYWD\n         IKJNAME 'APPLID',SUBFLD=PCE77\nPCE22    IKJSUBF\nPCE222   IKJIDENT 'LOGMODE',FIRST=ALPHA,OTHER=ANY,MAXLNTH=8,           *\n               DEFAULT='SCS     '\nPCE33    IKJSUBF\nPCE333   IKJIDENT 'SLUBUFF',HEX,MAXLNTH=2\nPCE44    IKJSUBF\nPCE444   IKJIDENT 'PLUBUFF',HEX,MAXLNTH=2\nPCE55    IKJSUBF\nPCE555   IKJIDENT 'LUTYPE',HEX,MAXLNTH=2\nPCE77    IKJSUBF\nPCE777   IKJIDENT 'APPLID',FIRST=ALPHA,OTHER=ANY,MAXLNTH=8,            *\n               DEFAULT='WATPR   '\n         IKJENDP\n***********************************************************************\n*        Mapping MACROs                                               *\n***********************************************************************\n         CVT   DSECT=YES           COMMUNICATIONS VECTOR TABLE\n         IKJCPPL ,                 COMMAND PROCESSOR PARAMETER LIST\n         IKJPPL ,                  PARSE PARAMETER LIST\n         IKJPSCB ,                 PROTECTED STEP CONTROL BLOCK\n         IFGACB AM=VTAM,DSECT=YES\n         IFGRPL AM=VTAM,DSECT=YES\n         ISTDNIB\n         EQUREG R\n         END   ,\n\n\nS A Barnett\nSenior Technical Consultant\nIMI Computing Ltd (UK)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N007A05": {"ttr": 8715, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00C\\x00C\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:39", "lines": 67, "newlines": 67, "modlines": 0, "user": "SNAUPDT"}, "text": "LAN to mainframe connectivity via APPN\n\nSNA Update, Issue 4, December 1991, described the\nenhancement to the 3174 to enable PU type 2.1 traffic to pass\nthrough unimpaired. A new piece of the APPN jigsaw has now\nbeen added with the announcement by IBM of the 3172. This\ndevice connects directly to an IBM mainframe channel and\nsupports the attachment of a token ring. As such it is an\nalternative to the 3745 and 3174 as a means of connecting a\ntoken ring to the mainframe. A key difference is that the 3172\nwill connect not just token ring but all main local area network\nprotocols and hardware (Ethernet, PC Network, FDDI, and\nMAP).\n\nWhen attached by a 3172, the token ring appears to the\nmainframe to be an SNA switched major node, that is a PU\ntype 2.0 and a set of associated LUs. There is nothing\nsignificant or different about this. What is significant is that the\n3172 will also support PU type 2.1: in other words, APPN.\nThis would indicate that it is not intended to put APPN support\ninto the 3174 Establishment Controller, the cheaper way of\nconnecting a token ring to a mainframe, but what about the\n3745 which still awaits significant APPN announcements?\n\nPrice-wise the 3172 is not cheap, but it is considerably less\nexpensive than the 3745. This is significant since recent\nACF/NCP announcements suggest that new developments such\nas APPN and X.25 Frame Relay may not be supported on older\ncommunications controllers such as the 3725 and 3720. The\n3172 therefore offers a cheaper alternative to the 3745 or\nwhatever may follow to replace this ageing device and a\nreplacement for locally-attached 3174s.\n\nWhat is interesting about this announcement is that it is the\nclosest APPN has got to the mainframe. Low Entry\nNetworking has seen a series of announcements supporting\nAPPN. LEN implements APPN PU type 2.1 such that PS/2s\nwith OS/2 Extended Edition and Communications Manager are\nable to establish sessions between themselves directly.\nHowever, this does rely on the PS/2s being directly linked: if\nthey are not, it is back to the host for session establishment.\n\nRecently announced is a new Systems Application Architecture\n(SAA) product, Network Services/2, which runs under OS/2\nExtended Edition on the PC and enables development of APPN\nend nodes. Two PCs operating under NS/2, configured to\nsupport an end node and running an APPN application, will be\nable to communicate directly with each other, peer-to-peer,\nover a LAN. These products all indicate that APPN has been\npitched initially to bring as much local area networking as\npossible into the SNA world. The 3172 begins to extend this\nAPPN incorporation to the mainframe.\n\nOn paper the 3172 offers a bridge to allow high-level network\nprotocols (APPN, OSI, TCP/IP) to pass from the LAN to the\nmainframe. It is not apparent whether the 3172s act as more\nthan a bridge and have full APPN network node capabilities\n(dynamic connectivity, network management etc). If this is the\nintention, what is missing is a remote version of the 3172.\nKeep watching.\n\nBrian Alford\nSystems Consultant\nAranda (UK)\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N007A06": {"ttr": 8961, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x01\\x16\\x05O\\x01\\x16\\x06/\\x12I\\x02\\xc5\\x02\\xc2\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T12:49:43", "lines": 709, "newlines": 706, "modlines": 0, "user": "SNAUPDT"}, "text": "NetView application development using VIEW\n\nWhen our operations department requested an application to\nexecute under NetView, I wrote a REXX EXEC that utilizes\nthe NetView VIEW command processor.\n\nVIEW is a powerful feature of the NetView product which\nallows users to create panels using various colours and\nhighlighting criteria. When I originally looked at developing\nthe application I considered using NetView Assembler macros.\nThese are very cumbersome and rely heavily on coding 3270\ndatastreams. I decided to use VIEW because of its ease of use\nand the methods it uses to control the screen, and its flexible\napproach to displaying data.\n\nThe application that I developed provides an interface to the\nuser allowing him to issue NetView commands and to monitor\nthe changing status of tape devices indicated by the changing\ncolours on the screen. The VIEW command is structured in the\nfollowing way:\n\n      VIEW name1 name2 MSG|NOMSG INPUT|NOINPUT\n\no      name1 - this is an application name used by the NetView\n      program. This name allows the user to name the\n      application.\n\no      name2 - the name of the panel to be displayed.\n\no      MSG - this allows the panel to be interrupted to receive\n      messages or to be updated without pressing the ENTER\n      key. This allows status changes to be shown dynamically.\n\no      NOMSG - this is the default setting and forces the\n      NetView user to press the ENTER key to obtain an\n      indication of a change in status.\n\no      INPUT - will return useful information, such as last key\n      pressed, cursor location, etc.\n\no      NOINPUT - treats all input as commands.\n\nThe panels that can be created using the VIEW command allow\ncolour and highlighting to be controlled using attribute symbols\nor attribute variables. Obviously how data is displayed is\ndependent on the type of terminal device being utilized.\n\nAttribute symbols are defined in the panel source code. There\nare two attribute sets available for use. The one that is used is\ncontrolled by an option coded at the start of the panel\ndefinition.\n\nFor example, if you code three asterisks at the start of the panel\nthe default attribute set (AT1) is used. If you code three\nasterisks followed by the character string AT2, then the\nalternate attribute set will be used. The facilities available in\neach attribute set are shown below.\n\n\nATTRIBUTE SET ONE (AT1)\n\nColour                       Symbol    Hex char   Intensity    Field\nWHITE                          %         X'6C'      HIGH       TEXT\nREVERSED WHITE                 }         X'D0'      HIGH       TEXT\nUNDERSCORED WHITE              !         X'5A'      HIGH       TEXT\nWHITE                          ~         X'A1'      HIGH       INPUT\nTURQUOISE                      $         X'5B'      HIGH       TEXT\nUNDERSCORED TURQUOISE          \\         X'E0'      HIGH       TEXT\nBLUE                           +         X'4E'      NORMAL     TEXT\nREVERSED BLUE                  {         X'C0'      HIGH       TEXT\nGREEN                          @         X'7C'      NORMAL     TEXT\nYELLOW                         \u00ac         X'5F'      NORMAL     TEXT\nPINK                           |         X'6A'      NORMAL     TEXT\nRED                            #         X'4A'      HIGH       TEXT\n\n\nATTRIBUTE SET TWO (AT2)\n\nColour                       Symbol    Hex char   Intensity    Field\nWHITE                          %         X'6C'      HIGH       TEXT\nREVERSED WHITE                 }         X'D0'      HIGH       TEXT\nREVERSED RED                   !         X'5A'      HIGH       TEXT\nWHITE                          ~         X'A1'      HIGH       TEXT\nTURQUOISE                      $         X'5B'      NORMAL     TEXT\nREVERSED TURQUOISE             \\         X'E0'      NORMAL     TEXT\nBLUE                           +         X'4E'      NORMAL     TEXT\nREVERSED BLUE                  {         X'C0'      NORMAL     TEXT\nGREEN                          @         X'7C'      NORMAL     TEXT\nYELLOW                         \u00ac         X'5F'      NORMAL     TEXT\nREVERSED YELLOW                |         X'6A'      NORMAL     TEXT\nBLINKING RED                   #         X'4A'      NORMAL     TEXT\n\nCertain rules exist that relate to attribute sets and their usage on\npanels. These are detailed in the NetView Customization\nmanual. In contrast, attribute variables are actually assigned in\nthe command procedure or REXX EXEC that is being used to\ndrive the application.  Again rules exist for their usage:\nhowever, this method of defining attributes allows much more\nflexible design. The potential values for attribute variables are\nas follows.\n\nF = FIELD\n\nValues\n\nFA      Protected data that cannot be entered on a displayed\n      panel. This is the default setting.\n\nF1      Unprotected data that can be entered.\n\nI = INTENSITY\n\nValues\n\nIN      Normal\nIH      High\nID      Dark, non-displayable data.\n\nC = COLOUR\n\nValues\n\nCD      Default for device\nCW      White or neutral\nCB      Blue\nCR      Red\nCP      Pink\nCG      Green\nCT      Turquoise\nCY      Yellow.\n\nH = HIGHLIGHT\n\nValues\n\nHD      Default extended highlighting\nHB      Blinking\nHR      Reverse video\nHU      Underscored.\n\nU = CURSOR\n\nValues\n\nUN      Cursor will not be placed at this field.\nUY      Cursor will be placed at the beginning of this field. This\n      must be specified for only one variable on the panel.\n\nAPPLICATION DESIGN\n\nWhen I designed the application it was decided that it would be\nthe front end for our tape operators and would be invoked at\nsign-on. This meant that the operators would have to be able to\nissue commands from the panel and, if another component of\nNetView was utilized, upon completion, the tape application\nwould always be re-invoked. This is achieved by using the\nVIEW command and in NetView terminology is known as a\n'rollable' application. The way in which NetView is designed\nforces the controlling application (the tape application in this\ninstance) to be suspended until a command entered from the\npanel completes. This was undesirable and I overcame the\nproblem by using the CMD HIGH command in the REXX\nEXEC. This command queues the entered command for\nexecution then returns to the invoking REXX EXEC.\n\nThe NetView program itself allows multiple copies of a\ncommand processor or application to be executed at once.\nBecause our application is one that will be running constantly\nthis can cause problems to occur if more than one copy is\nexecuted at a time under the same NetView task. This could\ncause the ROLL effect of the application to behave in\nunpredictable ways. To overcome this I used the UNIQUE\ncommand. By coding the SIGNAL ON HALT and UNIQUE, I\nensured that error messages are trapped and that the ROLL\napplication is always re-invoked.\n\nThree special variables are provided to help manage full-screen\ninput. These are:\n\nREXX and HLL    NetView CLIST     Description\nVIEWAID         &VIEWAID          The AID key used to\n                                  enter input.\nVIEWCURROW      &VIEWCURROW       The cursor location\n                                  (ROW) when the AID key was pressed.\nVIEWCURCOL      &VIEWCURCOL       The cursor location\n                                  (COLUMN) when the AID key was pressed.\n\nThe values of these variables will depend on how the panel is\nused. VIEWAID can have values of PF1, PF2 - 24, PA1, PA2,\nand PA3. If PA1, PA2, or PA3 are pressed the other two\nvariables are not set, only VIEWAID is set. The other variables\nare only set if the PF keys are used or if ENTER is pressed.\n\nThe application I designed is very simple. The tape operators\ninitially wanted to be able to see the changing status of tape\ndrives while performing other tasks. When a tape operator\nsigns on to the master tape operator user-id the application is\nstarted. It sets up the necessary environment and initializes\nseveral attribute variables. It then calls an internal subroutine to\nissue MVS DISPLAY UNIT commands for the six tape drives\nin question. From this it sets up further display variables, and if\na tape is already mounted on one of these devices it resets the\npreviously set attribute variables. The reason for this reset will\nbe explained later.\n\nOnce all variables are set it uses a special command to place\nthe values into the GLOBAL variable pool. It then enters a\ndisplay section. Using the VIEW command the first panel is\ndisplayed. The panel will show boxes representing the tape\ndevices and the status of the devices will be displayed\nunderneath the boxes. The variables are set to display in green\nif the device is not in use. If the device is in use then the\nvariables are set to display in yellow. This is the reason for the\nprevious reset. If the MVS DISPLAY command shows that a\nvolume is mounted on a tape drive then the original setting of\nthe variable is changed to allow the variable to be displayed in\nyellow.\n\nThe operator can then monitor tape status changes throughout\nthe day as the colours change from green to yellow. Once the\ninitial application has been started the status changes are\nrecorded by trapping MVS tape mount messages using\nNetView Message Automation Tables.\n\nThe application is now started and the initial panel displayed.\nThe operator can enter NetView commands on the command\nline or use the PF keys defined to the application to end the\napplication, display the second panel which contains on-line\nhelp information, or perform other functions. The second panel\nis displayed if the PF8 key is pressed or if the operator types\nNEXT and presses the ENTER key. This panel is a simple help\npanel and is controlled in the same way as the first panel by\nusing the VIEW command.\n\nBecause the initial panel is issued with the MSG parameter, the\npanel can be updated without the operator having to press the\nENTER key. The application utilizes this feature of the VIEW\ncommand by using NetView message automation tables. All\nwe want to do is change the status of the global variables if a\ntape is mounted on a device, or if the tape is de-mounted.\n\n\nMAIN TAPE ALLOCATION REXX EXEC\n\n/* REXX */\n/*       ********************************************************    */\n/*       * PROGRAM NAME: BTAPAPL.                               *    */\n/*       * PROGRAMMER:   JOHN BRADLEY.                          *    */\n/*       * PURPOSE.                                             *    */\n/*       * THIS APPLICATION WAS DESIGNED TO HELP OUR OPERATIONS *    */\n/*       * PERSONNEL MONITOR THE STATUS OF OUR TAPE AND         *    */\n/*       * CARTRIDGE DRIVES. IT IS NOT MEANT TO BE A            *    */\n/*       * COMPREHENSIVE TAPE AND CARTRIDGE MONITOR.            *    */\n/*       * WHEN THE TAPE OPERATOR SIGNS ONTO THE SYSTEM THE     *    */\n/*       * APPLICATION IS STARTED AND THE TAPE STATUSES ARE     *    */\n/*       * OBTAINED.                                            *    */\n/*       * STANDARD STATUS WITH NO TAPE IN USE IS DISPLAYED     *    */\n/*       * IN GREEN.                                            *    */\n/*       * MESSAGE AUTOMATION TABLE ENTRIES ARE USED TO CHANGE  *    */\n/*       * THE COLOUR TO YELLOW IF A TAPE IS MOUNTED ON A       *    */\n/*       * DRIVE.                                               *    */\n/*       * PANELS: THE APPLICATION USES BTAPPNL1 AND BTAPAPL2.  *    */\n/*       * EXECS:  REXX EXEC BTAPAPL2 IS USED BY THE MESSAGE    *    */\n/*       *         AUTOMATION.                                  *    */\n/*       ********************************************************    */\n/*       * INITSECT IS USED TO INITIALIZE THE ENVIRONMENT AND   *    */\n/*       * SETUP ATTRIBUTES FOR VARIOUS VARIABLES.              *    */\n/*       ********************************************************    */\nINITSECT:\nSIGNAL ON HALT                         /* USE WITH NETVIEW VIEW.     */\n'UNIQUE PROMOTE'                       /* ONLY BTAPAPL APPLICATION.  */\nIF RC = 4 THEN EXIT -5                 /* BAD RC FROM UNIQUE.        */\nSIGNAL ON ERROR                        /* SETUP SIGNAL ON ERROR.     */\n$VAR1 = 'FA IH CG HR UN'               /* SETUP DISPLAY VARIABLE     */\n$VAR2 = 'FA IH CG HR UN'               /* ATTRIBUTES.                */\n$VAR3 = 'FA IH CG HR UN'\n$VAR4 = 'FA IH CG HR UN'\n$VAR5 = 'FA IH CG HR UN'\n$VAR6 = 'FA IH CG HR UN'\n$VAR7 = 'FA IH CG HR UN'\n$VAR8 = 'FA IH CG HR UN'\n$VAR9 = 'FA IH CG HR UN'\n$VAR10 = 'FA IH CG HR UN'\n$VAR11 = 'FA IH CG HR UN'\n$VAR12 = 'FA IH CG HR UN'\n$COMMAND = 'FI          UY'            /* SETUP INPUT VARIABLE.      */\n/*       ********************************************************    */\n/*       * PROCSECT IS USED TO CALL A SUBROUTINE THAT PERFORMS  *    */\n/*       * PROCESSING TO INITIALIZE FURTHER VARIABLES FROM      *    */\n/*       * OUTPUT OBTAINED USING THE MVS DISPLAY COMMAND.       *    */\n/*       ********************************************************    */\nPROCSECT:\nCALL DISPSUB 440                       /* CALL SUBROUTINE.           */\nU440 = UNITNME1                        /* PUT UNITNAME INTO VAR.     */\nS440 = UNITSTS1                        /* PUT UNIT STATUS INTO VAR.  */\nIF VOLSTAT1 \u00ac= '' THEN                 /* IF TAPE ON DRIVE THEN      */\n   DO                                  /* SETUP VARIABLES TO DISPLAY */\n    $VAR1 = 'FA IH CY HR UN'           /* AS YELLOW INSTEAD OF       */\n    $VAR3 = 'FA IH CY HR UN'           /* GREEN.                     */\n   END\nCALL DISPSUB 441                       /* CALL SUBROUTINE.           */\nU441 = UNITNME1                        /* PUT UNITNAME INTO VAR.     */\nS441 = UNITSTS1                        /* PUT UNIT STATUS INTO VAR.  */\nIF VOLSTAT1 \u00ac= '' THEN                 /* IF TAPE ON DRIVE THEN      */\n   DO                                  /* SETPU VARIABLES TO DISPLAY */\n   $VAR2 = 'FA IH CY HR UN'            /* AS YELLOW INSTEAD OF       */\n   $VAR4 = 'FA IH CY HR UN'            /* GREEN.                     */\n  END\nCALL DISPSUB C00                       /* CALL SUBROUTINE.           */\nUC00 = UNITNME1                        /* PUT UNITNAME INTO VAR.     */\nSC00 = UNITSTS1                        /* PUT UNIT STATUS INTO VAR.  */\nIF VOLSTAT1 \u00ac= '' THEN                 /* IF TAPE ON DRIVE THEN      */\n   DO                                  /* SETUP VARIABLES TO DISPLAY */\n    $VAR5 = 'FA IH CY HR UN'           /* AS YELLOW INSTEAD OF       */\n    $VAR9 = 'FA IH CY HR UN'           /* GREEN.                     */\n   END\nCALL DISPSUB C01                       /* CALL SUBROUTINE.           */\nUC01 = UNITNME1                        /* PUT UNITNAME INTO VAR.     */\nSC01 = UNITSTS1                        /* PUT UNIT STATUS INTO VAR.  */\nIF VOLSTAT1 \u00ac= '' THEN                 /* IF TAPE ON DRIVE THEN      */\n   DO                                  /* SETUP VARIABLES TO DISPLAY */\n    $VAR6 = 'FA IH CY HR UN'           /* AS YELLOW INSTEAD OF       */\n    $VAR10 = 'FA IH CY HR UN'          /* GREEN.                     */\n   END\nCALL DISPSUB C08                       /* CALL SUBROUTINE.           */\nUC08 = UNITNME1                        /* PUT UNITNAME INTO VAR.     */\nSC08 = UNITSTS1                        /* PUT UNIT STATUS INTO VAR.  */\nIF VOLSTAT1 \u00ac= '' THEN                 /* IF TAPE ON DRIVE THEN      */\n   DO                                  /* SETUP VARIABLES TO DISPLAY */\n    $VAR7 = 'FA IH CY HR UN'           /* AS YELLOW INSTEAD OF       */\n    $VAR11 = 'FA IH CY HR UN'          /* GREEN.                     */\n   END\nCALL DISPSUB C09                       /* CALL SUBROUTINE.           */\nUC09 = UNITNME1                        /* PUT UNITNAME INTO VAR.     */\nSC09 = UNITSTS1                        /* PUT UNIT STATUS INTO VAR.  */\nIF VOLSTAT1 \u00ac= '' THEN                 /* IF TAPE ON DRIVE THEN      */\n   DO                                  /* SETUP VARIABLES TO DISPLAY */\n    $VAR8 = 'FA IH CY HR UN'           /* AS YELLOW INSTEAD OF       */\n    $VAR12 = 'FA IH CY HR UN'          /* GREEN.                     */\n   END\n/*       ********************************************************    */\n/*       * FOLLOWING COMMAND IS USED TO CREATE GLOBAL VARIABLES *    */\n/*       * FROM THE VARIABLES INITIALIZED IN PREVIOUS SECTION   *    */\n/*       * AND THIS SECTION.                                    *    */\n/*       ********************************************************    */\n'GLOBALV PUTC $VAR1,$VAR2,$VAR3,$VAR4,$VAR5,$VAR6',\n              '$VAR7,$VAR8,$VAR9,$VAR10,$VAR11,$VAR12',\n              'S440,S441,SC00,SC01,SC08,SC09'\n/*       ********************************************************    */\n/*       * DISPSECT DISPLAYS THE INITIAL PANEL FOR BTAPAPL.     *    */\n/*       * THE APPLICATION IS CREATED AS ROLLABLE.              *    */\n/*       * COMMANDS CAN BE ISSUED FROM THE PANEL.               *    */\n/*       * THE PFKEYS USED BY THE APPLICATION FOLLOW STANDARD   *    */\n/*       * NETVIEW DESIGN.                                      *    */\n/*       ********************************************************    */\nDISPSECT:\n DO FOREVER                                 /* LOOP FOREVER.         */\n    COMMAND = '00'X                         /* CLEAR CMDLINE FOR INP */\n    'VIEW BTAPAPPL BTAPPNL1 MSG INPUT'      /* PUT PANEL ON SCREEN.  */\n    UPPER COMMAND                           /* TRANSLATE INPUT.      */\n    SELECT                                  /* CONTROL PFKEYS.       */\n     WHEN VIEWAID = PF2 THEN EXIT\n     WHEN VIEWAID = PF3 THEN CMD HIGH RETURN\n     WHEN VIEWAID = PF6 THEN CMD HIGH ROLL\n     WHEN VIEWAID = PF8 THEN CALL DISPSEC2\n     WHEN VIEWAID = ENTER THEN\n      SELECT\n       WHEN COMMAND = NEXT THEN CALL DISPSEC2\n       WHEN COMMAND \u00ac= ' ' THEN\n        DO\n         'CMD HIGH' COMMAND\n        END\n         OTHERWISE NOP\n      END\n       OTHERWISE NOP\n    END\n END\nEXIT\n/*       ********************************************************    */\n/*       * DISPSEC2 DISPLAYS THE INITIAL PANEL FOR BTAPAPL.     *    */\n/*       * THE APPLICATION IS CREATED AS ROLLABLE.              *    */\n/*       * COMMANDS CAN BE ISSUED FROM THE PANEL.               *    */\n/*       * THE PFKEYS USED BY THE APPLICATION FOLLOW STANDARD   *    */\n/*       * NETVIEW DESIGN.                                      *    */\n/*       ********************************************************    */\nDISPSEC2:\n DO FOREVER                                 /* LOOP FOREVER.         */\n    COMMAND = '00'X                         /* CLEAR CMDLINE FOR INP */\n    'VIEW BTAPAPPL BTAPPNL2 MSG INPUT'      /* PUT PANEL ON SCREEN.  */\n    UPPER COMMAND                           /* TRANSLATE INPUT.      */\n    SELECT                                  /* CONTROL PFKEYS.       */\n     WHEN VIEWAID = PF2 THEN EXIT\n     WHEN VIEWAID = PF3 THEN CMD HIGH RETURN\n     WHEN VIEWAID = PF6 THEN CMD HIGH ROLL\n     WHEN VIEWAID = PF7 THEN RETURN\n     WHEN VIEWAID = ENTER THEN\n      SELECT\n       WHEN COMMAND = BACK THEN RETURN\n       WHEN COMMAND \u00ac= ' ' THEN\n        DO\n         'CMD HIGH' COMMAND\n        END\n         OTHERWISE NOP\n      END\n       OTHERWISE NOP\n    END\n END\nRETURN\n/*       ********************************************************    */\n/*       * DISPSUB IS THE SUBROUTINE THAT IS USED TO ISSUE      *    */\n/*       * MVS DISPLAY COMMANDS AND TRAP THE OUTPUT TO USE      *    */\n/*       * VARIOUS FIELDS TO INITIALIZE VARIABLES.              *    */\n/*       ********************************************************    */\nDISPSUB:\nARG UNITPRM                            /* OBTAIN PARAMETER.          */\nUNITNME1 = ' '                         /* INITIALIZE VARIABLES.      */\nUNITTYP1 = ' '\nUNITSTS1 = ' '\nVOLSER1 = ' '\nVOLSTAT1 = ' '\nFLUSHQ                                 /* START MESSAGE PROCESSING.  */\n'TRAP AND SUPPRESS ONLY MESSAGES IEE450I'\n'MVS D U,,,'UNITPRM',1'\n'WAIT 5 SECONDS FOR MESSAGES'\nSELECT\n WHEN EVENT() = 'M' THEN\n  DO\n   'MSGREAD'\n   'GETMLINE LINE' 3\n   'PARSEL2R LINE UNITNME1 UNITTYP1 UNITSTS1 VOLSER1 VOLSTAT1'\n  END\nEND\nRETURN                                 /* RETURN TO MAIN PROCESSING. */\n/*       ********************************************************    */\n/*       * ERROR AND HALT ARE ROUTINES THAT ARE ENTERED IF THE  *    */\n/*       * PREVIOUS SIGNAL COMMANDS ARE FIRED.                  *    */\n/*       ********************************************************    */\nERROR:\nEXIT -6\nHALT:\nEXIT -7\n\n\nPANEL BTAPPNL1\n\n/*       ********************************************************    */\n/*       * PANEL DEFINITION.                                    *    */\n/*       * NETVIEW MAIN DISPLAY PANEL FOR BTAPAPL.              *    */\n/*       ********************************************************    */\n*** AT2\n+BTAPPNL1\n\u00ac                    O N L I N E   T A P E   M O N I T O R\n$\n$\n\u00ac                                 T A P E S\n$\n$                  &VAR1     $                   &VAR2     $\n$                  &VAR3     $                   &VAR4     $\n$\n$                     &U440$                        &U441$\n$                   &S440    $                    &S441    $\n$\n\u00ac                            C A R T R I D G E S\n$\n$        &VAR5     $    &VAR6     $    &VAR7     $    &VAR8     $\n$        &VAR9     $    &VAR10    $    &VAR11    $    &VAR12    $\n$\n$           &UC00$         &UC01$         &UC08$         &UC09$\n$         &SC00    $     &SC01    $     &SC08    $     &SC09    $\n$\n%ACTION===>&COMMAND                                                    %\n$\n$        PF2= End  PF3= Return  PF6= Roll  PF8= Forward\n\n\nPANEL BTAPPNL2\n\n/*       ********************************************************    */\n/*       * PANEL DEFINITION.                                    *    */\n/*       * btapapl SECONDARY DISPLAY PANEL       .              *    */\n/*       ********************************************************    */\n*** AT2\n+BTAPPNL2\n\u00ac                    O N L I N E   T A P E   M O N I T O R\n$\n$\n$   This system allows the current status of our tape drives to be\n$   monitored.\n$\n$   The previous panel displays the status as@GREEN$when the tape\n$   drive is not in use.\n$\n$   If a tape drive is in use then it will be displayed in\u00acYELLOW$.\n$\n$   The unit address and MVS status are displayed below the tape\n$   status display.\n$\n$   Any available%NETVIEW$commands can be issued from the%COMMAND$line\n$   and once complete the tape application will be re-instated.\n$\n$   Use the%PFKEYS$to control the flow of the panels being displayed.\n$\n%ACTION===>&COMMAND                                                    %\n$\n$        PF2= End  PF3= Return  PF6= Roll  PF7= Back\n\n\nMessage Automation Table statements\n\n*        **************************************************************\n*        * MESSAGE AUTOMATION STATEMENTS FOR BTAPAPL REXX EXEC.       *\n*        **************************************************************\n IF MSGID='TMS001' & TOKEN(2)='IEF233A' & TEXT = .A\n  THEN EXEC(CMD('BTAPAPL2 ' A)\n  ROUTE(ONE STS01));\n*\n IF MSGID='TMS001' & TOKEN(2)='IEF233D' & TEXT = .A\n  THEN EXEC(CMD('BTAPAPL2 ' A)\n  ROUTE(ONE STS01));\n*\n IF MSGID='IEF234E' & TEXT = .A\n  THEN EXEC(CMD('BTAPAPL3 ' A)\n  ROUTE(ONE STS01));\n\n\nBTAPAPL2 REXX EXEC\n\nWhen a tape management message is issued to the operator's\nmaster console and the second word in the message is\n'IEF233A', the message text is captured and the following sub-\napplication is called.\n\n/* REXX */\n/*       ********************************************************    */\n/*       * BTAPAPL2 IS CALLED BY MESSAGE AUTOMATION TO UPDATE   *    */\n/*       * THE BTAPPNL1 SCREEN.                                 *    */\n/*       ********************************************************    */\nARG PARMSTR\n'PARSEL2R PARMSTR PARM1 PARM2 PARM3'\nIF SUBSTR(PARM3,1,3) = 440 THEN\n   DO\n    'GLOBALV GETC $VAR1,$VAR3'\n    $VAR1 = 'FA IH CY HR UN'\n    $VAR3 = 'FA IH CY HR UN'\n    'GLOBALV PUTC $VAR1,$VAR3'\n   END\nIF SUBSTR(PARM3,1,3) = 441 THEN\n   DO\n    'GLOBALV GETC $VAR2,$VAR4'\n    $VAR2 = 'FA IH CY HR UN'\n    $VAR4 = 'FA IH CY HR UN'\n    'GLOBALV PUTC $VAR2,$VAR4'\n   END\nIF SUBSTR(PARM3,1,3) = C00 THEN\n   DO\n    'GLOBALV GETC $VAR5,$VAR9'\n    $VAR5 = 'FA IH CY HR UN'\n    $VAR9 = 'FA IH CY HR UN'\n    'GLOBALV PUTC $VAR5,$VAR9'\n   END\nIF SUBSTR(PARM3,1,3) = C01 THEN\n   DO\n    'GLOBALV GETC $VAR6,$VAR10'\n    $VAR6 = 'FA IH CY HR UN'\n    $VAR10 = 'FA IH CY HR UN'\n    'GLOBALV PUTC $VAR6,$VAR10'\n   END\nIF SUBSTR(PARM3,1,3) = C08 THEN\n   DO\n    'GLOBALV GETC $VAR7,$VAR11'\n    $VAR7 = 'FA IH CY HR UN'\n    $VAR11 = 'FA IH CY HR UN'\n    'GLOBALV PUTC $VAR7,$VAR11'\n   END\nIF SUBSTR(PARM3,1,3) = C09 THEN\n   DO\n    'GLOBALV GETC $VAR8,$VAR12'\n    $VAR8 = 'FA IH CY HR UN'\n    $VAR12 = 'FA IH CY HR UN'\n    'GLOBALV PUTC $VAR8,$VAR12'\n   END\nEXIT\n\n\nBTAPAPL3 REXX EXEC\n\nThe application is passed the text of the message that has\ncaused it to be called. The application then checks to see which\ndevice has issued the tape mount message. Once it has\nidentified this it updates the global variables and places them\nback in the global pool. Once this has occurred the main\napplication display will change to show the tape device as\nbeing used, and the colour of the box presented on the panel\nfor that tape device will change from green to yellow.\n\nThe second message automation statement works in the same\nway but for a different mount message. The last statement calls\nthe application presented below.\n\n/* REXX */\n/*       ********************************************************    */\n/*       * BTAPAPL3 IS CALLED BY MESSAGE AUTOMATION TO UPDATE   *    */\n/*       * THE BTAPAPL1 SCREEN.                                 *    */\n/*       ********************************************************    */\nARG PARMSTR2\n'PARSEL2R PARMSTR2 PARM1 PARM2'\nIF SUBSTR(PARM2,1,3) = 440 THEN\n   DO\n    'GLOBALV GETC $VAR1,$VAR3'\n    $VAR1 = 'FA IH CG HR UN'\n    $VAR3 = 'FA IH CG HR UN'\n    'GLOBALV PUTC $VAR1,$VAR3'\n   END\nIF SUBSTR(PARM2,1,3) = 441 THEN\n   DO\n    'GLOBALV GETC $VAR2,$VAR4'\n    $VAR2 = 'FA IH CG HR UN'\n    $VAR4 = 'FA IH CG HR UN'\n    'GLOBALV PUTC $VAR2,$VAR4'\n   END\nIF SUBSTR(PARM2,1,3) = C00 THEN\n   DO\n    'GLOBALV GETC $VAR5,$VAR9'\n    $VAR5 = 'FA IH CG HR UN'\n    $VAR9 = 'FA IH CG HR UN'\n    'GLOBALV PUTC $VAR5,$VAR9'\n   END\nIF SUBSTR(PARM2,1,3) = CO1 THEN\n   DO\n    'GLOBALV GETC $VAR6,$VAR10'\n    $VAR6 = 'FA IH CG HR UN'\n    $VAR10 = 'FA IH CG HR UN'\n    'GLOBALV PUTC $VAR6,$VAR10'\n   END\nIF SUBSTR(PARM2,1,3) = C08 THEN\n   DO\n    'GLOBALV GETC $VAR7,$VAR11'\n    $VAR7 = 'FA IH CG HR UN'\n    $VAR11 = 'FA IH CG HR UN'\n    'GLOBALV PUTC $VAR7,$VAR11'\n   END\nIF SUBSTR(PARM2,1,3) = C09 THEN\n   DO\n    'GLOBALV GETC $VAR8,$VAR12'\n    $VAR8 = 'FA IH CG HR UN'\n    $VAR12 = 'FA IH CG HR UN'\n    'GLOBALV PUTC $VAR8,$VAR12'\n   END\nEXIT\n\nThis is the opposite of the previous application and is called\nwhen the device is no longer being used. This REXX EXEC\nwill reset the global variables so that the display can show the\ntape device in green. The message table entries should be\nplaced in the live NetView message automation table which is\nnormally contained in the NetView DSIPARM dataset.\n\n\nERROR MESSAGES\n\nFinally, I should mention that the VIEW command provides a\nnumber of return codes that need to be trapped in case of\nerrors. My application does not utilize any of them; however,\nfor more complex applications it can be useful to use them. I\nhave presented these below. These codes can be trapped by\nusing a supplied NetView command list named SHOWCODE.\n\nCode      Meaning\n\n 4            Panel not found in CNMPNL1 or CNMMSGF datasets.\n 8            Panel format definition incorrect.\n16            VIEW invoked with invalid parameters.\n24            Full screen command processor available to OST only.\n28            Logical record length of panel not 80 bytes.\n32            Unrecoverable error resulted from macro call.\n36            Internal programming error occurred.\n81            Panel definition format invalid.\n82            Panel definition format invalid. Greater than 9600 bytes.\n83            Panel definition format invalid. Comment lines\n      incorrectly placed in panel definition.\n84            Panel definition format invalid. More than 24 lines for display.\n85            Panel definition format invalid. More than one\n      command line defined.\n\nThe SHOWCODE command list can be used to produce\nNetView messages for each of the above return codes. The list\nbelow shows the messages associated with the particular return\ncodes.\n\nCode      Message\n\n 4            CNM335I\n 8            CNM336I\n16            CNM338I\n24            CNM340I\n28            CNM341I\n32            CNM342I\n36            CNM343I\n81-85      CNM336I\n\nThis article has covered features of NetView that can be used\nto design very powerful applications and has also highlighted\nhow message automation can be used to design applications\nthat require no operator intervention.\n\n\nJohn Bradley\nSenior Technical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N007A07": {"ttr": 9220, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\xcc\\x00\\xcc\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:39", "lines": 204, "newlines": 204, "modlines": 0, "user": "SNAUPDT"}, "text": "Session control in LU6.2\n\nIn theory we should be able to forget all the pre-LU6.2\ncomplications of session control. VTAM handles all LU-LU\nsession establishment and takedown and ensures the quality and\navailability of the sessions. When an LU6.2 application\nrequests a conversation by issuing the macro:\n\n      APPCCMD CONTROL=ALLOCATE,LUNAME=partner_LU\n\nVTAM establishes a session between the application and\npartner LU and returns to the application the conversation-id\n(CONVID) of this dedicated session. The CONVID is then\nused to correlate the underlying session and allow the\nassociated application transactions to communicate.  An\napplication can allocate and use in parallel many conversations\nwith a partner LU6.2 application. Each conversation is\nassigned a unique session which means in SNA terms that\nVTAM must establish parallel sessions between the two LUs.\n\nBy means of the LOGMODE, two communicating applications\ncan agree firstly on whether they will support parallel sessions\nand, if so, how many and what to do if there is contention\nbetween them. Session limits are set for a particular mode\nname and there can be a number of mode names each of which\nhas a different set of session limits defined. Once the\napplications have established communication, session limits\ncan be re-negotiated using the Change Number Of Sessions\n(CNOS) function for which three key values are specified:\n\n1      Maximum number of sessions.\n\n2      Minimum number of sessions for which this application is\n      the contention winner.\n\n3      Minimum number of sessions for which the partner\n      application is the contention winner.\n\nSession limit manipulation is primarily intended to enable\ncontrol of the resources used by the applications.  Changing\nsession limits is a useful way of closing down an application in\na controlled manner.\n\nUsing the APPCCMD interface support, an application can\nmanipulate the underlying session limits if required via use of\nthe CNOS request. This is coded as the QUALIFY=CNOS\noption on the CONTROL=OPRCNTL form of the APPCCMD\nmacro.\n\nUsing this mechanism an application can define new session\nlimits by supplying a 7-byte area containing a mapping of the\nCNOS Session Limits Control Block with the new values. The\ncontrol block is mapped by DSECT ISTSLCNS (VTAM\nSession Limit, Change Number of Sessions) and contains\nvalues for the maximum number of sessions for the mode, the\nnumber of sessions each application is allowed to hold\nallocated in the event of contention, and who is responsible for\nthe draining of surplus sessions.\n\nThe following example is a subroutine that is triggered by an\noperator command to halve the current number of active\nsessions with the partner application LU62PART.\n\n\nSubroutine: Scheduled session change\n\nBecause of a trigger the number of sessions allowed will be\nreduced to a half of the allowed maximum for the on-line\nmode.\n\nSESSREST DS    0H\n    Entry Protocol\n* Request a display of logmode ONLINE for the application LU62PART.\n         APPCCMD CONTROL=OPRCNTL,\n               QUALIFY=DISPLAY,\n               RPL=LU62RPL,\n               ACB=LU62ACB,\n               AREA=LU62SLD,\n               AAREA=LU62RPLX,\n               AREALEN=64,\n               LUNAME=LU62PART,\n               LOGMODE=ONLINE,\n               OPTCD=SYN\n         LTR   R15,R15                 Display OK ?\n         BNZ   SESSREX4                Exit with bad RC\n         LA    R7,LU62SLD              Set addressability ...\n         USING ISTSLD,R7               ... to display block\n         LH    R2,SLDDSESL             Maximum session limit\n         SRL   R2,1                    Halve the limit\n         LH    R3,SLDSESSL             Current session limit\n         CR    R3,R2                   Already below half limit ?\n         BL    SESSREX0                Take good exit\n**********************************************************************\n* Define new session limits for the mode. As the maximum has been    *\n* halved then both the minimum local and remote contention winner    *\n* values must be similarly reduced otherwise the macro will fail with*\n* RCPRI=X'002C',RCSEC=X'0007' if the sum of these two exceeds the new*\n* overall maximum.                                                   *\n**********************************************************************\n         STH   R2,SLDDSESL             Set new maximum limit\n         LH    R3,SLDDMCWL             Halve minimum for ...\n         SRL   R3,1                    ... local contention\n         STH   R3,SLDDMCWL             Set new value\n         LH    R4,SLDDMCWP             Halve minimum for ...\n         SRL   R4,1                    ... partner contention\n         STH   R4,SLDDMCWP             Set new value\n         APPCCMD CONTROL=OPRCNTL,\n               QUALIFY=DEFINE,\n               RPL=LU62RPL,\n               ACB=LU62ACB,\n               AREA=LU62SLD,\n               AAREA=LU62RPLX,\n               AREALEN=64,\n               LUNAME=LU62PART,\n               LOGMODE=ONLINE,\n               OPTCD=SYN\n         LTR   R15,R15                 Define OK ?\n         BNZ   SESSREX8                Exit with bad RC\n**********************************************************************\n* Initiate a change in the number of sessions between the            *\n* applications for the mode ONLINE. (New limits do not come into     *\n* effect until CNOS negotiation has been initiated).                 *\n**********************************************************************\n         DROP  R7\n         LA    R7,LU62CNOS             Set addressability ...\n         USING ISTSLCNS,R7             ... to CNOS block\n         STH   R2,SLCSESSL             Set new ...\n         STH   R3,SLCMCWL              ... session ...\n         STH   R4,SLCMCWP              ... limits\n         APPCCMD CONTROL=OPRCNTL,\n               QUALIFY=CNOS,\n               RPL=LU62RPL,\n               ACB=LU62ACB,\n               AREA=LU62SLD,\n               AAREA=LU62RPLX,\n               AREALEN=7,\n               LUNAME=LU62PART,\n               LOGMODE=ONLINE,\n               OPTCD=SYN\n         LTR   R15,R15                 Define OK ?\n         BNZ   SESSREXC                Exit with bad RC\nSESSREX0 DS    0H\n         SR    R15,R15                 Set session reset OK\n         BR    R14\nSESSREX4 DS    0H\n         LA    R15,4                   Set session reset RC=4\n         BR    R14\nSESSREX8 DS    0H\n         LA    R15,8                   Set session reset RC=8\n         BR    R14\nSESSREXC DS    0H\n         LA    R15,12                  Set session reset RC=12\n         BR    R14\nLU62RPL  RPL   AM=VTAM                 Request Parameter List\nLU62RPLX ISTRPL6                       RPL Extension\nLU62SLD  DS    XL64                    Define/Display cntl block\nLU62CNOS DS    XL7                     CNOS control block\n\n\nDisplaying the number of sessions\n\nAn in-core table is maintained by VTAM which relates partner\napplication LU names to the mode names that are being used to\nestablish sessions. This table is called the LM Table. Access\ncan be gained to session information in the table via the\nOperator Control or OPRCNTL function of the APPCCMD\ninterface. Information can only be requested for a specific log\nmode for a specific partner application LU name, a general\ninquiry is not supported, for example:\n\n     APPCCMD CONTROL=OPRCNTL,QUALIFY=DISPLAY,\n           LOGMODE=log-mode-name,\n           LUNAME=partner-LU,\n           AREA=display-area\n\nAREA=display-area must point to a 64-byte area into which the\ninformation can be placed by the interface. The control block is\nmapped by DSECT ISTSLD (VTAM Session Limit, Display)\nand contains much information relating to the sessions for the\nmode including the maximum number of sessions allowed and\nwhether security access fields are to be passed in the FMH5.\n\nInitially VTAM gathers entries for the LM table from the\nVTAM application definition and LOGMODE tables. It is\npossible for an application to change some of the values set in\nthe entries by using the OPRCNTL qualifier\nQUALIFY=DEFINE.\n\nSNASVCMG is the log mode used by VTAM for\ncommunication between partner applications primarily to\nobtain information relating to session limits. If VTAM does not\nknow the session limits to be set with another application it will\nfind out by using the SNASVCMG mode to communicate.\nFortunately the activity relating to this mode is transparent to\nthe application. It must be the first mode for which session\nnegotiation is performed and if the application omits to do this\nthen VTAM will instead. There is an entry in the default\nLOGMODE table for SNASVCMG, so remember if you\nreplace the table: an entry must be included.\n\nBrian Alford\nSystems Consultant\nAranda (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N007A08": {"ttr": 9224, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:39", "lines": 26, "newlines": 26, "modlines": 0, "user": "SNAUPDT"}, "text": "6611 delays create third-party opportunities\n\nThe delivery delays on IBM's new 6611 Network Processor are\nunfortunate, but they underline the fact that IBM is exploring\nunfamiliar territory with its new device. The 6611 is important,\nin that it puts IBM's seal of approval on the multi-protocol\nrouter market, currently dominated by companies like Cisco\nand Wellfleet. Once it starts shipping, the IBM device is likely\nto establish a new standard, both for multi-port source route\nbridging between Token Rings and for routing across open\nnetworks.\n\nThe 6611 incorporates a number of new technologies,\nincluding the Data Link Switching technique for encapsulating\nunroutable SNA and NETBIOS traffic. Presumably\nperformance is not yet up to a marketable standard, and IBM is\nwise to delay shipment until the Network Processor is ready.\n\nEarly test sites have found that the 6611 offers superior\nhandling of SNA and Token Ring traffic. The only concern\nfrom IBM's point of view will be that Cisco and Crosscom are\ncatching up fast in this area: a long delay on the 6611 may\nreduce IBM's share of a very significant market.\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N008A00I": {"ttr": 9226, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:39", "lines": 12, "newlines": 12, "modlines": 0, "user": "SNAUPDT"}, "text": "N008 - SNA Update issue 8 December 1992\nIndex to files contained in archive\n\nFilename  Article title\n--------  -------------\nN00801   VTAM buffer pools\nN00802   Network performance monitors - a survey\nN00803   Retrieving the VTAM NETID\nN00804   APPN update\nN00805   3174 status/usage displays in NetView\nN00806   An Assembler routine to print the Net/Stat log\nN00807   Analysing LUDRPOOL and PUDRPOOL usage\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N008A01": {"ttr": 9228, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x01E\\x01E\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:39", "lines": 325, "newlines": 325, "modlines": 0, "user": "SNAUPDT"}, "text": "VTAM buffer pools\n\nI was given the task of reviewing the VTAM buffers at our site\nand tuning them, if required. Before I could perform any part\nof the tuning I needed to gather statistics on how they were\nworking over a period of time. As we do not have any software\nto provide this information, I had two options:\n\n1      Issue the VTAM command 'D NET,BFRUSE' and read\n      the information from the log.\n2      Run a program that will extract the data and write it to a file.\n\nI chose the second option and thus the following program was\ncreated. As it is, this program should be run from a batch job\nthat will either write the output to the batch SYSOUT file or to\na dataset. It would be possible for this program to have a\nstarted task wrapped around it and monitor the pools\nautomatically.\n\n**********************************************************************\n*  NAME        -   BUFFPOOL                                          *\n*  FUNCTION    -   THIS PROGRAM WILL DISPLAY THE VTAM BUFFER POOLS.  *\n*                  THE ADDRESS MODE MUST BE 31 AS THE POOLS ARE      *\n*                  STORED ABOVE THE LINE.                            *\n*                  THIS PROGRAM MUST RUN AUTHORIZED.                 *\n*                  THE LABEL POOLIDS INSTRUCTS THIS PROGRAM WHICH    *\n*                  VTAM BUFFER POOLS SHOULD BE REPORTED ON.          *\n*                  THE EXAMPLE SHOWN BELOW WILL MONITOR THE IO00,    *\n*                  LP00, WP00, LF00, CRPL, SF00, AND AP00.           *\n*  EXAMPLE:                                                          *\n*   POOLIDS  DC    C'IO00LP00WP00LF00CRPLSF00SP00AP00FFFF'           *\n*   NOTE: THE LAST ID IN THE FIELD MUST BE 'FFFF'                    *\n**********************************************************************\n*  THIS MODULE MUST BE LINKED AUTHORIZED.   EG. SETCODE AC(1)        *\n*  IT MUST ALSO RESIDE IN AN AUTHORIZED LIBRARY                      *\n*  THIS IS REQUIRED SO THAT SUPERVISOR STATE CAN BE SET.             *\n**********************************************************************\n*  TESTED ON   -   MVS/XA V2.2.1                                     *\n*                  VTAM   V3.3                                       *\n**********************************************************************\n*  THE FOLLOWING JCL IS REQUIRED TO RUN BUFFPOOL.                    *\n*      STEP1    EXEC PGM=BUFFPOOL                                    *\n*      STEPLIB  DD DSN=MY.AUTH.LIBRARY,DISP=SHR                      *\n*      SYSABEND DD SYSOUT=*                                          *\n*      SYSPRINT DD SYSOUT=*                                          *\n*      SYSOUT   DD SYSOUT=*                                          *\n*  OR                                                                *\n*      SYSOUT   DD DSN=STORE.THE.DATA,DISP=MOD                       *\n**********************************************************************\nBUFFPOOL CSECT\nBUFFPOOL AMODE 31\nBUFFPOOL RMODE ANY\n         STM   R14,R12,12(R13)    SAVE CALLER'S REGISTERS\n         LR    R12,R15            INITIALIZE BASE REGISTER\n         USING BUFFPOOL,R12       ESTABLISH ADDRESSABILITY\n         LA    R14,SAVEAREA       MY SAVE AREA\n         ST    R14,8(R13)         LINK TO CALLER'S\n         ST    R13,SAVEAREA+4     LINK TO MINE\n         LA    R13,SAVEAREA       POINT R13 TO MY SAVEAREA\n         OPEN  (SYSOUT,(OUTPUT))  OPEN SYSOUT DATASET\n******************************\n*  ESTABLISH ADDRESSABILITY  *\n******************************\n         L     R3,CVTPTR          LOAD CVT ADDRESS\n         USING CVTMAP,R3          ADDRESSABILITY TO CVT\n         L     R4,CVTEXT2         LOAD EXTENDED STORAGE ADDRESS\n         USING CVTXTNT2,R4        ADDRESSABILITY TO CVT EXTENDED STORAG\n         L     R5,CVTATCVT        POINTER TO ATCVT\n         L     R5,0(R5)           LOAD POINTER TO THE BPDTY\n         MODESET KEY=ZERO,MODE=SUP CHANGE TO SUPERVISOR STATE\n         L     R5,980(R5)         POINTER TO BUFFER POOL DIRECTORY\n************************************************************\n*  EXTRACT INFORMATION FROM BUFFER POOL DIRECTORY - BPDTY  *\n************************************************************\n         LH    R6,0(R5)           LOAD NUMBER OF ENTRIES\n         ST    R6,NUMENTS         STORE NUMBER OF ENTRIES\n         LA    R5,368(R5)         POINTER TO BUFFER POOL ENTRIES BPENT\n********************************************************\n*  EXTRACT INFORMATION FROM BUFFER POOL ENTRY - BPENT  *\n********************************************************\n         LA    R7,POOL            LOAD ADDRESS OF POOL ARRAY\nA0000    MVC   0(12,R7),0(R5)     STORE POOL ID, FORMAT AND BUFFER SIZE\n         LA    R5,16(R5)          INCREMENT TO NEXT BUFFER POOL\n         LA    R7,44(R7)          MOVE POINTER ALONG ARRAY\n         BCT   R6,A0000           SUBTRACT ONE AND BRANCH\n***************************************************************\n*  EXTRACT INFORMATION FROM BUFFER POOL CONTROL BLOCK - BPCB  *\n***************************************************************\n         LA    R7,POOL            LOAD ADDRESS OF POOL ARRAY\n         USING POOLDEF,R7         ESTABLISH ADDRESSABILITY\n         L     R6,NUMENTS         LOAD NUMBER OF ENTRIES\nB0000    DS    0H\n         L     R8,BPCBADDR        LOAD BPCP ADDRESS\n         MVC   CURRTOT,36(R8)     STORE CURRENT TOTAL\n         MVC   MAXUSED,56(R8)     STORE MAXIMUM USED\n         MVC   CURRVL,88(R8)      STORE CURRENT AVAILABLE\n         MVC   CONTHR,148(R8)     STORE CONTRACTION THRESHOLD\n         MVC   EXPTME,152(R8)     STORE TIMES EXPANDED\n         MVC   EXPTHR,156(R8)     STORE EXPANSION THRESHOLD\n         MVC   MAXTOT,160(R8)     STORE MAXIMUM TOTAL\n         MVC   EXPINC,166(R8)     STORE EXPANSION INCREMENT\n         LA    R7,44(R7)          MOVE POINTER ALONG ARRAY\n         BCT   R6,B0000           SUBTRACT ONE AND BRANCH\n*************************\n*  RESET AUTHORIZATION  *\n*************************\nC0000    DS    0H\n         MODESET KEY=NZERO,MODE=PROB CHANGE BACK TO NORMAL STATE\n         LA    R1,C0010           LOAD BRANCH ADDRESS\n         BSM   0,R1               REVERT TO 24-BIT ADDRESSING\n****************************************\n*  SKIP THRU ARRAY AND PRINT OUT DATA  *\n****************************************\nC0010    DS    0H\n         PUT   SYSOUT,TITLE1      WRITE OUT TITLE\n         PUT   SYSOUT,BLANKLNE    SKIP A LINE\n         LA    R7,POOL            POINT TO POOL ARRAY - RESET\n         USING POOLDEF,R7         ESTABLISH ADDRESSABILITY\n         L     R8,NUMENTS         RETRIEVE NUMBER OF BUFFER ENTRIES\nD0000    LA    R10,POOLIDS        MOVE IN POOL IDENTIFIER\nE0000    CLC   0(4,R10),POOLID    LOOK FOR A MATCH\n         BE    F0000              BRANCH IF MATCHED\n         CLC   0(4,R10),=C'FFFF'  END OF TABLE\n         BE    K0000              BRANCH IF MATCHED\n         A     R10,=F'4'          INDEX TO NEXT ID\n         B     E0000              TRY AGAIN\nF0000    MVC   OUT1(4),POOLID     MOVE IN BUFFER POOL NAME\n***********************\n*  SETUP BUFFER SIZE  *\n***********************\n         SR    R9,R9              CLEAR REGISTER 9\n         ICM   R9,B'0011',BUFFSIZE  MOVE IN BUFFER SIZE\n         CVD   R9,WORKCVD         CONVERT TO DECIMAL\n         UNPK  NUM5,WORKCVD       UNPACK\n         OI    NUM5+L'NUM5-1,X'F0' MAKE IT PRINTABLE\n         MVC   OUT2,NUM5          MOVE TO SYSOUT\n*******************************\n*  SETUP EXPANSION THRESHOLD  *\n*******************************\n         SR    R9,R9              CLEAR REGISTER 9\n         ICM   R9,B'0011',EXPTHR  MOVE IN THRESHOLD SIZE\n         CVD   R9,WORKCVD         CONVERT TO DECIMAL\n         CH    R9,=X'7FFF'        DOES POOL HAVE EXPANSION ?\n         BNE   G0000              YES, CONTINUE\n         MVC   NUM5,=C'*N/A*'     NO, SET OUTPUT\n         B     H0000              BRANCH AROUND WORK\nG0000    UNPK  NUM5,WORKCVD       UNPACK\n         OI    NUM5+L'NUM5-1,X'F0' MAKE IT PRINTABLE\nH0000    MVC   OUT3,NUM5          MOVE TO SYSOUT\n********************************\n*  SETUP EXPANSION INCREMENTS  *\n********************************\n         SR    R9,R9              CLEAR REGISTER 9\n         ICM   R9,B'0011',EXPINC  MOVE IN EXPANSION INCREMENTS\n         CVD   R9,WORKCVD         CONVERT TO DECIMAL\n         UNPK  NUM5,WORKCVD       UNPACK\n         OI    NUM5+L'NUM5-1,X'F0' MAKE IT PRINTABLE\n         MVC   OUT4,NUM5          MOVE TO SYSOUT\n********************\n*  SETUP MAX USED  *\n********************\n         SR    R9,R9              CLEAR REGISTER 9\n         ICM   R9,B'1111',MAXUSED MOVE IN MAX USED\n         CVD   R9,WORKCVD         CONVERT TO DECIMAL\n         UNPK  NUM8,WORKCVD       UNPACK\n         OI    NUM8+L'NUM8-1,X'F0' MAKE IT PRINTABLE\n         MVC   OUT5,NUM8          MOVE TO SYSOUT\n**************************\n*  SETUP TIMES EXPANDED  *\n**************************\n         SR    R9,R9              CLEAR REGISTER 9\n         ICM   R9,B'1111',EXPTME  MOVE IN TIMES EXPANDED\n         CVD   R9,WORKCVD         CONVERT TO DECIMAL\n         UNPK  NUM8,WORKCVD       UNPACK\n         OI    NUM8+L'NUM8-1,X'F0' MAKE IT PRINTABLE\n         MVC   OUT6,NUM8          MOVE TO SYSOUT\n*********************\n*  SETUP MAX TOTAL  *\n*********************\n         SR    R9,R9              CLEAR REGISTER 9\n         ICM   R9,B'1111',MAXTOT  MOVE IN MAX TOTAL\n         CVD   R9,WORKCVD         CONVERT TO DECIMAL\n         UNPK  NUM8,WORKCVD       UNPACK\n         OI    NUM8+L'NUM8-1,X'F0' MAKE IT PRINTABLE\n         MVC   OUT7,NUM8          MOVE TO SYSOUT\n*************************\n*  SETUP CURRENT TOTAL  *\n*************************\n         SR    R9,R9              CLEAR REGISTER 9\n         ICM   R9,B'1111',CURRTOT MOVE IN CURRENT TOTAL\n         CVD   R9,WORKCVD         CONVERT TO DECIMAL\n         UNPK  NUM8,WORKCVD       UNPACK\n         OI    NUM8+L'NUM8-1,X'F0' MAKE IT PRINTABLE\n         MVC   OUT8,NUM8          MOVE TO SYSOUT\n*********************************\n*  SETUP CONTRACTION THRESHOLD  *\n*********************************\n         SR    R9,R9              CLEAR REGISTER 9\n         ICM   R9,B'0011',CONTHR  MOVE IN CONTRACTION THRESHOLD\n         CVD   R9,WORKCVD         CONVERT TO DECIMAL\n         CH    R9,=X'7FFF'        DOES POOL HAVE EXPANSION ?\n         BNE   I0000              YES, CONTINUE\n         MVC   NUM5,=C'*N/A*'     NO, SET OUTPUT\n         B     J0000              BRANCH AROUND WORK\nI0000    UNPK  NUM5,WORKCVD       UNPACK\n         OI    NUM5+L'NUM5-1,X'F0' MAKE IT PRINTABLE\nJ0000    MVC   OUT9,NUM5          MOVE TO SYSOUT\n*****************************\n*  SETUP CURRENT AVAILABLE  *\n*****************************\n         SR    R9,R9              CLEAR REGISTER 9\n         ICM   R9,B'1111',CURRVL\n         CVD   R9,WORKCVD         CONVERT TO DECIMAL\n         UNPK  NUM8,WORKCVD       UNPACK\n         OI    NUM8+L'NUM8-1,X'F0' MAKE IT PRINTABLE\n         MVC   OUT10,NUM8         MOVE TO SYSOUT\n************************\n*  PRINT ALL THE DATA  *\n************************\n         PUT   SYSOUT,LINE1       WRITE OUT BUFFER INFORMATION\n         PUT   SYSOUT,LINE2       WRITE OUT BUFFER INFORMATION\n         PUT   SYSOUT,LINE3       WRITE OUT BUFFER INFORMATION\n         PUT   SYSOUT,LINE4       WRITE OUT BUFFER INFORMATION\n         PUT   SYSOUT,LINE5       WRITE OUT BUFFER INFORMATION\n***********************************************\n*  BRANCH BACK AND GET THE NEXT POOL DETAILS  *\n***********************************************\nK0000    LA    R7,44(R7)          MOVE POINTER ALONG ARRAY\n         BCT   R8,D0000           SUBTRACT ONE AND BRANCH\n         CLOSE SYSOUT\n*********\n*  END  *\n*********\nEXIT     DS    0H                 RETURN\n         L     R13,SAVEAREA+4     POINT TO CALLER'S SAVEAREA\n         SR    R15,15             SET RETURN CODE TO 0\n         LM    R14,R12,12(R13)    RELOAD CALLER'S REGISTERS\n         BR    R14                RETURN TO CALLER\n*************************\n*  STORAGE DEFINITIONS  *\n*************************\nSAVEAREA DS    18F                USER SAVE AREA\nNUMENTS  DS    CL4                NUMBER OF ENTRIES\nWORKCVD  DS    D                  DOUBLE WORD WORK AREA\nNUM5     DC    CL5'00000'         NUMBER\nNUM8     DC    CL8'00000000'      NUMBER\nSYSOUT   DCB   DDNAME=SYSOUT,DSORG=PS,MACRF=(PM),LRECL=80,             X\n               BLKSIZE=80,RECFM=FB\nPOOLIDS  DC    C'IO00LP00WP00LF00CRPLSF00SP00AP00FFFF'\n         LTORG\n*******************\n*  REPORT FORMAT  *\n*******************\nTITLE1   DS    0CL80              SYSOUT FORMAT\n         DC    C'                            VTAM BUFFER POOL'\n         DC    CL35' '\nBLANKLNE DC    CL80' '\nLINE1    DS    0CL80\nOUT1     DC    CL5' '             POOL ID\n         DC    CL10' '\n         DC    C'BUFF SIZE  '\nOUT2     DC    CL5' '             BUFFER SIZE\n         DC    C'     EXP INCREMENT   '\nOUT4     DC    CL5' '             EXPANSION INCREMENT\n         DC    CL21' '\nLINE2    DS    0CL80\n         DC    CL15' '\n         DC    C'TIMES EXP  '\nOUT6     DC    CL10' '            TIMES EXPANDED\n         DC    C'EXP/CONT THRESH '\nOUT3     DC    CL5' '             EXPANSION THRESHOLD\n         DC    C'/'\nOUT9     DC    CL5' '             CONTRACTION THRESHOLD\n         DC    CL16' '\nLINE3    DS    0CL80\n         DC    CL15' '\n         DC    C'CURR TOTAL '\nOUT8     DC    CL10' '            CURRENT TOTAL\n         DC    C'CURR AVAILABLE  '\nOUT10    DC    CL10' '            CURRENT AVAILABLE\n         DC    CL16' '\nLINE4    DS    0CL80\n         DC    CL15' '\n         DC    C'MAX TOTAL  '\nOUT7     DC    CL10' '            MAX TOTAL\n         DC    C'MAX USED        '\nOUT5     DC    CL10' '            MAX USED\n         DC    CL18' '\nLINE5    DC    70C'-'\n         DC    10C' '\n**********************************\n*  BUFFER POOL ARRAY  (12 X 44)  *\n**********************************\nPOOL     DS    12CL44\nPOOLDEF  DSECT\n********************************\n*   BUFFER POOL ENTRY (BPENT)  *\n********************************\nPOOLID   DS    F                  I/O BUFFER\nFORMAT   DS    H                  POOL FORMAT\nBUFFSIZE DS    H                  BUFFER SIZE\nBPCBADDR DS    F                  ADDRESS OF BPCB\n****************************************\n*   BUFFER POOL CONTROL BLOCK  (BPCB)  *\n****************************************\nCURRTOT  DS    F                  CURRENT TOTAL\nMAXUSED  DS    F                  MAX USED\nCURRVL   DS    F                  CURRENT AVAILABLE\nCONTHR   DS    F                  CONTRACTION THRESHOLD\nEXPTME   DS    F                  TIMES EXPANDED\nEXPTHR   DS    F                  EXPANSION THRESHOLD\nMAXTOT   DS    F                  MAX TOTAL\nEXPINC   DS    F                  EXPANSION INCREMENTS\n*\n         CSECT\n         DC    C'END BUFFER POOL' EYE CATCH\n         CVT   DSECT=YES          COMMUNICATIONS VECTOR TABLE\n         $REGS\n         END\n\n\nCraig Brown\nSystems Programmer\nAustralian Paper Manufacturers (Australia)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N008A02": {"ttr": 9476, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x01\\xd2\\x01\\xd2\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:39", "lines": 466, "newlines": 466, "modlines": 0, "user": "SNAUPDT"}, "text": "Network performance monitors - a survey\n\nThe following article is taken from the findings of Xephon's\nIBEX research programme, a series of regular surveys covering\nall aspects of the computer industry directly related to IBM and\nIBM-compatible mainframe installations throughout the world.\n\nWe asked those taking part in the survey if they \"have a\nVTAM or network performance monitor (eg NetSpy, NetView\nPM, Omegamon for VTAM etc)\". 30% of the 910 sites that\nresponded to this part of the questionnaire have one or more\nnetwork monitors - a significant increase on the 23% of sites\nthat had network performance monitors in a similar survey we\nconducted last year. Figure 1 shows the distribution of\npackages reported by five or more members at sites classified\nby principal operating system. The most widespread network\nmonitor in the sample is IBM's NetView Performance Monitor,\nwhich was previously known as Network Performance\nMonitor, or NPM, and is a replacement for IBM's NPA\n(Network Performance Analyser). NetView PM is installed at\n15% of sites and accounts for 47% of licences. Legent's\nNetSpy is the second most widely installed package in the\nsurvey, being reported by 10% of sites in the sample, and\naccounts for 32% of licences. Other packages installed at five\nor more sites are: Candle's Omegamon II for VTAM, which  is\ninstalled at 3% of sites and accounts for 9% of licences;\nBlueLine Software's Vital Signs for VTAM, which is installed\nat 2% of sites and accounts for 6% of licences; and Landmark\nSystems' The Monitor for VTAM, which is installed at a little\nunder 1% of sites and accounts for 3% of licences.\n\nFigure 2 shows the percentage of sites (broken down by\nprincipal operating system, industry, and region) that have\nnetwork performance monitors installed. Network monitors are\ninstalled at almost 50% of MVS/ESA sites (regardless of which\nversion they have), at around 40% of MVS/XA sites, but at\nonly 8% of all other sites. The breakdown by industry sector\nshows these packages are less popular at manufacturing, health\ncare, and educational sites than at other sites, while the\nbreakdown by region shows little significant difference in the\nuptake of this technology at sites in different locations.\n\nIn addition to the 272 sites in our sample with network\nperformance monitors, 106 sites (12% of those in the survey)\nare thinking of acquiring such packages in the coming year,\nwhile 27 sites (10% of those with packages) are thinking of\nreplacing their current package. Figure 3 shows how these\nplanned installations and replacements would affect the user\nbases of packages in our sample. 73 of the 133 sites acquiring\npackages in the next twelve months have as yet not chosen a\npackage - for this reason, Figure 3 shows the effect of\nassigning these 'undecided' licences to packages pro-rata to the\nprospective customers that have already chosen each.\n\nNetSpy looks set to gain most in the coming year - 19\nmembers are thinking of installing it and only three are\nthinking of replacing it, which would result in an extra 16\nlicences. Significantly, 11 members are thinking of acquiring\nNetSpy as a replacement for NetView PM. By assigning\nNetSpy its share of the 'undecided' licences (as explained\nabove), we estimate that NetSpy may attract another 23\nlicences (among our sample sites), resulting in a net gain of 39\nlicences in the coming year.\n\nOmegamon II for VTAM has been chosen by seven members\nacquiring network monitors in the coming year (including three\nwho are replacing NetView PM), while one member is thinking\nof replacing it. This would result in a net gain of six licences at\nsites in the sample. Omegamon's share of the 'undecided'\nlicences would yield another eight licences, resulting in an\noverall net gain of fourteen.\n\nFour members are considering installing Vital Signs for VTAM\n(two of them as replacements for NetView PM), while one\nmember is considering replacing it - a net gain of three\nlicences. Vital Signs' share of the 'undecided' licences would\nyield five extra licences, giving it an overall net gain of eight.\n\nThree members are considering installing The Monitor for\nVTAM (one of them as a replacement for NetView PM), and\none member is considering replacing it - a net gain of two\nlicences. The Monitor's share of the 'undecided' licences is\nfive, resulting in an overall net gain of six.\n\nNo fewer than 23 sites, none of which currently has a network\nperformance monitor, are considering installing NetView PM.\nHowever, 21 members who currently use NetView PM are\nconsidering replacing it - a net gain of only two licences.\nNevertheless, we estimate that NetView may attract another 28\nlicences from members currently undecided about which\npackage to acquire, which would yield an overall net gain of\naround thirty licences.\n\n\nMarket shares\n\nWe asked members in which year they installed their network\nperformance monitors. Figure 4 shows the installed bases of\nthe leading packages at sample sites each year since 1986 based\non these responses, while Figure 5 shows the corresponding\nmarket shares. Both charts exclude packages for which we\nwere not given an acquisition date, and hence somewhat\nunderestimate the installed bases of packages. Readers should\nalso note that the number of 'Future' licences in Figures 4 and\n5 is calculated by adding all sites planning to acquire a package\nin the next year and subtracting the number planning to replace\nit. Prospective customers who have yet to choose a package are\nshown as 'unspecified', and are not allocated to other packages\nas in Figure 3.\n\nThe market for network performance monitors appears to have\nbeen growing exponentially up to 1990, at which time it\nslowed down considerably, no doubt as a result of the slow-\ndown in the mainframe market as a whole. Nevertheless, the\nmarket for these packages appears to have grown by around\n16% last year, and there is considerable interest in acquiring\nthese packages in the coming year.\n\nNetView PM and NetSpy both benefited from the strength of\nthe market for network monitors prior to 1990, by which time\nboth packages had established over half their current user-\nbases. Since 1989, NetSpy has been steadily gaining market\nshare at the expense of NetView PM, and looks set to overtake\nthe latter in the next few years. Omegamon has chalked up\nsteady sales in the last few years - its market share has grown\nfor the last two years, and looks set to grow again in the\ncoming year.\n\n\nCompetitive evaluations\n\nWe asked members if they had conducted an evaluation\ninvolving two or more packages before acquiring their current\none. Figure 6 shows the percentage of currently installed\npackages that were involved in such evaluations (the chart only\nexplicitly lists packages for which ten or more members\nreported whether an evaluation had taken place).\n\nAlmost three-quarters of NetSpy's users conducted an\nevaluation before selecting it, while, at the other extreme, only\n17% of NetView PM's licences resulted from evaluations.\nNetSpy is also very successful in evaluations, winning eleven\nout of every twelve - see Figure 7. NetView PM, by contrast,\nhas a somewhat poor record in evaluations. Figure 8 shows the\nresults of all 124 evaluations reported by members. Overall,\nthe percentage of network performance monitors that were\nselected after evaluations has increased from 30% in our\nOctober 1990 survey, and 38% in the October 1991 survey, to\n41% in this survey.\n\n\nUser ratings\n\nWe asked members to rate their network performance monitors\non a scale from one ('poor') to five ('excellent') using the\nfollowing twelve criteria:\n\no      Range of measurements\no      Historical data collection\no      Batch reporting\no      Threshold warnings\no      Problem/bottleneck analysis\no      Reporting of statistics\no      Session manager interface\no      Performance overhead\no      Reliability\no      Ease of use\no      Vendor support\no      Value for money.\n\nIn addition, members were asked to assess how accurately and\ncompletely their network performance monitors measured the\nfollowing aspects of VTAM/network performance - again\nusing a scale from one ('poor') to five ('excellent'):\n\no      End-user response times\no      Host response times\no      Network response times\no      Line utilization\no      Buffer statistics\no      Channel I/O\no      Error rates\no      NCP cycle utilization\no      Virtual routes\no      Storage analysis.\n\nFigure 9 shows the average ratings awarded by members to\ntheir network performance monitors and Figure 10 shows the\nratings for the degree of accuracy and completeness with which\npackages monitor various aspects of network performance.\nFigures 9 and 10 are arranged with the package with the\nhighest aggregate score at the top. The sample sizes for the\nratings charts are as follows: 86 members rated NetSpy, 124\nrated NetView PM, 20 rated Omegamon for VTAM, eight\nrated The Monitor for VTAM, and 14 rated Vital Signs for VTAM.\n\nOn average, members awarded higher ratings for reliability\nthan for other criteria - 'all packages' were rated nearer 'good'\n(4) than 'satisfactory' (3) in this category. Packages also\nscored, on average, very well for the range of measurements\nthey collect and for their vendor support, again scoring nearer\n'good' than 'satisfactory' for both criteria. The average ratings\nfor threshold warnings and performance overhead are only\nmarginally nearer 'satisfactory' than 'good', as are, to a lesser\nextent, those for value for money and historical data collection.\nThe only criterion for which all packages were, on average,\nrated less than 'satisfactory' is batch reporting.\n\nThe aspect of network performance that packages were\nreckoned, on average, to have monitored most accurately and\ncompletely is line utilization. Network response times, host\nresponse times, error rates, and end-user response times were\nalso considered, on average, to be monitored well - all\npackages were, on average, awarded ratings nearer 'good' than\n'satisfactory' for each of the above criteria. Packages were\nawarded average ratings of 'satisfactory' or better for\nmonitoring NCP cycle utilization, buffer statistics, virtual\nroutes, and channel I/O activity, and ratings somewhat below\n'satisfactory' for storage analysis.\n\nFigure 11 shows the average ratings awarded to packages\nplotted consecutively on a single axis. Note that we've\nincluded the average each package scored for the degree of\naccuracy and completeness with which it monitors all the\nchosen aspects of network performance as a single rating in\nFigure 11 under the heading 'quality of measurements'.\n\nThe Monitor for VTAM achieves the highest overall ratings,\ncoming first for no fewer than nine of the twelve criteria (range\nof measurements, threshold warnings, problem/bottleneck\nanalysis, reporting of statistics, session manager interface,\nreliability, ease of use, vendor support, and value for money)\nand also achieves the highest average ratings for its overall\nmeasurement of network performance. The Monitor comes\nsecond for historical data collection and performance overhead,\nand third for batch reporting. It is awarded average ratings of\n'good' or better for nine criteria, average ratings nearer 'good'\nthan 'satisfactory' for another two criteria (historical data\ncollection and session manager interface), and only scores\nbelow 'satisfactory' for one criterion (batch reporting - the\nonly criterion for which it scores below average). However, it\nshould be stressed that these ratings are based on only eight\nresponses.\n\nNetSpy comes second overall, having come first for its batch\nreporting (only NetSpy and Omegamon have average ratings of\n'satisfactory' or better for batch reporting), second for three\ncriteria (range of measurements, session manager interface, and\nreliability) and third for all the remaining criteria. NetSpy is the\nonly package to score above average for all twelve criteria, and\nalso has an above average rating for its overall measurement of\nnetwork performance. NetSpy's average rating for reliability is\nslightly better than 'good', and for all the remaining criteria it\nscores average ratings between 'satisfactory' and 'good'.\n\nVital Signs for VTAM is the third best rated package overall,\ncoming first for historical data collection and performance\noverhead, and second for another four criteria (reporting of\nstatistics, ease of use, vendor support, and value for money).\nVital Signs also comes second for its overall measurement of\nnetwork performance, and scores above average for all but\nthree of our criteria (batch reporting, threshold warnings, and\nsession manager interface).\n\nOmegamon for VTAM comes fourth overall; its best ratings are\nfor batch reporting, threshold warnings, and\nproblem/bottleneck analysis - coming second for each.\nNetView Performance Monitor fares rather badly in the ratings,\ncoming last for ten of the twelve criteria and second from last\nfor the remaining two. The package is rated below average for\nall criteria.\n\n\nBest and worst features\n\nWe asked members what they consider the best and worst\nfeatures of their packages. In this section we summarize the\ncomments members made. Note that some of the comments\nquoted below are paraphrased versions of what members wrote.\n\nWe received 63 comments from members expressing their\nopinion of NetSpy's best feature, and 52 from members\nexpressing their opinion of the package's worst feature.\nNineteen members considered NetSpy easy to use, another\nthree found the package easy to install, one found it easy to\ncustomize, and one found it easy to implement. A number of\nmembers listed one or more of the measurements taken by\nNetSpy as its best feature - they include four who singled out\nline utilization, two who singled out end-to-end response time,\nthree who singled out end-user response time, one who singled\nout network response time, and one who singled out buffer\nusage. Three members liked the on-line reports and three liked\nthe on-line alerts and threshold warnings. Three members\nfound NetSpy's performance overhead frugal, three found the\npackage flexible, two found it reliable, and two liked the way\nthe package reports statistics. Other comments about NetSpy\ninclude: \"ability to interact with TPX\", \"speed of information\",\n\"easy to equate real terminal name to logical terminal\", \"feeds\nMICS database, handles virtual/real terminal mapping\", \"hot-\nkey set-up\", \"output records are simple in format and the SAS\nrecord definitions make it easy to port records to SAS\", \"trace\nfacilities\", and \"once installed, it works immediately\". One\nuser simply thought there were \"so many \u00ddgood features\u00a8 to\nchoose from\"!\n\nNetSpy's user interface elicited critical comments from seven\nmembers, including one who was critical of the \"cumbersome\nand confusing panels\", one who complained that the \"panels\ndon't retain values, which have to be re-entered\", and another\nwho found the \"presentation and user interface a little creaky\nand old-fashioned\". Seven members found using NetSpy\nincurred too great a performance overhead, including two who\nthought the package used too many CPU cycles, two who\ncomplained of excessive use of DASD storage, and one who\nthought the package used too much memory. Five members\nwere critical of NetSpy's batch reporting (one of them thought\nthe batch reporting \"esoteric\", one criticized the \"inability to\nexclude things from the batch reporting utility\", and another\n\"especially\" disliked the batch reporting of historical data).\nAnother two members were critical of the reporting facilities as\na whole while a third member bemoaned the lack of on-line\ngraphics. Five members found NetSpy difficult to use, three\nthought the package needed a better on-line help facility, and\none disliked the documentation supplied with the package. A\nnumber of the critical comments we received concerned aspects\nof NetSpy's performance monitoring - they include: \"cannot\nmonitor individual applications within a CICS region\",\n\"definite response time measurement adversely affects Unisys\n\u00dd!\u00a8 clusters in the network\", \"does not provide breakdown of\nnetwork performance from host out\", \"as yet doesn't give exact\nresponse time at the end-user level\", \"inability to capture user,\nhost, and network response times simultaneously\", \"lack of\nchannel information\", \"no LAN monitoring\", \"\u00ddpoor\u00a8\nmonitoring of cross-domain applications\", and \"no response\ntimes in X.25\". Other critical comments about NetSpy include:\n\"\u00ddhave suffered\u00a8 a couple of failures over two years\", \"\u00ddpoor\u00a8\ninterfaces with NetView AS\", \"poor history of tuning\nstatistics\", \"SMF data for sessions running under session\nmanager are included in session manager statistics\", \"inflexible\nreal-time control\", \"\u00ddpoor\u00a8 threshold warnings\", \"too many\nparameters to worry about\", \"\u00ddpoor\u00a8 tuning and\nrecommendations\", \"\u00ddpoor\u00a8 vendor support\", and \"\u00ddit needs\u00a8\nmore diagnostic capabilities\".\n\n67 of the comments we received about NetView PM concerned\nits best feature and 69 concerned its worst feature. Eight\nmembers liked NetView PM's interface with the base package,\nNetView (two of them emphasized how this aids in automating\nthe network - another two members simply thought NetView's\nbest feature was its network automation). Two members liked\nNetView PM's interface to VTAM, one member liked the\ninterface with NCP/NPSI, and one member liked the interface\nwith \"other IBM communications programs\". The way\nNetView PM's monitors various aspects of network\nperformance was praised by a number of members, including\nits measurement of line utilization (listed by four members, one\nof whom noted how the package monitors \"terminal by\nterminal statistics on a line\"), end-to-end response time (two\nmembers), end-user response time (two members), and NCP\ncycle utilization (one member). Two members liked the way\nthe package provides session statistics, three were impressed\nwith the problem and bottleneck analysis, two liked the\nthreshold warnings provided (one singled out \"NetView's\ngeneric ALERT function\"), two praised the range of\nmeasurements taken by NetView, one liked the \"ability to get\ninto LANs\", and one liked the \"Token Ring information\".\nNetView's performance overhead was considered frugal by\nthree members, one of whom cited the package's low\nconsumption of CPU cycles. Three members found NetView\nreliable, two liked the vendor support, two liked the user\ninterface, two liked the package's graphics, two liked the on-\nline statistics, and one thought the package secure. Other\ncomments in praise of NetView include: \"ability to control\nclusters\", \"ease and speed of switching applications\", \"easy to\nobtain\", \"flexible\", \"network review data\", \"\u00ddthe package\u00a8\noutputs to SLR for consolidated reports\", \"remote testing and\nconfiguration facilities\", \"stability\", and \"up to date with IBM\ntechnology\".\n\nFourteen members found NetView PM \"difficult to use\",\nincluding one who wrote that the package \"requires a highly\ntechnical individual to use\"; another four members disliked the\nuser interface, and one member found the package's\npresentation poor. Nine members complained of the lack of\nadequate batch reporting, eight members found the package's\nperformance overhead excessive (one singled out the VTAM\nperformance, another the large memory requirement), four\nmembers found the package \"too difficult to customize\" or\nimplement, two members complained of the lack of \"tags\" or\ninterfaces to third-party packages, and two members\ncomplained that \"adding an application often doesn't work\neasily\". Two members questioned NetView PM's reliability\n(one described it as \"bug-ridden\", the other noted its ability to\n\"bring down VTAM\"), one member complained of the\ndocumentation, one complained of \"unannounced and\nundocumented record format changes\", and five members\nfound the package lacked the facilities to monitor response\ntimes adequately (one singled out end-to-end response times,\ntwo singled out end-user response times, and the others weren't\nspecific). Two members found the package lacked LAN\nmonitoring (one of them singled out the monitoring of Token\nRing LANs - contradicting another member's opinion of the\npackage's best feature), two members found the facilities for\ndata gathering \"too complex\", and two members found\nNetView PM lacked facilities to monitor X.25 networks. Other\ncritical comments about NetView Performance Monitor\ninclude: \"insufficient detail in diagnostic capability\", \"limited\nanalysis\", \"low functionality\", \"no user reporting\", \"runs in\nCICS regions\", and \"screen design\".\n\nEleven members wrote about Omegamon's best feature and\nnine wrote about its worst feature. Three members found the\npackage easy to use, two liked its warning messages, one liked\nits \"interface with Candle's status monitor\", one liked the\ninterface with NetView, one member noted the package's\nexcellent \"monitoring of TNSTATS, buffer pool, and control\nblock queues\", another was pleased with the way it handled\n\"response time problem determination\", and two members\nfound the package \"flexible\". Other comments praising\nOmegamon are: \"\u00ddit's a\u00a8 Candle product\", \"spool analysis\",\nand \"task monitoring (kill etc)\".\n\nFour of the negative comments about Omegamon centre around\nthe package's ease of use - one notes the \"unfriendly screens\",\nwhile another accuses the package of being \"very awkward and\nunforgiving\". Two members found running Omegamon\nincurred a \"high cost\", one disliked the \"response time\nmethodology\", one thought the package was \"missing some\ndesirable messages\", and another noted the lack of an\n\"interface to either AOC or ANO from IBM\".\n\nFour members wrote positive comments about The Monitor for\nVTAM and five wrote negative ones. The positive comments\nwere: \"cost\", \"ease of use\", \"easily customized\", and \"value\nfor money\". The negative comments were: \"\u00ddpoor\u00a8 graphics\",\n\"\u00ddlack of\u00a8 integration with other Monitors from Landmark\",\n\"no NetView interface\", \"not user friendly - no dynamic re-\nconfiguration\", and \"\u00ddpoor\u00a8 resource utilization\".\n\nThirteen members wrote to praise Vital Signs for VTAM and\neleven members wrote comments critical of it. Four members\nfound Vital Signs easy to use, one commented that the package\n\"is easier to install than it used to be\", another liked the\npackage's \"SAA/CUA display\". Three members were pleased\nwith the way the package measures end-user response times,\none member liked Vital Signs' \"comprehensive statistics\ncollection\", one was pleased with the collection of \"network\nand buffer statistics\", and another noted that the package\n\"provides information not available elsewhere, thus helping to\nspot trouble areas\".\n\nNine members were critical of Vital Signs' reporting facilities -\nfour singled out the batch reports, including one who was\nconcerned that \"selective batch reporting is not available -\nwould like time window option\", and five members were\ncritical of its reporting in general (one wrote that \"management\nreporting\" was so poor, \"we've had to write our own reports\",\none complained of \"reporting and regeneration to match a new\nNCP\", and another noted that, while the reporting facilities\nwere poor, \"they've promised to improve this in the next\nrelease\"). Other critical comments about Vital Signs were:\n\"difficulty in reviewing historical data\", \"high overhead\", and\n\"session analysis\".\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N008A03": {"ttr": 9729, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00\\x85\\x00\\x85\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:39", "lines": 133, "newlines": 133, "modlines": 0, "user": "SNAUPDT"}, "text": "Retrieving the VTAM NETID\n\nRecently, as part of our automated operations planning and\nnetwork control site distribution, we have had to provide a\nmechanism for deciding which batch processes are to be run,\ndepending on the system in question.\n\nInitially we were going to use the SYSID of the system;\nhowever, in the past this has changed and also is different for\neach machine even though the processing for some machines in\nthe same network is identical.\n\nAfter a lot of thought we decided that we would use our\nVTAM NETID to invoke the necessary automation. The\nNETID is never changed and is unique to each of our networks\nbut the same for machines sited in the same network.\n\nWhat we needed was a process that would retrieve the system's\nNETID and then issue a message to the console. This is then\ncaptured by NetView or Net/Master automation and, depending\non the NETID, the necessary job schedules are started.\n\nI wrote the following very simple Assembler program to\nachieve the NETID retrieval. It locates the VTAM ATCVT\ncontrol block and then obtains the address that points to the\neight-character NETID in storage. This is moved to a WTO\nwhich is issued to the operator's console and retrieved by a\nmessage automation rule. This then uses a small NetView\nREXX EXEC to process and start the necessary schedules.\n\nAt present this is the only use we have put this to; however, we\nplan to use the NETID to schedule network start-up and shut-\ndown automation and to automate some messages that are\nissued to remote users.\n\n\nSOURCE CODE FOR BNETID\n\n*\n**************************************************************\n\n*        * PROGRAM NAME: BNETID.\n*\n*        * PURPOSE:      ROUTINE TO RETRIEVE THE NETID OF THIS VTAM   *\n*        *               SYSTEM.                                      *\n*        **************************************************************\n*        *                                                            *\n*        * LOCATING THE NETID.                                        *\n*        * -------- --- ------                                        *\n*        *                                                            *\n*        * X'408' LOW STORAGE ---------> ATCVT                        *\n*        *                                 |                          *\n*        *          -----------------------                           *\n*        *         |                                                  *\n*        *          -----> ATCVT + X'728'------> ATCNETID             *\n*        *                                                            *\n*        * DEPENDENCIES.                                              *\n*        * -------------                                              *\n*        *                                                            *\n*        * THIS PROGRAM HAS ONLY BEEN RUN ON VTAM 3.2 SYSTEMS.        *\n*        *                                                            *\n*        **************************************************************\nBNETID  CSECT\nBNETID  AMODE      31\nBNETID  RMODE      24\n         USING     *,R15               /* ENTRY ADDRESS.             */\n         B         SKP                 /* BRANCH PAST HEADER.        */\n         DC        XL1'08'             /* LENGTH OF TITLE.           */\n         DC        C'BNETID'           /* NAME OF PROGRAM.           */\nSKP      DS        0H\n         STM       R14,R12,12(R13)     /* STORE REGISTERS.           */\n         DROP      R15                 /* DROP R15 AS BASE.          */\n         BALR      R12,R0              /* NORMAL ENTRY.              */\n         USING     *,R12               /* SET UP R12 AS BASE.        */\n         LR        R11,R13             /* SAVE SAVEAREA ADDRESS.     */\n         LA        R13,RSAVE           /* LOAD MY SAVEAREA ADDRESS.  */\n         ST        R11,4(,R13)         /* STORE ORIGINAL SAREA ADDR. */\n         ST        R13,8(,R11)         /* STORE MY SAVEAREA ADDRESS. */\n         L         R6,X'408'           /* POINT TO ATCVT.            */\n         MVC       BNETIDO,1832(R6)    /* MOVE NETID INTO MESSAGE.   */\n         MVC       MSG1+43(8),1832(R6) /* MOVE NETID INTO MESSAGE.   */\nMSG1     WTO       'BNET001I: NETID FOR THIS NETWORK =         ',      X\n               ROUTCDE=11\nEXIT     EQU       *\n         SR        R15,R15             /* ZEROIZE RETURN CODE.       */\n         L         R13,4(R13)          /* RELOAD SAVEAREA ADDRESS.   */\n         RETURN    (14,12),RC=(15)     /* RETURN TO TSO.             */\nRSAVE    DS        18F\nBNETIDO  DS        CL8\n         END\n\n\nJCL TO ASSEMBLE AND LINK EDIT BNETID\n\n//STS01V      JOB   (SDTS),'J.BRADLEY',CLASS=A,MSGCLASS=Q,\n//            MSGLEVEL=(1,1),NOTIFY=STS01\n//*\n//ASM1        EXEC  PGM=IEV90,PARM='OBJ,NODECK,XREF(SHORT)'\n//SYSLIB      DD    DSN=SYS1,MACLIB,DISP=SHR\n//            DD    DSN=SYS1.AMODGEN,DISP=SHR\n//            DD    DSN=STS01.BD.MACLIB,DISP=SHR\n//            DD    DSN=SYS1.HASPSRC,DISP=SHR\n//            DD    DSN=SYS1.ATSOMAC,DISP=SHR\n//SYSUT1      DD    UNIT=SYSDA,SPACE=(1700,(600,100))\n//SYSUT2      DD    UNIT=SYSDA,SPACE=(1700,(300,50))\n//SYSUT3      DD    UNIT=SYSDA,SPACE=(1700,(300,50))\n//SYSPRINT    DD    SYSOUT=*\n//SYSLIN      DD    UNIT=SYSDA,SPACE=(80,(200,50)),DISP=(,PASS)\n//SYSIN       DD    DSN=STS01.BD.SOURCE(BNETID),DISP=SHR\n//*\n//LKED1       EXEC  PGM=IEWL,PARM=('MAP,LET,LIST,NCAL'),\n//            COND=(0,NE,ASM1)\n//SYSUT1      DD    UNIT=SYSDA,SPACE=(1024,(50,20))\n//SYSPRINT    DD    SYSOUT=*\n//SYSLMOD     DD    DSN=STS01.BD.LOAD,DISP=SHR\n//SYSLIB      DD    DSN=*.ASM1.SYSLIN,DISP=(OLD,DELETE)\n//SYSLIN      DD    *\n INCLUDE SYSLIB\n NAME    BNETID(R)\n/*\n\n\nSAMPLE OUTPUT FROM AN EXECUTION OF BNETID\n\nIEF403I STS01B - STARTED - TIME=11.15.50\n+BNET001I: NETID FOR THIS NETWORK = GBBRAD01\n-\nIEF404I STS01B - ENDED - TIME=11.15.51\n\n\nJohn Bradley\nSenior Technical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N008A04": {"ttr": 9732, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x00q\\x00q\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:39", "lines": 113, "newlines": 113, "modlines": 0, "user": "SNAUPDT"}, "text": "APPN update\n\nUnder APPN, as a node activates it can communicate with all\nother accessible nodes to notify the APPN network what\nresources it controls. This dynamic nature of APPN is one of\nthe principal benefits of the architecture since it removes the\nnecessity for time and resource consuming network static\ndefinitions. An ACF/VTAM Version 3 host network node (ie\nan SSCP supporting a subarea) can only participate in an APPN\nnetwork as a Low Entry Node. In effect VTAM views any\nconnected APPN network node as a special domain.\nACF/VTAM Version 3 cannot communicate intelligently with\nan APPN node to identify the local resources, eg host\napplications, but must wait until solicited by an adjoining\nAPPN node. Working in conjunction with a front-end\nprocessor running ACF/NCP, VTAM can connect to an APPN\nnetwork but is aware of only the adjacent APPN node. The\nNCP defines Boundary Session control blocks between the\nsubarea and the APPN node to enable sessions to be\nestablished.\n\nEarlier this year IBM announced ACF/VTAM 4.1 with support\nfor APPN. This represents possibly the most significant new\nrelease of VTAM since SNA was first implemented and with it\nIBM is attempting to bring the mainframe into the world of\nopen systems, which is currently the preserve of small systems.\n\nThis does not mean that network planners should push full\nspeed ahead to APPN. What it does enable is a considered\nappraisal of APPN in the knowledge that the last significant\npiece of the jigsaw will be available (probably mid to late\n1993). Mainframe support was always destined to be some\ntime behind other announcements for two reasons: firstly the\nIBM development effort required to upgrade ACF/VTAM and\nsecondly the anxiety of IBM to be seen to be contending in the\nareas of greatest activity and momentum, Local Area Networks\n(LANs). Now IBM has a considerable footing in the area of\nLAN-based internetwork communications, effort can be\nexpended elsewhere.\n\nPerhaps the most significant feature of ACF/VTAM 4.1 to\nmost SNA sites is the support of LU protocols other than\nLU6.2. Limited support for device-dependent protocols such as\nLU2 (ie 3270 terminals) was announced plus a hint that this\nsupport would be considerably extended for Release 2 of the\nproduct. This means that an SNA site could plan to migrate to\nAPPN without immediately having to convert all existing SNA\napplications. Perhaps, not surprisingly, it is becoming clear\nthat IBM is encouraging the migration route rather than\nconversion. In other words, customers are being encouraged to\ndesign all new applications using APPN and plan to convert\nexisting applications when time and resources allow. LU2-\nbased applications could take advantage of the new features of\nAPPN without having to convert though the performance cost\nremains to be determined. To support LU2 across an APPN\nnetwork, IBM uses a transport technique termed 'pipelining' or\n'tunnelling' and which would appear basically to be\nencapsulation (wrapping one protocol around another). Such a\ntechnique is widely used by OEM vendors to overcome\ninterconnection problems between diverse network protocols.\n\nAPPN support on the mainframe will remove the necessity for\nstatic network configurations. In effect the Front End Processor\n(FEP) running ACF/NCP will only need to know about the\nlink(s) from the mainframe to the APPN network. This does\nnot mean that there will be a decreased load on the FEP. As\nresources are activated or connected they will be dynamically\nadded to the APPN network directory. Over a period of time\nthe local directory could build up knowledge of the location of\nevery resource in the network. Dynamic connectivity and\nresource directory maintenance will consume resources on both\nthe mainframe and the FEP. In practice it is likely that the FEP\nwill require at least a storage upgrade but probably also a CPU\nupgrade to handle the increased work.\n\nConsider some of the new NCP parameters introduced in\nACF/NCP 4.3 and 5.2 specifically to support APPN\nconnections:\n\n         BUILD ADDSESS=\n               MAXSESS=\n               NAMTAB=\n\nADDSESS defines a pool of Boundary Session control blocks\navailable for use by APPN LUs when the defined limit for the\nLU has been reached. In other words, a licence to expand.\nMAXSESS defines the maximum number of sessions an APPN\nLU can have (this must be greater than ADDSESS). NAMTAB\ndefines the number of entries in the Network Name Table\n(Network-ids, SSCP-ids, PU2.l node-ids etc). Injudicious\nvalues for these parameters could result in heavy storage usage\nin the NCP. However, these parameters do illustrate how\nsimple APPN is to define. APPN will see a trade-off in cost\nbetween greatly diminished network system programmer time\nand increased hardware.\n\nAn interesting spin-off from the ACF/VTAM 4.1\nannouncements is the fact that it should be possible to\naccommodate CICS in an APPN network without. any\nchanges. This feature may well go hand in hand with the\ndramatic recent announcements to support CICS on non-IBM\nplatforms. Advanced Program to Program Communications\n(APPC) is based on distributed transaction processing and\nCICS is the only viable transaction processing application\nsupported by IBM. By pipelining the LU2 traffic across the\nAPPN network, CICS can be run almost anywhere. Making\nCICS available on any platform enables IBM to market an\nOpen System solution based on an underlying SNA network.\n\nBrian Alford\nSystems Consultant\nAranda (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N008A05": {"ttr": 9735, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00&\\x01\\x16\\x05O\\x01\\x16\\x06/\\x12P\\x03\\xf8\\x03\\xf8\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T12:50:26", "lines": 1016, "newlines": 1016, "modlines": 0, "user": "SNAUPDT"}, "text": "3174 status/usage displays in NetView\n\nThe following REXX EXECs were developed at our site to\nenable operators to see easily, from one screen within\nNetView, the status of a local SNA controller and also list all\nthe users currently using the controller.\n\nThe first EXEC (SNASTAT) is invoked by the following\ncommand:\n\n      SNASTAT nodename\n\nwhere nodename is the name of the SNA major node.\n\nThis EXEC displays the following information:\n\no      Status of major node, PU, and LUs by colour\n      -      Green - active\n      -      Green inverse - active in session (LU only)\n      -      White - pending\n      -      Turquoise - never active\n      -      Red - inactive\n      -      Yellow       - any other state.\n\no      Number of active sessions.\n\no      Time screen was last refreshed.\n\nAvailable function keys from the SNASTAT display are as follows:\n\no      PF3 - exit display\no      PF5 - refresh display\no      PF6 - roll to other NetView applications\no      PF12 - retrieve last command\no      PF13 - display user information on LU\no      PF14 - summary of active users on the controller (SNASUM exec)\no      PF21 - issue a command against a resource\no      PA1 - retrieve one of last 20 commands issued.\n\nPF13 and PF21 require the cursor to be positioned on a\nresource before the PF key is struck.\n\nThe second EXEC (SNASUMM) is invoked by the command:\n\n      SNASUMM nodename\n\nwhere nodename is the name of the SNA major node.\n\nThis EXEC displays the following information:\n\no      Status of major node, PU, and LUs by colour (as for SNASTAT)\no      The application that the LU is in session with\no      The department, name and telephone number of the user\no      Number of active sessions\no      Time screen was last refreshed.\n\nAvailable function keys from the SNASUMM display are as follows:\n\no      PF3 - exit display\no      PF5 - refresh display\no      PF6 - roll to other NetView applications\no      PF7 - page up\no      PF8 - page down\no      PF12 - retrieve last command\no      PF13 - display controller status summary (SNASTAT)\no      PF21 - issue a command against a resource\no      PA1 - retrieve one of last 20 commands issued.\n\nPF21 requires the cursor to be positioned on a resource before\nthe PF key is struck.\n\nThese EXECs will need the following changes to suit your own\nnaming convention. At our site the fifth character of the SNA\nmajor node name and the PU name is the colour code of the\ncontroller (eg LSDSR001).\n\n      $DESC = 'FA C'substr(DEVID,5,1)' HR' - set display heading colour\n\n      PUID ='USDS'||substr(DEVID,5,1)      - set the PU name\n\nThe information on users is stored in an 80-column dataset\ncalled NETVIEW.VTAMADDR.OWNERS, which has the\nfollowing format.\n\n      Col  1 -  8 = LU no 1 name\n      Col 11 - 18 = LU no 2 name\n      Col 21 - 28 = LU no 3 name\n      Col 31 - 50 = Department name\n      Col 51 - 72 = User name\n      Col 73 - 76 = Telephone extension.\n\nWith minor modifications the EXECs can be adapted to display\ninformation on other devices, eg local non-SNA controllers,\nFEP attached controllers, etc. The main change to be made is\nthe way in which messages returned from the display command\nin subroutine GETINFO are parsed.\n\n\nSNASTAT REXX EXEC\n\n/*********************************************************************/\n/* SNASTAT    :-REXX EXEC to display status of SNA 3174s.            */\n/*********************************************************************/\n/* Initialize error handling.                                        */\n/*********************************************************************/\nTrace E\n/*********************************************************************/\n/* Input parameter check.                                            */\n/*********************************************************************/\nDEVID = MSGVAR(1)\nIf DEVID = '' then\n   Do\n      'NETSTAT'\n      Exit\n   End\nIf DEVID = 'INACTIVE' then exit\n/*********************************************************************/\n/* Initialize variables.                                             */\n/*********************************************************************/\nVER = '1.5'\n$COMMAND = 'FI UY'\nREAD = 0\n$OUT1 = 'FA CY'\n$OUT2 = 'FA CY'\n$OUT3 = 'FA CY'\n$OUT4 = 'FA CY'\n$OUT5 = 'FA CY'\n$FLD1 = 'FA CP'\n$FLD2 = 'FA CP'\n$FLD3 = 'FA CP'\n$FLD4 = 'FA CP'\n$FLD5 = 'FA CP'\nDESC = 'SNA MAJOR NODE'\n$DESC = 'FA C'substr(DEVID,5,1)' HR'\n$DEVID = 'FI CG'\nREPEAT = 0\nKEY = 0\nNUMPREV = 20\n'Globalv GETT REPCNT'\nIf REPCNT = '' then REPCNT = 0\n'Globalv PUTT REPCNT'\n$KEY = 'FI UY'\n$PTR. = 'FA CG HB'\n$PREV. = 'FA CY'\nCAll GETINFO\n/*********************************************************************/\n/* MAIN LOOP                                                         */\n/*********************************************************************/\nDo forever\n   /******************************************************************/\n   /* Display main panel.                                            */\n   /******************************************************************/\n   If REPEAT = 0 then\n      Do\n         COMMAND = ' '\n         KEY = 0\n      End\n   Else\n      Do\n         'Globalv GETT PREV.'KEY\n         COMMAND = PREV.KEY\n         REPEAT = 0\n      End\n   'VIEW 9 SNASTAT1 INPUT'\n   /*******************************************************************/\n   /* Convert input fields to upper case.                             */\n   /*******************************************************************/\n   ERRMSG = '                    Last refreshed 'TIME' (now 'TIME()')'\n   $ERRMSG = 'FA CY HB'\n   Upper COMMAND\n   /*******************************************************************/\n   /* Process panel responses.                                        */\n   /*******************************************************************/\n   OUT1 = ''\n   OUT2 = ''\n   OUT3 = ''\n   OUT4 = ''\n   OUT5 = ''\n   FLD1 = ''\n   FLD2 = ''\n   FLD3 = ''\n   FLD4 = ''\n   FLD5 = ''\n   Select\n      When viewaid = PA1 then\n         Do\n           KEY = ''\n           'Globalv GETT REPCNT'\n           Do I = 1 to 20\n              'Globalv GETT PREV.'I\n              PTR.I = '      '\n           End\n           PTR.REPCNT = '====> '\n           Do I = 1 to 20\n              Interpret('PREV'I) '= PREV.I'\n              Interpret('PTR'I) '= PTR.I'\n              Interpret('$PREV'I) '= $PREV.I'\n              Interpret('$PTR'I) '= $PTR.I'\n           End\n           'VIEW 9 LASTCOMM INPUT'\n            Select\n               When viewaid = ENTER & KEY > 0 & KEY < 21 then REPEAT = 1\n               Otherwise nop\n            End\n         End\n      When viewaid = PF3 then exit\n      When viewaid = PF5 then call GETINFO\n      When viewaid = PF6 then\n         Do\n            'Globalv PUTT REPCNT'\n            CMD HIGH ROLL\n            'Globalv GETT REPCNT'\n            ERR = 5\n            Call SETERR\n         End\n      When viewaid = PF12 then\n         Do\n            REPEAT = 1\n            If KEY = 0 then KEY = REPCNT\n            Else\n               Do\n                  KEY = KEY - 1\n                  If KEY < 1 then KEY = NUMPREV\n                  'GLobalv GETT PREV.'KEY\n                  Do while PREV.KEY = ''\n                     KEY = KEY - 1\n                     If KEY < 1 then KEY = NUMPREV\n                     'Globalv GETT PREV.'KEY\n                  End\n               End\n         End\n      When viewaid = PF13 then\n         Do\n            LOC = (VIEWCURROW - 11) * 8 + (VIEWCURCOL + 7) % 10\n            Select\n               When VIEWCURROW = 5 & (VIEWCURCOL + 1) % 10 = 4 then\n                  Do\n                     ERR = 33\n                     Call SETERR\n                  End\n               When VIEWCURROW = 6 & (VIEWCURCOL + 1) % 10 = 4 then\n                  Do\n                     ERR = 33\n                     Call SETERR\n                  End\n               When LUID.LOC \u00ac= '' then call GETUSER\n               Otherwise\n                  Do\n                     ERR = 13\n                     Call SETERR\n                  End\n            End\n         End\n      When viewaid = PF14 then\n         Do\n            'SNASUMM' DEVID\n            ERR = 5\n            Call SETERR\n         End\n      When viewaid = PF21 & COMMAND \u00ac= ' ' then\n         Do\n            LOC = (VIEWCURROW - 11) * 8 + (VIEWCURCOL + 7) % 10\n            ERR = 5\n            Select\n               When VIEWCURROW = 5 & (VIEWCURCOL + 1) % 10 = 4 then\n                  'CMD HIGH 'COMMAND' 'DEVID\n               When VIEWCURROW = 6 & (VIEWCURCOL + 1) % 10 = 4 then\n                  'CMD HIGH 'COMMAND' 'PUID\n               When LUID.LOC \u00ac= '' then\n                  'CMD HIGH 'COMMAND' 'LUID.LOC\n               Otherwise ERR = 21\n            End\n            Call SETERR\n            Call SAVECOMM\n         End\n      When viewaid = PF21 then\n         Do\n            ERR = 0\n            Call SETERR\n         End\n      When viewaid = ENTER then\n         Select\n            When COMMAND \u00ac= ' ' then\n               Do\n                  'CMD HIGH' COMMAND\n                  ERR = 5\n                  Call SETERR\n                  Call SAVECOMM\n               End\n            Otherwise\n               Do\n                  ERR = 0\n                  Call SETERR\n               End\n         End\n      Otherwise\n         Do\n            ERR = 99\n            Call SETERR\n         End\n   End\nEnd\nExit\nGETINFO:\n/**********************************************************************/\n/* Initialize variables.                                              */\n/**********************************************************************/\n   TIME = TIME()\n   ERRMSG = '                    Last refreshed 'TIME' (now 'TIME()')'\n   $ERRMSG = 'FA CY HB'\n   $PUID = 'FI CR'\n   LUID. = ''\n   $LUID. = 'FA CR'\n   PUID = 'USDS'||substr(DEVID,5,1)\n/**********************************************************************/\n/* Loop to get status of PU.                                          */\n/**********************************************************************/\n   'OVERRIDE DISPLAY=NO'\n   'OVERRIDE NETLOG=NO'\n   'TRAP AND SUPPRESS MESSAGES IST453I IST075I'\n   'DIS 'PUID\n   'WAIT 20 SECONDS FOR MESSAGES'\n   'OVERRIDE DISPLAY=YES'\n   'OVERRIDE NETLOG=YES'\n   Select\n      When EVENT() = 'M' then\n         Do\n            'MSGREAD'\n            Select\n               When (MSGID() = 'IST453I') then exit\n               When (MSGID() = 'IST075I') then\n                  Do\n                     NUM = 0\n                     'GETMLINE LINE 2'\n                     PARSE VAR LINE V1 V2 STAT REST\n                     Select\n                        When STAT = 'ACTIV' then\n                           Do\n                              $PUID = 'Fi CG'\n                              'GETMSIZE NUMLINES'\n                              SESS = 0\n                              $SESS = 'FA CY'\n                              Do I = 5 to NUMLINES\n                                 'GETMLINE LINE 'I\n                     PARSE VAR LINE MSGID L.1 S.1.L.2 S.2.L.3 S.3.REST\n                                 If MSGID = 'IST080I' then\n                                    Do J = 1 to 3\n                                       If L.J \u00ac= '' then\n                                          Do\n                                             NUM = NUM + 1\n                                             LUID.NUM = L.J\n                                             Select\n                        When S.J = 'ACTIV' then $LUID.NUM = 'FI CG'\n                        When S.J = 'ACT/S' then\n                           Do\n                              SESS = SESS + 1\n                              $SESS = 'FA CG'\n                              $LUID.NUM = 'FI CG HR'\n                           End\n                        When S.J = 'PCTD2' then $LUID.NUM = 'FI CW'\n                        When S.J = 'NEVAC' then $LUID.NUM = 'FI CT'\n                        When S.J = 'ACTIV' then $LUID.NUM = 'FI CG'\n                        When S.J = 'INACT' then $LUID.NUM = 'FI CR'\n                        Otherwise $LUID.NUM = 'FI CY'\n                                             End\n                                          End\n                                    End\n                              End\n                           End\n                        When STAT = 'PCTD2' then $PUID = 'FI CW'\n                        When STAT = 'NEVAC' then $PUID = 'FI CT'\n                        When STAT = 'ACTIV' then $PUID = 'FI CG'\n                        When STAT = 'INACT' then $PUID = 'FI CR'\n                        Otherwise $PUID = 'FI CY'\n                     End\n                  End\n               Otherwise Say MSGID()\n            End\n         End\n      When EVENT() = 'T' then say 'TIMEOUT ('PUID')'\n      When EVENT() = 'E' then say 'ERROR ('PUID')'\n      Otherwise nop\n   End\n   'TRAP NO MESSAGES'\n   'FLUSHQ'\n   Do I = 1 to NUM\n      Interpret('LUID'I) '= LUID.I'\n      Interpret('$LUID'I) '= $LUID.I'\n   End\nReturn\nSETERR:\n   $ERRMSG = 'FA CR HB'\n   Select\n      When ERR = 0 then\n         ERRMSG = 'Command missing.'\n      When ERR = 5 then\n         Do\n            ERRMSG = 'Last refreshed 'TIME' (now 'TIME()')'\n            $ERRMSG = 'FA CY HB'\n         End\n      When ERR = 7 then\n         ERRMSG = 'First panel is currently being displayed.'\n      When ERR = 8 then\n         ERRMSG = 'Last panel is currently being displayed.'\n      When ERR = 13 then\n         ERRMSG = 'Select a resource using cursor then press PF13.'\n      When ERR = 33 then\n         ERRMSG = 'Detail display not available for this resource.'\n      When ERR = 14 then\n         ERRMSG = 'Select a resource using cursor then press PF14.'\n      When ERR = 21 then\n         ERRMSG = 'Select a resource using cursor then press PF21.'\n      When ERR = 24 then\n         ERRMSG = 'Select a resource using cursor then press PF24.'\n      When ERR = 99 then\n            ERRMSG = 'Invalid PF key.'\n      Otherwise nop\n   End\n   LEN = (78 - Length(ERRMSG)) % 2\nERRMSG = Substr('                                       ',1,LEN)ERRMSG\nReturn\nGETUSER:\n   If READ = 0 then\n      Do\n         'TRAP AND SUPPRESS ONLY MESSAGES CNM272I'\n         \"ALLOCATE DA('NETVIEW.VTAMADDR.OWNERS') SHR FREE\"\n         'WAIT 5 SECONDS FOR MESSAGES'\n         'MSGREAD'\n         DDNAME = WORD(MSGSTR(),1)\n         'TRAP NO MESSAGES'\n         'FLUSHQ'\n         ADDRESS MVS 'EXECIO * DISKR 'DDNAME' ( STEM ARRAY.'\n         ADDRESS MVS 'EXECIO 0 DISKR 'DDNAME' ( FINIS'\n         READ = 1\n      End\n   OUT1 = 'Address ='\n   OUT2 = 'Dept.   ='\n   OUT3 = 'Owner   ='\n   OUT4 = 'Tel.Ext.='\n   OUT5 = 'Session ='\n   LEN = Length(LUID.LOC)\n   Do I = 1 to ARRAY.0\n      If LUID.LOC = Substr(ARRAY.I,1,LEN) then\n         FLD1 = Substr(ARRAY.I,1,10)\n      Else if LUID.LOC = Substr(ARRAY.I,11,LEN) then\n         FLD1 = Substr(ARRAY.I,11,10)\n      Else if LUID.LOC = Substr(ARRAY.I,21,LEN) then\n         FLD1 = Substr(ARRAY.I,21,10)\n      If FLD1 \u00ac= '' then\n         Do\n            FLD2 = Substr(ARRAY.I,31,20)\n            FLD3 = Substr(ARRAY.I,51,22)\n            FLD4 = Substr(ARRAY.I,73,4)\n            If length($LUID.LOC) = 5 then\n               Do\n                  FLD5 = 'Not active'\n                  Return\n               End\n            Else\n               Do\n                  'OVERRIDE DISPLAY=NO'\n                  'OVERRIDE NETLOG=NO'\n                  'TRAP AND SUPPRESS ONLY MESSAGES IST075I'\n                  'DIS 'LUID.LOC\n                  'WAIT 5 SECONDS FOR MESSAGES'\n                  'OVERRIDE DISPLAY=YES'\n                  'OVERRIDE NETLOG=YES'\n                  Select\n                     When EVENT() = 'M' then\n                        Do\n                           'MSGREAD'\n                           Select\n                              When (MSGID() = 'IST075I') then\n                                 Do\n                                    'GETMSIZE NUMLINES'\n                                    Do I = 12 to NUMLINES\n                                       'GETMLINE LINE 'I\n                                       PARSE VAR LINE MESS SES REST\n                                       If MESS = 'IST635I' then\n                                          Do\n                                             SES1 = Substr(SES,1,5)\n                                             SES2 = Substr(SES,6,3)\n                                             Select\n                                                When SES1 = 'ALST0' then\n                                                   FLD5 = 'TSO 'SES2\n                                                When SES1 = 'CNM06' then\n                                                   FLD5 = 'NetView 'SES2\n                                                Otherwise FLD5 = SES\n                                             End\n                                             I = NUMLINES\n                                          End\n                                   End\n                                End\n                              Otherwise Say MSGID()\n                           End\n                        End\n                     When EVENT() = 'T' then say 'TIMEOUT ('LUID.LOC')'\n                     When EVENT() = 'E' then say 'ERROR ('LUID.LOC')'\n                     Otherwise nop\n                  End\n                  Return\n               End\n         End\n   End\n   FLD1 = LUID.LOC\n   FLD2 = 'Not connected'\n   FLD3 = '-'\n   FLD4 = '-'\n   FLD5 = 'Not active'\nReturn\nSAVECOMM:\n   REPEAT = 0\n   KEY = 0\n   'Globalv GETT PREV.'REPCNT\n   If PREV.REPCNT \u00ac= COMMAND then\n      Do\n         REPCNT = REPCNT + 1\n         If REPCNT > NUMPREV then REPCNT = 1\n         PREV.REPCNT = COMMAND\n         'Globalv PUTT PREV.'REPCNT\n         'GLobalv PUTT REPCNT'\n      End\nReturn\n\n\nSNASTAT1 PANEL\n\n/**********************************************************************/\n/* SNASTAT1   :- Display panel for SNASTAT REXX exec.                 */\n/**********************************************************************/\n***\n+SNASTAT1      %S N A   3 1 7 4   S T A T U S   D I S P L A Y      +Version &VER\n$\n$                               &DESC          $\n$&OUT1     &FLD1              $------------------\n$&OUT2     &FLD2              $|\u00acNAME&DEVID    $|\n$&OUT3     &FLD3              $|  \u00acPU =&PUID   $|\n$&OUT4     &FLD4              $|\u00ac# SESS =&SESS $|\n$&OUT5     &FLD5              $------------------\n$\n$\n$&LUID1   $&LUID2   $&LUID3   $&LUID4   $&LUID5   $&LUID6   $&LUID7   $&LUID8\n$&LUID9   $&LUID10  $&LUID11  $&LUID12  $&LUID13  $&LUID14  $&LUID15  $&LUID16\n$&LUID17  $&LUID18  $&LUID19  $&LUID20  $&LUID21  $&LUID22  $&LUID23  $&LUID24\n$&LUID25  $&LUID26  $&LUID27  $&LUID28  $&LUID29  $&LUID30  $&LUID31  $&LUID32\n$&LUID33  $&LUID34  $&LUID35  $&LUID36  $&LUID37  $&LUID38  $&LUID39  $&LUID40\n$&LUID41  $&LUID42  $&LUID43  $&LUID44  $&LUID45  $&LUID46  $&LUID47  $&LUID48\n$&LUID49  $&LUID50  $&LUID51  $&LUID52  $&LUID53  $&LUID54  $&LUID55  $&LUID56\n$&LUID57  $&LUID58  $&LUID59  $&LUID60  $&LUID61  $&LUID62  $&LUID63  $&LUID64\n$&LUID65  $&LUID66  $&LUID67  $&LUID68  $&LUID69  $&LUID70  $&LUID71  $&LUID72\n$&LUID73  $&LUID74  $&LUID75  $&LUID76  $&LUID77  $&LUID78  $&LUID79  $&LUID80\n&ERRMSG\n%Command==>&COMMAND\n$     PF3= Return      PF5= Refresh     PF6= Roll     PF12/PA1= Retrieve\n$    \u00acPF13=$Owner      PF14= Session summary         \u00acPF21=$Command\n\n\nLASTCOMM PANEL\n\n/**********************************************************************/\n/* LASTCOMM   :- Display/selection panel for last 20 commands.        */\n/**********************************************************************/\n***\n+LASTCOMM      %L A S T   2 0   C O M M A N D S   I S S U E D      +Version &VER\n&PTR1 $ 1.&PREV1\n&PTR2 $ 2.&PREV2\n&PTR3 $ 3.&PREV3\n&PTR4 $ 4.&PREV4\n&PTR5 $ 5.&PREV5\n&PTR6 $ 6.&PREV6\n&PTR7 $ 7.&PREV7\n&PTR8 $ 8.&PREV8\n&PTR9 $ 9.&PREV9\n&PTR10$10.&PREV10\n&PTR11$11.&PREV11\n&PTR12$12.&PREV12\n&PTR13$13.&PREV13\n&PTR14$14.&PREV14\n&PTR15$15.&PREV15\n&PTR16$16.&PREV16\n&PTR17$17.&PREV17\n&PTR18$18.&PREV18\n&PTR19$19.&PREV19\n&PTR20$20.&PREV20\n%Enter choice ==>&KEY\n$                                   PF3= Return\n$\n\n\nSNASUMM REXX EXEC\n\n/**********************************************************************/\n/* SNASUMM    :- REXX EXEC to display summary of active sessions      */\n/*               on a SNA 3174.                                       */\n/**********************************************************************/\n/* Initialize error handling.                                         */\n/**********************************************************************/\nTrace E\n/**********************************************************************/\n/* Input parameter check.                                             */\n/**********************************************************************/\nDEVID = MSGVAR(1)\nIf DEVID = '' then\n   Do\n      'NETSTAT'\n      Exit\n   End\nIf DEVID = 'INACTIVE' then exit\n/**********************************************************************/\n/* Initialize variables.                                              */\n/**********************************************************************/\nVER = '1.5'\n$COMMAND = 'FI UY'\nDESC = 'SNA MAJOR NODE'\n$DESC = 'FA C'substr(DEVID,5,1)' HR'\n$DEVID = 'FA CG'\nREPEAT = 0\nKEY = 0\nNUMPREV = 20\n'Globalv GETT REPCNT'\nIf REPCNT = '' then REPCNT = 0\n'Globalv PUTT REPCNT'\n$KEY = 'FI UY'\n$PTR. = 'FA CG HB'\n$PREV. = 'FA CY'\nMAXPAN = 1\nCall READIN\nCall GETINFO\n/**********************************************************************/\n/* MAIN LOOP                                                          */\n/**********************************************************************/\nPANEL = 1\nIf SESS > 12 then PFK = 'PF8= Forward'\nDo forever\n   /*******************************************************************/\n   /* Display main panel.                                             */\n   /*******************************************************************/\n   If REPEAT = 0 then\n      Do\n         COMMAND = ' '\n         KEY = 0\n      End\n   Else\n      Do\n         'Globalv GETT PREV.'KEY\n         COMMAND = PREV.KEY\n         REPEAT = 0\n      End\n   Do I = 1 to 12\n      J = I + (PANEL - 1) * 12\n      K = Substr('    ',1,4 - Length(J))J'.'\n      Interpret('NO'I) '= K'\n      Interpret('LUID'I) '= LUID.J'\n      Interpret('$LUID'I) '= $LUID.J'\n      Interpret('DEPT'I) '= DEPT.J'\n      Interpret('NAME'I) '= NAME.J'\n      Interpret('SES'I) '= SES.J'\n      Interpret('TEL'I) '= TEL.J'\n   End\n   'VIEW 9 SNASUMM1 INPUT'\n   /*******************************************************************/\n   /* Convert input fields to upper case.                             */\n   /*******************************************************************/\n   ERRMSG = '                    Last refreshed 'TIME' (now 'TIME()')'\n   $ERRMSG = 'FA CY HB'\n   Upper COMMAND\n   /*******************************************************************/\n   /* Process panel responses.                                        */\n   /*******************************************************************/\n   Select\n      When viewaid = PA1 then\n         Do\n           KEY = ''\n           'Globalv GETT REPCNT'\n           Do I = 1 to 20\n              'Globalv GETT PREV.'I\n              PTR.I = '      '\n           End\n           PTR.REPCNT = '====> '\n           Do I = 1 to 20\n              Interpret('PREV'I) '= PREV.I'\n              Interpret('PTR'I) '= PTR.I'\n              Interpret('$PREV'I) '= $PREV.I'\n              Interpret('$PTR'I) '= $PTR.I'\n           End\n           'VIEW 9 LASTCOMM INPUT'\n            Select\n               When viewaid = ENTER & KEY > 0 & KEY < 21 then REPEAT = 1\n               Otherwise nop\n            End\n         End\n      When viewaid = PF3 then exit\n      When viewaid = PF5 then call GETINFO\n      When viewaid = PF6 then\n         Do\n            'Globalv PUTT REPCNT'\n            CMD HIGH ROLL\n            'GLobalv GETT REPCNT'\n            ERR = 5\n            Call SETERR\n         End\n      When viewaid = PF7 then\n         Do\n            PANEL = PANEL - 1\n            If PANEL < 1 then\n               Do\n                  PANEL = 1\n                  ERR = 7\n                  Call SETERR\n               End\n            If PANEL = 1 & SESS < 13 then PFK = ''\n            Else if PANEL = 1 & SESS > 12 then PFK = 'PF8= Forward'\n            Else PFK = 'PF7= Back   PF8= Forward'\n         End\n      When viewaid = PF8 then\n         Do\n            PANEL = PANEL + 1\n            If PANEL > MAXPAN then\n               Do\n                  PANEL = MAXPAN\n                  ERR = 8\n                  Call SETERR\n               End\n            If PANEL = 1 then PFK = ''\n            Else if PANEL = MAXPAN then PFK = 'PF7= Back'\n            Else PFK = 'PF7= Back   PF8= Forward'\n         End\n      When viewaid = PF12 then\n         Do\n            REPEAT = 1\n            If KEY = 0 then KEY = REPCNT\n            Else\n               Do\n                  KEY = KEY - 1\n                  If KEY < 1 then KEY = NUMPREV\n                  'Globalv GETT PREV.'KEY\n                  Do while PREV.KEY = ''\n                     KEY = KEY - 1\n                     If KEY < 1 then KEY = NUMPREV\n                     'Globalv GETT PREV.'KEY\n                  End\n               End\n         End\n      When viewaid = PF13 then\n         Do\n            'SNASTAT' DEVID\n            ERR = 5\n            Call SETERR\n         End\n      When viewaid = PF21 & COMMAND \u00ac= ' ' then\n         Do\n            LOC = VIEWCURROW - 8 + (PANEL - 1) * 12\n            If VIEWCURROW > 8 & VIEWCURROW < 21 & LUID.LOC \u00ac= '' then\n               Do\n                  'CMD HIGH 'COMMAND' 'LUID.LOC\n                  ERR = 5\n                  Call SETERR\n                  Call SAVECOMM\n               End\n            Else\n               Do\n                  ERR = 21\n                  Call SETERR\n               End\n         End\n      When viewaid = PF21 then\n         Do\n            ERR = 0\n            Call SETERR\n         End\n      When viewaid = ENTER then\n         Select\n            When COMMAND \u00ac= ' ' then\n               Do\n                  'CMD HIGH' COMMAND\n                  ERR = 5\n                  Call SETERR\n                  Call SAVECOMM\n               End\n            Otherwise\n               Do\n                  ERR = 0\n                  Call SETERR\n               End\n         End\n      Otherwise\n         Do\n            ERR = 99\n            Call SETERR\n         End\n   End\nEnd\nExit\nGETINFO:\n/**********************************************************************/\n/* Initialize variables.                                              */\n/**********************************************************************/\n   TIME = TIME()\n   ERRMSG = '                    Last refreshed 'TIME' (now 'TIME()')'\n   $ERRMSG = 'FA CY HB'\n   $PUID = 'FA CR'\n   $LUID. = 'FA CR'\n   LUID. = ''\n   LUID.1 = 'None'\n   DEPT. = ''\n   NAME. = ''\n   SES. = ''\n   TEL. = ''\n   PUID = 'USDS'||substr(DEVID,5,1)\n/**********************************************************************/\n/* Loop to get status of PU.                                          */\n/**********************************************************************/\n   'OVERRIDE DISPLAY=NO'\n   'OVERRIDE NETLOG=NO'\n   'TRAP AND SUPPRESS MESSAGES IST453I IST075I'\n   'DIS 'PUID\n   'WAIT 20 SECONDS FOR MESSAGES'\n   'OVERRIDE DISPLAY=YES'\n   'OVERRIDE NETLOG=YES'\n   Select\n      When EVENT() = 'M' then\n         Do\n            'MSGREAD'\n            Select\n               When (MSGID() = 'IST453I') then exit\n               When (MSGID() = 'IST075I') then\n                  Do\n                     'GETMLINE LINE 2'\n                     PARSE VAR LINE V1 V2 STAT REST\n                     Select\n                        When STAT = 'ACTIV' then\n                           Do\n                              $PUID = 'FA CG'\n                              'GETMSIZE NUMLINES'\n                              SESS = 0\n                              $SESS = 'FA CY'\n                              Do I = 5 to NUMLINES\n                                 'GETMLINE LINE 'I\n                     PARSE VAR LINE MSGID L.1 S.1 L.2 S.2 L.3 S.3\n                                 If MSGID = 'IST080I' then\n                                    Do J = 1 to 3\n                                       If L.J \u00ac= '' & S.J = 'ACT/S' then\n                                          Do\n                                             SESS = SESS + 1\n                                             $SESS = 'FA CG'\n                                             LUID.SESS = L.J\n                                             $LUID.SESS = 'FI CG'\n                                          End\n                                    End\n                              End\n                           End\n                        When STAT = 'PCTD2' then $PUID = 'FA CW'\n                        When STAT = 'NEVAC' then $PUID = 'FA CT'\n                        When STAT = 'ACTIV' then $PUID = 'FA CG'\n                        When STAT = 'INACT' then $PUID = 'FA CR'\n                        Otherwise $PUID = 'FA CY'\n                     End\n                  End\n               Otherwise Say MSGID()\n            End\n         End\n      When EVENT() = 'T' then say 'TIMEOUT ('PUID')'\n      When EVENT() = 'E' then say 'ERROR ('PUID')'\n      Otherwise nop\n   End\n   'TRAP NO MESSAGES'\n   'FLUSHQ'\n   If SESS > 0 then\n      Do\n         MAXPAN = (SESS + 11) % 12\n         Call ADDINFO\n      End\nReturn\nREADIN:\n   Trace O\n   'TRAP AND SUPPRESS ONLY MESSAGES CNM272I'\n   \"ALLOCATE DA('NETVIEW.VTAMADDR.OWNERS') SHR FREE\"\n   'WAIT 5 SECONDS FOR MESSAGES'\n   'MSGREAD'\n   DDNAME = WORD(MSGSTR(),1)\n   'TRAP NO MESSAGES'\n   'FLUSHQ'\n   ADDRESS MVS 'EXECIO * DISKR 'DDNAME' ( STEM ARRAY.'\n   ADDRESS MVS 'EXECIO 0 DISKR 'DDNAME' ( FINIS'\n   Trace E\nReturn\nADDINFO:\n   Do I = 1 to SESS\n      Do J = 1 to ARRAY.0\n         If Substr(ARRAY.J,1,Length(LUID.I)) = LUID.I |,\n            Substr(ARRAY.J,11,Length(LUID.I)) = LUID.I |,\n            Substr(ARRAY.J,21,Length(LUID.I)) = LUID.I then\n            Do\n               DEPT.I = Substr(ARRAY.J,31,20)\n               NAME.I = Substr(ARRAY.J,51,20)\n               TEL.I = Substr(ARRAY.J,73,4)\n               J = ARRAY.0\n            End\n      End\n      'OVERRIDE DISPLAY=NO'\n      'OVERRIDE NETLOG=NO'\n      'TRAP AND SUPPRESS MESSAGES IST075I'\n      'DIS 'LUID.I\n      'WAIT 20 SECONDS FOR MESSAGES'\n      'OVERRIDE DISPLAY=YES'\n      'OVERRIDE NETLOG=YES'\n      Select\n         When EVENT() = 'M' then\n            Do\n               'MSGREAD'\n               Select\n                  When (MSGID() = 'IST075I') then\n                     Do\n                        'GETMLINE LINE 14'\n                        PARSE VAR LINE V1 SES.I STAT REST\n                        SES1 = Substr(SES.I,1,5)\n                        SES2 = Substr(SES.I,6,3)\n                        Select\n                           When SES1 = 'ALST0' then\n                              SES.I = 'TSO 'SES2\n                           When SES1 = 'CNM06' then\n                              SES.I = 'NetView 'SES2\n                           Otherwise nop\n                        End\n                     End\n                  Otherwise Say MSGID()\n               End\n            End\n         When EVENT() = 'T' then say 'TIMEOUT ('LUID.I')'\n         When EVENT() = 'E' then say 'ERROR ('LUID.I')'\n         Otherwise nop\n      End\n      'TRAP NO MESSAGES'\n      'FLUSHQ'\n   End\nReturn\nSETERR:\n   $ERRMSG = 'FA CR HB'\n   Select\n      When ERR = 0 then\n         ERRMSG = 'Command missing.'\n      When ERR = 5 then\n         Do\n            ERRMSG = 'Last refreshed 'TIME' (now 'TIME()')'\n            $ERRMSG = 'FA CY HB'\n         End\n      When ERR = 7 then\n         ERRMSG = 'First panel is currently being displayed.'\n      When ERR = 8 then\n         ERMSG = 'Last panel is currently being displayed.'\n      When ERR = 13 then\n         ERRMSG = 'Select a resource using cursor then press PF13.'\n      When ERR = 14 then\n         ERRMSG = 'Select a resource using cursor then press PF14.'\n      When ERR = 21 then\n         ERRMSG = 'Select a resource using cursor then press PF21.'\n      When ERR = 24 then\n         ERRMSG = 'Select a resource using cursor then press PF24.'\n      When ERR = 99 then\n            ERRMSG = 'Invalid PF key.'\n      Otherwise nop\n   End\n   LEN = (78 - Length(ERRMSG)) % 2\nERRMSG = Substr('                                       ',1,LEN)ERRMSG\nReturn\nSAVECOMM:\n   REPEAT = 0\n   KEY = 0\n   'Globalv GETT PREV.'REPCNT\n   If PREV.REPCNT \u00ac= COMMAND then\n      Do\n         REPCNT = REPCNT + 1\n         If REPCNT > NUMPREV then REPCNT = 1\n         PREV.REPCNT = COMMAND\n         'Globalv PUTT PREV.'REPCNT\n         'Globalv PUTT REPCNT'\n      End\nReturn\n\n\nSNASUMM1 PANEL\n\n/**********************************************************************/\n/* SNASUMM1   :- Display panel for SNASUMM REXX exec.                 */\n/**********************************************************************/\n***\n+SNASUMM1      %S N A   3 1 7 4   S T A T U S   D I S P L A Y      +Version &VER\n$                               &DESC          $\n$                              ------------------\n$                              |\u00acNAME&DEVID    $|\n$                              |  \u00acPU =&PUID   $|\n$                              |\u00ac# SESS =&SESS $|\n$                              ------------------\n$\n\u00ac&NO1 &LUID1   %&SES1       +&DEPT1               |1                $&TEL1\n\u00ac&NO2 &LUID2   %&SES2       +&DEPT2               |2                $&TEL2\n\u00ac&NO3 &LUID3   %&SES3       +&DEPT3               |3                $&TEL3\n\u00ac&NO4 &LUID4   %&SES4       +&DEPT4               |4                $&TEL4\n\u00ac&NO5 &LUID5   %&SES5       +&DEPT5               |5                $&TEL5\n\u00ac&NO6 &LUID6   %&SES6       +&DEPT6               |6                $&TEL6\n\u00ac&NO7 &LUID7   %&SES7       +&DEPT7               |7                $&TEL7\n\u00ac&NO8 &LUID8   %&SES8       +&DEPT8               |8                $&TEL8\n\u00ac&NO9 &LUID9   %&SES9       +&DEPT9               |9                $&TEL9\n\u00ac&NO10&LUID10  %&SES10      +&DEPT10              |10               $&TEL10\n\u00ac&NO11&LUID11  %&SES11      +&DEPT11              |11               $&TEL11\n\u00ac&NO12&LUID12  %&SES12      +&DEPT12              |12               $&TEL12\n&ERRMSG\n%Command==>&COMMAND\n$PF3= Return          PF5= Refresh           PF6= Roll  &PFK\n$PF12/PA1= Retrieve   PF13= Detail Display  \u00acPF21=$Command\n\n\nJohn Cameron\nSenior Technical Specialist\nLife Association of Scotland (UK)     c Life Association of Scotland 1992\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "N008A06": {"ttr": 10243, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x16\\x05O\\x01\\x16\\x05O\\x12P\\x01\\x0f\\x01\\x0f\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-02-23T12:50:39", "lines": 271, "newlines": 271, "modlines": 0, "user": "SNAUPDT"}, "text": "An Assembler routine to print the Net/Stat log\n\nWe have recently installed the Net/Master product at our site\nand the following program has been written to enable us to\nproduce hardcopy output of the Net/Stat log. Net/Stat is the\nNet/Master equivalent of the NetView Status Monitor product.\nNet/Stat records events onto a VSAM dataset named SMLOG.\nThis dataset can be browsed on-line; however, no facility is\nprovided to print the log. We have found that it is beneficial,\nespecially in relation to problems that require further\ninvestigation, to have a hardcopy print of the SMLOG dataset.\nI wrote the following Assembler program to produce a printout\nof the dataset in question. It is very simple and does not print\nthe dataset using any input criteria, such as date or resource.\nWe clear our Net/Stat dataset each day so the print routine does\nnot generate vast amounts of output. It may be necessary to\namend the program if the Net/Stat dataset is not cleared daily.\n\n\nSMLOGPRT UTILITY SOURCE CODE\n\nSMLOGPRT CSECT\n*        **************************************************************\n*        * PROGRAM NAME: SMLOGPRT.                                    *\n*        * PURPOSE:      PRINT THE NETMASTER SMLOG DATASET.           *\n*        * MANUALS:      VSAM ADMINISTRATION: MACRO INSTRUCTION       *\n*        *                                    REFERENCE               *\n*        *                                    - GC26-4152-03.         *\n*        **************************************************************\nSMMAIN   EQU       *\n         SAVE      (14,12)             /* SAVE REGISTERS.            */\n         LR        R12,R15             /* LOAD ENTRY POINT.          */\n         USING     SMLOGPRT,R12        /* ESTABLISH A BASE.          */\n         ST        R13,SAVEAREA+4      /* STORE SAVEAREA ADDRESS.    */\n         LA        R2,SAVEAREA         /* CHAIN SAVEAREA.            */\n         ST        R15,8(R13)          /* CHAIN SAVEAREA.            */\n         LR        R13,R2              /* LOAD NEW SAVEAREA.         */\nSM0010   EQU       *\n         OPEN      (SMLOGACB)          /* OPEN THE ACB FOR DATASET.  */\n         LTR       R15,R15             /* TEST RETURN CODE.          */\n         BZ        SM0020              /* IF OK, CONTINUE.           */\n         LR        R7,R15              /* SAVE REGISTER.             */\n         CVD       R15,PFLD            /* MAKE RETCODE DECIMAL.      */\n         UNPK      RC,PFLD             /* FORMAT FOR DISPLAY.        */\n         MVZ       RC+1(1),RC          /* REMOVE SIGN.               */\n         MVC       ERRFLD(40),SMMSG010 /* MOVE IN ERROR MESSAGE.     */\n         MVC       WTO1+4(43),SMMSG1   /* MOVE INTO WTO.             */\n         LA        R5,WTO1             /* LOAD WTO ADDRESS.          */\n         WTO       MF=(E,(R5))         /* WRITE IT TO THE JOBLOG.    */\n*        **************************************************************\n*        * SHOWCB MACRO.                                              *\n*        * ACB=    - POINTS IT TOWARD SMLOGACB.                       *\n*        * AREA=   - AREA TO RETURN REQUESTED INFORMATION.            *\n*        * FIELDS= - RETURN ERROR REASON CODE (1 WORD MAXIMUM).       *\n*        * LENGTH= - LENGTH OF RETURNED FIELD.                        *\n*        **************************************************************\n         SHOWCB    ACB=SMLOGACB,       /* FORMAT REASON CODE.        */X\n               AREA=ERRCDE,                                            X\n               FIELDS=ERROR,                                           X\n               LENGTH=4\n         L         R6,ERRCDE           /* LOAD REASON CODE.          */\n         CVD       R6,PFLD             /* CONVERT REASON CODE.       */\n         UNPK      REASON,PFLD         /* UNPACK IT.                 */\n         MVZ       REASON+2(1),REASON+1 /* REMOVE SIGN.              */\n         MVC       RESMSG(40),SMMSG030 /* MOVE IN MESSAGE.           */\n         MVC       WTO1+4(43),SMMSG2   /* MOVE INTO WTO.             */\n         LA        R5,WTO1             /* LOAD WTO ADDRESS.          */\n         WTO       MF=(E,(R5))         /* WRITE IT TO THE JOBLOG.    */\n         B         SMEND               /* GO AND END.                */\nSM0020   EQU       *\n         OPEN      (SYSOUT,(OUTPUT))   /* OPEN OUTPUT DATASET.       */\n         LTR       R15,R15             /* TEST RETURN CODE.          */\n         BZ        SM0025              /* IF OK, CONTINUE.           */\n         LR        R7,R15              /* SAVE REGISTER.             */\n         CVD       R15,PFLD            /* NO, MAKE RETCODE DECIMAL.  */\n         UNPK      RC,PFLD             /* FORMAT FOR DISPLAY.        */\n         MVZ       RC+1(1),RC          /* REMOVE SIGN.               */\n         MVC       ERRFLD(40),SMMSG020 /* MOVE IN ERROR MESSAGE.     */\n         MVC       WTO1+4(43),SMMSG1   /* MOVE INTO WTO.             */\n         LA        R5,WTO1             /* LOAD WTO ADDRESS.          */\n         WTO       MF=(E,(R5))         /* WRITE IT TO THE JOBLOG.    */\n         B         SMEND               /* GO AND END.                */\nSM0025   EQU       *\n         TIME      DEC                 /* GET TODAY'S DATE.          */\n         ST        R1,ANS              /* STORE ANSWER.              */\n         UNPK      DATE,ANS            /* FORMAT IT.                 */\n         OI        DATE+7,X'F0'        /* REMOVE SIGNS.              */\n         MVC       OUTHEAD1+96(2),DATE+3 /* ONTO REPORT HEADER.      */\n         MVC       OUTHEAD1+99(3),DATE+5 /* ONTO REPORT HEADER.      */\nSM0030   EQU       *\n         GET       RPL=SMLOGRPL        /* ISSUE GET FOR SMLOG.       */\n         LTR       R15,R15             /* RECORD RETRIEVED?          */\n         BNZ       SM0200              /* NO, EOF REACHED.           */\nSM0040   EQU       *\n         CLI       PRTSW,X'80'         /* SWITCH ON?                 */\n         BNE       SM0045              /* NO BRANCH TO DO NORMAL.    */\n         SR        R8,R8               /* ZEROIZE REGISTER 8.        */\n         PUT       SYSOUT,OUTHEAD1     /* WRITE HEADER LINE.         */\n         PUT       SYSOUT,BLANK        /* WRITE HEADER LINE.         */\n         PUT       SYSOUT,OUTHEAD2     /* WRITE HEADER LINE.         */\n         PUT       SYSOUT,OUTHEAD3     /* WRITE HEADER LINE.         */\n         PUT       SYSOUT,BLANK        /* WRITE HEADER LINE.         */\n         A         R8,COUNT1           /* ADD 5 TO COUNTER.          */\nSM0045   EQU       *\n         MVC       OUTTIM(11),INAREA+21 /* MOVE TIME TO OUTREC.      */\n         MVC       OUTNOD(8),INAREA+33 /* MOVE NODENAME TO OUTREC.   */\n         MVC       OUTUSR(8),INAREA+42 /* MOVE USER TO OUTREC.       */\n         MVC       OUTDYR(2),INAREA+51 /* FORMAT DATE.               */\n         MVC       OUTDMT(2),INAREA+53 /* FORMAT DATE.               */\n         MVC       OUTDDA(2),INAREA+55 /* FORMAT DATE.               */\n         MVC       OUTMSG(137),INAREA+78 /* MOVE MSGTXT TO OUTREC.   */\nSM0150   EQU       *\n         PUT       SYSOUT,OUTREC1      /* WRITE RECORD.              */\n         PUT       SYSOUT,OUTREC2      /* WRITE RECORD.              */\n         A         R8,COUNT2           /* ADD 1 TO COUNTER.          */\n         MVI       PRTSW,X'00'         /* TURN OFF HEADER PRINT.     */\n         C         R8,PAGEEND          /* END OF PAGE?               */\n         BNH       SM0175              /* NO, BRANCH PAST RESET.     */\n         MVI       PRTSW,X'80'         /* TURN ON HEADER PRINT.      */\n         B         SM0030              /* GO READ ANOTHER.           */\nSM0175   EQU       *\n         B         SM0030              /* GO READ ANOTHER.           */\nSM0200   EQU       *\n         CLOSE     (SMLOGACB,,SYSOUT)  /* CLOSE FILES.               */\n         SR        R7,R7               /* ZEROIZE REGISTER 7.        */\nSMEND    EQU       *\n         L         R13,SAVEAREA+4      /* RELOAD SAVEAREA.           */\n         LR        R15,R7              /* LOAD RETURN CODE.          */\n         L         R14,12(R13)         /* RELOAD REGS.               */\n         LM        R0,R12,20(R13)      /* RELOAD REGS.               */\n         BR        R14                 /* RETURN TO CALLER.          */\nSAVEAREA DS        18F\nANS      DS        F\nCOUNT1   DC        F'5'\nCOUNT2   DC        F'2'\nDATE     DS        D\nERRCDE   DS        F\nPAGEEND  DC        F'55'\nPFLD     DC        D'0'\nPRTSW    DC        X'80'\nSMMSG1   DS        0CL43\nERRFLD   DC        CL40'                                        '\nRC       DS        CL2\n         DC        CL1' '\nSMMSG2   DS        0CL43\nRESMSG   DC        CL40'                                        '\nREASON   DS        CL3\nBLANK    DS        CL150' '\nOUTHEAD1 DS        0CL150\n         DC        CL1'1'\n         DS        CL45\n         DC        CL35'S M L O G   P R I N T   R E P O R T'\n         DS        CL5\n         DC        CL9'RUN DATE:'\n         DS        CL1\nJULYY    DS        CL2\n         DC        CL1'.'\nJULDDD   DS        CL3\n         DS        CL49\nOUTHEAD2 DS        0CL150\n         DS        CL2\n         DC        CL10'TIME OPUT '\n         DS        CL2\n         DC        CL8'USERNODE'\n         DS        CL2\n         DC        CL8' USERID '\n         DS        CL2\n         DC        CL8'  DATE  '\n         DS        CL2\n         DS        CL106\nOUTHEAD3 DS        0CL150\n         DS        CL2\n         DC        CL10'---- ---- '\n         DS        CL2\n         DC        CL8'--------'\n         DS        CL2\n         DC        CL8' ------ '\n         DS        CL2\n         DC        CL8'  ----  '\n         DS        CL2\n         DS        CL106\nOUTREC1  DS        0CL150\n         DS        CL1\nOUTTIM   DS        CL11\n         DS        CL2\nOUTNOD   DS        CL8\n         DS        CL2\nOUTUSR   DS        CL8\n         DS        CL2\nOUTDDA   DS        CL2\n         DC        CL1'/'\nOUTDMT   DS        CL2\n         DC        CL1'/'\nOUTDYR   DS        CL2\n         DS        CL2\n         DS        CL106\nOUTREC2  DS        0CL150\n         DC        CL14' MESSAGE TEXT:'\nOUTMSG   DS        CL136\nSMMSG010 DC        CL40'SMMSG010:ERROR OPENING SMLOG DATASET RC='\nSMMSG020 DC        CL40'SMMSG020:ERROR OPENING O/PUT DATASET RC='\nSMMSG030 DC        CL40'SMMSG030:SHOWCB REASON CODE RETURNED =  '\nWTO1     WTO       '                                                ', X\n               ROUTCDE=(2,11),MF=L\nSYSOUT   DCB       DDNAME=SYSOUT,RECFM=FBA,MACRF=PM,LRECL=150,DSORG=PS\nSMLOGACB ACB       AM=VSAM,DDNAME=SMLOG,MACRF=(KEY,SEQ,IN)\nSMLOGRPL RPL       ACB=SMLOGACB,AM=VSAM,AREA=INAREA,AREALEN=4096,      X\n               OPTCD=(KEY,SEQ),RECLEN=4096\nINAREA   DS        4096XL1'00'\n         END\n\nThe format of the records recorded onto the dataset is presented\nbelow along with the JCL required to execute the print utility.\nThe program can be executed against Net/Stat when it is active\nwithout causing any problems. A standard assembly and link\nedit should be performed to create the necessary load module to\nbe executed. The format of the records and the program\npresented here have been executed successfully on a\nNet/Master 2.2 system and have proved to be an invaluable aid\nin debugging and event tracing.\n\n\nSMLOG DATASET RECORD FORMAT\n\nBytes 1-11      Time in the format hh.mm.ss.ss\nByte 12      Blank\nBytes 13-20      Node name\nByte 21      Blank\nBytes 22 - 29      User name\nByte 30      Blank\nBytes 31-46      Correlator-id\n   31-36         Date in the format YYMMDD\n   37-42         Time in the format HHMMSS\n   43-46         Sequence number for date/time collisions\nByte 47      Blank\nBytes 48-51      Sequence number\nByte 52      Blank\nByte 53      Message class\nByte 54      Blank\nByte 55      Logging class in range 0-5\nByte 56      Message text (variable in length)\nByte 57-64      NCL procedure name\nByte 65      Hyphen (-)\nByte 66-68      Message sequence number within NCL\nByte 69      Colon (:)\nByte 70-n      Text.\n\n\nFILE KEY INFORMATION\n\nBytes 1-16      Correlator-id\n  1-6         Date in the format YYMMDD\n  7-12         Time in the format HHMMSS\n  13-16         Sequence number for date/time collisions\nBytes 17-19       Logical process sequence\nByte 20      Tie-breaker, initial value = 0.\n\n\nJCL TO EXECUTE SMLOGPRT\n\n//STS01B      JOB   (SDTS),CLASS=A,MSGCLASS=Q,MSGLEVEL=(1,1)\n//STEP1       EXEC  PGM=SMLOGPRT\n//STEPLIB     DD    DSN=NETMAST.LOADLIB.USER,DISP=SHR\n//SMLOG       DD    DSN=NETSTAT.SMLOG.CLUSTER,DISP=SHR\n//SYSOUT      DD    SYSOUT=A\n//\n\n\nJohn Bradley\nSenior Technical Support Engineer (UK)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "N008A07": {"ttr": 10248, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x16\\x05O\\x01\\x16\\x06/\\x12Q\\x01f\\x01f\\x00\\x00\\xe2\\xd5\\xc1\\xe4\\xd7\\xc4\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-03-02T12:51:02", "lines": 358, "newlines": 358, "modlines": 0, "user": "SNAUPDT"}, "text": "Analysing LUDRPOOL and PUDRPOOL usage\n\n\nINTRODUCTION\n\nDo you define the PUDRPOOL and/or LUDRPOOL\nparameters in your NCP? If you do, did you ever wonder how\nmany of these resources are ever used? If you have, here is a\nNetView CLIST for you.\n\nUsing dynamic reconfiguration, it is possible to define\nparameters that allow you to add and delete SDLC type 1 and\ntype 2 physical units and logical units dynamically without\nhaving to regenerate the NCP. On the PUDRPOOL parameter,\nyou define the number of physical units that can be added. On\nthe LUDRPOOL parameter, you define the number of\nindependent and dependent logical units that can be added. In\naddition, these parameters also reflect the number of switched\nPUs and LUs that can be added and the number of Token Ring\nLUs that can be added.\n\n\nWhy Be Concerned?\n\nThe PUDRPOOL and LUDRPOOL parameters allocate a\nnumber of control blocks. If you  allow for a large number of\nPUs and LUs to be added dynamically, the size of your NCP\ncould become an issue. If you have a large Token Ring\nnetwork or a switched dial-up network that fluctuates, you\nmight be interested in the actual number of devices active to\nVTAM. This way you can stay one step ahead of demand.\n\n\nHow Resources are Allocated\n\nWhen you dynamically delete a PU or LU, the number of\navailable PUs or LUs will increase by one. When you\ndynamically add a PU or LU, the number of available PUs or\nLUs does not decrease until the Request Network Address\nAssignment (RNAA) is sent. NCP keeps track of the number of\navailable physical units in the Physical Unit Pool Anchor Block\n(PAB) and the number of available logical units in the Logical\nUnit Anchor Block (LAB). NCP adds the number of\nindependent and dependent LUs together.\n\n\nAbout The Clist\n\nThe following NetView CLIST is written in REXX for\nNetView Version 1 Release 3. It reads NCP storage for a 3745\non NCP Version 5 Release 3 or Release 3.1. You must enter\nthe name of the NCP as a parameter. It will display the number\nof available PUs that can be added.\n\nFor the LU pool, it will display:\n\no      The maximum number available (NUMTYP2 plus\n      NUMILU on the LUDRPOOL parameter in the NCP).\n\no      The number of LUs dynamically added.\n\no      The current number of LUs that can be added.\n\no      The lowest number of LUs available since the NCP was initialized.\n\n\nAn Example\n\nThe following parameters are defined in NCP001:\n\nLUPOOL   LUDRPOOL NUMTYP2=1700,NUMILU=300\nPUPOOL   PUDRPOOL NUMBER=10\n\nOne PU was dynamically added. A large number of Token\nRing PCs that emulate a PU and LUs are active in the network.\nEntering the NetView CLIST LUPUPOOL NCP001 might\nresult in the output shown in Figure 1.\n\n     LUPUPOOL NCP001\n\n     PU POOL  NUMBER CURRENTLY AVAILABLE -     9\n\n     LU POOL  MAXIMUM NUMBER  AVAILABLE  -  2000\n     LU POOL  NUMBER CURRENTLY USED      -   593\n     LU POOL  NUMBER CURRENTLY AVAILABLE -  1407\n     LU POOL  MINIMUM NUMBER AVAILABLE   -  1323\n     Figure 1: Sample display\n\n\nThe CLIST LUPUPOOL\n\n/* NETVIEW CLIST LUPUPOOL*/\n/*  */\nIF PARMCNT() \u00ac= 0 THEN SIGNAL START\n'CLEAR'\nSAY 'DISPLAY THE NUMBER OF PU''S AND LU''S THAT CAN BE ADDED VIA'\nSAY 'DYNAMIC CONFIGURATION.'\nSAY 'COMMAND:'\nSAY ' '\nSAY 'LUPUPOOL (NCPNAME)'\nSAY 'NCPNAME = NAME OF THE NCP TO BE CHECKED'\nSAY ' '\nSAY 'EXAMPLE:'\nSAY 'LUPUPOOL NCPNAME'\nSAY ' '\nSAY 'PU POOL  NUMBER CURRENTLY AVAILABLE -    10'\nSAY ' '\nSAY 'LU POOL  MAXIMUM NUMBER  AVAILABLE  -   512'\nSAY 'LU POOL  NUMBER CURRENTLY USED      -   352'\nSAY 'LU POOL  NUMBER CURRENTLY AVAILABLE -   160'\nSAY 'LU POOL  MINIMUM NUMBER AVAILABLE   -   156'\nSAY ' '\nHELP:\nEXIT\n/*  */\nSTART:\nNCP = MSGVAR(1)\n/* ********************************************************************** */\n/*  '6E8' +   POINTS TO THE XDA                                         * */\n/*    |                                                                 * */\n/*    |                                                                 * */\n/*    -> XDA + 92                                                       * */\n/*         |                                                            * */\n/*         |                                                            * */\n/*         -> HWX + 0                                                   * */\n/*             |                                                        * */\n/*             |                                                        * */\n/*             -> QAB + 0                                               * */\n/*                 |                                                    * */\n/*                 |                                                    * */\n/*                 -> PAB                                               * */\n/*                                                                      * */\n/*                     + 18 = CURRENT NUMBER AVAIL                      * */\n/*                                                                      * */\n/*             -> QAB + 4                                               * */\n/*                 |                                                    * */\n/*                 |                                                    * */\n/*                 -> LAB                                               * */\n/*                                                                      * */\n/*                     + 8 = TOTAL NUMBER                               * */\n/*                     + 12 = CURRENT NUMBER AVAIL                      * */\n/*                                                                      * */\n/* ********************************************************************** */\n/*  GET LOW CORE 6E0 TO 6E8                */\n/* ********************************************************************** */\nDISADDR = 6E0\nDISLEN = 12\nDISVAR = 'WD'\nDISRET = 'LOWCORE'\nSIGNAL DIS\nLOWCORE:\n/* ********************************************************************** */\nXDA = WD3\n/* ********************************************************************** */\n/*  GET THE ADDRESS OF THE HWX OUT OF THE XDA                       * */\n/*  HWX IS X'5C' (92) BYTES INTO THE XDA                                * */\n/* ********************************************************************** */\nDISADDR = XDA\nDISLEN = 96\nDISRET = 'HAVXDA'\nSIGNAL DIS\nHAVXDA:\nHWX = DISLAST\n/* ********************************************************************** */\n/*  GET THE ADDRESS OF THE QAB OUT OF THE HWX                       * */\n/*       THE ADDRESS OF THE QAB IS X'00'(00) INTO THE HWX               * */\n/* ********************************************************************** */\nDISADDR = HWX\nDISLEN = 4\nDISRET = 'HAVQAB'\nSIGNAL DIS\nHAVQAB:\nQAB = DISLAST\n/* ********************************************************************** */\n/*  GET THE ADDRESS OF THE LAB OUT OF THE QAB                       * */\n/*       THE ADDRESS OF THE PAB IS X'00'(00) INTO THE QAB               * */\n/*       THE ADDRESS OF THE LAB IS X'04'(04) INTO THE QAB               * */\n/* ********************************************************************** */\nDISADDR = QAB\nDISLEN = 8\nDISRET = 'HAVPAB'\nSIGNAL DIS\nHAVPAB:\nPAB = WD1\nLAB = DISLAST\n/* ********************************************************************** */\n/*  GET THE PUDRPOOL INFORMATION OUT OF PAB                         * */\n/* ********************************************************************** */\nDISPAB:\nDISADDR = PAB\nDISLEN = 20\nDISVAR = 'PUDR'\nDISRET = 'HAVPUDR'\nSIGNAL DIS\nHAVPUDR:\nAVP = SUBSTR(PUDR5,5,4)\n/* ********************************************************************** */\n/*  GET THE LUDRPOOL INFORMATION OUT OF LAB                         * */\n/* ********************************************************************** */\nDISLAB:\nDISADDR = LAB\nDISLEN = 20\nDISVAR = 'LUDR'\nDISRET = 'HAVLUDR'\nSIGNAL DIS\nHAVLUDR:\nTOTL = SUBSTR(LUDR3,1,4)\nAVL = SUBSTR(LUDR4,1,4)\nMINL = SUBSTR(LUDR5,1,4)\n/* ********************************************************************** */\n/*  CONVERT HEX TO DECIMAL       */\n/* ********************************************************************** */\nAVAIP = X2D(AVP)\nTOT  = X2D(TOTL)\nAVAIL = X2D(AVL)\nUSED = TOT - AVAIL\nMIN   = X2D(MINL)\n/* ********************************************************************** */\n/*  FORMAT THE OUTPUT             */\n/* ********************************************************************** */\nAVP = RIGHT(AVAIP,5)\nTOTL = RIGHT(TOT,5)\nAVL = RIGHT(AVAIL,5)\nMINL = RIGHT(MIN,5)\nUSL = RIGHT(USED,5)\nSAY ' '\nSAY 'PU POOL  NUMBER CURRENTLY AVAILABLE - 'AVP\nSAY ' '\nSAY 'LU POOL  MAXIMUM NUMBER  AVAILABLE  - 'TOTL\nSAY 'LU POOL  NUMBER CURRENTLY USED      - 'USL\nSAY 'LU POOL  NUMBER CURRENTLY AVAILABLE - 'AVL\nSAY 'LU POOL  MINIMUM NUMBER AVAILABLE   - 'MINL\nEXIT\n/* ********************************************************************** */\n/*    D I S   S U B R O U T I N E                                       * */\n/*                                                                      * */\n/*  FUNCTION: DISPLAY NCP STORAGE WITH VTAM NCPSTOR COMMANDS            * */\n/*  INPUT:                                                              * */\n/*    DISADDR = HEX ADDRESS TO BE DISPAYED                              * */\n/*    NCP     = NCP TO BE DISPLAYED                                     * */\n/*    DISLEN  = LENGTH OF STORAGE DISPLAY                               * */\n/*    DISRET  = RETURN ADDRESS FROM DIS ROUTINE                         * */\n/*    DISVAR  = VARIABLE PREFIX FOR OUTPUT ARRAY                        * */\n/*  OUTPUT:                                                             * */\n/*    DISLAST = VALUE OF LAST WORD OF STORAGE DISPLAY                   * */\n/*    DISVAR1.= ARRAY OF WORDS FROM 1 TO N WITH OUTPUT OF DISPLAY       * */\n/*                                                                      * */\n/* ********************************************************************** */\nDIS:\nD = 0\n'TRAP SUPPRESS MESSAGES  IST097I IST244I IST245I IST314I IST241I IST242I'\n'D NET,NCPSTOR,ID='NCP',LENGTH='DISLEN',ADDR='DISADDR\nIF RC \u00ac= 0 THEN\n DO\n  'TRAP NO MESSAGES'\n  'FLUSHQ'\n  SIGNAL ERROR\n END\n  'WAIT 60 MESSAGES'\n  DO FOREVER\n  SELECT           /* SELECT ON ALL EVENTS  */\n    WHEN (EVENT()='M') THEN\n    DO\n      'MSGREAD'\n      SELECT          /* SELECT ON MESSAGE    */\n        WHEN (MSGID()='IST097I') THEN CALL NOPVER\n        WHEN (MSGID()='IST244I') THEN CALL VER\n        WHEN (MSGID()='IST245I') THEN CALL VER\n        WHEN (MSGID()='IST314I') THEN CALL ENDW\n        WHEN (MSGID()='IST241I') THEN LEAVE\n        WHEN (MSGID()='IST242I') THEN CALL REJECT\n        OTHERWISE NOP\n      END             /* SELECT ON MESSAGE    */\n    END            /* EVENT() = M DO LOOP     */\n    WHEN EVENT() = 'G' THEN\n     DO\n      'TRAP NO MESSAGES'\n      'FLUSHQ'\n      SIGNAL STRVER\n     END\n    WHEN (EVENT() = 'T') THEN\n     DO\n      'TRAP NO MESSAGES'\n      'FLUSHQ'\n      SIGNAL ERROR\n     END\n    OTHERWISE NOP\n  END              /* SELECT ON ALL EVENTS    */\n  'WAIT CONTINUE'\n END                /* END DO FOREVER          */\n/*  LEAVE LOOP  */\nLASTNCP = NCP\nDISLAST = VALUE(A)\n'TRAP NO MESSAGES'\n'FLUSHQ'\nSIGNAL VALUE(DISRET)\nRETURN\n/* ********************************************************************** */\n/*  IST245I 000260 00000000 00000000 00000000 00000000 */\n/* ********************************************************************** */\nVER:\nMSZI = 1\n'GETMSIZE MSZ'\nNEWMSG:\nI = 2\n'GETMLINE MSGTXT 'MSZI\n'PARSEL2R MSGTXT MSID NUM1 NUM2 NUM3 NUM4 NUM5'\nIF MSID \u00ac= 'IST245I' THEN SIGNAL NXTMSG\nWORD = VALUE('NUM'||I)\nVERLOOP:\nD = D + 1\nA = DISVAR||D\nINTERPRET A '= WORD'\nI = I + 1\nIF I > 5 THEN SIGNAL NXTMSG\nWORD = VALUE('NUM'||I)\nIF '.'WORD \u00ac= '.' THEN SIGNAL VERLOOP\nNXTMSG:\nMSZI = MSZI + 1\nIF MSZI <= MSZ THEN SIGNAL NEWMSG\nRETURN\n/* ********************************************************************** */\n/*  IGNORE THESE MESSAGES */\n/*  IST097I NCPSTOR ACCEPTED */\n/*  IST244I NCP STORAGE FOR ID = (NCP) */\n/*  IST314I END */\n/* ********************************************************************** */\nNOPVER:\nENDW:\nRETURN\n/* ********************************************************************** */\n/*  IST241I NCPSTOR COMMAND COMPLETE FOR ID = (NCP) */\n/* ********************************************************************** */\nENDVER:\nSTRVER:\nLASTNCP = NCP\nDISLAST = VALUE(A)\n'TRAP NO MESSAGES'\n'FLUSHQ'\nSIGNAL VALUE(DISRET)\nRETURN\n/* ********************************************************************** */\n/*  IST242I NCPSTOR COMMAND FAILED FOR ID = (NCP) SENSE = 08060000 */\n/* ********************************************************************** */\nREJECT:\nSAY MSGID()' 'MSGSTR()\nEXIT\n/* ********************************************************************** */\n/*  NCPSTOR COMMAND TIMED OUT */\n/* ********************************************************************** */\nERROR:\nSAY '***  CLIST ENDED EXPECTED DISPLAY RESULTS WERE NOT RECEIVED'\nEXIT\n/* ******************( END OF LUPUPOOL CLIST)*****************************\n\n\n                                           c Reserved 1992\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT944/FILE944.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT944", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}