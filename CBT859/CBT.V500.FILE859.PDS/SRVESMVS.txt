*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
         COPY   SMSYMS        | Get Structured Macros symbols.
         COPY   SRVESMAC      | Get Environment Support symbols.
         SMLIST CONVERT=YES
SRVESMVS title "MVS/XA Environment Support service processor"
         srvmod name=srvesmvs,dates='1989, 1990, 1995'
         gblb   &srv_clemson
         gblc  &srv_modname
         gblc  &srv_stdmnt
*&srv_clemson setb 0   <-- temporarily inserted to assemble special
*                           version for use by xsub in a non-clemson
*                           environment. Re-assembled w/o this line
*                           afterwards. -- mjm 2008-08-27
*---------------------------------------------------------------------*
*
*  Copyright (C) Clemson University Research Foundation 1987, 1990.
*
*  Program     SRVESMVS
*
*  Abstract    This is the MVS/XA Environment Support service
*              processor.  Its use is documented in the "Clemson
*              University Service Processors User's Guide and
*              Reference".
*
*  Program     Reentrant, problem key and state, standard linkage,
*  Attributes  non-authorized, AMODE(31), RMODE(ANY)
*
*  Special   o The following programs are exit routines that may be
*  Notes       replaced by applications (via an application MNT):
*              SRVESX01 - Message issuer exit routine.
*
*  Change
*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution
*
*---------------------------------------------------------------------*
 block type=program,name=&srv_modname,amode=31,rmode=any,              $
               options=(*srvprc,noesv,noclrdebug,long,                 $
               (parms,vl,(count,pwa_#parms),(using,r11))),             $
               parmmap=parmlist,subopts=(*swa,loadbase)
*
  l       r9,pwaaesv                | r9 -> Environment Support Vector.
  using   esv,r9                    | Establish r9 as the ESV base reg.
  lh      r15,=h'&es_wrong_number_of_parms' Set a tenative return-code.
  l       r2,pwa_#parms             | Put parm count in a reg.
*                                   |
  l       r1,prmafncd               | r1 -> Function code.
  l       r1,0(,r1)                 | r1 := function code.
  caseblk reg=r1                    | Case on function code.
  eject
* *===================================================================*
* *  ES_START function
* *===================================================================*
  case  &start                      | ES_START function:
   leave   block=*,(ch,r2,lt,=h'3'),or,(ch,r2,gt,=h'6')
   callsub start                    |   Start environment support.
   slr     r15,r15                  |   Indicate success.
  eject                             |
* *===================================================================*
* * ES_TERMINATE function.
* *===================================================================*
  case  &terminate                    | ES_TERMINATE function.
*
*  Unload all exit routines.
*
   callsub unload_module,(&es_mvs_message_exit)
*
*  Free the ESV/DIA storage and mark the PWA to be freed on return.
*
   l        r1,pwaaesv                |   R1 -> ESV/DIA storage.
   freemain rc,lv=esvcblen+debug_area_size,a=(1)
   smctrl   freepwa=yes               |   Mark the PWA to be freed.
   slr      r15,r15                   |   Indicate success.
  eject                               |
* *===================================================================*
* * ES_OBTAIN_STORAGE
* *===================================================================*
  case  &es_obtain_storage            |
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,ne,=h'7')     |  Invalid number of parms.
   l     r4,prmgsize                  |  Load r4
   icm   r4,b'1111',0(r4)             |   with size of request.
   l     r5,prmgsp                    |  Load r5
   icm   r5,b'1111',0(r5)             |   with subpool.
   l     r6,prmgbdy                   |  Load r6 with
   icm   r6,b'1111',0(r6)             |   boundary.
   l     r7,prmgloc                   |  Load r7 with
   icm   r7,b'1111',0(r7)             |   location.
   caseblk reg=r7                     |  do getmain based on location
   case &es_location_any              |  for location any
    if (ch,r6,eq,=y(&es_page_boundary))            if page boundary
     getmain rc,lv=(4),sp=(5),bndry=page,loc=(any)  do this getmain
    elseif (ch,r6,eq,=y(&es_doubleword_boundary))  else if doubleword
     getmain rc,lv=(4),sp=(5),loc=(any)             do this getmain
    else                              |            else if invalid
     la    r15,&es_invalid_boundary   |             set bad return code
    endif                             |            endif
   case &es_location_below            |  for location below
    if (ch,r6,eq,=y(&es_page_boundary))            if page boundary
     getmain rc,lv=(4),sp=(5),bndry=page,loc=below  do this getmain
    elseif (ch,r6,eq,=y(&es_doubleword_boundary))  else if doubleword
     getmain rc,lv=(4),sp=(5),loc=below             do this getmain
    else                              |            else if invalid
     la    r15,&es_invalid_boundary   |             set bad return code
    endif                             |            endif
   case other                         |  for invalid locations
    la    r15,&es_invalid_location    |   set bad return code
   endcase                            |
   if (treg,r15,z)                    |  if return code is zero
    l     r2,prmgaddr                 |   store storage address
    st    r1,0(,r2)                   |    in return area.
   elseif (ch,r15,eq,=h'4')           |  if rc=4
    la    r15,&es_storage_not_available   set return code
   elseif (ch,r15,eq,=h'8')           |  if rc=8
    la    r15,&es_invalid_boundary    |   set return code
   elseif (ch,r15,eq,=h'12')          |  if rc=12
    la    r15,&es_invalid_location    |   set return code
   else                               |  if another rc
    la    r15,&es_undetermined        |   set return code
   endif                              |  endif
  eject
* *===================================================================*
* *  release_storage
* *===================================================================*
  case  &es_release_storage           |
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,ne,=h'5')     |  invalid number of parms.
   l        r4,prmfsize               |  load r4
   icm      r4,b'1111',0(r4)          |   with size of request
   l        r5,prmfsp                 |  load r5
   icm      r5,b'1111',0(r5)          |   with subpool
   l        r6,prmfaddr               |  load r6 with address
   icm      r6,b'1111',0(r6)          |   of storage to free
   freemain rc,lv=(4),sp=(5),a=(6)    |  do freemain
   if (ch,r15,eq,=h'4')               |  if rc=4
    la    r15,&es_storage_not_released    set return code
   elseif (treg,r15,nz)               |  if another rc
    la    r15,&es_undetermined        |   set return code
   endif                              |  endif
  eject                               |
* *===================================================================*
* * ES_LOAD_MODULE function.
* *===================================================================*
  case  &es_load_module               | ES_LOAD_MODULE:
   srvclrdb ,                         |   Reset the DIA stack.
   leave    block=*,(ch,r2,lt,=h'4')  |   Leave if too few parms.
   leave    block=*,(ch,r2,gt,=h'5')  |   Leave if too many parms.
   la       r5,=h'&es_lm_standard'    |   r5 -> Default type.
   if       (ch,r2,ge,=h'5')          |   If path supplied.
     l      r5,prmlpath               |     r5 -> Supplied type.
   endif                              |   EndIf.
   callsub  load_module,(*prmlepnm,*prmlepa,(r5))
  eject                               |
* *===================================================================*
* * ES_UNLOAD_MODULE function.
* *===================================================================*
  case  &es_unload_module             | ES_UNLOAD_MODULE:
   srvclrdb ,                         |   Reset the DIA stack.
   leave    block=*,(ch,r2,lt,=h'3')  |   Leave if too few parms.
   leave    block=*,(ch,r2,gt,=h'4')  |   Leave if too many parms.
   callsub  unload_module,(*prmlepnm) |   Unload the module.
   if       (ch,r2,eq,=h'4')          |   If an EPA was supplied.
     l      r1,prmlepa                |     r1 -> EPA of unloaded mod.
     la     r1,0(,r1)                 |     Clear high-bit.
     if     (treg,r1,nz)              |     If non-null parameter.
       xc   0(4,r1),0(r1)             |       Set EPA to zeros.
     endif                            |     EndIf.
   endif                              |   EndIf.
  eject
* *===================================================================*
* *  display message.
* *===================================================================*
  case  &es_display_message           | ES_DISPLAY_MESSAGE:
   leave   block=*,(ch,r2,lt,=h'3')   |   Leave if too few parms.
   leave   block=*,(ch,r2,gt,=h'4')   |   Leave if too many parms.
   if      (ch,r2,ge,=h'4')           |   If explicit length.
     l     r3,prm_dm_text             |     r3 -> message text.
     l     r4,prm_dm_len              |     r4 -> message length.
   else                               |   Else.
     l     r3,prm_dm_text             |     r3 -> prefixed message.
     l16   r0,0(r3)                   |     r0 := message length.
     st    r0,pwa_dm_len              |     Convert to fullword.
     la    r3,2(,r3)                  |     r3 -> message text.
     la    r4,pwa_dm_len              |     r4 -> message length.
   endif                              |   EndIf.
*                                     |
   if (clc,pwa_msg_epa,eq,=f'0')      |   If issue-message missing.
     la      r15,&es_missing_exit_routine   Set return code.
   else                               |   Else.
     callx   pwa_msg_epa,(pwa_msg_token,pwa_xnfo,(r3),(r4))
*    R15 = whatever the exit set it to, which by definition should
*    be a valid Environment Support return code.
   endif                              |   EndIf.
  space
* *===================================================================*
* *  clear debug info.
* *===================================================================*
  case  &es_clear_debug_info          | start of clear debug info
   leave   block=*,(ch,r2,lt,=h'2'),or,(ch,r2,gt,=h'3')
   push    using                      |  save using environment
   if      (ch,r2,eq,=h'2')           |  If no parms specified.
     la    r1,&es_cdi_execute         |    R1 := default action.
   else                               |  Else.
     l     r1,prmcdact                |    r1 -> Action parm.
     l     r1,0(r1)                   |    r1 := Action parm.
   endif                              |  EndIf.
   slr       r15,r15                  |  Successful return-code.
   if    (c,r1,eq,=f'&es_cdi_execute')   If Action=EXECUTE
     if (cli,esvdbinhibit,ne,x'00')   |    If ClearDebug inhibited.
       la     r15,&es_clear_debug_inhibited  Set return-code.
     else                             |    Else.
       srvclrdb conditional=no        |      Reset debug info.
       slr      r15,r15               |      Successful return-code.
     endif                            |    EndIf.
   elseif (c,r1,eq,=f'&es_cdi_inhibit')  ElseIf Action=INHIBIT
     l8       r0,esvdbinhibit         |    R0 := inhibit count.
     if       (ch,r0,lt,=h'255')      |    If not already @ max.
       al     r0,=f'1'                |      Add 1.
       stc    r0,esvdbinhibit         |      Replace value in ESV.
     endif                            |    EndIf.
     slr      r15,r15                 |    Successful return-code.
   elseif (c,r1,eq,=f'&es_cdi_enable')   ElseIf Action=ENABLE
     l8       r0,esvdbinhibit         |    R0 := inhibit count.
     if       (treg,r0,nz)            |    If count is positive.
       sl     r0,=f'1'                |      Subtract 1.
       stc    r0,esvdbinhibit         |      Replace value in ESV.
     endif                            |    EndIf.
     slr      r15,r15                 |    Successful return-code.
   else                               |  Else.
     la   r15,&es_invalid_action      |    Set bad return-code.
   endif                              |  EndIf.
   pop     using                      |  restore using environment
   space
* *===================================================================*
* *  save debug info.
* *===================================================================*
  case  &es_save_debug_info           | start of save debug info
   leave   block=*,(ch,r2,lt,=h'4'),or,(ch,r2,gt,=h'7')
   push    using                      |  save using environment
   la      r1,prmfd                   |  point r1 past first two parms
   callsub save_debug_info            |  save debug info
   pop     using                      |  restore using environment
  eject
* *===================================================================*
* *  display debug info and display debug info with abend.
* *===================================================================*
  case  &es_display_debug_info,       | start of save debug info       $
               &es_display_debug_info_and_abend
   leave   block=*,(ch,r2,ne,=h'2')   |  invalid number of parms.
   push  using                        |  save using environment
   l32   r3,esvdbtop                  |  point r3 to top of stack
   if m                               |  if it has overflowed
    la    r3,0(,r3)                   |   clear overflow flag
    callsub display_and_log,          |   issue debug info lost        $
               (msg_debugging_info_lost)   message.
   endif                              |  endif
   l     r4,esvdbbtm                  |  point r4 to bottom of stack
   if (clr,r4,eq,r3)                  |  if stack is empty
    callsub display_and_log,          |   issue stack empty            $
               (msg_debugging_info_lost)   message.
   else                               |  else
    loop until                        |   print each debug entry
     l16   r5,0(r4)                   |    load r5 with length of entry
     l8    r1,2(r4)                   |    load r1 with type of entry
     if     (ch,r1,eq,=al2(dbitygdi)) |    if it is general debug info
      callsub display_debug_gdi,((r4))      call its subroutine
     elseif (ch,r1,eq,=al2(dbitytxt)) |    if it is text info
      callsub display_debug_text,((r4))     call its subroutine
     elseif (ch,r1,eq,=al2(dbityhex)) |    if it is hex info
      callsub display_debug_hex,((r4))      call its subroutine
     else                             |    if none of the above
      callsub display_and_log,        |     issue an error             $
               (msg_invalid_debug_info)      message
      callsub display_debug_hex,((r4))      assume it is hex info
     endif                            |    endif
     alr   r4,r5                      |    point to next entry
    endloop until,(clr,r4,ge,r3)      |   loop through all entries
    if (clr,r4,ne,r3)                 |   if pointers ended up strange
     callsub display_and_log,         |    issue an error message      $
               (msg_invalid_debug_info)
    endif                             |   endif
   endif                              |  endif
   l     r1,prmafncd                  |  load address of function code
   l     r1,0(,r1)                    |  load r1 with function code
   if (ch,r1,eq,=h'&es_display_debug_info_and_abend')
    abend 1000,dump                   |  abend if the function code
   endif                              |   is display debug and abend.
   pop   using                        |  restore using environment
  eject                               |
* *===================================================================*
* *  get userid.
* *===================================================================*
  case  &es_get_userid                | start of get current userid
   push  using                        |  save using environment
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.
   lcba  r1,asxb                      |  point r1 to asxb
   l     r14,prmar1                   |  point r14 to 8-byte parm area
   mvc   0(7,r14),asxbuser-asxb(r1)   |  move seven bytes to parm area
   mvi   7(r14),x'40'                 |  blank out last byte
   slr   r15,r15                      |  set successful return code
   if (tm,0(r14),z,x'bf')             |  if userid is blank or null
    la    r15,&es_could_not_locate    |   set error return code
   endif                              |  endif
   pop   using                        |  restore using environment
  eject
* *===================================================================*
* *  get group.
* *===================================================================*
  case  &es_get_group                 | start of get current userid
   push  using                        |  save using environment
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.
   la    r15,&es_could_not_locate     |  assume the worst
   lcba  r1,acee                      |  point r1 to asxb
   if nz                              |  if acee exist
    l     r15,prmar1                  |   point r15 to 8-byte parm area
    mvc   0(8,r15),aceegrpn-acee(r1)  |   move seven bytes to parm area
    slr   r15,r15                     |   set good return code
   endif                              |  endif
   pop   using                        |  restore using environment
  eject
* *===================================================================*
* *  get cacct.
* *===================================================================*
  aif (not &srv_clemson).skip7
  case  &es_get_cacct                 | start of get current cacct
   push  using                        |  save using environment
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.
   la    r15,&es_could_not_locate     |  be pessimistic
   lcba  r1,acee                      |  point r1 to acee
   if nz                              |  if acee exist
    l32   r2,aceeiep-acee(r1)         |   point r2 to iep
    if nz                             |   if iep exist
     l     r1,prmar1                  |    point r1 return area
     mvc   0(8,r1),ieppact+1-iep(r2)  |    move cacct to return area
     if (tm,0(r1),nz,x'bf')           |    if acct in not blank or null
      slr   r15,r15                   |     set successful return code
     endif                            |    endif
    endif                             |   endif
   endif                              |  endif
   pop   using                        |  restore using environment
  eject
.skip7 anop
* *===================================================================*
* *  get sysres volume name.
* *===================================================================*
  case  &es_get_sysres_volume_name    | start of get sysres volume name
   push  using                        |  save using environment
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.
   lcba  r1,cvt                       |  point r1 to cvt
   l     r1,cvtsysad-cvt(,r1)         |  point to sysres ucb
   l     r2,prmar1                    |  point r2 return area
   mvc   0(6,r2),ucbvoli-ucb(r1)      |  move cacct to return area
   slr   r15,r15                      |  set successful return code
   pop   using                        |  restore using environment
  eject
* *===================================================================*
* *  get terminal identification
* *===================================================================*
  aif (not &srv_clemson).skip1
  case  &es_get_terminal_name         | start of get terminal name
   push  using                        |  save using environment
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.
   clemsrv rtnname                    |  get terminal name
   if (treg,r15,z)                    |  if terminal name located
    l     r2,prmar1                   |   point r2 to return area
    stcm  r0,b'1111',0(r2)            |   store terminal name
    stcm  r1,b'1111',4(r2)            |   in return area.
   else                               |  if terminal name not located
    la    r15,&es_could_not_locate    |   set bad return code
   endif                              |  endif
   pop   using                        |  restore using environment
  eject                               |
.skip1 anop
* *===================================================================*
* *  get jobcard name field.
* *===================================================================*
  aif (not &srv_clemson).skip2
  case &es_get_jobcard_name_field     | start of jobcard name field
   push  using                        |  save using environment
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.
   la    r0,c00enlen                  |  load r0 with size of area
   la    r1,pwac00                    |  point r1 to return area
   clemsrv c00                        |  get programmer name
   if (treg,r15,z)                    |  if terminal name located
    l     r2,prmar1                   |   point r2 to return area
    mvc   0(20,r2),pwac00+c00pname-c00    move name to return area
   else                               |  if unsuccessful
    la    r15,&es_could_not_locate    |   set bad return code
   endif                              |  endif
   pop   using                        |  restore using environment
  eject
.skip2 anop
* *===================================================================*
* *  get jobcard room number.
* *===================================================================*
  aif (not &srv_clemson).skip3
  case &es_get_jobcard_room           | start of jobcard room number
   push  using                        |  save using environment
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.
   la    r0,c00enlen                  |  load r0 with size of area
   la    r1,pwac00                    |  point r2 to return area
   clemsrv c00                        |  get programmer name
   if (treg,r15,z)                    |  if terminal name located
    l     r2,prmar1                   |   point r2 to return area
    mvc   0(4,r2),pwac00+c00roomn-c00 |   move name to return area
   else                               |  if unsuccessful
    la    r15,&es_could_not_locate    |   set bad return code
   endif                              |  endif
   pop   using                        |  restore using environment
  eject
.skip3 anop
* *===================================================================*
* *  get tsu, stc or job.
* *===================================================================*
  aif (not &srv_clemson).skip4
  case &es_get_tsu_stc_or_job         | start get tsu, stc or job
   push  using                        |  save using environment
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.
   la    r0,c00enlen                  |  load r0 with size of area
   la    r1,pwac00                    |  point r1 to return area
   clemsrv c00                        |  get programmer name
   if (treg,r15,z)                    |  if successful
    l     r2,prmar1                   |   point r2 to return area
    mvc   0(3,r2),pwac00+c00jobid-c00 |   move type to return area
   else                               |  if unsuccessful
    la    r15,&es_could_not_locate    |   set bad return code
   endif                              |  endif
   pop   using                        |  restore using environment
  eject
.skip4 anop
* *===================================================================*
* *  get jobid.
* *===================================================================*
  aif (not &srv_clemson).skip5
  case &es_get_jobid                  | start get jobid
   push  using                        |  save using environment
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.
   la    r0,c00enlen                  |  load r0 with size of area
   la    r1,pwac00                    |  point r1 to return area
   clemsrv c00                        |  get programmer name
   if (treg,r15,z)                    |  if successful
    l     r2,prmar1                   |   point r2 to return area
    mvc   0(8,r2),pwac00+c00jobid-c00 |   move jobid to return area
   else                               |  if unsuccessful
    la    r15,&es_could_not_locate    |   set bad return code
   endif                              |  endif
   pop   using                        |  restore using environment
  eject                               |
.skip5 anop
* *===================================================================*
* *  get default destination.
* *===================================================================*
  case &es_get_default_destination    | start get default destination
   push  using                        |  save using environment
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.
   la    r15,&es_could_not_locate     |  set default return code
   lcba  r1,asxb                      |  point r1 to asxb
   icm   r1,b'1111',asxblwa-asxb(r1)  |  point r1 to lwa
   if nz                              |  if lwa exist
    l     r1,lwapscb-lwa(,r1)         |   point r1 to pscb
    l     r14,prmar1                  |   point r14 to return area
    mvc   0(8,r14),pscbdest-pscb(r1)  |   point r1 to upt
    slr   r15,r15                     |   set successful return code
   endif                              |  endif
   pop   using                        |  restore using environment
  eject                               |
* *===================================================================*
* *  get dsname prefix.
* *===================================================================*
  case  &es_get_prefix                | start get dsname prefix
   push  using                        |  save using environment
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,ne,=h'3')     |  invalid number of parms.
   la    r15,&es_could_not_locate     |  set default return code
   lcba  r1,asxb                      |  point r1 to asxb
   icm   r1,b'1111',asxblwa-asxb(r1)  |  point r1 to lwa
   if nz                              |  if lwa exist
    l     r1,lwapscb-lwa(,r1)         |   point r1 to pscb
    l     r1,pscbupt-pscb(,r1)        |   point r1 to upt
    la    r2,uptprefx-upt(,r1)        |   point r2 to prefix
    l8    r3,uptprefl-upt(r1)         |   load r3 with length of prefix
    icm   r3,b'1000',=x'40'           |   fill with spaces
    l     r0,prmar1                   |   point r0 to return area
    la    r1,8                        |   load r1 with length of area
    mvcl  r0,r2                       |   move prefix to return area
    slr   r15,r15                     |   set successful return code
   endif                              |  endif
   pop   using                        |  restore using environment
   eject                              |
* *===================================================================*
* *  get time.  date code works until the year 2087.
* *===================================================================*
  case  &es_get_time                  | get time
   push  using                        |  save using environment
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,lt,=h'3')     |  invalid number of parms.
   leave block=*,(ch,r2,gt,=h'4')     |  invalid number of parms.
   time  bin                          |  issue time macro
*  binary form time
   l32   r3,prmar1                    |  point r3 return area
   la    r3,0(,r3)                    |  Clear high-order bit.
   if (treg,r3,nz)                    |  if non-zero
    stcm  r0,b'1111',0(r3)            |   store time in return area
   endif                              |  endif
*  ccyyddd packed form date
   slr   r15,r15                      |  Clear out return-code.
   leave block=*,(clc,pwa_#parms,lt,=f'4')
   l32   r3,prmar2                    |  point r3 return area
   la    r3,0(,r3)                    |  Clear high-order bit.
   if (treg,r3,nz)                    |  if non-zero
    if (clm,r1,b'0100',ge,=al1(87))   |   if year >= 87
     icm   r1,b'1000',=x'19'          |    century is 19
    else                              |   if year < 87
     icm   r1,b'1000',=x'20'          |    century is 20
    endif                             |   endif
    stcm  r1,b'1111',0(r3)            |   store date in return area
   endif                              |  endif
*
   slr   r15,r15                      |  set successful return code
   pop   using                        |  restore using environment
* *===================================================================*
* *  get GMT time.  date code works until the year 2087.
* *===================================================================*
  case  &es_get_gmt_time              | get time
   push  using                        |  save using environment
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,lt,=h'3')     |  invalid number of parms.
   leave block=*,(ch,r2,gt,=h'4')     |  invalid number of parms.
   time  bin,zone=gmt                 |  issue time macro
*  binary form time
   l32   r3,prmar1                    |  point r3 return area
   la    r3,0(,r3)                    |  Clear high-order bit.
   if (treg,r3,nz)                    |  if non-zero
    stcm  r0,b'1111',0(r3)            |   store time in return area
   endif                              |  endif
*  ccyyddd packed form date
   slr   r15,r15                      |  Clear out return-code.
   leave block=*,(clc,pwa_#parms,lt,=f'4')
   l32   r3,prmar2                    |  point r3 return area
   la    r3,0(,r3)                    |  Clear high-order bit.
   if (treg,r3,nz)                    |  if non-zero
    if (clm,r1,b'0100',ge,=al1(87))   |   if year >= 87
     icm   r1,b'1000',=x'19'          |    century is 19
    else                              |   if year < 87
     icm   r1,b'1000',=x'20'          |    century is 20
    endif                             |   endif
    stcm  r1,b'1111',0(r3)            |   store date in return area
   endif                              |  endif
*
   slr   r15,r15                      |  set successful return code
   pop   using                        |  restore using environment
  eject                               |
* *===================================================================*
* *  get formatted time.  date code works until the year 2087.
* *===================================================================*
  case  &es_get_formatted_time        | start of get formatted_time
   push  using                        |  save using environment
   srvclrdb                           |  reset debug info
   leave block=*,(ch,r2,lt,=h'3')     |  invalid number of parms.
   leave block=*,(ch,r2,gt,=h'5')     |  invalid number of parms.
*  *------------------------------------------------------------------*
*  *  Get time and add century to date.
*  *------------------------------------------------------------------*
   time  dec                          |  issue time macro
   st    r0,pwa_dec_time              |  save time in pwa
   st    r1,pwa_yyddd                 |  save yyddd
*  *------------------------------------------------------------------*
*  *  Edit time and move it to return area if provided.
*  *------------------------------------------------------------------*
   l32   r3,prmar1                    |  point r3 to TIME parm.
   la    r3,0(,r3)                    |  Clear hi-bit.
   if    (treg,r3,nz)                 |  If non-zero.
    mvc   pwa_time_mask,psd_time_mask |   move mask to pwa
    ed    pwa_time_mask,pwa_dec_time  |   edit time (hh:mm:ss.th)
    mvc   0(11,r3),pwa_time_mask+1    |   store time in return area
   endif                              |  endif
*  *------------------------------------------------------------------*
*  * Edit date in form mm/dd/yy and move it to return area if provided.
*  *------------------------------------------------------------------*
   slr   r15,r15                      |  Clear out return-code.
   leave block=*,(clc,pwa_#parms,lt,=f'4')
   l32   r3,prmar2                    |  Point r3 to GREGORIAN parm.
   la    r3,0(,r3)                    |  Clear hi-bit.
   if    (treg,r3,nz)                 |  If non-zero.
*   *-----------------------------------------------------------------*
*   *  convert day to binary.  if the day is past february 28 and
*   *  this is not a leap year, add 1 to the day to skip february 29.
*   *-----------------------------------------------------------------*
    zap   pwad,pwa_yyddd+2(2)         |   convert ddd
    cvb   r2,pwad                     |    to binary.
    if (ch,r2,gt,=y(31+28))           |   if past feb 28
     mvi   pwad+7,x'0c'               |    convert year
     mvo   pwad,pwa_yyddd+1(1)        |     to packed.
     cvb   r1,pwad                    |    convert year to binary
     sll   r1,30                      |    shift mod 4 to high 2 bits
     if (treg,r1,nz)                  |    if year is not a leap year
      la    r2,1(,r2)                 |     add 1 to skip feb 29
     endif                            |    endif
    endif                             |   endif
*   *-----------------------------------------------------------------*
*   *  calculate month and day of month by searching table.
*   *-----------------------------------------------------------------*
    la    r15,=h'31,29,31,30,31,30,31,31,30,31,30' days in month
    la    r1,11                       |   loop up to 11 times
    loop bct                          |   start of loop
     leave loop=*,(ch,r2,le,0(r15))   |    leave if days left <=
*                                     |     days in this month
     sh    r2,0(,r15)                 |    subtract days in month
     la    r15,2(,r15)                |    point to next months days
    endloop bct,r1                    |   continue loop
    lcr   r1,r1                       |   calculate
    ah    r1,=h'12'                   |    month.
*   *-----------------------------------------------------------------*
*   * move date to return area in form mm/dd/yy.
*   *                 displacements => 01234567
*   *-----------------------------------------------------------------*
    cvd   r1,pwad                     |   convert month to decimal
    oi    pwad+7,x'0f'                |   remove sign
    unpk  0(2,r3),pwad+6(2)           |   convert to printable
    mvi   2(r3),c'/'                  |   put in first slash
    cvd   r2,pwad                     |   convert day to decimal
    oi    pwad+7,x'0f'                |   remove sign
    unpk  3(2,r3),pwad+6(2)           |   convert to printable
    mvi   5(r3),c'/'                  |   put in second slash
    unpk  pwad(3),pwa_yyddd+1(2)      |   convert year to printable
    mvc   6(2,r3),pwad                |   return date to caller
*   *-----------------------------------------------------------------*
   endif                              |  endif
*  *------------------------------------------------------------------*
*  * edit date in form ccyy.ddd and move it to return area if provided.
*  *------------------------------------------------------------------*
   slr   r15,r15                      |  Clear out return-code.
   leave block=*,(clc,pwa_#parms,lt,=f'5')
   l     r3,prmar3                    |  point r3 to JULIAN parm.
   la    r3,0(,r3)                    |  Clear hi-bit.
   if    (treg,r3,nz)                 |  if non-zero.
    l     r1,pwa_yyddd                |
    if (clm,r1,b'0100',ge,=al1(87))   |   if year >= 87
     icm   r1,b'1000',=x'19'          |    century is 19
    else                              |   if year < 87
     icm   r1,b'1000',=x'20'          |    century is 20
    endif                             |   endif
    st    r1,pwa_ccyyddd              |   store date in return area
    mvc   pwa_ccyyddd_mask,psd_ccyyddd_mask move mask to pwa
    ed    pwa_ccyyddd_mask,pwa_ccyyddd      edit (ccyy.ddd)
    mvc   0(8,r3),pwa_ccyyddd_mask+1  |     move date to return area
   endif                              |  endif
*  *------------------------------------------------------------------*
   slr   r15,r15                      |  set successful return code
   pop   using                        |  restore using environment
  eject                               |
* *===================================================================*
* *  all other function codes are invalid.
* *===================================================================*
  case  other                         |
   srvclrdb                           |  reset debug info
   la    r15,&es_invalid_function     |  set return code
* *-------------------------------------------------------------------*
  endcase                             | endcase
 endblk block=&srv_modname,rc=(r15)
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Start
*  Abstract:   Start environment support.
*
*---------------------------------------------------------------------*
  block type=subroutine,name=start
*
*  Get storage for the ESV and the Debug Information Area (DIA).
*
   getmain rc,lv=esvcblen+debug_area_size get storage
   st      r1,pwaaesv               |   Save address of ESV.
   l       r15,prm1esv              |   Point r15 to ESV return area.
   st      r1,0(,r15)               |   Store esv address.
   lr      r9,r1                    |   Point r9 to ESV.
*
*  Initialize the Environment Support Vector (ESV) and the DIA.
*
   xc    esv(esvcblen),esv          |   Clear the entire ESV.
   mvc   esvid,=al4(esvidt)         |   Initialize the ESV identifier.
   la    r0,esvcblen                |   Save the ESV's length within
   sth   r0,esvlen                  |     the ESV itself.
   mvi   esvver,1                   |   Set the version number.
   mvi   esvrel,1                   |   Set the release number.
   sm_lal r1,linkage_getmain        |   Install the linkage
   st    r1,esvalget                |     getmain routine.
   sm_lal r1,linkage_freemain       |   Install the linkage
   st    r1,esvalfre                |     freemain routine.
   mvc   esvesepa,=a(&srv_modname)   Set Environment Sup
   st    r13,esvestkn               |   Set Environment Support TOKEN.
   lr    r1,r9                      |   R1 -> Start of ESV storage.
   al    r1,=a(esvcblen)            |   R1 -> Start of DIA storage.
   st    r1,esvdbbtm                |   Set DIA stack bottom.
   st    r1,esvdbtop                |   Set DIA stack top.
   al    r1,=a(debug_area_size)     |   R1 -> last byte in DIA storage.
   st    r1,esvdblmt                |   Save as DIA stack limit.
*
*  If an application MNT was provided, save its address.
*
   if (clc,pwa_#parms,ge,=f'4')     |   If enough parameters given.
     l   r1,prm1mnt                 |     R1 -> Appl MNT pointer.
     la  r1,0(,r1)                  |     Clear high-bit, if on.
     if  (treg,r1,nz)               |     If appl MNT provided.
       l r1,0(,r1)                  |       R1 -> Appl MNT.
     endif                          |     EndIf.
     st  r1,pwaaamnt                |     Save as appl MNT address.
   endif                            |   EndIf.
*
*  Load exit routines.
*
   if (clc,pwa_#parms,ge,=f'5')     |   If ExitInfo parameter given.
     l       r1,prm1xnfo            |     r1 -> Exit Info word.
     la      r1,0(,r1)              |     Turn off high-bit.
     st      r1,pwa_xnfo            |     Save address in PWA.
   else                             |   Else.
     mvc     pwa_xnfo,=f'0'         |     Use default ExitInfo value.
   endif                            |   EndIf.
*
*  Decode options if supplied.
*
   if (clc,pwa_#parms,ge,=f'6')     |   If Options parameter given.
     l       r1,prm1opts            |     r1 -> Exit Info word.
     la      r1,0(,r1)              |     Turn off high-bit.
     if (treg,r1,nz)                |     If there are options:
      mvc   pwa_oc_mnt,0(r1)        |      Move MNT option
      ni    pwa_oc_mnt,&es_oc_mnt   |      to PWA.
     endif                          |     Endif.
   endif                            |   EndIf.
*
*  If options is STDMNT (default), try to locate the standard MNT.
*
   if (cli,pwa_oc_mnt,eq,&es_oc_stdmnt)
    wxtrn &srv_stdmnt               |    &srv_stdmnt is weak reference
    l32   r0,=a(&srv_stdmnt)        |    R0 -> Standard MNT.
    if    z                         |    If not linked in, then.
      load  ep=&srv_stdmnt,erret=no_standard_mnt Attempt to load it.
    endif                           |    EndIf.
    st    r0,pwaasmnt               |    Save address in pwa
no_standard_mnt equ *               |   i know it's tacky!@$#$@
   endif                            |
*
   macro
   load_exit &epname,&epa
   gbla      &es_missing_exit_routine,&es_lm_standard
   callsub   load_module,(&epname,&epa,&es_lm_standard)
   if        (treg,r15,nz)
     la      r15,&es_missing_exit_routine
     leave   block=*
   endif
   mend
*
   load_exit &es_mvs_message_exit,pwa_msg_epa
   mvc       pwa_msg_token,=f'0'
*
*  Set successful return code and quit.
*
   slr   r15,r15                    |   Set successful return code.
  endblk block=start                |   Return to caller.
 eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: load_module,(epname,epa,path)
*  Abstract:   Load a module into storage.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=load_module
  lm       r3,r5,0(r1)                | r3->epname r4->epa r5->path.
  icm      r5,b'1111',0(r5)           | r5 := path.
*                                     |
  callsub loc_mnt,(pwaaamnt,(r3))     | Search application MNT.
  if      (treg,r1,z)                 | If not in application MNT.
    callsub loc_mnt,(pwaasmnt,(r3))   |   Search standard MNT.
  endif                               | Endif.
*                                     |
  lr    r6,r1                         | R6 -> MNT entry, if located.@C2
  using mnt,r6                        | R6 is the MNT base reg.
*                                                                   @C2
  if (ch,r5,eq,=h'&es_lm_no_load')    | If no_load option specified:@C2
    la    r15,&es_module_not_loaded   |   Assume the worst.         @C2
    xc  0(l'mntepa,r4),0(r4)          |   Clear EPA in return area. @C2
    if (treg,r6,nz)                   |   If MNT found:             @C2
      l32    r0,mntepa                |     Load EPA from MNT.      @C2
      if nz,and,(cl,r0,ne,=a(x'80000000'))  If non-zero:            @C3
        st     r0,0(,r4)              |       Store EPA in return   @C2
        slr    r15,r15                |       area and set RC=0.    @C2
      endif                           |     Endif.                  @C2
    endif                             |   Endif.                    @C2
    leave block=*                     |   Skip rest of block.       @C2
  endif                               | Endif.                      @C2
*                                                                   @C2
  if    (treg,r6,z)                   | If module not located yet.  @C2
    if (ch,r5,eq,=h'&es_lm_mnt_only') |   If MNT_ONLY specified.
      la    r15,&es_module_not_loaded |     Set return code.
      leave block=*                   |     Return to caller.
    else                              |   Else, system load okay.
      la  r6,pwawmnt                  |     Make a dummy MNT entry.
      xc  pwawmnt,pwawmnt             |     Clear it to zeros.
      mvc mntname,0(r3)               |     Move in module's name.
      mvc mnttruename,0(r3)           |     Use it as TrueName.     @c1
    endif                             |   EndIf.
  endif                               | EndIf.
*                                     |
  l32 r0,mntepa                       | Load EPA from the MNT entry.
  if  z,or,(cl,r0,eq,=a(x'80000000')) | If the module is not loaded.@C3
    load  eploc=mnttruename,          |   Attempt to load module.   @c1+
               erret=load_failed      |   Skip store if failure.    @c1
  endif                               | Endif.
  st    r0,0(,r4)                     | Store EPA in return area.
  slr   r15,r15                       | Set return code to zero.
  leave block=*                       | Return to caller.
*                                     |
load_failed la  r15,&es_module_not_loaded
*                                     |
 endblk block=load_module,rc=(r15)    | EndBlock.
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: unload_module,(epname)
*  Abstract:   unload a module from storage.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=unload_module
   l        r3,0(r1)                  | R3 -> EPNAME.
   callsub  loc_mnt,(pwaaamnt,(r3))   | Search application MNT.
   if       (treg,r1,z)               | If not in application MNT.
     callsub loc_mnt,(pwaasmnt,(r3))  |   Search standard MNT.
   endif                              | Endif.
*                                     |
   ltr   r6,r1                        | R6 -> MNT entry, if located.
   using mnt,r6                       | R6 is the MNT base reg.
   if    z,then                       | If module not located yet.
     la  r6,pwawmnt                   |   Make a dummy MNT entry.
     xc  pwawmnt,pwawmnt              |   Clear it to zeros.
     mvc mntname,0(r3)                |   Move in module's name.
     mvc mnttruename,0(r3)            |   Use it as TrueName.       @c1
   endif                              | EndIf.
*                                     |
   slr   r15,r15                      | Set success return code.
   l32   r0,mntepa                    | Load EPA from the MNT entry.
   if    z,or,(cl,r0,eq,=a(x'80000000')) If Zero.                   @C3
     delete eploc=mnttruename         |   Unload the module.        @c1
     if (treg,r15,nz)                 |   If return code is bad.
       la  r15,&es_module_not_unloaded      Set the return code.
     endif                            |   EndIf.
   endif                              | EndIf.
 endblk block=unload_module,rc=(r15)  |
 eject
*---------------------------------------------------------------------*
*
*  subroutine: loc_mnt
*  abstract:   find mnt entry
*  inputs:     (a_mnt_table_pointer,cl8_name_to_locate)
*  outputs:    r1 points to mnt or has zero
*
*---------------------------------------------------------------------*
 space 1                              |
 block name=loc_mnt,type=subroutine   |
  lm    r2,r3,0(r1)                   | point r2 to table pointer and
*                                     |  r3 to name to locate
  slr   r1,r1                         | set r1 to zero
  l32   r5,0(r2)                      | point r5 to mnt pointer
  if nz                               | if not zero
   icm   r5,b'1111',0(r5)             |  point r5 to mnt
  endif                               | endif
  using mnt,r5                        | establish base for mnt
  if nz                               | if a mnt table exist
   loop until                         |  search for mnt for service
    if (cli,0(r5),eq,0)               |   if end of table
     slr   r5,r5                      |    set mnt address to null
     leave loop=*                     |    stop search
    endif                             |   endif
    leave loop=*,(clc,mntname,eq,0(r3))   leave if search is complete
    la    r5,mntcblen(,r5)            |   point to next mnt
   endloop until,leave                |  end of search code
   lr    r1,r5                        |  point r1 to mnt
  endif                               | endif
  strsa r1                            | return r1
 endblk block=loc_mnt                 |
 eject                                |
*---------------------------------------------------------------------*
*
*  subroutine: save_debug_info
*  abstract:   put debug information in debug area
*  inputs:     (see prmfd part of prm dsect)
*
*---------------------------------------------------------------------*
 space 1                              |
 block name=save_debug_info,type=subroutine
* *-------------------------------------------------------------------*
* *  establish base and count parms.
* *-------------------------------------------------------------------*
  lr    r8,r1                         | point r8 to parms
  using prmfd,r8                      | establish new parm base
  la    r15,7                         | load r15 with max parms
  loop bct                            | loop searching for end
   leave loop=*,(tbit,0(r1),x'80')    |  quit loop if high bit on
   la    r1,4(,r1)                    |  point to next parm
  endloop bct,r15                     | endloop
  lcr   r7,r15                        | calculate number
  ah    r7,=y(7+1)                    |  of parms.
* *-------------------------------------------------------------------*
* *  process particular type of parm.
* *-------------------------------------------------------------------*
  l     r1,prmvtype                   | load r1 with
  l     r1,0(,r1)                     |  type.
  caseblk reg=r1                      | start of case block
  case &es_debug_id_gdi               | case general debug information
*  *------------------------------------------------------------------*
*  *  store general debug information.
*  *------------------------------------------------------------------*
   if (ch,r7,ne,=h'2')                |  if number of parms is not 2
    callsub display_and_log,(msg_debug_wrong_parms) display message
    leave block=*                     |             leave subroutine
   endif                              |  endif
   l     r3,prmvagdi                  |  point r3 to gdi
   using gdi,r3                       |  establish base for gdi
   l     r15,gdimodid                 |  point r15 to module id
   l8    r1,0(r15)                    |  load module id length
   ah    r1,=y(dbi1flen+1)            |  add length of fixed part + 1
   callsub get_debug_storage          |  get debug storage
   ltr   r4,r1                        |  put storage address in r4
   leave z,block=*                    |  leave if debug area is full
   using dbi,r4                       |  establish base for storage
   mvi   dbity,dbitygdi               |  move type to debug area
   mvc   dbi1ofst,gdioffst            |  move offset to debug area
   mvc   dbi1rc,gdirc                 |  move return code to debug area
   mvc   dbi1regs,gdiregs             |  move registers to debug area
   l     r15,gdimodid                 |  point r15 to module id
   l8    r1,0(r15)                    |  load r1 with length of id
   exi   r1,(mvc,dbi1modi(*-*),0(r15))   move id and length
   drop  r4                           |  drop base for dbi
  case &es_debug_id_text,&es_debug_id_hex
*  *------------------------------------------------------------------*
*  *  store text and hex debug information.
*  *------------------------------------------------------------------*
   if (ch,r7,gt,=h'5'),or,            |  if wrong number of parms      $
               (ch,r7,lt,=h'3')       |
    callsub display_and_log,(msg_debug_wrong_parms)
    leave block=*                     |   leave subroutine
   endif                              |  endif
   l     r4,prmvtxsl                  |  load r4 with
   l     r4,0(,r4)                    |   storage length.
   slr   r3,r3                        |  assume name length of zero
   if (ch,r7,eq,=h'4')                |  if there are 4 parms
    la    r3,8                        |   assume name length of 8
   elseif (ch,r7,eq,=h'5')            |  if there are 5 parms
    l     r3,prmvtxnl                 |   load name length
    l     r3,0(,r3)                   |    from parameter.
   endif                              |  endif
   if (ch,r3,gt,=h'255'),or,          |  if name length > 255 or       $
               (ch,r4,gt,=h'32765')   |   data length > 32765.
    callsub display_and_log,(msg_debug_bad_length)
    leave block=*                     |   leave subroutine
   endif                              |  endif
   la    r1,1+2+dbivar-dbi(r3,r4)     |  calculate storage needed
   callsub get_debug_storage          |  get storage
   ltr   r2,r1                        |  point r2 to storage
   using dbi,r2                       |  establish base for dbi
   leave z,block=*                    |  leave if debug area is full
   mvi   dbity,dbityhex               |  assume type of hex
   l     r1,prmvtype                  |  load r1 with
   l     r1,0(,r1)                    |   type.
   if (ch,r1,eq,=h'&es_debug_id_text')   if text
    mvi   dbity,dbitytxt              |   set type to text
   endif                              |  endif
   la    r2,dbivar                    |  point r2 to variable part
   drop  r2                           |  drop base for fixed part
   stc   r3,0(,r2)                    |  storage name length first
   la    r2,1(,r2)                    |  point r2 past length
   if (ch,r7,ge,=h'4')                |  if a name is provided
    lr    r15,r3                      |   load r15 with length
    l     r14,prmvtxn                 |   point r15 to name
    mvcl  r2,r14                      |   move it to debug area
   endif                              |  endif
   stcm  r4,b'0011',0(r2)             |  store text/hex length
   la    r2,2(,r2)                    |  point r2 past length
   lr    r3,r4                        |  load r3 with text/hex length
   lr    r15,r3                       |  load r15 with text/hex length
   l     r14,prmvtxs                  |  point r14 to text/hex
   mvcl  r2,r14                       |  move text/hex to debug area
  case other                          | any other case
   callsub display_and_log,(msg_debug_invalid_type)
  endcase                             |
 endblk block=save_debug_info,rc=0    |
 eject                                |
*---------------------------------------------------------------------*
*
*  subroutine: get_debug_storage
*  abstract:   obtain storage from debug area
*  inputs:     r1 has length
*  outputs:    r1 has address or zero if no room
*
*---------------------------------------------------------------------*
 space 1                              |
 block name=get_debug_storage,type=subroutine
  lr    r15,r1                        | put length in r15
  l32   r1,esvdbtop                   | point r1 to top of stack
  if m                                | if already an overflow
   slr   r1,r1                        |  return zero as address
  else                                | else
   lr    r2,r1                        |  point r2 to new
   alr   r2,r15                       |   top of stack.
   if (cl,r2,le,esvdblmt),and,        |  if not past limit             $
               (ch,r15,le,=h'32766')  |   size not to large
    stcm  r15,b'0011',0(r1)           |   save length in first halfword
    st    r2,esvdbtop                 |   store new top
   else                               |  if past limit
    callsub display_and_log,(msg_debug_area_full)
    slr   r1,r1                       |   return zero as address
    sbit  esvdbtop,x'80'              |   indicate overflow
   endif                              |  endif
  endif                               | endif
  strsa r1                            | return r1
 endblk block=get_debug_storage,rc=0  |end of subroutine
 space 2                              |
 eject                                |
*---------------------------------------------------------------------*
*
*  subroutine: display_debug_gdi
*  abstract:   display gdi type debug information
*  inputs:     (address_of_dbi)
*
*---------------------------------------------------------------------*
 space 1                              |
 block name=display_debug_gdi,type=subroutine
  l     r3,0(,r1)                     | point r3 to dbi
  using dbi,r3                        | establish addressibility
  fill  ddgo,x'40',length=(ddgolen1,s)  fill output line with spaces
  mvc   ddgoc1,=c"SRV1000I Error"     | Move start of message
  lh    r1,dbi1rc                     | convert return code
  cvd   r1,pwad                       |  to decimal.
  mvc   ddgorc,=x'402020202120'       | edit return code
  ed    ddgorc,pwad+5                 |  into message.
  mvc   ddgoc2,=c" at offset +"       | Move next part of message
  callsub convert_printable_hex,      | convert offset to              $
               (dbi1ofst,2,ddgoofst)  |  printable hex.
  mvc   ddgoc3,=c" in "               | Move next part of message
  la    r0,ddgomdid                   | move
  la    r1,l'ddgomdid                 |  module id
  la    r14,dbi1modi+1                |  to message
  l8    r15,dbi1modi                  |  and fill
  icm   r15,b'1000',=x'40'            |  with
  mvcl  r0,r14                        |  spaces.
  callsub display_and_log,(ddgo,=a(ddgolen1)) display and log message
  fill  ddgo,x'40',length=(ddgolen2,s)  fill output line with spaces
  mvc   ddgorgid,=cl7'R0-R3'          |        display and
  callsub move_regs,(dbi1regs+(0*4),ddgorgs)    log registers
  callsub display_and_log,(ddgo,=a(ddgolen2))   r0-r3.
  mvc   ddgorgid,=cl7'R4-R7'          |        display and
  callsub move_regs,(dbi1regs+(4*4),ddgorgs)    log registers
  callsub display_and_log,(ddgo,=a(ddgolen2))   r4-r7.
  mvc   ddgorgid,=cl7'R8-R11'         |        display and
  callsub move_regs,(dbi1regs+(8*4),ddgorgs)    log registers
  callsub display_and_log,(ddgo,=a(ddgolen2))   r8-r11.
  mvc   ddgorgid,=cl7'R12-R15'        |        display and
  callsub move_regs,(dbi1regs+(12*4),ddgorgs)   log registers
  callsub display_and_log,(ddgo,=a(ddgolen2))   r12-r15.
 endblk block=display_debug_gdi       |
         swa                          |
ddgo     equ   *                      |
ddgoc1   ds    c"SRV1000I Error"
ddgorc   ds    cl6                    |
ddgoc2   ds    c" at offset +"        |
ddgoofst ds    cl4                    |
ddgoc3   ds    c" in "                |
ddgomdid ds    cl47                   |
ddgolen1 equ   *-ddgo                 |
         org   ddgo                   |
         ds    c"SRV1000I "
ddgorgid ds    cl7                    |
         ds    cl2                    |
ddgorgs  ds    cl(4*(8+1))            |
ddgolen2 equ   *-ddgo                 |
         org   ,                      |
         endswa ,                     |
 eject                                |
*---------------------------------------------------------------------*
*
*  subroutine: move regs
*  abstract:   move registers for display_debug_gdi subroutine
*  inputs:     (address_of_four_regs,address_of_dest)
*
*---------------------------------------------------------------------*
 space 1                              |
 block name=move_regs,type=subroutine |
  lm    r2,r3,0(r1)                   |
  callsub convert_printable_hex,(0*4(r2),4,0*9(r3))
  callsub convert_printable_hex,(1*4(r2),4,1*9(r3))
  callsub convert_printable_hex,(2*4(r2),4,2*9(r3))
  callsub convert_printable_hex,(3*4(r2),4,3*9(r3))
 endblk block=move_regs               |
  eject                               |
*---------------------------------------------------------------------*
*
*  subroutine: display_debug_text
*  abstract:   display text type debug information
*  inputs:     (address_of_dbi)
*
*---------------------------------------------------------------------*
 space 1                              |
 block name=display_debug_text,type=subroutine
  l     r3,0(,r1)                     | point r3 to dbi
  la    r3,dbi3-dbi(,r3)              | point r3 to name length
  l8    r2,0(r3)                      | load length of name
  st    r2,ddtlen                     | save it in pwa
  la    r3,1(,r3)                     | point r3 past length
  if (treg,r2,nz)                     | if length of name is nonzero
   callsub display_and_log,((r3),ddtlen) display name
   alr   r3,r2                        |  point r3 past name
  endif                               | endif
  callsub display_and_log,((r3))      | display text
 endblk block=display_debug_text      |
         space 2                      |
         swa ,                        |
ddtlen   ds    f                      |
         endswa                       |
 eject                                |
*---------------------------------------------------------------------*
*
*  subroutine: display_debug_hex
*  abstract:   display hex type debug information
*  inputs:     (address_of_dbi)
*
*---------------------------------------------------------------------*
 space 1                              |
 block name=display_debug_hex,type=subroutine
  l     r3,0(,r1)                     | point r3 to dbi
  la    r3,dbi4-dbi(,r3)              | point r3 to name length
  l8    r2,0(r3)                      | load length of name
  st    r2,ddhlen                     | save it in pwa
  la    r3,1(,r3)                     | point r3 past length
  if (treg,r2,nz)                     | if length of name is nonzero
   callsub display_and_log,((r3),ddhlen)   display name
   alr   r3,r2                        |  point r3 past name
  endif                               | endif
  l16   r2,0(r3)                      | load r2 with length hex data
  la    r3,2(,r3)                     | point r3 past length
  xc    ddhoffst,ddhoffst             | set offset to zero
  loop while,(treg,r2,p)              | loop while hex data is left
   lr    r4,r2                        |  load r4 with length remaining
   if (ch,r4,gt,=h'16')               |  if r4 is greater than 16
    la    r4,16                       |   set length to 16
   endif                              |  endif
   slr   r2,r4                        |  calculate next length
   fill  ddho,x'40',length=(ddholen,s)   fill output line with spaces
   mvi   ddhopls,c'+'                 |  move plus to output
   mvi   ddhoast1,c'*'                |  move asterisk to output
   mvi   ddhoast2,c'*'                |  move second asterisk to output
   callsub convert_printable_hex,     |  convert and move offset       $
               (ddhoffst,2,ddhoofst)  |   to output.
   fill  ddhotran,c'.'                |  fill trans area with periods
   lr    r1,r4                        |  put length in r1
   bctr  r1,0                         |  sub 1 from length for ex
   exi   r1,(mvc,ddhotran(*-*),0(r3)) |  move and translate unprintable
   exi   r1,(tr,ddhotran(*-*),psd_printable_chars) characters to c'.'.
   la    r5,ddhohex                   |  point r5 to printable hex out-
   loop while,(treg,r4,p)             |  put area and loop converting.
    lr    r0,r4                       |   set r0 to length to convert
    if (ch,r0,gt,=h'4')               |   if length > 4
     la    r0,4                       |    set length to 4
    endif                             |   endif
    st    r0,ddhlen                   |   save this length
    slr   r4,r0                       |   calculate next remaining
    callsub convert_printable_hex,    |   convert this piece to        $
               ((r3),ddhlen,(r5))     |    printable hex
    la    r5,9(,r5)                   |   point r5 to next output area
    la    r3,4(,r3)                   |   point r3 to next piece
   endloop while                      |  endloop
   callsub display_and_log,(ddho,=a(ddholen)) display message
   lh    r1,ddhoffst                  |  increment
   la    r1,16(,r1)                   |   offset
   sth   r1,ddhoffst                  |   by 16.
  endloop while                       | endloop
 endblk block=display_debug_hex       |
         swa ,                        |
ddhlen   ds     f                     |
ddhoffst ds     h                     |
ddho     equ    *                     |
         ds     cl1' '                |
ddhopls  ds     cl1'+'                |
ddhoofst ds     cl4                   |
         ds     cl2'  '               |
ddhohex  ds     cl35                  |
         ds     cl2'  '               |
ddhoast1 ds     cl1'*'                |
ddhotran ds     cl16                  |
ddhoast2 ds     cl1'*'                |
ddholen  equ    *-ddho                |
         endswa                       |
 eject                                |
*---------------------------------------------------------------------*
*
*  subroutine: convert_printable_hex
*  abstract:   convert storage to printable hex.
*  inputs:     (source,length_of_storage,destination)
*  note:       length should be no greater than 4.
*
*---------------------------------------------------------------------*
 space 1                              |
 block name=convert_printable_hex,type=subroutine
  lm    r3,r5,0(r1)                   | point r3 to source
*                                     | point r5 to destination
  l     r4,0(,r4)                     | load r4 with length of source
  bctr  r4,0                          | sub 1 from length for exi
  exi   r4,(mvc,chptemp1(*-*),0(r3))  | move source to temp storage
  unpk  chptemp2,chptemp1             | unpack it
  tr    chptemp2,psd_prt_hex_table    | translate it to printable
  sla   r4,1                          | calculate:
  la    r4,1(,r4)                     |   2 * length - 1
  exi   r4,(mvc,0(*-*,r5),chptemp2)   | move result to destination
 endblk block=convert_printable_hex   |
  space 1                             |
         swa                          |
chptemp1 ds    cl5                    | one more than max length
chptemp2 ds    cl9                    | area to unpack into
         endswa                       |
 eject                                |
*---------------------------------------------------------------------*
*
*  subroutine: display_and_log
*  abstract:   issue a message and log it to syslog
*  inputs:     (address_of_message,length_of_message)
*              if the second parameter is not specified, the message
*              is assumed to have a halfword length of the message
*              as a prefix.
*
*---------------------------------------------------------------------*
 block name=display_and_log,type=subroutine
   if (tbit,0(r1),x'80',OFF)          | If explicit length.
     lm    r3,r4,0(r1)                |   r3->text, r4->length.
   else                               | Else.
     l     r3,0(,r1)                  |   r3 -> prefixed message.
     l16   r0,0(r3)                   |   r0 := message length.
     st    r0,pwa_dm_len              |   Convert to fullword.
     la    r3,2(,r3)                  |   r3 -> message text.
     la    r4,pwa_dm_len              |   r4 -> message length.
   endif                              | EndIf.
   if (clc,pwa_msg_epa,eq,=f'0')      |   If issue-message missing.
     la      r15,&es_missing_exit_routine   Set return code.
   else                               |   Else.
     callx   pwa_msg_epa,(pwa_msg_token,pwa_xnfo,(r3),(r4))
*    R15 = whatever the exit set it to, which by definition should
*    be a valid Environment Support return code.
   endif                              |   EndIf.
 endblk block=display_and_log
 eject
**--------------------------------------------------------------------*
**  do basic r-form getmain and return.  address of storage is
**  returned in r1.
**--------------------------------------------------------------------*
 block type=subroutine,name=linkage_getmain,                           $
               options=(*nosubopts,saveusing)
  using linkage_getmain,r15           | establish base
  getmain r,lv=(0)                    | get storage
 endblk block=linkage_getmain         |
 space 3                              |
**--------------------------------------------------------------------*
**  do basic r-form freemain and return.
**--------------------------------------------------------------------*
 block type=subroutine,name=linkage_freemain,                          $
               options=(*nosubopts,saveusing)
  freemain r,lv=(0),a=(1)             | free storage
 endblk block=linkage_freemain        |
         title "Program Static Data and symbols"
*---------------------------------------------------------------------*
*                                                                     *
*  Program Static Data and Equates.                                   *
*                                                                     *
*---------------------------------------------------------------------*
debug_area_size equ 4096              | debug area size
         psd   ,                      |
         ltorg ,                      |
psd_time_mask dc x'4021207a20207a20204b2020'   hh:mm:ss.th
psd_ccyyddd_mask dc x'40212020204b202020'      ccyy.ddd
psd_prt_hex_table equ *-c'0'          |
         dc    c'0123456789abcdef'    |
psd_printable_chars equ *             |
*                 0 1 2 3 4 5 6 7 8 9 a b c d e f
         dc    x'4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b' 0
         dc    x'4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b' 1
         dc    x'4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b' 2
         dc    x'4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b' 3
         dc    x'404b4b4b4b4b4b4b4b4b4a4b4c4d4e4f' 4
         dc    x'504b4b4b4b4b4b4b4b4b5a5b5c5d5e5f' 5
         dc    x'60614b4b4b4b4b4b4b4b4b6b6c6d6e6f' 6
         dc    x'4b4b4b4b4b4b4b4b4b4b7a7b7c7d7e7f' 7
         dc    x'4b8182838485868788894b4b4b4b4b4b' 8
         dc    x'4b9192939495969798994b4b4b4b4b4b' 9
         dc    x'4b4ba2a3a4a5a6a7a8a94b4b4b4b4b4b' a
         dc    x'4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b4b' b
         dc    x'4bc1c2c3c4c5c6c7c8c94b4b4b4b4b4b' c
         dc    x'4bd1d2d3d4d5d6d7d8d94b4b4b4b4b4b' d
         dc    x'4b4be2e3e4e5e6e7e8e94b4b4b4b4b4b' e
         dc    x'f0f1f2f3f4f5f6f7f8f94b4b4b4b4b4b' f
         space 1                      |
         macro                        |
&name    msg   &msg                   |
&name    dc    al2(&name._message_length)
         dc    c&msg                  |
&name._message_length equ *-&name-2   |
         mend                         |
         space 1                      |
msg_invalid_debug_info      msg "SRV1000I Debug area contains invalid i$
               nformation"
msg_no_debugging_info       msg "SRV1001I No debugging information is a$
               vailable"
msg_debugging_info_lost     msg "SRV1002I Debugging information was los$
               t"
msg_debug_area_full         msg "SRV1003I Debugging area is full"
msg_debug_wrong_parms       msg "SRV1004I Invalid parameters passed to $
               Save_Debug_Information"
msg_debug_bad_length        msg "SRV1005I Invalid length passed in debu$
               g information"
msg_debug_invalid_type      msg "SRV1006I Invalid debug type"
         space 5                      |
         endpsd                       |
         title "Program Work Area"
*---------------------------------------------------------------------*
*                                                                     *
*  Program Work Area                                                  *
*                                                                     *
*---------------------------------------------------------------------*
                    pwa   ,     | Program Work Area
*
pwa_oc_mnt          ds    x     | Option: &ES_OC_ STDMNT/NOSTDMNT
*
pwa_#parms          ds    f     | Count of parameters passed in.
pwa_xnfo            ds    a     | -> Exit Information word.
pwa_msg_epa         ds    a     | EPA of Issue_Message routine.
pwa_msg_token       ds    f     | Token for Issue_Message routine.
pwad     ds    d     work doubleword  |
pwaaesv  ds    a     address of service processor global area
pwafsle  ds    a     address of first service load entry
pwaaamnt ds    a     address of application module name table
pwaasmnt ds    a     address of standard module name table
pwawepa  ds    a     entry point address work field
         es_gdi dsect=no              |
pwawork  ds    cl133                  |
         ds    0f                     |
pwawmnt  ds    xl(mntcblen)           |
pwafswa  ds    0f                     | function specific work area
  aif (not &srv_clemson).skip8
         org   pwafswa                | org to start of work area
pwac00   ds    0f,xl(c00enlen)        |
.skip8   anop
         org   pwafswa                | org to start of work area
pwa_dec_time  ds f                    |
pwa_yyddd     ds f                    |
pwa_ccyyddd   ds f                    |
pwa_time_mask    ds xl(l'psd_time_mask)
pwa_ccyyddd_mask ds xl(l'psd_ccyyddd_mask)
         org   pwafswa                | org to start of work area
pwa_dm_len    ds f                    | Length for Display message.
         org   ,                      | org to end of work area
         endpwa                       |
         title "DSECTS"               |
*---------------------------------------------------------------------*
*
* Dsects.
*
*---------------------------------------------------------------------*
         es_parmlist ,                |
         iefjssob ,                   |
         ihaasxb ,                    |
         ihaascb ,                    |
         ihaacee ,                    |
         ikjeflwa ,                   |
         ikjpscb ,                    |
         ikjupt ,                     |
ucb      dsect ,                      |
         iefucbob ,                   |
         cvt   dsect=yes              |
  aif (not &srv_clemson).skip6
         raciep ,                     |
         jesc00 ,                     |
.skip6   anop
         es_esv ,                     |
         es_mnt id=mnt                |
         es_dbi ,                     |
         end   ,                      |
