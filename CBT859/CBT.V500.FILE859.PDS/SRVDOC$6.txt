.**********************************************************************
.**********************************************************************
.*                                                                    *
.*                                                                    *
.*            Chapter. Writing A Service Processor                    *
.*                                                                    *
.*                                                                    *
.**********************************************************************
:h1.Writing A Service Processor
.**********************************************************************
Typical programmers will often find that they have to perform certain
tasks over and over when writing code, such as string manipulation, file
handling or date conversion.  Usually, such programmers will find, as
they talk shop with their colleagues over lunch or a cup of coffee, that
they all perform these same tasks, and find them equally repetitive (and
boring).  Many of the existing Service Processors were conceived in this
manner, by programmers who were willing to write some set of functions
one last time in a nice package so they could get on with their lives.
.*
:p.This chapter will describe how to write a service processor, and will
actually develop a working service processor as an example.  The
conventions which have developed over time will be explained, and the
philosophy behind service processors will be presented.  It is assumed
that the reader is an experienced assembler programmer, and is familiar
with the Clemson Structured Macros, as they will be used in the
examples.
.**********************************************************************
:h2.Service Processor Conventions
.*
There are several programming conventions that experience has shown to
work well for service processors.  Many have evolved from "unwritten
rules", while others are based mainly on convenience and common sense.
.*
:ul.
:li.:hp2.Service processors should always be reentrant.:ehp2.  The
Clemson Structured Macros make reentrancy a simple matter.  In
addition, a service processor can "remember" things across calls,
since its program workarea is reused.  Also, a service processor may
be called from an authorized program, in which case reentrancy can
provide additional protection and security.
.*
:li.:hp2.Service processors should be able to operate normally whether
in an authorized state or not.:ehp2.  For the OS environment, an
:hp1.authorized state:ehp1. generally refers to a program running
in supervisor state, a system key, or with APF authorization.
Exceptions are those service processors which require some state (such
as APF authorization) to perform their function.
.*
:li.:hp2.A service processor should be as efficient as possible.:ehp2.
Assembler-language applications are often written in assembler because
of performance requirements.  The service processor cannot know this
beforehand, so it should always assume that performance is critical to
its callers.  The use of a performance analysis tool such as STROBE is
suggested as a way to optimize routines and find "hot spots" in the
code during development.
.*
:li.:hp2.Service processors can be called directly, or by using
:hp3.function macros.:ehp3.:ehp2.
:hp2.Direct calls:ehp2.  generally involve building your own parameter
list and coding your own CALL or CALLX, while
:hp2.function macros:ehp2. allow you to code parameters as macro
keywords.  The main advantage of function macros to a service
processor's caller is the amount of housekeeping and repetitive coding
that is eliminated.  The main advantage to the service processor's
:hp1.author:ehp1. is that the use of function macros simplifies the
task of documenting the service processor.
.*
:li.:hp2.A service processor should be environment-independent if
possible.:ehp2.  This simply means that the service processor should
call Environment Support or other environment-dependent service
processors to do environment-dependent things, like obtain memory or
deal with files.  This tends to isolate the service processor from its
environment, and also makes it easy to transport to a different
environment (for example, from OS to IDMS/DC) as long as
environment-dependent routines are available in the new environment.
.*
:li.:hp2.A service processor should avoid abends.:ehp2.  This includes
program checks as well as "unrecoverable" errors where the programmer
assumes that the only thing left to do is terminate the caller's task.
If a service processor abends :hp1.for any reason:ehp1., it should be
considered as a bug unless there's a good excuse (for example, if the
checks required to prevent a particular abend would severely impact
the service processor's performance).  Service processors, as a rule,
should make reasonable attempts to check caller-provided parameters
for validity:  the number of parameters, nonzero addresses for
required information, the validity of the service processor's token,
and so on.
.*
:li.:hp2.Service processors should return specific return codes for
any error and let the caller decide if the situation merits an abend
or not.:ehp2.  The service processor environment provides a
:hp1.general debug information:ehp1. area that service processors can
save information in:  these areas can be stacked (in case one service
processor calls another).  The debug area can be displayed by the
caller using
:#x.ES_Display_Debug_Info:e#x. or
:#x.ES_Display_Debug_Info_And_Abend:e#x.: a service processor should
not take it upon itself to display the debug information.
.*
:li.:hp2.It's OK for a service processor to call other service
processors.:ehp2.
If this is done, the service processor should not display its debug
information due to another service processor's error, but should save
its own debug information instead and return a meaningful error to its
caller (which may be yet another service processor).  This way, the
caller can display the debug information and see a trace of how the
error occurred.
.*
:li.:hp2.If a service processor cannot recover from some situation,
some method should be used to restrict subsequent calls.:ehp2.  For
example, when the OS File Handler cannot create a file as requested, a
flag is set that disallows any other call except
:#x.FI_Terminate:e#x..
.*
:eul.
.**********************************************************************
:h2 id=spcc.The "Cheap Calculator" Service Processor
.*
Throughout the rest of this chapter, examples will be used to
illustrate aspects of service processor development.  Our examples
will actually develop a working service processor, which will emulate
a four-function calculator.  The "Cheap Calculator", or :#x.SRVCC:e#x.
service processor, will have five simple functions: Add, Subtract,
Multiply, Divide and Clear, as well as Start and Terminate.  For the
sake of brevity, this is a really cheap calculator that can only
handle integer arithmetic.  The calculator's "display" is maintained
internally by SRVCC and returned to the caller after each operation:
the caller can perform operations on the display, or set it to zero by
clearing it.
.*
:p.SRVCC, while simple and small, contains all of the components and
attributes of a service processor, and can be used as a model for
developing a more elaborate set of routines.
.**********************************************************************
:h2.Components Of A Service Processor
.*
:h3.The Service Processor Load Module
The executable copy of the service processor is a load module residing
either in the system linklist or a load library that the caller must
reference via :#x.STEPLIB:e#x..  Publicly-available service processors
have a naming convention, as follows:
:ul.
:li.The load module name begins with "SRV".
:li.The characters "SRV" are followed by a two-character
identifier ("CC" in our example).
:li.If the service processor is environment-dependent, the remainder
of the load module name identifies the environment (for example,
"MVS" for an MVS-dependent module).
:eul.
:p.In MVS/XA, the load module should have the attributes
AMODE(31) and RMODE(ANY), unless this is not possible
for some reason (for example, the service processor might use QSAM,
which requires RMODE(24)).  The service processor should expect to be
called AMODE(31).
.*
:h3.The Service Processor Copy Member
It is customary to provide a copy member containing global symbols,
function macro definitions and any other tools that might
help the programmer code up calls to the service processor.
.*
:h4.The SRV##ID Macro
.*
The :#x.SRV##ID:e#x. macro can set or override the
:#x.EPA:e#x., :#x.TOKEN:e#x. and :#x.ESVA:e#x. parameters via global
symbols unique for each service processor ID used in a program.
:#x.SRV##ID:e#x. relieves the function macro author of a number of
programming chores.  Generally, one would code a :#x.SRV##ID
SET:e#x. in the service processor's ID macro to establish these
symbols for the rest of the macros, and to generate storage for
those fields that aren't specified.  Subsequent function macros
would issue :#x.SRV##ID GET:e#x. to retrieve these symbols.
.*
:h4.DEFUCOND Macros
.*
DEFUCOND macros should be defined for each of the service processor's
possible return codes.  These macros should have the same name as the
corresponding return code's global symbol.  The condition name must
be preceded with a "%" when used in a conditional statement, as
shown in
:figref refid=macdefx..
.*
:fig id=macdefx width=column concat=no.
:figcap.User-Defined Condition Example
:#x.
    CC_ADD  ID=CC,VALUE=5,DISPLAY=PWA_DISPLAY
    IF    (TREG,R15,NZ)
      IF    (%CC_OVERFLOW)
        CALLSUB OVERFLOW
      ELSE
        ERREXIT NAME=CC_ERROR
      ENDIF
    ENDIF
:e#x.
:efig.
.*
:p.Use the :#x.SRV##RC:e#x. macro to actually generate
the return code comparison, as illustrated in
:figref refid=macdefu..
.*
:fig id=macdefu width=column concat=no.
:figcap.DEFUCOND Macros For SRVCC
:#x.
 *---------------------------------------------------------------------*
 * DEFUCOND macros to facilitate checking return codes.
 *---------------------------------------------------------------------*
    DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_CC_ID
    DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_NUMBER_OF_PARMS
    DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_FUNCTION
    DEFUCOND MACRO=SRV##RC,NAME=CC_OVERFLOW
    DEFUCOND MACRO=SRV##RC,NAME=CC_PARAMETER_MISSING
 :e#x.
:efig.
:h4.The ID Macro
There are a number of parameters that would be coded repeatedly if a
service processor was called using normal means (:#x.CALL:e#x. or
:#x.CALLX:e#x.).  A major advantage of the function macros is that
they can be made to "remember" this information, and can even generate
some of the storage required to hold it.
.*
:p.The ID macro uses the :#x.SRV##ID SET:e#x. macro to
establish global symbols for the service processor's session
defaults, as shown in :figref refid=macid..
.*
:fig id=macid   width=column concat=no.
:figcap.CC_ID Macro For SRVCC
:#x.
.su off
 *---------------------------------------------------------------------*
 *
 *  CC_ID Macro: Establish default values for a specific service
 *               processor and associate them with the specified ID
 *               name.  The values are stored in the following created
 *               global variables, which are used by the other macros:
 *
 *    Variable Name                     Description
 *    -------------  -----------------------------------------------
 *    #$&ID.$#IDMAC  Name of macro that created the ID: CC_ID.
 *    #$&ID.$#ESID   Service processor's Environment Support ID.
 *    #$&ID.$#EPN    Tag for Service processor's Entry Point Name.
 *    #$&ID.$#EPA    Tag for Service processor's Entry Point Address.
 *    #$&ID.$#TKN    Tag for Service processor's Entry Point Token.
 *
 *---------------------------------------------------------------------*
          MACRO
          CC_ID &ID=,&ESVA=,&SPEPNAME=,                                *
                &SPEPA=,&SPTOKEN=,&ESID=
 .*
 .* Invoke SRV##ID to create globals used by all ID's.
 .*
          SRV##ID SET,ID=&ID.,IDMAC=CC_ID,                             *
                ESID=&ESID.,SPEPNAME=&SPEPNAME,                        *
                SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.
          MEND
.su on
:e#x.
:efig.
.*
.*
:h4.The Function Macros
.*
The remainder of the function macros, for the most part, will
generate executable code and will call the service processor
with appropriate parameters for the function desired.
The macro itself should perform reasonable checks for the
presence and validity of parameters, and may perform any
additional checking or processing required.
.*
:h4.Global Symbols
.*
There are several groups of global symbols used by the service
processor macros, the service processor code itself, and/or the
program that will use the service processor.
.*
:h5.Symbols Required By SRV##ID:
.*
:#x.SRV##ID SET:e#x. will define and set a number of unique global
symbols.  The symbols are unique in that each symbol name contains the
ID name specified on the service processor's ID macro.  Symbols
created by :#x.SRV##ID SET:e#x. are only used by :#x.SRV##ID GET:e#x.,
and the developer should not be concerned about them.
.*
:p.:#x.SRV##ID GET:e#x. returns the values of these symbols in a
series of fixed-name symbols to the calling macro.  The individual
symbols and their meanings are:
.*--------------------------------------------------------------------*
:tdef id=tsrvidf cols='*'.
:tdef id=tsrvidd cols='2* 2* 5*' frame=box rules=both
     hdframe=rules compact mindepth=p5
     split=yes concat=yes width=column.
:table id=tsrvids refid=tsrvidd.
:tcap.Variables Returned By ##SRVID GET
:thd.
:c.Keyword
:c.GET Returns
:c.Description
:ethd.
:row.:c.ID
     :c.&amp.#_IDMAC
     :c.The ID value for this service processor session
:row.:c.IDMAC
     :c.&amp.#_IDMAC
     :c.Name of the ID macro that generated this information
:row.:c.ESID
     :c.&amp.#_IDESID
     :c.ID of the associated Environment Support session
:row.:c.ESVA
     :c.&amp.#_IDESVA
     :c.Storage tag containing the ESV address
:row.:c.SPEPNAME
     :c.&amp.#_IDEPN
     :c.Service processor's CL8 entry name
:row.:c.SPEPA
     :c.&amp.#_IDEPA
     :c.Service processor's entry point address
:row.:c.SPTOKEN
     :c.&amp.#_IDTKN
     :c.Storage tag containing token for this service
processor session
:etable.
.*
:h5.Function Code And Return Code Symbols:
.*
All function codes and return codes should have global symbols
assigned to them.  Note that when the copy member is copied into the
calling program, these symbols are defined in open code:  this means
that the caller can reference them with no additional effort, but the
function macros defined in the copy member must reference those global
symbols that they need.  This will always include the function code
symbol, and often will include any global symbols specific to the
service processor.
.*
:fig id=macsyms width=column concat=no.
:figcap.Symbol Definitions For SRVCC
:#x.
.su off
 *---------------------------------------------------------------------*
 *  Service processor module name.
 *---------------------------------------------------------------------*
    GBLC   &CHEAP_CALCULATOR
 &CHEAP_CALCULATOR SETC '''SRVCC    '''
 *---------------------------------------------------------------------*
 *  Function symbols.
 *---------------------------------------------------------------------*
    GBLA   &CC_START,&CC_TERMINATE
    GBLA   &CC_ADD,&CC_SUBTRACT,&CC_MULTIPLY,&CC_DIVIDE
    GBLA   &CC_CLEAR
 &CC_START         SETA   1
 &CC_TERMINATE     SETA   2
 &CC_ADD           SETA   3
 &CC_SUBTRACT      SETA   4
 &CC_MULTIPLY      SETA   5
 &CC_DIVIDE        SETA   6
 &CC_CLEAR         SETA   7
 *---------------------------------------------------------------------*
 *  Return code symbols.
 *---------------------------------------------------------------------*
   GBLA    &CC_INVALID_CC_ID
   GBLA    &CC_INVALID_NUMBER_OF_PARMS
   GBLA    &CC_INVALID_FUNCTION
   GBLA    &CC_OVERFLOW
   GBLA    &CC_PARAMETER_MISSING
 &CC_INVALID_CC_ID           SETA  1
 &CC_INVALID_NUMBER_OF_PARMS SETA 2
 &CC_INVALID_FUNCTION        SETA  3
 &CC_OVERFLOW                SETA  4
 &CC_PARAMETER_MISSING       SETA  5
.su on
:e#x.
:efig.
.*
:h5.Other Symbols:
.*
Generally, if additional global symbols would simplify the tasks of
the service processor's users or its author, they should be provided.
One example of such symbols is the time, date and duration symbols
provided by the Date/Time Service Processor.
.*
:h4.Parameter Validity Checking
.*
Much of the validity checking performed by a service processor can be
performed at assembly time by the function macros.  This is not to say
that the service processor code should not validity-check the
parameters as well:  a caller may use :#x.CALLX:e#x. to call the
service processor, a parameter list may be overlaid at execution time,
or some other unforeseen problem may occur.  Validity checking by the
function macros is primarily for the programmer's benefit, as this
tends to catch common errors (omitted or mutually exclusive
parameters, constants where addresses should be specified, and so on)
at assembly time.
.*
:h4.CALLX Vs. ##PLIST
.*
The Structured Macros include the ##PLIST macro, which is used
internally by PLIST, CALLSUB and CALLX to build parameter lists.
##PLIST has 3 forms: :#x."START":e#x. to initiate a parameter list,
:#x."END":e#x. to terminate one, and :#x."PARM,parameter":e#x.
to add a parameter to the list being built.  ##PLIST is
especially useful for building variable-length parameter lists,
as shown in :figref refid=mac##pl..
:fig id=mac##pl  width=column concat=no.
:figcap.Building A Variable-Length Parameter List Using ##PLIST
:#x.
.su off
 .*
 .* Given a parameter containing a VL list of things (in this case,
 .* "SOURCE=(p1,p2,p3,...,pn)"), generate the base parameter list.
 .*
          ##PLIST START                   | Generate PWA tag, code
          ##PLIST PARM,&#_IDTKN           | Initial parms
          ##PLIST PARM,&SRVPROC_FUNCTION  |
          ##PLIST PARM,&#_ESVA            |
 .*
 .* Generate a VL list from the operand(s) of SOURCE, if any.
 .*
 &N       SETA  1
 .PL_LOOP ANOP  ,                         |
          AIF   (&N GT N'&SOURCE).PL_LOOPEND
          ##PLIST PARM,&SOURCE(&N)        | Entry for SOURCE(n)
 &N       SETA  &N+1                      |
          AGO   .PL_LOOP                  |
 .PL_LOOPEND ANOP ,
 .*
 .* Terminate the parameter list and call service processor.
 .*
          ##PLIST END,VL      | Set X'80' on last parm, load R1
          CALLX  &#_IDEPA     | Call the service processor.
          MEXIT
.su on
:e#x.
:efig.
.*
:h4.The CC_Add Macro
.*
:figref refid=macaddm. illustrates the :#x.CC_Add:e#x. macro,
which uses the basic components of a function macro.
.*
:fig id=macaddm  width=column concat=no.
:figcap.CC_ADD Macro For SRVCC
:#x.
.su off
 *---------------------------------------------------------------------*
 *  CC_Add Macro.
 *  Format:    CC_ADD    ID=CC,
 *                       SPEPA=CC_entry_point_address,  (*)
 *                       SPTOKEN=CC_token_address,      (*)
 *                       ESVA=ESV_address,              (*)
 *                       VALUE=address | constant | register,
 *                       DISPLAY=address | register
 *  (*) - These may be defaulted to values set or generated by CC_ID.
 *---------------------------------------------------------------------*
          MACRO
          CC_ADD  &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,        |              *
                &VALUE=,&DISPLAY=                       |
          GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA  |  SRV##ID
          GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN              |   Symbols
          GBLA  &CC_ADD                                 | Function code
 .*
 .* Obtain service processor ID values.
 .*
          SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),  | Fill out the   *
                ID=&ID,IDMAC=CC_ID,                   | defaults from  *
                SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,        | CC_ID macro.   *
                ESVA=&ESVA.                           |
          AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
 .*
 .* Ensure required parameters are present.
 .*
          AIF  ('&VALUE' EQ '').MISSING     | VALUE is required
          AIF  ('&DISPLAY' EQ '').MISSING   | DISPLAY required
          AIF  (T'&DISPLAY EQ 'N').BADDISP  | DISPLAY can't be constant
 .*
 .* Generate the CC_ADD call.
 .*
          ##PLIST START            |     Start parmlist generation.
          ##PLIST PARM,&#_IDTKN    |     Parameter 1: Token.
          ##PLIST PARM,&CC_ADD     |     Parameter 2: ADD function.
          ##PLIST PARM,&#_IDESVA   |     Parameter 3: ESVA.
          ##PLIST PARM,&VALUE      |     Parameter 4: Function-specific.
          ##PLIST PARM,&DISPLAY    |     Parameter 5: Function-specific.
          ##PLIST END,VL           |     Set VL bit, load register 1
          CALLX  &#_IDEPA          |     Call the service processor.
          MEXIT
 .MISSING MNOTE 8,'Required parameter(s) missing.'
          MEXIT
 .BADDISP MNOTE 8,'Invalid address of ''&DISPLAY'' for DISPLAY.'
 .MEXIT   MEND
.su on
:e#x.
:efig.
.*
.*
:h5.Miscellaneous Macros:
.*
If your service processor makes use of complex parameters
(control blocks, parameters that point to other parmlists,
text with control information, etc.), consider creating some
macros that will help the programmer deal with your service
processor.
As an example, the Message Services service processor includes
a set of macros to generate message CSECTs: these macros do not
produce executable code, but create the message text and
associated data structures that would be tedious and
time-consuming to produce manually.
.*
:h3.The User's Guide And Reference
.*
The :hp1.Service Processors User's Guide And Reference:ehp1. (this
document) should contain a chapter for each publicly-available service
processor, and writing the chapter should be considered among the tasks
involved in writing a new service processor.  The chapters reside in
:#x.SYSTEMS.SRV.SOURCE:e#x., as members :#x.SRVDOCxx:e#x.,
where :#x.xx:e#x. is the service processor's two-character ID.
.*
:h2.Writing The Code
.*
By now, it should be apparent that the task of actually writing the
service processor code is only part of the work involved.  The code
for a service processor, once a basic framework is in place, is
actually fairly simple to produce.  The elements of this framework
exist in all service processors, and indeed are often copied from
an existing service processor when a new one is being written.
.*
:h3.Structured Macro Support
.*
Service processors are invariably written using the Structured Macros.
In addition to the "standard" set of macros and tools, the Structured
Macros contain support intended to facilitate the coding of service
processors.
.*
:h4.OPTIONS=*SRVPRC
.*
The super option *SRVPRC must be coded on the
:#x.BLOCK TYPE=PROGRAM:e#x. macro for any service processor.  In
addition to the options provided by the *PWA super option,
*SRVPRC also includes the following:
.*
:ul.
:li.:hp2.XA:ehp2.: Causes XA-only instructions (BAS, BASR) to be
used for linkage by CALLSUB and CALLX.
.*
:li.:hp2.NO370:ehp2.: Excludes bimodal code around linkage sequences.
.*
:li.:hp2.(REUSPWA,1):ehp2.: Specifies that a reusable PWA should be
used, and that its address is the first parameter in the parameter
list (e.g. the token).  This option causes a PWA to be getmained and
anchored off of this address when the START function is invoked.
.*
:li.:hp2.(FNCODE,2,AL4(1)):ehp2.: Indicates that the function code
will be the second parameter, and that the START function's code
is 1.
.*
:li.:hp2.(ESV,3,PWAAESV):ehp2.: Specifies that the ESV address is the
third parameter, and provides the tag in the PWA where the ESV address
will be stored when START is invoked.  The presence of the ESV
parameter will also cause BLOCK and ENDBLK to call Environment
Support's linkage GETMAIN and FREEMAIN routines, instead of generating
their own GETMAIN and FREEMAIN macros.
.*
:li.:hp2.ERRADDR:ehp2.: Instructs the ERREXIT macro to use a BAS
instruction to call the error exit.  If the :#x.code:e#x. operand of
ERREXIT is provided, the value of :#x.code:e#x. is generated as a
halfword immediately following the BAS instruction.  This allows the
ERREXIT routine to save the address where the error was detected in
the debug area.
:li.:hp2.CLRDEBUG:ehp2.: Specifies whether the debug area should be
cleared upon each entry to the program block.
:eul.
.*
:p.If additional program block options are required or should be
turned off, they can be coded normally following the *SRVPRC super
option.
Refer to the
:hp1.Clemson University Structured Programming Macros
User's Guide And Reference:ehp1. for additional information.
.*
:h4.SMCTRL
.*
The *SRVPRC super option causes the service processor's PWA to be
getmained during the START call, and retained across subsequent
calls: hence, the TERMINATE routine should include the macro
:#x.SMCTRL FREEPWA=YES:e#x..  This sets a flag in the PWA which
will cause the service processor's ENDBLK macro to freemain the
PWA.
.*
:h4.Parameter List Support
.*
The BLOCK macro can set up a base register for the service processor's
parameter list, as well as counting the parameters, by specifying
:#x.(PARMS,(USING,reg),(COUNT,pwa_fullword),VL):e#x.  among the
:#x.OPTIONS:e#x.  and coding the operand :#x.PARMMAP=dsect_name:e#x..
There is also a :#x.COPYPARM:e#x. option which will reserve PWA
storage for the largest possible parameter list and copy the caller's
parameter list to the PWA for each call, ensuring that all unused
parameters in the copy are set to zero.  While :#x.COPYPARM:e#x. may
be desirable, it can take an excessive amount of time if large
parameter lists are in use.
Refer to the
:hp1.Clemson University Structured Programming Macros
User's Guide And Reference:ehp1. for additional information.
.*
:h3.The Parameter List
.*
The typical service processor parameter list, as has already been
demonstrated, contains a common set of parameters at its beginning
followed by zero or more function-specific parameters.  The common
parameters, as well as a suggested format for the parameter list
DSECT, are presented below.
.*
:h4.The Function Code
The first parameter of any service processor call is the address
of a :#x.function code.:e#x.  The
:#x.function code:e#x.
is always a fullword containing some nonzero numeric value, and is
used to request a particular function from the service processor.
Values of F'1' and F'2' are generally used for :#x.Start:e#x.  and
:#x.Terminate:e#x. respectively.
Global symbols are usually defined in the service processor's
copy member for the function codes, as seen in
:figref refid=macsyms..
.*
:h4.The Token
.*
:p.The token serves to uniquely identify a service processor "session",
and is returned by the :#x.START:e#x. function.  Each time it is called,
the service processor will validate its token by ensuring that some
field(s) in its PWA have been set to some identifiable value.  The token
facility allows a program to activate multiple service processor
"sessions" by issuing multiple
:#x.START:e#x. calls and saving the different tokens, then using the
tokens to refer to individual sessions on subsequent calls.
.*
:p.For example, one might wish to read two files and create a third
file:  this could be done by starting three separate File Handler
sessions with appropriate parameters, and using the three tokens as
unique identifiers.  Using the function macros, the caller can isolate
himself somewhat from specifying (or even defining!) the token by
allowing the ID macro (and its call to :#x.##SRVID SET:e#x.)  to
generate the tokens' storage and associate an ID value with each token.
.*
:h4.The ESV Address
.*
As a rule, the ESVA, or ESV address, is passed as the third
parameter to at least the :#x.START:e#x. function. If an ESV address is
provided to the :#x.START:e#x. function, the service processor can
save the address and allow subsequent parameter lists to be shorter:
however, an invalid-token error (where the PWA pointer is not valid)
may degenerate into "unpredictable results" when the service processor
attempts to use Environment Support to save error information.
.*
:h4.Other Parameters
.*
Individual functions will, of course, have zero or more
function-specific parameters.
.*
:h4.The Parameter List DSECT
.*
Typically, the DSECT for the service processor's parameter list will
contain the following:
:ul.
:li.A "common" section at the beginning containing the token and
function code.
:li.Individual sections for each set of function-specific parameters,
using :#x.ORG:e#x. to redefine the storage for each function.
:li.A tag for every parameter.  The tags should contain the function
name (or an abbreviation) for function-specific parameters.
:li.An :#x.EQU:e#x. at the end of the shortest function-specific
section (or at the end of the common section if appropriate), set to
the minimum number of parameters that the service processor supports.
:li.An :#x.EQU:e#x. at the end of each function-specific section, set
to the number of parameters that the function allows.  If the function
supports a variable number of parameters, two
:#x.EQU:e#x.'s should be used for the minimum and maximum number of
parameters.
:li.An :#x.EQU:e#x. at the end of the DSECT, set to the maximum
number of parameters that the service processor supports.
:eul.
.*
:p.The parameter list DSECT for SRVCC appears in
:figref refid=ccparmd..
:fig id=ccparmd width=column concat=no.
:figcap.SRVCC's Parameter List DSECT (Partial)
:#x.
.su off
 title "SRVCC -- Parameter List DSECT"
parmlist          dsect ,             |
prm_CC_id         ds a                | CC_identifier === PWA base
prm_functioncode  ds a                | Function to be performed
prm_min_#         equ (*-parmlist)/4  | Minimum number of parameters
*                                     |   (defined here since there are
*                                     |   functions with no function-
*                                     |   specific parameters).
prm_function_dept equ *               | Function-dependent parameters:
*---------------------------------------------------------------------*
*                  Start function parameters
*---------------------------------------------------------------------*
                  org prm_function_dept
prm_start_esv     ds a                | Environment Support Vector.
prm_start_min_#   equ (*-parmlist)/4  | Minimum # START parameters.
prm_start_max_#   equ (*-parmlist)/4  | Maximum # START parameters.
*---------------------------------------------------------------------*
*                 Terminate function parameters
*---------------------------------------------------------------------*
               org prm_function_dept  |
prm_terminate_#   equ (*-parmlist)/4  | No function-specific parms.
*---------------------------------------------------------------------*
*                 CC_Add function parameters
*---------------------------------------------------------------------*
               org prm_function_dept  |
prm_add_value     ds    f             | Value to add to display.
prm_add_display   ds    f             | Where to store updated display.
prm_add_#         equ (*-parmlist)/4  |
*---------------------------------------------------------------------*
*     Other function-dependent parameter sections defined here.
*---------------------------------------------------------------------*
               :
               :
*---------------------------------------------------------------------*
*            End of function-dependent parameter sections.
*---------------------------------------------------------------------*
                org ,                 |
prm_max_#          equ (*-parmlist)/4 | Maximum number of parameters.
.su on
:e#x.
:efig.
.*
:h4.Parameter List Validation
.*
One of the best ways to avoid abends by a service processor is to
scrutinize the caller's parameters carefully.  Invalid numbers of
parameters, missing parameters and incorrect data provided by the
caller should be checked, and a descriptive error returned if
a problem is detected.
.*
:h5.Common Parameter Validation.
The validations listed here are standard for any service processor.
They should be coded following the program block macro, and prior
to the main case block.
The equivalent code for SRVCC is shown in :figref refid=macent..
.*
:ul.
:li.:hp2.Function code::ehp2.  The function code should be one
supported by the service processor.  Usually, a symbol in the
copy member defining the highest-used function code is used to
check the function code passed by the caller.  A function code
of zero is generally invalid (since it may represent a
missing parameter).
.*
:li.:hp2.Token::ehp2.  After a successful START, the token should
point to the service processor's PWA.  The START code will usually set
some unique value at a fixed offset in the PWA that subsequent
calls can check: generally, this is the PWA address followed by some
short character string (for example, :#x.CC_ID:e#x.) that can be
checked quickly.
.*
:li.:hp2.Number of parameters::ehp2.  The parm count can be set by
:#x.OPTIONS=(...,(PARMS,(COUNT,:hp1.pwa_count_field:ehp1.),...)):e#x.
on the program block macro.  This count field should be checked
against the minimum and maximum number of parameters supported.
:eul.
.*
:h5.Function-Specific Parameter Validation.
.*
The code at the start of an individual function should, first of all,
ensure that the number of parameters passed is acceptable for that
function.  In addition, the validation code should check for missing
parameters (a zero pointer in the parameter list), as well as anything
that might cause a program check (a zero value to be used for
division, invalid packed-decimal data, etc).  Keep in mind, however,
that excessive validity checking will probably impact the service
processor's performance.
.*
:h3.Entry Logic
.*
The BLOCK macro can be made to perform most of the housekeeping chores
of entering a service processor, such as setting up base registers,
clearing the debug area, and counting the parameters.  The remaining
entry logic may then consist of ERREXIT macros: these should ensure
that at least a minimum and no more than a maximum number of parameter
were specified, as well as performing some simple validity check on
the PWA.  This validity check is typically a check for some unique
thing in the PWA that the START function put there.
.*
:fig id=macent  width=column concat=no.
:figcap.Entry Logic For SRVCC
:#x.
.su off
  title "SRVCC -- Initialization"
  block name=SRVCC,type=program,amode=31,rmode=any,                    *
                options=(*srvprc,long,                                 *
                (parms,(using,r11),(count,pwa_number_of_parms),vl)),   *
                parmmap=parmlist,basereg=(r12,r9),                     *
                subopts=(*swa,loadbase)
 * *------------------------------------------------------------------*
 * * Ensure that at least the minimum and no more than the maximum
 * * number of parameters were passed in the parameter list.
 * *------------------------------------------------------------------*
   l     r0,pwa_number_of_parms        | Save number of parms.
   errexit    (ch,r0,lt,=y(prm_min_#)),      Ensure number of parms    *
                or,(c,r0,gt,=a(prm_max_#)),    is within limits.       *
                code=&CC_invalid_number_of_parms
   l     r1,prm_functioncode           | Load the function code into
   l     r1,0(,r1)                     |   a register for testing.
 * *------------------------------------------------------------------*
 * * If the function code is something other than start, make sure that
 * * the PWA contains the eye-catcher string and the correct value for
 * * CC_ID.   If not, then the CC_ID passed in is garbage.
 * *------------------------------------------------------------------*
   if (c,r1,ne,=f'&CC_start')          | If not startup function:
    errexit ((clc,pwa_visual,ne,psd_eyecatcher),  Check eyecatcher &  *
                or,(c,r13,ne,pwa_CC_id)),   PWA's address of itself;  *
                code=&CC_invalid_CC_id |    error if they don't match.
   endif                               | Endif.
.su on
:e#x.
:efig.
.*
:h3.The Main CASE Block
.*
The simplest way to process the function code is with a case block.
This is usually the heart of any service processor.  The individual
functions may be coded as subroutines, or may be handled inline if
they're not too complex. Refer to
:figref refid=macstrt. and
:figref refid=macadd. for examples.
.*
:h3.The START And TERMINATE Functions
.*
The START routine should perform whatever initialization the
service processor requires, such as starting other service
processors or opening files.
In addition, the START function
should establish some unique value or values
in the PWA that can be used by other functions for validity
checking.  Generally, a fullword containing the PWA address
and some character string is used: the character string also
serves as an eyecatcher when a dump is taken.
.*
:p.The TERMINATE routine should take care of any
end-of-task processing required, such as closing files or
terminating other service processors.  The TERMINATE
routine should also include the macro
:#x.SMCTRL FREEPWA=YES:e#x. to cause the program's ENDBLK
to freemain the PWA.
.*
:p.The START and TERMINATE routines for SRVCC are illustrated
in :figref refid=macstrt..
.*
:fig id=macstrt width=column concat=no.
:figcap.The CC_Start And CC_Terminate Functions
:#x.
.su off
    title "SRVCC -- CC_Start Function" |
 * *------------------------------------------------------------------*
 * * Select the code to process the function.
 * *------------------------------------------------------------------*
   caseblk reg=r1                      | Start of function case block.
   space 1                             |
 *  *-----------------------------------------------------------------*
 *  * Start function.
 *  *-----------------------------------------------------------------*
    case &CC_start                     |  Start function.
 *   *----------------------------------------------------------------*
 *   * Set the eyecatcher and the CC_ID fields.   These are checked
 *   * each time the CC server is entered to avoid integrity problems.
 *   *----------------------------------------------------------------*
     mvc   pwa_visual,psd_eyecatcher   |   Set the eyecatcher and the
     st    r13,pwa_CC_id               |   CC_ID are for validity checks
     xc    pwa_clear_start(pwa_clear_length),pwa_clear_start
 *   *----------------------------------------------------------------*
 *   * Make sure that a valid number of parameters are specified.
 *   *----------------------------------------------------------------*
     l     r3,pwa_number_of_parms      |   Load r3 with number of parms.
     errexit    (ch,r3,lt,=y(prm_start_min_#)),or,   Error if out      +
                (ch,r3,gt,=y(prm_start_max_#)),      of bounds.        +
                code=&CC_invalid_number_of_parms
     space 1                           |
     l    r1,pwaaesv                   | Load pointer to ESV.
     using esv,r1                      |
     mvc   pwa_es_epa,esvesepa         | Copy EPA and token addresses
     mvc   pwa_es_token,esvestkn       | for current Env. Support sess.
     drop  r1                          |
     slr   r0,r0                       |
     st    r0,pwa_display              | Clear the "display".
 *  *-----------------------------------------------------------------*
  title "SRVCC -- CC_Terminate Function"
 *  *-----------------------------------------------------------------*
 *  *  CC_Terminate function.
 *  *-----------------------------------------------------------------*
    case &CC_Terminate                 |
     l     r3,pwa_number_of_parms      |   Load r3 with number of parms
     errexit    (ch,r3,lt,=y(prm_terminate_#)),  Error if not correct. +
                code=&CC_invalid_number_of_parms
     smctrl  freepwa=yes               |
 *  *-----------------------------------------------------------------*
.su on
:e#x.
:efig.
.*
:h3.Other Functions
.*
Each service processor function should ensure that it was passed the
appropriate number of parameters, and that they contain or point to
valid information.
.*
:fig id=macadd width=column concat=no.
:figcap.The CC_Add Function
:#x.
.su off
 title "SRVCC -- CC_Add Function"     |
 *  *-----------------------------------------------------------------*
 *  *  CC_Add function.
 *  *-----------------------------------------------------------------*
    case &CC_Add                       | Add function.
     l     r3,pwa_number_of_parms      |   Load r3 w/ number of parms.
     errexit    (ch,r3,ne,=y(prm_add_#)),  Error if not correct.       *
                code=&CC_invalid_number_of_parms
     l32   r1,prm_add_value            |  Get pointer to value to add
     errexit (z),code=&CC_Parameter_Missing  Error if pointer missing
     l     r1,0(r1)                    |  Get the value
     a     r1,pwa_display              |  Add current display contents
     st    r1,pwa_display              |  Update the display
     l32   r2,prm_add_display          |  Get addr of caller's display
     errexit (z),code=&CC_Parameter_Missing  Error if pointer missing
     st    r1,0(r2)                    |  Return display to caller.
     errexit (c,r1,gt,=f'99999999'),   |  Return error for             *
                code=&CC_Overflow      |   "overflow" condition.
 *  *-----------------------------------------------------------------*
.su on
:e#x.
:efig.
.*
:h3.The Main Error Exit
.*
Any service processor should provide as much information as possible
when it detects an error.  Environment Support provides a means to
allow service processors to chain blocks of information (known as
:hp1.debug areas:ehp1.), as shown in :figref refid=macerrx..
.*
:fig id=macerrx width=column concat=no.
:figcap.SRVCC's ERREXIT Routine
:#x.
.su off
  title "SRVCC - General Error Exit"   |
  block type=errexit                   |
 * *------------------------------------------------------------------*
 * * Save module/offset, registers, return-code.
 * *------------------------------------------------------------------*
   stm   r0,r15,gdiregs                | Save registers at time of error
   la    r0,4(,r12)                    | Point to module identification.
   st    r0,gdimodid                   | Save in general debug area.
   mvc   gdirc,0(r14)                  | Copy return code.
   slr   r14,r12                       | Calculate offset at time of err
   sth   r14,gdioffst                  | Save in debug area.
   l     r2,pwaaesv                    | Point r2 to ESV.
   using esv,r2                        | Establish base for ESV.
   es_save_debug_info  id=ES,gdi=debug_area_address
 * *------------------------------------------------------------------*
 * * Look at the error code.  If add'l information would be useful,
 * * stuff into the debug area.
 * *------------------------------------------------------------------*
   lh    r15,gdirc                     | Get return code.
   caseblk reg=r15,mult=1              | Case on return-code.
     case &CC_invalid_function         |
       es_save_debug_info id=ES,       |                               *
                text=(psd_invalid_function,l'psd_invalid_function)
     case &CC_invalid_number_of_parms  |
       es_save_debug_info id=ES,       |                               *
                text=(psd_invalid_#_parms,l'psd_invalid_#_parms)
     case &CC_invalid_CC_ID            |
       es_save_debug_info id=ES,       |                               *
                text=(psd_invalid_CC_ID,l'psd_invalid_CC_ID)
   endcase                             | EndCase.
   drop r2                             |
 * *------------------------------------------------------------------*
 * * Set the return-code and exit.
 * *------------------------------------------------------------------*
   lh    r15,gdirc                     | Set return code.
  endblk rc=(r15)                      |
  title "SRVCC -- Constants"           |
          psd   ,                      |
 psd_eyecatcher  dc    cl8'CHEAP_SP'   | So everyone will know ...
 psd_invalid_function   dc  c"Unsupported function."
 psd_invalid_#_parms    dc  c"Invalid number of parameters."
 psd_invalid_cc_id      dc  c"Invalid token provided."
 psd_overflow           dc  c"Output value is too large for requested *
                format."               |
 psd_undetermined_error   dc  c"Undetermined error."
          ltorg ,                      |
          endpsd ,                     |
.su on
:e#x.
:efig.
.*
Service processors typically contain only one error exit: hence, the
ERREXIT block may be unnamed, which simplifies coding somewhat.  The
error exit expects the :#x.ERRADDR:e#x. option to be set on the
program block: this generates a :#x.BAS  R14,:hp1.errexit:ehp1.:e#x.,
followed by the :#x.ERREXIT:e#x. macro's :#x.CODE:e#x. value,
to call the error exit.  Thus, the error exit can report where it was
called within the service processor.
.*
:p.The Environment Support service processor offers a variety of
diagnostic aids which service processors can use to save error
information.  The error exit shown in :figref refid=macerrx. makes use
of several of these tools, and can be used as a model.  This sample
error exit performs the following:
.*
:ul.
:li.Saves all registers in the General Debug Info (GDI) area.  This area
can be generated by coding :#x.ES_GDI  DSECT=NO:e#x. in the PWA. Refer t
the :#x.ES_GDI:e#x. macro in copy member :#x.SRVESMAC:e#x. for the forma
of the GDI.
.*
:li.Saves the address of the module name (usually +4 from the start of
the main CSECT) in the GDI.
.*
:li.Saves the :#x.ERREXIT:e#x. macro's
:#x.CODE:e#x. value in the GDI.  (This is a halfword
pointed to by R14.)
.*
:li.Passes the GDI to the :#x.ES_SAVE_DEBUG_INFO:e#x. function to be
"stacked" with any existing debug information.
.*
:li.Depending on the type of error, additional information (in the form
messages or hex info) may be saved by the error exit using
:#x.ES_SAVE_DEBUG_INFO:e#x..
.*
:li.Exits with the return code passed
via the :#x.ERREXIT:e#x. macro's
:#x.CODE:e#x. value.
.*
:eul.
:p.
Normally, a service processor :hp2.should not:ehp2. call any service
processor functions other than :#x.ES_SAVE_DEBUG_INFO:e#x. from within
its error exit.  This is because vital information about the error being
handled may exist in the debugging information area and calling a
service processor function causes that information to automatically be
cleared.  If a service processor's error exit needs to use service
processor functions other than :#x.ES_SAVE_DEBUG_INFO:e#x., the
:xmp.
ES_CLEAR_DEBUG_INFO ID=es,ACTION=INHIBIT
:exmp.
function should be used to inhibit clearing of the debugging information
area before calling other service processor functions (any service
processor functions, not just Environment Support functions).
:p.
After all function calls have been made from within the error exit, the
following function call should be made
:xmp.
ES_CLEAR_DEBUG_INFO ID=es,ACTION=ENABLE
:exmp.
to re-ebable clearing of the debugging information area.  When control
is returned to the calling application, it may decide it can tolerate
the error and proceed.  This function does not actually clear the
debugging information area, but allows it to be cleared automatically
the next time any service processor function is invoked.  If this is not
done, and if the calling application proceeds with execution, the
debugging area cannot be cleared and extraneous information may
accumulate there.
.*
.**********************************************************************
