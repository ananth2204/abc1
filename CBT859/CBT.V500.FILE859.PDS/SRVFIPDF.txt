*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
*
*  COPYRIGHT (C) 1987 CLEMSON UNIVERSITY
*
*  Program     SRVFIPDF
*
*  Abstract    This server is the ISPF/PDF Edit file handler for
*              program macros, and reads lines from the file currently
*              being edited by ISPF/PDF Edit or from another member of
*              the same PDS, if a PDS member is currently being edited.
*              File-specifications recognized are:
*
*              null-string : the file being edited.
*              *           : the file being edited.
*              *(member)   : another member of the file.
*
*  Parameters:
*    Two parameters, FileID and FunctionCode, are required for each
*    call to the file manager.  Additional parameters are required for
*    different FunctionCodes.  The entire parameter list required for
*    each function is listed below.
*
*    START
*     CALLX SRVFIPDF,(FileID,&START,ESV,Info,FileName,Length,Access)
*
*    TERMINATE
*     CALLX SRVFIPDF,(FileID,&TERMINATE)
*
*    READLINE
*     CALLX SRVFIPDF,(FileID,&FI_READLINE,Area,AreaSize,Length)
*
*    GET_INFO
*     CALLX SRVFIPDF,(FileID,&FI_GET_INFO,InfoCode,**Info Dependent**)
*                                       &FI_GI_NAME,Area,Size,NameLen)
*                                       &FI_GI_MSG,Area,Size,MsgLen)
*                                       &FI_GI_LRECL,Lrecl)
*                                       &FI_GI_RECFM,Recfm)
*                                       &FI_GI_IDSTRING,IdString)
*
*  The meaning of each parameter is explained below.
*
*    FileID is a fullword used to uniquely identify the opened file.
*      It is initialized during the startup function.
*
*    FunctionCode is a fullword integer that specifies the function to
*      be performed.  Symbolic identifiers are provided for each
*      function and may be accessed by placing a COPY statement for
*      SRVFIMAC in the assembler program.  These symbols should be
*      used in place of actual integer values.  The following
*      FunctionCodes are supported:
*
*      &FI_START
*        Open a new file and assign to it a unique identifier:  FileID.
*        In addition to the FileID and FunctionCode parameters, the
*        parameters ESV, FileName, and NameLength are required. The
*        parameter Info is ignored, but its position in the parameter
*        list must be maintained.
*
*      &FI_TERMINATE
*        Close the file and FileID to zeros.
*
*      &FI_READLINE
*        Read the next line of the file into the provided as the Line
*        parameter.  A maximum of MaxLength characters will be read
*        into the area and the actual length of the line, including
*        truncated characters if any, will be placed in parameter
*        Length.  Return codes will be set to indicate truncation and
*        end of file.
*
*      &FI_GET_INFO
*        Return information, selected by InfoCode, about the file.  The
*        following InfoCodes are supported:
*
*        &FI_GI_MSG
*          Return the most-recently generated message in Area.  If the
*          message is longer than Size, it will be truncated and no
*          indication will be returned.  The size of the returned
*          message (or Size, whichever is smaller) will be returned in
*          the MsgLen parameter.
*
*
*        &FI_GI_NAME
*          Return the fully qualified data set name, including member
*          name if the file is a PDS member.  The name will be returned
*          in Area, and will be truncated to Size if neccessary.  The
*          length of the file's name (or Size, whichever is smaller)
*          will be returned in the NameLen parameter.  If truncation
*          occurs, a message will be generated.
*
*        &FI_GI_LRECL
*          Return the logical record length of the file as a signed
*          halfword value in parameter Lrecl.
*
*        &FI_GI_RECFM
*          Return an eight (8) byte character string describing the
*          file's record format.  Currently, only the first character
*          is used: it is 'F' for fixed length records and 'V' for
*          varying length records.  All remaining characters are set to
*          blanks.
*
*        &FI_GI_IDSTRING
*          Return an eight (8) byte character string that can be used
*          for identification purposes.  This string is not unique.
*          For PDS members, IdString is the member name.  For
*          sequential data sets, it is currently set to blanks.
*
*  Special     This server *must* be invoked from an ISPF/PDF Edit
*  Notes       macro environment.
*
*              The program that uses this server should set CONTROL
*              ERRORS RETURN to insure that a graceful shutdown can be
*              done in the event of an ISPF severe error.  This server
*              equipped to handle all return codes from ISPF services.
*
*  Program     reentrant, problem key and state, standard linkage,
*  Attributes  non-authorized, amode(any), rmode(any)
*
*  Change
*  History     06/26/87 MJM - NEW
*
*---------------------------------------------------------------------*
 EJECT
 COPY  SMSYMS                         | Structured macros symbols.
 COPY  SRVESMAC                       | Environment Support symbols.
 COPY  SRVFIMAC                       | File Handler symbols.
 COPY  SRVSTMAC                       | String Handler symbols.
 EJECT
*---------------------------------------------------------------------*
*
*  Macro:      ISREDIT
*  Purpose:    Invoke the ISREDIT service with an EDIT macro command.
*
*---------------------------------------------------------------------*
         MACRO
         ISREDIT &COMMAND,&MAXRC=0
         GBLC    &PWA
         LCLC    &LENGTH,&BUFFER
&BUFFER  SETC    'TXT&SYSNDX'
&LENGTH  SETC    '=A(L''&BUFFER)'
         PSD     TYPE=PARTIAL
&BUFFER  DC      C&COMMAND
         ENDPSD
         CALLX   ISPLINK,(ISREDIT,&LENGTH,&BUFFER)
         ST      R15,&PWA.ERR_REF
         IF      (C,R15,GT,=A(&MAXRC))
           MESSAGE (XP00008,&PWA.ERR_REF,&BUFFER,&LENGTH)
         ENDIF
         MEND
*---------------------------------------------------------------------*
*
*  Macro:      TRIM
*  Purpose:    Set R15 := the length of a string with trailing blanks
*              removed.
*
*---------------------------------------------------------------------*
         MACRO
         TRIM &ADDR,&LEN
         LA   R14,&ADDR             | R14 -> Start of string.
         L    R15,&LEN              | R15 := Length of string.
         ALR  R15,R14               | R15 -> Past end of string.
         LOOP UNTIL                 | Loop backwards over string.
           BCTR R15,0               |   Back up by one character.
         ENDLOOP UNTIL,((CR,R15,LT,R14),OR,(CLI,0(R15),NE,C' '))
         LA      R15,1(,R15)        | R15 -> Past final non-blank.
         SLR     R15,R14            | R15 := trimmed length.
         MEND
*---------------------------------------------------------------------*
*
*  Macro:      MESSAGE (condition),(parameters)
*              MESSAGE (parameters)
*  Purpose:    Conditionally invoke the message subroutine.
*
*---------------------------------------------------------------------*
         MACRO
         MESSAGE
         AIF   (N'&SYSLIST EQ 1).CALL
         AIF   (N'&SYSLIST EQ 2).COND
         MNOTE 8,'WRONG NUMBER OF PARMS'
.CALL    CALLSUB MESSAGE,&SYSLIST(1)
         MEXIT
.COND    IF   &SYSLIST(1)
           CALLSUB MESSAGE,&SYSLIST(2)
         ENDIF
         MEND
 EJECT
***********************************************************************
**                                                                   **
**                                                                   **
**                         SRVFIPDF Main Program                     **
**                                                                   **
**                                                                   **
***********************************************************************
 BLOCK NAME=SRVFIPDF,TYPE=PROGRAM,AMODE=ANY,RMODE=ANY,R1SAVE=R9,       +
               CPYRGHT='COPYRIGHT (C) 1987 CLEMSON UNIVERSITY',        +
               OPTIONS=(*SRVPRC,LONG),SUBOPTS=(*SWA,LOADBASE)
   ES_ID   ID=ES,SPEPA=&PWA.ESEPA,SPTOKEN=&PWA.ESTOKEN,ESVA=PWAAESV
   ST_ID   ID=ST,SPEPNAME=&STRING_HANDLER,SIZELENGTH=4
   FI_ID   ID=OS_FI,SPEPNAME=&FI_OS_FILE_HANDLER
*---------------------------------------------------------------------*
*  Copy the parameter list to the PWA and turn off high-order bit.
*---------------------------------------------------------------------*
   USING FI_PARMLIST,R9               | Establish addressability.
   LA    R1,FI_PARMLIST               | R1 -> first parameter.
   LA    R2,&PWA.PARMLIST             | R2 -> pwa copy of parmlist.
   LOOP WHILE,(TBIT,0(R1),X'80',OFF)  | Loop over parameters.
     MVC 0(4,R2),0(R1)                |   Copy parameter to pwa.
     LA  R2,4(,R2)                    |   Advance to next parameter.
     LA  R1,4(,R1)                    |   Advance to next parameter.
   ENDLOOP WHILE                      | EndLoop.
   MVC 0(4,R2),0(R1)                  | Copy final parameter to pwa.
   NI  0(R2),X'7F'                    | Turn off high-order bit.
   LA  R1,4(,R1)                      | Point past final parameter.
   SLR R1,R9                          | Get length of entire parmlist.
   SRL R1,2                           | Get number of parameters.
   ST  R1,&PWA.#PARMS                 | Save in PWA for future use.
   LA  R9,&PWA.PARMLIST               | R9 -> Copy of parmlist.
*---------------------------------------------------------------------*
*  Establish addressability on data areas and validate the environment.
*---------------------------------------------------------------------*
   MVC     GDIRC,=H'0'                | Clear out return-code.
   CALLSUB CHECK_PARMS                | Check parms and environment.
*---------------------------------------------------------------------*
*  Use the FunctionCode to determine which subroutine to invoke.
*---------------------------------------------------------------------*
   L       R1,FI_FUNCTIONCODE         | R1 -> function code.
   L       R1,0(R1)                   | R1 := function code.
   CASEBLK REG=R1,MULT=1              | Case on FunctionCode.
     CASE &START                      |   Open a new file.
       CALLSUB START                  |
     CASE &TERMINATE                  |   Close a file.
       CALLSUB TERMINATE              |     Kill file and buffers.
       SMCTRL  FREEPWA=YES            |     Release the PWA on exit.
     CASE &FI_READLINE                |   Read the next line.
       CALLSUB READLINE               |
     CASE &FI_GET_INFO                |   Obtain information.
       CALLSUB GET_INFO               |
     CASE OTHER                       |   Invalid function code.
       MESSAGE (XP00001,0(R2))        |
   ENDCASE                            | EndCase.
*                                     |
   LH   R15,GDIRC                     |
 ENDBLK BLOCK=SRVFIPDF                | Quit w/possible return code.
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: CHECK_PARMS                                            *
*  ABSTRACT:   Check parameters and calling environment.              *
*                                                                     *
***********************************************************************
 BLOCK NAME=CHECK_PARMS,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  If the function code is something other than start, check the
*  eye-catcher string and FileID.  If bad, the FileID is garbage.
*---------------------------------------------------------------------*
   L  R2,FI_FUNCTIONCODE              | R2 -> Fullword function code.
   L  R2,0(R2)                        | R2 := Fullword function code.
   IF (C,R2,NE,=F'&START')            | If not startup function then.
     ERREXIT (CLC,&PWA.VISUAL,NE,EYECATCHER),CODE=&FI_INVALID_FILEID
     ERREXIT (C,R13,NE,&PWA.FILEID),CODE=&FI_INVALID_FILEID
     IF (TBIT,&PWA.F,&PWA.F_IN_ERROR)
       CASEBLK REG=R2,WREG=R2,MULT=1  |   Case on FunctionCode.
       CASE &TERMINATE,&FI_GET_INFO   |     These are always ok.
       CASE OTHER                     |     Cannot do other functions.
         MESSAGE (XP00011)            |     Halted by previous error.
       ENDCASE                        |   EndCase.
     ENDIF                            |   Endif.
   ENDIF                              | Endif.
*---------------------------------------------------------------------*
*  If not invoked from under ISPF, abort execution.
*---------------------------------------------------------------------*
   CALLX   =V(ISPQRY)              | Set R15 = 0 if running under ISPF.
   MESSAGE (TREG,R15,NZ),(XP00003) | If not invoked from ISPF, quit.
 ENDBLK BLOCK=CHECK_PARMS
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: START                                                  *
*  ABSTRACT:   Open a file for the type of access requested.          *
*                                                                     *
***********************************************************************
 BLOCK NAME=START,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  Insure that all parameters were specified, and initialize PWA.
*---------------------------------------------------------------------*
   MVC     &PWA.VISUAL,EYECATCHER   | Both the eyecatcher and the
   ST      R13,&PWA.FILEID          | fileid are validity checks.
   MVI     &PWA.F,X'00'             | Clear out state flags.
   MESSAGE (CLC,&PWA.#PARMS,NE,=F'7'),(XP00002,'START',5)
*                                   |
   L       R1,PWAAESV               | R1 -> Environment Support Vector.
   USING   ESV,R1                   | Establish addressability.
   MVC     &PWA.ESEPA,ESVESEPA      | Copy Environment Support's EPA.
   MVC     &PWA.ESTOKEN,ESVESTKN    | Copy Environment Support's TOKEN.
   DROP    R1                       | Drop addressability.
*---------------------------------------------------------------------*
*  Load and start the string-handler for use in message formatting.
*---------------------------------------------------------------------*
   ES_LOAD_MODULE ID=ES,SPID=ST           | Load String Handler module.
   MESSAGE        (TREG,R15,NZ),(XP00018) | String Handler not loaded.
   ST_START       ID=ST                   | Start the String Handler.
   MESSAGE        (TREG,R15,NZ),(XP00019) | String Handler ¬started.
   EJECT
*---------------------------------------------------------------------*
*  Process the OPTIONS parameter.
*---------------------------------------------------------------------*
*
*  Make sure that all reserved OPTIONS flags are zeros.
*
   L  R2,FI_OPTIONS                      | R2 -> options parameter.
   IF (TBIT,0(R2),&FI_OC_RESERVED,ANY)   | If any reserved options.
     MESSAGE (XP00014,(R2))              |   Issue an error message.
   ENDIF                                 | EndIf.
*
*  Separate the remaining flags to make checking for specific values
*  and combinations of values easier.
*
   MVC   &PWA.MODE,0(R2)                 | Save INPUT/OUTPUT flag.
   NI    &PWA.MODE,&FI_OC_MODE           | Mask off other bits.
*---------------------------------------------------------------------*
*  Define ISPF variables, parse the file-specification, and open file.
*---------------------------------------------------------------------*
   CALLX   ISPLINK,(VDEFINE,NAME_LIST,&PWA.VARS,FORMAT_LIST,           +
               LENGTH_LIST,'LIST    ')
   ST      R15,&PWA.ERR_REF
   MESSAGE (TREG,R15,NZ),(XP00004,&PWA.ERR_REF)
   SBIT    &PWA.F,&PWA.F_VDEFINED
*---------------------------------------------------------------------*
*  Get the data set name and member name from ISPF.
*---------------------------------------------------------------------*
   ISREDIT '(PDFTXT1) = DATASET'      | Get the data set name.
   MVC     &PWA.DSN,&PWA.TXT1         | Copy data set name.
   TRIM    &PWA.DSN,=A(L'&PWA.DSN)    | Get the dsname's length.
   ST      R15,&PWA.DSN_LEN           | Save the dsname's length.
*                                     |
   ISREDIT '(PDFTXT1) = MEMBER'       | Get the member name.
   MVC     &PWA.MEM,&PWA.TXT1         | Copy member name.
   TRIM    &PWA.MEM,=A(L'&PWA.MEM)    | Get the member's length.
   ST      R15,&PWA.MEM_LEN           | Save the member's length.
*---------------------------------------------------------------------*
*  Parse the file specification and open the file.
*---------------------------------------------------------------------*
   CALLSUB PARSE_FILESPEC              | Scan file-specification.
   CALLSUB OPEN_FILE                   | Open the specified file.
 ENDBLK BLOCK=START
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: PARSE_FILESPEC                                         *
*  ABSTRACT:   Parse the file-specification of the START function.    *
*                                                                     *
***********************************************************************
 BLOCK NAME=PARSE_FILESPEC,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  R4 -> file-specification.  R5 -> last character in file-spec.
*---------------------------------------------------------------------*
   L       R4,FI_FILENAME                | R4 := file-spec's text.
   L       R5,FI_NAMELENGTH              | R5 -> length of file-spec.
   L       R5,0(,R5)                     | R5 := length of file-spec.
   LA      R5,0(R5,R4)                   | R5 -> past end of file-spec.
   BCTR    R5,0                          | R5 -> last char.
*---------------------------------------------------------------------*
*  Parse the file-name, which must be either null, or an asterisk (*).
*---------------------------------------------------------------------*
   IF (CR,R4,LE,R5)                      | If filename is non-null.
     MESSAGE (CLI,0(R4),NE,C'*'),(XP00100)   If not *, invalid syntax.
     LA      R4,1(,R4)                   |   Advance past the '*'.
*---------------------------------------------------------------------*
*    If a member name was specified, parse it and set up for OS file.
*---------------------------------------------------------------------*
     IF (CR,R4,LE,R5)                    |   If there is anything left.
       MESSAGE (CLI,0(R4),NE,C'('),(XP00100)   If not (member), error.
       IF (CLI,0(R5),EQ,C')')            |     If closing paren.
         BCTR  R5,0                      |       R5 -> end of MEMBER.
       ENDIF                             |     EndIf.
       SLR     R5,R4                     |     R5 := length.
       MESSAGE (TREG,R5,NP),(XP00100)    |     Syntax error.
       LA      R4,1(,R4)                 |     R4 -> start of MEMBER.
       MESSAGE (CLC,&PWA.MEM_LEN,EQ,=F'0'),(XP00009,&PWA.DSN,          +
               &PWA.DSN_LEN,&PWA.MEM)
       LA      R14,&PWA.MEM              |     R14 -> member name stg.
       LA      R15,L'&PWA.MEM            |     R15 := Length of stg.
       ST      R5,&PWA.MEM_LEN           |     Save specified member.
       ICM     R5,8,=C' '                |     Pad copy with blanks.
       MVCL    R14,R4                    |     Copy member name.
       SBIT    &PWA.F,&PWA.F_OS_SERVER   |     Use the OS file server.
     ENDIF                               |   EndIf.
   ENDIF                                 | EndIf.
 ENDBLK BLOCK=PARSE_FILESPEC
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: OPEN_FILE                                              *
*  ABSTRACT:   Set up for reading the file.                           *
*                                                                     *
***********************************************************************
 BLOCK NAME=OPEN_FILE,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  If using the ISREDIT interface, set up current/last line numbers.
*---------------------------------------------------------------------*
   IF (NOT,(TBIT,&PWA.F,&PWA.F_OS_SERVER)) | If using ISREDIT.
     ISREDIT '(PDFTXT1) = RECFM'           |   Get the record format.
     MVC     &PWA.RECFM,&PWA.TXT1          |   Save the record format.
     ISREDIT '(PDFINT1) = LRECL'           |   Get the LRECL.
     L       R0,&PWA.INT1                  |   R0 := Fullword value.
     STH     R0,&PWA.LRECL                 |   Save as a halfword.
*                                          |
     ISREDIT '(PDFUSR) = USER_STATE'       |   Save the user's state.
     SBIT    &PWA.F,&PWA.F_USER_STATE      |   Remember it is saved.
     ISREDIT 'NUMBER = OFF'                |   Turn off numbering.
*                                          |
     ISREDIT '(PDFINT1) = LINENUM .ZFIRST',MAXRC=19
     MESSAGE (TREG,R15,NZ),(XP00005,'.ZFIRST',7)
     MVC     &PWA.LINE#,&PWA.INT1          |   Copy to current line#.
     ISREDIT '(PDFINT1) = LINENUM .ZLAST',MAXRC=19
     MESSAGE (TREG,R15,NZ),(XP00005,'.ZLAST',6)
     MVC     &PWA.LAST#,&PWA.INT1          |   Copy to last line#.
*---------------------------------------------------------------------*
*  Else, use the OS file server to open the file.
*---------------------------------------------------------------------*
   ELSE                                    | Else.
     ES_LOAD_MODULE ID=ES,SPID=OS_FI       |  Load the OS File Handler.
     MESSAGE        (TREG,R15,NZ),(XP00010)   Cannot load File Handler.
*
     ST_FORMAT ID=ST,STRING=&PWA.TXT1,RESULTLEN=&PWA.INT1,             +
               CONTROL='''{CL?}({CL?})''',                             +
               SOURCE=(&PWA.DSN,&PWA.DSN_LEN,&PWA.MEM,&PWA.MEM_LEN)
     MESSAGE   (TREG,R15,NZ),(XP00000)     |  Internal error.
*
     FI_START  ID=OS_FI,                   |  Start OS File Handler    +
               FILE=(&PWA.TXT1,&PWA.INT1), |    using 'DSNAME(MEMBER)' +
               OPTIONVALUE=*FI_OPTIONS,    |    and the OPTIONS and    +
               INFO=*FI_INFO               |    INFO parms passed in.
     ST      R15,&PWA.ERR_REF              |  Save the return code.
     ERREXIT (TREG,R15,NZ),NAME=OS_EXIT    |  Exit if in error.
   ENDIF                                   | EndIf.
*---------------------------------------------------------------------*
*  Mark the file as successfully opened.
*---------------------------------------------------------------------*
   SBIT &PWA.F,&PWA.F_OPENED
 ENDBLK BLOCK=OPEN_FILE
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: READLINE                                               *
*  ABSTRACT:   Obtain the next line from an already open file.        *
*                                                                     *
***********************************************************************
 BLOCK NAME=READLINE,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  Validate the current file status and the parameter list.
*---------------------------------------------------------------------*
   IF (TBIT,&PWA.F,&PWA.F_OPENED,OFF) If file is not opened.
     MESSAGE (XP00012,'READLINE',8) |   Issue an error message.
   ELSEIF (TBIT,&PWA.F,&PWA.F_EOF)  | ElseIf at end of file.
     ERREXIT CODE=&FI_END_OF_FILE   |   Exit w/EOF return-code.
   ELSEIF (CLI,&PWA.MODE,NE,&FI_OC_INPUT)
     MESSAGE (XP00017)              |
   ENDIF                            | EndIf.
*---------------------------------------------------------------------*
*  If using the OS file server, then get it to do the work.
*---------------------------------------------------------------------*
   IF (TBIT,&PWA.F,&PWA.F_OS_SERVER)    If using the OS file server.
     FI_READLINE ID=OS_FI,LINE=(*FI_RL_AREA,*FI_RL_AREA_SIZE),         +
               RESULTLEN=*FI_RL_LENGTH
     ST        R15,&PWA.ERR_REF     |      Save return code.
     ERREXIT   (TREG,R15,NZ),NAME=OS_EXIT  Exit with return code.
     LEAVE     BLOCK=*              |      Exit normally.
   ENDIF                            |    EndIf.
*---------------------------------------------------------------------*
*  If &PWA.LINE# > &PWA.LAST# then past end of file.
*---------------------------------------------------------------------*
   IF (CLC,&PWA.LINE#,GT,&PWA.LAST#)  If past end of file, then.
     SBIT    &PWA.F,&PWA.F_EOF      |   Set the end-of-file flag.
     ERREXIT CODE=&FI_END_OF_FILE   |   Issue a message and quit.
   ENDIF                            | EndIf.
*---------------------------------------------------------------------*
*  Invoke ISREDIT to obtain the current line.
*---------------------------------------------------------------------*
   MVC     &PWA.INT1,&PWA.LINE#     | Copy current line# to variable.
   ISREDIT '(PDFTXT1) = LINE &&PDFINT1',MAXRC=19
   MESSAGE (C,R15,EQ,=F'4'),(XP00202,=A(L'&PWA.TXT1))
   MESSAGE (TREG,R15,NZ),(XP00006,&PWA.LINE#,&PWA.ERR_REF)
*                                   |
   L       R1,&PWA.LINE#            | R1 := current relative line#.
   A       R1,=F'1'                 | Advance to next line.
   ST      R1,&PWA.LINE#            | Save for next time.
*---------------------------------------------------------------------*
*  Copy the line to the caller's buffer.
*---------------------------------------------------------------------*
   TRIM    &PWA.TXT1,=A(L'&PWA.TXT1) Remove trailing blanks from line.
   ST      R15,&PWA.LINE_LEN       | Save current line's length.
   LM      R2,R3,FI_RL_AREA        | R2/R3 -> text area, length.
   L       R3,0(R3)                | R3 := length of text area.
   LA      R4,&PWA.TXT1            | R4 -> input line.
   L       R5,&PWA.LINE_LEN        | R5 := length of input line.
   IF      (CR,R3,GT,R5)           | If more than enough room.
     LR    R3,R5                   |   Use only exact amount needed.
   ENDIF                           | EndIf.
   L       R6,FI_RL_LENGTH         | R6 -> line length parm.
   ST      R3,0(R6)                | Save length of returned line.
*                                  |
   IF (TREG,R5,P)                  | If anything to copy, then.
     IF (C,R3,GT,=F'256')          |   If too long for an MVC instr.
       MVCL    R2,R4               |     Copy information to caller.
       MESSAGE CC4,(XP00201,0(R6)) |     Record was truncated.
     ELSE                          |   Else.
       BCTR    R3,0                |     Subtract 1 for EX instr.
       EXI     R3,(MVC,0(0,R2),0(R4))    Copy information to caller.
       LA      R3,1(,R3)           |     Add 1 back for comparison.
       MESSAGE (CR,R3,LT,R5),(XP00201,0(R6))  Record was truncated.
     ENDIF                         |   EndIf.
   ENDIF                           | EndIf.
 ENDBLK BLOCK=READLINE
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: TERMINATE                                              *
*  ABSTRACT:   Close out and cleanup any/all files.                   *
*                                                                     *
***********************************************************************
 BLOCK NAME=TERMINATE,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  If using the ISREDIT interface, reset the NUMBER mode.
*---------------------------------------------------------------------*
   IF (NOT,(TBIT,&PWA.F,&PWA.F_OS_SERVER)) If using ISREDIT.
     IF (TBIT,&PWA.F,&PWA.F_OPENED)  |   If file has been opened.
       IF (TBIT,&PWA.F,&PWA.F_USER_STATE)  If user's state was saved.
         ISREDIT 'USER_STATE = (PDFUSR)'     Restore user's state.
         RBIT    &PWA.F,&PWA.F_USER_STATE    No longer saved.
       ENDIF                         |     EndIf.
     ENDIF                           |   EndIf.
*---------------------------------------------------------------------*
*  If using the OS file server, terminate it and unload it.
*---------------------------------------------------------------------*
   ELSE                              | Else using the OS server.
     IF (CLC,&PWA.OS_FI_SPEPA,NE,=F'0')   If the OS server is loaded.
       IF (CLC,&PWA.OS_FI_SPTOKEN,NE,=F'0') If the OS server started.
         FI_TERMINATE ID=OS_FI       |       Terminate File Handler.
       ENDIF                         |     EndIf.
       ES_UNLOAD_MODULE ID=ES,SPID=OS_FI   Unload OS File Handler.
     ENDIF                           |   EndIf.
   ENDIF                             | EndIf.
*---------------------------------------------------------------------*
*  Delete the variables that were created by SRVFIPDF.
*---------------------------------------------------------------------*
   IF (TBIT,&PWA.F,&PWA.F_VDEFINED)     | If variables were defined.
     CALLX ISPLINK,(VDELETE,NAME_LIST)  |   Delete them.
     RBIT  &PWA.F,&PWA.F_VDEFINED       |   No longer defined.
   ENDIF                                | EndIf.
*---------------------------------------------------------------------*
*  Terminate and unload the String Handler.
*---------------------------------------------------------------------*
   IF (CLC,&PWA.ST_SPEPA,NE,=F'0')     | If String Handler is loaded.
     IF (CLC,&PWA.ST_SPTOKEN,NE,=F'0') |   If String Handler started.
       ST_TERMINATE ID=ST              |     Terminate File Handler.
     ENDIF                             |   EndIf.
     ES_UNLOAD_MODULE ID=ES,SPID=ST    |   Unload String Handler.
   ENDIF                               | EndIf.
*
   RBIT  &PWA.F,&PWA.F_OPENED
 ENDBLK BLOCK=TERMINATE
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: GET_INFO                                               *
*  ABSTRACT:   Return selected information to the caller.             *
*                                                                     *
***********************************************************************
 BLOCK NAME=GET_INFO,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  Make sure that the information sub-code parameter was supplied.
*---------------------------------------------------------------------*
   MESSAGE (CLC,&PWA.#PARMS,LT,=F'3'),(XP00002,'GET_INFO',8)
*---------------------------------------------------------------------*
*  Call the routine that obtains the requested information.
*---------------------------------------------------------------------*
   L       R2,FI_GI_FUNCTION          | R2 -> information sub-code.
   L       R1,0(,R2)                  | R1 := information sub-code.
   CASEBLK REG=R1,WREG=R1,MULT=1      | Case on information sub-code.
     CASE &FI_GI_MSG                  |   Get last message issued.
       CALLSUB GET_INFO_MSG           |
     CASE &FI_GI_NAME                 |   Get file's full name.
       CALLSUB GET_INFO_NAME          |
     CASE &FI_GI_LRECL                |   Get logical record length.
       CALLSUB GET_INFO_LRECL         |
     CASE &FI_GI_RECFM                |   Get record format.
       CALLSUB GET_INFO_RECFM         |
     CASE &FI_GI_IDSTRING             |   Get identification string.
       CALLSUB GET_INFO_IDSTRING      |
     CASE OTHER                       |   Invalid information code.
       MESSAGE (XP00015,0(R2))        |
   ENDCASE                            | EndCase
 ENDBLK BLOCK=GET_INFO                |
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: GET_INFO_MSG                                           *
*  ABSTRACT:   Return the current message to the caller.              *
*                                                                     *
***********************************************************************
 BLOCK NAME=GET_INFO_MSG,TYPE=SUBROUTINE
   MESSAGE (CLC,&PWA.#PARMS,NE,=F'6'),(XP00002,'GET_INFO (MSG)',14)
*---------------------------------------------------------------------*
*  If using the OS file server, then get it to do the work.
*---------------------------------------------------------------------*
   IF (TBIT,&PWA.F,&PWA.F_OS_SERVER)  If using the OS file server.
     FI_GET_INFO ID=OS_FI,MSG=(*FI_GI_AREA,*FI_GI_AREA_SIZE),          +
               MSGLEN=*FI_GI_LENGTH
     ST      R15,&PWA.ERR_REF       |   Save return code.
     ERREXIT (TREG,R15,NZ),NAME=OS_EXIT Exit with return code.
     LEAVE   BLOCK=*                |   Exit normally.
   ENDIF                            | EndIf.
*---------------------------------------------------------------------*
*  Copy the formatted message to the user's buffer.
*---------------------------------------------------------------------*
   LM   R2,R3,FI_GI_AREA            | R2/R3 -> text area, length.
   L    R3,0(R3)                    | R3 := length of text area.
   LM   R4,R5,&PWA.MSG_DATA         | R4/R5 -> message text/length.
   L    R5,0(R5)                    | R5 := length of message.
   IF   (CR,R5,GT,R3)               | If too long to fit in area.
     LR R5,R3                       |   Reduce to exact length.
   ENDIF                            | EndIf.
   L    R1,FI_GI_LENGTH             | R1 -> message length parm.
   ST   R5,0(R1)                    | Save length of returned msg.
   ICM  R5,8,=C' '                  | Pad copied text with blanks.
   MVCL R2,R4                       | Copy information to caller.
 ENDBLK BLOCK=GET_INFO_MSG
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: GET_INFO_NAME                                          *
*  ABSTRACT:   Return the file's name to the caller.                  *
*                                                                     *
***********************************************************************
 BLOCK NAME=GET_INFO_NAME,TYPE=SUBROUTINE
   MESSAGE (CLC,&PWA.#PARMS,NE,=F'6'),(XP00002,'GET_INFO (NAME)',15)
*---------------------------------------------------------------------*
*  If using the OS file server, then get it to do the work.
*---------------------------------------------------------------------*
   IF (TBIT,&PWA.F,&PWA.F_OS_SERVER)  If using the OS file server.
     FI_GET_INFO ID=OS_FI,NAME=(*FI_GI_AREA,*FI_GI_AREA_SIZE),         +
               NAMELEN=*FI_GI_LENGTH
     ST      R15,&PWA.ERR_REF       |   Save return code.
     ERREXIT (TREG,R15,NZ),NAME=OS_EXIT Exit with return code.
     LEAVE   BLOCK=*                |   Exit normally.
   ENDIF                            | EndIf.
*---------------------------------------------------------------------*
*  Build the full file name in the caller's buffer.
*---------------------------------------------------------------------*
   IF   (CLC,&PWA.MEM_LEN,NE,=F'0')     | If a MEMBER specified.
     LA R2,=F'1'                        |   R2 -> length of '(' or ')'.
   ELSE                                 | Else.
     LA R2,=F'0'                        |   R2 -> null length value.
   ENDIF                                | EndIf.
*                                       |
   ST_FORMAT ID=ST,STRING=(*FI_GI_AREA,*FI_GI_AREA_SIZE),              +
               RESULTLEN=*FI_GI_LENGTH,                                +
               CONTROL='{CL?}{CL?}{CL?}{CL?}',                         +
               SOURCE=(&PWA.DSN,&PWA.DSN_LEN,'(',(R2),                 +
               &PWA.MEM,&PWA.MEM_LEN,')',(R2))
   IF (C,R15,EQ,=F'&ST_TRUNCATED')      | If data truncated, then.
     CALLSUB MESSAGE,(XP00007)          |   Issue a message and quit.
   ENDIF                                | EndIf.
 ENDBLK BLOCK=GET_INFO_NAME
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: GET_INFO_LRECL                                         *
*  ABSTRACT:   Return the file's logical record length as a halfword. *
*                                                                     *
***********************************************************************
 BLOCK NAME=GET_INFO_LRECL,TYPE=SUBROUTINE
   MESSAGE (CLC,&PWA.#PARMS,NE,=F'4'),(XP00002,'GET_INFO (LRECL)',16)
*---------------------------------------------------------------------*
*  If using the OS file server, then get it to do the work.
*---------------------------------------------------------------------*
   IF (TBIT,&PWA.F,&PWA.F_OS_SERVER)    | If using the OS file server.
     FI_GET_INFO ID=OS_FI,LRECL=*FI_GI_AREA
     ST          R15,&PWA.ERR_REF       |   Save return code.
     ERREXIT     (TREG,R15,NZ),NAME=OS_EXIT Exit with return code.
     LEAVE       BLOCK=*                |   Exit normally.
   ENDIF                                | EndIf.
*---------------------------------------------------------------------*
*  Return the file's logical record length, which is in the DCB.
*---------------------------------------------------------------------*
   IF (TBIT,&PWA.F,&PWA.F_OPENED,OFF)
     MESSAGE (XP00016,'GET_INFO (LRECL)',16)
   ENDIF                                | EndIf.
*                                       |
   L       R2,FI_GI_AREA                | R2 -> Halfword for LRECL.
   MVC     0(2,R2),&PWA.LRECL           | Copy LRECL to parameter.
 ENDBLK BLOCK=GET_INFO_LRECL
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: GET_INFO_RECFM                                         *
*  ABSTRACT:   Return the file's record format in an 8-byte field.    *
*                                                                     *
***********************************************************************
 BLOCK NAME=GET_INFO_RECFM,TYPE=SUBROUTINE
   MESSAGE (CLC,&PWA.#PARMS,NE,=F'4'),(XP00002,'GET_INFO (RECFM)',16)
*---------------------------------------------------------------------*
*  If using the OS file server, then get it to do the work.
*---------------------------------------------------------------------*
   IF (TBIT,&PWA.F,&PWA.F_OS_SERVER)    | If using the OS file server.
     FI_GET_INFO ID=OS_FI,RECFM=*FI_GI_AREA
     ST          R15,&PWA.ERR_REF       |   Save return code.
     ERREXIT     (TREG,R15,NZ),NAME=OS_EXIT Exit with return code.
     LEAVE       BLOCK=*                |   Exit normally.
   ENDIF                                | EndIf.
*---------------------------------------------------------------------*
*  Return a single character indicating the file's record format.
*---------------------------------------------------------------------*
   IF (TBIT,&PWA.F,&PWA.F_OPENED,OFF)
     CALLSUB MESSAGE,(XP00016,'GET_INFO (RECFM)',16)
   ELSE                                 | Else.
     L     R2,FI_GI_AREA                |   R2 -> Halfword for LRECL.
     MVC   0(8,R2),&PWA.RECFM           |   Copy RECFM to Area.
   ENDIF                                | EndIf.
 ENDBLK BLOCK=GET_INFO_RECFM
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: GET_INFO_IDSTRING                                      *
*  ABSTRACT:   Return an 8-character identification string.           *
*                                                                     *
***********************************************************************
 BLOCK NAME=GET_INFO_IDSTRING,TYPE=SUBROUTINE
   IF (CLC,&PWA.#PARMS,NE,=F'4')        | If not exactly 4 parameters.
     MESSAGE (XP00002,'GET_INFO (IDSTRING)',19)
   ENDIF                                | EndIf.
*---------------------------------------------------------------------*
*  If using the OS file server, then get it to do the work.
*---------------------------------------------------------------------*
   IF (TBIT,&PWA.F,&PWA.F_OS_SERVER)    | If using the OS file server.
     FI_GET_INFO ID=OS_FI,IDSTRING=*FI_GI_AREA
     ST          R15,&PWA.ERR_REF       |   Save return code.
     ERREXIT     (TREG,R15,NZ),NAME=OS_EXIT Exit with return code.
     LEAVE       BLOCK=*                |   Exit normally.
   ENDIF                                | EndIf.
*---------------------------------------------------------------------*
*  Return a single character indicating the file's record format.
*---------------------------------------------------------------------*
   IF (TBIT,&PWA.F,&PWA.F_OPENED,OFF)
     CALLSUB MESSAGE,(XP00016,'GET_INFO (IDSTRING)',19)
     LEAVE   BLOCK=*                    |   Should never get here.
   ELSE                                 | Else.
     L   R2,FI_GI_AREA                  |   R2 -> Return area.
     MVC 0(8,R2),=CL8' '                |   Initialize it to blanks.
     L   R5,&PWA.MEM_LEN                |   R5 := length of member.
     IF  (TREG,R5,P)                    |   If there is a member name.
       BCTR  R5,0                       |     Subtract 1 for EX instr.
       EXI   R5,(MVC,0(0,R2),&PWA.MEM)  |     Copy member name.
     ELSE                               |   Else.
*      Do nothing.                      |
     ENDIF                              |   EndIf.
   ENDIF                                | EndIf.
 ENDBLK BLOCK=GET_INFO_IDSTRING
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: MESSAGE                                                *
*  ABSTRACT:   Format a message and exit the program.                 *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=MESSAGE
   LR   R2,R1                          | R2 -> Parameter list.
   L    R4,0(R2)                       | R4 -> Message's ADCON.
   L    R4,0(R4)                       | R4 -> Message Length, Text.
*---------------------------------------------------------------------*
*  Count arguments and invoke String Handler to format the message.
*---------------------------------------------------------------------*
   LA R15,8                            | Nothing formatted yet.
   IF (CLC,&PWA.ST_SPEPA,NE,=F'0')     | If String Handler loaded.
     IF (CLC,&PWA.ST_SPTOKEN,NE,=F'0') |   If String Handler started.
       LR   R1,R2                      |     R1 -> parm before 1st arg.
       LOOP WHILE,(TBIT,0(R1),X'80',OFF)     While not @ last arg.
         LA    R1,4(,R1)               |      Advance to next arg.
       ENDLOOP WHILE                   |     EndLoop.
       SR      R1,R2                   |     R1 := length of plist.
       SRL     R1,2                    |     R1 := #arguments.
       ST      R1,&W.COUNT             |     Save for ST_FORMAT.
       ST_FORMAT ID=ST,STRING=&PWA.ERR_MSG,RESULTLEN=&PWA.ERR_MSG_LEN, +
               CONTROL=(4(R4),0(R4)),SOURCELIST=(4(R2),&W.COUNT)
     ENDIF                             |   EndIf.
   ENDIF                               | EndIf.
*---------------------------------------------------------------------*
*  If the message could not be formatted, use the unformatted version.
*---------------------------------------------------------------------*
   IF (TREG,R15,NZ)                    | If nothing formatted.
     L    R5,0(R4)                     |   R5 := length of msg text.
     LA   R1,L'&PWA.ERR_MSG            |   R1 -> Length of target area.
     IF   (CR,R5,GT,R1)                |   If too long to fit, then.
       LR R5,R1                        |     Use as much as possible.
     ENDIF                             |   EndIf.
     ST   R5,&PWA.ERR_MSG_LEN          |   Save length of message
     LR   R1,R5                        |   Set target to exact size.
     LA   R4,4(R4)                     |   R4 -> message text.
     LA   R0,&PWA.ERR_MSG              |   R0 -> Target area of move.
     MVCL R0,R4                        |   Copy message text.
   ENDIF                               | EndIf.
*---------------------------------------------------------------------*
*  Invoke the error exit with the message's return-code.
*---------------------------------------------------------------------*
   IF (CLI,&PWA.ERR_MSG+7,EQ,C'W')     | If a warning message,
     ERREXIT CODE=&FI_WARNING          |   Exit with the warning-code.
   ELSEIF (CLI,&PWA.ERR_MSG+7,EQ,C'E') | ElseIf an error message,
     ERREXIT CODE=&FI_ERROR            |   Exit with the error-code.
   ELSEIF (CLI,&PWA.ERR_MSG+7,EQ,C'S') | ElseIf an error message,
     ERREXIT CODE=&FI_SEVERE           |   Exit with the severe-code.
   ELSEIF (CLI,&PWA.ERR_MSG+7,EQ,C'X') | ElseIf invalid filename.
     MVI     &PWA.ERR_MSG+7,C'S'       |   Change to 'severe' message.
     ERREXIT CODE=&FI_INVALID_SYNTAX   |   Exit with the syntax-code.
   ELSE                                | Else
     ERREXIT CODE=&FI_SEVERE           |   Exit with the error-code.
   ENDIF                               | EndIf.
 ENDBLK BLOCK=MESSAGE
           SWA
&W.COUNT   DS  F
           ENDSWA
 EJECT
***********************************************************************
*                                                                     *
*  Error exit for all functions in the file handler.                  *
*                                                                     *
***********************************************************************
 BLOCK TYPE=ERREXIT
*---------------------------------------------------------------------*
*  Save module/offset, registers, return-code.
*---------------------------------------------------------------------*
   STM   R0,R15,GDIREGS          | Save registers at time of error.
   LA    R0,4(,R12)              | Point to module identification.
   ST    R0,GDIMODID             | Save in general debug area.
   MVC   GDIRC,0(R14)            | Copy return code.
   SLR   R14,R12                 | Calculate offset at time of error.
   STH   R14,GDIOFFST            | Save in debug area.
   ES_SAVE_DEBUG_INFO ID=ES,GDI=GDI
*---------------------------------------------------------------------*
*  Check the return-code, and save the debugging message accordingly.
*---------------------------------------------------------------------*
   LH    R3,GDIRC                | R3 := return-code.
   CASEBLK REG=R3,MULT=1         | Case on return-code.
     CASE &FI_END_OF_FILE        |
       L  R5,XP00200             |     R5 -> Length of message.
       LA R4,4(R5)               |     R4 -> Message text.
     CASE &FI_WARNING,&FI_ERROR,&FI_SEVERE,&FI_INVALID_SYNTAX
       LA R4,&PWA.ERR_MSG        |     R4 -> Formatted message text.
       LA R5,&PWA.ERR_MSG_LEN    |     R5 -> Length of formatted msg.
     CASE OTHER                  |   Unknown error-code.
       L  R5,XP00000             |     R5 -> Length of message.
       LA R4,4(R5)               |     R4 -> Message text.
   ENDCASE                       | EndCase.
   STM   R4,R5,&PWA.MSG_DATA     | Save address/length of message.
   ES_SAVE_DEBUG_INFO ID=ES,TEXT=((R4),(R5))
*---------------------------------------------------------------------*
*  Set the final return-code and exit.
*---------------------------------------------------------------------*
   LH R15,GDIRC                  | R15 := Return-code for this call.
   IF (C,R15,GT,=F'&FI_WARNING') | If greater than a warning.
     SBIT &PWA.F,&PWA.F_IN_ERROR |   Set the error flag in the PWA.
   ENDIF                         | EndIf.
 ENDBLK
 EJECT
***********************************************************************
*                                                                     *
*  Error exit for when SRVFIPDF is acting as an interface to the OS   *
*        File Handler.                                                *
*                                                                     *
***********************************************************************
 BLOCK TYPE=ERREXIT,NAME=OS_EXIT
   L    R15,&PWA.ERR_REF                    | R15 := SRVFIOS's RC.
   IF   (C,R15,EQ,=F'&FI_INVALID_SYNTAX')   | If passthru code, then.
     LA  R15,&FI_ERROR                      |   Change to ERROR code.
   ELSEIF (C,R15,EQ,=F'&FI_END_OF_FILE')    | ElseIf End-of-file.
     SBIT &PWA.F,&PWA.F_EOF                 |   Set EOF flag in PWA.
   ENDIF                                    | EndIf.
 ENDBLK BLOCK=OS_EXIT
 EJECT
*---------------------------------------------------------------------*
*
*  Static Data
*
*---------------------------------------------------------------------*
               PSD
               LTORG
EYECATCHER     DC   C'SRVFIPDF' | Value moved to PWA on initialize.
ISPLINK        DC   V(ISPLINK)  | EPA of ISPF interface routine.
VDEFINE        DC   C'VDEFINE ' | Service name for defining variables.
VDELETE        DC   C'VDELETE ' | Service name for deleting variables.
ISREDIT        DC   C'ISREDIT ' | Service name for edit macro commands.
*
* The following three lists name and map the ISPF variables used in
* this program.  The storage used to hold their values begins at
* &PWA.VARS.
*
NAME_LIST      DC   C'(PDFINT1 PDFINT2 PDFTXT1 PDFTXT2 PDFUSR)'
FORMAT_LIST    DC   CL8'FIXED',CL8'FIXED',CL8'CHAR',CL8'CHAR',CL8'CHAR'
LENGTH_LIST    DC   A(L'&PWA.INT1,L'&PWA.INT2,L'&PWA.TXT1,L'&PWA.TXT2)
               DC   A(L'&PWA.USER_STATE)
*                               |
            MACRO
&LABEL      TRANTAB
            LCLA &N
&LABEL      DS   0XL256        |
.NEWROW     DC   AL1(&N+0,&N+1,&N+2,&N+3,&N+4,&N+5,&N+6,&N+7)
            DC   AL1(&N+8,&N+9,&N+10,&N+11,&N+12,&N+13,&N+14,&N+15)
&N          SETA &N+16
            AIF  (&N LT 256).NEWROW
            MEND
FOLD        TRANTAB            | Translate tbl for uppercase conv.
            ORG  FOLD+C'a'     | Fold lowercase 'a' - 'i'.
            DC   C'ABCDEFGHI'  |
            ORG  FOLD+C'j'     | Fold lowercase 'j' - 'r'.
            DC   C'JKLMNOPQR'  |
            ORG  FOLD+C's'     | Fold lowercase 's' - 'z'.
            DC   C'STUVWXYZ'   |
            ORG
            EJECT
*---------------------------------------------------------------------*
* Messages are made up of a message identifier followed by a control
* string.  The message identifier has the format
*
*   XInnnnns
*
* where the characters XI always begin an XsubID-handler's message,
* nnnnn is the unique message number, and s indicates the message's
* severity.
*
* Severity                  Meaning
* --------   ---------------------------------------------
*    I       Informational.
*    W       Warning message.
*    E       An error occurred, but execution can continue.
*    S       Severe error.  Execution cannot continue.
*    X       Filename syntactically invalid.
*    C       Critical error.  Indicates a probable programming error.
*
*---------------------------------------------------------------------*
            MACRO
            MSG   &NUMBER,&SEVERITY,&TEXT
            LCLC  &MSGID,&OLDLOC
&OLDLOC     SETC  '&SYSLOC'
&MSGID      SETC  'XP&NUMBER'
&MSGID      DC    A(MSGT&SYSNDX)
XSMSGS      LOCTR ,
MSGT&SYSNDX DC    AL4(MSGL&SYSNDX),C'&MSGID&SEVERITY',C' ',C&TEXT
MSGL&SYSNDX EQU   *-MSGT&SYSNDX-4
&OLDLOC     LOCTR ,
            MEND
*
 MSG 00000,C,'Unknown error.'
 MSG 00001,C,'Invalid function-code parameter: {I}.'
 MSG 00002,C,'Wrong number of parameters for the {CL?} function.'
 MSG 00003,S,'SRVFIPDF must be invoked from an ISPF environment.'
 MSG 00004,C,'Unable to define internal variables. VDEFINE return code +
               was {I}.'
 MSG 00005,S,'Unable to obtain the value of the {CL?} builtin label.'
 MSG 00006,S,'ISREDIT (PDFTXT1) = LINE {I} ended with return code {I}.'
 MSG 00007,S,'File name truncated in GET_NAME function.'
 MSG 00008,C,'ISREDIT return code = {I}. Command was: "{CL? T}".'
 MSG 00009,S,'Data set {CL? T} is not partitioned, but member {CL8 T} w+
               as specified.'
 MSG 00010,S,'Unable to load the OS file server to read another member +
               of a partitioned data set.'
 MSG 00011,C,'Processing halted due to a previous error.'
 MSG 00012,S,'Function {CL?} not performed; file is not open.'
 MSG 00013,C,'OUTPUT mode not supported for files being edited with ISP+
               F Edit.'
 MSG 00014,C,'Invalid OPTIONS value: B"{BL1}".'
 MSG 00015,C,'Invalid information code ({I}) for the GET_INFO function.+
               '
 MSG 00016,S,'Function {CL?} not performed; file is not open.'
 MSG 00017,E,'READLINE cannot be invoked for files opened as OUTPUT.'
 MSG 00018,S,'Unable to load the String Handler (SRVSTR).'
 MSG 00019,S,'Unable to start the String Handler (SRVSTR).'
*
 MSG 00100,X,'Invalid syntax in file name.'
 MSG 00200,W,'End of file.'
 MSG 00201,E,'Input record was truncated to {I} characters.'
 MSG 00202,E,'Line truncated by ISREDIT to {I} characters.'
*
            ENDPSD
            EJECT
***********************************************************************
*                                                                     *
*  Program Work Area                                                  *
*                                                                     *
***********************************************************************
                     PWA
&PWA.VISUAL          DS  CL(L'EYECATCHER)
&PWA.FILEID          DS  A           | Unique file identifier.
&PWA.#PARMS          DS  F           | Number of parms passed in.
&PWA.PARMLIST        DS  CL(4*10)    | Copy of parameter list.
*                                    |
&PWA.ESEPA           DS  A           | Environment Support's EPA.
&PWA.ESTOKEN         DS  F           | Environment Support's TOKEN.
&PWA.MODE            DS  X           | Options INPUT/OUTPUT flag.
*                                    |
&PWA.STEPA           DS  A           | String-handler's entry-point.
&PWA.STTKN           DS  F           | String-handler's token.
&PWA.F               DS  X           | State information.
&PWA.F_OS_SERVER     EQU B'10000000' |   Using the OS file server.
&PWA.F_OPENED        EQU B'01000000' |   File successfully opened.
&PWA.F_IN_ERROR      EQU B'00100000' |   Halted due to an error.
&PWA.F_EOF           EQU B'00010000' |   End of file has been reached.
&PWA.F_USER_STATE    EQU B'00001000' |   User state saved in PWA.
&PWA.F_VDEFINED      EQU B'00000100' |   ISPF Variables are defined.
*                                    |
&PWA.MEM_LEN         DS  F           | Length of member name.
&PWA.MEM             DS  CL8         | Member name of PDS.
&PWA.DSN_LEN         DS  F           | Length of PDSname(member).
&PWA.DSN             DS  CL44        | OS data set name.
&PWA.LAST#           DS  F           | Last line number = .ZLAST
&PWA.LINE#           DS  F           | Current line number.
&PWA.LINE_LEN        DS  F           | Length of current input line.
&PWA.LRECL           DS  H           | Logical record length.
&PWA.RECFM           DS  CL8         | Record format: 'F' or 'V'.
*                                    | Error tracking information.
&PWA.PLIST           DS  CL(4*17)    |   Parameter list area.
&PWA.ERR_REF         DS  F           |   Latest return/reason code.
&PWA.MSG_DATA        DS  2F          |   Address/length of message.
&PWA.ERR_MSG_LEN     DS  F           |   Short description of error.
&PWA.ERR_MSG         DS  CL256       |   Error, Warning, or Info.
                     ES_GDI DSECT=NO |   Debugging area.
*---------------------------------------------------------------------*
* The following fields *must* correspond exactly to the mapping set up
* for VDEFINE by the PSD values NAME_LIST, FORMAT_LIST, and LENGTH_LIST
*---------------------------------------------------------------------*
&PWA.VARS            DS  0F          | Storage for VDEFINEd variables.
&PWA.INT1            DS  F           |   General integer variable.
&PWA.INT2            DS  F           |   General integer variable.
&PWA.TXT1            DS  CL256       |   General text variable.
&PWA.TXT2            DS  CL256       |   General text variable.
&PWA.USER_STATE      DS  CL2048      |   Saved user's state.
                     ENDPWA
                     EJECT
***********************************************************************
*  Parameter list for the File Handler.
***********************************************************************
           FI_PARMLIST        | File Handler parameter list.
           EJECT
           ES_ESV
           END
/*
//C.SYSLIB DD
//         DD
//         DD DISP=SHR,DSN=SYSTEMS.SRV.SOURCE
//         DD DISP=SHR,DSN=SYSTEMS.RACF.MACLIB
//         DD DISP=SHR,DSN=SYS2.MACLIB
//         DD DISP=SHR,DSN=SYS1.AMODGEN
//L.SYSLIB DD DISP=SHR,DSN=SYS1.ISPFLINK
//L.SYSIN  DD *
  INCLUDE SYSLIB(ISPQRY)
  INCLUDE SYSLIB(ISPLINK)
//
