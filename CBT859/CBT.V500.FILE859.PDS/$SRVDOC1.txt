
  Service Processors User's Guide And Reference

Clemson University Research Foundation
Service Processors
User's Guide And Reference

Last revision: July 14, 1997

Clemson University Research Foundation

26 Sep 2011

This document contains information that is proprietary and confidential
information of the Clemson University Research Foundation. This document
may not be reproduced in part or in whole without the written permission
of the Clemson University Research Foundation.

Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License in this library as member $LICENSE, or from the
Apache.Org web site. <http://www.apache.org/licenses/LICENSE-2.0>

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

€Clemson University Research Foundation 1989,1990,1992.

------------------------------------------------------------------------


  Preface <#ToC_1>

Service processors were created at Clemson University to assist in the
development and maintenance of assembly language programs. They provide
an efficient, flexible environment that can be used as a foundation for
constructing large and complex programs. Service processors provide a
variety of functions, including many of those directly available to
programs written in high-level programming languages, and are designed
so that new functions can be added as needed.

In conjunction with the /*Clemson University Structured Macros*/,
service processors bring assembler language programming to a level
approaching that of high-level programming languages. However, their use
is not restricted to assembly language programs: any program written in
a language that supports standard System/370 calling conventions can
benefit from service processors.

The Clemson University Service Processors are packaged in a load library
and accompanying macro library. The load library is accessed through the
system linklist or link pack area, so no STEPLIB is required for its
use. The macro library should be concatenated to the assembler's SYSLIB
file, and requires the IBM High-Level Assembler.

------------------------------------------------------------------------


  Table of Contents

  *

    *Preface* <#Header_1>

  *

    *Figures* <#HDRFIGLIST_START>

------------------------------------------------------------------------

/*Part 1. Service Processors User's Guide*/ <#HDRPART1>

  *

    *Chapter 1. Introduction to Service Processors* <#Header_4>

      o

        What Are Service Processors? <#Header_5>

      o

        How Programs use Service Processors <#Header_6>

      o

        The Service Processor Execution Environment <#Header_7>

  *

    *Chapter 2. Using Service Processors* <#Header_8>

      o

        Copy Members <#Header_9>

      o

        Loading Service Processors <#Header_10>

      o

        Invoking Services <#Header_11>

          +

            Symbol Definitions <#Header_12>

          +

            Function Macros and Service Processor Identifiers <#Header_13>

      o

        Checking Return Codes <#Header_14>

      o

        Multiple Sessions With the Same Processor <#Header_15>

      o

        Cascading Service Processors of the Same Type <#Header_16>

      o

        Putting it Together <#Header_17>

  *

    *Chapter 3. Service Processors And The Structured Macros* <#Header_18>

      o

        Useful Structured Macro Constructs <#Header_19>

      o

        Service Processor Support <#Header_20>

          +

            BLOCK Macro <#Header_21>

          +

            ERREXIT Macro <#Header_22>

          +

            User-Defined Conditions <#Header_23>

------------------------------------------------------------------------

/*Part 2. Service Processors Reference*/ <#HDRSPREF>

  *

    *Chapter 4. Description Of Service Processors* <#Header_25>

      o

        Service Processors <#Header_26>

      o

        Naming Conventions <#Header_27>

      o

        Linkage Conventions <#HDRLINKAGE>

  *

    *Chapter 5. Date/Time Services* <#Header_29>

          +

            Obtaining Date/Time Services' Symbols & Macros <#Header_30>

          +

            Establishing Date/Time Services Defaults <#Header_31>

          +

            Identifying Date/Time Services <#Header_32>

          +

            Loading Date/Time Services <#Header_33>

          +

            Specifying Date, Time And Interval Formats <#Header_34>

          +

            The General Input Format <#Header_35>

          +

            Common Parameters <#Header_36>

          +

            Description of Parameters. <#Header_37>

          +

            Return Codes <#Header_38>

          +

            Return Codes <#Header_39>

      o

        Date/Time Services Functions <#Header_40>

  *

    *Chapter 6. Environment Support* <#HDRSRVES>

      o

        Symbols & Macros <#Header_42>

      o

        Establishing Service Processor Identifiers <#Header_43>

      o

        Choosing an Environment Support Load Module <#Header_44>

      o

        Loading Environment Support <#Header_45>

      o

        Data Areas <#Header_46>

          +

            The Environment Support Vector <#Header_47>

          +

            Module Name Tables <#HDRMNTS>

          +

            The Debugging Information Area <#Header_49>

      o

        Common Parameters <#Header_50>

      o

        Complete List of Environment Support Return Codes <#Header_51>

      o

        Environment Support Service Processor Functions and Macros
        <#Header_52>

  *

    *Chapter 7. File Handlers* <#HDRSRVFI>

      o

        The Standard File Handler <#Header_54>

      o

        The Source Management System File Handler <#Header_55>

      o

        The ISPF/PDF File Handler <#Header_56>

      o

        The XsubID File Handler <#Header_57>

      o

        Preparing to use a File Handler <#Header_58>

          +

            Obtaining File Handler Symbols & Macros <#Header_59>

          +

            Establishing File Handler Defaults <#Header_60>

          +

            Identifying the File Handler <#Header_61>

          +

            Loading the File Handler <#Header_62>

      o

        Common Parameters <#Header_63>

      o

        Return Codes <#Header_64>

      o

        File Handler Service Processor Functions <#Header_65>

  *

    *Chapter 8. Item Manager* <#Header_66>

          +

            Obtaining Item Manager Symbols & Macros <#Header_67>

          +

            Establishing Item Manager Defaults <#Header_68>

          +

            Identifying the Item Manager <#Header_69>

          +

            Loading the Item Manager <#Header_70>

          +

            Common Parameters <#Header_71>

          +

            Complete List of Item Manager Return Codes <#Header_72>

      o

        Item Manager Service Processor Functions <#Header_73>

  *

    *Chapter 9. Memory Manager* <#HDRSRVMEM>

      o

        Preparing to Use the Memory Manager <#Header_75>

          +

            Common Parameters <#Header_76>

          +

            Complete List of Memory Manager Return Codes <#Header_77>

      o

        Memory Manager Service Processor Functions <#Header_78>

  *

    *Chapter 10. Message Services* <#Header_79>

          +

            Defining Messages <#Header_80>

          +

            Obtaining Message Services' Symbols & Macros <#Header_81>

          +

            Establishing Message Services Defaults <#Header_82>

          +

            Identifying Message Services <#Header_83>

          +

            Loading Message Services <#Header_84>

          +

            Common Parameters <#Header_85>

          +

            Return Codes <#Header_86>

      o

        Message Services Functions <#Header_87>

  *

    *Chapter 11. Printline* <#Header_88>

          +

            Basic Operation Of Printline <#Header_89>

          +

            The Format Of A Page <#Header_90>

          +

            Obtaining Printline Symbols & Macros <#Header_95>

          +

            Establishing Printline Defaults <#Header_96>

          +

            Identifying Printline <#Header_97>

          +

            Loading Printline <#Header_98>

          +

            Common Parameters <#Header_99>

          +

            Return Codes <#Header_100>

      o

        Printline Service Processor Functions <#Header_101>

  *

    *Chapter 12. String Handler* <#HDRSRVST>

      o

        Preparing to Use the String Handler <#Header_103>

      o

        Common Parameters <#Header_104>

      o

        Complete List of String Handler Return Codes <#Header_105>

      o

        String Handler Service Processor Functions <#Header_106>

  *

    *Chapter 13. Symbol Manager* <#HDRSRVSY>

          +

            Obtaining Symbol Manager Symbols & Macros <#Header_110>

          +

            Common Symbol Manager Parameters <#Header_111>

          +

            Identifying the Symbol Manager <#Header_112>

          +

            Loading the Symbol Manager <#Header_113>

          +

            Complete List of Symbol Manager Return Codes <#Header_114>

      o

        Symbol Manager Service Processor Functions <#Header_115>

  *

    *Appendix A. Writing A Service Processor* <#Header_116>

      o

        Service Processor Conventions <#Header_117>

      o

        The "Cheap Calculator" Service Processor <#HDRSPCC>

      o

        Components Of A Service Processor <#Header_119>

          +

            The Service Processor Load Module <#Header_120>

          +

            The Service Processor Copy Member <#Header_121>

          +

            The User's Guide And Reference <#Header_134>

      o

        Writing The Code <#Header_135>

          +

            Structured Macro Support <#Header_136>

          +

            The Parameter List <#Header_140>

          +

            Entry Logic <#Header_149>

          +

            The Main CASE Block <#Header_150>

          +

            The START And TERMINATE Functions <#Header_151>

          +

            Other Functions <#Header_152>

          +

            The Main Error Exit <#Header_153>

  *

    *Index* <#HDRINDEX_START>

------------------------------------------------------------------------


  Figures <#ToC_2>

 1.

    Obtaining Service Processor Symbols and Macros <#Figure_1>

 2.

    Loading service processors <#FIGLOSPS>

 3.

    Code that uses service processor symbols <#FIGCTUSPS>

 4.

    Code that does not use service processor symbols <#FIGCTNSPS>

 5.

    Establishing service processor defaults <#FIGESPD>

 6.

    Code that uses service processor interface macros <#FIGCTUSPIM>

 7.

    Generated Program Work Area (PWA) fields <#FIGGPWAFS>

 8.

    Checking service processor return codes <#FIGCSPRCS>

 9.

    TSO command buffer layout <#Figure_9>

10.

    Example command buffer contents <#Figure_10>

11.

    The DISPLAY program <#FIGDISPLAY>

12.

    Parameter list conventions <#FIGPLIST>

13.

    Environment Support's Symbols and Macros <#Figure_13>

14.

    Module Name Table Layout <#FIGMNTSTR>

15.

    Sample Message Module Definition <#Figure_15>

16.

    Printline Header Definition Example <#FIGPLHDREX>

17.

    Sample Header Definition With Page Counter <#FIGPLFMTHD>

18.

    User-Defined Condition Example <#FIGMACDEFX>

19.

    DEFUCOND Macros For SRVCC <#FIGMACDEFU>

20.

    CC_ID Macro For SRVCC <#FIGMACID>

21.

    Symbol Definitions For SRVCC <#FIGMACSYMS>

22.

    Building A Variable-Length Parameter List Using ##PLIST <#FIGMAC##PL>

23.

    CC_ADD Macro For SRVCC <#FIGMACADDM>

24.

    SRVCC's Parameter List DSECT (Partial) <#FIGCCPARMD>

25.

    Entry Logic For SRVCC <#FIGMACENT>

26.

    The CC_Start And CC_Terminate Functions <#FIGMACSTRT>

27.

    The CC_Add Function <#FIGMACADD>

28.

    SRVCC's ERREXIT Routine <#FIGMACERRX>

------------------------------------------------------------------------


  Part 1. Service Processors User's Guide <#ToC_3>

------------------------------------------------------------------------


  Chapter 1. Introduction to Service Processors <#ToC_4>

You are driving home from work when suddenly your car's engine, knowing
that your warranty expired just yesterday, starts sputtering and spews
out lots of black smoke. Then it dies completely and you have to call
for a wrecker to take it to the shop for repairs. When you finally make
it home, its too late to cook anything so you order a pizza and have it
delivered. After eating, you load up the dishwasher and turn it on only
to find out that a pipe has burst. Water floods your kitchen. You turn
the dishwasher off and, grumbling to yourself while cleaning up the
mess, resolve to call a plumber in the morning. What a lousy day!

What does all of this have to do with service processors? Well, in real
life you call on various companies or service industries to do things
for you. Towing service was provided by the wrecker, car repairs by the
shop, cooking and delivery by the pizza restaurant, water and
electricity to operate your dishwasher were provided by utility
companies, and plumbing repairs by the plumber. Many of the services you
call on are things you might be able to do for yourself, but its easier
and often more efficient to have it done by someone else.

Service processors perform analagous services for programs. Services are
available for extracting information about a program's execution
environment, efficiently managing storage, manipulating textual data,
reading from arbitrary files, and managing symbols. A service processor
groups related services together into a single "company" that programs
can call upon without having to worry about the implementation details.
This can dramatically reduce the amount of code that must be written to
develop a new program.

------------------------------------------------------------------------


    What Are Service Processors? <#ToC_5>

Service processors are an integrated system of subroutines that serve as
building-blocks for program construction. Each service processor is a
subroutine that provides one or more related services, usually for
managing a specific type of software resource such as a file or a symbol
table. Service processors take advantage of the building-blocks offered
by other service processors, building on their services wherever
possible. The services within a processor share internal code and
working storage, as well as data and other resources. They are able to
retain information and resources across invocations, providing them with
the ability to keep track of things on a program's behalf. Additional
features of service processors include a built-in mechanism for tracking
debugging information and a method of supporting multiple execution
environments. Some of the service processors available include:

  *

    Date/Time: provides services for obtaining the current date and time
    and for manipulating date/time values. The Date/Time service
    processor supports numerous formats and may be used to convert
    values from one format to another. Services are also available for
    subtracting or adding a duration to a given date/time value, and for
    calculating the duration between two date/time values.

  *

    Environment Support: acts as an interface between the calling
    program and its execution environment (an operating system, online
    system, high-level language, etc), and provides services for
    extracting information such as the time and date, userid and group
    name, and whether a program is executing in the forground or
    background.

  *

    Memory Manager: provides an efficient storage management scheme for
    programs that need to frequently allocate small items of storage and
    then free them all at once. Storage can be set up in separate
    /heaps/ and entire storage heaps can be released with a single call.
    Items of storage can, of course, be individually released as well.

  *

    String Handler: provides services for manipulating and formatting
    string data, and services for converting various types of data to
    and from character format.

  *

    Symbol Manager: provides services for storing symbols with attached
    information and retrieving them by name at a later time. The
    information attached to a symbol is controlled entirely by the
    calling program.

  *

    File Handlers: provide services for reading from various types of
    files without concern for the actual record layout or access method
    required.

  *

    PrintLine: this service processor provides an application program
    with a good set of basic report-writing services. It can be used to
    set up headers and footers on the printed page, keep track of the
    current page number and perform automatic ejects.

For a more detailed look at the services available, see Part 2, "Service
Processors Reference" <#HDRSPREF>: there is a separate chapter for each
service processor that describes its purpose and details the services it
provides. Also, scanning the table of contents is a quick way to get a
feel for what services are available.

------------------------------------------------------------------------


    How Programs use Service Processors <#ToC_6>

Programs use service processors by calling them with a function code
indicating the service to be performed (the terms function and service
are used interchangeably in this manual). For example, a program might
call the Environment Support service processor with the ES_GET_TIME
function code to obtain the current time and date. The program would, of
course, provide parameters in which Environment Support would return the
requested information. Each function of a service processor has its own
set of function-specific parameters.

Before a program can use any of a processor's services, it must
establish a session with the service processor by calling it with the
START function code. The *start* function establishes a session between
the calling program and the service processor, and returns a unique
session identifier to the caller. This session identifier, or /token/,
usually represents a software resource being managed by the newly
established session, such as an open file or a new symbol table.

The token returned by *start* is used on future calls to the service
processor, along with a function code, to identify the session (or
resource) for which a service is being requested. A program can start as
many sessions as desired, and most service processors provide optional
parameters that tailor the new session to the caller's needs. A
complimentary function code, TERMINATE, ends a service processor session
and resets the session identifier token to a null value.

------------------------------------------------------------------------


    The Service Processor Execution Environment <#ToC_7>

Although service processors reside in separate subroutines, they are
interdependent to varying degrees. For example, the Symbol Manager uses
the Memory Manager to deal with the storage in which symbols are kept
and the File Handler uses the String Handler to format its messages. One
service processor, Environment Support, is used by all service
processors for such basic services as allocating working storage,
managing debugging information, and gaining access to other service
processors.

When Environment Support is started (invoked with the START function
code), it creates a data area called the Environment Support Vector that
represents an execution environment for service processors. Environment
Support returns the address of the ESV to the calling program, which is
then responsible for passing it to other service processors as they are
started. Thus, Environment Support must be the first service processor
started. Once the address of the ESV has been passed to a service
processor it will be retained, so there is no need to provide it with
subsequent function calls.

------------------------------------------------------------------------


  Chapter 2. Using Service Processors <#ToC_8>

This chapter describes the general concepts and procedures needed to
make use of service processors. The focus in this chapter (as well as in
the rest of the manual) is on assembly language programming with the
/*Clemson University Structured Macros*/, and all examples are shown in
assembler. However, service processors can be used from any language
that supports standard System/370 linkage conventions and they have the
potential of running within the execution environment of high-level
languages such as PL/I.

While service processors are easy to use, some setting up is required
before a program can begin invoking their functions. As mentioned in the
introduction, each service processor is a subroutine. The subroutine,
which must be invoked in 31-bit addressing mode, must be loaded into
storage somehow and invoked with the START function code before any
other functions can be used. Also, all service processors depend on the
execution environment established by Environment Support, which must be
loaded and started before any other service processors.

------------------------------------------------------------------------


    Copy Members <#ToC_9>

Each service processor has a /copy member/ containing macros for
invoking its services and symbols that name its load module, function
codes, and return codes. Assembler programs should have a COPY statement
for each service processor they use, and it should appear as close to
the beginning of the program as possible. For example, the following
statements would be used to obtain the symbolic definitions and macros
for the Environment Support and String Handler service processors:

*Figure 1. Obtaining Service Processor Symbols and Macros* <#FT_Figure_1>

  COPY  SRVESMAC    | Copy Environment Support's symbols & macros.
  COPY  SRVSTMAC    | Copy the String Handler's symbols & macros.


After a service processor's copy member has been processed, all of its
symbols and macros are available for use. Look in the appropriate
chapters of Part 2, "Service Processors Reference" <#HDRSPREF> for
complete descriptions of service processor copy members and how to use
them. Programs written in a language other than assembler should contain
equivalent symbols or named constants for the function codes and return
codes they use.

------------------------------------------------------------------------


    Loading Service Processors <#ToC_10>

As a general rule, each service processor resides in its own load
module, although there are exceptions that will be described later. The
only service processor that must be loaded directly by the application
program is Environment Support. How this is done is dependent on the
programming language used and the environment in which it is running.
Once Environment Support has been loaded and started, other service
processors may be loaded through the ES_LOAD_MODULE function. For
example, an assembler program running under MVS/XA might issue the
following sequence of instructions to load Environment Support and two
other service processors.

*Figure 2. Loading service processors* <#FT_FIGLOSPS>



  LOAD  EPLOC==&MVS_ENVIRONMENT_SUPPORT   | Load Environment Support.
  ST    R0,ES_EPA                         | Save its EPA.
  CALLX ES_EPA,(ES_TKN,&ES_START,ES_ESVA) | Start Environment Support.
  CALLX ES_EPA,(ES_TKN,&ES_LOAD_MODULE,&STRING_HANDLER,ST_EPA)
  CALLX ES_EPA,(ES_TKN,&ES_LOAD_MODULE,&MEMORY_MANAGER,MM_EPA)

------------------------------------------------------------------------


    Invoking Services <#ToC_11>

Service processors are called using standard linkage conventions for
programs running in 31-bit addressing mode (see "Linkage Conventions"
<#HDRLINKAGE>). The first two parameters of the subroutine call are
always the same: a *token* followed by a *function code*. The minimum
call to invoke one of a service processor's functions looks like the
following for an assembler program written with the Structured Macros:

CALLX SERVICE_PROCESSOR,(TOKEN,FUNCTION_CODE)

The *function code* parameter is a four byte signed binary integer that
selects the desired function. Two function codes, START and TERMINATE,
are supported by all service processors. Other function codes are
dependent on the particular service processor. The *token* parameter is
a four byte value whose contents are set by the service processor itself
when the START function is invoked. Additional parameters may be
required or optional, depending on the service being requested.


      Symbol Definitions <#ToC_12>

The function code symbols provided by a service processor's copy member
should always be used in place of the actual integer values they
represent. For example, the instructions in Figure 3 <#FIGCTUSPS> load
and start three service processors and invoke several of their functions.

*Figure 3. Code that uses service processor symbols* <#FT_FIGCTUSPS>



     LOAD  EPLOC==C&MVS_ENVIRONMENT_SUPPORT
     ST    R0,ES_EPA
     CALLX ES_EPA,(ES_TKN,&ES_START,ES_ESVA)
     CALLX ES_EPA,(ES_TKN,&ES_LOAD_MODULE,&STRING_HANDLER,ST_EPA)
     CALLX ST_EPA,(ST_TKN,&ST_START,ES_ESVA)
     CALLX ES_EPA,(ES_TKN,&ES_LOAD_MODULE,&MEMORY_MANAGER,MM_EPA)
     CALLX MM_EPA,(MM_TKN,&MM_START,ES_ESVA)
     CALLX MM_EPA,(MM_TKN,&MM_OBTAIN_STORAGE,80,MSG_BUFFER)
     CALLX ES_EPA,(ES_TKN,&ES_GET_FORMATTED_TIME,TIME,,DATE)
     L     R2,MSG_BUFFER
     CALLX ST_EPA,(ST_TKN,&ST_FORMAT,(R2),80,MSG_LENGTH,               +
                'Execution beginning at %CL5 on %CL8.',36,TIME,DATE)
     CALLX ES_EPA,(ES_TKN,&ES_DISPLAY_MESSAGE,(R2),MSG_LENGTH)



Because symbols are used for specifying function codes, it is easy to
determine what functions are being invoked. After the instructions in
Figure 3 <#FIGCTUSPS> have been executed, a message like the one below
will be written to the user's terminal or to the job message log:

Execution beginning at 14:10 on 06/01/89.

Use of service processor symbols makes for code that is much easier to
understand than the following instruction sequence, which produces
identical code to that in Figure 3 <#FIGCTUSPS> but uses the actual
integer values instead of their symbolic names:

*Figure 4. Code that does not use service processor symbols* <#FT_FIGCTNSPS>



     LOAD  EPLOC==C'SRVESMVS'
     ST    R0,ES_EPA
     CALLX ES_EPA,(ES_TKN,1,ES_ESVA)
     CALLX ES_EPA,(ES_TKN,5,'SRVSTR',ST_EPA)
     CALLX ST_EPA,(ST_TKN,1,ES_ESVA)
     CALLX ES_EPA,(ES_TKN,5,'SRVMEM',MM_EPA)
     CALLX MM_EPA,(MM_TKN,1,ES_ESVA)
     CALLX MM_EPA,(MM_TKN,3,80,MSG_BUFFER)
     CALLX ES_EPA,(ES_TKN,24,TIME,JULIAN,,DATE)
     L     R2,MSG_BUFFER
     CALLX ST_EPA,(ST_TKN,3,(R2),80,MSG_LENGTH,                        +
              'Execution beginning at %CL5 on %CL8.',36,TIME,DATE)
     CALLX ES_EPA,(ES_TKN,7,(R2),MSG_LENGTH)


      Function Macros and Service Processor Identifiers <#ToC_13>

In programs that make heavy use of service processor functions, coding
subroutine calls can be a chore. After all, the first few items in the
subroutine call are always the same: an entry point address, a token
value, and a function code. Furthermore, if a large number of service
processors or service processor sessions are needed, creating labels and
storage for the entry point addresses and token values can become
tedious (e.g. ES_EPA, ES_TKN, etc).

The macros defined within each service processor's copy member can do
most of this automatically. There is a separate macro for invoking each
service processor function. The name of each function invocation macro
is the same as that of the function it invokes, and all values are
specified using keyword parameters instead of the positional parameters
used in CALLX statements.

In addition to the function invocation macros, each service processor
has a macro for establishing /service processor identifiers/. A service
processor identifier is a collection of parameters that will be
automatically used whenever the identifier is referenced. For example,
the ES_ID instruction in Figure 5 <#FIGESPD> creates an Environment
Support service processor identifier, ENV_SUP, and associates it with
four different values. Once it has been created, specifying ID=ENV_SUP
on any Environment Support macro is equivalent to specifying all of
those values.

*Figure 5. Establishing service processor defaults* <#FT_FIGESPD>



     ES_ID ID=ENV_SUP,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT,               +
                  SPEPA=ES_EPA,SPTOKEN=ES_TKN,ESVA=ES_ESVA



Any number of service processor identifiers can be created: they are
simply used for grouping several different parameters under a single
name. Each service processor has its own macro for creating identifiers,
but they are all similar and have at least the following keywords:
SPEPNAME, SPEPA, SPTOKEN, and ESVA. Additional keywords may be specified
for some service processor identifiers.

All keywords other than ID= are optional when creating any service
processor identifier and most will be set to default values if they are
omitted. In particular, if the entry point address and token value
keywords are omitted, storage will be reserved for them in the
Structured Macros Program Work Area (PWA). The same is true for the ESV
address, except that the ES_ID macro will generate the storage, and all
other service processor identifiers will default to the existing value.

Any storage field generated in the PWA by a service processor macro will
be named using Structured Macros global variable &PWA. followed by the
service processor identifier, an underscore, and the keyword to which
the value applies. For example, if SPTOKEN had not been specified in
Figure 5 <#FIGESPD>, the instruction

&PWA.ENV_SUP_SPTOKEN  DS  F

would have been generated for it in the PWA.

The code in Figure 6 <#FIGCTUSPIM> performs the same function as that in
Figure 3 <#FIGCTUSPS>, but uses service processor macro instructions in
place of the LOAD and CALLX instructions.

*Figure 6. Code that uses service processor interface macros*
<#FT_FIGCTUSPIM>



     ES_ID                 ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT
     ST_ID                 ID=ST,SPEPNAME=&STRING_HANDLER
     MM_ID                 ID=MM,SPEPNAME=&MEMORY_MANAGER
     ES_MVS_LOAD           ID=ES              | Load Env. Support.
     ES_START              ID=ES              | Start Env. Support.
     ES_LOAD_MODULE        ID=ES,SPID=ST      | Load String Handler.
     ES_LOAD_MODULE        ID=ES,SPID=MM      | Load Memory Manager.
     ST_START              ID=ST              | Start String Handler.
     MM_START              ID=MM              | Start Memory Manager.
     MM_OBTAIN_STORAGE     ID=MM,SIZE=80,ADDRESS=MSG_BUFFER
     ES_GET_FORMATTED_TIME ID=ES,TIME=TIME,GREGORIAN=DATE
     ST_FORMAT ID=ST,CONTROL='Execution beginning at %CL5 on %CL8.',   +
               SOURCE=(TIME,DATE),TARGET=(*MSG_BUFFER,80),             +
               RESULTLEN=MSG_LENGTH
     ES_DISPLAY_MESSAGE    ID=ES,MESSAGE=(*MSG_BUFFER,MSG_LENGTH)



The first instruction in Figure 6 <#FIGCTUSPIM> establishes default
values for Environment Support and associates them with service
processor identifier ES. While Environment Support's entry point name
was explicitly specified, its entry point address, token value, and ESV
address were not: ES_ID automatically reserves storage for them in the
PWA. The next two instructions do the same thing for the String Handler
and the Memory Manager, but use the previouly established value for ESVA
instead of generating new fields. After these three instructions have
been seen by the assembler, the following fields will have been created
in the PWA and named as shown:

*Figure 7. Generated Program Work Area (PWA) fields* <#FT_FIGGPWAFS>



  &PWA.ES_SPEPA   DS A    | ID=ES: Environment Support's Entry Point Address.
  &PWA.ES_SPTOKEN DS F    | ID=ES: Environment Support's Token.
  &PWA.ES_ESVA    DS F    | ID=ES: Environment Support's ESV Address.
  &PWA.ST_SPEPA   DS A    | ID=ST: String Handler's Entry Point Address.
  &PWA.ST_SPTOKEN DS F    | ID=ST: String Handler's Token.
  &PWA.MM_SPEPA   DS A    | ID=MM: Memory Manager's Entry Point Address.
  &PWA.MM_SPTOKEN DS F    | ID=MM: Memory Manager's Token.


The remaining instructions in Figure 6 <#FIGCTUSPIM> produce the same
code as their counterparts in Figure 3 <#FIGCTUSPS>, automatically
obtaining the correct parameters and values through service processor
identifiers.

------------------------------------------------------------------------


    Checking Return Codes <#ToC_14>

On return from any service processor function, register 15 will contain
an integer value indicating the results of the function's operation.
This value is the function's return code. Each service processor has its
own set of return codes, but a value of zero (*0*) always means a
function call has completed successfully.

When most service processor functions cannot complete successfully, they
save information in Environment Support's debugging information area,
set the return code, and return to the calling program. The return code
from these functions should always be checked to insure successful
operation. However, some functions are designed to succeed or abend the
program, so there is no need to examine their return codes. Refer to the
description of a particular function for details on how it handles
abnormal conditions.

Checking the return code after a service processor function call is
easy. Each service processor COPY member defines symbols for all of its
return codes. These symbols may be used in open code while checking
return codes, as in the following IF statement:

  IF (CH,R15,EQ,=H'&MM_STORAGE_NOT_AVAILABLE')   | If out of storage.

In addition to the return code symbols, user-conditions are defined (via
the Structured Macros DEFUCOND macro) for checking them. To use one of
these conditions, simply prefix the condition code's name with a percent
sign. This statement is identical to the one above and happens to
generate the same assembler code:

  IF (%MM_STORAGE_NOT_AVAILABLE)                 | If out of storage.

Figure 8 <#FIGCSPRCS> shows a typical sequence of instructions for
checking a function's return code. In this case, the Memory Manager's
MM_OBTAIN_STORAGE function is being invoked. While no attempt is made to
recover from errors, the out-of-storage return code is handled as a
special case. All other non-successful return codes from this function
indicate more serious problems and are handled by displaying Environment
Support's debugging information area and then abending the program with
a dump. The return codes from Environment Support's display services are
not checked because they will either succeed or abend the program.

*Figure 8. Checking service processor return codes* <#FT_FIGCSPRCS>



  MM_OBTAIN_STORAGE ID=MM,SIZE=133,ADDRESS=LINE  | Obtain 133 bytes stg.
  IF (%MM_STORAGE_NOT_AVAILABLE)                 | If out of storage.
    ES_DISPLAY_MESSAGE ID=ES,MESSAGE='Not enough storage to operate.'
    ERREXIT  CODE=8                              |   Exit with RC=8.
  ELSEIF (NOT,(%MM_SUCCESS))                     | ElseIf other   failure.
    ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES        |   Abend with a   dump.
  ENDIF                                          | EndIf.

------------------------------------------------------------------------


    Multiple Sessions With the Same Processor <#ToC_15>

------------------------------------------------------------------------


    Cascading Service Processors of the Same Type <#ToC_16>

------------------------------------------------------------------------


    Putting it Together <#ToC_17>

Now that the basic features and requirements of service processors have
been covered, a complete program can be written. This program is a TSO
command processor written in assembler using the Structured Macros and
the service processor macros. It uses Environment Support and the File
Handler to read in and display every line in a sequential data set or
member of a partitioned data set, and is invoked with the following
syntax:


DISPLAY /file-specification/

On entry to the program, register 1 must point to the TSO Command
Processor Parameter List, or CPPL. The first word in the CPPL is a
pointer to the command buffer containing the command entered by the
user. The command buffer looks like the following:

*Figure 9. TSO command buffer layout* <#FT_Figure_9>


Length of buffer



Offset to 1^st operand



Command Text

Buffer+0



buffer+2



buffer+4



The first field, length, is a signed halfword equal to the length of the
entire command buffer, including the four-byte prefix. The second field,
offset, is a signed halfword equal to the offset from the beginning of
command-text to the current position (thus, an offset of 0000 would
indicate the first character in command-text). The last field,
command-text, is the text of the command as entered by the user.

Before invoking DISPLAY, TSO will set the value of offset to indicate
the first non-blank character after the command name itself (i.e.
*DISPLAY*). For example, if a user entered the command *display
source(notes)*, the command buffer would contain the following values,
with length and offset shown in decimal:

*Figure 10. Example command buffer contents* <#FT_Figure_10>


Length



Offset



Command Text

25



8



display source(notes)


The listing below was taken directly from a working copy of the DISPLAY
program, and is well commented. To understand the code of this program
in detail, refer to the reference chapters for the Environment Support
and File Handler service processors.

*Figure 11. The DISPLAY program* <#FT_FIGDISPLAY>



*---------------------------------------------------------------------*
*
*  DISPLAY FileSpecification
*
*  A TSO command to display the contents of the specified sequential
*  data set or PDS member on the user's terminal.  If the file cannot
*  be opened for some reason, or if an error occurs while it is reading
*  a line, the program will issue an error message and terminate
*  normally.
*
*  Inputs:  On entry to this program, Register 1 (R1) must point to the
*           TSO Command Processor Parameter List (CPPL), which is
*           mapped by macro IKJCPPL in SYS1.MACLIB.
*
*  Outputs: Normally, each line in the file named by FileSpecification
*           will be written to the user's terminal. If an error occurs,
*           a message will be written to the terminal.  Some messages
*           are created by this program, but most are obtained from the
*           File Handler.
*
*  Return Codes:
*    0    - The specified file was successfully displayed.
*    4    - The file was displayed, but warning(s) were issued.
*    8    - The file was not displayed.  An error message was issued.
*   12    - A severe error occurred.  A message and dump were issued.
*   Abend - A critical error occurred that probably indicates an
*           internal programming error.  A message, mini-dump, and a
*           full storage dump will be issued.
*
*---------------------------------------------------------------------*
 BLOCK TYPE=PROGRAM,NAME=DISPLAY,OPTIONS=(*PWA),R1SAVE=R9,AMODE=31,    +
               RMODE=ANY
   USING  CPPL,R9          | Establish addressability on the CPPL.
   MVC    PWA_RC,=H'0'     | Initialize Display's return code.
*---------------------------------------------------------------------*
*  Get symbols & macros, and establish deault parameter values.
*---------------------------------------------------------------------*
   COPY   SRVESMAC         | Get Environment Support symbols & macros.
   COPY   SRVFIMAC         | Get File Handler symbols & macros.
   ES_ID  ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT   Set defaults.
   FI_ID  ID=FI,SPEPNAME=&FI_OS_FILE_HANDLER        Set defaults.
*---------------------------------------------------------------------*
*  Load and start Environment Support. Both functions will succeed or
*  abend trying, so their return codes are not checked.
*---------------------------------------------------------------------*
   ES_MVS_LOAD    ID=ES            | Load Environment Support.
   ES_START       ID=ES            | Start Environment Support.
*---------------------------------------------------------------------*
*  Attempt to load the File Handler.  Issue a message on failure.
*---------------------------------------------------------------------*
   ES_LOAD_MODULE ID=ES,SPID=FI    | Load File Handler.
   IF NOT,(%ES_SUCCESS)            | If unable to load File Handler.
     ES_DISPLAY_MESSAGE ID=ES,     |   Display an error message.       +
               MESSAGE='Unable to load File Handler.'
     ERREXIT CODE=12               |   Quit with a return code.
   ENDIF                           | EndIf.
*---------------------------------------------------------------------*
*  Get the FileSpecification's length and address from the command
*  buffer, and attempt to open it for sequential input.
*---------------------------------------------------------------------*
   L        R2,CPPLCBUF            | R2 := address of command buffer.
   LH       R3,2(,R2)              | R3 := offset after command name.
   LA       R3,4(,R3)              | R3 := offset from R2 to filename.
   LH       R0,0(,R2)              | R0 := total buffer length.
   SR       R0,R3                  | R0 := filename's length.
   ST       R0,PWA_LEN             | Save for parmlist.
*                                  |
   FI_START ID=FI,FILE=(0(R3,R2),PWA_LEN),ACCESS=&FI_INPUT_SEQUENTIAL
*                                  |
   IF NOT,(%FI_SUCCESS)            | If file could not be opened.
     IF (%FI_CRITICAL)             |   For CRITICAL errors...
       ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES  Abend immediately.
     ELSEIF (%FI_SEVERE)           |   For severe errors...
       ES_DISPLAY_DEBUG_INFO ID=ES |     Print debugging info.
       ERREXIT CODE=12             |     Shut-down and exit.
     ENDIF                         |   EndIf.
*                                  |   For all other errors...
     FI_GET_INFO ID=FI,MSG=PWA_MSG,MSGLEN=PWA_MSG_LEN  Get the msg.
     IF (%FI_SUCCESS)              |   If success: display it.
       ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(PWA_MSG,PWA_MSG_LEN)
       ERREXIT CODE=8              |     Shut-down and exit.
     ELSE                          |   Else.
       ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES  Abend immediately.
     ENDIF                         |   EndIf.
   ENDIF                           | EndIf.
*---------------------------------------------------------------------*
*  Read every line in the file and display it on the terminal.
*---------------------------------------------------------------------*
   LOOP UNTIL                      | Loop over all input lines.
     FI_READLINE ID=FI,LINE=PWA_LINE,RESULTLEN=PWA_LEN  Read a line.
     LEAVE       LOOP=*,(%FI_END_OF_FILE)               Leave if done.
*                                  |
     IF NOT,(%FI_SUCCESS)          |   If something went wrong.
       IF (%FI_CRITICAL)           |     For CRITICAL errors...
         ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES  Abend immediately.
       ELSEIF (%FI_SEVERE)         |     For severe errors...
         ES_DISPLAY_DEBUG_INFO ID=ES       Print debugging info.
         ERREXIT CODE=12           |       Shut-down and exit.
       ENDIF                       |     EndIf.
*                                  |
       LR        R2,R15            |     Remember READLINE's return-code.
       FI_GET_INFO ID=FI,MSG=PWA_MSG,MSGLEN=PWA_MSG_LEN Obtain the msg.
       IF NOT,(%FI_SUCCESS)        |     If no message was obtained.
         ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES  Abend immediately.
       ELSE                        |     Else, display the message.
         ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(PWA_MSG,PWA_MSG_LEN)
         ERREXIT (CH,R2,NE,=H'&FI_WARNING'),CODE=8 Shut-down and exit.
         MVC     PWA_RC,=H'4'      |       Set return-code to warning.
       ENDIF                       |     EndIf.
     ENDIF                         |   EndIf.
*                                  |
     ES_DISPLAY_MESSAGE ID=ES,     |   Display the line just read in.  +
               MESSAGE=(PWA_LINE,PWA_LEN)
   ENDLOOP UNTIL,LEAVE             | EndLoop.
*---------------------------------------------------------------------*
*  Close the file, terminate and unload service processors, and quit.
*---------------------------------------------------------------------*
   FI_TERMINATE     ID=FI          | Close and de-allocate file.
   ES_UNLOAD_MODULE ID=ES,SPID=FI  | Unload file handler.
   ES_TERMINATE     ID=ES          | Shut down Environment Support.
   ES_MVS_UNLOAD    ID=ES          | Unload Environment Support.
   LH               R15,PWA_RC     | Set R15 to final return-code.
 ENDBLK BLOCK=DISPLAY,RC=(R15)     | Exit with a succesful return code.


*---------------------------------------------------------------------*
*  Error Exit - On entry R14 will equal the integer value supplied on
*  the CODE= keyword of the ERREXIT macro.  This value will be used as
*  Display's return code.
*---------------------------------------------------------------------*
 BLOCK TYPE=ERREXIT                | Exit was entered with CODE=rc.
   LR               R2,R14         |   Set R2 to the value on CODE=.
   FI_TERMINATE     ID=FI          |   Close and de-allocate file.
   ES_UNLOAD_MODULE ID=ES,SPID=FI  |   Unload file handler.
   ES_TERMINATE     ID=ES          |   Shut down Environment Support.
   ES_MVS_UNLOAD    ID=ES          |   Unload Environment Support.
 ENDBLK RC=(R2)                    | Set R15 to return-code and exit.


*---------------------------------------------------------------------*
*  Program Work Area.
*---------------------------------------------------------------------*
              PWA    ,             | Program Work Area.
PWA_RC        DS     H             |   Display's return code.
PWA_LEN       DS     F             |   Used for filename & line length.
PWA_LINE      DS     CL80          |   Current input line.
PWA_MSG_LEN   DS     F             |   Length of message text.
PWA_MSG       DS     CL256         |   Warning or error message.
              ENDPWA ,             | End of PWA.
              IKJCPPL              | Command Processor Parameter List.
              END

------------------------------------------------------------------------


  Chapter 3. Service Processors And The Structured Macros <#ToC_18>

(intro paragraphs)

------------------------------------------------------------------------


    Useful Structured Macro Constructs <#ToC_19>

------------------------------------------------------------------------


    Service Processor Support <#ToC_20>

The Clemson Structured Macros contain several features to support the
operation of Service Processors. The fastest way to familiarize yourself
with these options is to use an existing service processor as a model.
Refer to the ôCheap Calculatorö service processor in Appendix A of this
guide and in the SRVCCxxx members of the Service Processor source library.


      BLOCK Macro <#ToC_21>

Typically, a service processor will use the following PROGRAM block options:

**SRVPRC, NOCLEARPWA, PARMS(USING(reg)), (COUNT,parm_count_field)*

An unusually large program may also use the *LONG*and *LOCTR*options to
make it easier to manage base registers, as well as the subroutine
options **SWA*and *LOADBASE*.

Typically, the Structured Macros' reentrant linkage will getmain and
freemain a program workarea, or PWA. Service processors usually need to
remember information from one call to the next (an open DCB, pointers to
data defined by earlier calls, etc), so the *SRVPRC super option
includes an option that prevents the freemain from occurring unless
requested. Typically, the service processor's TERMINATE function will
include the macro

SMCTRL FREEPWA=YES

which sets a flag to tell the linkage code to issue a FREEMAIN during
the return linkage.


      ERREXIT Macro <#ToC_22>

Service processor errors can usually share one unnamed errexit routine
that contains an *ES_DISPLAY_DEBUG_INFO_AND_ABEND*macro. This macro will
snap out the debug information area chain and issue a U1000 abend. For
example:

  LOOP  UNTIL                        | Loop until explicit LEAVE
    FI_READLINE ID=FI_SYSIN, etc     | Read a line from SYSIN
    LEAVE LOOP=*,(%FI_END_OF_FILE)   | Leave loop if EOF
    ERREXIT (NOT,%FI_SUCCESS)        | Any other error is fatal.
       :                             | .. process ..
  ENDLOOP UNTIL,LEAVE                |
  FI_CLOSE ID=FI_SYSIN               | Close file at EOF.
       :
BLOCK TYPE=ERREXIT                   | General service processor errexit
  ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES  | Display DIA's and abend.
ENDBLK                               |

Other error routines may be defined as ERREXIT blocks, but since
the Structured Macros only support one unnamed errexit block,
additional blocks must be named.


      User-Defined Conditions <#ToC_23>

The DEFUCOND macro defines conditions that can be used in Structured
Macro conditional statements (IF, LOOP WHILE, ENDLOOP UNTIL, LEAVE, etc)
to test for various Service Processor return codes by the retorn code's
symbol name. The DEFUCOND macros that set these conditions up at
assembly time are usually defined in the SRVxxMAC member. For example,
here are the DEFUCOND macros from SRVDTMAC that define all the return
codes for SRVDT:

*---------------------------------------------------------------------*

* DEFUCOND macros to facilitate checking return codes. If new return

* codes are added, don't forget to add a DEFUCOND for them.

*---------------------------------------------------------------------*

DEFUCOND MACRO=SRV##RC,NAME=DT_SUCCESS

DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_FUNCTION

DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_NUMBER_OF_PARMS

DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_DT_ID

DEFUCOND MACRO=SRV##RC,NAME=DT_ENVIRONMENT_SUPPORT_ERROR

DEFUCOND MACRO=SRV##RC,NAME=DT_STRING_HANDLER_ERROR

DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_DATE_FORMAT

DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_TIME_FORMAT

DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_INTERVAL_FORMAT

DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_INPUT_DATE

DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_INPUT_TIME

DEFUCOND MACRO=SRV##RC,NAME=DT_INVALID_INPUT_INTERVAL

DEFUCOND MACRO=SRV##RC,NAME=DT_OVERFLOW

DEFUCOND MACRO=SRV##RC,NAME=DT_OUT_OF_RANGE

------------------------------------------------------------------------


  Part 2. Service Processors Reference <#ToC_24>

------------------------------------------------------------------------


  Chapter 4. Description Of Service Processors <#ToC_25>

This chapter contains reference information that applies to all service
processors. Each of the remaining chapters in Part 2, "Service
Processors Reference" <#HDRSPREF> describes a different kind of service
processor, with the name of the processor at the bottom of odd-numbered
pages for easy reference.

------------------------------------------------------------------------


    Service Processors <#ToC_26>

A *service processor* is a subroutine that provides a set of related
services using normal subroutine calls to a single point of entry. The
first two parameters are the same for all service processors: a *token*
and a *function code*. The *function code* parameter is a signed
fullword integer set by the calling program to select the desired
service. Two function codes, START and TERMINATE, are supported by all
service processors. The *token* parameter is a four byte value whose
contents are set by the service processor itself when the START function
code is selected. Additional parameters may be required or optional,
depending on the selected function code. The general form of a service
processor subroutine call looks like:

call service_processor,(token,function_code,additional_parameters)

As a general rule, each service processor supports a unique set of
services. For example, there is only one Memory Manager and only one
String Handler. In some cases though, several service processors may
support the same set of services but provide access to different
execution environments or to a different kind of resource. For example,
there are several File Handler service processors. They all support
pretty much the same services, but for completely different kinds of files.

When more than one service processor supports the same set of services,
it is helpful to distinguish between a /service processor/ and the
/protocol/ it follows. Remember that a service processor is a
subroutine. The protocol it follows includes everything a program must
know in order to use it: calling sequences, required and optional
parameters, function codes, return codes, data structures, etc.

While the distinction between a service processor and its protocol is
often blurred, the distinction is important as it allows for flexible
code to be written. The only part of a program that must know what
service processor is being used for a given set of services is the part
that chooses which subroutine to load. The remaining code can use the
processor's services without knowing or caring what subroutine is being
invoked, so long as it follows the correct protocol. This makes it easy
to access various resources or environments that are similar in nature,
with little or no change in code.

------------------------------------------------------------------------


    Naming Conventions <#ToC_27>

A unique two-letter identification code has been assigned to every
publicly available service processor. This code is used as part of every
name associated with a service processor protocol. The service processor
identification codes for all public service processors are shown in
Table 1 <#TBLSPICS>.

Using /sp/ to represent the two-letter service processor identifier
codes shown in Table 1 <#TBLSPICS>, the various components of a service
processor are named as follows:

 1.

    The names of *Macros, Symbols, Conditions, Data areas*, and
    everything other than PDS member names are prefixed with the
    two-letter code followed by an underscore, "_", followed by an
    arbitrary name. Any name beginning with "/sp_/" is a part of the
    service processor protocol assigned to the /sp/ service processor
    identification code.

 2.

    *PDS Members* for service processors are named as follows:

     1.

        *Load Modules* are named SRV/sp/, unless a service processor has
        an environmental dependency in which case the name is
        SRV/sp//*env*/, where /*env*/ is up to three letters chosen to
        indicate the dependency. For example, SRVES*MVS* is the name of
        the /*MVS*/ Environment Support service processor load module.

     2.

        *Assembler COPY members* are named SRV/sp/MAC.

     3.

        *Internal COPY members* are named SRV/sp/IMC.

     4.

        *Excerciser* programs and data are named SRV/sp/XR/z/, where /z/
        is an arbitrary character (usually Z).

     5.

        *BookMaster Reference Chapters* for are named SRVDOC/sp/.

 3.

    *A composite load module* containing various service processors
    link-edited together with a Module Name Table and an Environment
    Support service processor is named SRVCM/*env*/. The corresponding
    Environment Support load module is an alias of the composite (e.g.
    SRVESMVS is an alias of SRVCMMVS, where SRVCMMVS contains MVS
    Environment Support as the main entry point, a module name table,
    and a number of service processors that have been linked into the
    module).



*Table 1. Service processor codes and member names*

Service Processor



Code



Environment Dependent



Copy Member



Load Module(s)

Data In Virtual Manager



*DV*



YES



SRV*DV*MAC



SRV*DV*MVS

Date/Time Services



*DT*



NO



SRV*DT*MAC



SRV*DT *

Environment Support



*ES*



YES



SRV*ES*MAC



SRV*ES*MVS

File Handler



*FI*



YES



SRV*FI*MAC



SRV*FI*OS SRV*FI*XID SRV*FI*PDF SRV*FI*SMS SRV*FI*SUB

Item Manager



*IM*



NO



SRV*IM*MAC



SRV*IM *

Memory Manager



*MM*



NO



SRV*MM*MAC



SRV*MM *

Message



*MS*



NO



SRV*MS*MAC



SRV*MS *

PrintLine



*PL*



YES



SRV*PL*MAC



SRV*PL*MVS

String Handler



*ST*



NO



SRV*ST*MAC



SRV*ST *

Symbol Manager



*SY*



NO



SRV*SY*MAC



SRV*SY *

------------------------------------------------------------------------


    Linkage Conventions <#ToC_28>

Service processors conform to standard System/370 linkage conventions
for programs running in 31-bit addressing mode. When the calling program
invokes a service processor function, registers 1, 13, 14, and 15 must
contain the following values, all of which are 31-bit addresses:

  *

    Register 1 must contain the address of a variable-length service
    processor parameter list.

  *

    Register 13 must contain the address of a 72-byte register save area
    aligned on a fullword boundary.

  *

    Register 14 must contain the address to which control will be returned.

  *

    Register 15 must contain the service processor's entry point address

The parameter list pointed to by register 1 is a sequence of fullword
addresses aligned on fullword boundaries. All addresses but the final
one in the list contain a *0* in their high-order bit. The final address
is denoted by a *1* in its high-order bit. Each address in the list
points to the corresponding parameter that is being passed to the
service processor.

Optional parameters may be omitted by setting their corresponding
parameter list address (parameter /x/) to zero. If the parameters to be
omitted occur at the end of the parameter list, the list may be
terminated early by setting the high-order bit of the last supplied (not
omitted) parameter address. The token and function code parameters are
/never/ optional. Thus, the minimum possible call to invoke a service
processor function looks like the following (for a program written with
the Structured Macros):

CALLX SERVICE_PROCESSOR,(TOKEN,FUNCTION_CODE),VL

On return from a service processor function, all registers except
register 15 will contain their original values. Register 15 will be set
to an integer indicating the results of the function's operation. This
value is the function's /return code/, and each function has its own set
of return codes. A return code of zero always indicates success. The
reference section for each service processor's function describes the
possible return codes, their meanings, and the appropriate actions to be
taken by the calling program.

------------------------------------------------------------------------


  Chapter 5. Date/Time Services <#ToC_29>

The Date/Time service processor is intended to reduce or eliminate the
tasks normally associated with handling date and time values in a
program. Date/Time Services may be used to:

  *

    Return the current date and/or time, in a variety of formats

  *

    Convert a date and/or time value from one format to another

  *

    Recognize the format of a character date or time value

  *

    Return the difference, or /duration/, between two date/time values

  *

    Add or subtract an interval value to a date and/or time

There are two major operations during each call to the Date/Time service
processor: these are /input conversion/ and /output conversion/. Input
conversion validates that the date and/or time value provided conforms
to the format specified, then converts the date and/or time values to an
internal representation. Output conversion converts the internal
representation to the date and/or time format requested by the caller.

Input validation is necessarily limited for performance reasons:
incoming date and time values are validity-checked to ensure that
numbers, words and other characters are in the right positions and
spelled correctly, but 'sanity checking' is only minimal. (For example,
an input Gregorian date of 02/30/1989 is considered valid: however, if
converted to another format, the output date will be equivalent to March
2, 1989.) Character input data (names of days and months, etc) may be
mixed case: character output data is always capitalized lowercase. (If a
program requires data returned from Date/Time Services to be uppercase,
the program can fold the data to uppercase itself.)

A /general input/ format is provided. This format actually supports a
variety of actual date or time formats by attempting to recognize the
format, then proceeding as though the date or time's true format was
specified by the caller. The true format is not returned to the caller:
however, the caller may use the DT_Convert function to convert the date
or time to any other supported format as required. This function may be
extremely useful for applications where a user is asked to provide a
date or time value: the application doesn't need to care what format the
dates and times are, but can get Date/Time Services to recognize, then
convert the dates and times to any format required.

Date/Time Services internally uses four tableless date conversion
algorithms. These were adapted from algorithms 199 and 398 from
/Collected Algorithms From Communications Of The ACM/. The algorithms
should be correct for any date between March 1, 0000 and December 31,
9999. Note, however, that Date/Time Services do not account for Pope
Gregory XIII's calendar adjustment in 1582 A.D: hence, date values prior
to October 15, 1582, although numerically accurate, will be 11 (or more)
days greater than the actual date.


      Obtaining Date/Time Services' Symbols & Macros <#ToC_30>

Date/Time Services' symbols and interface macros can be found in the
assembler copy member SRVDTMAC. This member contains symbols naming
Date/Time Services' load module, function codes, return codes, and
parameter values. It also contains macros for using all of the Date/Time
Services' functions. The following statement or its equivalent should
appear at the beginning of any program that uses Date/Time Services:

   COPY SRVDTMAC      Obtain Date/Time Services' symbols & macros.


      Establishing Date/Time Services Defaults <#ToC_31>

Some parameters are general to Date/Time Services and not specific to
any function. These parameters include its load module name
(/DT_epname/), entry point address (/DT_epa/), and token value
(/DT_token/). The DT_ID macro can be used to establish defaults for
these parameters and associate them with a unique service processor
identifier. The identifier may then be supplied on any Date/Time
Services macro instruction to refer to the default parameter values.


      Identifying Date/Time Services <#ToC_32>

The Date/Time service processor resides in the load module named by the
following symbol definition in copy member SRVDTMAC:

&DATETIME_SERVICES SETC '''SRVDT   '''

This symbolic name should be used as the service processor entry point
name for Date/Time Services as shown in the following macro instruction:

DT_ID ID=DT,SPEPNAME=&DATETIME_SERVICES  Set Date/Time Defaults.


      Loading Date/Time Services <#ToC_33>

The recommended method for loading Date/Time Services is through
Environment Support's ES_LOAD_MODULE function, as shown in the following
example:

ES_LOAD_MODULE ID=ES,SPID=DT            Load Date/Time Services


      Specifying Date, Time And Interval Formats <#ToC_34>

Although most of the Date/Time Services macros support both a date and a
time value as input and/or output, both need not be specified: a date or
time specification may be used alone as input or output if desired. For
example, to convert a date from one format to another, the DT_Convert
function could be called using the Datein and Dateout parameters alone.
Note that if a date or time value is not specified, it is treated as
having a value of zero: for dates, this is equivalent to Jan. 1, 0000,
while for times, this translates to 00:00:00.00, or exactly midnight.

Date/Time Services support a number of date and time formats. Each
format is actually an integer value, with its own symbol associated with
it (for example, format /&DT_Julian/ is equated to integer 2.) These are
listed in the following tables.

*Table 2. Date/Time Services Supported Date Formats*

Symbol Name



Format Value



Format Type



Description



Length



Example

*&DT_ES_Format*

^1 <#FNFNDATE1>



1



Both



Environment Support format date and time



8



X'1989359F', X'0047BF58'

*&DT_Julian*



2



Both



Standard Julian date



7



C'1989359'

*&DT_Juliand*



3



Both



7-digit Julian date with decimal



8



C'1989.359'

*&DT_Pjulian*



4



Both



Packed-decimal Julian date



4



P'1989359'

*&DT_Ijulian*



5



Both



Integer (binary) Julian date



4



F'1989359'

*&DT_Sjulian*



6



Both



Short Julian date



5



C'89359'

*&DT_Sjuliand*



7



Both



Short Julian date with decimal



6



C'89.359'

*&DT_Number_Of_Days*



8



Both



Number of days since Jan 1, 00



4



F'726767'

*&DT_Sgregorian*

^2 <#FNFNDATE2>



11



Both



Short Gregorian date



8



C'12/25/89'

*&DT_Gregorian*

^2 <#FNFNDATE2>



12



Both



Standard Gregorian date



10



C'12/25/1989'

*&DT_Sortdate*



13



Both



Date format suitable for sorting



10



C'1989-12-25'

*&DT_Ssortdate*



14



Both



Short version of DT_Sortdate



8



C'89-12-25'

*&DT_Year*



15



Output



Character year value



4



C'1989'

*&DT_Year2*



16



Output



2-digit character year



2



C'89'

*&DT_Pyear*



17



Output



Packed-decimal year value



4



PL4'1989'

*&DT_Iyear*



18



Output



Halfword integer year value



2



H'1989'

*&DT_Days*



19



Output



2-digit day number within month



2



C'25'

*&DT_Pdays*



20



Output



Packed day number within month



2



PL2'25'

*&DT_Idays*



21



Output



Integer day number within month



2



H'25'

*&DT_Month*



22



Output



2-digit month number



2



C'12'

*&DT_Pmonth*



23



Output



Packed month number



2



PL2'12'

*&DT_Imonth*



24



Output



Integer month number



2



H'12'

*&DT_Snormal*



31



Both



Short Normal format date



9



C'25 Dec 89'

*&DT_Normal*



32



Both



Normal format date



11



C'25 Dec 1989'

*&DT_SASdate7*



33



Both



7-character SAS 'DATE7.' format



7



C'25DEC89'

*&DT_SASdate9*



34



Both



9-character SAS 'DATE9.' format



9



C'25DEC1989'

*&DT_Text*



41



Both



Text format date



11-18



C'December 25, 1989'

*&DT_Textd*



42



Both



Text format with weekday



19-28



C'Monday, December 25, 1989'

*&DT_Weekday*



43



Output



Character weekday name



6-9



C'Monday'

*&DT_Weekday3*



44



Output



3-character weekday name



3



C'Mon'

*&DT_Monthname*



45



Output



Character month name



3-9



C'December'

*&DT_Monthname3*



46



Output



3-character month name



3



C'Dec'



*Table 3. Date/Time Services Supported Time Formats*

Symbol Name



Format Value



Format Type



Description



Length



Example

*&DT_Hundredths*



2



Both



Number of .01-second units since midnight



4



X'0047BF58'

*&DT_HHMM*



3



Both



Time in hours and minutes



5



C'13:03'

*&DT_HHMMSS*



4



Both



Time in hours, minutes, seconds



8



C'13:03:40'

*&DT_HHMMSSTH*



5



Both



Time in hours, minutes, seconds, hundredths



11



C'13:03:40.40'

*&DT_Civilian*



6



Both



Time in hours, minutes, seconds, AM/PM



11



C' 1:03:40 PM'

*&DT_TODCLOCK*

^*3* <#FNFNTIME1>



7



Both



System/370 time-of-day clock format^5 <#FNFNTIME3>



8



XL8'/TOD value/'

*&DT_Hours*

^*4* <#FNFNTIME2>



8



Output



2-character hour value



2



C'13'

*&DT_Phours*

^*4* <#FNFNTIME2>



9



Output



2-byte packed-decimal hours



2



PL2'13'

*&DT_Ihours*

^*4* <#FNFNTIME2>



10



Output



Halfword hours value



2



H'13'

*&DT_Minutes*

^*4* <#FNFNTIME2>



11



Output



Character minutes value



2



C'03'

*&DT_PMinutes*

^*4* <#FNFNTIME2>



12



Output



Packed-decimal minutes value



2



PL2'3'

*&DT_Iminutes*

^*4* <#FNFNTIME2>



13



Output



Halfword integer minutes value



2



H'3'

*&DT_Seconds*

^*4* <#FNFNTIME2>



14



Output



Character seconds value



2



C'51'

*&DT_Pseconds*

^*4* <#FNFNTIME2>



15



Output



Packed-decimal seconds value



2



PL2'51'

*&DT_Iseconds*

^*4* <#FNFNTIME2>



16



Output



Halfword integer seconds value



2



H'51'



*Table 4. Date/Time Services Supported Interval Formats*

Symbol Name



Format Value



Format Type



Description



Length



Example

*&DT_Delta*



1



Both



Interval in days, hours, minutes, seconds, hundredths



14



C'79-15:20:25.43'

*&DT_Days*



19



Both



2-digit number of days



5



C'00025'

*&DT_Pdays*



20



Both



Packed number of days



4



PL4'25'

*&DT_Idays*



21



Both



Integer number of days



2



H'25'

*&DT_Hours*

^*6* <#FNFNINTVL>



8



Both



2-character hour value



5



C'00013'

*&DT_Phours*

^*6* <#FNFNINTVL>



9



Both



4-byte packed-decimal hours



4



PL4'13'

*&DT_Ihours*

^*6* <#FNFNINTVL>



10



Both



Halfword hours value



2



H'13'

*&DT_Minutes*

^*6* <#FNFNINTVL>



11



Both



Character minutes value



5



C'00003'

*&DT_PMinutes*

^*6* <#FNFNINTVL>



12



Both



Packed-decimal minutes value



4



PL4'3'

*&DT_Iminutes*

^*6* <#FNFNINTVL>



13



Both



Halfword integer minutes value



2



H'3'

*&DT_Seconds*

^*6* <#FNFNINTVL>



14



Both



Character seconds value



5



C'00051'

*&DT_Pseconds*

^*6* <#FNFNINTVL>



15



Both



Packed-decimal seconds value



4



PL4'51'

*&DT_Iseconds*

^*6* <#FNFNINTVL>



16



Both



Halfword integer seconds value



2



H'51'

*&DT_Hundredths*



2



Both



Number of .01-second units



5



C'01578'

*&DT_Phundredths*



17



Both



Number of .01-second units



4



PL4'1578'

*&DT_Ihundredths*



18



Both



Number of .01-second units



2



H'1578'


      The General Input Format <#ToC_35>

Date/Time Services provide a generalized input format, known as
*&DT_General_Input*, which actually provides a format recognition
function for a variety of character date and time formats. If an input
value is declared to be of this format, Date/Time Services attempts to
determine the format: once the format is recognized, Date/Time Services
treats the value as though that input format was specified by the
caller. The invalid-input return codes indicate that the format was not
recognized.

The following date, time and interval formats are supported by the
*&DT_General_Input* format:

  *

    *&DT_Civilian*

  *

    *&DT_Gregorian*

  *

    *&DT_HHMM*

  *

    *&DT_HHMMSS*

  *

    *&DT_HHMMSSTH*

  *

    *&DT_Julian*

  *

    *&DT_Juliand*

  *

    *&DT_Normal*

  *

    *&DT_Sgregorian*

  *

    *&DT_Sjulian*

  *

    *&DT_Sjuliand*

  *

    *&DT_Snormal*

  *

    *&DT_Sortdate*

  *

    *&DT_Ssortdate*

  *

    *&DT_SASdate7*

  *

    *&DT_SASdate9*

  *

    *&DT_Text*


      Common Parameters <#ToC_36>

There are several parameters common to any Date/Time Services function
call. These are:


      Parameter



Description

id_name



specifies the name of a service processor identifier created by the
DT_ID macro which will be used by the DT_START macro to automatically
obtain values for /DT_epa/ and /DT_token/. This parameter is required
unless both /DT_epa/ and /DT_token/ are specified.

DT_epa



specifies the label of a fullword in storage that contains the entry
point address of an already-started Date/Time Services service
processor. The value specified by /DT_epa/ overrides any value obtained
from ID=/id_name/.

DT_token



specifies the label of a fullword in storage that contains the value
returned by DT_START for the /DT_token/ parameter. The value specified
by /DT_token/ overrides any value obtained from ID=/id_name/.


      Return Codes <#ToC_38>

Date/Time Services may issue any of the following return codes in
various situations. Some of the return codes may be received from any
call to Date/Time Services, while others are specific to individual
functions.

*Table 5. Return Codes*

*Return Code *



Symbol



Description

0



DT_SUCCESS



The Date/Time Services function has completed successfully.

1



DT_INVALID_FUNCTION



An unsupported function code was received by Date/Time Services.

2



DT_INVALID_NUMBER_OF_PARMS



The Date/Time Services function received an invalid number of
parameters. This may be due to an improperly coded CALLX or PLIST macro,
or the inadvertent use of the NOVL option.

3



DT_INVALID_DT_ID



Date/Time Services detected an invalid PWA address in DT_token.

4



DT_ENVIRONMENT_SUPPORT_ERROR



An Environment Support function suffered an error.

5



DT_STRING_HANDLER_ERROR



An error was reported by the String Handler service processor. More
information may be found by issuing the ES_DISPLAY_DEBUG_INFO function.

6



DT_INVALID_DATE_FORMAT



The integer fullword provided via the /date_format/ parameter was not a
supported Date/Time Services date format.

7



DT_INVALID_TIME_FORMAT



The integer fullword provided via the /time_format/ parameter was not a
supported Date/Time Services time format.

8



DT_INVALID_INTERVAL_FORMAT



The integer fullword provided via the /interval_format/ parameter was
not a supported Date/Time Services interval format.

9



DT_INVALID_INPUT_DATE



The date value provided by the caller failed validity checking for the
specified date format.

10



DT_INVALID_INPUT_TIME



The time value provided by the caller failed validity checking for the
specified time format.

11



DT_INVALID_INPUT_INTERVAL



The interval value provided by the caller failed validity checking for
the specified interval format.

12



DT_OVERFLOW



The interval value produced by the function is too large for the
specified output interval format.

13



DT_OUT_OF_RANGE



The output date/time value is not within the acceptable range for the
specified format. This will only occur when using DT_TODclock format,
when the date and time values are outside the range of Jan. 1, 1900 at
00:00:00.00 and Sept. 17, 2042 at 23:53:47.37.

------------------------------------------------------------------------


    Date/Time Services Functions <#ToC_40>

The remaining sections of this chapter describe all functions provided
by Date/Time Services, arranged in alphabetical order. Each function's
description begins on a new page, and the name of the function being
described appears in the top outside corner of every page.


      _DT_ADD - __Add Interval To Date And Time_

The DT_ADD function will add an interval to a date and/or time value.

DT_ADD ID=/id_name/ Ý,SPEPA=/DT_epa/¨ Ý,SPTOKEN=/DT_token/¨
   Ý,DATEIN=(/date_address,date_format/)¨
   Ý,TIMEIN=(/time_address,time_format/)¨
   Ý,INTERVAL=(/interval_address,interval_format/)¨
   Ý,DATEOUT=(/date_address,time_format/)¨
   Ý,TIMEOUT=(/time_address,time_format/)¨

CALLX /DT_epa/,(/DT_token/,&DT_ADD,/datein_address/
              ,/datein_format/,/timein_address/,/timein_format/
              ,/interval_address,interval_format,dateout_address/
              ,/dateout_format,timeout_address,timeout_format/)


Parameter



*Description *

datein_address



Specifies the address of the input date value. For variable-length input
formats, the field needs only to be as long as the date value, and does
not need to be padded with spaces. This is true for all input values for
DT_ADD.

datein_format



Specifies the format of the input date value. This value may be an
integer, numeric symbol, or the address of a fullword in storage. This
is true of all format specifications for DT_ADD.

timein_address



Provides the address of the input time value.

timein_format



Specifies the format of the input time value.

interval_address



Specifies the address of the input interval value.

interval_format



Specifies the format of the input interval value.

dateout_address



Specifies the address of the output date value. The area should be large
enough to hold the longest possible date value for the requested format.
If the format is variable-length, it should be cleared to spaces before
the call to DT_ADD.

dateout_format



Specifies the format of the output date value.

timeout_address



Provides the address of the output time value.

timeout_format



Specifies the format of the output time value.



*Examples*


To add a constant of 75 hours to the date and time values in pwa_date
and pwa_time, one would code:

     DT_ADD  ID=DT,
             DATEIN=(pwa_date,&DT_NORMAL),
             TIMEIN=(pwa_time,&DT_HHMMSS),
             INTERVAL=('75',&DT_HOURS),
             DATEOUT=(pwa_date,&DT_NORMAL),
             TIMEOUT=(pwa_time,&DT_HHMMSS)

This would replace the contents of pwa_date and pwa_time with the
updated date and time values.


      _DT_CONVERT - __Date And Time Format Conversion_

The DT_CONVERT function will convert a date and/or time value from one
supported format to another.

     DT_CONVERT ID=/id_name/ Ý,SPEPA=/DT_epa/¨ Ý,SPTOKEN=/DT_token/¨
        Ý,FROMDATE=(/date_address,date_format/)¨
        Ý,FROMTIME=(/time_address,time_format/)¨
        Ý,TODATE=(/date_address,date_format/)¨
        Ý,TOTIME=(/time_address,time_format/)¨

     CALLX /DT_epa/,(/DT_token/,&DT_CONVERT,/fromdate_address/
                   ,/fromdate_format/,/fromtime_address/,/fromtime_format/
                   ,/todate_address/,/todate_format/,/totime_address/
                   ,/totime_format/)


*Parameter *



*Description *

fromdate_address



Specifies the address of the input date value. For variable-length input
formats, the field needs only to be as long as the date value, and does
not need to be padded with spaces. This is true for all input values for
DT_CONVERT.

fromdate_format



Specifies the format of the input date value. This value may be an
integer, numeric symbol, or the address of a fullword in storage. This
is true of all format specifications for DT_CONVERT.

fromtime_address



Provides the address of the input time value.

fromtime_format



Specifies the format of the input time value.

todate_address



Specifies the address of the output date value. The area should be large
enough to hold the longest possible date value for the requested format.
If the format is variable-length, it should be cleared to spaces before
the call to DT_CONVERT.

todate_format



Specifies the format of the output date value.

totime_address



Provides the address of the output time value.

totime_format



Specifies the format of the output time value.


      Examples

If the current contents of fields pwa_date and pwa_time are date and
time are January 7, 1990 and 16:11:30 respectively, the following
DT_CONVERT macro:

DT_CONVERT  ID=DT,
            FROMDATE=(pwa_date,&DT_TEXT),
            FROMTIME=(pwa_time,&DT_HHMMSS),
            TODATE=(pwa_dateout,&DT_NORMAL),
            TOTIME=(pwa_timeout,&DT_CIVILIAN)

would return date and time values in pwa_dateout and pwa_timeout
respectively. These values would appear as:

   pwa_dateout    07 JAN 1990
   pwa_timeout     4:11:30 PM

_*DT_DURATION - *__*Duration Between Two Date/Time Values *_

The DT_DURATION function will return the duration, or difference,
between two date and/or time values. This duration, returned in interval
format, is always a positive number of days, hours, etc.

DT_DURATION ID=/id_name/ Ý,SPEPA=/DT_epa/¨ Ý,SPTOKEN=/DT_token/¨
   Ý,DATE1=(/date_address,date_format/)¨
   Ý,TIME1=(/date_address,time_format/)¨
   Ý,DATE2=(/date_address,date_format/)¨
   Ý,TIME2=(/date_address,time_format/)¨
   Ý,DURATION=(/duration_address,duration_format/)¨

CALLX /DT_epa/,(/DT_token/,&DT_CONVERT,/date1_address/
              ,/date1_format/,/time1_address/,/time1_format/
              ,/date2_address/,/date2_format/,/time2_address/
              ,/time2_format/,/duration_address/,/duration_format/)


*Parameter*



Description

date1_address



Specifies the address of the first input date value. For variable-length
input formats, the field needs only to be as long as the date value, and
does not need to be padded with spaces. This is true for all input
values for DT_DURATION.

date1_format



Specifies the format of the first input date value. This value may be an
integer, numeric symbol, or the address of a fullword in storage. This
is true of all format specifications for DT_DURATION.

time1_address



Provides the address of the first input time value.

time1_format



Specifies the format of the first input time value.

date2_address



Specifies the address of the second input date value.

date2_format



Specifies the format of the second input date value.

time2_address



Provides the address of the second input time value.

time2_format



Specifies the format of the second input time value.

duration_address



Provides the address of the output interval value. The area should be
large enough to hold the longest possible interval value for the
requested format. If the format is variable-length, it should be cleared
to spaces before the call to DT_DURATION.

duration_format



Specifies the format of the output interval value.


      Examples

If the fields pwa_date, pwa_date2, pwa_time, and pwa_time2 contain
various date and time values, the following call to DT_DURATION would
return the difference between them in DT_Delta format.

DT_DURATION ID=DT,
            DATE1=(pwa_date,&DT_TEXT),
            TIME1=(pwa_time,&DT_HHMMSS),
            DATE2=(pwa_date2,&DT_NORMAL),
            TIME2=(pwa_time2,&DT_CIVILIAN)
            DURATION=(pwa_interval,&DT_DELTA)

_*DT_GET_CURRENT - *__*Return Current Date And Time*_

The DT_GET_CURRENT function retrieves the current date and/or time. The
format requested may be any valid date format for date, and any valid
time format for time.

DT_GET_CURRENT ID=/id_name/ Ý,SPEPA=/DT_epa/¨ Ý,SPTOKEN=/DT_token/¨
   Ý,DATE=(/date_address,date_format/)¨
   Ý,TIME=(/date_address,time_format/)¨

CALLX /DT_epa/,(/DT_token/,&DT_GET_CURRENT,/date_address/
              ,/date_formatÝ,time_address,time_format¨/)


Parameter



Description

Description




date_address



Provides the address of an area where Date/Time Services will return the
current date. The area should be large enough to hold the longest
possible date value for the requested format. If the format is
variable-length, it should be cleared to spaces before the call to
DT_GET_CURRENT.

date_format



Specifies a format for the date value returned by DT_GET_CURRENT. This
value may be an integer, numeric symbol, or the address of a fullword in
storage. This is true of all format specifications for DT_GET_CURRENT.

time_address



Provides the address of an area where Date/Time Services will return the
current time.

time_format



Specifies a format for the time value returned by DT_GET_CURRENT.


      Examples

If the current date and time are January 7, 1990 and 16:11:30
respectively, the following DT_GET_CURRENT macro:

DT_GET_CURRENT  ID=DT,
                DATE=(pwa_date,&DT_NORMAL),
                TIME=(pwa_time,&DT_CIVILIAN)

would return date and time values in pwa_date and pwa_time respectively.
These values would appear as:

   pwa_date    07 JAN 1990
   pwa_time     4:11:30 PM

_*DT_ID - *__*Establish Default Date/Time Services Values*_

The DT_ID macro is used to establish default values for use by other
Date/Time Services macros, which may access those values through a
unique identifier, /id_name/, specified by the user. When allowed to
generate default values, this macro will create Program Work Area (PWA)
storage for /DT_epa/ and /DT_token/. These values, whether generated by
the macro or provided by the user, are accessable from all other
Date/Time Services macros via the ID=/id_name /parameter.

DT_ID ID=/id_name/
   Ý,SPEPNAME=/DT_epname/¨
   Ý,SPEPA=/DT_epa/¨
   Ý,SPTOKEN=/DT_token/¨
   Ý,ESID=/esid_name/¨
   Ý,ESVA=/esva/¨


*Parameter*



Description

esid_name



the name of a service processor identifier, created by the ES_ID macro,
which will be used by the DT_ID macro to automatically obtain the value
for esv (see below).

esva



Specifies the label of a fullword in storage that contains (or will
contain) the address of the Environment Support Vector (ESV) created by
the ES_START function.


      Examples

The following DT_ID macro will associate everything required by the
Date/Time Services macros with the service processor identifier DT, as
well as establish the sizelength value for the Date/Time Services session.

    DT_ID  ID=DT,
           SPEPNAME=&DATETIME_SERVICES,
           SPEPA=PWA_DT_ENTRY,
           SPTOKEN=PWA_DT_TOKEN,
           ESID=ES,
           ESVA=PWA_ESVA

PWA_DT_ENTRY  DS    F         Entrypoint for Date/Time Services
PWA_DT_TOKEN  DS    F         Unique token for Date/Time Services
PWA_ESVA      DS    F         Environment Support Vector address

Note that this example forces the various operands to specific values
and addresses. If these are not specified and do not need to be
explicitly referenced, simply coding the DT_ID macro with only the ID
and SPEPNAME operands will cause all of them to be generated automatically.

_*DT_START - Begin A Date/Time Services Session *_

The DT_START function establishes a new Date/Time Services session and
returns its session identifier in the /DT_token/parameter.

DT_START ID=/id_name/ Ý,SPEPA=/DT_epa/¨ Ý,SPTOKEN=/DT_token/¨
   Ý,ESVA=/esva/¨
   Ý,OPTION=(/option_list/)¨

CALLX /DT_epa/,(/DT_token/,&DT_START,/esva/,/option_byte/)


*Parameter *



Description

esva



Specifies the label of a fullword in storage that contains the address
of the Environment Support Vector (ESV) created by the ES_START function.

option_list



A list of additional options for this Date/Time Services session. If
multiple option values are specified, they must be enclosed in
parentheses. The only options currently supported are /EUROPEAN/ and
/AMERICAN/.

  *

    *EUROPEAN* - Gregorian dates processed by Date/Time Services will be
    of the format /"dd/mm/yyyy"/ If using the CALLX form of /DT_START/,
    the EUROPEAN option corresponds to a bit setting of X'80' in the
    option byte.

  *

    *AMERICAN* - Gregorian dates processed by Date/Time Services will be
    of the format /"mm/dd/yyyy"/ If using the CALLX form of /DT_START/,
    the AMERICAN option corresponds to the X'80' bit being set to zero
    in the option byte. AMERICAN is the default Gregorian date format.


      Examples

The following DT_START macro will initialize a Date/Time Services session.

  DT_START ID=DT

_*DT_SUBTRACT - Subtract Interval From Date And Time *_

The DT_SUBTRACT function will subtract an interval from a date and/or
time value.

DT_SUBTRACT ID=/id_name/ Ý,SPEPA=/DT_epa/¨ Ý,SPTOKEN=/DT_token/¨
   Ý,DATEIN=(/date_address,date_format/)¨
   Ý,TIMEIN=(/time_address,time_format/)¨
   Ý,INTERVAL=(/interval_address,interval_format/)¨
   Ý,DATEOUT=(/date_address,time_format/)¨
   Ý,TIMEOUT=(/time_address,time_format/)¨

CALLX /DT_epa/,(/DT_token/,&DT_SUBTRACT,/datein_address/
              ,/datein_format/,/timein_address/,/timein_format/
              ,/interval_address,interval_format,dateout_address,/
              ,/dateout_format,timeout_address,timeout_format/)


*Parameter *



Description

datein_address



Specifies the address of the input date value. For variable-length input
formats, the field needs only to be as long as the date value, and does
not need to be padded with spaces. This is true for all input values for
DT_SUBTRACT.

datein_format



Specifies the format of the input date value. This value may be an
integer, numeric symbol, or the address of a fullword in storage. This
is true of all format specifications for DT_ADD.

timein_address



Provides the address of the input time value.

timein_format



Specifies the format of the input time value.

interval_address



Specifies the address of the input interval value.

interval_format



Specifies the format of the input interval value.

dateout_address



Specifies the address of the output date value. The area should be large
enough to hold the longest possible date value for the requested format.
If the format is variable-length, it should be cleared to spaces before
the call to DT_SUBTRACT.

dateout_format



Specifies the format of the output date value.

timeout_address



Provides the address of the output time value.

timeout_format



Specifies the format of the output time value.


      Examples

To subtract a constant of 75 hours to the date and time values in
pwa_date and pwa_time, one would code:

DT_SUBTRACT ID=DT,
        DATEIN=(pwa_date,&DT_NORMAL),
        TIMEIN=(pwa_time,&DT_HHMMSS),
        INTERVAL=(75,&DT_HOURS),
        DATEOUT=(pwa_date,&DT_NORMAL),
        TIMEOUT=(pwa_time,&DT_HHMMSS)

This would replace the contents of pwa_date and pwa_time with the
updated date and time values.

_*DT_TERMINATE - Terminate A Date/Time Services Session *_

The DT_TERMINATE function concludes the Date/Time Services session
identified by the /DT_token/parameter, and releases any resources held
by the Date/Time Services service processor.

DT_TERMINATE ID=/id_name/ Ý,SPEPA=/DT_epa/¨ Ý,SPTOKEN=/DT_token/¨
CALLX /DT_epa/,(/DT_token/,&DT_TERMINATE)


      Examples

The following DT_TERMINATE macro will cause Date/Time Services to
release any resources that it acquired.

DT_TERMINATE ID=DT

------------------------------------------------------------------------


  Chapter 6. Environment Support <#ToC_41>

Environment Support is both a service processor and the foundation on
which other service processors build. As a service processor, it acts as
an interface between the programs that use it and the environment in
which they run. As a foundation for other service processors, it
provides additional support through a data area called the Environment
Support Vector, or ESV.

Services are available in Environment Support for obtaining and
releasing main storage, loading and unloading modules, issuing messages,
and managing debugging information. Services are also available for
obtaining information about the current execution environment such as
the current time and date, userid and group name, JOB card parameters,
and the prefix to use for qualifying data set names.

Environment support consists of a single load module and an assembler
copy member containing symbol definitions and macros. The load module
for Environment Support must be loaded into main storage and invoked
with the ES_START function (see ) before it can be used. After it has
been started, all of Environment Support's functions will remain
available until the ES_TERMINATE function (see ) has been invoked.


_*Warning:*_Some function descriptions are labeled
/*Clemson-Specific.*/These functions require operating system extensions
available only in Clemson University's production z/OS environment.
Attempts to use these functions will probably result in unusual return
codes or assorted abends.


    Symbols & Macros <#ToC_42>

Environment Support's symbols and macros can be found in the assembler
copy member SRVESMAC. This member contains symbols naming Environment
Support's load module, function codes, return codes, and parameter
values. It also contains macros for using all of Environment Support's
functions. The following statement or its equivalent should appear at
the beginning of any program that uses Environment Support:

*Figure 13. Environment Support's Symbols and Macros* <#FT_Figure_13>



  COPY  SRVESMAC      | Obtain Environment Support's symbols & macros.

------------------------------------------------------------------------


    Establishing Service Processor Identifiers <#ToC_43>

Several parameters are general to Environment Support and not specific
to any function. These parameters include the load module's name
(/es_epname/), the entry point address (/es_epa/), the token value
(/es_token/), and the Environment Support Vector's address (/esva/). The
ES_ID macro (see ) can be used to establish defaults for these
parameters and associate them with a unique service processor
identifier. The identifier may then be supplied on any Environment
Support macro instruction to refer to the default parameter values.

------------------------------------------------------------------------


    Choosing an Environment Support Load Module <#ToC_44>

In order to support different execution environments, there may be more
than one Environment Support service processor. However, all will have
the same basic protocol and will use the same COPY member. Each
Environment Support will reside in a separate load module, and the COPY
member will contain a different symbol for each one's load module name.
This provides programs with a degree of independence from their
environment, as switching to the appropriate Environment Support service
processor may be all that is required in order to run under different
environments.

Environment Support, acting as an interface between programs and their
execution environment, has intimate knowledge of the environment in
which it runs. It directly invokes system services and may interrogate
control blocks. To support multiple execution environments, there must
be separate Environment Support service processors for each environment,
identical in appearance to calling programs, but existing in separate
load modules. For example, in addition to the Environment Support that
runs directly under MVS, there might be one for VM, one for CICS and
another for IDMS/DC.

At the time of this writing, only the MVS/XA programming environment is
supported. However, a program that uses Environment Support's services
instead of directly accessing its environment can run under different
environments in the future simply by switching to the appropriate
Environment Support module.

Symbols defined in copy member SRVESMAC contain Environment Support's
load module names enclosed in single quotation marks. The symbol for the
MVS/XA Environment Support service processor looks like the following:

&MVS_ENVIRONMENT_SUPPORT   SETC  '''SRVESMVS'''

This symbolic name should be used as the service processor entry point
name for environment support as shown in the following ES_ID macro.

ES_ID ID=UNIQUE_NAME,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT

------------------------------------------------------------------------


    Loading Environment Support <#ToC_45>

The application program or its caller is responsible for loading
Environment Support's load module into storage. Because Environment
Support's services are not available until it has been loaded and
started, the load process is environment-dependent. For example, an
assembler program running under MVS/XA would need to issue a LOAD
EPNAME=&MVS_ENVIRONMENT_SUPPORT macro instruction and save register 0
(R0) as the entry point address.

To take advantage of the defaults established by ES_ID, use one of the
environment-specific load macros available for loading Environment
Support. In the MVS/XA environment, the code to identify and load
Environment Support would look like the following:

COPY        SRVESMAC            Obtain Env. Sup. symbols and macros.
ES_ID       ID=UNIQUE_NAME,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT
ES_MVS_LOAD ID=UNIQUE_NAME      Load Environment Support into storage.

The ES_MVS_LOAD macro issues the same LOAD instruction described above,
but it has access to the entry point address field (/es_epa/) generated
by the ES_ID macro instruction so nothing needs to be expicitly
specified. A complimentary macro, ES_MVS_UNLOAD, will generate the
appropriate DELETE instruction to remove Environment Support from storage.

------------------------------------------------------------------------


    Data Areas <#ToC_46>

There are three data areas associated with Environment Support: the
Environment Support Vector (ESV), Module Name Tables (MNTs), and the
Debugging Information Area (DIA). Of these, only the DIA is not directly
accessable to programs using Environment Support: it is accessed via
function calls instead.


      The Environment Support Vector <#ToC_47>

The ESV is a data area created by Environment during the ES_START
function to hold information specific to the current execution
environment. This information is used internally by Environment Support
and by other service processors. The fields of the ESV are mapped by the
ES_ESV macro ().

For the most part, programs do not have any reason to access the ESV's
fields. However, two of the fields contained in the ESV may be needed
occasionally. These are the ESVESEPA and the ESVESTKN. The ESVESEPA
contains the entry point address of Environment Support, and ESVESTKN
contains the token for the service processor session used to create the
ESV. These fields are of particular use to a routine that is called when
Environment Support is already active: if the routine has the address of
the ESV, it can easily obtain the entry point address and token needed
for calling Environment Support's functions. This is illustrated in the
following example, which establishes addressability on the ESV just long
enough to copy the EPA and TOKEN of Environment Support (neither value
will change until Environment Support is terminated or unloaded). /(Ref
#1.)/

BLOCK NAME=CMDEXEC,PARMS=(COMMAND,LENGTH,ESV),                       +
             OPTIONS=(*PWA,(ESV,3),(PARMS,COPY,PREFIX,VL)
  L     R1,&PPL.ESV              | R1 -> Environment Support Vector.
  USING ESV,R1                   | Establish addressability.
  MVC   &PWA.ES_SPEPA,ESVESEPA   | Copy Environment Support's EPA.
  MVC   &PWA.ES_SPTOKEN,ESVESEPA | Copy Environment Support's TOKEN.
  DROP  R1                       | Drop addressability.
  ES_ID ID=ES,SPEPA=&PWA.ES_SPEPA,SPTOKEN=&PWA.ES_SPTOKEN
*
  ES_DISPLAY_MESSAGE ID=ES,MESSAGE='The command to execute is:'
  ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(*&PPL.COMMAND,*&PPL.LENGTH)

  ... Remainder of program code ...

ENDBLK BLOCK=CMDEXEC
                  PWA
&PWA.ES_SPEPA     DS  A
&PWA.ES_SPTOKEN   DS  F

                  ... Remainder of program work area ...

                  ENDPWA
                  ES_ESV         Environment Support Vector DSECT.


      Module Name Tables <#ToC_48>

The purpose of module name tables (MNTs) is to reduce the number of
system loads that must be performed by the ES_LOAD_MODULE function. Two
MNTs may be searched by ES_LOAD_MODULE: an application MNT and
Environment Support's MNT. The application MNT is provided as an
optional parameter to the ES_START function by the calling program. The
ES_LOAD_MODULE function will search the application MNT first and then
Environment Support's MNT.

A module name table is an array of module names and addresses, with each
row in the array consisting of an eight character name followed by a
four byte address. The final entry in the array is denoted by all zeros.
Typically, the modules named in an MNT are link-edited with the MNT and
the addresses are filled in by the system loader. A module name table
may also be filled in by the application program before it starts
Environment Support.

The structure of an MNT is depicted in Figure 14 <#FIGMNTSTR>, which has
entries for three service processor modules:

*Figure 14. Module Name Table Layout* <#FT_FIGMNTSTR>



                Name    TrueName        EPA

------------------------------------------------------------------------

        +0      SRVMM   SRVMM   025BF700        Memory Manager.

------------------------------------------------------------------------

        +20     SRVMS   SRVMSMVS        00000000        Message Services.

------------------------------------------------------------------------

        +40     SRVPL   SRVPLMVS        00000000        Printline.

------------------------------------------------------------------------

        +80     SRVST   SRVST   02487AC0        String Handler.

------------------------------------------------------------------------

        +100    SRVSY   SRVSY   00000000        Symbol Manager.

------------------------------------------------------------------------

        +120    00                      End of MNT.

------------------------------------------------------------------------



The first two entries in Figure 14 <#FIGMNTSTR> show modules that have
been loaded into storage. The third entry shows a module that has not
been loaded into storage, so its address field has been set to zeros.

When a module's name is found in an MNT and it has a non-zero value in
the address field, its address is simply returned to the calling
program. If the address field is zero, ES_LOAD_MODULE will load the
module into storage and return the address to the calling program (which
may then fill in the module's address in the MNT). If the module's name
is not in any MNT, it will always be loaded into storage and its address
will be returned to the calling program.


      The Debugging Information Area <#ToC_49>

Error tracking and reporting capabilities are provided by Environment
Support, permitting service processors and other programs to save vital
diagnostic information and messages when errors are detected. Service
processors update this area and set a return code whenever they
encounter problems. The calling program may then issue a single function
call to Environment Support to display the diagnostic information and
optionally abort with a full storage dump. This scheme enables
applications to make their own decisions about how errors should be
handled, but provides an easy way for them to abort execution
immediately while providing the user with messages and diagnostic
information.

The following services are provided for accessing the DIA:

  *

    ES_CLEAR_DEBUG_INFO,

  *

    ES_DISPLAY_DEBUG_INFO,

  *

    ES_DISPLAY_DEBUG_INFO_AND_ABEND, and

  *

    ES_SAVE_DEBUG_INFO

------------------------------------------------------------------------


    Common Parameters <#ToC_50>

There are several parameters common to any Environment Support function
call. These parameters are listed below:


*Field *



*Description *

id_name



the name of a service processor identifier created by the ES_ID macro
which will be used by all other function invocation macros to
automatically obtain values for /es_epa/and /es_token/. This parameter
is required unless both /es_epa/and /es_token/are specified.

es_epa



a fullword in storage containing the entry point address of the
Environment Support service processor. The value specified by
/es_epa/overrides any value obtained from ID=/id_name/.

es_token



a fullword in storage containing the value (to be) returned by ES_START
for the /es_token/parameter. The value specified by /es_token/overrides
any value obtained from ID=/id_name/.



------------------------------------------------------------------------


    Complete List of Environment Support Return Codes <#ToC_51>

Many return codes can be returned from each function. In the function
descriptions later in this chapter, the most common return codes
returned by the particular function are documented. The following is a
complete list of Environment Support return codes.


*Return Code *



*Symbol Name*



*Description *

0



ES_SUCCESS



The invoked Environment Support function performed the requested service
without encountering any problems.

1



ES_MISSING_EXIT_ROUTINE



This return code indicates that the ES_START function was unable to
locate one of its exit routines, which must either be link-edited into
the standard or application module name table or accessable via the
standard system load mechanism.

2



ES_INTERNAL_ERROR



A self-examination within Environment Support determined that something
was wrong. This return code indicates a programming error within
Environment Support.

4



ES_INVALID_FUNCTION



An invalid /FunctionCode/(the second parameter in any service processor
function call) was specified.

8



ES_COULD_NOT_LOCATE



This return code is used by all ES_GET_... functions to indicate that
the requested information is unavailable.

12



ES_INVALID_BOUNDARY



The /boundary/parameter used for an ES_OBTAIN_STORAGE function call does
not contain a valid value.

16



ES_INVALID_LOCATION



The /location/parameter used for an ES_OBTAIN_STORAGE function call does
not contain a valid value.

17



ES_INVALID_ACTION



The /action/parameter used for an ES_CLEAR_DEBUG_INFO function call does
not contain a valid value.

18



ES_CLEAR_DEBUG_INHIBITED



An explicit attempt was made to clear the debugging information area
(function call ES_CLEAR_DEBUG_INFO ID=xx,ACTION=EXECUTE), but this
function had been inhibited by a previous call (with ACTION=INHIBIT).
The content of the debugging information area has been left intact.

20



ES_STORAGE_NOT_AVAILABLE



An ES_OBTAIN_STORAGE function call requested more storage than is
currently available.

24



ES_STORAGE_NOT_RELEASED



An ES_RELEASE_STORAGE function call failed because the storage could not
be released for some reason (perhaps it was not allocated in the first
place?).

28



ES_UNDETERMINED



An (internal, probably) error of indeterminate nature has occurred
within Environment Support.

32



ES_MODULE_NOT_LOADED



An ES_LOAD_MODULE function call was not able to load the requested
module into storage.

36



ES_MODULE_NOT_UNLOADED



An ES_UNLOAD_MODULE function call was not able to unload the requested
module from storage.

40



ES_WRONG_NUMBER_OF_PARMS



Either too few parameters were supplied for the function call or too
many were supplied. Check the parameter list to ensure that it is right
for the function being invoked.




    Environment Support Service Processor Functions and Macros <#ToC_52>

The remaining sections of this chapter describe all functions provided
by the Environment Support Service Processor, arranged in alphabetical
order. Each function's description begins on a new page, and the name of
the function being described appears in the top outside corner of every
page. \

_*ES_CLEAR_DEBUG_INFO - Reset the Debugging Information Area*_

The ES_CLEAR_DEBUG_INFO function removes all information from the
debugging information area. This function is invoked automatically by
all service processors functions so that the only information retained
in the debugging area is for the most recent problem.

*Note: *The only return code you should expect from invoking this
function is ES_SUCESS.

ES_CLEAR_DEBUG_INFO ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
  Ý,ACTION=/action/¨
CALLX /es_epa/,(/es_token/,&ES_CLEAR_DEBUG_INFO,Ý/action/¨)


*Parameter *



Description

action



An optional fullword value that specifies what action
ES_CLEAR_DEBUG_INFO should take with respect to clearing the debugging
information area. The default value for /action/is *EXECUTE*(or set
symbol &ES_CDI_EXECUTE, a fullword value of *1*), which will clear the
debugging information area if this function has not been inhibited. A
value of *INHIBIT*(set symbol &ES_CDI_INHIBIT, a fullword value of *2*)
will inhibit clearing of the debugging information area. A value of
*ENABLE*(set symbol &ES_CDI_ENABLE, a fullword value of *3*) will
reverse the effect of *INHIBIT*.



*Note: *Clearing of the debugging information area should not be
inhibited except under one circumstance: after an error has occurred, an
application program or service processor may need to call upon one or
more service processor functions to help gather and/or format additional
diagnostic information, without losing the information already present
in the debugging information area. The INHIBIT action should only be
invoked under this one condition, and the ENABLE action should be
invoked as soon as the additional diagnostic information has been
gathered and added to the debugging area. Calling on the ENABLE, action
does not, in itself, cause the debugging information area to be cleared.

*Note: *If ES_CLEAR_DEBUG_INFO is invoked while the function is
inhibited, it will not perform any action but will return a non-zero
return-code (ES_CLEAR_DEBUG_INHIBITED).


      Example

Suppose an application program invokes the ST_FORMAT function of the
string-handler service processor to format a message. The last field in
the message will contain text of unknown length, so the application
program expects to receive the ST_TRUNCATED return code occasionally. In
that specific case, the application program has no need for the
debugging information and clears it out to avoid having it show up in a
core dump if an abend occurs later.




  ST_FORMAT ID=ST,CONTROL='APM0282 Remaining text discarded: %C(V)',        +
               SOURCE=(INPUT_BUFFER,INPUT_LENGTH),                          +
               STRING=MESSAGE_BUFFER,RESULT_LENGTH=MESSAGE_LENGTH
  IF (CH,R15,EQ,=H'&ST_TRUNCATED')    | If some text got truncated.
    ES_CLEAR_DEBUG_INFO ID=ES         |   Don't worry about it.
  ELSEIF (TREG,R15,NZ)                | ElseIf there was another problem.
    STH     R15,PWA_LASTRC            |   Save the return code.
    MVC     PWA_LASTSP,=C&STRING_HANDLER  Save service processor's name.
    ERREXIT CODE=&ST_FORMAT           |   Let the error exit handle it.
  ENDIF                               | EndIf.



_*ES_DISPLAY_DEBUG_INFO - Display Debugging Information*_

The ES_DISPLAY_DEBUG_INFO function displays all information currently in
the debugging area. This function, or the
ES_DISPLAY_DEBUG_INFO_AND_ABEND function, should be invoked whenever an
unexpected return code is returned by any service processor function.

*Note: *The only return code you should expect from invoking this
function is ES_SUCESS.

ES_DISPLAY_DEBUG_INFO ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
CALLX /es_epa/,(/es_token/,&ES_DISPLAY_DEBUG_INFO)


      Example

The error exit of an application program has determined that the return
code from a service processor function indicates an environmental
problem beyond its control, such as a data set that is allocated to
another user, or insufficient storage. The problem needs to be corrected
before execution can continue, so the debugging information is displayed
and the program terminates execution.

ES_DISPLAY_DEBUG_INFO ID=ES              | Dump debugging information.

_*ES_DISPLAY_DEBUG_INFO_AND_ABEND - Abend with Dump*_

The ES_DISPLAY_DEBUG_INFO_AND_ABEND function displays all information
currently in the debugging area and then issues a system request for an
abend and storage dump. The actual abend code issued is dependent on the
implementation of Environment Support. For the MVS/XA version of
Environment Support, an MVS ABEND instruction with User Code 1000 will
be issued.

*Note: *This function does not return control to the application
program. It causes a task abend with a user code of 1000.

ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=/id_name/ Ý,SPEPA=/es_epa/¨
  Ý,SPTOKEN=/es_token/¨
CALLX /es_epa/,(/es_token/,&ES_DISPLAY_DEBUG_INFO_AND_ABEND)


      Example

The error exit of an application program has determined that the return
code from a service processor function indicates a programming error,
either within the application or within a service processor. Because the
error may be internal to the code being executed, all code and data
areas should be dumped.

ES_DISPLAY_DEBUG_INFO_AND_ABEND ID=ES    | Abort with a core dump.

_*ES_DISPLAY_MESSAGE - Display Text on the User's Screen*_

The ES_DISPLAY_MESSAGE function is used to write a textual message to
the default output device. For a TSO user, it is to the terminal screen;
for background TSO, it is to file SYSTSPRT; for a started task, it is to
the operator's console.

ES_DISPLAY_MESSAGE ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
   ,MESSAGE={/message/ | (/message/,/length/)}
CALLX /es_epa/,(/es_token/,&ES_DISPLAY_MESSAGE,/message/Ý,/length/¨)



*Parameter *



Description

message



specifies the label of a character string in storage containing the
message to be displayed. For both forms of invoking this function,
/message/may be specified as text enclosed in single quotation marks,
which will cause a character-literal to be generated.

length



Ýoptional¨ specifies the label of a fullword in storage containing the
length of the character string named by /message/. If /length/is
/not/specified, the storage named by /message/must be prefixed with a
signed halfword containing the length of the text to be displayed.

*Note: *For the macro form of invoking this function, if /message/is
provided as a quoted string and /length/is not specified, it will be
automatically supplied by the macro.


      Example

An application program invokes the ST_FORMAT function of the
string-handler to format a message, and then invokes the
ES_DISPLAY_MESSAGE function to display it to the user.

ST_FORMAT ID=ST,CONTROL='APM0282 Remaining text discarded: %C(V)',   +
             SOURCE=(INPUT_BUFFER,INPUT_LENGTH),                     +
             STRING=MESSAGE_BUFFER,RESULT_LENGTH=MESSAGE_LENGTH
IF (CH,R15,EQ,=H'&ST_TRUNCATED')    | If some text got truncated.
  ES_CLEAR_DEBUG_INFO ID=ES         |   Don't worry about it.
ELSEIF (TREG,R15,NZ)                | ElseIf there was another problem.
  STH     R15,PWA_LASTRC            |   Save the return code.
  MVC     PWA_LASTSP,=C&STRING_HANDLER  Save service processor's name.
  ERREXIT CODE=&ST_FORMAT           |   Let the error exit handle it.
ENDIF                               | EndIf.
ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(MESSAGE_BUFFER,MESSAGE_LENGTH)

_*ES_ESV - Environment Support Vector Mapping Macro *_

The ES_ESV macro is used to map the fields of the Environment Support
Vector, or ESV. For an example of using this macro, see page reference
#1 <#SPTESVXMP>.

ES_ESV
  Ý,DSECT={_*YES*_ | *NO*}¨
  Ý,PREFIX={_*ESV*_ | /prefix/}¨



*Parameter *



Description

DSECT



the *DSECT*keyword controls whether or not an assembler DSECT directive
is generated. The default is *YES*. The value of /prefix/will be used to
name the DSECT. If DSECT=NO is specified, a label named /prefix/will be
generated at the beginning of the ESV storage.

prefix



specifies the name to use for the generated DSECT or label, as well as
the prefix for all the labels of all other ESV fields.



_*ES_GET_CACCT - Get the Computer Center Account Number*_(Clemson-Specific)

The ES_GET_CACCT function returns to the application the Computer Center
Account Number (CACCT) of the currently running job.

*Note: *This function is specific to the /*Clemson University*/computing
environment.

ES_GET_CACCT ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
   ,CACCT=/cacct/
CALLX /es_epa/,(/es_token/,&ES_GET_CACCT,/cacct/)



*Parameter *



Description

cacct



specifies an eight (8) byte field into which the computer center account
number of the currently running job will be placed.



_*ES_GET_DEFAULT_DESTINATION - Get Printer Destination*_(Clemson-Specific)

The ES_GET_DEFAULT_DESTINATION function returns to the application the
printer destination of the currently running job.

ES_GET_DEFAULT_DESTINATION ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
   ,DEST=/dest/
CALLX /es_epa/,(/es_token/,&ES_GET_DEFAULT_DESTINATION,/dest/)



*Parameter *



Description

dest



specifies an eight (8) byte field into which the default printer
destination of the currently running job will be placed.



_*ES_GET_FORMATTED_TIME - Get Time and Date*_

The ES_GET_FORMATTED_TIME function returns to the application the
current time of day, gregorian date, and julian date.

ES_GET_FORMATTED_TIME ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
  Ý,TIME=/time/¨
  Ý,GREGORIAN=/gregorian/¨
  Ý,JULIAN=/julian/¨
CALLX /es_epa/,(/es_token/,&ES_GET_FORMATTED_TIME,Ý/time/¨,
  Ý/gregorian/¨,Ý/julian/¨)



*Parameter *



Description

time



specifies an eleven (11) byte field into which the current time, in
HH:MM:SS.TH character format (e.g. 18:09:53.78) will be placed. The time
is returned in 24-hour format.

gregorian



specifies an eight (8) byte field into which the current date, in
MM/DD/YY character format (e.g. 05/04/89) will be placed.

julian



specifies an eight (8) byte field into which the current date, in
CCYY.DDD character format (e.g. 1989.124) will be placed.



_*ES_GET_GROUP - Get the RACF Group Name of the Current User*_

The ES_GET_GROUP function returns to the application the RACF group name
under which the current job is running.

ES_GET_GROUP ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
   ,GROUP=/group/
CALLX /es_epa/,(/es_token/,&ES_GET_GROUP,/group/)



*Parameter *



Description

group



specifies an eight (8) byte field into which the RACF group name under
which the currently running job is running will be placed.

_*ES_GET_JOBCARD_NAME - Get the Programmer Comment Field
*_(Clemson-Specific)

The ES_GET_JOBCARD_NAME function returns to the application the user
comment field from the job card of the currently running job.

ES_GET_JOBCARD_NAME_FIELD ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
   ,NAME=/name/
CALLX /es_epa/,(/es_token/,&ES_GET_JOBCARD_NAME,/name/)



*Parameter *



Description

name



specifies a twenty (20) byte field into which the programmer name field
of the currently running job's JOB card will be placed.



_*ES_GET_JOBCARD_ROOM - Get the Programmer Room Field*_(Clemson-Specific)

The ES_GET_JOBCARD_ROOM function returns to the application the room
field from the job card of the currently running job.

ES_GET_JOBCARD_ROOM ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
   ,ROOM=/room/
CALLX /es_epa/,(/es_token/,&ES_GET_JOBCARD_ROOM,/room/)



*Parameter *



Description

room



specifies a four (4) byte field into which the room field of the
currently running job's JOB card will be placed.



_*ES_GET_JOBID - Get the System Assigned Job Identifier*_(Clemson-Specific)

The ES_GET_JOBID function returns to the application the system assigned
job identifier of the currently running job.

ES_GET_JOBID ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
   ,JOBID=/jobid/
CALLX /es_epa/,(/es_token/,&ES_GET_JOBID,/jobid/)



*Parameter *



Description

jobid



specifies an eight (8) byte field into which the system-assigned job
identifier for the currently running job will be placed.

_*ES_GET_PREFIX - Get Data Set Name Prefix*_

The ES_GET_PREFIX function returns to the application the data set name
prefix to use for unqualified data set names encountered under the
currently running job.

ES_GET_PREFIX ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
   ,PREFIX=/prefix/
CALLX /es_epa/,(/es_token/,&ES_GET_PREFIX,/prefix/)



*Parameter *



Description

prefix



specifies an eight (8) byte field into which the current TSO user's data
set name prefix will be placed.

_*ES_GET_SYSRES_VOLUME_NAME - Get Volser of IPL Volume*_

The ES_GET_SYSRES_VOLUME_NAME function returns to the application the
volume serial name of the volume from which the system was IPLed.

ES_GET_SYSRES_VOLUME_NAME ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
   ,VOLSER=/volser/
CALLX /es_epa/,(/es_token/,&ES_GET_SYSRES_VOLUME_NAME,/volser/)



*Parameter *



Description

volser



specifies a six (6) byte field into which the volume serial number of
the volume from which the currently running system was IPLed will be placed.

_*ES_GET_TERMINAL_NAME - Get the User's Terminal Name*_(Clemson-Specific)

The ES_GET_TERMINAL_NAME function returns to the application the
terminal name of the terminal assigned to the current user.

ES_GET_TERMINAL_NAME ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
   ,NAME=/name/
CALLX /es_epa/,(/es_token/,&ES_GET_TERMINAL_NAME,/name/)



*Parameter *



Description

name



specifies an eight (8) byte field into which the current TSO user's
terminal name will be placed.



_*ES_GET_TIME - Get Time and Date*_

The ES_GET_TIME function returns to the application the current time and
date.

ES_GET_TIME ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
  Ý,TIME=/time/¨
  Ý,DATE=/date/¨
CALLX /es_epa/,(/es_token/,&ES_GET_TIME,/time/,/date/)



*Parameter *



Description

time



specifies a fullword into which the current time of day, in .01 second
units, will be placed.

date



specifies a fullword into which the current date, in packed-decimal
CCYYDDDs format, will be placed.

_*ES_GET_TSU_STC_OR_JOB - Determine the Current Environment*_

The ES_GET_TSU_STC_OR_JOB function returns to the application an
indicator of the environment under which it is running.

ES_GET_TSU_STC_OR_JOB ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
   ,TYPE=/type/
CALLX /es_epa/,(/es_token/,&ES_GET_TSU_STC_OR_JOB,/type/)



*Parameter *



Description

type



specifies a three (3) byte field into which an indicator of the current
execution environment will be placed. The indicator will be "TSU" if
executing under foreground TSO, "STC" if executing as a started-task,
and "JOB" if executing as a batch job.



_*ES_GET_USERID - Get the Userid of the Current User*_

The ES_GET_USERID function returns to the application the userid of the
currently running TSU session.

ES_GET_USERID ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
   ,USERID=/userid/
CALLX /es_epa/,(/es_token/,&ES_GET_USERID,/userid/)



*Parameter *



Description

userid



specifies a seven (7) byte field into which the userid of the TSO user
currently logged on will be placed.



_*ES_ID - Establish Default Environment Support Values*_

The ES_ID macro is used to establish default values for use by other
Environment Support macros, which may access those defaults through a
unique identifier, /id_name/, specified by the user. Default values can
be established for the following parameters: /es_epname/, /es_epa/,
/es_token/, and /esva/.

In most cases, nothing other than the entry point name needs to be
specified on the ES_ID macro: it will automatically define working
storage fields for the remaining parameters if they are not specified.
These values, whether generated by the macro or provided by the user,
are accessable from all other Environment Support macros.

If the application program needs to access the parameters directly, then
they should be explicitly specified. For example, suppose a program
receives as one of its parameters the Environment Support Vector of an
already-started Environment Support service processor. In that case, the
module name would not be needed but the entry point address and token
value, already defined within the ESV, would need to be specified.
Assuming addressability on the ESV, the following ES_ID macro
instruction might be used to specify these fields.

ES_ID ID=STARTED_ES,SPEPA=ESVESEPA,SPTOKEN=ESVESTKN
ES_ID ID=/id_name/
  Ý,SPEPNAME=/es_epname/¨
  Ý,SPEPA=/es_epa/¨
  Ý,SPTOKEN=/es_token/¨
  Ý,ESVA=/esva/¨



*Parameter *



Description

id_name



the identifier to assign to the service processor identifier being
established. This name must be unique for all service processor
identifier's.

es_epname



the entry point name of the Environment Support service processor module
that is being used.

es_epa



specifies the label of a fullword in storage that will contain the entry
point address of the Environment Support service processor.

es_token



specifies the label of a fullword in storage that will contain the token
assigned by the ES_START function of Environment Support.

esva



specifies the label of a fullword in storage that will contain the
address of the environment support vector created by the ES_START
function of Environment Support.


      Example 1

The ES_ID macro below is the one most likely to be used in an MVS
assembler program. It specifies an /id_name/of ES and the entry point
name for the MVS environment support module, but allows all other values
to default. The ES_ID macro will generate fields in the Structured
Macros PWA for holding environment support's entry point address,
service processor token fullword, and a pointer to the environment
support vector. All other environment support macros will be able to
access those fields simply by specifying ID=ES

ES_ID     ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT


      Example 2

The next example shows how a program would be set up if it were called
with environment support already active. Presumably, the program would
have the environment support vector passed to it as one of its
parameters, and the example shows surrounding program text that takes
this into account. This is, in fact, the situation with service
processors themselves; their START function is always called with an ESV
as one of the parameters.

BLOCK NAME=SERVER,TYPE=PROGRAM,OPTIONS=(*PWA),R1SAVE=R9
  USING PARM_LIST,R9                       | R9 -> Parm list passed in.
  L     R8,PARM_ESV                        | R8 -> Active ESV.
  USING ESV,R8                             | Establish addressability.
  ES_ID ID=ACTIVE_ES,ESV=PARM_ESV,SPEPA=ESVESEPA,SPTOKEN=ESVESTKN
  .
  . Remaining program.
  .
ENDBLK BLOCK=SERVER

Notice that since the ESV contains fields within it for the EPA and
TOKEN, its fields may be named directly on the ES_ID macro. However, if
this is done, all environment support macros must have addressability to
the ESV. It is usually easier to copy these two values to the PWA to
save on register usage.

_*ES_LOAD_MODULE - Load a Module into Main Storage*_

The ES_LOAD_MODULE function is used to load a module into storage. If
the module name is in the application Module Name Table (MNT) or the
standard MNT and the table entry contains a nonzero entry point address,
ES_LOAD_MODULE returns this address to the caller; otherwise, the
request is satisfied by issuing an MVS LOAD macro.

ES_LOAD_MODULE ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
  Ý,SPID=/spid_name/¨
  Ý,EPNAME=/epname/¨
  Ý,EPA=/epa/¨
  Ý,TYPE={:us.STANDARD:eus. | MNT_ONLY}
CALLX /es_epa/,(/es_token/,&ES_LOAD_MODULE,/epname/,/epa/Ý,/type/¨)



*Parameter *



Description

spid_name



specifies the name of a service processor identifier created by any
/xx/_ID macro which will be used by the ES_LOAD_MODULE macro to
automatically obtain values for /epname/and /epa/(see below). This
parameter is required unless both /epname/and /epa/are specified.

epname



an eight byte field containing the name of the entry point to be loaded.
This parameter may be specified in single quotes if desired, in which
case a literal will be created for it. The value specified by
/epname/overrides any value obtained from SPID=/spid_name/.

epa



specifies the address of a fullword into which will be stored the
address of the module loaded. The value specified by /epa/overrides any
value obtained from SPID=/spid_name/.

type



specifies the process by which a module may be loaded. The
*STANDARD*process is to search the application MNT first (if there is
one), then the standard MNT; if the module is not in either MNT or if
the located MNT entry contains zeros for its EPA, a normal system load
will be performed. The *MNT_ONLY*process will not perform any load if
the module is not named in one of the MNTs, although a load may still be
done if the module's MNT entry contains zeros for its EPA. For the CALLX
form of invoking this function, symbols *&ES_LM_STANDARD*and
*&ES_LM_MNT_ONLY*may be used.


      Example

This example illustrates a program loading several service processors.
Since each service processor is assigned a unique service processor
identifier through xx_ID macro instructions, no tags are explicitly
created in working storage.

*
* Obtain symbols & macros for all service processors.
*
  COPY           SRVESMAC   Environment Support's symbols & macros.
  COPY           SRVMMMAC   Memory Manager symbols & macros.
  COPY           SRVSTMAC   String Handler symbols & macros.
  COPY           SRVSYMAC   Symbol Manager symbols & macros.
  COPY           SRVFIMAC   Standard File Handler symbols & macros.
*
* Establish default values for all service processors.
*
  ES_ID          ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT
  MM_ID          ID=MM,SPEPNAME=&MEMORY_MANAGER
  ST_ID          ID=ST,SPEPNAME=&STRING_HANDLER
  SY_ID          ID=SY,SPEPNAME=&SYMBOL_MANAGER
  FI_ID          ID=FI,SPEPNAME=&FI_OS_FILE_HANDLER
*
  ES_MVS_LOAD    ID=ES                Load environment support.
  ES_START       ID=ES                Start environment support.
  ES_LOAD_MODULE ID=ES,SPID=MM        Load the memory manager.
  ES_LOAD_MODULE ID=ES,SPID=ST        Load the string handler.
  ES_LOAD_MODULE ID=ES,SPID=SY        Load the symbol manager.
  ES_LOAD_MODULE ID=ES,SPID=FI        Load the standard file handler.

_*ES_MNT - Module Name Table Mapping Macro*_

The ES_MNT macro is used to map individual entries in a Module Name
Table, or MNT.

ES_MNT
  Ý,DSECT={_*YES*_ | *NO*}¨
  Ý,ID={_*ES_MNT*_ | /prefix/}¨



*Parameter *



Description

DSECT



the *DSECT*keyword controls whether or not an assembler DSECT directive
is generated. The default is *YES*. The value of /prefix/will be used to
name the DSECT. If DSECT=NO is specified, a label named /prefix/will be
generated at the beginning of the MNT storage.

prefix



specifies the name to use for the generated DSECT or label, as well as
the prefix for all the labels of all other MNT fields.

_*ES_MODULE_NAME - Module Name Table Creation Macro *_

The ES_MODULE_NAME macro is used generate entries in a static Module
Name Table.

ES_MODULE_NAME START,NAME='/table_name/'

- or -

ES_MODULE_NAME NAME='/generic_name/'Ý,TRUENAME='/entry_name/'¨

- or -

ES_MODULE_NAME END



*Parameter *



Description

table_name



Will be documented at a later time.

generic_name



Will be documented at a later time.

entry_name



Will be documented at a later time.



_*ES_MVS_LOAD - Load MVS Environment Support*_

The ES_MVS_LOAD macro is used in an MVS environment to load the
Environment Support module into main storage. This is only one possible
method that may be used and is provided as a convenience. This macro has
access to all fields identified by the ES_ID macro.

ES_MVS_LOAD ID=/id_name/ Ý,SPEPNAME=/es_epname/¨ Ý,SPEPA=/es_epa/¨



*Parameter *



Description

id_name



specifies the name of a service processor identifier created by the
ES_ID macro.

es_epname



specifies the entry point name of the Environment Support service
processor module that is being loaded.

es_epa



specifies the label of a fullword in storage that will contain the entry
point address of the Environment Support service processor.


        Return Codes

The ES_MVS_LOAD macro generates an MVS LOAD instruction, which will
cause a task abend if the module could not be found or loaded. The
content of register 15 (R15) is unpredictable.


      Example

This example illustrates the intended use of ES_MVS_LOAD. The macro has
access to all fields generated by the ES_ID macro, relieving the
programmer of the need to explicitly create any tags.

ES_ID       ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT  Set up an ES_ID.
ES_MVS_LOAD ID=ES                                    Load Env. Support.

_*ES_MVS_UNLOAD - Unload MVS Environment Support *_

The ES_MVS_UNLOAD macro complements the ES_MVS_LOAD macro by unloading
the environment support module from main storage.

ES_MVS_UNLOAD ID=/id_name/ Ý,SPEPNAME=/es_epname/¨ Ý,SPEPA=/es_epa/¨



*Parameter *



Description

id_name



specifies the name of a service processor identifier created by the
ES_ID macro.

es_epname



specifies the entry point name of the Environment Support service
processor module that is being loaded.

es_epa



specifies the label of a fullword in storage that will contain the entry
point address of the Environment Support service processor.



The ES_MVS_UNLOAD macro generates an MVS DELETE instruction, which will
set register 15 (R15) to 0 for successful completion and 4 for
unsuccessful completion.


      Example

This example illustrates the use of ES_MVS_UNLOAD to complement
ES_MVS_LOAD.

ES_ID       ID=ES,SPEPNAME=&MVS_ENVIRONMENT_SUPPORT  Set up an ES_ID.
ES_MVS_LOAD ID=ES                                    Load Env. Support.
   .
   . main body of program.
   .
ES_MVS_UNLOAD ID=ES                                  Unload Env. Sup.

_*ES_OBTAIN_STORAGE - Obtain a Block of Main Storage*_

The ES_OBTAIN_STORAGE function is used to obtain storage above or below
the 16 megabyte line on a doubleword or page boundary. This request for
storage is satisfied by issuing an MVS RC-form GETMAIN SVC.

ES_OBTAIN_STORAGE ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
  Ý,SUBPOOL={/subpool/ | *:us.0:eus.*}¨
  Ý,LOCATION={*:us.ANY:eus.* | *BELOW*}¨
  Ý,BOUNDARY={*:us.DOUBLEWORD:eus.* | *PAGE*}¨
   ,SIZE=/size/
   ,ADDRESS=/address/
CALLX /es_epa/,(/es_token/,&ES_OBTAIN_STORAGE,/size/,/subpool/,/boundary/,
              /location/,/address/)



*Parameter *



Description

size



a fullword containing the size in bytes of the storage area requested.

subpool



a fullword containing a binary 0 - 127 for the subpool that the storage
should be obtained from.

boundary



specifies whether the storage to be obtained should be allocated on a
*DOUBLEWORD*boundary or a *PAGE*boundary. For the macro, the default is
*DOUBLEWORD*. There is no default value for the CALLX form of invoking
this function, which requires that /boundary/indicate a fullword
containing a 1 (set symbol &ES_DOUBLEWORD_BOUNDARY) if the storage
should be obtained on a doubleword boundary and 2 (set symbol
&ES_PAGE_BOUNDARY) if it should be obtained on a page boundary.

location



specifies whether the storage to obtained must be allocated from below
the 16-megabyte line (*BELOW*) or if it may be obtained from any address
(*ANY*). The default value for the macro is *ANY*. There is no default
value for the CALLX form of invoking this macro, which requires that
/location/indicate a fullword containing a 1 (set symbol
&ES_LOCATION_ANY) if the storage may be allocated at any location and a
2 (set symbol &ES_LOCATION_BELOW) if the storage must be allocated below
the 16-megabyte line.

address



specifies the address of a fullword into which the ES_OBTAIN_STORAGE
function will store the address of the newly obtained storage. This
address will only be updated if the request for storage was successful.


      Example

The following macro instruction obtains 256 bytes of storage and saves
its address in PWA_MSGPTR.

  ES_OBTAIN_STORAGE ID=ES,SIZE=256,ADDRESS=PWA_MSGPTR

Assuming that ID=ES has established ES_EPA and ES_TOKEN as default
values for the /es_epa/and /es_token/parameters, respectively, this
instruction could also have been written as

  CALLX ES_EPA,(ES_TOKEN,&ES_OBTAIN_STORAGE,0,&ES_DOUBLEWORD_BOUNDARY,+
              &ES_LOCATION_ANY,256,PWA_MSGPTR)

_*ES_RELEASE_STORAGE - Release a Block of Main Storage*_

The ES_RELEASE_STORAGE function is used to release storage obtained by
the ES_OBTAIN_STORAGE function. This storage is released by issuing an
MVS RC-form FREEMAIN SVC.

ES_RELEASE_STORAGE ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
  Ý,SUBPOOL={/subpool/ | *:us.0:eus.*}¨
   ,SIZE=/size/
   ,ADDRESS=/address/
CALLX /es_epa/,(/es_token/,&ES_RELEASE_STORAGE,/size/,/subpool/,/address/)



*Parameter *



Description

size



a fullword containing the size in bytes of the storage area to be released.

subpool



a fullword containing a binary 0 - 127 for the subpool of the storage.

address



specifies the address of a fullword that contains the address of ahe
storage area to be released.



_*ES_SAVE_DEBUG_INFO - Save Debugging Information *_

The ES_SAVE_DEBUG_INFO function stores information in the debugging area
maintained by Environment Support. This information may then be
displayed by any service processor.

ES_SAVE_DEBUG_INFO ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨

Select one of

   ,GDI=/gdi/
or
   ,TEXT={/text/ | *(*/*text*/*,*/*length*/*)*}
   Ý,LABEL={/label/ | *(*/*label*/*,*/*length*/*)*}¨
or
   ,HEX={/hex/ | *(*/*hex*/*,*/*length*/*)*}
   Ý,LABEL={/label/ | *(*/*label*/*,*/*length*/*)*}¨

CALLX /es_epa/,(/es_token/,&ES_SAVE_DEBUG_INFO,

Select one of

              &ES_DEBUG_ID_GDI,/gdi/)
or
              &ES_DEBUG_ID_TEXT,/text/,Ý/length/¨,Ý/label/¨,Ý/length/¨)
or
              &ES_DEBUG_ID_HEX,/hex/,Ý/length/¨,Ý/label/¨,Ý/length/¨)



*Parameter *



Description

gdi



general debug information. Macro SRVGSI will map this control block.

text



text to be saved in debug area. If /length/is not specified, the first
two bytes of the storage referenced by /text/must contain the length of
the text.

hex



hex data to be saved in debug area. If /length/is not specified, the
first two bytes of the storage referenced by /text/must contain the
length of the text.

length



optional fullword length of the text or hex data to be saved in the
debug area.



_*ES_START - Begin an Environment Support Session *_

The ES_START function obtains and initializes a new Environment Support
Vector (ESV) and sets up Environment Support's internal working storage.
A unique session identifier is returned in the /es_token/parameter,
which must be specified when invoking any Environment Support function.
The address of the new ESV is returned to the application program via
the /es_epa/parameter. If the application provides a Module Name Table
(MNT), that will be retained within environment support for use by the
ES_LOAD_MODULE and ES_UNLOAD_MODULE functions.

ES_START ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
  Ý,ESVA=/esva/¨
  Ý,MNT=/mnt_address/¨
  Ý,EXITINFO=/exit_info/¨
CALLX /es_epa/,(/es_token/,&ES_START,/esva/Ý,/mnt_address/¨Ý,/exit_info/¨)



*Parameter *



Description

mnt_address



Ýoptional¨ specifies the label of a fullword in storage that contains
the address of an application Module Name Table.

exit_info



Ýoptional¨ specifies the label of a fullword in storage whose
/address/will be passed to all Environment Support exit modules as the
second parameter.



_*ES_TERMINATE - Stop an Environment Support session*_

The ES_TERMINATE function shuts-down Environment Support. It unloads all
modules that have been loaded by the ES_LOAD_MODULE function and are
still in storage, frees the storage occupied by the Environment Support
Vector, and releases Environment Support's working storage. Because
ES_TERMINATE frees the ESV, which is used by all service processors, it
should be issued only after all other service processors have been
terminated.

ES_TERMINATE ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
CALLX /es_epa/,(/es_epa/,&TERMINATE)

_*ES_UNLOAD_MODULE - Remove a Module from Main Storage*_

The ES_UNLOAD_MODULE function is used to remove a module from storage.
If the module name is in the application Module Name Table (MNT) or the
standard MNT and the table entry contains a nonzero entry point address,
ES_LOAD_MODULE simply returns to the caller; otherwise, the request is
satisfied by issuing an MVS DELETE macro instruction.

ES_UNLOAD_MODULE ID=/id_name/ Ý,SPEPA=/es_epa/¨ Ý,SPTOKEN=/es_token/¨
  Ý,SPID=/spid_name/¨
  Ý,EPNAME={/epname/¨
  Ý,EPA=/epa/¨
CALLX /es_epa/,(/es_token/,&ES_UNLOAD_MODULE,/epname/)


*Parameter *



Description

spid_name



specifies the name of a service processor identifier created by any
xx_ID macro, which will be used by the ES_UNLOAD_MODULE macro to
automatically obtain values for /epname/and /epa/.

epname



an eight byte field containing the name of the entry point to be unloaded.

epa



the field containing the module's entry point address. This can only be
specified on the macro form of ES_UNLOAD_MODULE and will cause the field
to be set to zeros.


------------------------------------------------------------------------


  Chapter 7. File Handlers <#ToC_53>

The File Handlers provide a generalized way to read and write sequential
files. The file handlers all work with the same parameters and produce
the same sets of return codes.

The File Handlers are each environment-dependent, but may be used with
any Environment Support service processor.

------------------------------------------------------------------------


    The Standard File Handler <#ToC_54>

The standard, or OS, file handler can be used to read and write
sequential files, in the form of a physical sequential file or an
individual PDS member. The OS file handler can also be made to
conditionally create, replace, or append to a sequential or partitioned
dataset, or a member of an existing PDS.

If used to create a file, the OS file handler will translate generalized
file characteristic information (estimated number of records, average
and maximum record length, etc) into information needed by MVS dynamic
allocation to create the disk dataset. In addition, the file creation
process may be provided with the UNIT, VOLUME and/or DIRBLKS parameters,
which can be set up using the FI_OS_INFO macro. An optimum blocksize is
calculated internally based on the type of device the file is being
created on.

When creating a dataset, the OS file handler has to determine the
optimum blocksize before calling MVS dynamic allocation. The OS file
handler currently allocates the new dataset in blocks, and attempts to
fit 6 blocks per track. (For example, a fixed-length file with 80-byte
records would cause a blocksize of 7440 to be selected on a 3380 disk
device.) If a specific volume is requested via the FI_OS_INFO macro, the
OS file handler will determine what type of device the volume is mounted
on, and calculate an optimum blocksize based on that device type. If a
volume is not specified, the device type of the MVS system's IPL volume
is used.

------------------------------------------------------------------------


    The ISPF/PDF File Handler <#ToC_56>

------------------------------------------------------------------------


    Preparing to use a File Handler <#ToC_58>


      Obtaining File Handler Symbols & Macros <#ToC_59>

The File Handler symbols and interface macros can be found in the
assembler copy member SRVFIMAC. This member contains symbols naming the
File Handler's load module, function codes, return codes, and parameter
values. It also contains macros for using all of the File Handler's
functions. The following statement or its equivalent should appear at
the beginning of any program that uses the string handler:

   COPY SRVFIMAC      Obtain the File Handler symbols & macros.


      Establishing File Handler Defaults <#ToC_60>

Some parameters are general to the strihg handler and not specific to
any function. These parameters include its load module name
(/fi_epname/), entry point address (/fi_epa/), and token value
(/fi_token/). The FI_ID macro (see ) can be used to establish defaults
for these parameters and associate them with a unique service processor
identifier. The identifier may then be supplied on any File Handler
macro instruction to refer to the default parameter values.


      Identifying the File Handler <#ToC_61>

The File Handler service processor resides in the load module named by
the following symbol definition in copy member SRVFIMAC:

&FI_OS_FILE_HANDLER  SETC  '''SRVFIOS  '''

This symbolic name should be used as the service processor entry point
name for the File Handler as shown in the following FI_ID macro
instruction.

FI_ID ID=FI,SPEPNAME=&FI_OS_FILE_HANDLER  Set File Handler Defaults.


      Loading the File Handler <#ToC_62>

The recommended method for loading the File Handler is through
Environment Support's ES_LOAD_MODULE function, as shown in the following
example:

ES_LOAD_MODULE ID=ES,SPID=FI            Load the File Handler

------------------------------------------------------------------------


    Common Parameters <#ToC_63>

Several parameters are common to all File Handler function calls. These
parameters are listed below:


*Parameter *



Description

id_name



specifies the name of a service processor identifier created by the
FI_ID macro which will be used by all other function invocation macros
to automatically obtain values for /fi_epa/and /fi_token/. This
parameter is required unless both /fi_epa/and /fi_token/are specified.

fi_epa



a fullword in storage containing the entry point address of the String
Handler service processor. The value specified by /fi_epa/overrides any
value obtained from ID=/id_name/.

fi_token



specifies the label of a fullword in storage that contains the value (to
be) returned by FI_START for the /fi_token/parameter. The value
specified by /fi_token/overrides any value obtained from ID=/id_name/.



------------------------------------------------------------------------


    Return Codes <#ToC_64>

Many return codes can be returned from each function. In the function
descriptions later in this chapter, the most common return codes
returned by the particular function are documented. The following is a
complete list of File Handler return codes.


*Return Code *



Symbol



Description

0



FI_SUCCESS



The File Handler function has completed successfully.

1



FI_END_OF_FILE



End of File has been reached.

2



FI_WARNING



Non-terminating error occurred.

3



FI_ERROR



Terminating error occurred.

4



FI_SEVERE



A severe terminating error.

5



FI_INVALID_SYNTAX



Unsupported filename syntax. The code is returned by the FI_START
function only; it is used when file-servers are being cascaded to
indicate that the file name is not for the type of file supported by
that particular file server and that the next server should be tried. If
file-servers are not being cascaded or if the last one has been tried,
FI_INVALID_SYNTAX should be treated in the same manner as FI_ERROR.

6



FI_INVALID_FILEID



A bad file-token was used.


    File Handler Service Processor Functions <#ToC_65>

The remaining sections of this chapter describe all functions provided
by the File Handler service processor, arranged in alphabetical order.
Each function's description begins on a new page, and the name of the
function being described appears in the top outside corner of every page.

_*FI_CLOSE - Close the File Being Processed*_

The FI_CLOSE function closes the file currently being processed but does
not deallocate from it. This function is normally not needed since
FI_TERMINATE will always close the file for you. However, if you need to
read the file again from the start and do not want to go through
allocation again, this function may be used.

FI_CLOSE ID=/id_name/ Ý,SPEPA=/fi_epa/¨ Ý,SPTOKEN=/fi_token/¨
CALLX /fi_epa/,(/fi_token/,&FI_CLOSE)

_*FI_GET_INFO - Obtain Information About a File*_

The FI_GET_INFO function retrieves information about the file identified
by the /fi_token/parameter. Information that can be obtained through
this function includes the most recent message issued, the file's name,
its logical record length, and its record format.

FI_GET_INFO ID=/id_name/ Ý,SPEPA=/fi_epa/¨ Ý,SPTOKEN=/fi_token/¨
  {
     ,NAME={(/name/,/length/) | /name/},NAMELEN=/namelen/
    |,MSG={(/msg/,/length/) | /msg/},MSGLEN=/msglen/
    |,LRECL=/lrecl/
    |,RECFM=/recfm/
    |,IDSTRING=/idstring/
  }

CALLX /fi_epa/,(/fi_token/,&FI_GET_INFO,
             {
              &FI_GI_NAME,/name/,/length/,/namelen/
             |&FI_GI_MSG,/msg/,/length/,/msglen/
             |&FI_GI_LRECL,/lrecl/
             |&FI_GI_RECFM,/recfm/
             |&FI_GI_IDSTRING,/idstring/
             })



*Parameter *



Description

Name, length,namelen



These three parameters specify an area in which to return the name of
the file being processed, a fullword containing the length of the area,
and a fullword into which the length of the file's name will be returned.

Msg, length,
msglen



These three parameters specify an area in which to return the most
recently created File Handler message, a fullword containing the length
of the area, and a fullword into which the length of the message will be
returned.

lrecl



A halfword into which the logical record length of the file being
processed will be returned.

recfm



An eight (8) character area into which the record format of the file
being processed will be returned.

idstring



An eight (8) character area into which a file-identifier string will be
returned. For members of a partitioned data set or other directory, the
member name will be used. For sequential data sets, one of the data
set's qualifiers will be used.



_*FI_ID - Establish Default File Handler Values *_

The FI_ID macro is used to establish default values for use by other
File Handler macros, which may access those values through a unique
identifier, /id_name/, specified by the user. When allowed to generate
default values, this macro will create Program Work Area (PWA) storage
for /fi_epa/and /fi_token/. These values, whether generated by the macro
or provided by the user, are accessable from all other File Handler
macros via the ID=/id_name/parameter.

FI_ID ID=/id_name/
  Ý,SPEPNAME=/fi_epname/¨
  Ý,SPEPA=/fi_epa/¨
  Ý,SPTOKEN=/fi_token/¨
  Ý,ESID=/esid_name/¨
  Ý,ESVA=/esva/¨



*Parameter *



Description

id_name



the identifier to assign to the service processor identifier being
established. This name must be unique for all service processor
identifier's.

fi_epname



the entry point name of the File Handler service processor module that
is being used. :pLt.fi_epa :pLd.specifies the label of a fullword in
storage that will contain the entry point address of the File Handler.

fi_token



specifies the label of a fullword in storage that will contain the token
assigned by the FI_START function of the File Handler.

esid_name



the name of a service processor identifier, created by the ES_ID macro,
which will be used by the FI_ID macro to automatically obtain the value
for esv (see below).

esva



specifies the label of a fullword in storage that contains (or will
contain) the address of the Environment Support Vector (ESV) created by
the ES_START function.


      Example 1

FI_ID     ID=FI_SMS,SPEPNAME=&SMS_FILE_HANDLER

_*FI_OPEN - Open the File For Processing *_

The FI_OPEN function opens the file currently allocated to and prepares
for processing. This will be done automatically by the FI_START function
unless option *MANUALOPEN*is specified. If an application needs to
allocate to a file once and then repeatedly open and close the file,
this function may be used in conjunction with the *MANUALOPEN*option.

FI_OPEN ID=/id_name/ Ý,SPEPA=/fi_epa/¨ Ý,SPTOKEN=/fi_token/¨
CALLX /fi_epa/,(/fi_token/,&FI_OPEN)

_*FI_OS_INFO - Provide OS-Specific Information About A File *_

The FI_OS_INFO macro is used to build a list of those parameters unique
to dataset creation using MVS dynamic allocation.

Unlike the other File Handler macros, FI_OS_INFO does not generate a
call to a service processor, or establish or use service processor
defaults. Instead, FI_OS_INFO generates a parameter list and constructs
dynamic allocation textunits in the caller's program workarea: this
list, in turn, is passed to FI_START using the INFO keyword.

There is no CALLX equivalent of the FI_OS_INFO macro.

FI_OS_INFO  PL=/parmlist_address/
          Ý,DIRBLKS=/PDS_dirblks/¨
          Ý,UNIT=/unit_name/¨
          Ý,VOLUME=/volume_ID/¨
          Ý,FREE=/free_value/¨
          Ý,SPIN=/spin_value/¨
          Ý,SYSOUT=/sysout_class/¨
          Ý,DS=/storage_area/¨



*Parameter *



Description

PDS_dirblks



Specifies the number of PDS directory blocks to be used when creating a
partitioned dataset. If not specified, the default is 10.

unit_name



Specifies the MVS unit name to be used when creating a dataset. If not
specified, the default is /SYSDA/.

volume



Specifies the volume serial number where the OS File Handler should
create a dataset. There is no default if volume is not specified, which
will cause the dataset to be created on an eligible disk volume mounted
as /storage/.

free_value



Keyword *CLOSE*or *END*, specifying that the file should be freed
(unallocated) by the system when it is closed or at the end of the
jobstep, respectively.

spin_value



Keyword *UNALLOC*or *NO*, specifying that the file should be release for
printing by the system when it is unallocated or at the end of the job,
respectively.

*Note: *When SPIN is used, the corresponding FI_START call should
specify OPTIONS=(SYSOUT). :pLt.sysout_class :pLd.specifies that this is
a sysout file and provides the sysout class to use. A sysout class of
'*' specifies that the system default sysout class should be used.

*Note: *When SYSOUT is used, the corresponding FI_START call should
specify OPTIONS=(SYSOUT).

parmlist_address



Provides a tag that FI_OS_INFO will generate when creating its parameter
list. This tag should be specified on the associated FI_START macro.
This is the only required parameter on the FI_OS_INOF macro.

storage_area



Instructs FI_OS_INFO to construct its parameter list in the program's
/PWA/or /SWA/. The default is for FI_OS_INFO to construct its parameters
in the storage area local to the block from which it was called.



_*FI_READLINE - Read the next Sequential Line from a File *_

The FI_READLINE function returns the next sequential input line of the
file specified by the /fi_token/parameter. The file must have been
opened with the INPUT_SEQUENTIAL access value.

FI_READLINE ID=/id_name/ Ý,SPEPA=/fi_epa/¨ Ý,SPTOKEN=/fi_token/¨
   ,LINE={/line/ | (/line/,/length/)}
   ,RESULTLEN=/result_len/
CALLX /fi_epa/,(/fi_token/,&FI_READLINE,/line/,/length/,/result_len/)



*Parameter *



Description

line



Provides the address of an area in storage where FI_READLINE should
return the next line of input.

length



Provides a fullword length of line.

resultlen



Provides a fullword in storage where FI_READLINE will return the length
of the line returned.



_*FI_START - Allocate to and Open a File*_

The FI_START function locates and opens the file named by /file/, and
prepares to access it in the manner specified in the /OPTIONS/parameter.
Currently, sequential input is supported for all file handlers, and
sequential output is supported by the OS file handler. Once the file has
been opened, it is ready for processing.

FI_START ID=/id_name/ Ý,SPEPA=/fi_epa/¨ Ý,SPTOKEN=/fi_token/¨
  Ý,ESVA=/esva/¨
   ,FILE={/file/ | *(*/*file*/*,*/*length*/*)*}
  Ý,INFO=/info/¨
  Ý,OPTIONS=(/option_list/)¨
  Ý,RECORDLENGTH=/average/ | *(*/*average,maximum*/*)*¨
  Ý,FILESIZE=/initial/ | *(*/*initial,increment*/*)*¨
CALLX /fi_epa/,(/fi_token/,&FI_START,/esva/,/info/,/file/,/length/,/optionbyte/,
              /avgreclen/,/maxreclen/,/initialsize/,/increment/¨)



*Parameter *



Description

file



specifies the label of an area in storage containing the name of the
file to be opened. The file name must follow standard convention for
files of its type.

length



specifies the label of a fullword in storage that contains a signed
binary integer equal to the length of the file name specified by /file/

info



Specifies the label of a fullword in storage containing a value whose
meaning may be different for each file handler service processor. In the
case of the OS file handler, the INFO parameter will point to a
parameter list built by the FI_OS_INFO macro.

options



Provides a list of options for handling the file being allocated and
opened. The supported options are:

  *

    *FILENAME*- The filename provided by the filename parameter is an
    actual filename (for example, an OS dataset name).

  *

    *FILEID*- The filename provided by the filename parameter is a file
    identifier of some kind (for example, a preallocated DDNAME if the
    OS file handler is being used).

  *

    *FILETEMP*- A temporary work file is being created.

  *

    *SYSOUT*- A sysout file is being created. *SYSOUT*requires
    *OUTPUT*and *NEW*, and implies *ISOCC*.

  *

    *INPUT*- The file is being opened for input processing.

  *

    *OUTPUT*- The file should be opened for output processing.

  *

    *NEW*- The file being opened for *OUTPUT*should be created. If the
    file already exists, an error will be returned. *NEW*is not valid
    for files being opened for *INPUT*.

  *

    *REPLACE*- The file being opened for *OUTPUT*should be created if it
    does not already exist. If it does already exist, its contents will
    be replaced. *REPLACE*is not valid for files being opened for *INPUT*.

  *

    *EXISTING*- The file must already exist. If the file is being opened
    for *OUTPUT*, its contents will be replaced.

  *

    *APPEND*- The file being opened for *OUTPUT*should be created if it
    does not already exist. If it does already exist, all new lines
    written to it will be appended to the existing contents. *APPEND*is
    not valid for files being opened for *INPUT*.

  *

    *ISOCC*- Indicates that lines contain ISO carriage control in the
    first byte. If the file handler supplies the record format for a
    file, the ISOCC option will cause the appropriate effect; otherwise,
    the ISOCC option is ignored.

  *

    *AUTOOPEN*- The file will automatically be opened for processing by
    the FI_START function. This is the default. Related parameter:
    *MANUALOPEN*.

  *

    *MANUALOPEN*- The file will not be automatically opened by FI_START:
    it must be opened using the FI_OPEN function before any processing
    may begin.

  *

    *AUTOFREE*- If the FI_START function allocates a new DDNAME to
    access the file, it will automatically be unallocated by the
    corresponding FI_TERMINATE function. Related parameter: *MANUALFREE*.

  *

    *MANUALFREE*- The file will not be unallocated by the FI_TERMINATE
    function, regardless of how it was allocated.

    The following OPTIONS parameters are mutually exclusive:

  *

    *FILENAME*and *FILEID*.

  *

    *AUTOFREE*and *MANUALFREE*

  *

    *AUTOOPEN*and *MANUALOPEN*

  *

    *INPUT*and *OUTPUT*

  *

    *APPEND*, *EXISTING*, *NEW*, and *REPLACE*

  *

    *INPUT*and any of *APPEND*, *NEW*, *REPLACE*, or *SYSOUT*.

optionvalue



Provides a one-byte value containing the option flag bits that
correspond to the possible OPTIONS values. Refer to the macro definition
for FI_START in copy member SRVFIMAC for the macro variable names that
represent the individual options' bit flags.

recordlength



Provides an average and (optionally) a maximum recordlength for a file
being created. During OUTPUT processing, the OS file handler uses the
average recordlength to determine the amount of disk space to request,
as well as to choose an optimum blocksize for the disk device being used
for the new file. For variable-length records, the maximum recordlength
is used to set the logical recordlength.

filesize



Provides a primary and (optionally) an incremental number of records
that will be stored in the file being created. These values are used to
determine how much disk space to request when a file is being created.



_*FI_TERMINATE - Close and Release a File *_

The FI_TERMINATE function ends a session with the File Handler. If the
file identified by /fi_token/has been allocated and opened, it will be
closed and released. All resources allocated to the session, including
buffers, working storage, and enqueues, are released back to the system.
This function must be invoked in order to cleanly terminate a File
Handler session, even if the FI_START function did not complete
successfully.

FI_TERMINATE ID=/id_name/ Ý,SPEPA=/fi_epa/¨ Ý,SPTOKEN=/fi_token/¨
CALLX /fi_epa/,(/fi_token/,&FI_TERMINATE)


      Example

The following statement is all that is needed to shut-down a session
with the File Handler.

FI_TERMINATE ID=DATA           Close and release input data file.

_*FI_WRITELINE - Add A Sequential Line To a File*_

The FI_WRITELINE function adds the line provided by the caller to the
file specified on the /FI_START/macro. The file must have been opened
with the OUTPUT option.

FI_WRITELINE ID=/id_name/ Ý,SPEPA=/fi_epa/¨ Ý,SPTOKEN=/fi_token/¨
   ,LINE={/line/ | (/line/,/length/)}
CALLX /fi_epa/,(/fi_token/,&FI_WRITELINE,/line/,/length/)


*Parameter *



Description

line



Provides the address of a record in storage to be added to the file
being created.

length



Provides a fullword length of the record being added to the file.


  Chapter 8. Item Manager <#ToC_66>

The Item Manager can be used to manage units of data, refered to as
items. Items can be associated with various data structures, such as,
linked lists and hash tables.

The Item Manager and this chapter are still under development.

The Item Manager is environment independent.


      Obtaining Item Manager Symbols & Macros <#ToC_67>

The Item Manager's symbols and interface macros can be found in the
assembler copy member SRVIMMAC. This member contains symbols naming the
Item Manager's load module, function codes, return codes, and parameter
values. It also contains macros for using all of the Item Manager's
functions. The following statement or its equivalent should appear at
the beginning of any program that uses the Item Manager:

   COPY SRVIMMAC      Obtain the Item Manager's symbols & macros.


      Establishing Item Manager Defaults <#ToC_68>

Some parameters are general to the Item Manager and not specific to any
function. These parameters include its load module name (/IM_epname/),
entry point address (/IM_epa/), and token value (/IM_token/). The IM_ID
macro (see ) can be used to establish defaults for these parameters and
associate them with a unique service processor identifier. The
identifier may then be supplied on any Item Manager macro instruction to
refer to the default parameter values.


      Identifying the Item Manager <#ToC_69>

The Item Manager service processor resides in the load module named by
the following symbol definition in copy member SRVIMMAC:

&ITEM_MANAGER     SETC  '''SRVIM  '''

This symbolic name should be used as the service processor entry point
name for the Item Manager as shown in the following IM_ID macro
instruction.

IM_ID ID=ST,SPEPNAME=&ITEM_MANAGER     Set Item Manager Defaults.


      Loading the Item Manager <#ToC_70>

The recommended method for loading the Item Manager is through
Environment Support's ES_LOAD_MODULE function, as shown in the following
example:

ES_LOAD_MODULE ID=ES,SPID=IM            Load the Item Manager


      Common Parameters <#ToC_71>

There are several parameters common to any Item Manager function call.
These parameters are listed below:



*Parameter *



Description

id_name



specifies the name of a service processor identifier created by the
IM_ID macro which will be used by all other function invocation macros
to automatically obtain values for /im_epa/and /im_token/. This
parameter is required unless both /im_epa/and /im_token/are specified.

im_epa



a fullword in storage containing the entry point address of the Item
Manager service processor. The value specified by /im_epa/overrides any
value obtained from ID=/id_name/.

im_token



specifies the label of a fullword in storage that contains the value (to
be) returned by IM_START for the /im_token/parameter. The value
specified by /im_token/overrides any value obtained from ID=/id_name/.


      Complete List of Item Manager Return Codes <#ToC_72>

Many return codes can be returned from each function. In the function
descriptions later in this chapter, the most common return codes
returned by the particular function, are documented. The following is a
complete list of return code.



*RC *



Symbol



Description

0



IM_SUCCESS



The function was completely successful.

2



IM_INVALID_NUMBER_OF_PARMS



The number of parameters supplied on the call to a function is not correct.

3



IM_INVALID_FUNCTION



The function code specified on a call to the Item Manager is not valid.

4



IM_FUNCTION_UNSUPPORTED_FOR_CLASS



The function is not supported for the class of the item supplied.

5



IM_DIV_START_FAILED



The Item Manager was not able to start the supplied DIV service processor.

6



IM_MEMORY_MANAGER_LOAD_ FAILED



The Item Manager was not able to load the memory manager.

7



IM_MEMORY_MANAGER_START_ FAILED



The Memory Manager failed when the Item Manager tried to start it.

8



IM_ITEM_STORAGE_NOT_ INITIALIZED



Item Manager Managed Storage had not been initialized yet. See for more
information.

9



IM_SETUP_ALREADY_COMPLETE



A second call was made to the IM_INITIALIZE function.

11



IM_INTERNAL_ERROR



Some kind of internal error has occured in the Item Manager. Use the
debug area to find out more information.

12



IM_INVALID_TOKEN



An invalid token was encountered when processing a function.

14



IM_STORAGE_NOT_AVAILABLE



The was not enough memory available in the user region to process the
function.

15



IM_DV_OPEN_WINDOW_FAILED



A call to the DV_OPEN_WINDOW function of the associated DIV service
processor has ended with a non-zero return code.

16



IM_DV_SAVE_FAILED



A call to the DV_SAVE function of the associated DIV service processor
has ended with a non-zero return code.

17



IM_DV_RESET_FAILED



A call to the DV_RESET function of the associated DIV service processor
has ended with a non-zero return code.

18



IM_FUNCTION_REQUIRES_DIV



The function envoked requires a DIV service processor EPA to be supplied
on the IM_START.

19



IM_INVALID_ITEM_TYPE_TOKEN



An item type token is not valid.

20



IM_ITEM_SIZE_REQUIRED



The itemsize parameter is required on the function call.

21



IM_NO_ROOM



There is not more room in Item Manager Managed Storage and no more can
be obtained.

22



IM_OFFSET_SPECIFIED_WHEN_ SIZE_WAS_ZERO



The offset parameter was supplied when the size was zero.

23



IM_LENGTH_REQUIRED



The length parameter is required.

24



IM_INVALID_OFFSET



An invalid offset was supplied.

25



IM_NOT_YET_SUPPORTED



The function of a part of the function is not yet supported.

26



IM_MISSING_PARAMETER



A parameter is missing.

27



IM_INVALID_ITEM_TYPE



A invalid item type was encountered.

28



IM_INVALID_ITEM



A invalid item was encountered.

29



IM_INVALID_SIZE



The size supplied was not valid.

30



IM_DESCRIPTION_TOO_LONG



The description supplied was not valid.

31



IM_LENGTH_PARM_ERROR



The length supplied was not valid.

32



IM_#_LINKS_PARM_ERROR



The #links parmameter supplied was not valid.

33



IM_LINKS_OFFSET_PARM_ERROR



The linksoffset parmameter supplied was not valid.

34



IM_ITEM_CHARACTERISTICS_ CHANGED



The characteristics of the item have changed. An item's length, offset
of links and number of links, can not be modified.

36



IM_INVALID_RETURN_AREA_SIZE



The return area size supplied is not valid.

37



IM_KEY_LENGTH_PARM_ERROR



The keylength parameter supplied is not valid.

38



IM_KEY_OFFSET_PARM_ERROR



The keyoffset parameter supplied is not valid.

39



IM_INVALID_DESCRIPTOR_TOKEN



The descriptor token parameter supplied is not valid.

40



IM_INVALID_ITEM_TOKEN



An item token is not valid.

41



IM_CURRENCY_ERROR



The proper currency is not established for the function.

42



IM_INVALID_LINK_NUMBER



The link number supplied is not valid.

43



IM_LINK_NOT_NULL



A link field is not null that is needed to connect an item to a structure.

44



IM_AT_END



At the end of a structure. For example, a IM_OBTAIN_NEXT was issued and
there were no more items in a list.

45



IM_REQUIRES_PRIOR_LINK



This function requires that the structure have prior links.

46



IM_REQUIRES_FINAL_LINK



This function requires that the structure have a final link.

47



IM_REQUIRES_OWNER_LINK



This function requires that the structure have owner links.

48



IM_NOT_FOUND



The item could not be found.

49



IM_HEAD_NOT_VALID_FOR_ THIS_DESCRIPTOR



The headtkn is not valid for this descriptor because the heads are in
the descriptor.

50



IM_INVALID_SFD



The Sort Fields Definitions (SFD) is not valid.

51



IM_INVALID_SORT_TECHNIQUE



The sort technique supplied is not valid.

52



IM_PRTKN_INVALID



PRTKN specified is not valid.

53



IM_PRTKN_REQUIRED



PRTKN required if prior links do not exist.

54



IM_HEADTKN_INVALID



HEADTKN specified is not valid.

55



IM_CURTKN_INVALID



CURTKN specified is not valid.

56



IM_ITEMTYPE_MISMATCH



The item type of the item being processed does not match the MEMTYPE
specified on the create for the corresponding descriptor.



    Item Manager Service Processor Functions <#ToC_73>

The remaining sections of this chapter describe all functions provided
by the Item Manager service processor, arranged in alphabetical order.
Each function's description begins on a new page, and the name of the
function being described appears in the top outside corner of every page.

_*IM_ADD_TO_DIRECTORY - Add An Item Token to The Token Directory*_

The IM_ADD_TO_DIRECTORY macro is used to add an item token to the Token
Directory. The Token Directory provides a way to symbolically remember
an item's token.

This function is not yet implemented.

IM_ADD_TO_DIRECTORY ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,NAME={/name/ | (/name/,/name_length/)}
   ,TOKEN=/token/
CALLX /im_epa/,(/im_token/,&IM_ADD_TO_DIRECTORY,&c
/name_length/,/name/,/token/)



*Parameter *



Description

name



specifies the label of a string that contains the name to be associated
with the token specified with the /token/parameter.

name_length



specifies the label of a signed binary integer indicating the length of
the string identified by the /name/parameter.

token



specifies the label of a fullword of storage that contains the token of
an item.


      Example

IM_ADD_TO_DIRECTORY ID=IM,NAME="MYTOKEN",TOKEN=TOKEN_TAG

_*IM_CONVERT_TOKEN_TO_ADDRESS - Convert a Token to an Address*_

The IM_CONVERT_TOKEN_TO_ADDRESS macro is used to convert a token to its
virtual storage address. To use this macro, the token conversion routine
address must be obtained. See to find out how to retrieve this address.

IM_CONVERT_TOKEN_TO_ADDRESS ID=/id_name/ Ý,SPTOKEN=/im_token/¨
  Ý,TKNCNVT=/tkncnvt/¨
   ,ITEMTKN=/itemtkn/
   ,ITEMADDR=/itemaddr/
None



*Parameter *



Description

tkncnvt



specifies the label of a fullword in storage that contains the entry
point address of the token conversion routine.

itemtkn



specifies the label of a fullword that contains the token of the item
for with a virtual address should be obtained.

itemaddr



specifies the label of a fullword into which will be place the virtual
storage address of the time.


      Example

This instruction will get the virtual storage address of the item whose
token is in A_TOKEN.

      IM_CONVERT_TOKEN_TO_ADDRESS ID=IM,ITEMTKN=A_TOKEN,            +
               ITEMADDR=THE_ADDRESS



*RC *



Symbol



Description

12



IM_INVALID_TOKEN



The token supplied was not valid.

_*IM_CONNECT - Connect An Item*_

The IM_CONNECT macro is used to connect an item to the structure
described by a descriptor. This structure can be a linked list or a hash
table. See and for information on how to create a structure descriptor.
The IM_CONNECT function does not changed currency.

IM_CONNECT ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
  Ý,ITEMTKN=/itemtkn/¨
  Ý,HEADTKN=/headtkn/¨
CALLX /im_epa/,(/im_token/,&IM_CONNECT,/desctkn/,/itemtkn/,/headtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of a
descriptor that describes the structure to which the item is to be
connected. The descriptor must describe a linked list or a hash table.

itemtkn



specifies the label of a fullword that contains the token of the item to
be connected. If this parameter is not specified, the item that is
current of Item Manager is connected.

headtkn



specifies the label of a fullword that contains the token of the item
that contains the heads when a structure can have multiple occurances.
If this parameter is not specified, the item that is current of item
type of the item type specified with the /headtype/parameter on the
associated descriptor create function is used.


      Example

This instruction will connect the item that is current of Item Manager
to the structure described by the descriptor whose token is in the
fullword at tag A_LIST_DESCRIPTOR_TOKEN.

IM_CONNECT ID=IM,DESCTKN=A_LIST_DESCRIPTOR_TOKEN

_*IM_CREATE_GROUP_DESCRIPTOR - Create A Group Descriptor*_

The IM_CREATE_GROUP_DESCRIPTOR macro is used to create a group
descriptor. A group is used to group items of certain item types in Item
Manager Managed Storage. See for information on specifying a group
descriptor when creating an item type descriptor.

IM_CREATE_GROUP_DESCRIPTOR ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
  Ý,TEXT=/text/¨
  Ý,STGINCR=/stgincr/¨
CALLX /im_epa/,
  (/im_token/,&IM_CREATE_GROUP_DESCRIPTOR,/desctkn/,/text/,/stgincr/)



*Parameter *



Description

desctkn



specifies the label of a fullword into which the token of the group
descriptor created will be returned.

text



specifies the label of text to be associated with this descriptor. See
for information on creating text.

stgincr



specifies the label of a fullword that contains the size of the
increment of storage that will be obtained each time that more storage
is required for items that are in this group. If the parameter is not
specified, 4K bytes is assumed.


      Example

This instruction will create a group descriptor. The Item Manager will
assign storage to this group in 128K increments.

      IM_CREATE_GROUP_DESCRIPTOR ID=IM,                             +
               DESCTKN=A_GROUP_DESCRIPTOR,                             +
               STGINCR==A(128*1024)

_*IM_CREATE_HASH_TABLE_DESCRIPTOR - Create A Hash Table Descriptor *_

The IM_CREATE_HASH_TABLE_DESCRIPTOR macro is used to create a structure
descriptor for a hash table.

Because of the number of links involved, the Item Manager does not
support multiple occurrences of a hash table. You can simulate multiple
occurrences by creating multiple hash table descriptors and storing
their tokens in the link fields of the appropriate items.

IM_CREATE_HASH_TABLE_DESCRIPTOR ID=/id_name/
  Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
  Ý,MEMTYPE=/memtype/¨
  Ý,TEXT=/text/¨
  Ý,OPTIONS=(ÝDUPLICATE_KEYS_ALLOWED¨)¨
  Ý,ENTRIES=/entries/¨
   ,SYNLNK#=/synlnk#/
   ,KEYOFF=/keyoff/
   ,KEYSZ=/keysz/|(IN_ITEM,/keysz_offset/)
CALLX /im_epa/,(/im_token/,&IM_CREATE_HASH_TABLE_DESCRIPTOR,/desctkn/,/text/,
      /optbyte/,/entries./,/synlnk#/,/keyoff/,/keysz/,/keysz_offset/,/memtype/)



*Parameter *



Description

desctkn



specifies the label of a fullword into which the token of the hash table
descriptor created will be returned.

memtype



specifies the label of a halfword which contains the item type of items
that can be members of the hash table. If this parameter is not
specified, items with a mixture of item types can be connected to the
hash table.

text



specifies the label of text to be associated with this descriptor. See
for information on creating text.

optbyte



specifies the options byte. :pLt.entries :pLd.specifies a fullword that
contains the number of entries that should be in the root part of the
hash table. Although the item manager does not check, this number should
be prime. If this parameter is not specified, 101 entries is assumed.

synlnk#



specifies a fullword that contains the link number within item connected
to this hash table, that will be used to chain synonyms.

keyoff



specifies a fullword that contains the offset of the key within each
item connected to this hash table. :pLt.keysz :pLd.specifies a fullword
that contains the size of the key. If this parameter is not specified,
the /keysize_offset/parameter must be specified. Keys can not be greater
than 255 bytes long.

keysz_offset



specifies a fullword that contains the offset within each item of one
byte that contains the size of the key in that item. This parameter is
mutually exclusive with the /keysz/parameter.


      Example

This instruction will create a hash table descriptor. A 5 byte key is in
each item at an offset of 6. The 2nd link field of each item is used for
the hash table synonym chain.

      IM_CREATE_HASH_TABLE_DESCRIPTOR ID=IM,                           +
               DESCTKN=A_HASH_TABLE_DESCRIPTOR,                        +
               SYNLNK#=2,                                              +
               KEYOFF=6,                                               +
               KEYSZ=5

_*IM_ID - Establish Default Item Manager Values*_

The IM_ID macro is used to establish default values for use by other
Item Manager macros, which may access those values through a unique
identifier, /id_name/, specified by the user. When allowed to generate
default values, this macro will create Program Work Area (PWA) storage
for /im_epa/and /im_token/. These values, whether generated by the macro
or provided by the user, are accessable from all other Item Manager
macros via the ID=/id_name/parameter.

IM_ID ID=/id_name/
  Ý,SPEPNAME=/IM_epname/¨
  Ý,SPEPA=/im_epa/¨
  Ý,SPTOKEN=/im_token/¨
  Ý,ESID=/esid_name/¨
  Ý,ESVA=/esva/¨
  Ýoptional keywords specific to Item Manager¨



*Parameter *



Description

id_name



the identifier to assign to the service processor identifier being
established. This name must be unique for all service processor identifiers.

IM_epname



the entry point name of the Item Manager service processor module that
is being used.

im_epa



specifies the label of a fullword in storage that will contain the entry
point address of the Environment Support service processor.

im_token



specifies the label of a fullword in storage that will contain the token
assigned by the IM_START function of the String Handler.

esid_name



the name of a service processor identifier, created by the ES_ID macro,
which will be used by the IM_ID macro to automatically obtain the value
for esv (see below).

esva



specifies the label of a fullword in storage that contains (or will
contain) the address of the Environment Support Vector (ESV) created by
the ES_START function.


      Example 1

IM_ID ID=ES,SPEPNAME=&ITEM_MANAGER

_*IM_CREATE_ITEM_TYPE_DESCRIPTOR - Create An Item Type Descriptor *_

The IM_CREATE_ITEM_TYPE_DESCRIPTOR macro is used to create a item type
descriptor.

Unlike all other tokens, which are four bytes long, the token for an
item type descriptor is only two bytes long. The first two bytes of
every item is the token of the item type descriptor that describes that
item's characteristics.

IM_CREATE_ITEM_TYPE_DESCRIPTOR ID=/id_name/
  Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,ITEMTYPE=/itemtype/
  Ý,TEXT=/text/¨
  Ý,OPTIONS=(/ÝFIRST_LINK_HAS_DESCRIPTION¨/)
  Ý,GROUPTKN=/grouptkn/¨
   ,ITEMSZ=/itemsz/ | (IN_ITEM,/itemsz_offset/,/itemsz_lensize/)
  Ý,#LINKS=/#links/ | (IN_ITEM,/#links_offset/,/#links_lensize/)¨
  Ý,LINKSOFF=/linksoff/ | (IN_ITEM,/linksoff_offset/,/linksoff_lensize/)¨
CALLX /im_epa/,(/im_token/,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,/itemtype/,/text/,
      /optbyte/,/grouptkn/,/itemsz/,/#links/,/linksoff/,
      /itemsz_lensize/,/itemsz_offset/,/#links_lensize/,/#links_offset/,
      /linksoff_lensize/,/linksoff_offset/)



*Parameter *



Description

itemtype



specifies the label of a halfword into which the token of the item type
descriptor created will be returned.

text



specifies the label of text to be associated with this descriptor. See
for information on creating text.

optbyte



specifies the options byte.

grouptkn



specifies the label of a fullword that contains the token of the group
descriptor to be used when creating items of this type. See for further
information on creating group descriptors. If this parameter is not
specified, items of this type will go into the default user group. See
for information on the size of the storage increment for the default
user group.

itemsz



specifies a fullword that contains the length of items of this type.
This parameter is mutually exclusive with the /itemsz_offset/and
/itemsz_lensize/parameters and is required if they are not specified.

itemsz_offset



specifies a fullword that contains the offset within each item of this
type of the item's length.

itemsz_lensize



specifies a fullword that contains the size of the item length within
each item of this type. This length can be 1, 2, 3 or 4.

#links



specifies a fullword that contains the number of links in items of this
type. This parameter is mutually exclusive with the /#links_offset/and
/#links_lensize/parameters and is required if they are not specified.

#links_offset



specifies a fullword that contains the offset within each item of this
type of the item's number of links.

#links_lensize



specifies a fullword that contains the size of the field within each
item of this type that contains its number of links. This length can be
1, 2, 3 or 4.

linksoff



specifies a fullword that contains the offset of the links in items of
this type. This parameter is mutually exclusive with the
/linksoff_offset/and /linksoff_lensize/parameters an is required if they
are not specified.

linksoff_offset



specifies a fullword that contains the offset within each item of this
type of the item's links offset.

linksoff_lensize



specifies a fullword that contains the size of the field within each
item of this type that contains its links offset. This length can be 1,
2, 3 or 4.


      Example

This instruction will create an item type descriptor. Each items stored
with the token returned by this function in its first two bytes will be
32 bytes long with two links at its end.

      IM_CREATE_ITEM_TYPE_DESCRIPTOR ID=IM,                         +
               ITEMTYPE=ITEM_TYPE_DESCRIPTOR,                          +
               ITEMSZ=32,#LINKS=2,LINKOFF=24

_*IM_CREATE_LINKED_LIST_DESCRIPTOR - Create A Linked List Descriptor*_

The IM_CREATE_LINKED_LIST_DESCRIPTOR macro is used to create a linked
list descriptor.

The sorted list related options and parameters for this function are not
yet implemented. Also, LIST_ORDER_NEXT and LIST_ORDER_PRIOR are not yet
implemented.

IM_CREATE_LINKED_LIST_DESCRIPTOR ID=/id_name/
  Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
  Ý,TEXT=/text/¨
  Ý,OPTIONS=(ÝHEADS_IN_DESCRIPTOR¨
             Ý,DUPLICATE_KEYS_ALLOWED¨
             Ý,LIST_ORDER_FIRST¨
             Ý,LIST_ORDER_FINAL¨
             Ý,LIST_ORDER_NEXT¨
             Ý,LIST_ORDER_PRIOR¨
             Ý,LIST_ORDER_SORTED_ASCENDING¨
             Ý,LIST_ORDER_SORTED_DESCENDING¨)
  Ý,FSTLNK#=/fstlnk#/¨
  Ý,FNLLNK#=/fnllnk#/¨
   ,NXTLNK#=/nxtlnk#/
  Ý,PRLNK#=/prvlnk#/¨
  Ý,OWNLNK#=/ownlnk#/¨
  Ý,HEADTYPE=/headtype/¨
  Ý,MEMTYPE=/memtype/¨
  Ý,KEYOFF=/keyoff/¨
  Ý,KEYSZ=/keysz/|(IN_ITEM,/keysz_offset/)¨
CALLX /im_epa/,(/im_token/,&IM_CREATE_LINKED_LIST_DESCRIPTOR,/desctkn/,/text/,
      /optbyte/,/fstlnk#./,/fnllk#/,/nxtlk#/,/prlnk#/,
      /headtype/,/keyoff/,/keysz/,/keysz_offset/,/memtype/)



*Parameter *



Description

desctkn



specifies the label of a fullword into which will be returned the token
of the linked list descriptor created.

text



specifies the label of text to be associated with this descriptor. See
for information on creating text.

optbyte



specifies the options byte.

HEADS_IN_ DESCRIPTOR



indicates that the heads for the list will be contained in the list
descriptor.

LIST_ORDER_FIRST



indicates that normally items will be connected to the start of the list.

LIST_ORDER_FINAL



indicates that normally items will be connected to the end of the list.

fstlnk#



specifies the label of a fullword that contains the link number of the
"first link" in the associated head items. Do not specify this parameter
if OPTIONS=HEADS_IN_DESCRIPTOR is specified. If
OPTIONS=HEADS_IN_DESCRIPTOR is not specified, this parameter is required.

fnllnk#



specifies the label of a fullword that contains the link number of the
"final link" in the associated head items. Do not specify this parameter
if OPTIONS=HEADS_IN_DESCRIPTOR is specified.

nxtlnk#



specifies the label of a fullword that contains the link number of the
"next link" in the associated member items.

prlnk#



specifies the label of a fullword that contains the link number of the
"prior link" in the associated member items.

ownlnk#



specifies the label of a fullword that contains the link number of the
"owner link" in the associated member items.

headtype



specifies the label of a halfword which contains the item type of the
items that will head the lists. Do not specify this parameter if
OPTIONS=HEADS_IN_DESCRIPTOR is specified. If OPTIONS=HEADS_IN_DESCRIPTOR
is not specified, this parameter is required.

memtype



specifies the label of a halfword which contains the item type of items
that can be members of the linked list. If this parameter is not
specified, items with a mixture of item types can be connected to the
linked list.

keyoff



specifies the label of a fullword which contains the offset of the key
in items of the list.

keysz



specifies the label of a fullword which contains the size of the key.

keysz_offset



specifies the label of a fullword which contains the offset of the one
byte key size in associated item.


      Example

This instruction will create a

      IM_CREATE_LINKED_LIST_DESCRIPTOR ID=IM,                          +
               DESCTKN=A_LINKED_LIST_DESCRIPTOR,                       +
               NXTLNK#=4

_*IM_DESTORY - Destroy A Descriptor*_

The IM_DESTORY macro is used to destroy a descriptor created by one of
the create functions.

This function is not yet implemented.

IM_DESTORY ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
CALLX /im_epa/,(/im_token/,&IM_DESTROY,/desctkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of a
descriptor to destroy. The descriptor must not be associated with any items.


      Example

This instruction will destroy the descriptor whose token is in the
fullword at tag A_DESCRIPTOR_TOKEN.

      IM_DESTORY ID=IM,DESCTKN=A_DESCRIPTOR_TOKEN

_*IM_DISCONNECT - Disconnect An Item *_

The IM_DISCONNECT macro is used to disconnect an item from the structure
described by a descriptor. This structure can be a linked list or a hash
table. See for information on how to connect an item to a structure. No
item is current of descriptor for the descriptor specified after this
function has completed. Other currency remains unchanged.

This function is only implemented for linked lists.

IM_DISCONNECT ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
  Ý,ITEMTKN=/itemtkn/¨
  Ý,HEADTKN=/headtkn/¨
  Ý,PRTKN=/prtkn/¨
CALLX /im_epa/,(/im_token/,&IM_DISCONNECT,/desctkn/,/itemtkn/,/headtkn/,/prtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of a
descriptor that describes the structure to which the item is to be
disconnected. The descriptor must describe a linked list or a hash table.

itemtkn



specifies the label of a fullword that contains the token of the item to
be disconnected. If this parameter is not specified, the item that is
current of Item Manager is disconnected.

headtkn



specifies the label of a fullword that contains the token of the item
that contains the heads when a structure can have multiple occurances.
If this parameter is not specified, the item that is current of item
type of the item type specified with the /headtype/parameter on the
associated descriptor create function is used.

prtkn



specifies the label of a fullword that contains the token of the item
prior to the one to be disconnected. If this parameter is not specified,
the associated descriptor must have a prior link.


      Example

This instruction will disconnect the item that is current of Item
Manager from the structure described by the descriptor whose token is in
the fullword at tag A_LIST_DESCRIPTOR_TOKEN.

      IM_DISCONNECT ID=IM,DESCTKN=A_LIST_DESCRIPTOR_TOKEN

_*IM_ERASE - Erase An Item *_

The IM_ERASE macro is used to erase an item from Item Manager Managed
Storage.

IM_ERASE ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
  Ý,OPTIONS=(ÝBYPASS_LINKS_CHECK¨)¨
  Ý,ITEMTKN=/itemtkn/¨
CALLX /im_epa/,(/im_token/,&IM_ERASE,/optbyte/,/itemtkn/)



*Parameter *



Description

optbyte



specifies the label of a byte that contains options.

itemtkn



specifies the label of a fullword that contains the token of the item to
be erased. If this parameter is not specified, the item that is current
of Item Manager is erased.


      Example

This instruction will erase the item that is current of Item Manager
from Item Manager Managed Storage.

      IM_ERASE ID=IM



*Return Code *



Symbol



Description

0



IM_SUCCESS



The IM_ERASE function has successfully erased the item from Item Manager
Managed Storage.

_*IM_FIND - Find An Item By Its Token*_

The IM_FIND macro is used to locate an item by its item token. The item
found will become current of Item Manager and current of item type.

IM_FIND ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,ITEMTKN=/itemtkn/
  Ý,ACTUALSZ=/actualsz/¨
CALLX /im_epa/,(/im_token/,&IM_FIND,/itemtkn/,/actualsz/)



*Parameter *



Description

id_name



specifies the name of a service processor identifier created by the
IM_ID macro which will be used by the IM_FIND macro to automatically
obtain values for /im_epa/and /im_token/. This parameter is required
unless both /im_epa/and /im_token/are specified.

im_epa



specifies the label of a fullword in storage that contains the entry
point address of an already-started Item Manager service processor. The
value specified by /im_epa/overrides any value obtained from ID=/id_name/.

im_token



specifies the label of a fullword in storage that contains the value
returned by IM_START for the /im_token/parameter. The value specified by
/im_token/overrides any value obtained from ID=/id_name/.

itemtkn



specifies the label of a fullword that contains the token of the item to
be located.

actualsz



specifies the label of a fullword into which will be place the actual
size of the item found.


      Example

This instruction will find the item whose token is in the fullword at
label ITEM_TOKEN.

      IM_FIND ID=IM,ITEMTKN=ITEM_TOKEN

_*IM_FIND_BY_KEY - Find An Item By Key*_

The IM_FIND_BY_KEY macro is used to locate an item by its key. The item
found will become current of Item Manager and current of item type.

IM_FIND_BY_KEY ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
   ,KEY=/key/ | (/key/,/key_length/)
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
CALLX /im_epa/,(/im_token/,&IM_FIND_BY_KEY,/desctkn/,/key_length/,/key/,
      /actualsz/,/itemtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the structure in which the item should be found.

key_length



specifies a fullword that contains the length of the key. Trailing
blanks are ignored in the compare, so the key can still match a item in
Item Manager Managed Storage even if the key length of that item is not
the same as the key length specified.

key



specifies the label of a field that contains the key of the item to locate.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item located.


      Example

This instruction will find the item in the linked list described by
A_LIST_DESCRIPTOR that has a key of "XYZZY".

      IM_FIND_BY_KEY ID=IM,DESCTKN=A_LIST_DESCRIPTOR,KEY="XYZZY"

_*IM_FIND_CURRENT_OF_DESCRIPTOR - Find the Item That is Current of
Descriptor*_

The IM_FIND_CURRENT_OF_DESCRIPTOR macro is used to locate an item that
is current of a given descriptor. The item found will become current of
Item Manager and current of item type.

IM_FIND_CURRENT_OF_DESCRIPTOR ID=/id_name/
  Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
CALLX /im_epa/,(/im_token/,&IM_FIND_CURRENT_OF_DESCRIPTOR,/desctkn/,
      /actualsz/,/itemtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the structure in which the item should be found.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item located.


      Example

This instruction will find the item that is current of descriptor for
the structure described by A_LIST_DESCRIPTOR.

      IM_FIND_CURRENT_OF_DESCRIPTOR ID=IM,DESCTKN=A_LIST_DESCRIPTOR

_*IM_FIND_CURRENT_OF_ITEM_TYPE - Find the Item That is Current of Item
Type*_

The IM_FIND_CURRENT_OF_ITEM_TYPE macro is used to locate an item that is
current of a given item type. The item found will become current of Item
Manager and remain current of item type.

IM_FIND_CURRENT_OF_ITEM_TYPE ID=/id_name/ Ý,SPEPA=/im_epa/¨Ý,SPTOKEN=/im_token/¨
   ,ITEMTYPE=/itemtype/
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
CALLX /im_epa/,(/im_token/,&IM_FIND_ITEM_TYPE,/itemtype/,/actualsz/,/itemtkn/)



*Parameter *



Description

itemtype



specifies the label of a halfword that contains the token of item type
descriptor for the item that should be found.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item located.


      Example

This instruction will find the item that is current of item type for the
structure described by A_LIST_DESCRIPTOR.

      IM_FIND_CURRENT_OF_ITEM_TYPE ID=IM,DESCTKN=A_LIST_DESCRIPTOR

_*IM_FIND_FINAL - Find the Final Item in a Structure*_

The IM_FIND_FINAL macro is used to locate the final item in a structure.
This functions is supported for Linked Lists. The item found will become
current of Item Manager, current of descriptor and current of item type.

IM_FIND_FINAL ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
  Ý,HEADTKN=/headtkn/¨
CALLX /im_epa/,
  (/im_token/,&IM_FIND_FINAL,/desctkn/,/actualsz/,/itemtkn/,/headtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the structure in which the item should be found.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item located.

headtkn



specifies the label of a fullword that contains the token of the head
item for the list. This parameter only applies to lists that do not
contain heads in the descriptor. If this parameter is not specified, the
item that is current of item type of the HEADTYPE associated with the
descriptor will be used.


      Example

This instruction will find the final item in the linked list described
by A_LIST_DESCRIPTOR.

      IM_FIND_FINAL ID=IM,DESCTKN=A_LIST_DESCRIPTOR

_*IM_FIND_FIRST - Find the First Item in a Structure*_

The IM_FIND_FIRST macro is used to locate the first item in a structure.
This functions is supported for Linked Lists. The item found will become
current of Item Manager, current of descriptor and current of item type.

IM_FIND_FIRST ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
  Ý,HEADTKN=/headtkn/¨
CALLX /im_epa/,
  (/im_token/,&IM_FIND_FIRST,/desctkn/,/actualsz/,/itemtkn/,/headtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the structure in which the item should be found.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item located.

headtkn



specifies the label of a fullword that contains the token of the head
item for the list. This parameter only applies to lists that do not
contain heads in the descriptor. If this parameter is not specified, the
item that is current of item type of the HEADTYPE associated with the
descriptor will be used.


      Example

This instruction will find the first item in the linked list described
by A_LIST_DESCRIPTOR.

      IM_FIND_FIRST ID=IM,DESCTKN=A_LIST_DESCRIPTOR

_*IM_FIND_IN_DIRECTORY - Find An Item Token in The Token Directory *_

The IM_FIND_IN_DIRECTORY macro is used to get an item token in the token
directory. Currency is not changed.

This function is not yet implemented.

IM_FIND_IN_DIRECTORY ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,NAME={/name/ | (/name/,/name_length/)}
   ,TOKEN=/token/
CALLX /im_epa/,(/im_token/,&IM_FIND_IN_DIRECTORY,/name_length/,/name/,/token/)



*Parameter *



Description

name



specifies the label of a string that contains the name that is
associated with the token specified with the /token/parameter.

name_length



specifies the label of a signed binary integer indicating the length of
the string identified by the /name/parameter.

token



specifies the label of a fullword of storage into which will be placed
the token of the associated item.


      Example

This instruction will find the item token associated with the name
"MY_TOKEN" and put it in TOKEN_TAG.

      IM_FIND_IN_DIRECTORY ID=IM,NAME="MY_TOKEN",TOKEN=TOKEN_TAG

_*IM_FIND_NEXT - Find the Next Item in a Structure *_

The IM_FIND_NEXT macro is used to locate the next item in a structure.
This functions is supported for Linked Lists. The item found will become
current of Item Manager, current of descriptor and current of item type.

IM_FIND_NEXT ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
  Ý,CURTKN=/curtkn/¨
  Ý,HEADTKN=/headtkn/¨
CALLX /im_epa/,(/im_token/,&IM_FIND_NEXT,/desctkn/,/actualsz/,/itemtkn/,
      /curtkn/,/headtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the structure in which the item should be found.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item located.

curtkn



specifies the label of a fullword that contains the token of the current
item in the list. If this parameter is not specified, the item that is
current of descriptor will be used. If this parameter has a value of
zero, the first item in the list will be found.

headtkn



specifies the label of a fullword that contains the token of the head
item for the list. This parameter only applies to lists that do not
contain heads in the descriptor. If this parameter is not specified, the
item that is current of item type of the HEADTYPE associated with the
descriptor will be used.


      Example

This instruction will find the next item in the linked list described by
A_LIST_DESCRIPTOR.

      IM_FIND_NEXT ID=IM,DESCTKN=A_LIST_DESCRIPTOR

_*IM_FIND_OWNER - Find the Owner Item of an item in a Structure *_

The IM_FIND_OWNER macro is used to locate the owner item of an item in a
structure. This functions is supported for Linked Lists. The item found
will become current of Item Manager and current of item type.

IM_FIND_OWNER ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
  Ý,CURTKN=/curtkn/¨
CALLX /im_epa/,
  (/im_token/,&IM_FIND_OWNER,/desctkn/,/actualsz/,/itemtkn/,/curtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the structure in which the item should be found.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item located.

curtkn



specifies the label of a fullword that contains the token of the item in
the list for which the owner should be found. If this parameter is not
specified, the item that is current of Item Manager will be used.


      Example

This instruction will find the owner item in the linked list described
by A_LIST_DESCRIPTOR.

      IM_FIND_OWNER ID=IM,DESCTKN=A_LIST_DESCRIPTOR

_*IM_FIND_PRIOR - Find the Prior Item in a Structure*_

The IM_FIND_PRIOR macro is used to locate the prior item in a structure.
This functions is supported for Linked Lists. The item found will become
current of Item Manager, current of descriptor and current of item type.

IM_FIND_PRIOR ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
  Ý,HEADTKN=/headtkn/¨
  Ý,CURTKN=/curtkn/¨
CALLX /im_epa/,(/im_token/,&IM_FIND_PRIOR,/desctkn/,/actualsz/,/itemtkn/,
      /curtkn/,/headtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the structure in which the item should be found.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item located.

curtkn



specifies the label of a fullword that contains the token of the current
item in the list. If this parameter is not specified, the item that is
current of descriptor will be used. If this parameter has a value of
zero, the last item in the list will be found.

headtkn



specifies the label of a fullword that contains the token of the head
item for the list. This parameter only applies to lists that do not
contain heads in the descriptor. If this parameter is not specified, the
item that is current of item type of the HEADTYPE associated with the
descriptor will be used.


      Example

This instruction will find the prior item in the linked list described
by A_LIST_DESCRIPTOR.

      IM_FIND_PRIOR ID=IM,DESCTKN=A_LIST_DESCRIPTOR

_*IM_GET - Get an Item *_

The IM_GET macro is used to obtain the item that is current of Item
Manager. Currency is not changed.

IM_GET ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,ITEM={/item/ | (/item/,/item_length/)}
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
CALLX /im_epa/,(/im_token/,&IM_GET,/item_length/,/item/,/actualsz/,/itemtkn/)



*Parameter *



Description

item



specifies the label of the storage into which a copy of the item will be
placed.

item_length



specifies the label of a signed binary integer indicating the length of
the storage area specified by the /name/parameter. In the macro form, if
item_length is not specified, an =A(L'item) will be used to determine
the length of the storage. This storage can be larger than the actual
item, but must be large enough to hold the complete item.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item located.


      Example

This instruction will get the item that is current of Item Manager.

      IM_GET ID=IM,ITEM=ITEM_WORK_AREA

_*IM_GET_DANGEROUS_ADDRESSES - Get Dangerous Addresses *_

The IM_GET_DANGEROUS_ADDRESSES macro is used to get the address of the
token-to-virtual-address conversion routine. This allows direct access
to Item Manager Managed Storage. Direct access to Item Manager Managed
Storage should be avoided, but can be accomplished through this routine
if there are overriding reasons. This is the function that will be used
to externalize any other internal Item Manager functions, as needed.

IM_GET_DANGEROUS_ADDRESSES ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
  Ý,TKNCNVT=/tkncnvt/¨
CALLX /im_epa/,(/im_token/,&IM_GET_DANGEROUS_ADDRESSES,/tkncnvt/)



*Parameter *



Description

tkncnvt



specifies the label of a fullword into which will be place the address
of the token convertion routine. If the macro form is used and this
parameter is not specified, the value of the TKNCNVT keyword on the
corresponding IM_ID macro is used.



      Example

This instruction will place the address of the conversion routine in
CONVERT_ADDRESS

      IM_GET_DANGEROUS_ADDRESSES ID=IM,TKNCNVT=CONVERT_ADDRESS

_*IM_INITIALIZE - Initialize Item Manager Managed Storage *_

The IM_INITIALIZE macro is used to initialize Item Manager Managed
Storage. If the Item Manager is not started with a DIV service process
specified or if this is the first use of a DIV data set, this function
must be called. IM_START return an return code of
&IM_ITEM_STORAGE_NOT_INITIALIZED, if Item Manager Managed Storage needs
to be initialized.

Specifying good values for the parameters of this function is the major
way that you can tune the Item Manager.

IM_INITIALIZE ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
  Ý,ITDSTG=/itdstg/¨
  Ý,UAINCR=/uaincr/¨
  Ý,SYSINCR=/sysincr/¨
  Ý,DFLTINCR=/dfltincr/¨
CALLX /im_epa/,
  (/im_token/,&IM_INITIALIZE,/itdstg/,/uaincr/,/sysincr/,/dfltincr/)



*Parameter *



Description

itdstg



specifies the label of a fullword that contains the amount of Item
Manager Managed Storage that should be reserved for item type
descriptors. The maximum and the default is 64K.

uaincr



specifies the label of a fullword that contains the amount of main
memory that will be obtained, each time that Item Manager Managed
Storage needs to expand. This number should be large enough so that few
increments will be needed for a session of the Item Manager. The default
increment is 64K.

sysincr



specifies the label of a fullword that contains the amount of Item
Manager Managed Storage that will be obtained, each time that the system
Item Manager Managed Storage needs to expand. System Item Manager
Managed Storage is used to hold structure descriptors and other system
items. The default increment is 4K.

dfltincr



specifies the label of a fullword that contains the amount of Item
Manager Managed Storage that will be obtained each time that the default
user Item Manager Managed Storage needs to expand. Default user Item
Manager Managed Storage is used for user items that do not specify
another group. The default increment is 64K.


      Example

This instruction will place the address of the conversion routine in
CONVERT_ADDRESS

      IM_GET_DANGEROUS_ADDRESSES ID=IM,TKNCNVT=CONVERT_ADDRESS

_*IM_MODIFY - Modify an Item in Item Manager Managed Storage*_

The IM_MODIFY macro is used to modify an item in Item Manager Managed
Storage. The length, number of links and offset of links of an item, can
not be modified with the IM_MODIFY function.

IM_MODIFY ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,ITEM=/item/
  Ý,OPTIONS=(ÝUPDATE_LINKS¨)¨
  Ý,ITEMTKN=/itemtkn/¨
CALLX /im_epa/,(/im_token/,&IM_MODIFY,/item/,/optstr/,/itemtkn/)



*Parameter *



Description

item



specifies the label of the storage into which a copy of the item will be
placed.

UPDATE_LINKS



this options indicates that the links will be updated. If this options
is not specified, the link fields of the item being updated are not
replaced.

optstr



specifies the label of a byte that contains the options. All bits except
bit 1 are reserved. Bit one corresponds to the UPDATE_LINKS option.

itemtkn



specifies the label of a fullword that contains the token of the item to
modify. If this parameter is not specified, the item that is current of
Item Manager is modified.


      Example

This instruction will modify the item that is current of Item Manager.

      IM_MODIFY ID=IM,ITEM=ITEM_WORK_STORAGE

_*IM_OBTAIN - Obtain An Item By Its Token *_

The IM_OBTAIN macro is used to obtain an item by its item token The item
found will become current of Item Manager and current of item type.

IM_OBTAIN ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,ITEM={/item/ | (/item/,/item_length/)}
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
CALLX /im_epa/,(/im_token/,&IM_OBTAIN,/itemtkn/,/item_length/,/item/,/actualsz/)



*Parameter *



Description

itemtkn



specifies the label of a fullword that contains the token of the item to
be obtained.

item



specifies the label of the storage into which a copy of the item will be
placed.

item_length



specifies the label of a signed binary integer indicating the length of
the storage area specified by the /name/parameter. In the macro form, if
item_length is not specified, an =A(L'item) will be used to determine
the length of the storage. This storage can be larger than the actual
item, but must be large enough to hold the complete item.

actualsz



specifies the label of a fullword into which will be place the actual
size of the item found.


      Example

This instruction will obtain the item whose token is in the fullword at
label ITEM_TOKEN.

      IM_OBTAIN ID=IM,ITEMTKN=ITEM_TOKEN

_*IM_OBTAIN_BY_KEY - Obtain An Item By Key*_

The IM_OBTAIN_BY_KEY macro is used to obtain an item by its key. The
item found will become current of Item Manager and current of item type.

IM_OBTAIN_BY_KEY ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
   ,KEY=/key/ | (/key/,/key_length/)
   ,ITEM={/item/ | (/item/,/item_length/)}
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
CALLX /im_epa/,(/im_token/,&IM_OBTAIN_BY_KEY,/desctkn/,/key_length/,/key/,
      /item_length/,/item/,/actualsz/,/itemtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the structure in which the item should be found.

key_length



specifies a fullword that contains the length of the key. Trailing
blanks are ignored in the compare, so the key can still match a item in
Item Manager Managed Storage even if the key length of that item is not
the same as the key length specified.

key



specifies the label of a field that contains the key of the item to obtain.

item



specifies the label of the storage into which a copy of the item will be
placed.

item_length



specifies the label of a signed binary integer indicating the length of
the storage area specified by the /name/parameter. In the macro form, if
item_length is not specified, an =A(L'item) will be used to determine
the length of the storage. This storage can be larger than the actual
item, but must be large enough to hold the complete item.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item obtained.


      Example

This instruction will obtain the item in the linked list described by
A_LIST_DESCRIPTOR that has a key of "XYZZY".

      IM_OBTAIN_BY_KEY ID=IM,DESCTKN=A_LIST_DESCRIPTOR,KEY="XYZZY"

_*IM_OBTAIN_CURRENT_OF_DESCRIPTOR - Obtain the Item That is Current of
Descriptor*_

The IM_OBTAIN_CURRENT_OF_DESCRIPTOR macro is used to obtain an item that
is current of a given descriptor. The item found will become current of
Item Manager and current of item type.

IM_OBTAIN_CURRENT_OF_DESCRIPTOR ID=/id_name/
  Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
   ,ITEM={/item/ | (/item/,/item_length/)}
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
CALLX /im_epa/,(/im_token/,&IM_OBTAIN_CURRENT_OF_DESCRIPTOR,/desctkn/,
      /item_length/,/item/,/actualsz/,/itemtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the structure in which the item should be found.

item



specifies the label of the storage into which a copy of the item will be
placed.

item_length



specifies the label of a signed binary integer indicating the length of
the storage area specified by the /name/parameter. In the macro form, if
item_length is not specified, an =A(L'item) will be used to determine
the length of the storage. This storage can be larger than the actual
item, but must be large enough to hold the complete item.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item obtained.


      Example

This instruction will obtain the item that is current of descriptor for
the structure described by A_LIST_DESCRIPTOR.

      IM_OBTAIN_CURRENT_OF_DESCRIPTOR ID=IM,DESCTKN=A_LIST_DESCRIPTOR

_*IM_OBTAIN_CURRENT_OF_ITEM_TYPE - Obtain the Item That is Current of
Item Type *_

The IM_OBTAIN_CURRENT_OF_ITEM_TYPE macro is used to obtain an item that
is current of a given item type. The item found will become current of
Item Manager and remain current of item type.

IM_OBTAIN_CURRENT_OF_ITEM_TYPE ID=/id_name/
  Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,ITEMTYPE=/itemtype/
   ,ITEM={/item/ | (/item/,/item_length/)}
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
CALLX /im_epa/,(/im_token/,&IM_OBTAIN_ITEM_TYPE,/itemtype/,
      /item_length/,/item/,/actualsz/,/itemtkn/)



*Parameter *



Description

itemtype



specifies the label of a halfword that contains the token of item type
descriptor for the item that should be found.

item



specifies the label of the storage into which a copy of the item will be
placed.

item_length



specifies the label of a signed binary integer indicating the length of
the storage area specified by the /name/parameter. In the macro form, if
item_length is not specified, an =A(L'item) will be used to determine
the length of the storage. This storage can be larger than the actual
item, but must be large enough to hold the complete item.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item obtained.


      Example

This instruction will obtain the item that is current of item type for
the structure described by A_LIST_DESCRIPTOR.

      IM_OBTAIN_CURRENT_OF_ITEM_TYPE ID=IM,DESCTKN=A_LIST_DESCRIPTOR

_*IM_OBTAIN_FINAL - Obtain the Final Item in a Structure *_

The IM_OBTAIN_FINAL macro is used to obtain the final item in a
structure. This functions is supported for Linked Lists. The item found
will become current of Item Manager, current of descriptor and current
of item type.

IM_OBTAIN_FINAL ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
   ,ITEM={/item/ | (/item/,/item_length/)}
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
  Ý,HEADTKN=/headtkn/¨
CALLX /im_epa/,(/im_token/,&IM_OBTAIN_FINAL,/desctkn/,
      /item_length/,/item/,/actualsz/,/itemtkn/,/headtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the structure in which the item should be found.

item



specifies the label of the storage into which a copy of the item will be
placed.

item_length



specifies the label of a signed binary integer indicating the length of
the storage area specified by the /name/parameter. In the macro form, if
item_length is not specified, an =A(L'item) will be used to determine
the length of the storage. This storage can be larger than the actual
item, but must be large enough to hold the complete item.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item obtained.

headtkn



specifies the label of a fullword that contains the token of the head
item for the list. This parameter only applies to lists that do not
contain heads in the descriptor. If this parameter is not specified, the
item that is current of item type of the HEADTYPE associated with the
descriptor will be used.


      Example

This instruction will obtain the final item in the linked list described
by A_LIST_DESCRIPTOR.

      IM_OBTAIN_FINAL ID=IM,DESCTKN=A_LIST_DESCRIPTOR

_*IM_OBTAIN_FIRST - Obtain the First Item in a Structure *_

The IM_OBTAIN_FIRST macro is used to obtain the first item in a
structure. This functions is supported for Linked Lists. The item found
will become current of Item Manager, current of descriptor and current
of item type.

IM_OBTAIN_FIRST ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
   ,ITEM={/item/ | (/item/,/item_length/)}
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
  Ý,HEADTKN=/headtkn/¨
CALLX /im_epa/,(/im_token/,&IM_OBTAIN_FIRST,/desctkn/,
      /item_length/,/item/,/actualsz/,/itemtkn/,/headtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the structure in which the item should be found.

item



specifies the label of the storage into which a copy of the item will be
placed.

item_length



specifies the label of a signed binary integer indicating the length of
the storage area specified by the /name/parameter. In the macro form, if
item_length is not specified, an =A(L'item) will be used to determine
the length of the storage. This storage can be larger than the actual
item, but must be large enough to hold the complete item.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item obtained.

headtkn



specifies the label of a fullword that contains the token of the head
item for the list. This parameter only applies to lists that do not
contain heads in the descriptor. If this parameter is not specified, the
item that is current of item type of the HEADTYPE associated with the
descriptor will be used.



      Example

This instruction will obtain the first item in the linked list described
by A_LIST_DESCRIPTOR.

      IM_OBTAIN_FIRST ID=IM,DESCTKN=A_LIST_DESCRIPTOR

_*IM_OBTAIN_NEXT - Obtain the Next Item in a Structure *_

The IM_OBTAIN_NEXT macro is used to obtain the next item in a structure.
This functions is supported for Linked Lists. The item found will become
current of Item Manager, current of descriptor and current of item type.

IM_OBTAIN_NEXT ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
   ,ITEM={/item/ | (/item/,/item_length/)}
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
  Ý,CURTKN=/curtkn/¨
  Ý,HEADTKN=/headtkn/¨
CALLX /im_epa/,(/im_token/,&IM_OBTAIN_NEXT,/desctkn/,
      /item_length/,/item/,/actualsz/,/itemtkn/,/curtkn/,/headtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the structure in which the item should be found.

item



specifies the label of the storage into which a copy of the item will be
placed.

item_length



specifies the label of a signed binary integer indicating the length of
the storage area specified by the /name/parameter. In the macro form, if
item_length is not specified, an =A(L'item) will be used to determine
the length of the storage. This storage can be larger than the actual
item, but must be large enough to hold the complete item.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item obtained.

curtkn



specifies the label of a fullword that contains the token of the current
item in the list. If this parameter is not specified, the item that is
current of descriptor will be used. If this parameter has a value of
zero, the first item in the list will be obtained.

headtkn



specifies the label of a fullword that contains the token of the head
item for the list. This parameter only applies to lists that do not
contain heads in the descriptor. If this parameter is not specified, the
item that is current of item type of the HEADTYPE associated with the
descriptor will be used.


      Example

This instruction will obtain the next item in the linked list described
by A_LIST_DESCRIPTOR.

      IM_OBTAIN_NEXT ID=IM,DESCTKN=A_LIST_DESCRIPTOR

_*IM_OBTAIN_OWNER - Obtain the Owner Item of a Structure *_

The IM_OBTAIN_OWNER macro is used to obtain the owner item of a
structure. This functions is supported for Linked Lists. The item found
will become current of Item Manager, current of descriptor and current
of item type.

IM_OBTAIN_OWNER ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
   ,ITEM={/item/ | (/item/,/item_length/)}
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
  Ý,CURTKN=/curtkn/¨
CALLX /im_epa/,(/im_token/,&IM_OBTAIN_OWNER,/desctkn/,
      /item_length/,/item/,/actualsz/,/itemtkn/,/curtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the structure in which the item should be found.

item



specifies the label of the storage into which a copy of the item will be
placed.

item_length



specifies the label of a signed binary integer indicating the length of
the storage area specified by the /name/parameter. In the macro form, if
item_length is not specified, an =A(L'item) will be used to determine
the length of the storage. This storage can be larger than the actual
item, but must be large enough to hold the complete item.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item obtained.

curtkn



specifies the label of a fullword that contains the token of the current
item in the list. If this parameter is not specified, the item that is
current of Item Manager will be used.


      Example

This instruction will obtain the owner item in the linked list described
by A_LIST_DESCRIPTOR.

      IM_OBTAIN_OWNER ID=IM,DESCTKN=A_LIST_DESCRIPTOR

_*IM_OBTAIN_PRIOR - Obtain the Prior Item in a Structure*_

The IM_OBTAIN_PRIOR macro is used to obtain the prior item in a
structure. This functions is supported for Linked Lists. The item found
will become current of Item Manager, current of descriptor and current
of item type.

IM_OBTAIN_PRIOR ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
   ,ITEM={/item/ | (/item/,/item_length/)}
  Ý,ITEMTKN=/itemtkn/¨
  Ý,ACTUALSZ=/actualsz/¨
  Ý,CURTKN=/curtkn/¨
  Ý,HEADTKN=/headtkn/¨
CALLX /im_epa/,(/im_token/,&IM_OBTAIN_PRIOR,/desctkn/,
      /item_length/,/item/,/actualsz/,/itemtkn/,/curtkn/,/headtkn/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the structure in which the item should be found.

item



specifies the label of the storage into which a copy of the item will be
placed.

item_length



specifies the label of a signed binary integer indicating the length of
the storage area specified by the /name/parameter. In the macro form, if
item_length is not specified, an =A(L'item) will be used to determine
the length of the storage. This storage can be larger than the actual
item, but must be large enough to hold the complete item.

actualsz



specifies the label of a fullword into which will be placed the actual
size of the item found.

itemtkn



specifies the label of a fullword into which will be placed the token of
the item obtained.

curtkn



specifies the label of a fullword that contains the token of the current
item in the list. If this parameter is not specified, the item that is
current of descriptor will be used. If this parameter has a value of
zero, the last item in the list will be obtained.

headtkn



specifies the label of a fullword that contains the token of the head
item for the list. This parameter only applies to lists that do not
contain heads in the descriptor. If this parameter is not specified, the
item that is current of item type of the HEADTYPE associated with the
descriptor will be used.


      Example

This instruction will obtain the prior item in the linked list described
by A_LIST_DESCRIPTOR.

      IM_OBTAIN_PRIOR ID=IM,DESCTKN=A_LIST_DESCRIPTOR

_*IM_REMOVE_FROM_DIRECTORY - Remove An Item Token from The Token
Directory *_

The IM_REMOVE_FROM_DIRECTORY macro is used to unassociate a name with an
item token in the token directory. Currency is not changed.

This function is not yet implemented.

IM_REMOVE_FROM_DIRECTORY ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,NAME={/name/ | (/name/,/name_length/)}
CALLX /im_epa/,(/im_token/,&IM_REMOVE_FROM_DIRECTORY,/name_length/,/name/)



*Parameter *



Description

name



specifies the label of a string that contains the name that is
associated with the token specified with the /token/parameter.

name_length



specifies the label of a signed binary integer indicating the length of
the string identified by the /name/parameter.


      Example

This instruction will remove the name "MY_TOKEN" from the token directory.

      IM_REMOVE_FROM_DIRECTORY ID=IM,NAME="MY_TOKEN"

_*IM_RESET - Reset Item Manager Managed Storage to Its Initial Contents *_

The IM_RESET macro is used to reset Item Manager Managed Storage to its
contents at the time of the last IM_SAVE function. This function is only
valid if a DIV service process was specified on the IM_START call. This
function will invoke the DV_RESET function of the associated DIV service
processor.

IM_RESET ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
CALLX /im_epa/,(/im_token/,&IM_RESET)


      Example

This instruction will reset Item Manager Managed Storage to its value
since the last save.

      IM_RESET ID=IM

_*IM_SAVE - Save Item Manager Managed Storage *_

The IM_SAVE function is used to save Item Manager Managed Storage. This
function is only valid if a DIV service process was specified on the
IM_START call. This function will invoke the DV_SAVE function of the
associated DIV service processor.

IM_SAVE ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
CALLX /im_epa/,(/im_token/,&IM_SAVE)


      Example

This instruction will save Item Manager Managed Storage.

      IM_SAVE ID=IM

_*IM_SFD - SFD Mapping Macro *_

The IM_SFD macro is used to map a Sort Fields Descriptions (SFD) entry.

IM_SFD ÝID=cbid¨
  Ý,DSECT=/dsectopt/¨



*Parameter *



Description

cbid



specifies the id to be place as a prefix to each generated tag.

dsectopt



either YES or NO to indicate whether a DSECT should be generated.


      Example

This instruction will generate a mapping dsect for the SFD.

      IM_SFD

_*IM_SORT - Sort a List *_

The IM_SORT function is used to sort a list.

IM_SORT ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,DESCTKN=/desctkn/
   ,FIELDS={/fields/ | ,FIELDSLIST=/fieldslist/
  Ý,TECHNIQUE=(ÝQUICK_SORT¨ | ÝBUBBLE_SORT¨)¨
  Ý,HEADTKN=/itemtkn/¨
CALLX /im_epa/,(/im_token/,&IM_SORT,/desctkn/,/fieldslist/,
      /headtkn/,/technique/)



*Parameter *



Description

desctkn



specifies the label of a fullword that contains the token of descriptor
that describes the list of items to be sorted.

fields



specifies the sort fields. See for the syntax of this parameter.

fieldslist



specifies a location that contains the Sort Fields Definitions (SFD).
Refer to or for information needed to build the SFD.

QUICK_SORT



specifies that quick sort should be used to sort the list. This is the
default sort techinque. It is very fast for all but very small lists,
which are slowed by the setup required. It should always be used except
when very small lists are sorted many times. It uses a partiton exchange
sort algorithm with improvements by Richard C. Singleton. See ACM
Algorithm 347 "An Efficient Algorithm For Sorting With Minimal Storage
{M1}" for more information.

BUBBLE_SORT



specifies that bubble sort should be used to sort the list. This is a
very slow sort techinque except for very short list (10 or less items).

technique



specifies a fullword that contains the sort technique to be used.
Symbols IM_SORT_TECHNIQUE_QUICK_SORT and IM_SORT_TECHNIQUE_BUBBLE_SORT
can be used to specify this technique. The default is quick sort.

headtkn



specifies the label of a fullword that contains the token of the item
that contains the heads when a structure can have multiple occurances.
If this parameter is not specified, the item that is current of item
type of the item type specified with the /headtype/parameter on the
associated descriptor create function is used.


      Example

This instruction will sort the list described by A_LIST_DESCRIPTOR in
ascending order by field CBFIELD, where CBSTART is the tag of the start
of the item.

      IM_SORT ID=IM,DESCTKN=A_LIST_DESCRIPTOR,                      +
                FIELDS=((CBFIELD-CBSTART,L'CBFIELD))

_*IM_SORT_FIELDLIST - Define Sort Fields *_

The IM_SORT_FIELDLIST macro is used to define static sort fields
definitions.

IM_SORT_FIELDLIST NAME=/name/
   ,FIELDS=/fieldlist/



*Parameter *



Description

name



the name to be associate with the sort fields.

fieldlist



a list of fields. The /fieldslist/is of the form:
((/offset/,/length/| /mask/, Ý/type/¨,ÝASCENDING|DESCENDING¨), ... as
many sort field as needed)

Parameter /offset/is the offset of the sort field in an item and
parameter /length/is the size of the sort field.

The valid values for /type/are: CHAR, PACKED, ZONED, FIXED, and BIT.

If BIT is specified, /mask/is required and is a one-byte value with bits
turned on in the positions that should be checked for sorting.

For all other types, /length/is used instead. It indicates the number of
bytes to compare for the field.

The default is CHAR.

ASCENDING is the default if neither ASCENDING or DESCENDING is specified.


      Example

This instruction will generate sort fields definitions that can be used
with the IM_SORT function to sort a list in ascending order by field
CBFIELD, where CBSTART is the tag of the start of the item.

      IM_SORT_FIELDSLIST NAME=PSD_FIELDSLIST,                       +
                FIELDS=((CBFIELD-CBSTART,L'CBFIELD))

_*IM_START - Start a Item Manager Session *_

The IM_START function is used to start the Item Manager.

IM_START ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
  Ý,ESVA=/esva/¨
  Ý,OPTIONS=(ÝREAD_ONLY¨
              Ý,ACTUAL_ADDRESS¨)
  Ý,DIVEPA=/divepa/¨
  Ý,DIVDDN=/divddn/¨
CALLX /im_epa/,(/im_token/,&IM_START,/esva/,/optbyte/,
      /divepa/,/divddn/)



*Parameter *



Description

esva



Specifies the label of a fullword in storage that contains the address
of the Environment Support Vector (ESV) created by the ES_START function.

READ_ONLY



option to indicate that the DIV data set will not be updated. If this
options is specified, the IM_SAVE can not be used.

ACTUAL_ADDRESS



option to indicate that actual virtual storage address should be used as
tokens for all but item type descriptors. If this is not specified,
tokens will be the relative byte within Item Manager Managed Storage. Do
not use this option if a DIV service processor is being used.

optbyte



specifies a byte of storage that contains the options. Bit 0 corresponds
to the READ_ONLY option and bit 1 corresponds to the ACTUAL_ADDRESS option.

divepa



specifies a fullword that contains the EPA of a DIV service processor.

divddn



specifies an eight byte field that contains the ddname of the file to be
used by the DIV service processor.


      Example

This instruction will start the Item Manager and use actual addresses as
token.

      IM_START ID=IM,OPTIONS=ACTUAL_ADDRESS



*Return Code *



Symbol



Description

0



IM_SUCCESS



A session of the Item Manager has successfully been started.

8



IM_ITEM_STORAGE_NOT_INITIALIZED



A session of the Item Manager has successfully been started. The
IM_INITIALIZE needs to be called to initialize Item Manager Managed Storage.



_*IM_STORE - Store an Item in Item Manager Managed Storage *_

The IM_STORE macro is used to store an item in Item Manager Managed
Storage. The item will become current of Item Manager.

IM_STORE ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
   ,ITEM={/item/ | (/item/,/item_length/)}
  Ý,ITEMTKN=/itemtkn/¨
CALLX /im_epa/,(/im_token/,&IM_STORE,/item_length/,/item/,/itemtkn/)



*Parameter *



Description

item



specifies the label of the storage in which the item to be placed in
Item Manager Managed Storage resides.

item_length



specifies the label of a signed binary integer indicating the length of
the storage area specified by the /name/parameter. In the macro form, if
item_length is not specified, an =A(L'item) will be used to determine
the length of the storage. This storage can be larger than the actual
item, but must be large enough to hold the complete item.

itemtkn



specifies the label of a fullword into which the token of the item will
be placed.


      Example

This instruction will store the item constructed at tag ITEM_WORK_AREA
in Item Manager Managed Storage.

      IM_STORE ID=IM,ITEM=ITEM_WORK_AREA

_*IM_TERMINATE - Terminate the Item Manager *_

The IM_TERMINATE function will terminate the Item Manager and release
all associated resources. It will also terminate the associated DIV
service processor.

IM_TERMINATE ID=/id_name/ Ý,SPEPA=/im_epa/¨ Ý,SPTOKEN=/im_token/¨
CALLX /im_epa/,(/im_token/,&IM_TERMINATE)


      Example

This instruction will terminate a session with the Item Manager.

      IM_TERMINATE ID=IM

_*IM_TEXT - Generating Description Text *_

The IM_TEXT macro is used to generate description text. Description text
is used with the TEXT keyword on various Item Manager macros.

/name/ IM_TEXT /string/



*Parameter *



Description

name



specifies the name to be associated with the text.

string



specifies a quoted string that contains the text.


      Example

SOMETEXT IM_TEXT "This is some text."

------------------------------------------------------------------------


  Chapter 9. Memory Manager <#ToC_74>

The memory manager is designed to make memory allocation efficient for
applications by reducing the number of system requests needed to obtain
and release portions of storage. For applications that need to
frequently allocate small items of storage, this can drastically reduce
system overhead.

Applications use the memory manager to create one or more storage
/heaps/, where each heap represents a storage space that may
incrementally grow and shrink over time as the application program
obtains and releases storage. The increment by which a heap grows and
shrinks may be specified when the heap is created, as can restrictions
on its location (anywhere, or below the 16-megabyte line). All storage
owned by a heap is automatically released when the heap is destroyed.

------------------------------------------------------------------------


    Preparing to Use the Memory Manager <#ToC_75>

The Memory Manager operates independently of its execution environment;
all managed storage is obtained through Environment Support. Like any
service processor, the Memory Manager must be loaded and started before
its functions can be used. This process is fully covered in Part 1,
"Service Processors User's Guide" <#HDRPART1> and will not be repeated
here.

The Memory Manager's service processor identification code is *MM*so:

  *

    the COPY member is *SRVMMMAC*,

  *

    the load module, named by symbol *&MM_MEMORY_MANAGER*, is SRVMM,

  *

    and the names of all symbols, macros, and conditions begin with the
    prefix *MM_*.

A storage heap is identified by the /mm_token/parameter, which is
required when invoking any Memory Manager function. Invoking the
MM_START function will create a new storage heap and return its
identification value in /mm_token/. Using the same value for
/mm_token/when invoking the MM_TERMINATE function will automatically
release all of the heap's storage and destroy it. To allocate and
release storage within a heap, use the MM_OBTAIN_STORAGE and
MM_RELEASE_STORAGE functions, identifying the heap with /mm_token/. To
reset all storage within a heap without giving the storage back to the
system, use the MM_RESET_HEAP function.


      Common Parameters <#ToC_76>

There are several parameters common to any Memory Manager function call.
These parameters are listed below:



*Parameter *



Description

id_name



the name of a service processor identifier created by the MM_ID macro
which will be used by all other function invocation macros to
automatically obtain values for /mm_epa/and /mm_token/. This parameter
is required unless both /mm_epa/and /mm_token/are specified.

mm_epa



a fullword in storage containing the entry point address of the Memory
Manager service processor. The value specified by /mm_epa/overrides any
value obtained from ID=/id_name/.

mm_token



a fullword in storage containing the value (to be) returned by MM_START
for the /mm_token/parameter. The value specified by /mm_token/overrides
any value obtained from ID=/id_name/.


      Complete List of Memory Manager Return Codes <#ToC_77>

Many return codes can be returned from each function. In the function
descriptions later in this chapter, the most common return codes
returned by the particular function are documented. The following is a
complete list of Memory Manager return codes.

*Return Code *



Symbol



Description

0



MM_SUCCESS



The invoked Memory Manager function performed the requested service
without encountering any problems.

1



MM_INVALID_FUNCTION



An invalid /FunctionCode/(the second parameter in any service processor
function call) was specified.

2



MM_INVALID_HEAPID



An invalid value was given in /mm_token/. This parameter must contain a
value previously returned by the MM_START function.

3



MM_INVALID_INCREMENT



An invalid value for the /increment/parameter was passed to the MM_START
function of the Memory Manager.

4



MM_INVALID_LOCATION



An invalid value for the /location/parameter was passed to the MM_START
function of the Memory Manager.

5



MM_INVALID_SIZE



An invalid value was provided for the /size/parameter, which must be a
positive fullword integer value.

6



MM_INVALID_PARM_COUNT



Either too few parameters were supplied for the function call or too
many were supplied. Check the parameter list to ensure that it is right
for the function being invoked.

7



MM_INVALID_ALIGNMENT



The value of /address/, a MM_RELEASE_STORAGE parameter, must be an even
multiple of eight (doubleword boundary).

8



MM_STORAGE_NOT_AVAILABLE



The system denied a request for storage.

9



MM_UNKNOWN_ERROR



The Memory Manager encountered an unexpected error. The application
program should respond to this return code by immediately dumping the
debugging area with the ES_DISPLAY_DEBUG_INFO function of Environment
Support.

*Note: *No functions other than MM_TERMINATE will be accepted by the
Memory Manager after this error has occurred.

10



MM_MEMORY_NOT_IN_HEAP



The memory being released (via MM_RELEASE_STORAGE) was not allocated
using the supplied mm_token value.

11



MM_MEMORY_NOT_ALLOCATED



The memory being released (via MM_RELEASE_STORAGE) does exist in the
heap indicated by the supplied /mm_token/value, but is not allocated and
thus cannot be released.

12



MM_CORRUPT_STORAGE



An internal control block has been overwritten by invalid data. The
application program may have written data beyond the end of a block of
storage previously allocated by the MM_OBTAIN_STORAGE function, or it
may have continued writing to storage released via the
MM_RELEASE_STORAGE function.

*Note: *No functions other than MM_TERMINATE will be accepted by the
Memory Manager after this error has occurred.

13



MM_NOT_USEABLE



All functions to the memory manager, other than MM_TERMINATE, have been
disabled due to a previous error. Errors that can cause the memory
manager to become unuseable are *MM_UNKNOWN_ERROR*and *MM_CORRUPT_STORAGE*.



    Memory Manager Service Processor Functions <#ToC_78>

The remaining sections of this chapter describe all functions provided
by the Memory Manager service processor, arranged in alphabetical order.
Each function's description begins on a new page, and the name of the
function being described appears at the top of every page.

_*MM_ID - Establish Default Memory Manager Values *_

The MM_ID macro is used to establish default values for use by other
Memory Manager macros, which may access those defaults through a unique
identifier, /id_name/, specified by the user. Default values can be
established for the following parameters: /mm_epname/, /mm_epa/, and
/mm_token/.

In most cases, nothing other than the entry point name needs to be
specified on the MM_ID macro: it will automatically define working
storage fields for the remaining parameters if they are not specified.
These values, whether generated by the macro or provided by the user,
are accessable from all other Memory Manager macros through the
ID=/id_name/. If the application program needs to access the parameters
directly, they should be explicitly specified.

MM_ID ID=/id_name/
  Ý,SPEPNAME=/mm_epname/¨
  Ý,SPEPA=/mm_epa/¨
  Ý,SPTOKEN=/mm_token/¨
  Ý,ESID=/esid_name/¨
  Ý,ESVA=/esva/¨



*Parameter *



Description

id_name



the identifier to assign to the service processor identifier being
established. This name must be unique for all service processor identifiers.

mm_epname



the entry point name of the Memory Manager service processor module that
is being used.

mm_epa



specifies the label of a fullword in storage that will contain the entry
point address of the Memory Manager service processor.

mm_token



specifies the label of a fullword in storage that will contain the value
assigned by the MM_START function of the Memory Manager.

esid_name



the name of a service processor identifier, created by the ES_ID macro,
which will be used by the MM_ID macro to automatically obtain the value
for /esv/(see below). If this parameter is not specified and an
Environment Support service processor ID exists, that ID will be used.

esva



specifies the label of a fullword in storage that contains (or will
contain) the address of the Environment Support Vector (ESV) created by
the ES_START function.


      Example

An application intends to use only one memory manager heap for its
storage and issues the following instruction:

   MM_ID ID=MM,EPNAME=&MEMORY_MANAGER

This instruction will save all parameter values and generate the
following code:

                  PWA TYPE=PARTIAL  | Generate fields to EPA & TOKEN.
&PWA.MM_SPEPA    DS  A             |   ID=MM: Entry point address.
&PWA.MM_SPTOKEN  DS  F             |   ID=MM: Token value.
                     ENDPWA  ,         | End of generated fields.

Once the MM_ID macro instruction above has been executed by the
assembler, specifying ID=MM on any Memory Manager macro instruction will
be equivalent to supplying all of the above values.

If the application needs to use more than one heap, it can either create
an ID for each heap, or it can specify ID=MM but override the
/mm_token/parameter on each macro instruction:

MM_START          ID=MM,SPTOKEN=NEW_HEAP  Create a new storage heap.
MM_OBTAIN_STORAGE ID=MM,SPTOKEN=NEW_HEAP,SIZE=256,ADDRESS=BUFFER_ADDR

_*MM_OBTAIN_STORAGE - Allocate Managed Storage*_

The MM_OBTAIN_STORAGE function allocates a single contiguous section of
memory for use by an application program. The new storage will begin on
a doubleword boundary and its address will be returned in the
/address/parameter. The storage will be initialized to all zeros before
it is returned to the application program.

If the Memory Manager cannot locate a large enough section of storage
within the specified heap, storage will be obtained from the system and
added to the heap. The amount of storage obtained from the system will
equal the heap's increment size or the amount of storage being allocated
(/size/), whichever is larger.

MM_OBTAIN_STORAGE ID=/id_name/ Ý,SPEPA=/mm_epa/¨ Ý,SPTOKEN=/mm_token/¨
   ,SIZE=/size/
   ,ADDRESS=/address/
CALLX /mm_epa/,(/mm_token/,&MM_OBTAIN_STORAGE,/size/,/address/)



*Parameter *



Description

size



specifies the label of a signed fullword integer indicating the desired
amount of storage to be allocated. The amount of storage to be allocated
must be between 1 and 16,777,215 bytes.

address



specifies a fullword in which the address of the newly allocated storage
is to be returned.



      Example

This example shows the code needed to allocate storage for holding a
simple control block.

          ...
   MM_OBTAIN_STORAGE ID=MM,SIZE==A(CTL_LEN),ADDRESS=PWA_CTLPTR
             ...
             PWA
PWA_CTLPTR   DS  A          Address of control block storage.
             ENDPWA
             ...
CTL          DSECT          Control Block's DSECT.
             ...              Various control block fields.
CTL_LEN      EQU  *-CTL     Length of Control Block.

_*MM_RELEASE_STORAGE - Release Managed Storage*_

The MM_RELEASE_STORAGE function releases a contiguous section of storage
back to the managed heap identified by the mm_token parameter. The
storage to be released must be located within the heap identified by
/mm_token/and must begin on a doubleword boundary. It is pointed to by
the /address/parameter and its length is specified by the /size/parameter.

The storage being released does not have to exactly match a previous
MM_OBTAIN_STORAGE request in its /address/and /size/, but it must
consist entirely of storage allocated from heap /mm_token/. For example,
a program might allocate a single large piece of storage and then give
it back piece-by-piece. So long as the storage being returned to the
heap came from the heap in the first place, there is no problem.

MM_RELEASE_STORAGE ID=/id_name/ Ý,SPEPA=/mm_epa/¨ Ý,SPTOKEN=/mm_token/¨
   ,SIZE=/size/
   ,ADDRESS=/address/
CALLX /mm_epa/,(/mm_token/,&MM_RELEASE_STORAGE,/size/,/address/)



*Parameter *



Description

size



a fullword integer indicating the desired amount of storage to be
released. The memory manager will round this value up to the nearest
multiple of eight.

address



a fullword address that points to the storage to be released. This
storage should have been previouly allocated in the same storage heap by
the MM_OBTAIN_STORAGE function of the memory manager, and must be
aligned on a doubleword boundary.


      Example

This example shows the code needed to release storage that held a simple
control block.

          ...
   MM_RELEASE_STORAGE ID=MM,SIZE==A(CTL_LEN),ADDRESS=PWA_CTLPTR
             ...
             PWA
PWA_CTLPTR   DS  A          Address of control block storage.
             ENDPWA
             ...
CTL          DSECT          Control Block's DSECT.
             ...              Various control block fields.
CTL_LEN      EQU  *-CTL     Length of Control Block.

_*MM_RESET_HEAP - Release All Managed Storage*_

The MM_RESET_HEAP function releases all managed storage back to the heap
identified by the mm_token parameter. This function provides
applications with a method of reusing a heap without having to terminate
and restart a Memory Manager session. When this function is used, all
storage previously obtained within the heap by the MM_OBTAIN_STORAGE
function is released back to the heap.

MM_RESET_HEAP ID=/id_name/ Ý,SPEPA=/mm_epa/¨ Ý,SPTOKEN=/mm_token/¨
CALLX /mm_epa/,(/mm_token/,&MM_RESET_HEAP)

_*MM_START - Create a New Storage Heap*_

The MM_START function creates a new storage heap for management by the
memory manager. Two optional parameters, /increment/and
/location/control how the heap will grow and where its storage will be
allocated.

MM_START ID=/id_name/ Ý,SPEPA=/mm_epa/¨ Ý,SPTOKEN=/mm_token/¨
  Ý,ESVA=/esva/¨
  Ý,INCREMENT={:us.4096:eus. | /increment/}¨
  Ý,LOCATION={*:us.ANY:eus.*|*BELOW*}¨
CALLX /mm_epa/,(/mm_token/,&MM_START,/esva/,Ý/increment/¨,Ý/location/¨)



*Parameter *



Description

increment



specifies the label of a fullword signed integer that will be used as
the smallest amount of storage to obtain from the system when the heap
needs to grow in size. A larger amount of storage will be obtained if
needed in order to satisfy an MM_OBTAIN_STORAGE request. If the
specified value for /increment/is an even multiple of the system page
size (4096 bytes), each increment of storage will be allocated on a page
boundary. The default value for /increment/is 4096 bytes.

location



specifies whether storage for the heap must come from below the
16-megabyte line (*BELOW*) or if it may come from anywhere (*ANY*). For
the call form of this function, /location/specifies a fullword in
storage containing the value of symbol &MM_LOCATION_BELOW if the storage
must come from below the 16-megabyte line and &MM_LOCATION_ANY if the
storage may come from anywhere. These symbols are defined in copy member
SRVMMMAC.



_*MM_TERMINATE - Destroy an Existing Storage Heap *_

The MM_TERMINATE function releases all storage associated with an
existing storage heap and then destroys the heap. The value of
/mm_token/will be set to zero when MM_TERMINATE returns.

MM_TERMINATE ID=/id_name/ Ý,SPEPA=/mm_epa/¨ Ý,SPTOKEN=/mm_token/¨
CALLX /mm_epa/,(/mm_token/,&MM_TERMINATE)

------------------------------------------------------------------------


  Chapter 10. Message Services <#ToC_79>

The Message Services service processor simplifies the tasks of defining,
issuing and maintaining messages. This is accomplished by:

  *

    Defining messages in a /central place/, separate from the code that
    issues them.

  *

    Defining /standards/which the messages must follow, which are
    enforced at assembly time.

  *

    Associating a /severity/with a message, which the issuer may
    optionally use to set returncodes.

  *

    Allowing /text substitution/within predefined messages. The
    substitution function uses the String Formatter: hence, any message
    may be defined using standard String Formatter format strings.

  *

    Defining the /message destination/at execution time.

  *

    Allowing the caller to /retrieve message text/if needed for special
    routing (such as multiple destinations).


      Defining Messages <#ToC_80>

Message Services requires its users to define messages in a message
CSECT. Macros are provided to simplify construction of this CSECT. Up to
25 message CSECTs may be loaded by an individual Message Services
session. Each message CSECT will ultimately reside as a load module:
however, since Message Services uses the ES_LOAD_MODULE function to
locate and load the message CSECTs into storage, the message CSECT could
be defined via a module name table and linked with the caller's load
modules and/or other message CSECTs as desired.

The construction of a message CSECT is a simple matter. The CSECT itself
is started and terminated by the MS_MESSAGE_MODULE macro, which also
defines the messages' prefix string, the length of the message
identifiers, and optionally the severity characters and their associated
return codes. Each individual message is defined by a MS_MESSAGE macro,
which ensures that the proper message ID prefix, length and severity
characters were used. The following example defines a message CSECT with
three messages:

*Figure 15. Sample Message Module Definition* <#FT_Figure_15>



      MS_MESSAGE_MODULE   START,                                   +
                  NAME=MSGMOD03,         This becomes the CSECT name  +
                  PREFIX=ABC,                                         +
                  IDLENGTH=8,            All msgids are 8 chars long  +
                  SEVCHAR=((I,0),(W,4),(E,8),(F,12))

ABC0001I MS_MESSAGE  'This is merely informational; return code is 0.'
ABC0002W MS_MESSAGE  'You are being warned; return code is 4.'
ABC0003E MS_MESSAGE  'An error has occurred; return code is 8.'

         MS_MESSAGE_MODULE   END

MS_MESSAGE_MODULE and MS_MESSAGE do not generate any executable code.


      Obtaining Message Services' Symbols & Macros <#ToC_81>

Message Services' symbols and interface macros can be found in the
assembler copy member SRVMSMAC. This member contains symbols naming
Message Services' load module, function codes, return codes, and
parameter values. It also contains macros for using all of the Message
Services' functions. The following statement or its equivalent should
appear at the beginning of any program that uses Message Services:

   COPY SRVMSMAC      Obtain Message Services' symbols & macros.


      Establishing Message Services Defaults <#ToC_82>

Some parameters are general to Message Services and not specific to any
function. These parameters include its load module name (/MS_epname/),
entry point address (/MS_epa/), and token value (/MS_token/). The MS_ID
macro (see ) can be used to establish defaults for these parameters and
associate them with a unique service processor identifier. The
identifier may then be supplied on any Message Services macro
instruction to refer to the default parameter values.


      Identifying Message Services <#ToC_83>

The Message service processor resides in the load module named by the
following symbol definition in copy member SRVMSMAC:

&MESSAGE_SERVICES SETC  '''SRVMS   '''

This symbolic name should be used as the service processor entry point
name for Message Services as shown in the following MS_ID macro
instruction:

MS_ID ID=MS,SPEPNAME=&MESSAGE_SERVICES    Set MsgServ Defaults.


      Loading Message Services <#ToC_84>

The recommended method for loading Message Services is through
Environment Support's ES_LOAD_MODULE function, as shown in the following
example:

ES_LOAD_MODULE ID=ES,SPID=MS            Load Message Services


      Common Parameters <#ToC_85>

There are several parameters common to any Message Services function
call. These are:



*Parameter *



Description

id_name



specifies the name of a service processor identifier created by the
MS_ID macro which will be used by the MS_START macro to automatically
obtain values for /MS_epa/and /MS_token/. This parameter is required
unless both /MS_epa/and /MS_token/are specified.

MS_epname



the entry point name of the Message Services service processor module
that is being used.

MS_epa



specifies the label of a fullword in storage that contains the entry
point address of an already-started Message Services service processor.
The value specified by /MS_epa/overrides any value obtained from
ID=/id_name/.

MS_token



specifies the label of a fullword in storage that contains the value
returned by MS_START for the /MS_token/parameter. The value specified by
/MS_token/overrides any value obtained from ID=/id_name/.



      Return Codes <#ToC_86>

Message Services may issue any of the following return codes in various
situations. Some of the return codes may be received from any call to
Message Services, while others are specific to individual functions.



*Return Code *



Symbol



Description

0



MS_SUCCESS



The Message Services function has completed successfully.

1



MS_INVALID_FUNCTION



The specified function code is not presently supported.

2



MS_INVALID_NUMBER_OF_PARMS



The Message Services function received an invalid number of parameters.
This may be due to an improperly coded CALLX or PLIST macro, or the
inadvertent use of the NOVL option.

3



MS_INVALID_MS_ID



Message Services detected an invalid PWA address in MS_token.

4



MS_ENVIRONMENT_SUPPORT_ ERROR



An error was reported by Environment Support. The error probably
occurred while attempting to load the Printline or String Handler
service processor.

5



MS_STRING_HANDLER_ERROR



An error was reported by the String Handler service processor. More
information may be found by issuing the ES_DISPLAY_DEBUG_INFO function.

6



MS_PRINT_LINE_TRUNCATED



The formatted message was too large to fit in Message Services' internal
256-byte buffer. The first 256 bytes of the message are printed.

7



MS_PRINTLINE_ERROR



An error was reported by the Printline service processor. More
information may be found by issuing the ES_DISPLAY_DEBUG_INFO function.

8



MS_INVALID_MSGDEST_OPTION



The option byte provided did not contain a valid MSGDEST option value.
Message Services currently supports the following MSGDEST option values:

  *

    /*0*/- Not specified.

  *

    /*1*/- DDNAME specified.

  *

    /*2*/- PLID or PL specified.

  *

    /*3*/- CONSOLE specified.

9



MS_MSGMOD_MISSING



Either the address of the message module list was zero, or the list's
count field was zero. At least one message module must be provided to
MS_START.

10



MS_TOO_MANY_MSGMODS



More than 25 message modules were provided to MS_START. At present,
Message Services can only handle 25 message modules.

11



MS_MSGMOD_NOT_LOADED



A particular message module could not be loaded by MS_START.

12



MS_MSGMOD_NOT_VALID



One of the message modules was not a valid Message Services message module.

13



MS_INVALID_SIZELENGTH



MS_START found a sizelength value that was greater than 4. The value of
sizelength must be between 1 and 4, or must be 0 or unspecified in order
to use the default value of 2.

14



MS_MESSAGE_NOT_FOUND



The message specified by msgid_string could not be found among the
active message modules.

15



MS_INVALID_PREFIX



The message prefix specified by msgid_string was not found among the
active message modules.

16



MS_MSGDEST_NOT_PROVIDED



A message destination was not provided via the MSGDEST operand of
MS_START. This Message Services function cannot be used without a
message destination.



------------------------------------------------------------------------


    Message Services Functions <#ToC_87>

The remaining sections of this chapter describe all functions provided
by Message Services, arranged in alphabetical order. Each function's
description begins on a new page, and the name of the function being
described appears in the top outside corner of every page.

_*MS_GET_MESSAGE - Retrieve Message Text*_

The MS_GET_MESSAGE function retrieves and formats a message, then
returns the formatted message text and its length to the caller.

MS_GET_MESSAGE ID=/id_name/ Ý,SPEPA=/MS_epa/¨ Ý,SPTOKEN=/MS_token/¨
   ,MSGID=/msgid_ID_string/
   ,STRING=({/string/ |(/string/,/string_length/)}
   ,RESULTLEN=/result_length/
   Ý,SOURCE=(/source1/,/source2/, ...)¨
CALLX /MS_epa/,(/MS_token/,&MS_GET_MESSAGE,/msgID_string/
              ,/string/,/string_length/,/result_length/
              {,/source1/,/source2/, ...})



*Parameter *



Description

msgid_ID_string



Specifies the message ID to be processed.

string



Specifies the area where MS_GET_MESSAGE will return the text of the
requested message.

string_length



Provides the length of the field named by string. The length of this
field is governed by the SizeLength operand specified on the MS_ID or
MS_START macro.

result_length



The MS_GET_MESSAGE function will return the actual length of the
formatted message into this field. The length of this field is governed
by the SizeLength operand specified on the MS_ID or MS_START macro.

source



Provides substitution parameters for the String Handler to insert into
the message being constructed.



*Examples *

If message ABC002I were defined in a message CSECT using:

ABC002E MS_MESSAGE "{I} parameters ignored due to {C}."

the following MS_GET_MESSAGE macro:

MS_GET_MESSAGE  ID=MS,
                MSGID==C'ABC002E',
                SOURCE=(3,"syntax errors")

would result in the message:

   ABC002E 3 parameters ignored due to syntax errors.

_*MS_ID - Establish Default Message Services Values*_

The MS_ID macro is used to establish default values for use by other
Message Services macros, which may access those values through a unique
identifier, /id_name/, specified by the user. When allowed to generate
default values, this macro will create Program Work Area (PWA) storage
for /MS_epa/and /MS_token/. These values, whether generated by the macro
or provided by the user, are accessable from all other Message Services
macros via the ID=/id_name/parameter.

MS_ID ID=/id_name/
   Ý,SPEPNAME=/MS_epname/¨
   Ý,SPEPA=/MS_epa/¨
   Ý,SPTOKEN=/MS_token/¨
   Ý,ESID=/esid_name/¨
   Ý,ESVA=/esva/¨
   Ý,SIZELENGTH=/integer/¨



*Parameter *



Description

esva



Specifies the label of a fullword in storage that contains (or will
contain) the address of the Environment Support Vector (ESV) created by
the ES_START function.

sizelength






*Examples*

The following MS_ID macro will associate everything required by the
Message Services macros with the service processor identifier PL, as
well as establish the sizelength value for the Message Services session.

    MS_ID  ID=PL,
           SPEPNAME=&MESSAGE_SERVICES,
           SPEPA=PWA_MS_ENTRY,
           SPTOKEN=PWA_MS_TOKEN,
           ESID=ES,
           ESVA=PWA_ESVA,
           SIZELENGTH=4

PWA_MS_ENTRY  DS    F         Entrypoint for Message Services
PWA_MS_TOKEN  DS    F         Unique token for Message Services session
PWA_ESVA      DS    F         Environment Support Vector address

_*MS_ISSUE_MESSAGE - Issue A Message*_

The MS_ISSUE_MESSAGE function retrieves, formats and prints the message
referred to by /msgid_string/.

MS_ISSUE_MESSAGE ID=/id_name/ Ý,SPEPA=/MS_epa/¨ Ý,SPTOKEN=/MS_token/¨
   ,MSGID=/msgid_string/
   Ý,SOURCE=(/source1/,/source2/, ...)¨
CALLX /MS_epa/,(/MS_token/,&MS_ISSUE_MESSAGE,/msgID_string/
              {,/source1/,/source2/, ...})



*Parameter *



Description

msgid_string



Specifies the message ID to be processed. This parameter may be coded as
a literal or an address.

source1,source2,...



Provides substitution parameters for the String Handler to insert into
the message being constructed.



*Examples *

If message ABC002I were defined in a message module using:

ABC002E MS_MESSAGE "{I} parameters ignored due to {C}."

the following MS_ISSUE_MESSAGE macro:

MS_ISSUE_MESSAGE  ID=MS,
                  MSGID='ABC002E',
                  SOURCE=(3,"syntax errors")

would result in the message:

ABC002E 3 parameters ignored due to syntax errors.

_*MS_MESSAGE - Define A Message *_

The MS_MESSAGE macro is used to define the text of a message. MS_MESSAGE
will also use the values specified by the MS_MESSAGE_MODULE operands
prefix, idlength and sevchar to enforce the respective attributes of the
message.

message_id  MS_MESSAGE  '      message_text      '



*Parameter *



Description

message_id



Provides the message ID for the message. The message ID will be
generated at the beginning of the message text. The message ID is
expected to be of the format: {msg_prefix}||{msg_number}||{sev_char} .
The contents and length of msg_prefix, as well as the value of sev_char
and the overall length of the message ID are enforced by the values
specified on MS_MESSAGE_MODULE.

message_text



Specifies a String Handler control string. The length of this string may
be up to 255 characters: however, the length of the resulting formatted
string cannot exceed 255 bytes.



*Examples *

The following MS_MESSAGE macros define a series of messages. They also
point out the default severity characters.

XYZ001I  MS_MESSAGE  "Information message, severity value of 0."
XYZ002W  MS_MESSAGE  "Warning message, severity value of 4."
XYZ003E  MS_MESSAGE  "Error message, severity value of 8."
XYZ004S  MS_MESSAGE  "Severe message, severity value of 12."
XYZ005C  MS_MESSAGE  "Catastrophic message, severity value of 16."

_*MS_MESSAGE_MODULE - Define A Message Module *_

The MS_MESSAGE_MODULE macro is used to start or end a message module.
MS_MESSAGE_MODULE also sets various attributes of the messages prefix,
idlength and sevchar to enforce the respective attributes of the message.

MS_MESSAGE_MODULE START
                 ,NAME=/csectname/
                 ,PREFIX=/msgid_prefix/
                 ,IDLENGTH={/msgid_length/ |/*8*/}
                 Ý,SEVCHAR=/sevchar_def/¨

     -- or --

MS_MESSAGE_MODULE END



*Parameter *



Description

START



Defines the beginning of a message module. :pLt.END :pLd.Defines the end
of the message module. This must be coded after all MS_MESSAGE macros.
No other parameters are valid when END is coded.

csectname



Provides the name of the CSECT that MS_MESSAGE_MODULE will generate.

msgid_prefix



Specifies that all messages defined in this message module must be
prefixed with this string. A message prefix may be up to 6 characters in
length.

msgid_length



Specifies the required length, in bytes, for all message IDs coded on
MS_MESSAGE macros.

sevchar_def



Provides a list of message suffix characters and an associated severity.
These are coded as (character,severity), where character is a single
message suffix character, and severity is the associated severity code.
A maximum of these severity codes will be returned to the caller if the
MAXSEV keyword is specified on the MS_START macro. Any message suffixes
coded on MS_MESSAGE macros that do not appear among the valid severity
characters will cause an assembly error. The default sevchar_def list is:

SEVCHAR=((I,0),(W,4),(E,8),(S,12),(C,16))



*Examples *

The following macros define a complete message module.

  MS_MESSAGE_MODULE START,
                    NAME=ABC$MSGS,
                    PREFIX=ABC,
                    IDLENGTH=7,
                    SEVCHAR=((I,0),(W,4),(E,8),(F,16))

ABC001I  MS_MESSAGE  "Informational message, severity = 0."
ABC002W  MS_MESSAGE  "Warning message, severity = 4."
ABC003E  MS_MESSAGE  "Error message, severity = 8."
ABC004F  MS_MESSAGE  "Fatal message, severity = 16."

  MS_MESSAGE_MODULE END
  END

_*MS_START - Begin A Message Services Session*_

The MS_START function establishes a new Message Services session and
returns its session identifier in the /MS_token/parameter. The message
destination, maximum severity field, message CSECT list and other global
Message Services parameters are provided here.

MS_START ID=/id_name/ Ý,SPEPA=/MS_epa/¨ Ý,SPTOKEN=/MS_token/¨
   Ý,ESVA=/esva/¨
   ,MSGDEST=(DDNAME,/ddnamespec/)     |
            (PLID,/msgserv_procid/)   |
            (PL,/PL_EPA/,/PL_token/)    |
            (CONSOLE)
   ,MSGMOD=(/msgmod_csect/,/msgmod_csect/, ...)
   ,MSGMODLIST=/msgmod_list/
   Ý,MAXSEV=/maxsev_address/¨
   Ý,PLCC=/carriage_control/¨
   Ý,SIZELENGTH={/sizelength/ | *2*}¨
   Ý,OPTIONS=(/option_list/)¨
CALLX /MS_epa/,(/MS_token/,&MS_START,/esva/,
              /msgmod_list/,/sizelengthmaxsev_address/,
              /carriage_control/,/MSGDEST_option,/
              /MSGDEST_specific_parameters/,/option_byte/)



*Parameter *



Description

esva



Specifies the label of a fullword in storage that contains the address
of the Environment Support Vector (ESV) created by the ES_START function.

MSGDEST



Specifies the message destination that Message Services will use to
write its formatted messages. The MSGDEST keyword supports the following
operands:

  *

    /*DDNAME*/: This provides the DDname that Message Services should
    use to start a Printline session. The Printline session will be
    terminated when MS_TERMINATE is called.

  *

    /*PLID*/: This specifies the service processor ID of an existing
    Printline session. The ID is used to find the

  *

    /*PL*/: This is used to provide the /PL_EPA/and /PL_token/of an
    existing Printline session.

  *

    /*CONSOLE*/: This specifies that the /console/is the message
    destination. The ES_DISPLAY_MESSAGE service is actually used to
    display the message.

MSGDEST_option



If the CALLX form is used, the MSGDEST keyword must be represented as a
single byte, containing one of the following values:

  *

    /*0*/- MSGDEST not specified. There are no additional parameters.

  *

    /*1*/- DDNAME specified. This is followed by the address of an
    8-character DDname.

  *

    /*2*/- PLID or PL specified. This is followed by the addresses of
    PL_EPA and PL_token respectively.

  *

    /*3*/- CONSOLE specified. There are no additional parameters.

msgmod_csect



Provides the names of one or more message modules. These modules will be
loaded by ES_LOAD_MODULE, and thus must either exist as separate load
modules in STEPLIB or be defined in an application module name table.

msgmod_list



If the application has a need to construct its own message module list,
it may be provided to MS_START using the MSGMODLIST keyword. The message
module list must consist of a fullword containing the number of message
module names, followed by a list of 8-character module names, as follows:

MOD_LIST DC   F'3'
         DC   CL8'ABC$MSGS'
         DC   CL8'DEF$MSGS'
         DC   CL8'XYZ$MSGS'

A list of this format is constructed when the MSGMOD keyword is used.
The MSGMOD and MSGMODLIST keywords are mutually exclusive.

maxsev_address



The optional address of a halfword where Message Services will maintain
the highest severity level of any message issued. This field should be
initialized to zeros before MS_ISSUE_MESSAGE or MS_GET_MESSAGE are invoked.

carriage_control



Optionally provides an ASA carriage control character to be used when
printing messages. If MSGDEST is not specified or is set to CONSOLE, use
of the PLCC keyword will generate an MNOTE. The operand of PLCC may be
specified as a quoted character or as an address.

sizelength



An integer value from 1 and 4 that determines the size, in bytes, of all
values representing string lengths by the String Handler. For example, a
/sizelength/value of 4 would cause all lengths returned by the String
Handler to be 4 bytes in length.

option_list



A list of additional options for this Message Services session. The only
option currently supported is /FOLD/.

    *FOLD*- All output produced by Message Services should be folded to
    uppercase. If using the CALLX form to call /MS_START/, the FOLD
    option corresponds to a bit setting of X'80' in the option byte.
    Note that when using a MSGDEST of /PLID/, the PrintLine session must
    have been started with /OPTIONS=FOLD/.



*Examples *

The following MS_START macro will initialize a Message Services session.
This MS_START example will cause the following to occur:

  *

    A Printline session will be started by Message Services, using
    DDname SYSPRINT and a SizeLength value of 4.

  *

    The message modules ABC$MSGS, DEF$MSGS and XYZ$MSGS are loaded and
    validated.

  *

    The address of PWA_MAXSEV is bound as the MaxSev halfword's address.
    PWA_MAXSEV will be maintained with the highest message severity code
    of any message issued by this Message Services session.

  *

    A carriage control byte of '0' will prefix all messages built by
    this Message Services session. This will cause messages to be
    double-spaced by PrintLine.

    MS_START ID=PL,
             MSGDEST=(DDNAME,=C'SYSPRINT'),
             MSGMOD=(ABC$MSGS,DEF$MSGS,XYZ$MSGS),
             MAXSEV=PWA_MAXSEV,
             PLCC='0',
             SIZELENGTH=4

PWA_MAXSEV   DS    H         Max. severity, maintained by MsgServ

_*MS_TERMINATE - Terminate A Message Services Session *_

The MS_TERMINATE function concludes the Message Services session
identified by the /MS_token/parameter, and releases any resources held
by the Message Services service processor.

MS_TERMINATE ID=/id_name/ Ý,SPEPA=/MS_epa/¨ Ý,SPTOKEN=/MS_token/¨
CALLX /MS_epa/,(/MS_token/,&MS_TERMINATE)

*Examples *

The following MS_TERMINATE macro will cause Message Services to close
its report file and release any resources that it acquired.

MS_TERMINATE ID=MS

------------------------------------------------------------------------


  Chapter 11. Printline <#ToC_88>

The Printline service processor is intended to simplify report writing
by managing such typical "housekeeping" tasks of report writing as
headers and footers, page ejects, and page numbers. This can reduce the
complexity of programs that need to produce reports, freeing the
developer to concentrate on other aspects of the report program.

The Printline service processor is dependent on the MVS operating system
environment, primarily due to its use of QSAM.

The Printline service processor can make use of the String Handler to
construct header, footer and data lines from String Handler control
strings and source parameters. Heading and footing definitions may be
added, changed or deleted dynamically. Page counters are defined as part
of a heading or footing data line: while the actual counters reside in
the caller's storage, they are incremented automatically by Printline,
and formatted under control of the associated format control string.
Multiple page counters may be defined at once, and they need not contain
the same values.


      Basic Operation Of Printline <#ToC_89>

Printline has three types of lines: /header/lines, /footer/lines, and
/data/lines. Header and footer lines are generally established once, and
remain "current" until either Printline is told to remove them or
Printline is terminated. Data lines are printed as they are passed to
Printline. If a data line would not fit on the current page, Printline
will print any footers that are currently defined, then print any
headers that are defined. Any page counters active at the time will be
incremented. The caller can also force a page "break" to occur by
calling a Printline function.

Printline uses the OS file handler for output. When the OS file handler
is started, option ISOCC and RECORDLENGTH=(4,maxlnsz) is specified.

By default, Printline will print exactly what is passed to it,
preserving lowercase data. An option can be used to cause Printline to
convert everything it prints to uppercase. This may be a consideration
if reports produced using Printline might print on uppercase-only printers.


      The Format Of A Page <#ToC_90>

Printline allows its caller to define the format of a report's page in
terms of:

  *

    The length of the page (number of total print lines),

  *

    The /header/, or those lines that appear at the top of each page,

  *

    The /footer/, or those lines that appear at the bottom of each page,

  *

    The body of the page.

Printline provides function macros to manage each of these components a
report: these are defined below.


        The Length Of The Page

When a Printline session is started, the caller specifies the space on a
page available for printing. The default page length is 66 print lines.
The actual space available for printing data is determined by the total
page length minus any headers and footers defined. Since headers and
footers can be defined, changed or removed in mid-report, the amount of
space available for printing data may change. The PL_QUERY_LINES_LEFT
function can return the amount of space remaining on the current page at
any point in a Printline session.


        Headers

Headers as defined by Printline, appear at the top of each printed page.
When a page break occurs (by either reaching the end of the current page
or calling the PL_PAGE_BREAK function), the headers are printed
according to the current header definition.

Header lines are defined individually by the PL_SET_HEADER and
PL_SET_FORMATTED_HEADER functions, and may be subsequently removed by
the PL_RESET_HEADER function. Each header line is assigned a "line
number": this number is used to determine the order that header lines
are printed in. A header may be redefined "in-place" using the same line
number, even if the number or size of its parameters changes. The line
numbers do not need to be consecutive: in fact, header lines can be
inserted by using a line number value between existing line numbers.
This example shows how a header line can be inserted and later removed
in mid-report, as shown in Figure 16 <#FIGPLHDREX>.

*Figure 16. Printline Header Definition Example* <#FT_FIGPLHDREX>



PL_SET_HEADER  ID=PL,LINE=10,STRING='1  The first header line.'
PL_SET_HEADER  ID=PL,LINE=20,STRING='0  The last header line.'
      :                         :
PL_PRINT       ID=PL, ...           Print some stuff.
      :                         :
PL_SET_HEADER  ID=PL,LINE=15,STRING='0  An inserted header line.'
      :                         :
PL_PRINT       ID=PL, ...           Print some more stuff.
      :                         :
PL_RESET_HEADER  ID=PL,LINE=15



Printline requires each print line provided by its caller to contain an
ASA carriage control character as its first character. This allows the
caller to retain some control over the appearance of the report. While
Printline does not set or change carriage control characters itself, it
uses the carriage controls provided by its caller to count the number of
lines printed and remaining on the current page. The first header line
on a page should contain a carriage control character of '1', to ensure
that a page eject occurs before that line is printed.

When using PL_SET_FORMATTED_HEADER, the caller can provide a fullword
that will be treated as a /page counter/. The page number is coded as
one of the String Formatter's substitution parameters in the SOURCE=
parameter: Printline is told which parameter to use as the page counter
via the PAGENUM parameter, which provides the position of the page
number's address in the SOURCE= list, as shown in Figure 17 <#FIGPLFMTHD>.

*Figure 17. Sample Header Definition With Page Counter* <#FT_FIGPLFMTHD>



PL_SET_FORMATTED_HEADER  ID=PL,                                       +
                LINE=10,                                              +
                STRING=format_string,                                 +
                SOURCE=(todays_date,page_number),                     +
                PAGENUM=2
         :                     :
format_string  DC  C'1  Date: {CL8}       This is the report that you +
                     always wanted.                  Page: {IL4}'
todays_date    DS  CL8
page_number    DS  F



In this case, the second SOURCE parameter provides the address of the
page counter: hence, the PAGENUM parameter specifies a value of "2".
Multiple page numbers may be defined throughout the report, although
only one may be defined per header or footer line: each will be
auto-incremented as the header or footer referencing it is printed. The
page counter values should be initially set to zero, but may be modified
by the calling program at any time. These counter fields are incremented
each time they are printed: hence, they should not be referred to by
more than one header or footer definition at a time.


        Footers

Footers, if defined, will appear at the bottom of each page printed.
Footers may be used for legends, footnotes, or to provide additional
information that should appear on each page of a report. Like headers,
footer lines are defined with unique "line numbers", which determine the
order in which the footer lines are printed.

Footer lines are defined individually by the PL_SET_FOOTER and
PL_SET_FORMATTED_FOOTER functions, and removed by the PL_RESET_FOOTER
function, in much the same way as headers are defined. Unlike headers,
however, Printline needs to know how many lines to reserve as footer
space, since it needs to be able to skip to the footer area if a page
eject is forced by PL_PAGE_BREAK. The PL_RESERVE_FOOTER function will
reserve a number of lines at the bottom of a report page for footer lines.

Like headers, footers may contain page counters, which are treated the
same way as page counters in headers. Use the PL_SET_FORMATTED_FOOTER
function to define page counters in footer lines. These counter fields
are incremented each time they are printed: hence, they should not be
referred to by more than one header or footer definition at a time.


        The Body Of The Page

After any headers have been defined and the space reserved by
PL_RESERVE_FOOTER has been deducted, the space remaining on a page is
available for the body of the report. Use the PL_PRINT and
PL_PRINT_FORMATTED functions to write data lines to the report.


      Obtaining Printline Symbols & Macros <#ToC_95>

Printline's symbols and interface macros can be found in the assembler
copy member SRVPLMAC. This member contains symbols naming Printline's
load module, function codes, return codes, and parameter values. It also
contains macros for using all of the Printline's functions. The
following statement or its equivalent should appear at the beginning of
any program that uses the Printline:

   COPY SRVPLMAC      Obtain Printline's symbols & macros.


      Establishing Printline Defaults <#ToC_96>

Some parameters are general to Printline and not specific to any
function. These parameters include its load module name (/PL_epname/),
entry point address (/PL_epa/), and token value (/PL_token/). The PL_ID
macro (see ) can be used to establish defaults for these parameters and
associate them with a unique service processor identifier. The
identifier may then be supplied on any Printline macro instruction to
refer to the default parameter values.


      Identifying Printline <#ToC_97>

The Printline service processor resides in the load module named by the
following symbol definition in copy member SRVPLMAC:

&PRINT_LINE       SETC  '''SRVMVSPL  '''

This symbolic name should be used as the service processor entry point
name for Printline as shown in the following PL_ID macro instruction.

PL_ID ID=ST,SPEPNAME=&PRINT_LINE       Set Printline Defaults.


      Loading Printline <#ToC_98>

The recommended method for loading Printline is through Environment
Support's ES_LOAD_MODULE function, as shown in the following example:

ES_LOAD_MODULE ID=ES,SPID=PL            Load Printline


      Common Parameters <#ToC_99>

There are several parameters common to many Printline function calls.
These are:



*Parameter *



Description

id_name



specifies the name of a service processor identifier created by the
PL_ID macro which will be used by the PL_START macro to automatically
obtain values for /PL_epa/and /PL_token/. This parameter is required
unless both /PL_epa/and /PL_token/are specified.

PL_epname



the entry point name of the Printline service processor module that is
being used.

PL_epa



specifies the label of a fullword in storage that contains the entry
point address of an already-started Date/Time Services service
processor. The value specified by /PL_epa/overrides any value obtained
from ID=/id_name/.

PL_token



specifies the label of a fullword in storage that contains the value
returned by PL_START for the /PL_token/parameter. The value specified by
/PL_token/overrides any value obtained from ID=/id_name/.



      Return Codes <#ToC_100>

Printline may issue any of the following return codes in various
situations. Some of the return codes may be received from any call to
Date/Time Services, while others are specific to individual functions.



*Return Code *



Symbol



Description

0



PL_SUCCESS



The Printline function has completed successfully.

1



PL_INVALID_FUNCTION



Printline does not support this function code.

2



PL_INVALID_NUMBER_OF_PARMS



The Printline function received an invalid number of parameters. This
may be due to an improperly coded CALLX or PLIST macro, or the
inadvertent use of the NOVL option.

3



PL_INVALID_PL_ID



The Printline service processor detected an invalid PWA address in
PL_token.

4



PL_MEMORY_MANAGER_ERROR



An attempt to invoke the Memory Manager resulted in an error. Debug
information should be available via the ES_DISPLAY_DEBUG_INFO function.

5



PL_CANNOT_OPEN_DCB



The DDname provided by the caller could not be used to OPEN the report
file. A "DDNAME MISSING" message may accompany this error.

6



PL_ENVIRONMENT_SUPPORT_ERROR



An attempt to invoke Environment Support resulted in an error. Debug
information should be available via the ES_DISPLAY_DEBUG_INFO function.

7



PL_STRING_HANDLER_ERROR



An error was detected by the String Handler while attempting to format a
footer line for printing. Debug information should be available via the
ES_DISPLAY_DEBUG_INFO function.

8



PL_PRINT_LINE_TRUNCATED



The length of string print_string exceeded the maximum line length
specified on the PL_START macro. The portion of print_string that would
fit in the print line is printed.

9



Reserved



This return code is currently unused.

10



PL_HEADER_NOT_FOUND



The header referred to by /line_number/was not found.

11



PL_FOOTER_NOT_FOUND



The footer referred to by /line_number/was not found.

12



PL_INVALID_PAGEDISP



The /pagenum/parameter's value was greater than the number of
/source/parameters.

13



PL_INVALID_SIZELENGTH



The /sizelength/parameter is not valid. It may only be a fullword
integer between 1 and 4.

14



PL_MISSING_PARAMETER



A required parameter is missing.

15



PL_HEADER_LINE_TRUNCATED



A simple or formatted header line has exceeded MaxLineSize in length.
The un-truncated portion of the header line is printed. Note that by the
time the caller is informed of this error, several header lines may have
been printed.

16



PL_FOOTER_LINE_TRUNCATED



A simple or formatted footer line has exceeded MaxLineSize in length.
The un-truncated portion of the footer line is printed. Note that by the
time the caller is informed of this error, several footer lines may have
been printed.


------------------------------------------------------------------------


    Printline Service Processor Functions <#ToC_101>

The remaining sections of this chapter describe all functions provided
by the Printline service processor, arranged in alphabetical order. Each
function's description begins on a new page, and the name of the
function being described appears in the top outside corner of every page.

_*PL_ID - Establish Default Printline Values*_

The PL_ID macro is used to establish default values for use by other
Printline macros, which may access those values through a unique
identifier, /id_name/, specified by the user. When allowed to generate
default values, this macro will create Program Work Area (PWA) storage
for /PL_epa/and /PL_token/. These values, whether generated by the macro
or provided by the user, are accessable from all other Printline macros
via the ID=/id_name/parameter.

PL_ID ID=/id_name/
   Ý,SPEPNAME=/PL_epname/¨
   Ý,SPEPA=/PL_epa/¨
   Ý,SPTOKEN=/PL_token/¨
   Ý,ESID=/esid_name/¨
   Ý,ESVA=/esva/¨
   Ý,SIZELENGTH=/integer/¨

*Parameter *



Description

esid_name



the name of a service processor identifier, created by the ES_ID macro,
which will be used by the PL_ID macro to automatically obtain the value
for esv (see below).

esva



Specifies the label of a fullword in storage that contains (or will
contain) the address of the Environment Support Vector (ESV) created by
the ES_START function.

sizelength



An integer value from 1 and 4 that determines the size, in bytes, of all
values representing string lengths by the String Handler. For example, a
/sizelength/value of 4 would cause all lengths returned by the String
Handler to be 4 bytes in length.



*Examples *

The following PL_ID macro will associate everything required by the
Printline macros with the service processor identifier PL, as well as
establish the sizelength value for the Printline session.

    PL_ID  ID=PL,
           SPEPNAME=&PRINT_LINE,
           SPEPA=PWA_PL_ENTRY,
           SPTOKEN=PWA_PL_TOKEN,
           ESID=ES,
           ESVA=PWA_ESVA,
           SIZELENGTH=4

PWA_PL_ENTRY  DS    F         Entrypoint for Printline
PWA_PL_TOKEN  DS    F         Unique token for Printline session
PWA_ESVA      DS    F         Environment Support Vector address

_*PL_PAGE_BREAK - Force A Page Break *_

The PL_PAGE_BREAK function causes a page break to occur immediately. As
a result, footers (if any) are printed at the bottom of the page, and
the next call to PL_PRINT or PL_PRINT_FORMATTED will cause headers (if
any) to be printed.

PL_PAGE_BREAK ID=/id_name/ Ý,SPEPA=/PL_epa/¨ Ý,SPTOKEN=/PL_token/¨
CALLX /PL_epa/,(/PL_token/,&PL_PAGE_BREAK)

*Examples *

The following Printline macro forces a page break to occur.

PL_PAGE_BREAK ID=PL

_*PL_PRINT - Unformatted Print *_

The PL_PRINT function prints an unformatted data line. The data line
must have an ASA carriage control character as its first character,

PL_PRINT ID=/id_name/ Ý,SPEPA=/PL_epa/¨ Ý,SPTOKEN=/PL_token/¨
   ,STRING={/print_string/ | /(print_string,string_len)/}
CALLX /PL_epa/,(/PL_token/,&PL_PRINT,/print_string/,/string_len/)



*Parameter *



Description

print_string



Specifies a character string to be printed.

string_len



Provides the length of print_string. This operand is not required on the
PL_PRINT macro if the macro can determine the length attribute of
print_string. The /string_len/value may be coded as an integer or other
numeric term, or may refer to a field in storage of /size_length/bytes
in length, containing the string's length.



*Examples *

The following Printline macro causes an unformatted print to occur.

PL_PRINT ID=PL,STRING==C"0 This data line will be double-spaced."

_*PL_PRINT_FORMATTED - Formatted Print*_

The PL_PRINT_FORMATTED function uses the String Handler to format and
print a data line. The data line (as produced by the String Handler)
must have an ASA carriage control character as its first character.

PL_PRINT_FORMATTED ID=/id_name/ Ý,SPEPA=/PL_epa/¨ Ý,SPTOKEN=/PL_token/¨
   ,CONTROL={/format_string/ | /(format_string,string_len)/}
   ,SOURCE={/(source1,source2,...)/}
CALLX /PL_epa/,(/PL_token/,&PL_PRINT_FORMATTED,/format_string/,/string_len/
             Ý,/arguments/¨)



*Parameter *



Description

format_string



Specifies the String Handler format string.

string_len



Provides the length of format_string. This operand is not required on
the PL_PRINT_FORMATTED macro if the macro can determine the length
attribute of print_string. The /string_len/value may be coded as an
integer or other numeric term, or may refer to a field in storage of
/size_length/bytes in length, containing the string's length.

source



Specifies up to 50 substitution parameters to be processed by the String
Handler.



*Examples *

The following Printline macro requests a formatted print.

PL_PRINT_FORMATTED ID=PL,
          STRING==C"0 Line {I}   A {CL20} print line.",
          SOURCE=(LINECTR,RPTNAME)

LINECTR  DC   F'35'
SPACING  DC   CL20"double-spaced"

As a result, the following is produced:

 Line 35   A double-spaced print line.

_*PL_QUERY_LINES_LEFT - Query Remaining Lines On A Page *_

The PL_QUERY_LINES_LEFT function returns the number of lines remaining
on the current page. This is computed using the current line pointer and
the footer space reserved at the bottom of the page. Note that
PL_QUERY_LINES_LEFT will cause headers to be printed if there are no
headers yet on the current page.

PL_QUERY_LINES_LEFT ID=/id_name/ Ý,SPEPA=/PL_epa/¨ Ý,SPTOKEN=/PL_token/¨
   ,LINES=/lines_remaining/
CALLX /PL_epa/,(/PL_token/,&PL_PAGE_BREAK,/lines_remaining/)



*Parameter *



Description

lines_remaining



specifies the address of a fullword where the PL_QUERY_LINES_LEFT
function will return the number of lines remaining on the current page.

:plist. :pLt.:pLd. :eplist.

*Examples *

The following Printline macro returns the lines remaining on the current
page.

     PL_QUERY_LINES_LEFT  ID=PL,LINES=PWA_Lines_Remaining
                :
                :
PWA_Lines_Remaining  DS   F

_*PL_RESERVE_FOOTER - Reserve Footer Space *_

The PL_RESERVE_FOOTER function reserves a number of lines at the bottom
of each page for footer space. If footers are used, the value specified
via PL_RESERVE_FOOTER is used in conjunction with the pagesize parameter
of PL_START to determine when and where page footers need to be printed.

PL_RESERVE_FOOTER ID=/id_name/ Ý,SPEPA=/PL_epa/¨ Ý,SPTOKEN=/PL_token/¨
   ,LINES=/footer_space/
CALLX /PL_epa/,(/PL_token/,&PL_RESERVE_FOOTER,/footer_space/)



*Parameter *



Description

footer_space



Specifies the number of lines to be reserved at the bottom of each page
for footer space.

*Examples*

The following Printline macro requests 5 lines of footer space to be
reserved.

PL_RESERVE_FOOTER ID=PL,LINES=5

_*PL_RESET_FOOTER - Delete Footer Definitions*_

The PL_RESET_FOOTER function deletes one or all existing footer
definitions. The footers are referred to by their line number: if a line
number of zero is specified, all existing footer definitions are deleted.

PL_RESET_FOOTER ID=/id_name/ Ý,SPEPA=/PL_epa/¨ Ý,SPTOKEN=/PL_token/¨
   ,LINE=/line_number/
CALLX /PL_epa/,(/PL_token/,&PL_RESET_FOOTER,/line_number/)



*Parameter *



Description

line_number



Specifies an integer value denoting the footer line to be deleted. A
/line_number/value of zero requests all existing footer definitions to
be deleted.



*Examples *

The following Printline macro requests the footer created as line 10 to
be deleted.

PL_RESET_FOOTER ID=PL,LINE=10

This example requests all footer definitions to be deleted.

PL_RESET_FOOTER ID=PL,LINE=0

_*PL_RESET_HEADER - Delete Header Definitions *_

The PL_RESET_HEADER function deletes one or all existing header
definitions. The headers are referred to by their line number: if a line
number of zero is specified, all existing header definitions are deleted.

PL_RESET_HEADER ID=/id_name/ Ý,SPEPA=/PL_epa/¨ Ý,SPTOKEN=/PL_token/¨
   ,LINE=/line_number/
CALLX /PL_epa/,(/PL_token/,&PL_RESET_HEADER,/line_number/)



*Parameter *



Description

line_number



Specifies an integer value denoting the header line to be deleted. A
/line_number/value of zero requests all existing header definitions to
be deleted.



*Examples*

The following Printline macro requests the header created as line 10 to
be deleted.

PL_RESET_HEADER ID=PL,LINE=10

This example requests all header definitions to be deleted.

PL_RESET_HEADER ID=PL,LINE=0

_*PL_SET_FOOTER - Establish Simple Footers *_

The PL_SET_FOOTER function defines a footer line to the Printline session.

PL_SET_FOOTER ID=/id_name/ Ý,SPEPA=/PL_epa/¨ Ý,SPTOKEN=/PL_token/¨
   ,LINE=/line_number/
   ,STRING={/string_spec/ | /(string_spec,string_len)/}
CALLX /PL_epa/,(/PL_token/,&PL_SET_FOOTER,/line_number/,/string_spec/,
             /string_len/)



*Parameter *



Description

line_number



Specifies an integer value denoting this footer line's relative position
among other footer lines. Footer lines are printed in ascending line
number order. The line numbers need not be contiguous: indeed, it may be
desirable to 'insert' footer definitions under program control. If a
line number specifies an already-defined footer line, that footer line's
definition is replaced. The /line_number/parameter may be coded as an
integer or as the address of a fullword.

string_spec



Specifies the character string, including ASA carriage control, for the
footer definition. The /string_spec/may be coded as a character literal
or as the address of a character string.

string_len



Specifies the length of the footer's /string_spec/value. If
/string_len/is not specified, the PL_SET_FOOTER macro will try to use
the length attribute of /string_spec/. The /string_len/value may be
coded as an integer or other numeric term, or may refer to a field in
storage of /size_length/bytes in length, containing the string's length.

*Examples *

The following example will define a simple footer line. Since the first
character of the footer string is a '0', this footer line will always be
double-spaced (i.e. preceded by a blank line). The footer's line number
is set to 10, for subsequent reference by other PL_SET_FOOTER,
PL_SET_FORMATTED_FOOTER, and PL_RESET_FOOTER macros.

PL_SET_FOOTER ID=PL,
          LINE=10,
          STRING==C"0 This footer line causes a double-space to occur."

_*PL_SET_FORMATTED_FOOTER - Establish Formatted Footers *_

The PL_SET_FORMATTED_FOOTER function defines a footer line to the
Printline session. The footer line will be formatted by the String
Handler before it is printed, thus allowing variable data to be included
in report footers.

PL_SET_FORMATTED_FOOTER ID=/id_name/ Ý,SPEPA=/PL_epa/¨ Ý,SPTOKEN=/PL_token/¨
   ,LINE=/line_number/
   ,CONTROL={/format_spec/ | /(fmtspec,fmtlen)/}
   Ý,PAGENUM=/page_offset/¨
   Ý,SOURCE={/source/ | /(source1,source2,...)/}¨
CALLX /PL_epa/,(/PL_token/,&PL_SET_FORMATTED_FOOTER,/line_number/,/format_spec/,
             /format_length/,{/pagedisp/,/arguments/})



*Parameter *



Description

line_number



Specifies an integer value denoting this footer line's relative position
among other footer lines. Footer lines are printed in ascending line
number order. The line numbers need not be contiguous: indeed, it may be
desirable to 'insert' footer definitions under program control. If a
line number specifies an already-defined footer line, that footer line's
definition is replaced. The /line_number/parameter may be coded as an
integer or as the address of a fullword.

format_spec



Specifies a format specification string, including ASA carriage control,
for the footer definition. The /format_spec/may be coded as a character
literal or as the address of a character string.

format_length



Specifies the length of the footer's /format_spec/value. If
/format_length/is not specified, the PL_SET_FORMATTED_FOOTER macro will
try to use the length attribute of /format_spec/. The
/format_length/value may be coded as an integer or other numeric term,
or may refer to a field in storage of /size_length/bytes in length,
containing the string's length.

page_disp



Specifies the displacement into the list of /source/parameters where the
Printline service processor will find a page number. For example, a
/page_disp/value of "3" tells Printline that the third /source/parameter
should be treated as a page number. Page numbers defined in this way are
auto-incremented by Printline as page ejects occur.

source



Specifies source values for the String Handler to substitute into the
format specification provided by /format_spec/Up to 50 substitution
values may be specified.



*Examples *

The following Printline macro will establish a formatted footer line.
The definition includes a page number (fullword "PAGECTR") which will be
formatted as the first substitution parameter in the format string. The
PAGECTR field is also auto-incremented at each page eject.

PL_SET_FORMATTED_FOOTER ID=PL,
              LINE=10,
              CONTROL=FORMAT,
              PAGENUM=1,
              SOURCE=(PAGECTR,RPTNAME)

PAGECTR  DC   F'0'
RPTNAME  DC   CL20"Macneil-Lehrer"
FORMAT   DC   C"0 Page {I}   The {CL20} Report."

The resulting string is printed as part of each subsequent page's footer:

  Page 1     The MacNeil-Lehrer Report.

Because of the carriage control of '0', this footer line will always be
preceded by a blank line.

_*PL_SET_FORMATTED_HEADER - Establish Formatted Headers*_

The PL_SET_FORMATTED_HEADER function defines a header line to the
Printline session. The header line will be formatted by the String
Handler before it is printed, thus allowing variable data to be included
in report headers.

PL_SET_FORMATTED_HEADER ID=/id_name/ Ý,SPEPA=/PL_epa/¨ Ý,SPTOKEN=/PL_token/¨
   ,LINE=/line_number/
   ,CONTROL={/format_spec/ | /(fmtspec,fmtlen)/}
   Ý,PAGENUM=/page_offset/¨
   Ý,SOURCE={/source | (source1,source2,...)}¨/
CALLX PL_epa,(PL_token,&PL_SET_FORMATTED_HEADER,line_number,
             format_spec,format_length,{pagedisp,arguments})



*Parameter *



Description

line_number



Specifies an integer value denoting this header line's relative position
among other header lines. Header lines are printed in ascending line
number order. The line numbers need not be contiguous: indeed, it may be
desirable to 'insert' header definitions under program control. If a
line number specifies an already-defined header line, that header line's
definition is replaced. The line_number parameter may be coded as an
integer or as the address of a fullword.

format_spec



Specifies a format specification string, including ASA carriage control,
for the header definition. The format_spec may be coded as a character
literal or as the address of a character string.

format_length



Specifies the length of the header's format_spec value. If format_length
is not specified, the PL_SET_FORMATTED_HEADER macro will try to use the
length attribute of format_spec. The format_length value may be coded as
an integer or other numeric term, or may refer to a field in storage of
size_length bytes in length, containing the string's length.

page_disp



Specifies the displacement into the list of source parameters where the
Printline service processor will find a page number. For example, a
page_disp value of "3" tells Printline that the third source parameter
should be treated as a page number. Page numbers defined in this way are
auto-incremented by Printline as page ejects occur.

source



Specifies source values for the String Handler to substitute into the
format specification provided by format_spec Up to 50 substitution
values may be specified.

*Examples *

The following Printline macro will establish a formatted header line.
The definition includes a page number (fullword "PAGECTR") which will be
formatted as the first substitution parameter in the format string. The
PAGECTR field is also auto-incremented at each page eject.

PL_SET_FORMATTED_HEADER ID=PL,
              LINE=10,
              control=FORMAT,
              PAGENUM=1,
              SOURCE=(PAGECTR,RPTNAME)

PAGECTR  DC   F'0'
RPTNAME  DC   CL20"Macneil-Lehrer"
FORMAT   DC   C"1 Page {I}   The {CL20} Report."

The resulting string is printed as part of each subsequent page's header:

  Page 1     The MacNeil-Lehrer Report.

Because of the carriage control of '1', this header line will always be
printed at the top of a new page.

_*PL_SET_HEADER - Establish Simple Headers *_

The PL_SET_HEADER function defines a header line to the Printline session.

PL_SET_HEADER ID=id_name Ý,SPEPA=PL_epa¨ Ý,SPTOKEN=PL_token¨
   ,LINE=line_number
   ,STRING={string_spec | (string_spec,string_len)}
CALLX PL_epa,(PL_token,&PL_SET_HEADER,line_number,string_spec,
              string_len)



*Parameter *



Description

line_number



Specifies an integer value denoting this header line's relative position
among other header lines. Header lines are printed in ascending line
number order. The line numbers need not be contiguous: indeed, it may be
desirable to 'insert' header definitions under program control. If a
line number specifies an already-defined header line, that header line's
definition is replaced. The line_number parameter may be coded as an
integer or as the address of a fullword.

string_spec



Specifies the character string, including ASA carriage control, for the
header definition. The string_spec may be coded as a character literal
or as the address of a character string.

string_len



Specifies the length of the header's string_spec value. If string_len is
not specified, the PL_SET_HEADER macro will try to use the length
attribute of string_spec. The string_len value may be coded as an
integer or other numeric term, or may refer to a field in storage of
size_length bytes in length, containing the string's length.



*Examples *

The following example will define a simple header line. Since the first
character of the header string is a '1', this header line will always
cause a page eject. The header's line number is set to 10, for
subsequent reference by other PL_SET_HEADER, PL_SET_FORMATTED_HEADER,
and PL_RESET_HEADER macros.

PL_SET_HEADER ID=PL,
              LINE=10,
              STRING==C"1 This header line causes a page eject."

_*PL_START - Begin A Printline Session *_

The PL_START function establishes a new Printline session and returns
its session identifier in the pl_token parameter. The page size, maximum
line length and size of fields specifying string lengths are determined
by the pagesize, maxlinesize and sizelength operands, respectively.

PL_START ID=id_name Ý,SPEPA=PL_epa¨ Ý,SPTOKEN=PL_token¨
   Ý,ESVA=esva¨
   ,DDNAME=ddname
   Ý,PAGESIZE={pagesize | *66*}¨
   Ý,MAXLNSZ={maximum_linesize | *133*}¨
   Ý,SIZELENGTH={integer | *2*}¨
   Ý,OPTIONS=(option_list)¨
CALLX PL_epa,(PL_token,&PL_START,esva,ddname,pagesize,maxlinesize,
              sizelength,option_byte)



*Parameter *



Description

esva



Specifies the label of a fullword in storage that contains the address
of the Environment Support Vector (ESV) created by the ES_START function.

ddname



Specifies the DDname that this Printline session will use to write its
output. The default DCB attributes are RECFM=VBA,LRECL=maxlinesize,
BLKSIZE=LRECL+4; however, any DCB attribute combination acceptable to
the OS File Handler is acceptable to Printline.

pagesize



Specifies the number of lines that the report page should contain. This
value is used to determine when Printline should print headers and
footers, as well as increment page counters.

maxlinesize



Specifies a field containing the maximum linesize that Printline should
write. This value will become the logical record length of the report
file produced. Should a data, header or footer line's length exceed the
maxlinesize value, the line will be truncated and printed, and a
truncation error will be returned.

sizelength



An integer value from 1 and 4 that determines the size, in bytes, of all
values representing string lengths by the String Handler. For example, a
sizelength value of 4 would cause all lengths returned by the String
Handler to be 4 bytes in length.

option_list



A list of additional options for this PrintLine session. If multiple
option values are specified, they must be enclosed in parentheses. The
only option currently supported is FOLD.

  *

    *FOLD*- All output produced by PrintLine should be folded to
    uppercase. If using the CALLX form to call PL_START, the FOLD option
    corresponds to a bit setting of X'80' in the option byte.



*Examples*

The following PL_START macro will initialize a Printline session.
Invoking PL_START will cause the following to occur:

  *

    The SPTOKEN value is set to the new Printline session's unique token
    value.

  *

    Blocksize information from the DD statement referred to by ddname is
    merged into Printline's report DCB.

  *

    The report file referred to by ddname is opened.

  *

    All headers, footers and data lines are to be converted to uppercase.

    PL_START ID=PL,
             SPEPNAME=&PRINT_LINE,
             SPEPA=PWA_PL_ENTRY,
             SPTOKEN=PWA_PL_TOKEN,
             ESID=ES,
             ESVA=PWA_ESVA,
             SIZELENGTH=4,
             DDNAME==C'SYSPRINT',
             OPTIONS=(FOLD)

PWA_PL_ENTRY  DS    F         Entrypoint for Printline
PWA_PL_TOKEN  DS    F         Unique token for Printline session
PWA_ESVA      DS    F         Environment Support Vector address

In this example, the SPEPNAME, SPEPA, SPTOKEN, ESID, ESVA and SIZELENGTH
parameters are included only for completeness. They may be specified on
the PL_ID macro and omitted from the call to PL_START, as follows:

    PL_START ID=PL,
             DDNAME==C'SYSPRINT'

_*PL_TERMINATE - Terminate A Printline Session *_

The PL_TERMINATE function concludes the Printline session identified by
the pl_token parameter, and releases any resources held by the Printline
service processor.

PL_TERMINATE ID=id_name Ý,SPEPA=PL_epa¨ Ý,SPTOKEN=PL_token¨
CALLX PL_epa,(PL_token,&PL_TERMINATE)

*Examples *

The following PL_TERMINATE macro will cause Printline to close its
report file and release any resources that it acquired.

PL_TERMINATE ID=PL

------------------------------------------------------------------------


  Chapter 12. String Handler <#ToC_102>

The String Handler provides common functions for string manipulation,
including formatting functions and data conversions.

Applications use the string handler to convert back and forth between
textual and non-textual representations of data, and to manipulate text
strings. The most heavily used function of the string handler is the
ST_FORMAT function, which can construct a text string from an arbitrary
number of (text and non-text) parameters. ST_FORMAT is extremely useful
for constructing error messages that contain imbedded information.

------------------------------------------------------------------------


    Preparing to Use the String Handler <#ToC_103>

The String Handler operates independently of its execution environment
and may be used with any Environment Support service processor. Like any
service processor, the String Handler must be loaded and started before
its functions can be used. This process is fully covered in Part 1,
"Service Processors User's Guide" <#HDRPART1> and will not be repeated
here.

The String Handler's service processor identification code is *ST*so:

  *

    the COPY member is SRV*ST*MAC,

  *

    the load module, named by symbol &ST_STRING_HANDLER, is SRV*ST*,

  *

    and the names of all symbols, macros, and conditions begin with the
    prefix *ST_*.

Global String Handler stuff goes here as well as tips on how to make
better use of it.

------------------------------------------------------------------------


    Common Parameters <#ToC_104>

Several parameters are common to all String Handler function calls.
These parameters are listed below: :plist. :pLt.id_name :pLd.specifies
the name of a service processor identifier created by the ST_ID macro
which will be used by all other function invocation macros to
automatically obtain values for st_epa and st_token. This parameter is
required unless both st_epa and st_token are specified. :pLt.st_epa
:pLd.a fullword in storage containing the entry point address of the
String Handler service processor. The value specified by st_epa
overrides any value obtained from ID=id_name. :pLt.st_token
:pLd.specifies the label of a fullword in storage that contains the
value (to be) returned by ST_START for the st_token parameter. The value
specified by st_token overrides any value obtained from ID=id_name.
:eplist.

------------------------------------------------------------------------


    Complete List of String Handler Return Codes <#ToC_105>

Many return codes can be returned from each function. In the function
descriptions later in this chapter, the most common return codes
returned by the particular function are documented. The following is a
complete list of String Handler return codes.



*Return Code *



Symbol



Description

0



ST_SUCCESS



The invoked String Handler function performed the requested service
without encountering any problems.

1



ST_INVALID_FUNCTION



An invalid FunctionCode (the second parameter in any service processor
function call) was specified.

2



ST_INVALID_SIZELENGTH



The value specified for sizelength was not *1*, *2*, *3*, or *4*.

3



ST_TRUNCATED



The formatted string was too long to fit into the area specified by
string and the only the first string_length characters were used.
Result_length has been set to the length of the truncated result and is
equal to string_length.

4



ST_OVERLAP



The area referenced by string overlaps in storage with the control
string or a source argument. Results are unpredictable because the
overlap could be detected at any point in the formatting process.
Formatting was halted immediately and result_length has been set to the
length of the formatted string up to the point of error.

5



ST_INTERNAL_ERROR



The String Handler detected an error during an internal consistancy
check. This is likely a problem with the String Handler itself and not
the program that called it.

6



ST_WRONG_NUMBER_OF_ PARAMETERS



The ST_FORMAT function has seven (7) required parameters, and
ST_FORMAT2has nine (9) required parameters. Less than the required
number of parameters were coded.

7



ST_INVALID_SOURCE_LENGTH



The length of a source argument, as specified with the format specifier
*L*/length/was outside the supported range of lengths for that
argument's type. See for more information.

8



ST_INVALID_SOURCE_FORMAT



The text in /string/does not conform to the required format, and could
not be converted to an integer.

9



ST_MAGNITUDE



ST_FORMAT: the length of a source argument, as specified with the format
specifier *L*/length/was too large to represent as a fullword signed
binary integer.


ST_STRING_TO_INTEGER: the value represented by the digits in /string/is
too large to be contained in a fullword binary value. It must be between
-2147483648 and 2147483647.

10



ST_FORMAT_COLUMN_TOO_LARGE



The specified column position was beyond the end of the area referenced
by /string/. That is, it was larger than the value of /string_length/.

11



ST_FORMAT_COLUMN_TOO_SMALL



The specified column position was negative.

12



ST_FORMAT_LENGTH_TOO_LARGE



The length specified in a format specification was larger than the
maximum allowed length for that type.

13



ST_FORMAT_LENGTH_TOO_SMALL



The length specified in a format specification was smaller than the
minimum allowed length for that type.

14



ST_FORMAT_PRECISION_ TOO_SMALL



The precision specified in a format specification was negative or zero.
It must be positive.

15



ST_FORMAT_MISSING_ARGUMENT



The format specifications in the control string referenced more
/arguments/than were present.

16



ST_FORMAT_MISSING_ COLUMN_VALUE



A format specification contained a relative column (@+ or @-), with no
column number or question mark.

17



ST_FORMAT_MISSING_ LENGTH_VALUE



A format specification contained the *L*of the *L*/length/item, but the
/length/part (an integer or question mark) was not specified.

18



ST_FORMAT_MISSING_ PRECISION_VALUE



A format specification contained the *.*of the *.*/precision/item, but
the /precision/part (an integer or question mark) was not specified.

19



ST_FORMAT_TYPE_REQUIRED



A format specification contained one or more items associated with the
/type/item, but no /type/was specified.

20



ST_FORMAT_SPEC_EMPTY



A format specification contained no items within the enclosing braces.

21



ST_FORMAT_SPEC_NOT_ENDED



The closing brace was not present for a format specification. Check the
/control_length/parameter to insure that it was correct.

22



ST_FORMAT_UNSUPPORTED_ KEYWORD



A keyword was specified that is not in Table 8 <#TBLFSKWDS>.

23



ST_FORMAT_UNSUPPORTED_TYPE



A /type/was specified that is not in Table 6 <#TBLFSTCDS>.

24



ST_FORMAT_UNSUPPORTED_ITEM



An item was specified that did not conform to the syntax for format
specifications described on page reference #3 <#SPTFSSYNTX>.

25



ST_FORMAT_PAD_TYPE_CONFLICT



A leading zero was specified with /width/, but the /type/item specified
a non-numeric /argument/.

26



ST_FORMAT_FILL_TOO_LONG



The fill pattern supplied within an ST_FORMAT format-specification was
longer than 256 characters, the maximum length permitted for fill patterns.


------------------------------------------------------------------------


    String Handler Service Processor Functions <#ToC_106>

The remaining sections of this chapter describe all functions provided
by the String Handler service processor, arranged in alphabetical order.
Each function's description begins on a new page, and the name of the
function being described appears in the top outside corner of every
page. :func id=stfrmt name='ST_FORMAT'.Build a Text String from
Arbitrary Parameters

The ST_FORMAT function constructs a formatted string from an arbitrary
number of input sources and places it in the area specified by the
/string/parameter. A control string, consisting of ordinary text and
imbedded /format specifications/, is used to guide the formatting
process. The resulting string will appear similar to the control string,
except that the format specifications will be replaced with the data
they indicate.

This function is most useful for formatting messages. Contextual
information can easily be included in a message to assist the user in
diagnosing and correcting problems. Consider the following message,
which is produced by the FI_START function of the File Handler:

/(Ref #2.)/
'FI00104E Member {CL8} not in {CL? TRIM}.',MEMBER,DSNAME,DSNAME_LENGTH

When the File Handler invokes ST_FORMAT, the member name and dataset
name will be inserted into the message text itself to produce a
formatted message such as the following:

'FI00104E Member LABELS not in HENRY.ISPF.SOURCE.'
ST_FORMAT ID=/id_name/ Ý,SPEPA=/st_epa/¨ Ý,SPTOKEN=/st_token/¨
   ,CONTROL={/control/ | (/control/,/control_length/)}
  Ý,SOURCE=(/argument/{,/argument/}) | SOURCELIST=(/arglist/,/argcount/)¨
  Ý,STRING={/string/ | (/string/,/string_length/)}¨
  Ý,RESULTLEN=/result_length/¨
CALLX /st_epa/,(/st_token/,&ST_FORMAT,/string/,/string_length/,
              Ý/result_length/¨,
              /control/,/control_length/{,/argument/})
- or -
CALLX /st_epa/,(/st_token/,&ST_FORMAT2,/string/,/string_length/,
              Ý/result_length/¨,
              /control/,/control_length/,/arglist/,/argcount/)



*Parameter *



Description

control



specifies the label of a string containing information to guide the
formatting process. See the section below, , for how this string should
be specified.

control_length



specifies the label of a signed binary integer indicating the length of
the string identified by the /control/parameter. The
/control_length/parameter may be from one to four bytes in length, as
determined by the /sizelength/parameter of the ST_START function.


*Note: *The macro form of ST_FORMAT will attempt to generate a value for
/control_length/automatically if it is not specified. In order to
generate the right value, however, /sizelength/must have previously been
specified on the ST_ID macro.

string



specifies the area of storage in which the formatted string will be
constructed.

string_length



specifies the label of a signed binary integer indicating the length of
the area referenced by /string/. This parameter may be from one to four
bytes in length, as determined by the /sizelength/parameter of the
ST_START function.


*Note: *The macro form of ST_FORMAT will attempt to generate a value for
/string_length/automatically if it is not specified. In order to
generate the right value, however, /sizelength/must have previously been
specified on the ST_ID macro.

result_length



specifies a field into which a signed binary integer containing the
length of the formatted string will be placed. The
/result_length/parameter may be from one to four bytes in length, as
determined by the /sizelength/parameter of the ST_START function.

{argument}



Values in storage that are referenced by format specifications imbedded
in the /control/string. The number of /argument/s required, as well as
their data formats, is determined by the format specifications imbedded
in the control string.

arglist



References a separate parameter list that contains the /argument/s
referenced by format specifications. This parameter requires the
/argcount/parameter also, and is only used with the ST_FORMAT2 interface
to the format function. :pLt.argcount :pLd.Specifies a signed fullword
in storage containing the number of /argument/s contained in /arglist/.



*Specifying Control Strings *

The /control/parameter is a character string consisting of normal text
intermixed with /format specifications/that acts as a template to guide
the formatting process. The control string below, for example, contains
two format specifications:

'FI00104E Member {CL8} not in {CL? TRIM}.'

As ST_FORMAT scans /control/from left to right, it builds a formatted
string in the area referenced by the /string/parameter. Normal text is
copied directly to the /string/area. When a format specification is
encountered, ST_FORMAT suspends the copying of normal text and performs
the operation indicated by the format specification. It then resumes its
scan of the control string following the format specification.

Each format specification may call for values to be taken from one or
more /argument/s, which are always referenced in consecutive order:
first, second, third, etc. The value of an /argument/is never modified
by ST_FORMAT, although a formatted copy of that value may be placed in
/string/. A format specification is distinguished from surrounding text
in the /control/string with braces (*{ }*) and has one of the following
forms, where brackets (Ý ¨) indicate optional items. /(Ref #3.)/

    *{*Ý*0*¨Ý/width/¨Ý*.*/precision/¨Ý*@*Ý/column/¨¨/type/Ý*L*/length/¨Ý
    /keyword.../¨*}*
    *{@*Ý/column/¨*}*
    *{{*

In the syntax above, /type/is a single letter that references an
associated source /argument/, and Ý/keyword.../¨ is a list of words that
provide optional formatting information.

/Arguments/are taken in the same order as the items in a format
specification that reference them (i.e. /width/first, then /precision/,
/column/, /type/, and /length/).

/Width/, /precision/, /column/, and /length/are all integers that can be
coded as either a sequence of digits or as a question mark (*?*) to
reference the value contained in an associated /argument/. When a
question mark is used, the referenced /argument/must be a signed binary
integer that is /sizelength/bytes in length (see the
/sizelength/parameter of ST_START on page reference #5 <#SPTSIZELEN>).
Optionally, /sizelength/can be overridden for a given /argument/by
suffixing the question mark with an integer value of 1, 2, 3, or 4. For
example, {CL?2} indicates that the length /argument/is a halfword value
(the 2 following the question mark) regardless of the value originally
specified for /sizelength/. The override applies only to the one
/argument/--it does not change the /sizelength/parameter's value.

No blanks can appear within a format specification, except between
keywords. If any part of a format specification is invalid, the length
of the text formatted so far will be returned in /result_length/and a
return code indicating the problem will be set. The discussion below
covers the basics of format specifications and describes the general
operation of ST_FORMAT with respect to the control string. :fh4.Type

In practice, most format specifications are fairly simple because almost
everything is optional (as indicated by all the brackets). In fact, the
large majority contain only /type/and perhaps one other item. As a
general rule, format specifications are built around /type/, with the
remaining items being used to supply additional information.

/Type/is a single letter that denotes both a source argument's layout
and the way it should be formatted. The presence of /type/in a format
specification indicates that there is an associated /argument/that
should be formatted in a certain way, and that the format specification
itself is acting as a placeholder to indicate the where the formatted
text should be placed within /string/. For example, the control string

'The character {C} was encountered {I} times.'

contains two format specifications, each of which only specifies /type/.
This control string requires two associated /argument/s, one for each
format specification. The format specification {C} indicates that a
single character should be taken from the first /argument/and placed in
/string/following 'The character '. Similarly, {I} indicates that a
textual representation of the four byte binary integer referenced by the
second /argument/should placed in /string/following ' was encountered '.
The resulting string would look like this:

'The character Z was encountered 437 times.'

The supported values for /type/are listed below. The default, minimum,
and maximum lengths for /argument/s of each type are listed in Table 7
<#TBLFSLNS>.

*Table 6. Format Specification Types*

Type



Description

A



Format an unsigned binary integer as a hexadecimal number. For example,
if a four byte integer containing the decimal value 2375373 were
formatted with this type, it would appear as 243ECD.

B



Format one or more characters (arbitrary byte values) as a sequence of
binary digits. Example: the EBCDIC character 'A' would format as
11000001 (hexadecimal 'C1').

C



Format one or more characters (arbitrary byte values) asis. That is, the
character(s) referenced by the associated /argument/ should be copied
without modification to the appropriate position in /string/.

I



Format a signed binary integer as a decimal number. Example: -32768.

U



Format an unsigned binary integer as a decimal number. Example: 65535.

X



Format one or more characters (arbitrary byte values) as a sequence of
hexadecimal digits. Example: the EBCDIC character 'A' would format as C1
(binary 11000001).



Each /argument/referenced by /type/has a default length. For example,
integers referenced with the format specification {I} are assumed to be
four bytes in length. Explicit lengths can be specified in format
specifications with the *L*/length/item. For example, the format
specification {IL2} references a two byte signed integer.

/Length/may be specified with a number coded directly in the format
specification or, if the actual length is not known until execution
time, as a question mark (*?*) to indicate that length of the
/argument/to be formatted is contained in yet another /argument/. For
example, suppose a word of some unknown length was desired instead of a
single character and the number of occurrances was held in a two byte
value. The new control string would look like the following:

'The word {CL?} was encountered {IL2} times.'

and would produce a result that looked like:

'The word SUPERCALAFRAGALISTIC was encountered 138 times.'

This control string would require /three/arguments: one for the
character string to insert, one for its length, and one for the number.
The arguments would have to be specified in that order, and the size of
the integer containing the word's length would be determined by the
/sizelength/parameter of the ST_START function.

Each type of data has minimum, maximum, and default source lengths
(specified in bytes):

*Table 7. Format Specification Source Lengths*

Type



Default



Minimum



Maximum

A



4



1



4

B



1



1



256

C



1



0



65535

I



4



1



4

U



4



1



4

X



1



0



65535



/Width/is used to specify the minimum amount of space that should be
reserved in /string/for formatted text. More space will be used if
needed, but if the text is shorter than /width/, it will be padded with
blanks (to the right for character types and to the left for numeric
types). Like /length/, /width/may be specified as a number or a question
mark. Expanding on the example used so far, the following control string
might be used:

'The word {15CL?} was encountered {5IL2} times.'

which, if used several times with different values, would produce
results that looked like:

'The word SUPERCALAFRAGALISTIC was encountered   138 times.'
'The word HELLO           was encountered    27 times.'
'The word GOODBYE         was encountered    14 times.'
'The word CALIFORNIA      was encountered     0 times.'

An additional feature of /width/is available for numeric data types
only: if a /width/is coded with a leading zero, the number will be
formatted with leading zeros. For example, the control string

'The word {15CL?} was encountered {05IL2} times.'

would produce these results instead:

'The word SUPERCALAFRAGALISTIC was encountered 00138 times.'
'The word HELLO           was encountered 00027 times.'
'The word GOODBYE         was encountered 00014 times.'
'The word CALIFORNIA      was encountered 00000 times.'

*Precision*

*.*/Precision/can also be specified as a number or a question mark, but
has a different meaning than /width/. For non-numeric data,
/precision/specifies the /maximum/amount of space that the formatted
text may use; if the text is longer, only the first
/precision/characters will be placed in /string/. In the example above,
if a /precision/of 15 were added to the first format specification:

'The word {15.15CL?} was encountered {05IL2} times.'

it would have produced

'The word SUPERCALAFRAGAL was encountered 00138 times.'
'The word HELLO           was encountered 00027 times.'
'The word GOODBYE         was encountered 00014 times.'
'The word CALIFORNIA      was encountered 00000 times.'

*.*/Precision/currently has no meaning for numeric data, but when real
numbers (fixed point or floating point) are supported, it will specify
the number of significant digits to the right of the decimal mark.

*Column *

During the process of formatting, ST_FORMAT maintains a pointer to the
current column position within /string/. This column position, denoted
by the symbol *@*, is initially set to 1. Whenever text (from the
control string itself or from a formatting operation) is added to
/string/it is placed in the position indicated by *@*. After the text
has been added, *@*is automatically updated to the column in
/string/immediately following the new text. This automatic operation
produces the expected results: the resulting string looks like the
original control string except that format specifications (acting as
placeholders) have been replaced with formatted text. The column
position can also be adjusted with format specifications, giving
application programs the ability to control the exact placement of text
within the formatted string.

*@*Ý/Column/¨ sets the value of *@*to a new column position, which can
be anywhere in the /string/area (even beyond the end of all text
formatted so far). It may be specified alone or as part of a format
specification containing /type/. In both cases, the value of *@*is set
before any text movement occurs. The new position specified by
/column/can be an actual column number, or it can be a question mark
that indicates the value for column is contained in an /argument/.
Either way, the number or question mark can be prefixed by a plus (*+*)
or minus (*-*) sign to indicate that the new column is relative to the
current one.

ST_FORMAT also maintains a /high-water/mark, which is always equal to
the highest column position reached during formatting. If *@*is
specified without a column number the current position is set to the
high-water mark, where new text will be appended to the string being
formatted.

When formatting is complete, ST_FORMAT reduces the high-water mark by
one column to produce /result_length/. This final value is normally
equal to the column position of the last character placed in /string/and
is considered to be the final length of the formatted text. However,
since format specifications can jump to any column position, portions of
the /string/area may have been skipped over and left untouched by
ST_FORMAT This is the way ST_FORMAT was designed to work, but it may
produce unexpected results if uninitialized portions of /string/are
skipped over during formatting. :fh4.Keywords

/Keyword/s are used to specify formatting options that cannot really be
specified any other way. The control string below, for example, contains
a format specifcation that uses the keywords CAPS and CENTER to place
text in the center of a line that will be printed as a page header.

'{?CL? CAPS CENTER}'

If ST_FORMAT were invoked with this control string and the three
arguments (80,'Year to Date Totals',19), the following line would result:

                           YEAR TO DATE TOTALS

The available keywords are listed in Table 8 <#TBLFSKWDS> below. Some of
these keywords can only be used with specific /type/s, as indicated in
their description.

*Table 8. Format Specification Keywords*

Keyword



Description

CAPS



Fold lowercase letters to capitals. This keyword only applies to type *C*.

C1ST



Capitalize the first letter of the formatted argument. This keyword only
applies to type *C*.

CENTER



Center the formatted argument in the field, padding it to the left and
right with blanks.

FILL or F



When the formatted argument does not extend to the end of the format
field, format the remainder of the field using a fill pattern.

Zero or more copies of the fill pattern are concatenated and placed such
that the result ends at the final position of the format field. If the
space to be filled is not an exact multple of the size of the fill
pattern, one or more blanks will be used /before/ filling to make up the
remainder. The default fill pattern is " .". Fill patterns may be
specified in parenthesis following the FILL keyword as:

  *

    A string enclosed in quotes, optionally prefixed with *C*. Either
    single or double quotes may be used to delimit string, so long as
    they are matched properly. If a quote of the same type as the
    delimiter is used within the string, two quotes must be used to
    represent one. Examples: F(" -") and FILL(C' -').

  *

    A hexadecimal string. Examples: FILL(X"4060"), F(X"00"), and F(X'9F').

  *

    A question mark (referencing the next supplied argument), optionally
    followed by *L* and a length (either an integer or a question mark
    to refer to the argument following the fill pattern argument). If no
    length is supplied, the default length is one. Examples: F(?),
    FILL(?L2), and FILL(?L?).

  *

    If the supplied fill pattern does not fit any of the above types,
    the entire sequence of characters between parentheses will be
    assumed to be the intended fill pattern. Examples: FILL( .) and F( -).

The maximum length for a fill pattern from any source is 256 bytes. A
zero-length fill pattern is replaced by the default: " .".

LEFT



Left-justify the formatted argument in the field, padding it with blanks
if necessary in order to fill in the field.

RELATIVE



For integers only: append the resulting formatted integer with the
characters *st*, *nd*, *rd*, or *th* to indicate a relative number (e.g.
1st, 2nd, 3rd, 4th, etc).

RIGHT



Right-justify the formatted argument in the field, prefixing it with
blanks or zeros if necessary in order to fill in the field.

TRIM or T



Remove trailing blanks from the formatted data before performing any
justification. This keyword only applies to type *C*.

Since braces are used to distinguish format specifications from
surrounding text, an opening brace cannot be coded as part of the normal
text. The format specification *{{*provides a way around this problem:
it is treated as if it were a single *&lbr*in normal text. For example,
the control string

This is a control string containing {{ braces }.

would result in the following formatted string:

This is a control string containing { braces }.

*Examples *

The examples below are all coded using the macro interface to the
ST_FORMAT function. They assume that instructions similar to the
following have been executed to provide default values for the STRING,
RESULTLEN, and SIZELENGTH keywords.

ES_ID ID=ES,SPEPNAME=&ES_MVS_ENVIRONMENT_SUPPORT
      ST_ID ID=ST,SPEPNAME=&STRING_HANDLER,STRING=LINE,            +
            RESULTLEN=LINE_LEN,SIZELENGTH=2
*
      ES_MVS_LOAD    ID=ES               Load Environment Support.
      ES_START       ID=ES               Start Environment Support.
      ES_LOAD_MODULE ID=ES,SPID=ST       Load the String Handler.
      ST_START       ID=ST               Start the String Handler.
*
       *...... ST_FORMAT examples go here ..... *
*
            PWA
LINE_LEN    DS    F                Length of string within LINE.
LINE        DS    CL80             String returned by ST_FORMAT.
            ENDPWA

Translated to call statements, each of the formatting examples would
look something like this:

CALL ST_EPA,(ST_TOKEN,&ST_FORMAT,LINE,=AL2(L'LINE),LINE_LEN, ... )

/*Example 1: */  This example uses the address (A) type to display a
dump of the current (or saved) contents of all sixteen general registers.

 STM                R0,R15,REGS    Save all registers in storage.
 ST_FORMAT          ID=ST,CONTROL=REG_LIST,SOURCE=('REGS',0,7,REGS)
 ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)
 ST_FORMAT          ID=ST,CONTROL=REG_LIST,SOURCE=('    ',8,15,REGS+(7*4))
 ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)
 .
 .
 .
REGS      DS  16F          <--- Registers 0-15 saved here.
REG_LIST  DC C'{CL4} {1A}-{1A}: {08A} {08A} {08A} {08A} {08A} {08A} {08A} {08A}'

would produce output that looks like the following:

REGS 0-7:0000DEB4 0000002C 0000DEB4 0000002C 00000018 007D5540 02729FEC
     8-F:0000DED8 0000002C 0272EDE4 0000DE8C 0272DDF8 00011818 8272EE20 0272EDE4

/*Example 2: */  This example uses the FILL keyword to demonstrate how a
report might use fill patterns to assist in lining up values to names.
The three ST_FORMAT statements below:

 ST_FORMAT  ID=ST,CONTROL=LINE_CONTROL,
                  SOURCE=('NAME',4,PWA_NAME,=A(L'PWA_NAME))
 ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)
 ST_FORMAT  ID=ST,CONTROL='{25CL? FILL(C" .")} {CL?}',
                  SOURCE=('STREET ADDR',11,PWA_STREET,=A(L'PWA_STREET))
 ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)
 ST_FORMAT  ID=ST,CONTROL='{25CL? FILL(C" .")} {CL?}',
                  SOURCE=('CITY & STATE',12,PWA_CITYST,=A(L'PWA_CITYST))
 ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(LINE,LINE_LEN)
 .
 .
 .
LINE_CONTROL  DC  C'{25CL? FILL(C" .")} {CL?}'

might produce the lines:

NAME  . . . . . . . . . . Donald Duck
STREET ADDR . . . . . . . 132 Mallard Lane
CITY & STATE  . . . . . . Drake City, D.Q.

_*ST_ID - Establish Default String Handler Values *_

The ST_ID macro is used to establish default values for use by other
String Handler macros, which may access those values through a unique
identifier, /id_name/, specified by the user. When allowed to generate
default values, this macro will create Program Work Area (PWA) storage
for /st_epa/and /st_token/. These values, whether generated by the macro
or provided by the user, are accessable from all other String Handler
macros via the ID=/id_name/parameter.

ST_ID ID=/id_name/
  Ý,SPEPNAME=/st_epname/¨
  Ý,SPEPA=/st_epa/¨
  Ý,SPTOKEN=/st_token/¨
  Ý,ESID=/esid_name/¨
  Ý,ESVA=/esva/¨
  Ý,SIZELENGTH=/sizelength/¨
  Ý,STRING={/string/ | (/string/,/string_length/)}¨
  Ý,RESULTLEN=/result_length/¨

*Parameter *



Description

id_name



the identifier to assign to the service processor identifier (SPID)
being established. This name must be unique for all service processor
identifiers.

st_epname



the entry point name of the String Handler service processor module
being used. This value defaults to 'SRVST '.

st_epa



a fullword that will contain the entry point address of the String
Handler service processor, after it has been loaded into storage.

st_token



a fullword that will contain a unique value, assigned by the ST_START
function. This value must be used for all String Handler function calls.

esid_name



the name of a service processor identifier, created by the ES_ID macro,
which will be used by the ST_ID macro to automatically obtain the value
for esv (see below).

esva



specifies the label of a fullword in storage that contains (or will
contain) the address of the Environment Support Vector (ESV) created by
the ES_START function.

sizelength



If specified, /sizelength/supplies a default value for the ST_START
function. Refer to for a full description of this parameter.

string | string_length, result_length



If specified, these parameters supply default values for like-named
parameters of other String Handler function macros. For example, if
/result_length/were specified on the ST_ID instruction but not on a
subsequent ST_INTEGER_TO_STRING instruction, the default value would be
used.


      Example 1

ST_ID ID=ES,SPEPNAME=&STRING_HANDLER

_*ST_INTEGER_TO_STRING - Convert Binary Integer to String*_

The ST_INTEGER_TO_STRING function produces a string that is equal to the
textual representation of a fullword signed binary integer. The result
will be a string of one or more digits with leading zeros removed,
prefixed with a minus sign (*-*) if the integer is negative.

ST_INTEGER_TO_STRING ID=/id_name/ Ý,SPEPA=/st_epa/¨ Ý,SPTOKEN=/st_token/¨
   ,INTEGER=/integer/
   ,STRING={/string/ | (/string/,/string_length/)}
   ,RESULTLEN=/result_length/
CALLX /st_epa/,(/st_token/,&ST_INTEGER_TO_STRING,/integer/,/string/,
              /string_length/,/result_length/)



*Parameter *



Description

integer



specifies the label of a fullword in storage containing a signed binary
integer in two's complement format.

string



specifies the label of an area in storage where a string containing the
textual equivalent of the value in /integer/should be placed.

string_length



specifies the label of a signed binary integer equal to the length of
the storage indicated by the /string/parameter. The /stringlen/parameter
may be from one to four bytes in length, as determined by the
/sizelength/parameter of the ST_START function.


*Note: *The macro form of ST_INTEGER_TO_STRING will attempt to generate
a value for /string_length/automatically if it is not specified. In
order to generate the right value, however, /sizelength/must have
previously been specified on the ST_ID macro. :pLt.result_length
:pLd.specifies the label of a fullword in storage in which the
ST_INTEGER_TO_STRING function will place a signed binary integer equal
to the length of the resulting string.



_*ST_START - Begin a String Handler Session *_

The ST_START function establishes a new session with the String Handler
and returns its session identifier in the /st_token/parameter. The size
(number of bytes) of the numbers used to specify string lengths to the
String Handler may be specified with the /sizelength/parameter. Halfword
length values are the default, but a session may be established using
byte, halfword, three-byte, or fullword length values.

ST_START ID=/id_name/ Ý,SPEPA=/st_epa/¨ Ý,SPTOKEN=/st_token/¨
  Ý,ESVA=/esva/¨
  Ý,SIZELENGTH=/sizelength/¨
CALLX /st_epa/,(/st_token/,&ST_START,/esva/Ý,/sizelength/¨)



*Parameter *



Description

sizelength



this parameter is a signed fullword integer that determines the size, in
bytes, of all values used to represent string lengths in the String
Handler session being started. All length-values passed to the String
Handler or returned by the String Handler will be of this size. If, for
example, /sizelength/= 2 (the default) then all lengths would be
represented as halfword values.


The macro forms of all String Handler functions will attempt to generate
values for string lengths automatically if they are not specified. In
order for these macros to generate the right values, however,
/sizelength/must be specified on the ST_ID macro, and it must be a
self-defining term. That is, it must be an actual number (i.e. *2*) or a
reference to a symbolic variable (e.g. *&ST_FULLWORD*) that has been set
to a numeric value with the assembler SETA directive. The following
symbols are available for this purpose: *&ST_BYTE*, *&ST_HALFWORD*,
*&ST_THREE_BYTE*, and *&ST_FULLWORD*.

:plist. :pLt./(Ref #5.)/:pLd.:eplist.

_*ST_STRING_TO_INTEGER - Convert a String to a Fullword*_

The ST_STRING_TO_INTEGER function produces a fullword signed binary
integer that is equal to the value represented the text string in
parameter /string/. The input string must contain a sequence of one or
more adjacent digits optionally prefixed with a sign character ("*+*" or
"*-*"). Any number of blanks may appear before or after the optional
sign or digit sequence, but not between digits.

ST_STRING_TO_INTEGER ID=/id_name/ Ý,SPEPA=/st_epa/¨ Ý,SPTOKEN=/st_token/¨
   ,STRING={/string/ | (/string/,/string_length/)}
   ,INTEGER=/integer/
CALLX /st_epa/,
   (/st_token/,&ST_STRING_TO_INTEGER,/string/,/string_length/,/integer/)



*Parameter *



Description

integer



specifies the label of a fullword in storage where a signed binary
integer equal to the value represented by /string/will be placed.

string



a sequence of numeric characters representing an integer value. A
leading sign character ("*+*" or "*-*") is optional. Blanks may appear
at any point in the string /except/between adjacent digits. Example
string: ' - 672 '.

string_length



specifies the label of a signed binary integer equal to the length of
the storage indicated by the /string/parameter. The
/string_length/parameter may be from one to four bytes in length, as
determined by the /sizelength/parameter of the ST_START function.

*Note: *The macro form of ST_STRING_TO_INTEGER will attempt to generate
a value for /string_length/automatically if it is not specified. In
order to generate the right value, however, /sizelength/must have
previously been specified on the ST_ID macro.

_*ST_TERMINATE - End a String Handler Session*_

The ST_TERMINATE function ends a session with the String Handler and
sets the /st_token/value to zero.

ST_TERMINATE ID=/id_name/ Ý,SPEPA=/st_epa/¨ Ý,SPTOKEN=/st_token/¨
CALLX /st_epa/,(/st_token/,&ST_TERMINATE)

------------------------------------------------------------------------


  Chapter 13. Symbol Manager <#ToC_109>

The Symbol Manager provides a mechanism for easily and efficiently
keeping track of data by name. With the Symbol Manager, data is stored
and maintained as symbols in a table. Each symbol has two parts: (1) a
/name/, and (2) a /value/. The /value/portion of a symbol is defined by
the application program and contains data to be associated with that
particular symbol.

To use a symbol table, an application first must invoke the SY_START
function. This function will create a new table and initialize it for
use. SY_START accepts several optional parameters that can be used to
tailor various aspects of the symbol table as needed.

Once SY_START has been used to set up a new symbol table, an application
can begin adding symbols to the table and manipulating them. Separate
functions are provided for installing symbols in the table, looking up
symbols to see if they exist or to get their values, updating the values
of symbols, and removing symbols from the table. When an application is
done using a table, the SY_TERMINATE function should be used to delete
the entire table (including any symbols it may contain).

There is currently no support within the Symbol Manager for scoping of
any nature: all symbols in the table must be unique and are accessable
at any time. If you have a need for scoping, or if you need to maintain
multiple sets of symbols, you can still do it by creating multiple
symbol tables.

As many symbol tables as needed may be created and maintained at the
same time. A symbol table is identified by /sy_token/, the value
returned by SY_START at the time the table was created. By invoking
SY_START multiple times to create multiple tables, and by keeping track
of the different /sy_token/values used to identify those tables, you can
maintain as many symbol tables as needed.

Hint: If you need to manage a hierarchical set of symbol tables, you can
store the /sy_token/value for one symbol table in the value of a symbol
in a different table. For example, a root symbol table may contain a
symbol (say for a subroutine) that contains as part of its value the
/sy_token/value of another symbol table (say for the subroutine's
internal symbols).

The Symbol Manager operates independently of its execution environment
and may be used with any Environment Support service processor.


      Obtaining Symbol Manager Symbols & Macros <#ToC_110>

The Symbol Manager's symbols and interface macros can be found in the
assembler copy member SRVSYMAC. This member contains symbols naming the
Symbol Manager's load module, function codes, return codes, and
parameter values. It also contains macros for using all of the Symbol
Manager's functions. The following statement or its equivalent should
appear at the beginning of any program that uses the string handler:

   COPY SRVSYMAC      Obtain the Symbol Manager's symbols & macros.


      Common Symbol Manager Parameters <#ToC_111>

Some parameters are general to the Symbol Manager and not specific to
any function. These parameters include its load module name
(/sy_epname/), entry point address (/sy_epa/), and token value
(/sy_token/). The SY_ID macro (see ) can be used to establish defaults
for these parameters and associate them with a unique service processor
identifier. The identifier may then be supplied on any Symbol Manager
macro instruction to refer to the default parameter values.

The parameters listed below apply to every Symbol Manager function.
:plist. :pLt.id_name :pLd.specifies the name of a service processor
identifier created by the SY_ID macro which will be used by all other
function invocation macros to automatically obtain values for
/sy_epa/and /sy_token/. This parameter is required on all function
macros unless both /sy_epa/and /sy_token/are specified. :pLt.sy_epa
:pLd.specifies the label of a fullword that contains the entry point
address of an already-started Symbol Manager service processor. The
value specified by /sy_epa/overrides any value obtained from
ID=/id_name/. :pLt.sy_token :pLd.specifies the label of a fullword that
contains the value returned by SY_START for the /sy_token/parameter. The
value specified by /sy_token/overrides any value obtained from
ID=/id_name/. :eplist.


      Identifying the Symbol Manager <#ToC_112>

The Symbol Manager service processor resides in the load module named by
the following symbol definition in copy member SRVSYMAC:

&SYMBOL_MANAGER  SETC  '''SRVSY   '''

This symbolic name should be used as the service processor entry point
name for the Symbol Manager as shown in the following SY_ID macro
instruction.

SY_ID ID=SY,SPEPNAME=&SYMBOL_MANAGER    Set Symbol Manager Defaults.


      Loading the Symbol Manager <#ToC_113>

The recommended method for loading the Symbol Manager is through
Environment Support's ES_LOAD_MODULE function, as shown in the following
example:

ES_LOAD_MODULE ID=ES,SPID=SY            Load the Symbol Manager


      Complete List of Symbol Manager Return Codes <#ToC_114>

Many return codes can be returned from each function. In the function
descriptions later in this chapter, the most common return codes
returned by the particular function are documented. The following is a
complete list of Symbol Manager return codes.



*Return Code *



Symbol



Description

0



SY_SUCCESS



The invoked Symbol Manager function performed the requested service
without encountering any problems.

1



SY_INVALID_VALUESIZE



The value specified for valuesize on the SY_START function was negative.

2



SY_INVALID_CAPS



The value specified for caps on the SY_START function was not equal to
the character string 'ON' or 'OFF'.

3



SY_INVALID_FUNCTION



An invalid FunctionCode (the second parameter in any service processor
function call) was specified.

4



SY_INVALID_TOKEN



The value specified for token does not identify any symbol currently in
the symbol table.

5



SY_INVALID_HASHSIZE



The value specified for hashsize on the SY_START function was either
zero, negative, or too large. The symbol manager can process hashsize
values from 1 up to an implementation maximum of 536870911 (hexadecimal
X"1FFFFFFF").

6



SY_INVALID_MEMINCR



The value specified for memincr on the SY_START function was either
negative or zero.

7



SY_INVALID_NUMBER_OF_PARMS



Either too few parameters were supplied for the function call or too
many were supplied. Check the parameter list to ensure that it is right
for the function being invoked.

8



SY_INVALID_LENGTH



The value specified for length on the SY_INSTALL or SY_LOOKUP function
was either negative or zero.

9



SY_MEMORY_PROBLEM



An error was encountered while attempting to obtain or release storage
for symbol table management. The Symbol Manager uses the Memory Manager
service processor for these functions, so the error will be in the
Environment Support Debug Information Area.

10



SY_STORAGE_NOT_AVAILABLE



Not enough storage was available to create the symbol table (for
SY_START calls) or to add a new symbol to the table (for SY_INSTALL
calls). Since symbol table size is limited only by the total amount of
memory available to your program, you must increase your region size to
get more storage.

11



SY_SYMBOL_ALREADY_INSTALLED



The SY_INSTALL function was called to install a new symbol in the symbol
table, but the provided symbol was already there.

12



SY_SYMBOL_NOT_FOUND



The symbol identified by name and length is not in the symbol table.


------------------------------------------------------------------------


    Symbol Manager Service Processor Functions <#ToC_115>

The remaining sections of this chapter describe all functions provided
by the Symbol Manager service processor, arranged in alphabetical order.
Each function's description begins on a new page, and the name of the
function being described appears in the top outside corner of every
page. :func name='SY_ID' id=syid.Establish Default Symbol Manager Values

The SY_ID macro is used to establish default values for use by other
Symbol Manager macros, which may access those values through a unique
identifier, id_name, specified by the user. When allowed to generate
default values, this macro will create Program Work Area (PWA) storage
for sy_epa and sy_token. These values, whether generated by the macro or
provided by the user, are accessable from all other Symbol Manager
macros via the ID=id_name parameter.

SY_ID ID=id_name
  Ý,SPEPNAME=sy_epname¨
  Ý,SPEPA=sy_epa¨
  Ý,SPTOKEN=sy_token¨
  Ý,ESID=esid_name¨
  Ý,ESVA=esva¨

*Parameter *



Description

id_name



the identifier to assign to the service processor identifier being
established. This name must be unique for all service processor
identifier's.

sy_epname



the entry point name of the Symbol Manager service processor module that
is being used.

sy_epa



specifies the label of a fullword that will contain the entry point
address of the Symbol Manager.

sy_token



specifies the label of a fullword that will contain the token assigned
by the SY_START function of the Symbol Manager.

esid_name



the name of a service processor identifier, created by the ES_ID macro,
which will be used by the SY_ID macro to automatically obtain the value
for esv (see below).

esva



specifies the label of a fullword that contains (or will contain) the
address of the Environment Support Vector (ESV) created by the ES_START
function.


      Example 1

SY_ID     ID=SY,SPEPNAME=&SYMBOL_MANAGER

_*SY_INSTALL - Install a Symbol in the Symbol Table *_

The SY_INSTALL function inserts a new symbol into the table identified
by the sy_token parameter. If the symbol is already in the symbol table,
SY_INSTALL will not update that symbol's value.

SY_INSTALL ID=id_name Ý,SPEPA=sy_epa¨ Ý,SPTOKEN=sy_token¨
   ,NAME={'name' | name | *(name,length)*}
  Ý,TOKEN=token¨
  Ý,VALUE=value¨
CALLX sy_epa,(sy_token,&SY_INSTALL,name,length,Ýtoken¨,Ývalue¨)



*Parameter *



Description

name



the name of the symbol to install. If the *CAPS*option is in effect, the
symbol will be stored in the table with name converted to uppercase.

length



a signed binary fullword integer equal to the length of the text
specified by name.

token



a fullword in which a unique four-byte identifier will be returned for
the newly installed symbol. The token must be used for all accesses to
the symbol in the future.

value



an application defined area containing the initial value to assign to
the symbol. The data referred to by value must be valuesize bytes in
length. See the SY_START function for an explanation of the valuesize
parameter.

_*SY_LOOKUP - Locate a Symbol in the Symbol Table *_

The SY_LOOKUP function locates the specified symbol in the table
identified by the sy_token value and returns its unique four-byte token
value. The token may then be used to identify the symbol for other
symbol manager functions.

SY_LOOKUP ID=id_name Ý,SPEPA=sy_epa¨ Ý,SPTOKEN=sy_token¨

  ,NAME={'name' | name | *(name,length)*}
  Ý,TOKEN=token¨
CALLX sy_epa,(sy_token,&SY_LOOKUP,name,length,Ýtoken¨)



*Parameter *



Description

name



the name of the symbol to be located in the symbol table. If the
*CAPS*option is in effect, the case of the symbol is not important.

length



the length (as a signed fullword integer) of the text pointed to by the
name parameter.

token



a fullword into which the unique token of the located symbol will be
returned.

_*SY_OBTAIN_NAME - Obtain a Symbol's Name *_

The SY_OBTAIN_NAME function returns the address and length of the name
of the specified symbol.

SY_OBTAIN_NAME ID=id_name Ý,SPEPA=sy_epa¨ Ý,SPTOKEN=sy_token¨
  ,TOKEN=tokennameptr
  ,LENGTH=length
CALLX sy_epa,(sy_token,&SY_OBTAIN_NAME,token,nameptr,length)



*Parameter *



Description

token



a fullword value returned by the token parameter of the SY_INSTALL or
SY_LOOKUP function.

nameptr



a fullword into which the address of the identified symbol's name will
be returned. This address will be of the symbol manager's copy of the
symbol's name which may have been converted to all capitals. The
application program must not modify this storage in any way!

length



a fullword into which a signed binary integer equal to the length of the
specified symbol's name will be returned.

_*SY_OBTAIN_VALUE - Obtain a Symbol's Value *_

The SY_OBTAIN_VALUE function returns the current value of the specified
symbol.

SY_OBTAIN_VALUE ID=id_name Ý,SPEPA=sy_epa¨ Ý,SPTOKEN=sy_token¨
  ,TOKEN=tokenvalue
CALLX sy_epa,(sy_token,&SY_OBTAIN_VALUE,token,value)



*Parameter *



Description

token



a fullword value returned by the token parameter of the SY_INSTALL or
SY_LOOKUP function.

value



an application defined area into which the current value of the
specified symbol will be placed. This area must be valuesize bytes in
length. See the SY_START function for an explanation of the valuesize
parameter.

_*SY_REMOVE - Remove a Symbol from the Symbol Table*_

The SY_REMOVE function removes a symbol (with its associated value) from
the symbol table. The symbol to be deleted must be identified by its token.

SY_REMOVE ID=id_name Ý,SPEPA=sy_epa¨ Ý,SPTOKEN=sy_token¨
  ,TOKEN=token
CALLX sy_epa,(sy_token,&SY_REMOVE,token)



*Parameter *



Description

token



Specifies the label of a fullword containing the value returned in the
token parameter of the SY_INSTALL or SY_LOOKUP function.

:plist. :pLt.:pLd.:eplist.

_*SY_START - Begin a New Symbol Manager Session*_

The SY_START function creates a new symbol table and returns its
identifier in the sy_token parameter. Optional parameters specify table
characteristics such as the size of the value portion of a symbol and
whether searches for symbols are case-sensitive.

SY_START ID=id_name Ý,SPEPA=sy_epa¨ Ý,SPTOKEN=sy_token¨
         Ý,ESVA=esva¨
         Ý,VALUESIZE={valuesize | :us.0:eus.}¨
         Ý,HASHSIZE={hashsize | :us.101:eus.}¨
         Ý,MEMINCR={memincr | :us.4096:eus.}¨
         Ý,CAPS={*ON*|*:us.OFF:eus.*}¨
CALLX sy_epa,(sy_token,&SY_START,esva,Ývaluesize¨,Ýcaps¨,Ýhashsize¨,
              Ýmemincr¨)



*Parameter *



Description

id_name



specifies the name of a service processor identifier created by the
SY_ID macro which will be used by the SY_DELETE macro to automatically
obtain values for sy_epa and sy_token. This parameter is required unless
both sy_epa and sy_token are specified.

sy_epa



specifies the label of a fullword that contains the entry point address
of an already-started Symbol Manager service processor. The value
specified by sy_epa overrides any value obtained from ID=id_name.

sy_token



specifies the label of a fullword that contains the value returned by
SY_START for the sy_token parameter. The value specified by sy_token
overrides any value obtained from ID=id_name.

esva



specifies the label of a fullword containing the address of an
Environment Support Vector.

valuesize



specifies the label of a fullword containing the length of the value
portion of symbols in the table being created. This value defaults to
*0*, meaning that no information is attached to symbols in the table.

caps



specifies the label of a string equal to either 'ON' or 'OFF', which
indicates whether or not symbol-table searches should be case-sensitive
('OFF') or not ('ON').

hashsize



Specifies the number of hash-table entries that should be reserved for
the symbol table being created. For maximum efficiency, this number
should be approximately 80% or more of the maximum number of symbols
that will reside in the table at any given time.

memincr



The Symbol Manager uses the Memory Manager to obtain all symbol table
storage, which is maintained within a single Memory Manager heap. This
parameter is passed to the MM_START function when the heap is created,
and should be large enough to avoid excessive system calls for obtaining
storage. An approximate value can be calculated as follows:

 1.

    The size of a symbol table entry is 12+valuesize+avg_length, where
    avg_length is the average length of a symbol's name.

 2.

    If the maximum number of possible symbols is known, simply calculate
    the total space they will require and use that.

 3.

    If the maximum number of possible symbols can vary wildly from
    execution to execution, try to choose a value for memincr that will
    be large enough to satisfy a majority of cases with a single
    increment of storage. In cases where more symbols are used, the heap
    will expand as needed.

_*SY_TERMINATE - End a Symbol Manager Session *_

The SY_TERMINATE function deletes the symbol table identified by the
sy_token parameter, automatically deleting all symbols currently
installed and releasing all storage obtained for that symbol table.

SY_TERMINATE ID=id_name Ý,SPEPA=sy_epa¨ Ý,SPTOKEN=sy_token¨
CALLX sy_epa,(sy_token,&SY_TERMINATE)

_*SY_UPDATE_VALUE - Replace a Symbol's Value*_

The SY_UPDATE_VALUE function replaces the value of the specified symbol.

SY_UPDATE_VALUE ID=id_name Ý,SPEPA=sy_epa¨ Ý,SPTOKEN=sy_token¨
  ,TOKEN=tokenvalue
CALLX sy_epa,(sy_token,&SY_UPDATE_VALUE,token,value)


*Parameter *



Description

token



a fullword value returned by the token parameter of the SY_INSTALL or
SY_LOOKUP function.

value



an application defined area containing the new value to assign to the
symbol. The data referred to by value must be valuesize bytes in length.
See the SY_START function for an explanation of the valuesize parameter.


  Appendix A. Writing A Service Processor <#ToC_116>

Typical programmers will often find that they have to perform certain
tasks over and over when writing code, such as string manipulation, file
handling or date conversion. Usually, such programmers will find, as
they talk shop with their colleagues over lunch or a cup of coffee, that
they all perform these same tasks, and find them equally repetitive (and
boring). Many of the existing Service Processors were conceived in this
manner, by programmers who were willing to write some set of functions
one last time in a nice package so they could get on with their lives.

This chapter will describe how to write a service processor, and will
actually develop a working service processor as an example. The
conventions which have developed over time will be explained, and the
philosophy behind service processors will be presented. It is assumed
that the reader is an experienced assembler programmer, and is familiar
with the Clemson Structured Macros, as they will be used in the examples.

------------------------------------------------------------------------


    Service Processor Conventions <#ToC_117>

There are several programming conventions that experience has shown to
work well for service processors. Many have evolved from "unwritten
rules", while others are based mainly on convenience and common sense.

  *

    *Service processors should always be reentrant.*The Clemson
    Structured Macros make reentrancy a simple matter. In addition, a
    service processor can "remember" things across calls, since its
    program workarea is reused. Also, a service processor may be called
    from an authorized program, in which case reentrancy can provide
    additional protection and security.

  *

    *Service processors should be able to operate normally whether in an
    authorized state or not.*For the OS environment, an authorized state
    generally refers to a program running in supervisor state, a system
    key, or with APF authorization. Exceptions are those service
    processors which require some state (such as APF authorization) to
    perform their function.

  *

    *A service processor should be as efficient as
    possible.*Assembler-language applications are often written in
    assembler because of performance requirements. The service processor
    cannot know this beforehand, so it should always assume that
    performance is critical to its callers. The use of a performance
    analysis tool such as STROBE is suggested as a way to optimize
    routines and find "hot spots" in the code during development.

  *

    *Service processors can be called directly, or by using function
    macros.**Direct calls*generally involve building your own parameter
    list and coding your own CALL or CALLX, while *function macros*allow
    you to code parameters as macro keywords. The main advantage of
    function macros to a service processor's caller is the amount of
    housekeeping and repetitive coding that is eliminated. The main
    advantage to the service processor's author is that the use of
    function macros simplifies the task of documenting the service
    processor.

  *

    *A service processor should be environment-independent if
    possible.*This simply means that the service processor should call
    Environment Support or other environment-dependent service
    processors to do environment-dependent things, like obtain memory or
    deal with files. This tends to isolate the service processor from
    its environment, and also makes it easy to transport to a different
    environment (for example, from OS to IDMS/DC) as long as
    environment-dependent routines are available in the new environment.

  *

    *A service processor should avoid abends.*This includes program
    checks as well as "unrecoverable" errors where the programmer
    assumes that the only thing left to do is terminate the caller's
    task. If a service processor abends for any reason, it should be
    considered as a bug unless there's a good excuse (for example, if
    the checks required to prevent a particular abend would severely
    impact the service processor's performance). Service processors, as
    a rule, should make reasonable attempts to check caller-provided
    parameters for validity: the number of parameters, nonzero addresses
    for required information, the validity of the service processor's
    token, and so on.

  *

    *Service processors should return specific return codes for any
    error and let the caller decide if the situation merits an abend or
    not.*The service processor environment provides a general debug
    information area that service processors can save information in:
    these areas can be stacked (in case one service processor calls
    another). The debug area can be displayed by the caller using
    ES_Display_Debug_Info or ES_Display_Debug_Info_And_Abend: a service
    processor should not take it upon itself to display the debug
    information.

  *

    *It's OK for a service processor to call other service
    processors.*If this is done, the service processor should not
    display its debug information due to another service processor's
    error, but should save its own debug information instead and return
    a meaningful error to its caller (which may be yet another service
    processor). This way, the caller can display the debug information
    and see a trace of how the error occurred.

  *

    *If a service processor cannot recover from some situation, some
    method should be used to restrict subsequent calls.*For example,
    when the OS File Handler cannot create a file as requested, a flag
    is set that disallows any other call except FI_Terminate.

------------------------------------------------------------------------


    The "Cheap Calculator" Service Processor <#ToC_118>

Throughout the rest of this chapter, examples will be used to illustrate
aspects of service processor development. Our examples will actually
develop a working service processor, which will emulate a four-function
calculator. The "Cheap Calculator", or SRVCC service processor, will
have five simple functions: Add, Subtract, Multiply, Divide and Clear,
as well as Start and Terminate. For the sake of brevity, this is a
really cheap calculator that can only handle integer arithmetic. The
calculator's "display" is maintained internally by SRVCC and returned to
the caller after each operation: the caller can perform operations on
the display, or set it to zero by clearing it.

SRVCC, while simple and small, contains all of the components and
attributes of a service processor, and can be used as a model for
developing a more elaborate set of routines.

------------------------------------------------------------------------


    Components Of A Service Processor <#ToC_119>


      The Service Processor Load Module <#ToC_120>

The executable copy of the service processor is a load module residing
either in the system linklist or a load library that the caller must
reference via STEPLIB. Publicly-available service processors have a
naming convention, as follows:

  *

    The load module name begins with "SRV".

  *

    The characters "SRV" are followed by a two-character identifier
    ("CC" in our example).

  *

    If the service processor is environment-dependent, the remainder of
    the load module name identifies the environment (for example, "MVS"
    for an MVS-dependent module).

In MVS/XA, the load module should have the attributes AMODE(31) and
RMODE(ANY), unless this is not possible for some reason (for example,
the service processor might use QSAM, which requires RMODE(24)). The
service processor should expect to be called AMODE(31).


      The Service Processor Copy Member <#ToC_121>

It is customary to provide a copy member containing global symbols,
function macro definitions and any other tools that might help the
programmer code up calls to the service processor.


        The SRV##ID Macro

The SRV##ID macro can set or override the EPA, TOKEN and ESVA parameters
via global symbols unique for each service processor ID used in a
program. SRV##ID relieves the function macro author of a number of
programming chores. Generally, one would code a SRV##ID SET in the
service processor's ID macro to establish these symbols for the rest of
the macros, and to generate storage for those fields that aren't
specified. Subsequent function macros would issue SRV##ID GET to
retrieve these symbols.


        DEFUCOND Macros

DEFUCOND macros should be defined for each of the service processor's
possible return codes. These macros should have the same name as the
corresponding return code's global symbol. The condition name must be
preceded with a "%" when used in a conditional statement, as shown in
Figure 18 <#FIGMACDEFX>.

*Figure 18. User-Defined Condition Example* <#FT_FIGMACDEFX>



    CC_ADD  ID=CC,VALUE=5,DISPLAY=PWA_DISPLAY
    IF    (TREG,R15,NZ)
      IF    (%CC_OVERFLOW)
        CALLSUB OVERFLOW
      ELSE
        ERREXIT NAME=CC_ERROR
      ENDIF
    ENDIF

Use the SRV##RC macro to actually generate the return code comparison,
as illustrated in Figure 19 <#FIGMACDEFU>.

*Figure 19. DEFUCOND Macros For SRVCC* <#FT_FIGMACDEFU>



 *---------------------------------------------------------------------*
 * DEFUCOND macros to facilitate checking return codes.
 *---------------------------------------------------------------------*
    DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_CC_ID
    DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_NUMBER_OF_PARMS
    DEFUCOND MACRO=SRV##RC,NAME=CC_INVALID_FUNCTION
    DEFUCOND MACRO=SRV##RC,NAME=CC_OVERFLOW
    DEFUCOND MACRO=SRV##RC,NAME=CC_PARAMETER_MISSING



        The ID Macro

There are a number of parameters that would be coded repeatedly if a
service processor was called using normal means (CALL or CALLX). A major
advantage of the function macros is that they can be made to "remember"
this information, and can even generate some of the storage required to
hold it.

The ID macro uses the SRV##ID SET macro to establish global symbols for
the service processor's session defaults, as shown in Figure 20
<#FIGMACID>.

*Figure 20. CC_ID Macro For SRVCC* <#FT_FIGMACID>



 *---------------------------------------------------------------------*
 *
 *  CC_ID Macro: Establish default values for a specific service
 *               processor and associate them with the specified ID
 *               name.  The values are stored in the following created
 *               global variables, which are used by the other macros:
 *
 *    Variable Name                     Description
 *    -------------  -----------------------------------------------
 *    #$&ID.$#IDMAC  Name of macro that created the ID: CC_ID.
 *    #$&ID.$#ESID   Service processor's Environment Support ID.
 *    #$&ID.$#EPN    Tag for Service processor's Entry Point Name.
 *    #$&ID.$#EPA    Tag for Service processor's Entry Point Address.
 *    #$&ID.$#TKN    Tag for Service processor's Entry Point Token.
 *
 *---------------------------------------------------------------------*
          MACRO
          CC_ID &ID=,&ESVA=,&SPEPNAME=,                                *
                &SPEPA=,&SPTOKEN=,&ESID=
 .*
 .* Invoke SRV##ID to create globals used by all ID's.
 .*
          SRV##ID SET,ID=&ID.,IDMAC=CC_ID,                             *
                ESID=&ESID.,SPEPNAME=&SPEPNAME,                        *
                SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.
          MEND


        The Function Macros

The remainder of the function macros, for the most part, will generate
executable code and will call the service processor with appropriate
parameters for the function desired. The macro itself should perform
reasonable checks for the presence and validity of parameters, and may
perform any additional checking or processing required.


        Global Symbols

There are several groups of global symbols used by the service processor
macros, the service processor code itself, and/or the program that will
use the service processor.

*Symbols Required By SRV##ID:: *  SRV##ID SET will define and set a
number of unique global symbols. The symbols are unique in that each
symbol name contains the ID name specified on the service processor's ID
macro. Symbols created by SRV##ID SET are only used by SRV##ID GET, and
the developer should not be concerned about them.

SRV##ID GET returns the values of these symbols in a series of
fixed-name symbols to the calling macro. The individual symbols and
their meanings are:

*Table 9. Variables Returned By ##SRVID GET*

Keyword



GET Returns



Description

ID



&#_IDMAC



The ID value for this service processor session

IDMAC



&#_IDMAC



Name of the ID macro that generated this information

ESID



&#_IDESID



ID of the associated Environment Support session

ESVA



&#_IDESVA



Storage tag containing the ESV address

SPEPNAME



&#_IDEPN



Service processor's CL8 entry name

SPEPA



&#_IDEPA



Service processor's entry point address

SPTOKEN



&#_IDTKN



Storage tag containing token for this service processor session



*Function Code And Return Code Symbols*

All function codes and return codes should have global symbols assigned
to them. Note that when the copy member is copied into the calling
program, these symbols are defined in open code: this means that the
caller can reference them with no additional effort, but the function
macros defined in the copy member must reference those global symbols
that they need. This will always include the function code symbol, and
often will include any global symbols specific to the service processor.

*Figure 21. Symbol Definitions For SRVCC* <#FT_FIGMACSYMS>



 *---------------------------------------------------------------------*
 *  Service processor module name.
 *---------------------------------------------------------------------*
    GBLC   &CHEAP_CALCULATOR
 &CHEAP_CALCULATOR SETC '''SRVCC    '''
 *---------------------------------------------------------------------*
 *  Function symbols.
 *---------------------------------------------------------------------*
    GBLA   &CC_START,&CC_TERMINATE
    GBLA   &CC_ADD,&CC_SUBTRACT,&CC_MULTIPLY,&CC_DIVIDE
    GBLA   &CC_CLEAR
 &CC_START         SETA   1
 &CC_TERMINATE     SETA   2
 &CC_ADD           SETA   3
 &CC_SUBTRACT      SETA   4
 &CC_MULTIPLY      SETA   5
 &CC_DIVIDE        SETA   6
 &CC_CLEAR         SETA   7
 *---------------------------------------------------------------------*
 *  Return code symbols.
 *---------------------------------------------------------------------*
   GBLA    &CC_INVALID_CC_ID
   GBLA    &CC_INVALID_NUMBER_OF_PARMS
   GBLA    &CC_INVALID_FUNCTION
   GBLA    &CC_OVERFLOW
   GBLA    &CC_PARAMETER_MISSING
 &CC_INVALID_CC_ID           SETA  1
 &CC_INVALID_NUMBER_OF_PARMS SETA 2
 &CC_INVALID_FUNCTION        SETA  3
 &CC_OVERFLOW                SETA  4
 &CC_PARAMETER_MISSING       SETA  5



*Other Symbols:*Generally, if additional global symbols would simplify
the tasks of the service processor's users or its author, they should be
provided. One example of such symbols is the time, date and duration
symbols provided by the Date/Time Service Processor.


        Parameter Validity Checking

Much of the validity checking performed by a service processor can be
performed at assembly time by the function macros. This is not to say
that the service processor code should not validity-check the parameters
as well: a caller may use CALLX to call the service processor, a
parameter list may be overlaid at execution time, or some other
unforeseen problem may occur. Validity checking by the function macros
is primarily for the programmer's benefit, as this tends to catch common
errors (omitted or mutually exclusive parameters, constants where
addresses should be specified, and so on) at assembly time.


        CALLX Vs. ##PLIST

The Structured Macros include the ##PLIST macro, which is used
internally by PLIST, CALLSUB and CALLX to build parameter lists. ##PLIST
has 3 forms: "START" to initiate a parameter list, "END" to terminate
one, and "PARM,parameter" to add a parameter to the list being built.
##PLIST is especially useful for building variable-length parameter
lists, as shown in Figure 22 <#FIGMAC##PL>.

*Figure 22. Building A Variable-Length Parameter List Using ##PLIST*
<#FT_FIGMAC##PL>



 .*
 .* Given a parameter containing a VL list of things (in this case,
 .* "SOURCE=(p1,p2,p3,...,pn)"), generate the base parameter list.
 .*
          ##PLIST START                   | Generate PWA tag, code
          ##PLIST PARM,IDTKN           | Initial parms
          ##PLIST PARM,&SRVPROC_FUNCTION  |
          ##PLIST PARM,ESVA            |
 .*
 .* Generate a VL list from the operand(s) of SOURCE, if any.
 .*
 &N       SETA  1
 .PL_LOOP ANOP  ,                         |
          AIF   (&N GT N'&SOURCE).PL_LOOPEND
          ##PLIST PARM,&SOURCE(&N)        | Entry for SOURCE(n)
 &N       SETA  &N+1                      |
          AGO   .PL_LOOP                  |
 .PL_LOOPEND ANOP ,
 .*
 .* Terminate the parameter list and call service processor.
 .*
          ##PLIST END,VL      | Set X'80' on last parm, load R1
          CALLX  IDEPA     | Call the service processor.
          MEXIT


        The CC_Add Macro

Figure 23 <#FIGMACADDM> illustrates the CC_Add macro, which uses the
basic components of a function macro.

*Figure 23. CC_ADD Macro For SRVCC* <#FT_FIGMACADDM>



 *---------------------------------------------------------------------*
 *  CC_Add Macro.
 *  Format:    CC_ADD    ID=CC,
 *                       SPEPA=CC_entry_point_address,  (*)
 *                       SPTOKEN=CC_token_address,      (*)
 *                       ESVA=ESV_address,              (*)
 *                       VALUE=address | constant | register,
 *                       DISPLAY=address | register
 *  (*) - These may be defaulted to values set or generated by CC_ID.
 *---------------------------------------------------------------------*
          MACRO
          CC_ADD  &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,        |              *
                &VALUE=,&DISPLAY=                       |
          GBLC  IDCODE,IDMAC,IDESID,IDESVA  |  SRV##ID
          GBLC  IDEPN,IDEPA,IDTKN              |   Symbols
          GBLA  &CC_ADD                                 | Function code
 .*
 .* Obtain service processor ID values.
 .*
          SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),  | Fill out the   *
                ID=&ID,IDMAC=CC_ID,                   | defaults from  *
                SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,        | CC_ID macro.   *
                ESVA=&ESVA.                           |
          AIF  ('IDCODE' NE 'SUCCESS').MEXIT
 .*
 .* Ensure required parameters are present.
 .*
          AIF  ('&VALUE' EQ '').MISSING     | VALUE is required
          AIF  ('&DISPLAY' EQ '').MISSING   | DISPLAY required
          AIF  (T'&DISPLAY EQ 'N').BADDISP  | DISPLAY can't be constant
 .*
 .* Generate the CC_ADD call.
 .*
          ##PLIST START            |     Start parmlist generation.
          ##PLIST PARM,IDTKN    |     Parameter 1: Token.
          ##PLIST PARM,&CC_ADD     |     Parameter 2: ADD function.
          ##PLIST PARM,IDESVA   |     Parameter 3: ESVA.
          ##PLIST PARM,&VALUE      |     Parameter 4: Function-specific.
          ##PLIST PARM,&DISPLAY    |     Parameter 5: Function-specific.
          ##PLIST END,VL           |     Set VL bit, load register 1
          CALLX  IDEPA          |     Call the service processor.
          MEXIT
 .MISSING MNOTE 8,'Required parameter(s) missing.'
          MEXIT
 .BADDISP MNOTE 8,'Invalid address of ''&DISPLAY'' for DISPLAY.'
 .MEXIT   MEND



*Miscellaneous Macros*

If your service processor makes use of complex parameters (control
blocks, parameters that point to other parmlists, text with control
information, etc.), consider creating some macros that will help the
programmer deal with your service processor. As an example, the Message
Services service processor includes a set of macros to generate message
CSECTs: these macros do not produce executable code, but create the
message text and associated data structures that would be tedious and
time-consuming to produce manually.


      The User's Guide And Reference <#ToC_134>

The Service Processors User's Guide And Reference (this document) should
contain a chapter for each publicly-available service processor, and
writing the chapter should be considered among the tasks involved in
writing a new service processor. The chapters reside in
SYSTEMS.SRV.SOURCE, as members SRVDOCxx, where xx is the service
processor's two-character ID.

------------------------------------------------------------------------


    Writing The Code <#ToC_135>

By now, it should be apparent that the task of actually writing the
service processor code is only part of the work involved. The code for a
service processor, once a basic framework is in place, is actually
fairly simple to produce. The elements of this framework exist in all
service processors, and indeed are often copied from an existing service
processor when a new one is being written.


      Structured Macro Support <#ToC_136>

Service processors are invariably written using the Structured Macros.
In addition to the "standard" set of macros and tools, the Structured
Macros contain support intended to facilitate the coding of service
processors.


        OPTIONS=*SRVPRC

The super option *SRVPRC must be coded on the BLOCK TYPE=PROGRAM macro
for any service processor. In addition to the options provided by the
*PWA super option, *SRVPRC also includes the following:

  *

    *XA*: Causes XA-only instructions (BAS, BASR) to be used for linkage
    by CALLSUB and CALLX.

  *

    *NO370*: Excludes bimodal code around linkage sequences.

  *

    *(REUSPWA,1)*: Specifies that a reusable PWA should be used, and
    that its address is the first parameter in the parameter list (e.g.
    the token). This option causes a PWA to be getmained and anchored
    off of this address when the START function is invoked.

  *

    *(FNCODE,2,AL4(1))*: Indicates that the function code will be the
    second parameter, and that the START function's code is 1.

  *

    *(ESV,3,PWAAESV)*: Specifies that the ESV address is the third
    parameter, and provides the tag in the PWA where the ESV address
    will be stored when START is invoked. The presence of the ESV
    parameter will also cause BLOCK and ENDBLK to call Environment
    Support's linkage GETMAIN and FREEMAIN routines, instead of
    generating their own GETMAIN and FREEMAIN macros.

  *

    *ERRADDR*: Instructs the ERREXIT macro to use a BAS instruction to
    call the error exit. If the code operand of ERREXIT is provided, the
    value of code is generated as a halfword immediately following the
    BAS instruction. This allows the ERREXIT routine to save the address
    where the error was detected in the debug area.

  *

    *CLRDEBUG*: Specifies whether the debug area should be cleared upon
    each entry to the program block.

If additional program block options are required or should be turned
off, they can be coded normally following the *SRVPRC super option.
Refer to the Clemson University Structured Programming Macros User's
Guide And Reference for additional information.


        SMCTRL

The *SRVPRC super option causes the service processor's PWA to be
getmained during the START call, and retained across subsequent calls:
hence, the TERMINATE routine should include the macro SMCTRL
FREEPWA=YES. This sets a flag in the PWA which will cause the service
processor's ENDBLK macro to freemain the PWA.


        Parameter List Support

The BLOCK macro can set up a base register for the service processor's
parameter list, as well as counting the parameters, by specifying
(PARMS,(USING,reg),(COUNT,pwa_fullword),VL) among the OPTIONS and coding
the operand PARMMAP=dsect_name. There is also a COPYPARM option which
will reserve PWA storage for the largest possible parameter list and
copy the caller's parameter list to the PWA for each call, ensuring that
all unused parameters in the copy are set to zero. While COPYPARM may be
desirable, it can take an excessive amount of time if large parameter
lists are in use. Refer to the Clemson University Structured Programming
Macros User's Guide And Reference for additional information.


      The Parameter List <#ToC_140>

The typical service processor parameter list, as has already been
demonstrated, contains a common set of parameters at its beginning
followed by zero or more function-specific parameters. The common
parameters, as well as a suggested format for the parameter list DSECT,
are presented below.


        The Function Code

The first parameter of any service processor call is the address of a
function code. The function code is always a fullword containing some
nonzero numeric value, and is used to request a particular function from
the service processor. Values of F'1' and F'2' are generally used for
Start and Terminate respectively. Global symbols are usually defined in
the service processor's copy member for the function codes, as seen in
Figure 21 <#FIGMACSYMS>.


        The Token

The token serves to uniquely identify a service processor "session", and
is returned by the START function. Each time it is called, the service
processor will validate its token by ensuring that some field(s) in its
PWA have been set to some identifiable value. The token facility allows
a program to activate multiple service processor "sessions" by issuing
multiple START calls and saving the different tokens, then using the
tokens to refer to individual sessions on subsequent calls.

For example, one might wish to read two files and create a third file:
this could be done by starting three separate File Handler sessions with
appropriate parameters, and using the three tokens as unique
identifiers. Using the function macros, the caller can isolate himself
somewhat from specifying (or even defining!) the token by allowing the
ID macro (and its call to ##SRVID SET) to generate the tokens' storage
and associate an ID value with each token.


        The ESV Address

As a rule, the ESVA, or ESV address, is passed as the third parameter to
at least the START function. If an ESV address is provided to the START
function, the service processor can save the address and allow
subsequent parameter lists to be shorter: however, an invalid-token
error (where the PWA pointer is not valid) may degenerate into
"unpredictable results" when the service processor attempts to use
Environment Support to save error information.


        Other Parameters

Individual functions will, of course, have zero or more
function-specific parameters.


        The Parameter List DSECT

Typically, the DSECT for the service processor's parameter list will
contain the following:

  *

    A "common" section at the beginning containing the token and
    function code.

  *

    Individual sections for each set of function-specific parameters,
    using ORG to redefine the storage for each function.

  *

    A tag for every parameter. The tags should contain the function name
    (or an abbreviation) for function-specific parameters.

  *

    An EQU at the end of the shortest function-specific section (or at
    the end of the common section if appropriate), set to the minimum
    number of parameters that the service processor supports.

  *

    An EQU at the end of each function-specific section, set to the
    number of parameters that the function allows. If the function
    supports a variable number of parameters, two EQU's should be used
    for the minimum and maximum number of parameters.

  *

    An EQU at the end of the DSECT, set to the maximum number of
    parameters that the service processor supports.

The parameter list DSECT for SRVCC appears in Figure 24 <#FIGCCPARMD>.

*Figure 24. SRVCC's Parameter List DSECT (Partial)* <#FT_FIGCCPARMD>



 title "SRVCC -- Parameter List DSECT"
parmlist          dsect ,             |
prm_CC_id         ds a                | CC_identifier === PWA base
prm_functioncode  ds a                | Function to be performed
prm_min_#         equ (*-parmlist)/4  | Minimum number of parameters
*                                     |   (defined here since there are
*                                     |   functions with no function-
*                                     |   specific parameters).
prm_function_dept equ *               | Function-dependent parameters:
*---------------------------------------------------------------------*
*                  Start function parameters
*---------------------------------------------------------------------*
                  org prm_function_dept
prm_start_esv     ds a                | Environment Support Vector.
prm_start_min_#   equ (*-parmlist)/4  | Minimum # START parameters.
prm_start_max_#   equ (*-parmlist)/4  | Maximum # START parameters.
*---------------------------------------------------------------------*
*                 Terminate function parameters
*---------------------------------------------------------------------*
               org prm_function_dept  |
prm_terminate_#   equ (*-parmlist)/4  | No function-specific parms.
*---------------------------------------------------------------------*
*                 CC_Add function parameters
*---------------------------------------------------------------------*
               org prm_function_dept  |
prm_add_value     ds    f             | Value to add to display.
prm_add_display   ds    f             | Where to store updated display.
prm_add_#         equ (*-parmlist)/4  |
*---------------------------------------------------------------------*
*     Other function-dependent parameter sections defined here.
*---------------------------------------------------------------------*
               :
               :
*---------------------------------------------------------------------*
*            End of function-dependent parameter sections.
*---------------------------------------------------------------------*
                org ,                 |
prm_max_#          equ (*-parmlist)/4 | Maximum number of parameters.


        Parameter List Validation

One of the best ways to avoid abends by a service processor is to
scrutinize the caller's parameters carefully. Invalid numbers of
parameters, missing parameters and incorrect data provided by the caller
should be checked, and a descriptive error returned if a problem is
detected.

*Common Parameter Validation.: *  The validations listed here are
standard for any service processor. They should be coded following the
program block macro, and prior to the main case block. The equivalent
code for SRVCC is shown in Figure 25 <#FIGMACENT>.

  *

    *Function code:*The function code should be one supported by the
    service processor. Usually, a symbol in the copy member defining the
    highest-used function code is used to check the function code passed
    by the caller. A function code of zero is generally invalid (since
    it may represent a missing parameter).

  *

    *Token:*After a successful START, the token should point to the
    service processor's PWA. The START code will usually set some unique
    value at a fixed offset in the PWA that subsequent calls can check:
    generally, this is the PWA address followed by some short character
    string (for example, CC_ID) that can be checked quickly.

  *

    *Number of parameters:*The parm count can be set by
    OPTIONS=(...,(PARMS,(COUNT,pwa_count_field),...)) on the program
    block macro. This count field should be checked against the minimum
    and maximum number of parameters supported.

*Function-Specific Parameter Validation.: *  The code at the start of an
individual function should, first of all, ensure that the number of
parameters passed is acceptable for that function. In addition, the
validation code should check for missing parameters (a zero pointer in
the parameter list), as well as anything that might cause a program
check (a zero value to be used for division, invalid packed-decimal
data, etc). Keep in mind, however, that excessive validity checking will
probably impact the service processor's performance.


      Entry Logic <#ToC_149>

The BLOCK macro can be made to perform most of the housekeeping chores
of entering a service processor, such as setting up base registers,
clearing the debug area, and counting the parameters. The remaining
entry logic may then consist of ERREXIT macros: these should ensure that
at least a minimum and no more than a maximum number of parameter were
specified, as well as performing some simple validity check on the PWA.
This validity check is typically a check for some unique thing in the
PWA that the START function put there.

*Figure 25. Entry Logic For SRVCC* <#FT_FIGMACENT>



  title "SRVCC -- Initialization"
  block name=SRVCC,type=program,amode=31,rmode=any,                    *
                options=(*srvprc,long,                                 *
                (parms,(using,r11),(count,pwa_number_of_parms),vl)),   *
                parmmap=parmlist,basereg=(r12,r9),                     *
                subopts=(*swa,loadbase)
 * *------------------------------------------------------------------*
 * * Ensure that at least the minimum and no more than the maximum
 * * number of parameters were passed in the parameter list.
 * *------------------------------------------------------------------*
   l     r0,pwa_number_of_parms        | Save number of parms.
   errexit    (ch,r0,lt,=y(prm_min_#)),      Ensure number of parms    *
                or,(c,r0,gt,=a(prm_max_#)),    is within limits.       *
                code=&CC_invalid_number_of_parms
   l     r1,prm_functioncode           | Load the function code into
   l     r1,0(,r1)                     |   a register for testing.
 * *------------------------------------------------------------------*
 * * If the function code is something other than start, make sure that
 * * the PWA contains the eye-catcher string and the correct value for
 * * CC_ID.   If not, then the CC_ID passed in is garbage.
 * *------------------------------------------------------------------*
   if (c,r1,ne,=f'&CC_start')          | If not startup function:
    errexit ((clc,pwa_visual,ne,psd_eyecatcher),  Check eyecatcher 1 *
                or,(c,r13,ne,pwa_CC_id)),   PWA's address of itself;  *
                code=&CC_invalid_CC_id |    error if they don't match.
   endif                               | Endif.


      The Main CASE Block <#ToC_150>

The simplest way to process the function code is with a case block. This
is usually the heart of any service processor. The individual functions
may be coded as subroutines, or may be handled inline if they're not too
complex. Refer to Figure 26 <#FIGMACSTRT> and Figure 27 <#FIGMACADD> for
examples.


      The START And TERMINATE Functions <#ToC_151>

The START routine should perform whatever initialization the service
processor requires, such as starting other service processors or opening
files. In addition, the START function should establish some unique
value or values in the PWA that can be used by other functions for
validity checking. Generally, a fullword containing the PWA address and
some character string is used: the character string also serves as an
eyecatcher when a dump is taken.

The TERMINATE routine should take care of any end-of-task processing
required, such as closing files or terminating other service processors.
The TERMINATE routine should also include the macro SMCTRL FREEPWA=YES
to cause the program's ENDBLK to freemain the PWA.

The START and TERMINATE routines for SRVCC are illustrated in Figure 26
<#FIGMACSTRT>.

*Figure 26. The CC_Start And CC_Terminate Functions* <#FT_FIGMACSTRT>



    title "SRVCC -- CC_Start Function" |
 * *------------------------------------------------------------------*
 * * Select the code to process the function.
 * *------------------------------------------------------------------*
   caseblk reg=r1                      | Start of function case block.
   space 1                             |
 *  *-----------------------------------------------------------------*
 *  * Start function.
 *  *-----------------------------------------------------------------*
    case &CC_start                     |  Start function.
 *   *----------------------------------------------------------------*
 *   * Set the eyecatcher and the CC_ID fields.   These are checked
 *   * each time the CC server is entered to avoid integrity problems.
 *   *----------------------------------------------------------------*
     mvc   pwa_visual,psd_eyecatcher   |   Set the eyecatcher and the
     st    r13,pwa_CC_id               |   CC_ID are for validity checks
     xc    pwa_clear_start(pwa_clear_length),pwa_clear_start
 *   *----------------------------------------------------------------*
 *   * Make sure that a valid number of parameters are specified.
 *   *----------------------------------------------------------------*
     l     r3,pwa_number_of_parms      |   Load r3 with number of parms.
     errexit    (ch,r3,lt,=y(prm_start_min_#)),or,   Error if out      +
                (ch,r3,gt,=y(prm_start_max_#)),      of bounds.        +
                code=&CC_invalid_number_of_parms
     space 1                           |
     l    r1,pwaaesv                   | Load pointer to ESV.
     using esv,r1                      |
     mvc   pwa_es_epa,esvesepa         | Copy EPA and token addresses
     mvc   pwa_es_token,esvestkn       | for current Env. Support sess.
     drop  r1                          |
     slr   r0,r0                       |
     st    r0,pwa_display              | Clear the "display".
 *  *-----------------------------------------------------------------*
  title "SRVCC -- CC_Terminate Function"
 *  *-----------------------------------------------------------------*
 *  *  CC_Terminate function.
 *  *-----------------------------------------------------------------*
    case &CC_Terminate                 |
     l     r3,pwa_number_of_parms      |   Load r3 with number of parms
     errexit    (ch,r3,lt,=y(prm_terminate_#)),  Error if not correct. +
                code=&CC_invalid_number_of_parms
     smctrl  freepwa=yes               |
 *  *-----------------------------------------------------------------*


      Other Functions <#ToC_152>

Each service processor function should ensure that it was passed the
appropriate number of parameters, and that they contain or point to
valid information.

*Figure 27. The CC_Add Function* <#FT_FIGMACADD>



 title "SRVCC -- CC_Add Function"     |
 *  *-----------------------------------------------------------------*
 *  *  CC_Add function.
 *  *-----------------------------------------------------------------*
    case &CC_Add                       | Add function.
     l     r3,pwa_number_of_parms      |   Load r3 w/ number of parms.
     errexit    (ch,r3,ne,=y(prm_add_#)),  Error if not correct.       *
                code=&CC_invalid_number_of_parms
     l32   r1,prm_add_value            |  Get pointer to value to add
     errexit (z),code=&CC_Parameter_Missing  Error if pointer missing
     l     r1,0(r1)                    |  Get the value
     a     r1,pwa_display              |  Add current display contents
     st    r1,pwa_display              |  Update the display
     l32   r2,prm_add_display          |  Get addr of caller's display
     errexit (z),code=&CC_Parameter_Missing  Error if pointer missing
     st    r1,0(r2)                    |  Return display to caller.
     errexit (c,r1,gt,=f'99999999'),   |  Return error for             *
                code=&CC_Overflow      |   "overflow" condition.
 *  *-----------------------------------------------------------------*


      The Main Error Exit <#ToC_153>

Any service processor should provide as much information as possible
when it detects an error. Environment Support provides a means to allow
service processors to chain blocks of information (known as debug
areas), as shown in Figure 28 <#FIGMACERRX>.

*Figure 28. SRVCC's ERREXIT Routine* <#FT_FIGMACERRX>



  title "SRVCC - General Error Exit"   |
  block type=errexit                   |
 * *------------------------------------------------------------------*
 * * Save module/offset, registers, return-code.
 * *------------------------------------------------------------------*
   stm   r0,r15,gdiregs                | Save registers at time of error
   la    r0,4(,r12)                    | Point to module identification.
   st    r0,gdimodid                   | Save in general debug area.
   mvc   gdirc,0(r14)                  | Copy return code.
   slr   r14,r12                       | Calculate offset at time of err
   sth   r14,gdioffst                  | Save in debug area.
   l     r2,pwaaesv                    | Point r2 to ESV.
   using esv,r2                        | Establish base for ESV.
   es_save_debug_info  id=ES,gdi=debug_area_address
 * *------------------------------------------------------------------*
 * * Look at the error code.  If add'l information would be useful,
 * * stuff into the debug area.
 * *------------------------------------------------------------------*
   lh    r15,gdirc                     | Get return code.
   caseblk reg=r15,mult=1              | Case on return-code.
     case &CC_invalid_function         |
       es_save_debug_info id=ES,       |                               *
                text=(psd_invalid_function,l'psd_invalid_function)
     case &CC_invalid_number_of_parms  |
       es_save_debug_info id=ES,       |                               *
                text=(psd_invalid_#_parms,l'psd_invalid_#_parms)
     case &CC_invalid_CC_ID            |
       es_save_debug_info id=ES,       |                               *
                text=(psd_invalid_CC_ID,l'psd_invalid_CC_ID)
   endcase                             | EndCase.
   drop r2                             |
 * *------------------------------------------------------------------*
 * * Set the return-code and exit.
 * *------------------------------------------------------------------*
   lh    r15,gdirc                     | Set return code.
  endblk rc=(r15)                      |
  title "SRVCC -- Constants"           |
          psd   ,                      |
 psd_eyecatcher  dc    cl8'CHEAP_SP'   | So everyone will know ...
 psd_invalid_function   dc  c"Unsupported function."
 psd_invalid_#_parms    dc  c"Invalid number of parameters."
 psd_invalid_cc_id      dc  c"Invalid token provided."
 psd_overflow           dc  c"Output value is too large for requested *
                format."               |
 psd_undetermined_error   dc  c"Undetermined error."
          ltorg ,                      |
          endpsd ,                     |



Service processors typically contain only one error exit: hence, the
ERREXIT block may be unnamed, which simplifies coding somewhat. The
error exit expects the ERRADDR option to be set on the program block:
this generates a BAS R14,errexit, followed by the ERREXIT macro's CODE
value, to call the error exit. Thus, the error exit can report where it
was called within the service processor.

The Environment Support service processor offers a variety of diagnostic
aids which service processors can use to save error information. The
error exit shown in Figure 28 <#FIGMACERRX> makes use of several of
these tools, and can be used as a model. This sample error exit performs
the following:

  *

    Saves all registers in the General Debug Info (GDI) area. This area
    can be generated by coding ES_GDI DSECT=NO in the PWA. Refer t the
    ES_GDI macro in copy member SRVESMAC for the forma of the GDI.

  *

    Saves the address of the module name (usually +4 from the start of
    the main CSECT) in the GDI.

  *

    Saves the ERREXIT macro's CODE value in the GDI. (This is a halfword
    pointed to by R14.)

  *

    Passes the GDI to the ES_SAVE_DEBUG_INFO function to be "stacked"
    with any existing debug information.

  *

    Depending on the type of error, additional information (in the form
    messages or hex info) may be saved by the error exit using
    ES_SAVE_DEBUG_INFO.

  *

    Exits with the return code passed via the ERREXIT macro's CODE value.

Normally, a service processor *should not*call any service processor
functions other than ES_SAVE_DEBUG_INFO from within its error exit. This
is because vital information about the error being handled may exist in
the debugging information area and calling a service processor function
causes that information to automatically be cleared. If a service
processor's error exit needs to use service processor functions other
than ES_SAVE_DEBUG_INFO, the

ES_CLEAR_DEBUG_INFO ID=es,ACTION=INHIBIT

function should be used to inhibit clearing of the debugging information
area before calling other service processor functions (any service
processor functions, not just Environment Support functions).

After all function calls have been made from within the error exit, the
following function call should be made

ES_CLEAR_DEBUG_INFO ID=es,ACTION=ENABLE

to re-enable clearing of the debugging information area. When control is
returned to the calling application, it may decide it can tolerate the
error and proceed. This function does not actually clear the debugging
information area, but allows it to be cleared automatically the next
time any service processor function is invoked. If this is not done, and
if the calling application proceeds with execution, the debugging area
cannot be cleared and extraneous information may accumulate there.

------------------------------------------------------------------------

*Footnotes:*

^1
    This format, although specified as a date format, will accept or
    return both a date and time value. The associated input or output
    time parameters will be ignored.
^2
    If

OPTIONS=EUROPEAN

    was specified on the DT_START macro, the month and day values will
    be reversed.
^3
    This format, although specified as a time format, will accept or
    return both a date and time value. The associated input or output
    date parameters will be ignored.
^4
    These formats may also be used as interval formats. Refer to Table 4
    <#TBLDTINTVL> for more information.
^5
    The System/370 time-of-day clock can only represent a limited range
    of dates and times, from Jan. 1, 1900 at 00:00:00.00 to Sept. 17,
    2042 at 23:53:47:37. Attempts to convert values outside this range
    to TOD format will result in a

    &DT_Out_Of_Range

    return code.
^6
    These formats may also be used as date or time formats, although
    their characteristics may be slightly different. Refer to Table 2
    <#TBLDTDATES> and Table 3 <#TBLDTTIMES> for more information.



