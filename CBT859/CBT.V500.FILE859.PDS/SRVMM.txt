*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
SRVMM     TITLE 'Memory Service Processor'
         SRVMOD NAME=SRVMM,DATES='1987, 1990, 1995'
         gblc  &srv_modname
*---------------------------------------------------------------------*
*
*  Copyright (C) Clemson University Research Foundation 1987, 1990.
*
*  Program     SRVMM, Memory Service Processor
*
*  Abstract    This processor is designed to make memory allocation
*              efficient for applications by reducing the number of
*              system requests needed to allocate and release portions
*              of storage.  For applications that need to frequently
*              allocate small items of storage, this can drastically
*              reduce system overhead.
*
*  Parameters:
*    Two parameters, HeapID and FunctionCode, are required for each
*    call to the memory manager.  Additional parameters are required
*    for different FunctionCodes.  The entire parameter list required
*    for each function is listed below.
*
*    START
*      CALLX SRVMM,(HeapID,&Start,ESV,Increment,Location)
*
*    TERMINATE
*      CALLX SRVMM,(HeapID,&Terminate)
*
*    OBTAIN
*      CALLX SRVMM,(HeapID,&MM_OBTAIN_STORAGE,Bytes,Address)
*
*    RELEASE
*      CALLX SRVMM,(HeapID,&MM_RELEASE_STORAGE,Bytes,Address)
*
*    The meaning of each parameter is explained below.
*
*    HeapID is a fullword used to uniquely identify the heap of memory
*      being managed.  It is initialized during the startup function.
*
*    FunctionCode is a fullword integer that specifies the function to
*      be performed.  Symbolic identifiers are provided for each
*      function and may be accessed by placing a COPY statement for
*      SRVMMMAC in the assembler program.  These symbols should be
*      used in place of actual integer values.  The following
*      FunctionCodes are supported:
*
*      &START = 1
*        Create a new memory heap and assign to it a unique identifier:
*        HeapID.  In addition to the HeapID and FunctionCode
*        parameters, the parameter ESV is required and the Increment
*        parameter is optional.
*
*      &TERMINATE = 2
*        Free all memory associated with the identified memory heap and
*        destroy the heap, setting HeapID to zeros.
*
*      &MM_OBTAIN_STORAGE = 3
*        Allocate the specified amount of memory, rounded up to the
*        next eight byte boundary, out of the specified memory heap and
*        return its address.  In addition to the HeapID and
*        FunctionCode parameters, Bytes and Address are required.
*
*      &MM_RELEASE_STORAGE = 4
*        Free a specific portion of memory previously allocated within
*        the specified memory heap.  In addition to the HeapID and
*        FunctionCode parameters, Bytes and Address are required.
*
*      &MM_RESET_HEAP = 5
*        Free all memory previously allocated within the specified
*        memory heap, without requiring termination.  This permits
*        re-use of storage obtained from the system, potentially
*        reducing the number of system getmains/freemains required.
*
*    ESV is a fullword given to the application by the Server Manager
*      when it was started up.
*
*    Increment is an optional parameter specifying, as a fullword
*      integer, the incremental size of the heap.  When there is not
*      enough memory in the heap to satisfy an Obtain request, the heap
*      is increased by the number of bytes requested or HeapIncrement,
*      whichever is larger.  This parameter defaults to a value of
*      4096 and can have a maximum value of 16777215 and a minimum
*      value of 1.  If the parameter is missing or zero, the default
*      value will be used.
*
*    Location is an optional parameter specifying, as a fullword,
*      where the storage should be allocated: anywhere, or below the
*      16 Megabyte line.
*
*    Bytes is a fullword describing how much memory is to be obtained
*      or released.  It can have a maximum value of 16777215 and a
*      minimum value of 1.
*
*    Address is returned by the obtain function as the address of the
*      newly allocated memory and passed to the release function as the
*      address of the memory to be freed.
*
*  Return codes:
*
*   &MM_INVALID_FUNCTION
*      An invalid function was specified.  The memory manager only
*      supports the functions START, TERMINATE, OBTAIN, and RELEASE.
*   &MM_INVALID_HEAPID
*      The HeapID provided does not identify an active heap created by
*      the START function of the memory processor.
*   &MM_INVALID_INCREMENT
*      The heap increment was non-positive or greater than the maximum
*      allowed.
*   &MM_INVALID_LOCATION
*      The specified location value is not one of &ES_LOCATION_ANY or
*      &ES_LOCATION_BELOW.  The location for memory returned by the
*      memory manager must be specified as being anywhere or below the
*      16 megabyte line.  It defaults to above.
*   &MM_INVALID_SIZE
*      The number of bytes specified to be obtained or released was
*      greater than the maximum allowed, or was non-positive.
*   &MM_INVALID_PARM_COUNT
*      The number of parameters was incorrect for the specified
*      function, or the FunctionCode or HeapID was not provided.
*   &MM_INVALID_ALIGNMENT
*      Memory being released must be on a doubleword boundary.
*   &MM_STORAGE_NOT_AVAILABLE
*      The memory manager was unable to get enough memory from the
*      system to satisfy the request for storage.
*   &MM_UNKNOWN_ERROR
*      An unknown error occurred while attempting to obtain memory
*      from the system.
*   &MM_MEMORY_NOT_IN_HEAP
*      The storage being released is not currently allocated in the
*      specified memory heap.
*   &MM_MEMORY_NOT_ALLOCATED
*      The storage being released is within the specified memory heap,
*      but is not allocated.
*   &MM_CORRUPT_STORAGE
*      The internal data structure used to manage storage has been
*      corrupted.
*   &MM_NOT_USEABLE
*      The memory manager is not useable due to a previous error.  The
*      previous error may be found in the reason-code.  It should be
*      shut down by the application.
*
*  Program     reentrant, problem key and state, server linkage,
*  Attributes  non-authorized, amode(any), rmode(any)
*
*  Change
*  History     05/25/87 MJM - New
*              01/27/89 MJM - Added code to MM_RELEASE_STORAGE to
*                 insure that FREE_BLOCKs adjacent to the storage being
*                 freed are also in the same STG_BLOCK as the storage
*                 being freed.  What was happening was that FREE_BLOCKs
*                 adjacent in memory but not in the same STG_BLOCK (the
*                 STG_BLOCKS themselves were adjacent in memory) were
*                 being merged into a single FREE_BLOCK, which was
*                 later given away to a MM_OBTAIN_STORAGE request.
*                 When the request came in to free it again, since the
*                 storage was not entirely contained in a single
*                 STG_BLOCK, the RELEASE_STORAGE code detected the
*                 error and complained.
*              11/08/89 MJM - Added the MM_RESET_HEAP function.
*              11/01/02 MJM - Fixed release_storage code that checks
*                             for adjacent free_blocks: the check to
*                             make sure two free_blocks were in the
*                             same stg_block was in error.
*            2009-09-02 mjm - Fized invalid_size error code.
*
*  Method of   o The memory server keeps a list of storage blocks and
*  Operation     a list of free-storage elements.  Initially, both
*                lists are empty.  A free-storage element represents
*                a portion of storage within one of the storage blocks.
*              o Both lists are maintained with a special header node,
*                which initially points to itself - representing an
*                empty list.  The link field of each list element must
*                be at displacement zero so that it will map properly
*                over the header node.
*              o When no free-storage element is large enough to
*                satisfy an allocation request, a new block of storage
*                is allocated and chained to front of the storage block
*                list.  The size of the allocated block is equal to the
*                increment value or the size of the allocation request,
*                whichever is larger.  A single free-storage element is
*                created that is equal to the entire block and added to
*                the front of the free-storage list.
*              o When memory is freed, it is first checked to insure
*                that it lies entirely within one of the storage
*                blocks.  Then it is turned into a free-storage element
*                and inserted into the beginning of the list.  No
*                attempt is made to coalesce adjacent blocks.
*              o On termination of the memory server, all storage
*                blocks are freed, along with the PWA and every other
*                piece of storage.  No storage block is freed before
*                termination, even if all memory within the block has
*                been explicitly freed.
*
*  Special Notes:
*  . The memory manager must be kept compact and efficient, with
*    special attention given to short instruction paths.
*  . The intended use of the memory manager is for an application to
*    do lots of obtains for storage and then to terminate the manager
*    without ever releasing any specific portion of storage.  For this
*    reason, the code was written to make allocation as efficient as
*    possible, at the expense of efficiency for releasing specific
*    portions of memory.
*  . When an application releases storage, it is quite possible that
*    one or more of the values pointed to by the parameter list are
*    contained in the storage being released.  This is perfectly legal.
*    Any changes made to the RELEASE_STORAGE code should take care to
*    pick up all needed parameter values before wiping the contents of
*    the storage being released.
*
*  Possible Enhancements
*  . The current implementation retains all getmained storage until it
*    its terminated.  If there is a need to do so, a RETAIN parameter
*    can be added to the start function.  It would default to a value
*    that means *ALL, but applications could specify that any storage
*    block that contains no allocated storage should be freed (*NONE)
*    or that an empty block should be freed only if xxx number of bytes
*    would still be available after its release.
*  . The control blocks used to maintain incremental-getmained chunks
*    are getmained themselves.  This means that every time the heap is
*    incremented, two getmains are done.  What could be done instead
*    is to start with a good-sized array of storage control blocks
*    in the PWA, and getmain overflow arrays as needed.
*---------------------------------------------------------------------
 EJECT
   COPY   SRVESMAC                    | Copy service processor symbols.
   COPY   SRVMMMAC                    | Copy service processor symbols.
   COPY   SMSYMS                      | Get structured macro syms.
 EJECT
***********************************************************************
*
*  The following macro is for setting and checking the error detection
*  code of a free_block or stg_block.  If an error is detected, the
*  error-exit is invoked with the appropriate error code.  The macros
*  assumes addressability on the free_block or stg_block being
*  examined.
*
***********************************************************************
         MACRO
         EDC    &TYPE,&OPER
         GBLA   &MM_CORRUPT_STORAGE
         XR     R0,R0                     | R0 := EDC Accumulator.
         ICM    R0,B'0111',&TYPE._SIZE    | Get the size value.
         X      R0,&TYPE._LINK            | Exclusive-OR link field.
         AIF    ('&TYPE' NE 'STG').NOADDR
         X      R0,&TYPE._ADDR            | Exclusive-OR addr field.
.NOADDR  ANOP
         LR     R15,R0                    | R15 := EDC so far.
         SRL    R15,16                    | Shift upper half down.
         XR     R0,R15                    | XOR with real EDC.
         LR     R15,R0                    | R15 := EDC so far.
         SRL    R15,8                     | Shift last byte down.
         XR     R0,R15                    | XOR with real EDC.
         AIF    ('&OPER' EQ 'SET').SET
         AIF    ('&OPER' EQ 'CHECK').CHK
         MNOTE  8,'Invalid EDC operation'
         MEXIT
.SET     STC    R0,&TYPE._EDC             | Move the result to the EDC.
         MEXIT
.CHK     ERREXIT (CLM,R0,1,NE,&TYPE._EDC),CODE=&MM_CORRUPT_STORAGE
         MEND
 EJECT
***********************************************************************
*
*  Main program code.
*
***********************************************************************
 BLOCK NAME=&srv_modname,TYPE=PROGRAM,AMODE=31,RMODE=ANY,              +
               OPTIONS=(*SRVPRC,NOCLEARPWA),R1SAVE=R11,SUBOPTS=*SWA
   USING PARMLIST,R11                 | Establish addressability.
*                                     |
   ERREXIT (TBIT,PRM_HEAPID,X'80'),CODE=&MM_INVALID_PARM_COUNT
   L     R1,PRM_FUNCTIONCODE          | Load the function code into
   L     R1,0(,R1)                    |   a register for testing.
*---------------------------------------------------------------------*
*  If the function code is something other than start, make sure that
*  the PWA contains the eye-catcher string and the correct value for
*  HeapID.  If not, then the HeapID passed in is garbage.  Also check
*  to see if the Heap is useable -- it may have been messed up due to
*  a previous error.
*---------------------------------------------------------------------*
   IF (C,R1,NE,=F'&START'),THEN       | If not startup function then
     ERREXIT ((CLC,PWA_VISUAL,NE,EYECATCHER),OR,(C,R13,NE,PWA_HEAPID)),+
               CODE=&MM_INVALID_HEAPID
     IF (C,R1,NE,=F'&TERMINATE'),THEN |   If not Terminate either then
       ERREXIT (NOT,(TBIT,PWA_F_USEABLE)),CODE=&MM_NOT_USEABLE
     ENDIF                            |   Endif.
   ENDIF                              | Endif.
*                                     |
   CASEBLK REG=R1                     |
   EJECT
***********************************************************************
*                                                                     *
*    Start a new memory heap.                                         *
*                                                                     *
***********************************************************************
     CASE &START
*---------------------------------------------------------------------*
*       Set the eyecatcher and the heapid fields.  These are checked
*       each time the memory server is entered to avoid integrity
*       problems.
*---------------------------------------------------------------------*
        MVC  PWA_VISUAL,EYECATCHER    | Both the eyecatcher and the
        ST   R13,PWA_HEAPID           | HeapID are for validity checks.
*---------------------------------------------------------------------*
*       Initialize the storage block and free-storage block lists.
*---------------------------------------------------------------------*
        LA   R1,PWA_STG_HDR           | Initialize the list header
        ST   R1,PWA_STG_HDR           | by pointing it to itself.
        ST   R1,PWA_STG               |
        LA   R1,PWA_FREE_HDR          | Initialize the list header
        ST   R1,PWA_FREE_HDR          | by pointing it to itself.
        ST   R1,PWA_FREE              |
*---------------------------------------------------------------------*
*       If the heap increment parameter is present, use it instead of
*       the default.  If it is invalid, the error exit is invoked, but
*       the memory manager is still in a useable state.
*---------------------------------------------------------------------*
        MVC PWA_INCREMENT,DFLT_INCREMENT | Set the minimum block size.
        IF  (NOT,(TBIT,PRM_ESV,X'80'))   | If increment parm present.
          L  R1,PRM_INCREMENT            |   R1 -> increment value.
          LA R1,0(,R1)                   |   Clear high-order bit.
          IF (TREG,R1,NZ)                |   If parameter not missing.
            L  R1,0(,R1)                 |     R1 := Heap increment.
            ERREXIT ((TREG,R1,M),OR,(C,R1,GT,MAX_INCREMENT)),          +
               CODE=&MM_INVALID_INCREMENT
            IF (TREG,R1,NZ)              |     If not zero.
              ST   R1,PWA_INCREMENT      |       Save increment size.
            ENDIF                        |     EndIf.
          ENDIF                          |   EndIf.
        ENDIF                            | EndIf
*---------------------------------------------------------------------*
*       If the increment is an even-multiple of a page, use page-
*       boundary for storage-block allocations.  Otherwise, use
*       doubleword boundaries.
*---------------------------------------------------------------------*
        LA R2,&ES_DOUBLEWORD_BOUNDARY    | Default boundary.
        XR R0,R0                         | Clear for division instr.
        L  R1,PWA_INCREMENT              | R0 := remainder of increment
        D  R0,=A(&MM_PAGE_SIZE)          |       divided by page-size.
        IF (TREG,R0,Z),THEN              | If an even page-multiple.
          LA R2,&ES_PAGE_BOUNDARY        |   Use page alignment.
        ENDIF                            | EndIf.
        ST  R2,PWA_BOUNDARY              | Save selected boundary.
*---------------------------------------------------------------------*
*       If the location parameter is present, use it instead of the
*       default.
*---------------------------------------------------------------------*
        LA R2,&ES_LOCATION_ANY           | Set the default location.
        IF (NOT,((TBIT,PRM_ESV,X'80'),OR,(TBIT,PRM_INCREMENT,X'80')))
          L  R1,PRM_LOCATION             |   R1 -> location value.
          LA R1,0(,R1)                   |   Clear high-order bit.
          IF ((TREG,R1,NZ),AND,(CLC,=F'0',NE,0(R1)))
            ICM R2,15,0(R1)              |     Use instead of default
          ENDIF                          |   EndIf.
        ENDIF                            | EndIf
        ST   R2,PWA_LOCATION             | Save location.
        CASEBLK REG=R2,MULT=1
          CASE &ES_LOCATION_BELOW,&ES_LOCATION_ANY
          CASE OTHER
            ERREXIT CODE=&MM_INVALID_LOCATION
        ENDCASE
*---------------------------------------------------------------------*
*       If all parameters have checked-out, indicate memory is okay.
*---------------------------------------------------------------------*
        SBIT PWA_F_USEABLE            | Indicate Memory Manager is ok.
     EJECT
***********************************************************************
*                                                                     *
*    Destroy an existing memory heap.                                 *
*                                                                     *
***********************************************************************
     CASE &TERMINATE
*---------------------------------------------------------------------*
*       Free each block of storage and its associated descriptor.  Then
*       wipe out the integrity-checking data in the PWA so that if the
*       HeapID (which is really the PWA base) is used again, it will be
*       recognized as a garbage pointer before getting us into deep
*       trouble.
*---------------------------------------------------------------------*
        L      R10,PWAAESV            |
        USING  ESV,R10                |
        L      R3,PWA_STG_HDR         | Point to 1st storage block
        USING  STG_BLOCK,R3           |   and establish addressability.
        LOOP   WHILE,(C,R3,NE,PWA_STG)
          L    R4,STG_LINK            |   Save address of next block.
          L24  R1,STG_SIZE            |   Get free storage parameters.
          ST   R1,PWA_WORK            |
          CALLX ESVESEPA,(ESVESTKN,&ES_RELEASE_STORAGE,PWA_WORK,0,     +
               STG_ADDR)
          ST   R3,PWA_WORK
          CALLX ESVESEPA,(ESVESTKN,&ES_RELEASE_STORAGE,=A(STG_BLOCK_L),+
               0,PWA_WORK)
          LR   R3,R4                  |   Point to next block in list.
        ENDLOOP WHILE                 | EndLoop.
        DROP    R3,R10                |
*                                     |
        XC   PWA_VISUAL,PWA_VISUAL    | Insure that the PWA cannot be
        XC   PWA_HEAPID,PWA_HEAPID    | accidentally used again.
*                                     |
        SMCTRL FREEPWA=YES            | Free the PWA.
     EJECT
***********************************************************************
*                                                                     *
*    Allocate some memory.                                            *
*                                                                     *
***********************************************************************
     CASE &MM_OBTAIN_STORAGE
*---------------------------------------------------------------------*
*       Verify that the parameters BYTES and ADDRESS were provided
*       and that BYTES is a reasonable number.  Put BYTES in R3.
*---------------------------------------------------------------------*
        ERREXIT ((TBIT,PRM_FUNCTIONCODE,X'80'),OR,                     +
               (TBIT,PRM_BYTES,X'80'),OR,                              +
               (NOT,(TBIT,PRM_ADDRESS,X'80'))),                        +
               CODE=&MM_INVALID_PARM_COUNT
        L       R3,PRM_BYTES          | Point R3 to BYTES parameter.
        L       R3,0(,R3)             | Load up the value.
        ERREXIT ((TREG,R3,NP),OR,(C,R3,GT,MAX_BYTES)),                 +
               CODE=&MM_INVALID_SIZE
        A       R3,=F'7'              | Round the request up to an
        N       R3,=X'FFFFFFF8'       |   eight-byte boundary.
*---------------------------------------------------------------------*
*       Search the free-storage list for a block large enough to
*       satisfy the request.
*---------------------------------------------------------------------*
        L     R6,PWA_FREE             | Initialize previous node addr.
        L     R4,PWA_FREE_HDR         | Point to 1st free-stg element
        USING FREE_BLOCK,R4           | and establish addressability.
        LOOP  WHILE,(C,R4,NE,PWA_FREE)  Loop over free-storage list.
          EDC   FREE,CHECK            |   Check error detection code.
          LEAVE LOOP=*,(CLM,R3,B'0111',LE,FREE_SIZE)
          LR    R6,R4                 |   Save as the previous node.
          L     R4,FREE_LINK          |   Point to next element.
        ENDLOOP WHILE                 | EndLoop.
*---------------------------------------------------------------------*
*       If none is found, then allocate a new storage block and create
*       a single free-storage element for it.
*---------------------------------------------------------------------*
        IF (C,R4,EQ,PWA_FREE)         | If no free-stg element found...
          L       R10,PWAAESV         |
          USING   ESV,R10             |
          CALLX   ESVESEPA,(ESVESTKN,&ES_OBTAIN_STORAGE,               +
               =A(STG_BLOCK_L),0,&ES_DOUBLEWORD_BOUNDARY,              +
               &ES_LOCATION_ANY,PWA_WORK)
          ERREXIT (C,R15,EQ,=A(&ES_STORAGE_NOT_AVAILABLE)),            +
               CODE=&MM_STORAGE_NOT_AVAILABLE
          ERREXIT (TREG,R15,NZ),CODE=&MM_UNKNOWN_ERROR
          L       R5,PWA_WORK         |   Establish addressability on
          USING   STG_BLOCK,R5        |     the storage descriptor.
          MVC     STG_LINK,PWA_STG_HDR    Insert the new descriptor in
          ST      R5,PWA_STG_HDR      |     front of the list.
          LR      R2,R3               |   R2 := Size block to allocate.
          IF (C,R2,LT,PWA_INCREMENT)  |   If minimum size larger then
            L  R2,PWA_INCREMENT       |     Use the minimum block size.
          ENDIF                       |   Endif.
          ST      R2,PWA_WORK         |
          CALLX   ESVESEPA,(ESVESTKN,&ES_OBTAIN_STORAGE,PWA_WORK,0,    +
               PWA_BOUNDARY,PWA_LOCATION,STG_ADDR)
          ERREXIT (C,R15,EQ,=A(&ES_STORAGE_NOT_AVAILABLE)),            +
               CODE=&MM_STORAGE_NOT_AVAILABLE
          ERREXIT (TREG,R15,NZ),CODE=&MM_UNKNOWN_ERROR
          L       R4,STG_ADDR         |   Establish addr on Free_block.
          STCM    R2,7,STG_SIZE       |   Save the block's total size.
          MVC     FREE_LINK,PWA_FREE_HDR  Link the new free block in
          ST      R4,PWA_FREE_HDR     |     front and make it equal to
          MVC     FREE_SIZE,STG_SIZE  |     the entire storage block.
          L       R6,PWA_FREE         |   Set previous node addr.
          EDC     STG,SET             |   Set the Error Detection Code.
          DROP    R5,R10              |   Clean up addressability.
        ENDIF                         | EndIf
*---------------------------------------------------------------------*
*       Obtain memory for the user out of the located/created
*       free-storage element, insuring that it is aligned okay.  When
*       finished, R4 will point to the user's storage and not to a
*       free_block element.
*---------------------------------------------------------------------*
        L24     R5,FREE_SIZE          | R5 := number of bytes after
        SR      R5,R3                 |   user's chunk carved out.
        IF      (C,R5,GE,=F'8'),THEN  | If enough left to keep block
          STCM  R5,7,FREE_SIZE        |   then save amount left.
          EDC   FREE,SET              |   Set the Error Detection Code.
          LA    R4,FREE_BLOCK(R5)     |   Point to user's storage.
        ELSE                          | Else remove entire free_block.
          MVC   FREE_LINK-FREE_BLOCK(L'FREE_LINK,R6),FREE_LINK
          DROP  R4                    | Clean up on addressability.
          IF    (C,R6,NE,PWA_FREE)    | If previous not equal header.
            USING FREE_BLOCK,R6       |   Establish addressability.
            EDC   FREE,SET            |   Set the Error Detection Code.
            DROP  R6                  |   Clean up addressability.
          ENDIF                       |   EndIf.
        ENDIF                         | EndIf.
*                                     |
        LR   R14,R4                   | R14 := address of user's stg.
        LR   R15,R3                   | R15 := length of user's stg.
        LOOP WHILE,(C,R15,GE,=F'256') | Loop over large chunks.
          XC  0(256,R14),0(R14)       |   Clear out the chunk of stg.
          LA  R14,256(,R14)           |   Advance to the next chunck.
          S   R15,=F'256'             |   Adjust remaining length.
        ENDLOOP WHILE                 | EndLoop.
        IF (TREG,R15,P),THEN          | If anything left, then.
          BCTR R15,0                  |   Subtract 1 for EX instr.
          EXI  R15,(XC,0(0,R14),0(R14))   Clear out remaining stg.
        ENDIF                         | EndIf.
*                                     |
        L       R1,PRM_ADDRESS        | Point to user's ADDRESS parm
        ST      R4,0(,R1)             |   and save the new storage.
   EJECT
***********************************************************************
*                                                                     *
*    Free some memory.
*                                                                     *
***********************************************************************
     CASE &MM_RELEASE_STORAGE
*---------------------------------------------------------------------*
*       Verify that the parameters BYTES and ADDRESS were provided
*       and that they are reasonable numbers.  Put ADDRESS in R4 and
*       ADDRESS + BYTES in R3.
*---------------------------------------------------------------------*
        ERREXIT ((TBIT,PRM_FUNCTIONCODE,X'80'),OR,                     +
               (TBIT,PRM_BYTES,X'80'),OR,                              +
               (NOT,(TBIT,PRM_ADDRESS,X'80'))),                        +
               CODE=&MM_INVALID_PARM_COUNT
        L       R3,PRM_BYTES          | Point R3 to BYTES parameter.
        L       R3,0(,R3)             | R3 := BYTES.
        ERREXIT ((TREG,R3,NP),OR,(C,R3,GT,MAX_BYTES)),                 +
               CODE=&MM_INVALID_SIZE
        A       R3,=F'7'              | Round the request up to an
        N       R3,=X'FFFFFFF8'       |   eight-byte boundary.
        L       R4,PRM_ADDRESS        | Point R4 to ADDRESS parameter.
        L       R4,0(,R4)             | R4 := ADDRESS.
        LA      R4,0(,R4)             | Clear high-order bit/byte.
        LR      R0,R4                 |
        N       R0,=F'7'              | R0 := low-order 3 bits of addr.
        ERREXIT (TREG,R0,NZ),CODE=&MM_INVALID_ALIGNMENT
        LA      R2,0(R3,R4)           | R2 := ADDRESS + BYTES.
*---------------------------------------------------------------------*
*       Loop over the PWA_STG to insure that the storage to be
*       freed is completely within one of the storage blocks owned by
*       this heap.  It must start and end within the bounds of one of
*       the blocks. If it partially overlaps a block or is not within
*       a block, then end in error.
*---------------------------------------------------------------------*
        L     R5,PWA_STG_HDR          | Point R5 to the 1st STG_BLOCK
        USING STG_BLOCK,R5            | and establish addressability.
        LOOP  WHILE,(C,R5,NE,PWA_STG) | Loop over STG_BLOCK list.
          EDC STG,CHECK               |   Check the Error code.
          L24 R6,STG_SIZE             |   R6 := STG_ADDR + STG_SIZE.
          A   R6,STG_ADDR             |   If new stg starts w/in block
          IF  ((C,R4,GE,STG_ADDR),AND,(CR,R4,LT,R6)),THEN
            ERREXIT (CR,R2,GT,R6),CODE=&MM_MEMORY_NOT_IN_HEAP
            LEAVE LOOP=*              |     Storage is non-overlapping
          ENDIF                       |   EndIf.
          L   R5,STG_LINK             | Point to next STG_BLOCK.
        ENDLOOP WHILE                 | EndLoop.
        ERREXIT (C,R5,EQ,PWA_STG),CODE=&MM_MEMORY_NOT_IN_HEAP
*---------------------------------------------------------------------*
*       Loop over the list of free storage blocks to insure that the
*       storage to be freed does not overlap any of the existing free
*       storage blocks.  While at it, check for free blocks in the same
*       STG_BLOCK that are adjacent to the beginning or the end of the
*       storage being released and check the error detection code of
*       each free storage block examined.
*---------------------------------------------------------------------*
        MVC   PWA_ADJ_BEFORE,=F'0'    | Initially, no free storage
        MVC   PWA_ADJ_AFTER,=F'0'     | blocks known to be adjacent.
        L     R7,PWA_FREE_HDR         | Point to 1st free storage block
        USING FREE_BLOCK,R7           |   and establish addressability.
        L     R8,PWA_FREE             | R8 points to previous block.
        LOOP  WHILE,(C,R7,NE,PWA_FREE)  Loop over the free storage list
          EDC   FREE,CHECK            |   Check Error Detection Code.
          L24   R1,FREE_SIZE          |
          AR    R1,R7                 |   R1 := FREE_ADDR + FREE_SIZE
          ERREXIT (((CR,R4,GE,R7),AND,(CR,R4,LT,R1)),OR,               +
               ((CR,R2,GT,R7),AND,(CR,R2,LE,R1))),                     +
               CODE=&MM_MEMORY_NOT_ALLOCATED
          IF (C,R7,GE,STG_ADDR),AND,(CR,R1,LT,R6)  If in STG_BLOCK.
            IF (CR,R1,EQ,R4)          |        If adjacent before.
              ST  R7,PWA_ADJ_BEFORE   |          Remember this block.
            ELSEIF (CR,R2,EQ,R7)      |        ElseIf adjacent after.
              ST  R7,PWA_ADJ_AFTER    |          Remember this block
              ST  R8,PWA_ADJ_PREV     |          and previous block.
            ENDIF                     |        EndIf.
          ENDIF                       |      EndIf
          LR    R8,R7                 |      R8 -> Previous block.
          L     R7,FREE_LINK          |      R7 -> New current block.
        ENDLOOP WHILE                 | EndLoop
        DROP    R7                    | FREE_BLOCK
        DROP    R5                    | STG_BLOCK
*---------------------------------------------------------------------*
*       If there was a free block adjacent to the end of the storage
*       being released, pull the existing block out of the free-chain
*       and update the total size being released.
*---------------------------------------------------------------------*
        IF    (CLC,PWA_ADJ_AFTER,NE,=F'0'),THEN
          L     R7,PWA_ADJ_AFTER      | Go to the adjacent block ...
          USING FREE_BLOCK,R7         |   Establish addressability.
          L24   R1,FREE_SIZE          |   Get its size and add it to
          AR    R3,R1                 |   the total size being freed.
          L     R1,FREE_LINK          |   Get the link.
          L     R7,PWA_ADJ_PREV       | Point to the previous block...
          ST    R1,FREE_LINK          |   Update its linkage.
          IF    (C,R7,NE,PWA_FREE)    |   If not pointing to the hdr.
            EDC   FREE,SET            |     Update its Error Detection.
          ENDIF                       |   EndIf.
          DROP  R7                    |   Clean up addressability.
        ENDIF                         | EndIf
*---------------------------------------------------------------------*
*       If there was a free block adjacent to the beginning of the
*       storage being released, merge the two, updating the size.
*       Otherwise, create a new free block for the released storage
*       and insert it in front of the free-storage list.
*---------------------------------------------------------------------*
        USING FREE_BLOCK,R4           |   Establish addressability.
        IF    (CLC,PWA_ADJ_BEFORE,NE,=F'0'),THEN
          L     R4,PWA_ADJ_BEFORE     |   Point to the adjacent block
          L24   R1,FREE_SIZE          |   Get the size into a register
          AR    R3,R1                 |   and add the size being freed.
        ELSE                          | Else
          L     R1,PWA_FREE_HDR       |   Get link to 1st block.
          ST    R4,PWA_FREE_HDR       |   Replace w/link to new block.
          ST    R1,FREE_LINK          |   Set link to the next block.
        ENDIF                         | EndIf
*                                     |
        STCM  R3,7,FREE_SIZE          | Update with the new size.
        EDC   FREE,SET                | Set the Error Detection Code.
        DROP  R4                      | Clean up addressability.
*---------------------------------------------------------------------*
*       Since the storage is not allocated, wipe the caller's pointer.
*---------------------------------------------------------------------*
        L     R1,PRM_ADDRESS          | R1 -> Caller's pointer to stg.
        XC    0(4,R1),0(R1)           | Clear it to zeros.
   EJECT
***********************************************************************
*                                                                     *
*  Reset the heap but retain all getmained storage.                   *
*                                                                     *
***********************************************************************
     CASE &MM_RESET_HEAP
*---------------------------------------------------------------------*
*       Set the free-list to empty.
*---------------------------------------------------------------------*
        LA   R1,PWA_FREE_HDR          | Initialize the list header
        ST   R1,PWA_FREE_HDR          | by pointing it to itself.
        ST   R1,PWA_FREE              |
*---------------------------------------------------------------------*
*       Run the storage blocks, adding each as a free-element.
*---------------------------------------------------------------------*
        L      R3,PWA_STG_HDR         | Point to 1st storage block
        USING  STG_BLOCK,R3           | and establish addressability.
        LOOP   WHILE,(C,R3,NE,PWA_STG)  Loop over storage blocks.
          EDC     STG,CHECK           |   Check the Error code.
          USING   FREE_BLOCK,R4       |   Make it a free_block.
          L       R4,STG_ADDR         |   R4 -> storage block.
          MVC     FREE_LINK,PWA_FREE_HDR  Link the new free block in
          ST      R4,PWA_FREE_HDR     |   front and make it equal to
          MVC     FREE_SIZE,STG_SIZE  |   the entire storage block.
          EDC     FREE,SET            |   Set the Error Detection Code.
          DROP    R4                  |   Drop free_block addressing.
          L       R3,STG_LINK         |   Point to next block in list.
        ENDLOOP WHILE                 | EndLoop.
        DROP    R3                    | Drop storage-block addressing.
   EJECT
***********************************************************************
*                                                                     *
*    Invalid Function Code.                                           *
*                                                                     *
***********************************************************************
     CASE OTHER                       |
        ERREXIT CODE=&MM_INVALID_FUNCTION
   ENDCASE                            |
*                                     |
 ENDBLK BLOCK=&srv_modname,RC=0       |
*
***********************************************************************
*                                                                     *
*  Exit with a return code equal to the code passed in.               *
*                                                                     *
***********************************************************************
 BLOCK TYPE=ERREXIT
*---------------------------------------------------------------------*
*  Save module/offset, registers, return-code.
*---------------------------------------------------------------------*
   ST    R15,PWA_REASON          | Save possible return-code.
   STM   R0,R15,GDIREGS          | Save registers at time of error.
   SM_LAL R0,&srv_modname+4      | Point to module identification.
   ST    R0,GDIMODID             | Save in general debug area.
   MVC   GDIRC,0(R14)            | Copy return code.
   SL    R14,=A(&srv_modname)    | Calculate offset at time of error.
   STH   R14,GDIOFFST            | Save in debug area.
   L     R2,PWAAESV              |
   USING ESV,R2                  |
   CALLX ESVESEPA,(ESVESTKN,&ES_SAVE_DEBUG_INFO,&ES_DEBUG_ID_GDI,GDI)
*---------------------------------------------------------------------*
*  Look at the error code.  Some errors imply that the memory manager
*  has lost its cookies and should not attempt to do anything other
*  than shut-down (if it can even do that).
*---------------------------------------------------------------------*
   LH    R15,GDIRC               | Get return code.
   CASEBLK REG=R15,MULT=1        | Case on return-code.
     CASE &MM_UNKNOWN_ERROR,&MM_NOT_USEABLE
       RBIT  PWA_F_USEABLE       |   Indicate memory manager unsafe.
       CALLX ESVESEPA,(ESVESTKN,&ES_SAVE_DEBUG_INFO,                   +
               &ES_DEBUG_ID_HEX,PWA_REASON,4,'REASON',6)
     CASE &MM_CORRUPT_STORAGE    |
       RBIT  PWA_F_USEABLE       |   Indicate memory manager unsafe.
       MVC  PWA_REASON,GDIRC     |   Remember reason it can't be used.
     CASE OTHER                  |   Don't bother w/other errors.
   ENDCASE                       | EndCase.
   DROP  R2                      |
*---------------------------------------------------------------------*
*  Set the return-code and exit.
*---------------------------------------------------------------------*
   LH    R15,GDIRC               | Set return code.
 ENDBLK
 EJECT
*---------------------------------------------------------------------*
*
*  Static Data
*
*---------------------------------------------------------------------*
                PSD
EYECATCHER      DC   CL8'MEMORY'      | Eyecatcher value for dumps.
DFLT_INCREMENT  DC   F'4096'          | Default minimum block size.
MAX_INCREMENT   DC   F'16777215'      | Largest possible increment.
MAX_BYTES       DC   F'16777215'      | Maximum allowed size for
*                                     | allocation -- limited by the
*                                     | data structures to a maximum of
*                                     | 16777215 bytes.
                LTORG
                ENDPSD
                EJECT
*-----m---------------------------------------------------------------*
*
*  Program Work Area
*
*---------------------------------------------------------------------*
               PWA
PWA_AREA       DS    0F               | Beginning of visible PWA stg.
PWA_VISUAL     DS    CL8              | Character string 'MEMORY'.
PWA_F          DS    X                | Flags for memory manager.
PWA_F_USEABLE  EQU   X'80'            | Memory manager is useable.
PWA_HEAPID     DS    A                | Unique heap identifier.
PWA_INCREMENT  DS    A                | Minimum block size.
PWA_BOUNDARY   DS    A                | Doubleword/page for stg_blocks.
PWA_LOCATION   DS    A                | Above/below the 16M line.
PWA_STG        DS    A                | Address of PWA_STG_HDR.
PWA_STG_HDR    DS    A                | List of STG_BLOCK elements.
PWA_FREE       DS    A                | Address of PWA_FREE_HDR.
PWA_FREE_HDR   DS    A                | List of free_storage elements.
PWA_ADJ_BEFORE DS    A                | Free_block's adjacent to the
PWA_ADJ_AFTER  DS    A                |   storage being released.
PWA_ADJ_PREV   DS    A                | Block previous to PWA_ADJ_AFTER
PWA_WORK       DS    F                | Fullword work area.
               ORG   PWA_WORK         |
PWA_WORK_H1    DS    H                | Halfword work area 1.
PWA_WORK_H2    DS    H                | Halfword work area 2.
               ORG   PWA_WORK         |
PWA_WORK_B1    DS    X                | Byte work area 1.
PWA_WORK_B2    DS    X                | Byte work area 2.
               ORG   ,                |
PWA_REASON     DS    F                | Reason memory manager died.
               ES_GDI DSECT=NO        | General debugging information.
PWA_AREA_L     EQU   *-PWA_AREA       | Length of visible PWA stg.
               ENDPWA
               EJECT
*---------------------------------------------------------------------
*
*  Storage description DSECTs.
*
*---------------------------------------------------------------------
STG_BLOCK     DSECT                   | Storage block Descriptor
STG_LINK      DS     A                | Link to next STG_BLOCK.
STG_ADDR      DS     A                | Address of storage block.
STG_EDC       DS     X                | Error Detection Code.
STG_SIZE      DS     FL3              | Total size of allocated block.
STG_BLOCK_L   EQU    *-STG_BLOCK      | Length of descriptor.
*
FREE_BLOCK    DSECT                   | Describes a free storage area.
FREE_LINK     DS     A                | Pointer to next free storage.
FREE_EDC      DS     X                | Error Detection Code.
FREE_SIZE     DS     FL3              | Size of free storage area.
              EJECT
*---------------------------------------------------------------------
*  Parameter list for the memory server.
*---------------------------------------------------------------------
PARMLIST          DSECT              |
PRM_HEAPID        DS  A              | Heap identifier === PWA base
PRM_FUNCTIONCODE  DS  A              | Function to be performed
PRM_FUNCTION_DEPT EQU *              | Function-dependent parameters
PRM_ESV           DS  A              | Environment Support Vector.
PRM_INCREMENT     DS  A              | Heap increment size.
PRM_LOCATION      DS  A              | Location of obtained storage.
                  ORG PRM_FUNCTION_DEPT
PRM_BYTES         DS  A              | Bytes to allocate/free
PRM_ADDRESS       DS  A              | Address allocated/to be freed
*---------------------------------------------------------------------
*  Environment support vector mapping dsect.
*---------------------------------------------------------------------
                  ES_ESV
                  END
