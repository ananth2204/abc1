*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
//SRVDTREX JOB TIME=(,4)
/*JOBPARM L=20
//IRXFUSER EXEC ASMPCL,PDS='SYS1.LPA2LIB',NAME=SRVDTREX,
//  COPT=',RENT',LOPT=',RENT,REUS,REFR'
//P.SYSIN  DD  *
  SMLIST CONVERT=YES                  |
DTSERVS  title "Function Table Definition Macro"
         macro                        |
         function_table &parm,&function=,&program=,&type='ADCON'
         gbla  &function_counter      |
         lcla  &pgmtype               |
         aif   ('&parm' eq 'start').start
         aif   ('&parm' eq 'end').end |
         aif   ('&parm' eq 'define').define
         mnote 8,"Unknown parameter of &PARM."
         mexit ,                      |
.start   anop  ,                      |
irxfuser csect ,                      | CSECT name of IRXFUSER
irxfuser amode 31                     |
irxfuser rmode any                    |
         dc    cl8'irxfuser'          | Eyecatcher of IRXFUSER
         dc    f'24'                  | Length of header
         dc    f'-1'                  | Number of rows (updated later)
         dc    f'0'                   | Reserved; must be zero
         dc    f'32'                  | Length of one entry
&function_counter seta  0             |
         mexit ,                      |
.define  anop  ,                      |
&function_counter seta &function_counter+1
         dc    cl8'&function'         | Name of function
         aif   ('&type' eq 'ADCON').setadcon
         aif   ('&type' eq 'VCON').setvcon
         aif   ('&type' eq 'LOAD').setload
         mnote 8,"Unknown program type of &TYPE."
         mexit ,                      |
.setadcon anop ,                      |
         dc    A(&program)            | Address of function routine
         dc    F'0'                   | Reserved
         dc    cl8' '                 | Do not issue a LOAD for it
         dc    cl8' '                 | No DDname for LOAD
         mexit ,                      |
.setvcon anop ,                       |
         dc    V(&program)            | VCON for function routine
         dc    F'0'                   | Reserved
         dc    cl8' '                 | Do not issue a LOAD for it
         dc    cl8' '                 | No DDname for LOAD
         mexit ,                      |
.setload anop ,                       |
         dc    F'0'                   | Empty address for function code
         dc    F'0'                   | Reserved
         dc    cl8'&program'          | Name to be LOADed
         dc    cl8' '                 | DDname to load routine from
         mexit ,                      |
.end     anop  ,                      |
         org   irxfuser+12            | ORG back to number of rows
         dc    f'&function_counter'   | Set number of rows
         org   ,                      |
         mexit ,                      |
         mend  ,                      |
         title "Define Function Table"
  function_table start                | Start the function table.
    function_table define,            |   Define DTSETUP as a VCON.    *
               function=DTSETUP,      |                                *
               program=DTSETUP,       |                                *
               type=VCON              |
    function_table define,            |   Define DATECNVT as a VCON.   *
               function=DATECNVT,     |                                *
               program=DATECNVT,      |                                *
               type=VCON              |
    function_table define,            |   Define TIMECNVT as a VCON.   *
               function=TIMECNVT,     |                                *
               program=TIMECNVT,      |                                *
               type=VCON              |
    function_table define,            |   Define DATEADD as a VCON.    *
               function=DATEADD,      |                                *
               program=DATEADD,       |                                *
               type=VCON              |
    function_table define,            |   Define TIMEADD as a VCON.    *
               function=TIMEADD,      |                                *
               program=TIMEADD,       |                                *
               type=VCON              |
    function_table define,            |   Define DATEDIFF as a VCON.   *
               function=DATEDIFF,     |                                *
               program=DATEDIFF,      |                                *
               type=VCON              |
  function_table end                  |
  TITLE "SRVDT Interface For Rexx Programs"
     print off                        |
     copy  srvdtmac                   |
     copy  smsyms                     |
     copy  srvesmac                   |
     print on,gen                     |
     eject                            |
*---------------------------------------------------------------------*
*
*  Copyright (C) 1992 Clemson University
*
*  Program     DATECNVT
*
*  Abstract    This routine acts as an interface to some basic Date/
*              Time Service Processor functions.
*
*  Inputs:
*      Parameters  R0 - Address of Rexx environment block;
*                       see SYS1.MACLIB(IRXENVB).
*                  R1 - Address of external function parmlist;
*                       see SYS1.MACLIB(IRXEFPL).
*                  Standard linkage otherwise.
*                  The EFPL points to the argument list, described by
*                  SYS1.MACLIB(IRXARGTB), and the evaluation block,
*                  described by SYS1.MACLIB(IRXEVALB).
*      Files       None.
*      Other       None.
*
*  Outputs:
*      Returncodes Zero - It worked
*                  Nonzero - It didn't work.
*      Messages    Text description of the SRVDT error will be stored
*                  in the function result area.
*      Files       None.
*      Other       Rexx variables set.
*
*  PROGRAM     Reentrant, problem key and state, standard linkage,
*  ATTRIBUTES  non-authorized, AMODE(31), RMODE(ANY)
*
*  Special     The functions supported and their call formats are:
*  Notes         Result = DTSETUP()
*                  .. Creates a bunch of Rexx variables to help out.
*                DateOut = DATECNVT(DateIn <,FormatIn <,FormatOut>>)
*                  .. Converts a date from one format to another.  The
*                     formatin and formatout parameters are optional.
*                     FormatIn defaults to DT_General_Input, while
*                     FormatOut defaults to DT_Normal.  A zero may be
*                     specified for either format as a placeholder.
*                TimeOut = TIMECNVT(TimeIn <,FormatIn <,FormatOut>>)
*                  .. Converts a time from one format to another.  The
*                     formats work like DATECNVT; the default FormatIn
*                     is DT_General_Input, while the default FormatOut
*                     is DT_Civilian.
*                DateOut = DATEADD(DateIn,Interval <,FormatIn
*                                  <,FormatIn2 <,FormatOut>>)
*                  .. Adds an interval value to a date value, producing
*                     a date value.  The default FormatIn is DT_General
*                     _Input, the default FormatIn2 is DT_Days, and the
*                     default FormatOut is DT_Normal.
*                Difference = DATEDIFF(Datein,Datein2 <,FormatIn
*                                     ,FormatIn2 <,FormatOut>>>)
*                  .. Produces the difference between two date values.
*                     The default input formats are DT_General_Input,
*                     while the default FormatOut is DT_Days.
*
*  Change
*  History     08/24/92 New - New
*              __/__/__ ___
*              __/__/__ ___
*
*  Method of   An entry stub passes the addresses of the EFPL and
*  Operation   ENVB, as well as the name of the function called, to
*              csect DTSERVS, which does all the hard stuff.  There
*              is an entry stub for each function.  These stubs are
*              at the end of the module;  this makes DTSERVS start at
*              location counter zero, which makes debugging easier.
*
*---------------------------------------------------------------------*
         EJECT                        |
         macro                        |
         set_immediate &text,&value   |
         lcla  &ltext,&lvalue         |
&ltext   seta  k'&text                |
&lvalue  seta  k'&value               |
         psd   type=partial           |
#txt&sysndx  dc  c'&text'             |
#val&sysndx  dc  c'&value'            |
         endpsd ,                     |
         callsub set_variable,        |                                *
               (#txt&sysndx,=F'&ltext',#val&sysndx,=F'&lvalue')
         mend                         |
         macro                        |
         set_variable &variable,&value,&len
         lcla  &ltext,&lvalue         |
&ltext   seta  k'&variable            |
         psd   type=partial           |
#txt&sysndx  dc  c'&variable'         |
         endpsd ,                     |
         callsub set_variable,        |                                *
               (#txt&sysndx,=F'&ltext',&value,&len)
         mend                         |
         macro                        |
  Validate_Packed_Data   &Data=,&Len=,&Type=DATE
.*--------------------------------------------------------------------*
.* Macro:      Validate_Packed_Data
.* Purpose:    Attempt to ensure packed-decimal input is valid and
.*             won't cause an 0C7.
.* Syntax:     Validate_Packed_Data Data=<RX address>,Len=<integer>
.* Notes:      The code generated by this macro uses R15, R1, and R2.
.*             If someone wants to make the macro smart enough to pick
.*             apart any form of RX address someday, the use of field
.*             pwa_packed_validation can be removed.
.*        ---> Don't use R15 to point to the input field: the macro
.*             wipes out the contents of R15.
.*             Thanks to John Fisher (FISHER@RPIECS) for the basic
.*             routine.
.*--------------------------------------------------------------------*
    gbla  &dt_invalid_input_date      | Globals for the errexit
    gbla  &dt_invalid_input_time      |
    gbla  &dt_invalid_input_interval  |
    lcla  &errcode                    | Local errexit code
.*--------------------------------------------------------------------*
  sr    r2,r2                         | Clear R2
  la    r15,pwa_packed_validation+&len.-1   | Get addr end of input
  mvc   pwa_packed_validation(&len.),&data  | Copy input to workarea
  trt   pwa_packed_validation(&len.),psd_packed_table | Check out data:
  cr    r1,r15                        | R1 should -> last byte: else,
  bne   inv&sysndx                    |  it's an error.
  b     *+4(r2)                       | If we got a hit, check it out.
  b     inv&sysndx                    | Byte of 00: no sign on it.
  b     inv&sysndx                    | Byte of 04: it's not valid.
  b     ok&sysndx                     | Byte of 08: it's a valid sign.
inv&sysndx ds 0h                      |
         aif   ('&type' ne 'DATE').chktime
&errcode seta  &dt_invalid_input_date |
         ago   .errex                 |
.chktime aif   ('&type' ne 'TIME').chkint
&errcode seta  &dt_invalid_input_time |
         ago   .errex                 |
.chkint  aif   ('&type' ne 'INTERVAL').badtype
&errcode seta  &dt_invalid_input_interval
         ago   .errex                 |
.badtype mnote 8,"Invalid data type of &TYPE.: must be DATE, TIME or IN*
               TERVAL".               |
         mexit                        |
.errex   anop                         |
  la    r15,&errcode                  |
  st    r15,pwa_dt_rc                 |
  callsub  dt_error                   | Generate error rtn. call
  b    xit&sysndx                     |
ok&sysndx  ds 0h                      |
  xr    r15,r15                       |
xit&sysndx ds 0h                      |
         mend                         |
         macro                        |
         tracemsg &text               |
         gblb  &dt_trace              |
         aif   (not &dt_trace).out    |
         tput  #tmsg&sysndx,l'#tmsg&sysndx
         b     #skip&sysndx           |
#tmsg&sysndx dc c&text                |
#skip&sysndx ds 0h                    |
.out     mexit                        |
         mend                         |
        title "Date/Time Services Interface"
**--------------------------------------------------------------------*
**
**  Date/Time Services interface.
**
**  On entry, R1 points to the following parameter list:
**    +0 - CL8'function name'   (e.g DATECNVT, etc)
**    +4 - Address of Rexx EFPL (the original R1 from Rexx's call)
**    +8 - Address of ENVBLOCK  (the original R0 from Rexx's call)
**
**--------------------------------------------------------------------*
          gblb  &dt_trace             |
&dt_trace setb  0                     | No messages ...
 block name=DTSERVS,type=program,     |                                *
               options=(*pwa,xa,loctr,long,noclearpwa),                *
               amode=31,rmode=any,    |                                *
               subopts=(*swa,loadbase),                                *
               r1save=r2              |
  es_id id=es,esva=pwa_esv_address,   |                                +
               spepa=pwa_es_epa,      |                                +
               sptoken=pwa_es_token   |
      space 1                         |
  dt_id id=DT,spepname=&DateTime_Services,                             *
               spepa=pwa_dt_epa,      |                                *
               sptoken=pwa_dt_token   |
  lm    r7,r9,0(r2)                   | Get address of EFPL, ENVBLOCK
  mvc   pwa_function_name,0(r7)       | Copy function name for later
  using efpl,r8                       | Base on EFPL
  using envblock,r9                   | Base on ENVBLOCK
  mvc   pwa_irxexte,envblock_irxexte  | Copy address of Rexx EXTE
  l     r6,efpleval                   | Point to evalblock address
  l     r6,0(,r6)                     | Load up the address
  using evalblock,r6                  |  and base on the evalblock.
* *------------------------------------------------------------------*
* *  Start service processors if necessary, then call function code.
* *-------------------------------------------------------------------*
  callsub start_service_processors    |
  if     (clc,pwa_function_name,eq,=c'DTSETUP ')
   callsub create_variables           |
  elseif (clc,pwa_function_name,eq,=c'DATECNVT')
   callsub convert_a_date             |
  elseif (clc,pwa_function_name,eq,=c'TIMECNVT')
   callsub convert_a_time             |
  elseif (clc,pwa_function_name,eq,=c'DATEADD ')
   callsub add_dates                  |
  elseif (clc,pwa_function_name,eq,=c'TIMEADD ')
   callsub add_times                  |
  elseif (clc,pwa_function_name,eq,=c'DATEDIFF')
   callsub date_difference            |
*
* elseif (clc,pwa_function_name,eq,=c'DATESUB ')  We can put these in
*  callsub subtract_dates             |           if the demand exists.
* elseif (clc,pwa_function_name,eq,=c'TIMESUB ')
*  callsub subtract_times             |
* elseif (clc,pwa_function_name,eq,=c'TIMEDIFF')
*  callsub time_difference            |
*
  endif                               |
* *-------------------------------------------------------------------*
  set_immediate  DT_RC,0              | If we got here, we did OK.
* *-------------------------------------------------------------------*
 callsub stop_service_processors      |
 endblk rc=0                          |
 title "Convert A Date Value"         |
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_A_Date
*  Abstract:   This subroutine calls SRVDT to convert a date value
*              to another format.
*  Inputs:     No parameters; the PWA contains variables that will
*              be used for conversion.
*  Outputs:    EVALBLOCK filled in with result.
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=convert_a_date,type=subroutine
  tracemsg "Convert_A_Date entered."  |
  l     r3,efplarg                    |
  using argtable_entry,r3             |
* *-------------------------------------------------------------------*
* * Set default formats.
* *-------------------------------------------------------------------*
  mvc   pwa_input_format,=a(&dt_general_input)  Default the input and
  mvc   pwa_output_format,=a(&dt_normal)        output date formats.
* *-------------------------------------------------------------------*
* * Parse function arguments;  there must be at least one.
* *-------------------------------------------------------------------*
  fill  pwa_input,c' '                | Clear field to receive arg
  callsub parse_argument,((r3),pwa_input,'C')   Copy text of input
  errexit name=function_error,(treg,r15,nz),    Wasn't one: complain.  *
               code=2,codereg=r14
  la    r3,argtable_next              |         Next argument ...
  callsub parse_argument,((r3),pwa_input_format,'V')  Get value
  if    (treg,r15,z)                  |         If there was one
   la    r3,argtable_next             |           Try for three
   callsub parse_argument,((r3),pwa_output_format,'V')  Get value
  endif                               | Finished with parsing input.
  drop  r3                            |
* *-------------------------------------------------------------------*
* * Special cases:  If incoming interval format is DT_NUMBER_OF_DAYS,
* * convert it to integer for SRVDT.
* *-------------------------------------------------------------------*
  callsub convert_date_formats,(pwa_input,pwa_input_format)
* *-------------------------------------------------------------------*
* * Call DT_CONVERT and see what happens.
* *-------------------------------------------------------------------*
  fill  pwa_result,c' '               |
  DT_Convert  ID=DT,Fromdate=(pwa_input,pwa_input_format),             *
               Todate=(pwa_result,pwa_output_format)
  if    (treg,r15,nz)                 |
   st    r15,pwa_dt_rc                |
   callsub dt_error                   |
   leave block=*                      |
  endif                               |
* *-------------------------------------------------------------------*
* * Special case:  DT_Number_Of_Days is handy, but SRVDT only supports
* * it in a binary format.  Convert it to zoned decimal.
* *-------------------------------------------------------------------*
  if    (clc,pwa_output_format,eq,=a(&DT_Number_Of_Days)) If #_Of_Days
   l     r1,pwa_result                |  Result is a fullword value
   cvd   r1,pwa_d                     |  Convert to packed
   unpk  pwa_result(7),pwa_d          |  Doesn't need to be pretty
   oi    pwa_result+6,x'f0'           |  Don't forget last byte
  endif                               |
* *-------------------------------------------------------------------*
* * Scan from end of pwa_result looking for 1st non-blank, then pass
* * the resulting field length and text back to Rexx.
* *-------------------------------------------------------------------*
  la    r14,pwa_result+l'pwa_result-1 | Point to end of result string
  la    r1,l'pwa_result               | Load up its length
  loop  bct                           |
   leave loop=*,(cli,0(r14),ne,c' ')  |
   bctr  r14,0                        |
  endloop bct,r1                      |
  st    r1,evalblock_evlen            | Save result's len in EvalBlock
  bctr  r1,0                          |
  exi   r1,(mvc,evalblock_evdata(0),pwa_result)  Set result.
 endblk                               |
 title "Convert A Time Value"         |
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_A_Time
*  Abstract:   This subroutine calls SRVDT to convert a time value
*              to another format.
*  Inputs:     No parameters; the PWA contains variables that will
*              be used for conversion.
*  Outputs:    EVALBLOCK filled in with result.
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=convert_a_time,type=subroutine
  tracemsg "Convert_A_Time entered."  |
  l     r3,efplarg                    | Point to 1st Argtable entry
  using argtable_entry,r3             |
* *-------------------------------------------------------------------*
* * Set default formats.
* *-------------------------------------------------------------------*
  mvc   pwa_input_format,=a(&dt_general_input)  Default the input and
  mvc   pwa_output_format,=a(&dt_civilian)      output date formats.
* *-------------------------------------------------------------------*
* * Parse function arguments;  there must be at least one.
* *-------------------------------------------------------------------*
  fill  pwa_input,c' '                |
  callsub parse_argument,((r3),pwa_input,'C')  Get its address
  errexit name=function_error,(treg,r15,nz),                           *
               code=3,codereg=r14
   la    r3,argtable_next             |
  callsub parse_argument,((r3),pwa_input_format,'V')  Get its value
  if    (treg,r15,z)                  | If we got one
   la    r3,argtable_next             |
   callsub parse_argument,((r3),pwa_output_format,'V') Get its value.
  endif                               |
  drop  r3                            |
* *-------------------------------------------------------------------*
* * Special cases:  If incoming interval format is DT_HUNDREDTHS,
* * DT_SECONDS, DT_MINUTES, DT_HOURS or DT_DAYS, pack it and use
* * DT_PHUNDREDTHS, etc. internally.
* *-------------------------------------------------------------------*
  callsub convert_interval_formats,(pwa_input2,pwa_input_format2)
* *-------------------------------------------------------------------*
* * Call DT_CONVERT and see what happens.
* *-------------------------------------------------------------------*
  fill  pwa_result,c' '               | Swab the decks first
  DT_Convert  ID=DT,Fromtime=(pwa_input,pwa_input_format), Convert it  *
               Totime=(pwa_result,pwa_output_format) or tell me why not
  if    (treg,r15,nz)                 | Bad value, huh?
   st    r15,pwa_dt_rc                |
   callsub dt_error                   |  Go set result to error msg
   leave block=*                      |   and get out.
  endif                               |
* *-------------------------------------------------------------------*
* * Special case:  DT_Hundredths is handy, but SRVDT only supports
* * it in a binary format.  Convert it to zoned decimal.
* *-------------------------------------------------------------------*
  if    (clc,pwa_output_format,eq,=a(&DT_Hundredths)) If DT_100'ths
   l     r1,pwa_result                |  Result is a fullword value
   cvd   r1,pwa_d                     |  Convert to packed
   unpk  pwa_result(7),pwa_d          |  Doesn't need to be pretty
   oi    pwa_result+6,x'f0'           |  Don't forget last byte
  endif                               |
* *-------------------------------------------------------------------*
* * Scan from end of pwa_result looking for 1st non-blank, then pass
* * the resulting field length and text back to Rexx.
* *-------------------------------------------------------------------*
  la    r14,pwa_result+l'pwa_result-1 | We gotta tell Rexx how long the
  la    r1,l'pwa_result               |  answer is ...
  loop  bct                           |
   leave loop=*,(cli,0(r14),ne,c' ')  |
   bctr  r14,0                        |
  endloop bct,r1                      |
  st    r1,evalblock_evlen            | Save result's len in EvalBlock
  bctr  r1,0                          |
  exi   r1,(mvc,evalblock_evdata(0),pwa_result)  Set result.
 endblk                               |
 title "Add Two Date Values"          |
*---------------------------------------------------------------------*
*
*  Subroutine: Add_Dates
*  Abstract:   This subroutine calls SRVDT to add an interval to a
*              date value.
*  Inputs:     No parameters; the PWA contains variables that will
*              be used for conversion.
*  Outputs:    EVALBLOCK filled in with result.
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=add_dates,type=subroutine |
  tracemsg "Add_Dates entered."       |
  l     r3,efplarg                    | Point to 1st Argtable entry
  using argtable_entry,r3             |
* *-------------------------------------------------------------------*
* * Set default formats.
* *-------------------------------------------------------------------*
  mvc   pwa_input_format,=a(&dt_general_input)  Default the input and
  mvc   pwa_input_format2,=a(&dt_general_input)   input and output
  mvc   pwa_output_format,=a(&dt_normal)            date formats.
* *-------------------------------------------------------------------*
* * Parse function arguments;  there must be at least two.
* *-------------------------------------------------------------------*
  callsub parse_argument,((r3),pwa_input,'C')  Get its address
  errexit name=function_error,(treg,r15,nz),                           *
               code=4,codereg=r14
  la    r3,argtable_next              |
  fill  pwa_input2,c' '               |
  callsub parse_argument,((r3),pwa_input2,'C')
  errexit name=function_error,(treg,r15,nz),                           *
               code=5,codereg=r14
  la    r3,argtable_next              |
  callsub parse_argument,((r3),pwa_input_format,'V')  Get its value
  if    (treg,r15,z)                  | If we got one
   la    r3,argtable_next             |
   callsub parse_argument,((r3),pwa_input_format2,'V') Get value.
   if    (treg,r15,z)                 | If we got one
    la    r3,argtable_next            |
    callsub parse_argument,((r3),pwa_output_format,'V') Get value.
   endif                              |
  endif                               |
  drop  r3                            |
* *-------------------------------------------------------------------*
* * Special cases:  If incoming interval format is DT_HUNDREDTHS,
* * DT_SECONDS, DT_MINUTES, DT_HOURS or DT_DAYS, pack it and use
* * DT_PHUNDREDTHS, etc. internally.
* *-------------------------------------------------------------------*
  callsub convert_interval_formats,(pwa_input2,pwa_input_format2)
* *-------------------------------------------------------------------*
* * Now, call SRVDT.
* *-------------------------------------------------------------------*
  fill  pwa_result,c' '               | Swab the decks first
  DT_Add      ID=DT,Datein=(pwa_input,pwa_input_format),               *
               Interval=(pwa_input2,pwa_input_format2),                *
               Dateout=(pwa_result,pwa_output_format)
  if    (treg,r15,nz)                 | Bad value, huh?
   st    r15,pwa_dt_rc                |
   callsub dt_error                   |  Go set result to error msg
   leave block=*                      |   and get out.
  endif                               |
* *-------------------------------------------------------------------*
* * Special case:  DT_Hundredths is handy, but SRVDT only supports
* * it in a binary format.  Convert it to zoned decimal.
* *-------------------------------------------------------------------*
  if    (clc,pwa_output_format,eq,=a(&DT_Number_Of_Days)) If #_of_Days
   l     r1,pwa_result                |  Result is a fullword value
   cvd   r1,pwa_d                     |  Convert to packed
   unpk  pwa_result(7),pwa_d          |  Doesn't need to be pretty
   oi    pwa_result+6,x'f0'           |  Don't forget last byte
  endif                               |
* *-------------------------------------------------------------------*
* * Scan from end of pwa_result looking for 1st non-blank, then pass
* * the resulting field length and text back to Rexx.
* *-------------------------------------------------------------------*
  la    r14,pwa_result+l'pwa_result-1 | We gotta tell Rexx how long the
  la    r1,l'pwa_result               |  answer is ...
  loop  bct                           |
   leave loop=*,(cli,0(r14),ne,c' ')  |
   bctr  r14,0                        |
  endloop bct,r1                      |
  st    r1,evalblock_evlen            | Save result's len in EvalBlock
  bctr  r1,0                          |
  exi   r1,(mvc,evalblock_evdata(0),pwa_result)  Set result.
 endblk                               |
 title "Add Two Time Values"          |
*---------------------------------------------------------------------*
*
*  Subroutine: Add_Times
*  Abstract:   This subroutine calls SRVDT to add an interval to a
*              time value.
*  Inputs:     No parameters; the PWA contains variables that will
*              be used for conversion.
*  Outputs:    EVALBLOCK filled in with result.
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=add_times,type=subroutine |
  tracemsg "Add_Times entered."       |
  l     r3,efplarg                    | Point to 1st Argtable entry
  using argtable_entry,r3             |
* *-------------------------------------------------------------------*
* * Set default formats.
* *-------------------------------------------------------------------*
  mvc   pwa_input_format,=a(&dt_general_input)  Default the input and
  mvc   pwa_input_format2,=a(&dt_delta)           input and output
  mvc   pwa_output_format,=a(&dt_civilian)          date formats.
* *-------------------------------------------------------------------*
* * Parse function arguments;  there must be at least two.
* *-------------------------------------------------------------------*
  callsub parse_argument,((r3),pwa_input,'C')  Get its address
  errexit name=function_error,(treg,r15,nz),                           *
               code=4,codereg=r14
  la    r3,argtable_next              |
  fill  pwa_input2,c' '               |
  callsub parse_argument,((r3),pwa_input2,'C')
  errexit name=function_error,(treg,r15,nz),                           *
               code=5,codereg=r14
  la    r3,argtable_next              |
  callsub parse_argument,((r3),pwa_input_format,'V')  Get its value
  if    (treg,r15,z)                  | If we got one
   la    r3,argtable_next             |
   callsub parse_argument,((r3),pwa_input_format2,'V') Get value.
   if    (treg,r15,z)                 | If we got one
    la    r3,argtable_next            |
    callsub parse_argument,((r3),pwa_output_format,'V') Get value.
   endif                              |
  endif                               |
  drop  r3                            |
* *-------------------------------------------------------------------*
* * Special cases:  If incoming interval format is DT_HUNDREDTHS,
* * DT_SECONDS, DT_MINUTES, DT_HOURS or DT_DAYS, pack it and use
* * DT_PHUNDREDTHS, etc. internally.
* *-------------------------------------------------------------------*
  callsub convert_interval_formats,(pwa_input2,pwa_input_format2)
* *-------------------------------------------------------------------*
* * Now, call SRVDT.
* *-------------------------------------------------------------------*
  fill  pwa_result,c' '               | Swab the decks first
  DT_Add      ID=DT,Timein=(pwa_input,pwa_input_format),               *
               Interval=(pwa_input2,pwa_input_format2),                *
               Timeout=(pwa_result,pwa_output_format)
  if    (treg,r15,nz)                 | Bad value, huh?
   st    r15,pwa_dt_rc                |
   callsub dt_error                   |  Go set result to error msg
   leave block=*                      |   and get out.
  endif                               |
* *-------------------------------------------------------------------*
* * Special case:  DT_Hundredths is handy, but SRVDT only supports
* * it in a binary format.  Convert it to zoned decimal.
* *-------------------------------------------------------------------*
  if    (clc,pwa_output_format,eq,=a(&DT_Hundredths)) If .01-seconds
   l     r1,pwa_result                |  Result is a fullword value
   cvd   r1,pwa_d                     |  Convert to packed
   unpk  pwa_result(7),pwa_d          |  Doesn't need to be pretty
   oi    pwa_result+6,x'f0'           |  Don't forget last byte
  endif                               |
* *-------------------------------------------------------------------*
* * Scan from end of pwa_result looking for 1st non-blank, then pass
* * the resulting field length and text back to Rexx.
* *-------------------------------------------------------------------*
  la    r14,pwa_result+l'pwa_result-1 | We gotta tell Rexx how long the
  la    r1,l'pwa_result               |  answer is ...
  loop  bct                           |
   leave loop=*,(cli,0(r14),ne,c' ')  |
   bctr  r14,0                        |
  endloop bct,r1                      |
  st    r1,evalblock_evlen            | Save result's len in EvalBlock
  bctr  r1,0                          |
  exi   r1,(mvc,evalblock_evdata(0),pwa_result)  Set result.
 endblk                               |
 title "Produce Difference Between Two Dates"
*---------------------------------------------------------------------*
*
*  Subroutine: Date_Difference
*  Abstract:   This subroutine calls SRVDT to determine the difference
*              between two date values.
*  Inputs:     No parameters; the PWA contains variables that will
*              be used for conversion.
*  Outputs:    EVALBLOCK filled in with result.
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=date_difference,type=subroutine
  tracemsg "Date_Difference entered." |
  l     r3,efplarg                    | Point to 1st Argtable entry
  using argtable_entry,r3             |
* *-------------------------------------------------------------------*
* * Set default formats.
* *-------------------------------------------------------------------*
  mvc   pwa_input_format,=a(&dt_general_input)  Default the input and
  mvc   pwa_input_format2,=a(&dt_general_input)   input and output
  mvc   pwa_output_format,=a(&dt_days)              date formats.
* *-------------------------------------------------------------------*
* * Parse function arguments;  there must be at least two.
* *-------------------------------------------------------------------*
  callsub parse_argument,((r3),pwa_input,'C')  Get its address
  errexit name=function_error,(treg,r15,nz),                           *
               code=4,codereg=r14
  la    r3,argtable_next              |
  fill  pwa_input2,c' '               |
  callsub parse_argument,((r3),pwa_input2,'C')
  errexit name=function_error,(treg,r15,nz),                           *
               code=5,codereg=r14
  la    r3,argtable_next              |
  callsub parse_argument,((r3),pwa_input_format,'V')  Get its value
  if    (treg,r15,z)                  | If we got one
   la    r3,argtable_next             |
   callsub parse_argument,((r3),pwa_input_format2,'V') Get value.
   if    (treg,r15,z)                 | If we got one
    la    r3,argtable_next            |
    callsub parse_argument,((r3),pwa_output_format,'V') Get value.
   endif                              |
  endif                               |
  drop  r3                            |
* *-------------------------------------------------------------------*
* * Now, call SRVDT.
* *-------------------------------------------------------------------*
  fill  pwa_result,c' '               | Swab the decks first
  DT_Duration ID=DT,Date1=(pwa_input,pwa_input_format),                *
               Date2=(pwa_input2,pwa_input_format2),                   *
               Duration=(pwa_result,pwa_output_format)
  if    (treg,r15,nz)                 | Bad value, huh?
*  dc    h'0'
   st    r15,pwa_dt_rc                |
   callsub dt_error                   |  Go set result to error msg
   leave block=*                      |   and get out.
  endif                               |
* *-------------------------------------------------------------------*
* * Scan from end of pwa_result looking for 1st non-blank, then pass
* * the resulting field length and text back to Rexx.
* *-------------------------------------------------------------------*
  la    r14,pwa_result+l'pwa_result-1 | We gotta tell Rexx how long the
  la    r1,l'pwa_result               |  answer is ...
  loop  bct                           |
   leave loop=*,(cli,0(r14),ne,c' ')  |
   bctr  r14,0                        |
  endloop bct,r1                      |
  st    r1,evalblock_evlen            | Save result's len in EvalBlock
  bctr  r1,0                          |
  exi   r1,(mvc,evalblock_evdata(0),pwa_result)  Set result.
 endblk                               |
 title "Create SRVDT-Related Variables For DTSETUP Function"
*---------------------------------------------------------------------*
*
*  Subroutine: Create_Variables
*  Abstract:   This routine creates a bunch of handy variables that
*              subsequent calls to SRVDT functions can use later;
*              mainly these are date/time formats and return codes.
*  Inputs:     None.
*  Outputs:    Bunch of variables are set.
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=create_variables,type=subroutine
* tracemsg "Create_Variables entered."
*--------------------------------------------------------------------*
* Return code variables.
*--------------------------------------------------------------------*
  set_immediate DT_SUCCESS,0          |
  set_immediate DT_INVALID_FUNCTION,1 |
  set_immediate DT_INVALID_NUMBER_OF_PARMS,2
  set_immediate DT_INVALID_DT_ID,3    |
  set_immediate DT_ENVIRONMENT_SUPPORT_ERROR,4
  set_immediate DT_STRING_HANDLER_ERROR,5
  set_immediate DT_INVALID_DATE_FORMAT,6
  set_immediate DT_INVALID_TIME_FORMAT,7
  set_immediate DT_INVALID_INTERVAL_FORMAT,8
  set_immediate DT_INVALID_INPUT_DATE,9
  set_immediate DT_INVALID_INPUT_TIME,10
  set_immediate DT_INVALID_INPUT_INTERVAL,11
  set_immediate DT_OVERFLOW,12        |
  set_immediate DT_OUT_OF_RANGE,13    |
*--------------------------------------------------------------------*
* Supported date formats.
*--------------------------------------------------------------------*
*--------------------------------------------------------------------*
*  Numeric formats (Julian, number-of-days)
*--------------------------------------------------------------------*
  set_immediate DT_JULIAN,&dt_julian
  set_immediate DT_JULIAND,&dt_juliand
  set_immediate DT_SJULIAN,&dt_sjulian
  set_immediate DT_SJULIAND,&dt_sjuliand
  set_immediate DT_NUMBER_OF_DAYS,&dt_number_of_days
*--------------------------------------------------------------------*
*  Month-day-year formats (Gregorian, sortdate).  Numeric year,
*  day and month values fall within this group.
*--------------------------------------------------------------------*
  set_immediate DT_SGREGORIAN,&dt_sgregorian
  set_immediate DT_GREGORIAN,&dt_gregorian
  set_immediate DT_SORTDATE,&dt_sortdate
  set_immediate DT_SSORTDATE,&dt_ssortdate
  set_immediate DT_YEAR,&dt_year
  set_immediate DT_YEAR2,&dt_year2
  set_immediate DT_DAYS,&dt_days
  set_immediate DT_MONTH,&dt_month
*--------------------------------------------------------------------*
*  Normal formats (Normal, SAS date).
*--------------------------------------------------------------------*
  set_immediate DT_SNORMAL,&dt_snormal
  set_immediate DT_NORMAL,&dt_normal
  set_immediate DT_SASDATE7,&dt_sasdate7
  set_immediate DT_SASDATE9,&dt_sasdate9
*--------------------------------------------------------------------*
*  Text formats. Weekday and month names appear here.
*--------------------------------------------------------------------*
  set_immediate DT_TEXT,&dt_text
  set_immediate DT_TEXTD,&dt_textd
  set_immediate DT_WEEKDAY,&dt_weekday
  set_immediate DT_WEEKDAY3,&dt_weekday3
  set_immediate DT_MONTHNAME,&dt_monthname
  set_immediate DT_MONTHNAME3,&dt_monthname3
  set_immediate DT_DEFAULT_DATE_FORMAT,&dt_default_date_format
*--------------------------------------------------------------------*
  set_immediate DT_GENERAL_INPUT,&dt_general_input
*--------------------------------------------------------------------*
* Supported time formats.
*--------------------------------------------------------------------*
  set_immediate DT_HUNDREDTHS,&dt_hundredths
  set_immediate DT_HHMM,&dt_hhmm
  set_immediate DT_HHMMSS,&dt_hhmmss
  set_immediate DT_HHMMSSTH,&dt_hhmmssth
  set_immediate DT_CIVILIAN,&dt_civilian
  set_immediate DT_HOURS,&dt_hours
  set_immediate DT_MINUTES,&dt_minutes
  set_immediate DT_SECONDS,&dt_seconds
  set_immediate DT_DEFAULT_TIME_FORMAT,&dt_default_time_format
*--------------------------------------------------------------------*
* Supported interval formats.
*--------------------------------------------------------------------*
  set_immediate DT_DELTA,&dt_delta    | C'    3-:10:25:15.25'
  set_immediate DT_HUNDREDTHS,&dt_hundredths
*--------------------------------------------------------------------*
* Return a zero to caller.
*--------------------------------------------------------------------*
  mvc   evalblock_evlen,=f'1'         | Set length of result to 1
  mvi   evalblock_evdata,c'0'         | Set result to C'0'.
 endblk                               |
 title "Parse Arguments From Rexx"    |
 block name=parse_argument,type=subroutine
*---------------------------------------------------------------------*
*
*  Subroutine: Parse_Argument
*  Abstract:   This routine fills out variables based on the contents
*              of the Rexx ARGTABLE.
*  Inputs:     On entry, R1 points to the following parameter list:
*                +0 - The current ARGTABLE entry.
*                +4 - Place to save the value.
*                +8 - Action to take with argument:
*                      C'C' - Save text of data at +4%
*                      C'V' - Save value of data at +4%
*
*  Outputs:    Area at parmlist+4% set as requested.  RC 4 indicates
*              that the function was not done (e.g arg pointer was
*              x'FF's or pointed to zero), while RC 8 ...
*
*  Special Notes:
*
*    For "value" requests, a value of zero will not be stored (e.g will
*    not overlay any "default" that may have been pre-set).
*
*    Also, variable DT_RC will contain SRVDT's return code.  Note that
*    all numeric variables must be zoned-decimal.
*
*---------------------------------------------------------------------*
  lm    r3,r5,0(r1)                   | Pick up parameters
  tracemsg "Parse_Argument entered."  |
  using argtable_entry,r3             | R3 points to Argtable entry.
  if    (cli,0(r3),eq,x'ff')          | If no parameter here
   la    r15,4                        |  Set RC for caller
   leave block=*                      |   and exit.
  endif                               |
  if    (cli,0(r5),eq,c'C')           | Save address of data?
   l     r1,argtable_argstring_length |           Get its length
   errexit name=function_error,(ch,r1,gt,=h'32'), Sanity-check it      *
               code=8,codereg=r14     |
   bctr  r1,0                         |           Do a VL move.
   l     r15,argtable_argstring_ptr   |
   exi   r1,(mvc,0(0,r4),0(r15))      |
  elseif (cli,0(r5),eq,c'V')          | Save value of data?
   l     r2,argtable_argstring_ptr    |  Point to argument string
   l     r1,argtable_argstring_length |  Get its length
   bctr  r1,0                         |  Subtract 1 for execute
   exi   r1,(pack,&w.d,0(0,r2))       |  Pack VL string
   validate_packed_data data=&w.d,len=8 Make sure it's OK
   if    (treg,r15,nz)                |
    leave block=*                     |
   endif                              |
   cvb   r1,&w.d                      |  Convert to integer
   if    (treg,r1,nz)                 |  If present and nonzero
    st    r1,0(r4)                    |   Save for SRVDT later,
   endif                              |   overriding the default.
  else                                | Otherwise (bad 3rd parm)
   errexit name=function_error,       |  We got a bad call somewhere.  *
               code=6,codereg=r14     |
  endif                               |
  xr    r15,r15                       |
  drop  r3                            |
 endblk                               |
 swa   ,                              |
&w.d   ds   d                         |
 endswa ,                             |
 title "Define And Set Variables By Calling IRXEXCOM"
*---------------------------------------------------------------------*
*
*  Subroutine: Set_Variable
*  Abstract:   This routine sets a Rexx variable using IRXEXCOM.
*  Inputs:     On entry, R1 points to the following parameter list:
*                +0 - Address of variable name
*                +4 - Length of variable name
*                +8 - Address of value to stuff in it
*                +C - Length of value to stuff in it
*  Outputs:    Variable set as requested.
*  Special
*  Notes:      Macros Set_Variable and Set_Immediate generate calls to
*              this routine.
*
*---------------------------------------------------------------------*
 block name=set_variable,type=subroutine
* *-------------------------------------------------------------------*
* * To call IRXEXCOM, R1 points to the following parameter list:
* *   a('IRXEXCOM')     > Address of CL8'IRXEXCOM'
* *   a(0)              > For whatever reason, these two addresses
* *   a(0)              > must be identical.  Zero is OK.
* *   a(SHVBLOCK)       > Address of 1st 32-byte SHVBLOCK.  Refer to
* *                       SYS1.MACLIB(IRXSHVB).
* *-------------------------------------------------------------------*
  lm    r2,r5,0(r1)                   | Pick up caller's parms
* tracemsg "Set_Variable entered."
  fill  &w.shvb                       | Clear out the SHVB first
  la    r6,&w.shvb                    | Point a base reg at it
  using shvblock,r6                   |
  mvi   shvcode,shvstore              | Set func code to "STORE"
  st    r2,shvnama                    | Set address of variable name
  l     r0,0(r3)                      |
  mvc   shvnaml,0(r3)                 | Set length of variable name
  st    r4,shvvala                    | Set address of variable buffer
  mvc   shvvall,0(r5)                 | Set length of variable buffer
  l     r2,pwa_irxexte                |
  using irxexte,r2                    |
  callx irxexcom,('IRXEXCOM',0,0,&w.shvb)
  errexit name=function_error,(treg,r15,nz),code=7,codereg=r14
  drop  r2                            |
 endblk rc=(r15)                      |
 swa   ,                              |
&w.shvb  ds   cl32                    |
 endswa  ,                            |
    eject ,                           |
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Integer_Formats
*  Abstract:   This routine will convert the character "integer"
*              formats to their packed-decimal equivalent.
*  Inputs:     On entry, R1 points to the following parameter list:
*                +0 - Address of input field
*                +4 - Address of fullword format value
*  Outputs:    If input format was one that we needed to convert, the
*              input field contains the converted value and the input
*              format field contains the new format.
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=convert_interval_formats,type=subroutine
  lm    r3,r4,0(r1)                   |
  l     r14,0(r4)                     |
  caseblk reg=r14,mult=1              |
   case &DT_Hundredths,&DT_Seconds,&DT_Minutes,&DT_Hours,&DT_Days,     *
               &DT_Month
    tracemsg "Converter: Conversion started."
    la    r1,31(,r3)                  | Point to end of input string
    la    r15,32                      | Assumed length of input
    loop  bct                         | Loop thru input:
     leave loop=*,(cli,0(r1),ne,c' ') |  Quit when nonblank seen.
     bctr  r1,0                       |  Decrement text ptr
    endloop bct,r15                   | Decrement counter.
    bctr  r15,0                       | Knock one off for EXI
    exi   r15,(pack,pwa_d,0(0,r3))    | Move it to work field.
    validate_packed_data data=pwa_d,  | Make sure it's OK ...          *
               len=l'pwa_d,           |   macro will errexit if not.   *
               type=INTERVAL          |
    mvc   0(4,r3),pwa_d+4             | These formats are all PL4.
    l     r14,0(r4)                   | Decide which packed format:
    caseblk reg=r14,mult=1            |
     case &DT_Hundredths              |
      mvc   0(4,r4),=a(&DT_Phundredths)
     case &DT_Seconds                 |
      mvc   0(4,r4),=a(&DT_Pseconds)  |
     case &DT_Minutes                 |
      mvc   0(4,r4),=a(&DT_Pminutes)  |
     case &DT_Hours                   |
      mvc   0(4,r4),=a(&DT_Phours)    |
     case &DT_Days                    |
      tracemsg "DT_Days Converted To DT_Pdays."
      mvc   0(4,r4),=a(&DT_Pdays)     |
     case &DT_Month                   |
      tracemsg "DT_Month Converted To DT_Pmonth."
      mvc   0(4,r4),=a(&DT_Pmonth)    |
    endcase                           |
  endcase                             |
 endblk                               |
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_Formats
*  Abstract:   This routine will convert the character "integer"
*              formats to their packed-decimal equivalent.
*  Inputs:     On entry, R1 points to the following parameter list:
*                +0 - Address of input field
*                +4 - Address of fullword format value
*  Outputs:    If input format was one that we needed to convert, the
*              input field contains the converted value and the input
*              format field contains the new format.
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=convert_date_formats,type=subroutine
  lm    r3,r4,0(r1)                   |
  l     r14,0(r4)                     |
  caseblk reg=r14,mult=1              |
   case &DT_Number_Of_Days
    tracemsg "Converter: Conversion started."
    la    r1,31(,r3)                  | Point to end of input string
    la    r15,32                      | Assumed length of input
    loop  bct                         | Loop thru input:
     leave loop=*,(cli,0(r1),ne,c' ') |  Quit when nonblank seen.
     bctr  r1,0                       |  Decrement text ptr
    endloop bct,r15                   | Decrement counter.
    bctr  r15,0                       | Knock one off for EXI
    exi   r15,(pack,pwa_d,0(0,r3))    | Move it to work field.
    validate_packed_data data=pwa_d,  | Make sure it's OK ...          *
               len=l'pwa_d,           |   macro will errexit if not.   *
               type=INTERVAL          |
    mvc   0(4,r3),pwa_d+4             | These formats are all PL4.
    l     r14,0(r4)                   | Decide which packed format:
    tracemsg "DT_Number_Of_Days converted to integer."
    cvb   r1,pwa_d
    st    r1,0(,r3)
  endcase                             |
 endblk                               |
  title "DT_Error: Set SRVDT error code, return to caller"
*---------------------------------------------------------------------*
*
*  Subroutine: DT_Error
*  Abstract:   Set Rexx variable DT_RC to whatever's in R15.
*  Inputs:     R15 contains the SRVDT return code.
*  Outputs:    DT_RC set. Also, the function return variable is set to
*              a string describing the error (eg "Invalid Date Format")
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
         macro                        |
         set_message &text            |
         lcla  &ltext                 |
&ltext   seta  k'&text-2              | Assumes string is quoted.
         psd   type=partial           |
#txt&sysndx  dc c&text                |
         endpsd ,                     |
         mvc   evalblock_evdata(l'#txt&sysndx),#txt&sysndx
         mvc   evalblock_evlen,=F'&ltext'
         mend   ,                     |
 block name=dt_error,type=subroutine  |
* ex    0,*                           |
  l     r15,pwa_dt_rc                 |
  cvd   r15,pwa_d                     | Convert SRVDT RC to packed
  lr    r4,r15                        | Save SRVDT RC for CASEBLK
  tracemsg "*** DT_Error entered. ***"
  unpk  pwa_unpk,pwa_d                | Convert SRVDT RC to text
  oi    pwa_unpk+l'pwa_unpk-1,x'f0'   | Clean up after UNPK
  la    r3,pwa_unpk                   | Find the first nonzero digit:
  la    r2,l'pwa_unpk                 |
  loop  bct                           |
   leave loop=*,(cli,0(r3),ne,c'0')   |  Exit when a digit ¬= zero.
   la    r3,1(,r3)                    |  At end, R3 points to nonzero
  endloop bct,r2                      |  digit or past end of string.
  st    r2,&w.f                       |
  set_variable  dt_rc,(r3),&w.f       | Set dt_rc to R3% for len of R2.
  caseblk reg=r4,mult=1               | Select error text to return ...
   case   &dt_invalid_function        |
    set_message "Invalid function for SRVDT."
   case   &dt_invalid_number_of_parms |
    set_message "Invalid number of parameters."
   case   &dt_invalid_dt_id           |
    set_message "SRVDT token validation error."
   case   &dt_environment_support_error
    set_message "Environment support error."
   case   &dt_string_handler_error    |
    set_message "String handler error."
   case   &dt_invalid_date_format     |
    set_message "Invalid date format."
   case   &dt_invalid_time_format     |
    set_message "Invalid time format."
   case   &dt_invalid_interval_format |
    set_message "Invalid interval format."
   case   &dt_invalid_input_date      |
    set_message "Invalid input date value."
   case   &dt_invalid_input_time      |
    set_message "Invalid input time value."
   case   &dt_invalid_input_interval  |
    set_message "Invalid input interval value."
   case   &dt_overflow                |
    set_message "Date value overflow."
   case   &dt_out_of_range            |
    set_message "Date out of range."  |
   case   other                       |
    set_message "Unknown SRVDT error."
  endcase                             |
 endblk                               |
 swa   ,                              |
&w.f   ds   f                         |
 endswa ,                             |
*---------------------------------------------------------------------*
 block name=start_service_processors,type=subroutine
  es_MVS_load id=ES                  |
  ES_Start id=ES                     |
  ES_Load_Module id=ES,spid=DT       |
  errexit name=function_error,(treg,r15,nz),code=1,codereg=r14
  DT_Start     ID=DT                 | /* options=european */
  if    (treg,r15,nz)                |
   st    r15,pwa_dt_rc                |
   callsub dt_error                  |
   leave block=*                     |
  endif                              |
 endblk                               |
*---------------------------------------------------------------------*
 block name=stop_service_processors,type=subroutine
  DT_Terminate ID=DT                  | Terminate service processors.
  ES_Unload_Module id=ES,spid=DT      |
  ES_Terminate ID=ES                  |
  ES_MVS_Unload ID=ES                 |
  xc    pwa_dt_token,pwa_dt_token     |
 endblk                               |
*---------------------------------------------------------------------*
*
*  Errexit:    Function_Error
*  Purpose:    Return RC 16 to the caller for non-SRVDT errors.
*  Called By:  Various
*  Inputs:     None
*  Outputs:    RC 16 for exit.
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=function_error,type=errexit
  lr    r4,r14                        |
  tracemsg "Errexit Function_Error entered."
  callsub stop_service_processors     |
  lr    r14,r4                        |
 endblk rc=16                         |
 title "Program Static Data, Constants"
 psd   ,                              |
*---------------------------------------------------------------------*
*
*  The packed-decimal translate-and-test table works as follows:
*    .. Valid non-sign bytes have a value of x'00' in the table.
*    .. Valid sign bytes have a value of x'08' in the table. These
*       should only occur as the last byte in the field being tested.
*    .. All other bytes have a value of x'04' in the table. If one of
*       these is found, the packed-decimal number is not legal.
*  The table is used by macro "Validate_Packed_Data".
*
*---------------------------------------------------------------------*
*                          0 1 2 3 4 5 6 7 8 9 a b c d e f
psd_packed_table dc  xl16'00000000000000000000080808080808' 0
                 dc  xl16'00000000000000000000080808080808' 1
                 dc  xl16'00000000000000000000080808080808' 2
                 dc  xl16'00000000000000000000080808080808' 3
                 dc  xl16'00000000000000000000080808080808' 4
                 dc  xl16'00000000000000000000080808080808' 5
                 dc  xl16'00000000000000000000080808080808' 6
                 dc  xl16'00000000000000000000080808080808' 7
                 dc  xl16'00000000000000000000080808080808' 8
                 dc  xl16'00000000000000000000080808080808' 9
                 dc  xl16'04040404040404040404040404040404' a
                 dc  xl16'04040404040404040404040404040404' b
                 dc  xl16'04040404040404040404040404040404' c
                 dc  xl16'04040404040404040404040404040404' d
                 dc  xl16'04040404040404040404040404040404' e
                 dc  xl16'04040404040404040404040404040404' f
 ltorg ,                              |
 endpsd ,                             |
 title "Program Workarea, Misc. Data Areas"
 pwa   ,                              |
pwa_d              ds  d              |
pwa_esv_address    dc  f'0'           |
pwa_es_epa         dc  f'0'           |
pwa_es_token       dc  f'0'           |
pwa_dt_epa         dc  f'0'           |
pwa_dt_token       dc  f'0'           |
pwa_dt_rc          ds  f              |
pwa_irxexte        ds  f              |
pwa_input_format   ds  f              |
pwa_input_format2  ds  f              |
pwa_output_format  ds  f              |
pwa_input_len      ds  f              |
pwa_input_len2     ds  f              |
pwa_function_name  ds  cl8            |
pwa_input          ds  cl32           |
pwa_input2         ds  cl32           |
pwa_result         ds  cl32           |
pwa_unpk           ds  cl9            |
pwa_packed_validation  ds  cl9        |
 endpwa ,                             |
 space 1                              |
 irxenvb ,                            | Rexx environment block.
 space 1                              |
 irxefpl ,                            | External function parmlist.
 space 1                              |
 irxargtb ,                           | Argument list.
 space 1                              |
 irxevalb ,                           | Evaluation block.
 space 1                              |
 irxshvb ,                            | Shared variable block.
 space 1                              |
 irxexte ,                            | Rexx external entry points.
 space 1                              |
         title "DATECNVT: Entry Stub For Date Conversion"
**--------------------------------------------------------------------*
**
**  Stub for date conversion.
**
**--------------------------------------------------------------------*
 block name=DATECNVT,type=program,    |                                *
               options=(*pwa,xa,noregequ,noclearpwa),                  *
               amode=31,rmode=any,r1save=r9
  using efpl,r9                       |
  l     r10,4(,r13)                   | Dig R0 out of the savearea
  l     r10,20(,r10)                  |
  callx =v(DTSERVS),('DATECNVT',(r9),(r10)),vl
 endblk                               |
 psd   ,                              |
   ltorg ,                            |
 endpsd ,                             |
 pwa   ,                              |
 endpwa ,                             |
 drop  ,                              |
         title "TIMECNVT: Entry Stub For Time Conversion"
**--------------------------------------------------------------------*
**
**  Stub for time conversion.
**
**--------------------------------------------------------------------*
 block name=TIMECNVT,type=program,    |                                *
               options=(*pwa,xa,noregequ,noclearpwa),                  *
               amode=31,rmode=any,r1save=r9
  using efpl,r9                       |
  l     r10,4(,r13)                   | Dig R0 out of the savearea
  l     r10,20(,r10)                  |
  callx =v(DTSERVS),('TIMECNVT',(r9),(r10)),vl
 endblk                               |
 psd   ,                              |
   ltorg ,                            |
 endpsd ,                             |
 pwa   ,                              |
 endpwa ,                             |
 drop  ,                              |
         title "DATEADD: Entry Stub For Date Addition"
**--------------------------------------------------------------------*
**
**  Stub for date addition.
**
**--------------------------------------------------------------------*
 block name=DATEADD,type=program,     |                                *
               options=(*pwa,xa,noregequ,noclearpwa),                  *
               amode=31,rmode=any,r1save=r9
  using efpl,r9                       |
  l     r10,4(,r13)                   | Dig R0 out of the savearea
  l     r10,20(,r10)                  |
  callx =v(DTSERVS),('DATEADD ',(r9),(r10)),vl
 endblk                               |
 psd   ,                              |
   ltorg ,                            |
 endpsd ,                             |
 pwa   ,                              |
 endpwa ,                             |
 drop  ,                              |
         title "TIMEADD: Entry Stub For Date Addition"
**--------------------------------------------------------------------*
**
**  Stub for time addition.
**
**--------------------------------------------------------------------*
 block name=TIMEADD,type=program,     |                                *
               options=(*pwa,xa,noregequ,noclearpwa),                  *
               amode=31,rmode=any,r1save=r9
  using efpl,r9                       |
  l     r10,4(,r13)                   | Dig R0 out of the savearea
  l     r10,20(,r10)                  |
  callx =v(DTSERVS),('TIMEADD ',(r9),(r10)),vl
 endblk                               |
 psd   ,                              |
   ltorg ,                            |
 endpsd ,                             |
 pwa   ,                              |
 endpwa ,                             |
 drop  ,                              |
         title "DATEDIFF: Entry Stub For Date Addition"
**--------------------------------------------------------------------*
**
**  Stub for date difference.
**
**--------------------------------------------------------------------*
 block name=DATEDIFF,type=program,    |                                *
               options=(*pwa,xa,noregequ,noclearpwa),                  *
               amode=31,rmode=any,r1save=r9
  using efpl,r9                       |
  l     r10,4(,r13)                   | Dig R0 out of the savearea
  l     r10,20(,r10)                  |
  callx =v(DTSERVS),('DATEDIFF',(r9),(r10)),vl
 endblk                               |
 psd   ,                              |
   ltorg ,                            |
 endpsd ,                             |
 pwa   ,                              |
 endpwa ,                             |
 drop  ,                              |
         title "DTSETUP: Entry Stub For SRVDT Rexx Variable Setup"
**--------------------------------------------------------------------*
**
**  Stub for Rexx variable setup.
**
**--------------------------------------------------------------------*
 block name=DTSETUP,type=program,     |                                *
               options=(*pwa,xa,noregequ,noclearpwa),                  *
               amode=31,rmode=any,r1save=r9
  using efpl,r9                       |
  l     r10,4(,r13)                   | Dig R0 out of the savearea
  l     r10,20(,r10)                  |
  callx =v(DTSERVS),('DTSETUP ',(r9),(r10)),vl
 endblk                               |
 psd   ,                              |
   ltorg ,                            |
 endpsd ,                             |
 pwa   ,                              |
 endpwa ,                             |
 drop  ,                              |
 end ,                                |
//C.SYSLIB DD
//         DD
//         DD DSN=SYSTEMS.SRV.SOURCE,DISP=SHR
//L.SYSIN  DD  *
 NAME SRVDTREX(R)                     |
