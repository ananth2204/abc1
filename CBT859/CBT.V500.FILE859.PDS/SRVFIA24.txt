*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
**********************************************************************
**
** This is a copy of SRVFIOS before it was converted to AMODE=31.
**
**********************************************************************
            SMLIST CONVERT=YES
SRVFIOS     title "File service processor"
         srvmod name=srvfios,dates='1987, 1990, 1993, 1995, 2001'
*
*
*  WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
*
*  For performance reasons, this module does NOT use COPY in the
*  options statement to copy incoming parameters.  If you want to check
*  a parm to see if it is actually present, you must do it the old
*  fashioned way: check the high-order bit of the last non-optional
*  parm and go forward from there.....mjm 2001-08-13.
*
*  WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
*
*---------------------------------------------------------------------*
*
*  Copyright (C) Clemson University Research Foundation 1987, 2001.
*
*  Program     SRVFIOS
*
*  Abstract    SRVFIOS reads from and writes to sequential files with
*              either fixed length or varying length records. Programs
*              can use SRVFIOS to read from a file or write records to
*              a file without having to know anything more than the
*              file's data set name or ddname.  All records passed
*              between the file server and its caller are in the form
*              of a varying length string, regardless of the actual
*              characteristics of the file being accessed.
*
*  Parameters:
*    Documented in the Service Processors Guide & Reference.
*
*  Program     reentrant, problem key and state, standard linkage,
*  Attributes  non-authorized, amode(any), rmode(24)
*
*  Special     1. This program depends on the PWA being automatically
*  Notes          cleared to all-zeros by the BLOCK macro when it is
*                 first allocated during start-up.
*              2. This program runs below the 16-megabyte line because
*                 it uses standard I/O macros.  However, it expects to
*                 be called with Amode=31.
*              3. For sequential input, the data set is dynamically
*                 allocated with a disposition of SHR, causing the
*                 following enqueue to be performed:
*
*                 ENQ SYSDSN,CL44(dsname),S,44,SYSTEM
*
*                 For sequential output, if the data set exists,
*                 dynamic allocation is invoked again to change the
*                 disposition to OLD.  If the data set does not exist,
*                 dynamic allocation is invoked with a disposition of
*                 NEW to create it.  In either case, the following
*                 enqueue results:
*
*                 ENQ SYSDSN,CL44(dsname),S,44,SYSTEM
*
*                 The above enqueues are implicitly performed as a
*                 result of dynamic allocation.  In addition, if output
*                 is being done to a member of a partitioned data set,
*                 the following enqueue is explicitly performed:
*
*                 ENQ SPFEDIT,'CL44(dsname),CL8(member)',E,52,SYSTEMS
*
*  Change
*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution
*
*---------------------------------------------------------------------*
 EJECT
 print off
 copy  smsyms    | Obtain Structured Macros symbols.
 copy  srvesmac  | Obtain Environment Support symbols & macros.
 copy  srvstmac  | Obtain String Handler symbols & macros.
 copy  srvfimac  | Obtain File Handler symbols & macros.
 copy  smpucond  | Obtain User Conditions.
 print on,gen
 EJECT
*---------------------------------------------------------------------*
*
*  Macro:      TEXT_UNIT Key,(Parm 1,Parm 2,...)
*  Purpose:    Define storage for a dynamic allocation text unit. The
*              value used for Key should be the name of a dynamic
*              allocation verb defined in IEFZB4D0. The values used for
*              Parm-n must be such that when used on a DC instruction,
*              they will not cause alignment and will produce the
*              correct length value for L' attributes.
*
*---------------------------------------------------------------------*
                macro
&label          text_unit &key,&parm
                lcla &n,&i
&n              seta n'&parm                    number of parms.
&label._key     dc  al2(&key)                   dynalloc text unit key.
&label._count   dc  al2(&n)                     number of parameters.
&i              seta 1
.parm_loop      aif (&i gt &n).noparm
                dc  al2(l'&label._parm&i)       length of parameter.
&label._parm&i  dc  &parm(&i)                   value of parameter.
&i              seta &i+1
                ago  .parm_loop
.noparm         anop
&label          equ &label._key,*-&label._key,c'c'  text unit storage.
                mend
 eject
***********************************************************************
***********************************************************************
**                                                                   **
**                                                                   **
**                      SRVFIOS Main Program                         **
**                                                                   **
**                                                                   **
***********************************************************************
***********************************************************************
         gblb   &security_check
&security_check setb 0        << PERMANENT: Allow S913 instead of
*                                trying to detect RACF security
*                                violations and issue a message.
*
 block name=srvfios,type=program,amode=31,rmode=24,                    +
               options=(*srvprc,main,dyn,long),r1save=r9,           @DD+
               subopts=(*swa,loadbase)
   es_id id=es,spepa=pwa_esepa,sptoken=pwa_estkn,esva=pwaaesv
   st_id id=st,spepname=&string_handler,sizelength=4,                  +
               spepa=pwa_st_spepa,sptoken=pwa_st_sptoken
*                                     |
   using fi_parmlist,r9               | Establish addressability.
   mvc   gdirc,=h'0'                  | Clear out return-code.
*---------------------------------------------------------------------*
*  If the function code is something other than start, make sure that
*  the PWA contains the eye-catcher string and the correct value for
*  FileID.  If not, then the FileID passed in is garbage.
*---------------------------------------------------------------------*
   l  r2,fi_functioncode              | R2 -> Fullword function code.
   l  r1,0(r2)                        | R2 := function code.
   if (cl,r1,ne,=f'&start')           | If not startup function then
     if ((clc,pwa_visual,ne,eyecatcher),or,(c,r13,ne,pwa_fileid))
       errexit code=&fi_invalid_fileid
     elseif (tbit,pwa_1_error)        |
       caseblk reg=r1,mult=1          |     Case on function-code.
         case &terminate,&fi_get_info,&fi_get_reference
         case other                   |       Die on anything else.
           callsub message,(fi00004)  |
           errexit code=0             |
       endcase                        |     EndCase.
     endif                            |   Endif.
   endif                              | Endif.
*---------------------------------------------------------------------*
*  Use the FunctionCode to determine which subroutine to invoke.
*---------------------------------------------------------------------*
   l  r1,0(r2)                        | R1 := function code.
*                                     |
   caseblk reg=r1,mult=1              | Case on FunctionCode.
     case &start                      |   Open a new file.
       callsub start                  |
     case &terminate                  |   Terminate file handler.
       callsub terminate              |     Kill file and buffers.
       smctrl  freepwa=yes            |     Release the PWA on exit.
     case &fi_open                    |   Open the file.
       callsub open_parm              |     Process open parameters.
       callsub open                   |     Open file.
     case &fi_close                   |   Close the file.
       callsub close                  |
     case &fi_delete                  |   Delete the file.
       callsub delete                 |
     case &fi_readline                |   Read the next line.
       callsub readline               |
     case &fi_writeline               |   Read the next line.
       callsub writeline              |
     case &fi_get_info                |   Obtain information.
       callsub get_info               |
     case &fi_set_status              |   Set file status information.
       callsub set_status             |
     case &fi_get_reference           |   Obtain information.
       callsub get_reference          |
     case &fi_find                    |   Find.
       callsub find                   |
     case other                       |   Invalid function code.
       callsub message,(fi00005,0(r2))
       errexit code=0                 |
   endcase                            | EndCase.
*                                     |
   lh      r15,gdirc                  | R15 := return code.
 endblk block=srvfios                 | Quit w/possible return code.
 eject
***********************************************************************
*                                                                     *
*  Subroutine: START                                                  *
*  Abstract:   Open a file for the type of access requested. The only *
*              access modes supported are sequential input or output. *
*                                                                     *
***********************************************************************
 block name=start,type=subroutine
*  *------------------------------------------------------------------*
*  * All fields in the PWA have already been initialized to zeros by
*  * the block macro.  Initialize those fields that must be non-zero
*  *------------------------------------------------------------------*
   mvc   pwa_visual,eyecatcher          | Eyecatcher and fileid are for
   st    r13,pwa_fileid                 | validity checks and dumps.
   l     r2,pwaaesv                     | R2 -> ESV.
   using esv,r2                         | Establish addressability.
   mvc   pwa_esepa,esvesepa             | Get Environment Support EPA.
   mvc   pwa_estkn,esvestkn             | Get Env Support TOKEN.
   drop  r2                             | Drop addressability.
*                                       |
   fill  pwa_ddname,c' '                | Clear out the DDNAME.
   fill  pwa_dsname,c' '                | Clear out the DSNAME.
   fill  pwa_member,c' '                | Clear out the MEMBER.
   fill  pwa_volser,c' '                | Clear out the VOLSER.
   fill  pwa_sysoutclass,c' '           | Clear out the SYSOUTCLASS.
   fill  pwa_unitname,c' '              | Clear out the UNITNAME.
   fill  pwa_userid,c' '                | Set the default userid value.
   mvc   pwa_fi_reference(12),=c"Unknown file" | Initialize ref string
   mvc   pwa_avglrecl,=f'0'             | Initialize to 0 (missing)
   mvc   pwa_maxlrecl,=f'0'             | Initialize to 0 (missing)
   mvc   pwa_sizeinit,=f'1000'          | Default SizeInit = 1000.
   mvc   pwa_sizeincr,=f'1000'          | Default SizeIncr = 1000.
*                                       |
   la    r1,pwa_textunits+l'pwa_textunits-4
   st    r1,pwa_textunits_end
*                                       |
   es_get_userid id=es,userid=pwa_userid   Attempt to get the real one.
*                                       |
*  *------------------------------------------------------------------*
*  * Load and start the string-handler for use in message formatting.
*  *------------------------------------------------------------------*
   es_load_module id=es,spid=st         | Load String Handler module.
   if (treg,r15,nz),then                | If string-handler not loaded
     st   r15,pwa_save_r15              | Preserve r15 for errexit
     callsub message,(fi00023)          |   Unable to load.
     l    r15,pwa_save_r15              | Rest r15 for debug analysis
     errexit code=0                     |
   endif                                | EndIf.
   st_start id=st                       | Start the String Handler.
   if (treg,r15,nz),then                | If string-handler ¬started.
     st   r15,pwa_save_r15              | Preserve r15 for errexit
     callsub message,(fi00024)          |   Unable to start.
     l    r15,pwa_save_r15              | Rest r15 for debug analysis
     errexit code=0                     |
   endif                                | EndIf.
*  *------------------------------------------------------------------*
*  * Insure that required parameters were specified for FI_START.
*  *------------------------------------------------------------------*
   if not,((tbit,fi_fileid,x'80',off),and,         Make sure fileid,   +
               (tbit,fi_functioncode,x'80',off),and,    functioncode,  +
               (tbit,fi_esv,x'80',off),and,             esv, info,     +
               (tbit,fi_info,x'80',off),and,            filename,      +
               (tbit,fi_filename,x'80',off),and,        namelength,    +
               (tbit,fi_namelength,x'80',off))      and options present
     callsub message,(fi00006,'start',5) |   Issue an error message.
     errexit code=0                      |
   endif                                 | EndIf.
*  *------------------------------------------------------------------*
*  * Process the OPTIONS parameter.
*  *------------------------------------------------------------------*
*
*  Make sure that all reserved OPTIONS flags are zeros.
*
   l  r2,fi_options                      | R2 -> options parameter.
   la r2,0(r2)                           | Get rid of VL bit if any.
   if (treg,r2,z)                        | If OPTIONS not supplied.
     callsub message,(fi00007,,0)        |   Issue an error message.
     errexit code=0                      |
   elseif (tbit,0(r2),&fi_oc_reserved,any)
     callsub message,(fi00007,0(r2),1)   |   Issue an error message.
     errexit code=0                      |
   else                                  |
     mvc   pwa_oc_xopt,0(r2)             | Save XOPT flag.
     ni    pwa_oc_xopt,&fi_oc_xopt       | Mask off other bits.
     if    (cli,pwa_oc_xopt,eq,&fi_oc_xoptword)
       if  (tbit,1(r2),&fi_oc2_reserved,any),or,                       +
               (tbit,2(r2),&fi_oc3_reserved,any),or,                   +
               (tbit,3(r2),&fi_oc4_reserved,any)
         callsub message,(fi00007,0(r2),4)
         errexit code=0
       endif
     endif
   endif                                 | EndIf.
*
*  Separate the option-flags to make checking for specific values
*  and combinations of values easier.
*
   mvc   pwa_oc_mode,0(r2)               | Save INPUT/OUTPUT flag.
   ni    pwa_oc_mode,&fi_oc_mode         | Mask off other bits.
   mvi   pwa_oo_mode,&fi_oo_input        | Set OO_MODE
   if (cli,pwa_oc_mode,eq,&fi_oc_output)   to reflect
    mvi   pwa_oo_mode,&fi_oo_output      | status of
   endif                                 | INPUT/OUTPUT flag.
   mvc   pwa_oc_ident,0(r2)              | Save FILENAME/FILEID flag.
   ni    pwa_oc_ident,&fi_oc_ident       | Mask off other bits.
   mvc   pwa_oc_filetempx,0(r2)          | Save FILETEMP flag.
   ni    pwa_oc_filetempx,&fi_oc_filetempx Mask off other bits.
   mvc   pwa_oc_disp,0(r2)               | EXISTING/NEW/REPLACE/APPEND.
   ni    pwa_oc_disp,&fi_oc_disp         | Mask off other bits.
   mvc   pwa_oc_recfm,0(r2)              | Save FIXED/VARIABLE flag.
   ni    pwa_oc_recfm,&fi_oc_recfm       | Mask off other bits.
   mvc   pwa_oc_open,0(r2)               | Save OPEN=AUTO|MANUAL flag.
   ni    pwa_oc_open,&fi_oc_open         | Mask off other bits.
*
   if (cli,pwa_oc_xopt,eq,&fi_oc_xoptword) If extended options
     mvc   pwa_oc2_free,1(r2)            |   Save FREE flag.
     ni    pwa_oc2_free,&fi_oc2_free     |   Mask off other bits.
     mvc   pwa_oc2_cc,1(r2)              |   Save ISOCC flag.
     ni    pwa_oc2_cc,&fi_oc2_cc         |   Mask off other bits.
     mvc   pwa_oc2_sysoutx,1(r2)         |   Save SYSOUT flag.
     ni    pwa_oc2_sysoutx,&fi_oc2_sysoutx   Mask off other bits.
     mvc   pwa_oc2_chkpdsmemx,1(r2)      |   Save CHKPDSMEM flag.
     ni    pwa_oc2_chkpdsmemx,&fi_oc2_chkpdsmemx Mask off other bits.
*
     if (tbit,1(r2),&fi_oc2_ascii,on)    |   If ASCII option specified.
      sbit pwa_2_ascii                   |    Turn on pwa flag.
     endif                               |   EndIf.
     mvc   pwa_oc2_library,1(r2)         |   Save LIBRARY flag.
     ni    pwa_oc2_library,&fi_oc2_library   Mask off other bits.
   endif                                 | EndIf.
*
*  Check for invalid combinations of options.
*
   if (cli,pwa_oo_mode,eq,&fi_oo_input)  | If INPUT access mode.
     if (cli,pwa_oc_disp,ne,&fi_oc_existing) If not EXISTING file.
       callsub message,(fi00032)         |     Issue an error message.
       errexit code=0                    |     Exit w/return-code.
     endif                               |   EndIf.
   endif                                 | EndIf.
   if (cli,pwa_oo_mode,eq,&fi_oo_output) | If OUTPUT access mode.
     if (cli,pwa_oc2_library,eq,&fi_oc2_library) If LIBRARY option.
       callsub message,(fi00033,         |     Issue an error message. +
               'LIBRARY and OUTPUT',18)  |
       errexit code=0                    |     Exit w/return-code.
     endif                               |   EndIf.
   endif                                 | EndIf.
*  *------------------------------------------------------------------*
*  * Process optional START parameters (OUTPUT mode only)
*  *------------------------------------------------------------------*
   block type=inline,name=&s.optional_start_parms
    if (tbit,fi_options,x'80',on)
     leave block=&s.optional_start_parms
    endif
    if (cli,pwa_oo_mode,eq,&fi_oo_input) | If INPUT mode.
     if (tbit,fi_options,x'80',off)      |  If parm(s) follow options.
       callsub message,(fi00034)         |   Issue an error message.
       errexit code=0                    |   Exit w/return-code.
     endif                               |  EndIf.
    endif                                | EndIf.
*   *-----------------------------------------------------------------*
*   * Process RECORDLENGTH=(average <,maximum>)
*   *     and FILESIZE=(initial <,increment>).
*   *-----------------------------------------------------------------*
    l   r1,fi_avg_reclen                 | r1 -> Avg_reclen parm.
    la  r1,0(,r1)                        | Toss high-order bit.
    if  (treg,r1,p)                      | If still non-zero address
      l  r1,0(,r1)                       |   r1 := avg_reclen parm.
      if (treg,r1,p)                     |   If value is non-zero.
        st r1,pwa_avglrecl               |     Save in PWA.
      endif                              |   EndIf.
    endif                                | EndIf.
*                                        |
    if (tbit,fi_avg_reclen,x'80',on)     | If end of parms.
     leave block=&s.optional_start_parms |  Done with parms.
    endif                                | EndIf.
*                                        |
    l   r1,fi_max_reclen                 | r1 -> Max_reclen parm.
    la  r1,0(,r1)                        | Toss high-order bit.
    if  (treg,r1,p)                      | If still non-zero address
      l  r1,0(,r1)                       |   r1 := max_reclen parm.
      if (treg,r1,p)                     |   If value is non-zero.
        st r1,pwa_maxlrecl               |     Save in PWA.
      endif                              |   EndIf.
    endif                                | EndIf.
*                                        |
    if (tbit,fi_max_reclen,x'80',on)     | If end of parms.
     leave block=&s.optional_start_parms |  Done with parms.
    endif                                | EndIf.
*                                        |
    l   r1,fi_size_initial               | r1 -> Initial size parm.
    la  r1,0(,r1)                        | Toss high-order bit.
    if  (treg,r1,p)                      | If still non-zero.
      l  r1,0(,r1)                       |   r1 := initial size.
      if (treg,r1,p)                     |   If value is non-zero.
        st r1,pwa_sizeinit               |     Save in PWA.
      endif                              |   EndIf.
    endif                                | EndIf.
*                                        |
    if (tbit,fi_size_initial,x'80',on)   | If end of parms.
     leave block=&s.optional_start_parms |  Done with parms.
    endif                                | EndIf.
*                                        |
    l   r1,fi_size_increment             | r1 -> Increment size parm.
    la  r1,0(,r1)                        | Toss high-order bit.
    if  (treg,r1,p)                      | If still non-zero.
      l  r1,0(,r1)                       |   r1 := increment size.
      if (treg,r1,p)                     |   If value is non-zero.
        st r1,pwa_sizeincr               |     Save in PWA.
      endif                              |   EndIf.
    endif                                | EndIf.
*                                        |
    if (tbit,fi_size_increment,x'80',on) | If end of parms.
     leave block=&s.optional_start_parms |  Done with parms.
    endif                                | EndIf.
*   *-----------------------------------------------------------------*
*   * Process REFERENCE string.
*   *-----------------------------------------------------------------*
    l   r1,fi_reference                  | r1 -> reference.
    la  r1,0(,r1)                        | Discard high order bit.
    if (treg,r1,nz)                      | If nonzero
     mvc pwa_fi_reference,0(r1)          |   Save in PWA.
     sbit pwa_2_reference_supplied       |   Set flag in pwa.
    endif                                | EndIf.
   endblk block=&s.optional_start_parms
*  *------------------------------------------------------------------*
*  * If neither avg or max specified, supply default values.  If only
*  * one value supplied, use that same value for both avg and max.
*  *------------------------------------------------------------------*
   l  r2,pwa_avglrecl                    |  r2 := avg lrecl.
   l  r3,pwa_maxlrecl                    |  r3 := max lrecl.
   if (treg,r2,z),and,(treg,r3,z)        |  If neither parm specified.
     mvc pwa_avglrecl,=f'80'             |    Default AvgLrecl = 80.
     mvc pwa_maxlrecl,=f'251'            |    Default MaxLrecl = 251.
   elseif (treg,r2,p),and,(treg,r3,z)    |  ElseIf only avg specified.
     st  r2,pwa_maxlrecl                 |    Set maxlrecl = avglrecl.
   elseif (treg,r2,z),and,(treg,r3,p)    |  ElseIf only max specified.
     st  r3,pwa_avglrecl                 |    Set avglrecl = maxlrecl.
   endif                                 |  EndIf.
*  *------------------------------------------------------------------*
*  * Use the avg and max lrecl values to determine the record
*  * format of the output file.  If RECFM=V, add 4 to lrecls.
*  *------------------------------------------------------------------*
   l  r2,pwa_avglrecl                    |  r2 := avg lrecl.
   l  r3,pwa_maxlrecl                    |  r3 := max lrecl.
   if (cr,r2,eq,r3)                      |  If max lrecl = avg lrecl.
     sbit  pwa_1_fb                      |    Force RECFM=F,
   elseif (cr,r2,gt,r3)                  |  ElseIf Avg > max lrecl
     callsub message,(fi00115,pwa_maxlrecl,pwa_avglrecl)
     errexit code=0                      |
   else                                  |  Else.
     sbit  pwa_1_vb                      |    Force RECFM=V,
     la    r2,4(,r2)                     |    Add 4 to avg lrecl.
     st    r2,pwa_avglrecl               |
     la    r3,4(,r3)                     |    Add 4 to max lrecl.
     st    r3,pwa_maxlrecl               |
   endif                                 |  EndIf.
*  *------------------------------------------------------------------*
*  * Extract information from supplied text-units.
*  *------------------------------------------------------------------*
   l32   r2,fi_info                  | Search caller's INFO list
   if    (nz),and,(clc,=f'0',ne,0(r2)) If present and non-null.
     loop until                      |   textunit pointers:
       l  r1,0(r2)                   |
       if (clc,0(2,r1),eq,=al2(dalvlser)) Is this VOLSER textunit?
         lh    r15,4(r1)             |      Get volume's length
         bctr  r15,0                 |      Set it up for EXECUTE
         exi   r15,(mvc,pwa_volser(0),6(r1)) Copy volser to PWA
       elseif (clc,0(2,r1),eq,=al2(dalsysou)) Is this SYSOUT textunit?
         if (clc,2(2,r1),gt,=al2(0000))     if # not zero then
           mvc pwa_sysoutclass,6(r1) |        copy sysout class char.
         endif                       |      endif.
       endif                         |     EndIf.
       leave loop=*,(tbit,0(r2),x'80')     Leave if at final textunit.
       la    r2,4(r2)                |     r2 -> Next entry.
     endloop until,leave             |   EndLoop.
   endif                             | EndIf.
*  *------------------------------------------------------------------*
*  * Create a better REFERENCE string if one was not supplied.
*  *------------------------------------------------------------------*
   if not,(tbit,pwa_2_reference_supplied)   | Ref not supplied
     if (cli,pwa_oc2_sysoutx,eq,&fi_oc2_sysout) | If it is SYSOUT
      mvc  pwa_fi_reference,=cl70"a SYSOUT file"
     elseif (cli,pwa_oc_ident,eq,&fi_oc_fileid) | If its a DDNAME
      l  r4,fi_filename          | R4 := file-specification's text.
      l  r5,fi_namelength        | R5 -> length of file-specification.
      fill  pwa_fi_reference,c' ' | Clear out the REFERENCE string.
      st_format id=st,string=pwa_fi_reference,                         +
               control='DDNAME {cl? caps trim}',                       +
               source=(0(r4),0(r5))
     elseif (cli,pwa_oc_ident,eq,&fi_oc_filename) | If its a FILENAME.
      l  r4,fi_filename          | R4 := file-specification's text.
      l  r5,fi_namelength        | R5 -> length of file-specification.
      fill  pwa_fi_reference,c' ' | Clear out the REFERENCE string.
      st_format id=st,string=pwa_fi_reference,                         +
               control='{cl? caps trim}',source=(0(r4),0(r5))
     elseif (cli,pwa_oc_filetempx,eq,&fi_oc_filetemp) If FILETEMP
      mvc  pwa_fi_reference,=cl70"a TEMPORARY DATASET"
     endif                                |
   endif                                |
*  *------------------------------------------------------------------*
*  * Parse the file's name and allocate the file.
*  *------------------------------------------------------------------*
   callsub parse_filename            | If file name provided, get it.
   callsub allocate_file             | Allocate the file now.
*                                    |   If OPTION=LIBRARY:
   if (cli,pwa_oc2_library,eq,&fi_oc2_library)
     if (cli,pwa_member,ne,c" ")     |     If member specified:
       callsub message,(fi00037)     |      It is an error.
       errexit code=0                |      Exit.
     endif                           |     Endif.
   endif                             |   Endif.
*  *------------------------------------------------------------------*
*  * If AUTOOPEN is in effect, open the file for INPUT/OUTPUT now.
*  *------------------------------------------------------------------*
   if (cli,pwa_oc_open,ne,&fi_oc_manualopen)  If OPEN=AUTO.
     callsub open                        |      Open the data set.
   endif                                 |    EndIf.
   callsub message,(fi00000)          | Successful completion.
 endblk block=start
                 swa
&w.avg_rec_len   ds     f
&w.max_rec_len   ds     f
                 endswa
 eject
***********************************************************************
*                                                                     *
*  Subroutine: TERMINATE                                              *
*  Abstract:   Close out and cleanup any/all files.                   *
*                                                                     *
***********************************************************************
 block name=terminate,type=subroutine,amode=31
   if (tbit,pwa_1_open)                  | If file is open.
     callsub close                       |   Close it.
   endif                                 | EndIf.
*---------------------------------------------------------------------*
*  If we allocated to the data set ourselves, and AUTOFREE is in effect
*  then free the data set.
*---------------------------------------------------------------------*
   if (cli,pwa_oc2_free,eq,&fi_oc2_autofree)
     if (tbit,pwa_1_allocated),and,(clc,pwa_ddname,ne,=cl8' ')
       if (tbit,pwa_2_free_on_terminate)
         mvc &w.ddname,&s.ddname         | Initialize DDNAME text unit.
         mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname
         plist (&w.ddname),vl,pl=pwa_textunits
         callsub dynalloc,               | Releasing allocated file.   +
               (=al1(s99vrbun),          |   Unallocate function.      +
               =al1(s99nomnt,0),0,       |   Request-block flags.      +
               pwa_err_msg,              |   Return message area.      +
               =a(l'pwa_err_msg),        |   Length of message area.   +
               pwa_err_msg_len,          |   Length of returned msg.   +
               pwa_textunits),vl         |   Free by DDNAME.
       endif
     endif
   endif
*---------------------------------------------------------------------*
*  Terminate and unload the string handler.
*---------------------------------------------------------------------*
   if (clc,pwa_st_spepa,ne,=f'0')        | If string handler loaded.
     if (clc,pwa_st_sptoken,ne,=f'0')    |   If string-handler started.
       st_terminate id=st                |     Terminate it.
     endif                               |   EndIf.
     es_unload_module id=es,spid=st      |   Unload the String Handler.
     mvc   pwa_st_spepa,=f'0'            |   Set EPA to zeros.
   endif                                 | EndIf.
   callsub message,(fi00000)             | Successful completion.
 endblk block=terminate
*---------------------------------------------------------------------*
*  Working storage for dynamic de-allocation of OS data sets.
*---------------------------------------------------------------------*
             ssd
&s.ddname    text_unit dunddnam,CL8' '   | DDNAME=<blanks>
             endssd
             swa
&w.ddname    ds      cl(l'&s.ddname)     |   DUN DDNAME Text unit.
             endswa
             eject
***********************************************************************
*                                                                     *
*  Subroutine: OPEN_PARM                                              *
*  Abstract  : Process the FI_OPEN parms.
*                                                                     *
***********************************************************************
 block name=open_parm,type=subroutine,amode=31
*---------------------------------------------------------------------*
*  If Option is specified, process it.
*---------------------------------------------------------------------*
   mvi   pwa_oo_mode,&fi_oo_default   |     Assume defaulting.
   if    (tbit,fi_functioncode,x'80',off)   If option parm is present.
    l32   r2,fi_op_options            |      r2 -> options parm.
    if    nz,then                     |      If a value was provided.
     mvc   pwa_oo_mode,0(r2)          |       Save INPUT/OUTPUT flag.
     ni    pwa_oo_mode,&fi_oo_mode    |       Mask off other bits.
    endif                             |      Endif.
   endif                              |     Endif.
   if (cli,pwa_oo_mode,eq,&fi_oo_default)   If defaulting:
     mvi   pwa_oo_mode,&fi_oo_input           Set OO_MODE
     if (cli,pwa_oc_mode,eq,&fi_oc_output)    based on
       mvi   pwa_oo_mode,&fi_oo_output        start
     endif                            |       option.
   endif                              |     Endif.
 endblk block=open_parm
             eject
***********************************************************************
*                                                                     *
*  Subroutine: OPEN                                                   *
*  Abstract  : Open the file for processing.                          *
*                                                                     *
***********************************************************************
 block name=open,type=subroutine,amode=31
*  *------------------------------------------------------------------*
*  * Ensure that the file is not already open and reset flags.
*  *------------------------------------------------------------------*
   if  (tbit,pwa_1_open)                 | If file already OPEN.
     callsub message,(fi00126,"already",7)   Issue an error message
     errexit code=0                      |   and exit w/ret-code.
   endif                                 | EndIf.
   rbit pwa_2_fios_supplies_dcb_attributes Reset flag.
*  *------------------------------------------------------------------*
*  * For CLEMSON only, determine if RACF will allow the OPEN.
*  *------------------------------------------------------------------*
     aif (not &security_check).skip3
     if (cli,pwa_oo_mode,eq,&fi_oo_input)    If input mode.
       callsub security_check,("READ")   |     Check for READ access.
     else                                |   Else.
       callsub security_check,("UPDATE") |     Check for UPDATE access.
     endif                               |   EndIf.
.skip3 anop
*  *------------------------------------------------------------------*
*  * For existing data sets, perform a number of checks to (1)
*  * avoid destroying the file and (2) avoid any ABENDs.
*  *------------------------------------------------------------------*
   if (clc,=c'PO',ne,pwa_dsorg),and,(clc,=c'PS',ne,pwa_dsorg)
     callsub message,(fi00101,pwa_dsorg,pwa_dsname)
     errexit code=0
   endif
   if not,(tbit,pwa_1_ds_not_existing)   | If already existed.
*    *----------------------------------------------------------------*
*    * Read in the JFCB for the file and extract information from it.
*    *----------------------------------------------------------------*
     callsub read_jfcb                   |   Read PO or PS JFCB.
     la      r8,pwa_jfcb                 |   r8 -> JFCB storage.
     using   infmjfcb,r8                 |   Address the JFCB.
     mvc     pwa_volser,jfcbvols         |   Extract data set VOLSER.
     lh      r0,jfclrecl                 |   Extract data set LRECL
     st      r0,pwa_lrecl                |      and save in PWA.
     lh      r1,jfcblksi                 |   Extract data set BLKSIZE
     st      r1,pwa_blksize              |      and save in PWA.
     mvc     pwa_recfm,jfcrecfm          |   Extract data set RECFM.
     if      (tbit,jfcbtsdm,jfcsds)      |   If SYSIN|SYSOUT data set.
       sbit  pwa_2_sysinout              |     Indicate in PWA.
     endif                               |   EndIf.
*    *----------------------------------------------------------------*
*    * Enforce data set/member replacement rules and ensure that the
*    * data set organization is consistent with the specified name.
*    *----------------------------------------------------------------*
*                                        |   If option=LIBRARY:
     if (cli,pwa_oc2_library,eq,&fi_oc2_library)
       if (clc,=c'PO',ne,pwa_dsorg)      |     If not PO or POU:
         callsub message,(fi00038)       |      It is an error.
         errexit code=0                  |      Exit.
       endif                             |     Endif.
     elseif (cli,pwa_member,ne,c" ")     |   Elseif MEMBER specified.
       if (clc,=c'PO',ne,pwa_dsorg)      |     If DSORG ¬= PO or POU.
         callsub message,(fi00108,pwa_dsname,pwa_member) Format msg.
         errexit code=0                  |                 Exit w/rc.
       endif                             |     EndIf.
       if (cli,pwa_oc2_chkpdsmemx,eq,&fi_oc2_chkpdsmem)
         callsub does_member_exist       |       See if member in PDS.
         if      (treg,r15,z)            |       If so.
           sbit  pwa_1,pwa_1_member      |         Flag for later.
           if    (cli,pwa_oc_disp,eq,&fi_oc_new)   If NEW specified.
             callsub message,(fi00117,pwa_member,pwa_dsname) ¬REPLACE.
             errexit code=0              |           Exit w/error code.
           endif                         |         EndIf.
         else                            |       Else, member ¬there.
           if (cli,pwa_oc_disp,eq,&fi_oc_existing) If EXISTING spec'd.
             callsub message,(fi00104,pwa_member,pwa_dsname)
             errexit code=0              |           Exit w/error code.
           endif                         |         EndIf.
         endif                           |       EndIf.
       endif                             |     EndIf.
     else                                |   Else.
       if (cli,pwa_oc_disp,eq,&fi_oc_new)      If NEW was specified.
         callsub message,(fi00128,pwa_dsname)    ¬REPLACE.
         errexit code=0                  |       Exit w/error code.
       endif                             |     EndIf.
       if (clc,=c'PO',eq,pwa_dsorg)      |     If DSORG = PO or POU.
         callsub message,(fi00103,pwa_dsname)    Member required.
         errexit code=0                  |       Exit w/return-code.
       endif                             |     EndIf.
     endif                               |   EndIf.
*    *----------------------------------------------------------------*
*    *
*    * If performing OUTPUT to a DDNAME, abends (013-34's, etc) may
*    * occur due to improperly coded or missing DCB attributes.  This
*    * section of code attempts to detect certain *missing* DCB
*    * attributes and supply reasonable defaults for them.  It does not
*    * check specified (non-missing) attributes for validity.
*    * This code only applies to DISP=NEW data sets, except as noted
*    * below for sysout files.
*    *
*    *----------------------------------------------------------------*
*    *
*    * DSC - When read-jfcb is used on a SYSOUT file, the returned DCB
*    * attributes for LRECL and BLKSIZE may be incorrect.  For example,
*    * one experiment in interactive TEST resulted in
*    * RECFM=VB,LRECL=240,BLKSIZE=240 (lrecl cannot equal blksize for
*    * VB datasets....abend 013-34).  The values coded on the DD
*    * statement for that experiment had a much higher BLKSIZE that was
*    * replaced by some component...presumably JES.  Since the output
*    * records will be stored the same regardless of the DCB attributes
*    * used (they go to spool), this code always overrides the DCB
*    * ---- changed, was RECFM=VB,LRECL=32756,BLKSIZE=32760 ---- mgg
*    * attributes for SYSOUT data sets to:
*    *   RECFM=F|FA,LRECL=pwa_maxlrecl,BLKSIZE=pwa_maxlrecl or
*    *   RECFM=V|VA,LRECL=pwa_maxlrecl,BLKSIZE=pwa_maxlrecl+4
*    * depending on whether variable and/or IOSCC was requested.
*    *
*    *----------------------------------------------------------------*
     if (cli,pwa_oo_mode,eq,&fi_oo_output)   If OUTPUT file.
       if (tbit,pwa_2_sysinout)          |     If SYSOUT file.
         sbit pwa_2_fios_supplies_dcb_attributes Indicate supplied.
         l    r1,pwa_maxlrecl            |       Set LRECL to maximum
         st   r1,pwa_lrecl               |       LRECL.
         if (tbit,pwa_1_fb)              |       If fixed requested:
          mvi  pwa_recfm,dcbrecf         |         Force RECFM=F.
         else                            |       Else:
          mvi  pwa_recfm,dcbrecv         |         Force RECFM=V.
          la   r1,4(,r1)                 |         BLKSIZE+=4.
         endif                           |       Endif.
         st   r1,pwa_blksize             |       Store BLKSIZE.
         if (cli,pwa_oc2_cc,eq,&fi_oc2_isocc)    If ISOCC requested:
           sbit  pwa_recfm,dcbrecca      |        Indicate in RECFM.
         endif                           |       Endif.
       elseif (cli,pwa_oc_ident,eq,&fi_oc_fileid), If DDname alloc'd   +
               and,(tbit,jfcbind2,jfcnew,on)   Elseif FILEID and NEW:
         sbit pwa_2_fios_supplies_dcb_attributes Indicate supplied.
         l  r1,pwa_lrecl                 |  R1  := existing LRECL.
         l  r15,pwa_blksize              |  R15 := existing BLKSIZE.
         if (treg,r1,z),and,(treg,r15,z),   If neither specified, and  +
               and,(tbit,pwa_recfm,dcbrecf+dcbrecv,ON)   RECFM=U then
             mvi  pwa_recfm,x'00'        |    Assume RECFM ¬specified.
         endif                           |  EndIf.
*                                        |
         if (cli,pwa_recfm,eq,x'00')     |  If no RECFM value.
           if (tbit,pwa_1_vb)            |    If caller requested VB
             sbit  pwa_recfm,dcbrecv+dcbrecbr   Make note in RECFM
           elseif (tbit,pwa_1_fb)        |    ElseIf caller wants FB.
             sbit  pwa_recfm,dcbrecf+dcbrecbr   Make note of FB.
           elseif (tbit,pwa_2_sysinout)  |    ElseIf SYSINOUT file.
             sbit  pwa_recfm,dcbrecv+dcbrecbr   Default to VB.
           else                          |    Else
             sbit  pwa_recfm,dcbrecf+dcbrecbr   Default to FB.
           endif                         |    EndIf.
           if (cli,pwa_oc2_cc,eq,&fi_oc2_isocc) If ISOCC requested:
             sbit  pwa_recfm,dcbrecca    |     Indicate in RECFM.
           endif                         |    Endif.
         endif                           |  EndIf.
*                                        |
         if (treg,r15,z)                 |  If BLKSIZE missing.
           lh  r15,=h'11476'             |    Assume BLKSIZE= 1/4 track
           if (tbit,pwa_recfm,dcbrecf)   |    If RECFM=F
             if  (treg,r1,z)             |      If LRECL missing.
               l  r1,pwa_avglrecl        |        Choose LRECL value.
               st r1,pwa_lrecl           |        Set chosen LRECL.
             endif                       |      EndIf.
             if (tbit,pwa_recfm,dcbrecbr,OFF)   If not blocked.
               lr r15,r1                 |        BLKSIZE = LRECL.
             elseif (cr,r1,gt,r15)       |        ElseIf LRECL>BLKSIZE.
               lr r15,r1                 |        BLKSIZE = LRECL.
             else                        |      Else.
               xr r14,r14                |        Adjust BLKSIZE to
               dr r14,r1                 |        an even multiple of
               xr r14,r14                |        LRECL.
               mr r14,r1                 |
             endif                       |      EndIf.
           else                          |    Else, RECFM = V.
             if  (treg,r1,z)             |      If LRECL missing.
               l  r1,pwa_maxlrecl        |        Choose LRECL value.
               st r1,pwa_lrecl           |        Set chosen LRECL.
             elseif (cr,r1,gt,r15)       |        ElseIf LRECL>BLKSIZE.
               la r15,4(,r1)             |        BLKSIZE = LRECL+4.
             endif                       |      EndIf.
             if (tbit,pwa_recfm,dcbrecbr,OFF),or,(cr,r1,gt,r15)
               la r15,4(,r1)             |        BLKSIZE = LRECL+4.
             endif                       |      EndIf.
           endif                         |    EndIf.
           st r15,pwa_blksize            |    Save chosen BLKSIZE.
         elseif (treg,r1,z)              |  ElseIf LRECL missing.
           if (tbit,pwa_recfm,dcbrecf)   |    If RECFM=F
             l  r1,pwa_avglrecl          |      Choose LRECL value.
             if (tbit,pwa_recfm,dcbrecbr,OFF),or,(cr,r1,gt,r15)
               lr  r1,r15                |        Use LRECL=BLKSIZE.
             else                        |      Else.
               xr r14,r14                |        Divide BLKSIZE by
               dr r14,r1                 |        chosen LRECL value.
               if (treg,r14,nz)          |        If ¬even multiple.
                 callsub message,(fi00125,pwa_blksize,pwa_avglrecl)
                 errexit code=0          |          Exit w/ret-code.
               endif                     |        EndIf.
             endif                       |      EndIf.
           else                          |    Else, RECFM = VB.
             l  r1,pwa_maxlrecl          |      Choose LRECL value.
             s  r15,=f'4'                |
             if (tbit,pwa_recfm,dcbrecbr,OFF),or,(cr,r1,gt,r15)
               lr r1,r15                 |        LRECL = BLKSIZE-4.
             endif                       |      EndIf.
           endif                         |    EndIf.
           st  r1,pwa_lrecl              |    Save as pwa_lrecl.
         endif                           |   EndIf.
       endif                             |   Not using OPTION FILEID.
     endif                               |  EndIf.
*    *----------------------------------------------------------------*
   endif  <Checks on existing datasets>  | EndIf.
   drop    r8                            | Drop the JFCB.
*  *------------------------------------------------------------------*
*  * Open for sequential INPUT or sequential OUTPUT.
*  *------------------------------------------------------------------*
   la    r8,pwa_dcb                      | Base on working DCB
   using ihadcb,r8                       | Get addressability.
   if (cli,pwa_oo_mode,eq,&fi_oo_input)  | If INPUT access mode.
     if (cli,pwa_oc2_library,eq,&fi_oc2_library)
       mvc   pwa_dcb(dcblngpo),&s.po_dcb |     Use BPAM DCB.
     else                                |
       mvc   pwa_dcb(dcblngps),&s.gl_dcb |     Use get-locate DCB.
     endif                               |
     mvc   dcbddnam,pwa_ddname           |   Set DDname in working DCB
     mvc   pwa_open(open_l),&psd.open    |   Copy OPEN's parmlist.
     block amode=24                      |   Begin-Amode24.
       open  (pwa_dcb,input),mf=(e,pwa_open) Open for INPUT.
       lr    r5,r15                      |     Save return-code.
     endblk                              |   End Amode-24.
   else                                  | Else, OUTPUT access mode.
     if (cli,pwa_member,ne,c' ')         |   If writing to a member.
       callsub spfedit_enq,(pwa_dsname,pwa_member) Enqueue on member.
       if      (treg,r15,nz)             |           If in-use.
         st   r15,pwa_save_r15           | Preserve r15 for errexit
         callsub message,(fi00119,pwa_member)          Error msg.
         l    r15,pwa_save_r15           | Rest r15 for debug analysis
         errexit code=0                  |             Exit w/ret-code.
       endif                             |           EndIf.
     endif                               |   EndIf.
     mvc   pwa_dcb(dcblngps),&s.pl_dcb   |   Use PUT-Locate DCB.
     if (tbit,pwa_2_fios_supplies_dcb_attributes)
       l     r1,pwa_lrecl                |   Include derived LRECL,
       sth   r1,dcblrecl                 |   BLKSIZE and RECFM in
       l     r1,pwa_blksize              |   DCB being built.
       sth   r1,dcbblksi                 |
       mvc   dcbrecfm,pwa_recfm          |
     endif                               |
     mvc   dcbddnam,pwa_ddname           |   Set DDname in working DCB.
     mvc   pwa_open(open_l),&psd.open    |   Copy OPEN's parmlist.
     block amode=24                      |   Begin-Amode24.
       if (cli,pwa_oc_disp,eq,&fi_oc_append) If APPEND option.
         open (pwa_dcb,extend),mf=(e,pwa_open) Open for EXTEND.
       else                              |    Else.
         open (pwa_dcb,output),mf=(e,pwa_open) Open for OUTPUT.
       endif                             |    Endif.
       lr    r5,r15                      |      Save return-code.
     endblk                              |   End Amode-24.
   endif                                 | EndIf.
*  *------------------------------------------------------------------*
*  * Check to see if OPEN succeeded and if RECFM supported.
*  *------------------------------------------------------------------*
   if (treg,r5,nz)                       | If OPEN failed.
     st   r15,pwa_save_r15               | Preserve r15 for errexit
     callsub message,(fi00102,pwa_dsname)    Format error message.
     l    r15,pwa_save_r15               | Rest r15 for debug analysis
     errexit code=0                      |   Exit w/return-code.
   endif                                 | EndIf.
   sbit    pwa_1,pwa_1_open              | Indicate past open.
*                                        |
   if not,(tbit,dcbrecfm,dcbrecu,mixed)  | If not FIXED or VARYING.
     callsub message,(fi00107)           |   Issue error msg.
     errexit code=0                      |   Exit w/ret-code.
   endif                                 | EndIf.
*                                        |
   l16   r1,dcblrecl                     | r1 := actual LRECL.
   st    r1,pwa_lrecl                    | Save as a fullword.
   mvc   pwa_recfm,dcbrecfm              | Copy actual RECFM.
*  *------------------------------------------------------------------*
*  * If OPTION=LIBRARY, BPAM is used.  Get a buffer for for DECBs and
*  * and maximum blocks.
*  *------------------------------------------------------------------*
   if (cli,pwa_oc2_library,eq,&fi_oc2_library)
*   *-----------------------------------------------------------------*
*   * Get storage for buffer entries (BENT).
*   *-----------------------------------------------------------------*
    lh    r1,dcbblksi                 |  Calculate size
    sm_ahi r1,bent_fixed_len+7        |  of one buffer entry
    srl   r1,3                        |  rounded up to
    sll   r1,3                        |  a multiple of 8.
    st    r1,pwa_bent_size            |  Save it.
    l8    r15,dcbncp                  |  Calculate size
    sth   r15,pwa_bent_count          |  of buffer needed
    mh    r1,pwa_bent_count           |  for dcbncp buffer
    st    r1,pwa_bent_buffer_size     |  entries.
    es_obtain_storage id=es,          |  Get storage for               +
               location=below,        |  all buffer entries.           +
               size=pwa_bent_buffer_size,                              +
               address=pwa_bent_buffer_address
    if not,(%es_success)              |  If not successful:
     st    r15,&w.rc                  |
     callsub message,(fi00010,&w.rc)  |   Save error message.
     errexit code=0                   |   Exit.
    endif                             |  Endif.
*   *-----------------------------------------------------------------*
*   * Link buffer entries into a circular list.
*   *-----------------------------------------------------------------*
    lh    r15,pwa_bent_count          |  r15 = buffer entry count.
    l     r1,pwa_bent_buffer_address  |  r1 -> first buffer entry.
    using bent_start,r1               |  Establish base for entry.
    loop until                        |  Loop chaining entries.
      sm_decr r15                     |   Decrement count.
      if np                           |   If last one:
       l     r0,pwa_bent_buffer_address    Point it back to
       st    r0,bent_next             |    first entry.
       leave loop=*                   |    Leave loop.
      else                            |   Else:
       lr    r0,r1                    |    Point r0 to
       al    r0,pwa_bent_size         |    next entry.
       st    r0,bent_next             |    Save it in this entry.
       lr    r1,r0                    |    Make next entry the current.
      endif                           |   Endif.
    endloop until,leave               |  Endloop.
    drop   r1                         |  Drop base for entry.
*   *-----------------------------------------------------------------*
   endif                              | Endif.
*  *------------------------------------------------------------------*
   drop r8                               | Drop addressability.
   callsub message,(fi00000)             | Successful completion.
 endblk block=open
*---------------------------------------------------------------------*
*  Static storage for opening an OS data set.
*---------------------------------------------------------------------*
          ssd
&s.gl_dcb dcb ddname=--------,macrf=(gl),dsorg=ps,synad=synad,eodad=eof
&s.po_dcb dcb ddname=--------,macrf=r,dsorg=po,synad=synad,eodad=eof
&s.pl_dcb dcb ddname=--------,macrf=(pl),dsorg=ps,synad=synad
          endssd
          swa
&w.rc     ds  f
          endswa
          eject
***********************************************************************
*                                                                     *
*  Subroutine: CLOSE                                                  *
*  Abstract  : Close the file without terminating.                    *
*                                                                     *
***********************************************************************
 block name=close,type=subroutine,amode=31
   if  (tbit,pwa_1_open,OFF)            | If file is not OPEN.
     callsub message,(fi00126,"not",3)   |   Issue an error message
     errexit code=0                      |   and exit w/ret-code.
   endif                                 | EndIf.
*---------------------------------------------------------------------*
*  If the data set is currently OPEN, close it and free its buffers.
*---------------------------------------------------------------------*
   la    r8,pwa_dcb                   | Establish addressability on
   using ihadcb,r8                    |   the OS Data Control Block.
   if (tbit,pwa_1_open),then
     block type=inline,amode=24       |   Start Amode=24.
       plist (pwa_dcb),vl             |     Set parms in working stg.
       close (pwa_dcb),mf=(e,(1))     |     Close the file.
       rbit   pwa_1,pwa_1_open        |     Reset OPEN flag.
       rbit   pwa_1,pwa_1_eof         |     Reset EndOfFile flag.
       callsub free_buffer_pool,(pwa_dcb)   Free DCB's buffer pool
     endblk                           |
   endif                              |
   if (tbit,pwa_2_member_enq)         | if spfedit enq was done
     callsub spfedit_deq,             |        Undo it.                +
               (pwa_dsname,pwa_member)
   endif                              |
*---------------------------------------------------------------------*
*  Free buffer entries buffer.
*---------------------------------------------------------------------*
  if (clc,pwa_bent_buffer_address,ne,=f'0')  If buffer obtained:
    es_release_storage id=es,         |        Release it.             +
               size=pwa_bent_buffer_size,                              +
               address=pwa_bent_buffer_address
    if not,(%es_success)              |        If release failed:
     st    r15,&w.rc                  |
     callsub message,(fi00043,&w.rc)  |         Save message.
     errexit code=0                   |         Exit.
    endif                             |        Endif.
    fill   pwa_bent_buffer_size       |        Clear size and
    fill   pwa_bent_buffer_address    |        address fields.
   endif                              |      Endif.
*---------------------------------------------------------------------*
   callsub message,(fi00000)             | Successful completion.
 endblk block=close
          swa
&w.rc     ds    f
          endswa
          eject
***********************************************************************
*                                                                     *
*  Subroutine: DELETE                                                 *
*  Abstract  : Delete the sequential data set or PDS member.          *
*                                                                     *
*  Note: If the data set or member is enqueued on (in-use) when this  *
*        function is invoked, it will fail.  We could add a WAIT      *
*        option to get around this.                                   *
*                                                                     *
***********************************************************************
 block name=delete,type=subroutine,amode=31
   if (tbit,pwa_1_open)                  | If file is open.
     callsub close                       |   Close it.
   endif                                 | EndIf.
*---------------------------------------------------------------------*
*  Handle the delete function for a PDS member.
*---------------------------------------------------------------------*
   if (clc,=c'PO',eq,pwa_dsorg)          | If deleting a member.
     callsub read_jfcb                   |   Read in PDS's JFCB.
     aif (not &security_check).skip1
     callsub security_check,("UPDATE")   |   Check RACF access.
.skip1 anop
     callsub spfedit_enq,(pwa_dsname,pwa_member) Enqueue on member.
     if (treg,r15,nz)                    |   If in-use.
       st   r15,pwa_save_r15             | Preserve r15 for errexit
       callsub message,(fi00119,pwa_member)    Error msg.
       l    r15,pwa_save_r15             | Rest r15 for debug analysis
       errexit code=0                    |     Exit w/ret-code.
     endif                               |   EndIf.
     la    r8,pwa_dcb                    |   r8 -> PO DCB to use.
     using ihadcb,r8                     |   Establish addressability.
     la    r7,pwa_jfcb                   |   r7 -> our copy of JFCB.
     using infmjfcb,r7                   |   Establish addressability.
     mvc   jfcbelnm,=cl8' '              |   Clear the member name.
     mvc   pwa_open(open_l),&psd.open    |   Copy OPEN plist to PWA.
     block amode=24                      |   Block Amode-24.
       open  (pwa_dcb,output),type=j,mf=(e,pwa_open)
     endblk                              |   EndBlk Amode-24.
     if (tbit,dcboflgs,dcbofopn,off)     |   If OPEN failed.
       callsub message,(fi00102,pwa_dsname)    Issue an error message.
       errexit code=0                    |     Exit with error-code.
     endif                               |   Endif.
     block amode=24                      |   Block Amode-24.
       stow    pwa_dcb,pwa_member,d      |     Delete the member.
       st      r15,&w.stow_rc            |     Save return-code.
       plist   (pwa_dcb),vl              |     Set plist in pwa.
       close   (pwa_dcb),mf=(e,(1))      |     Close PO DCB.
       callsub free_buffer_pool,(pwa_dcb)      Free its buffer pool.
     endblk                              |   EndBlk Amode-24.
     drop    r8,r7                       |   Drop DCB, JFCB addressing.
     callsub spfedit_deq                 |   Remove the enqueue.
     mvc &w.ddname,&s.ddname             |   Use DDNAME allocated to.
     mvc &w.unalloc,&s.unalloc           |   Set up UNALLOC text unit.
     mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname
     plist (&w.ddname,&w.unalloc),vl,pl=pwa_textunits
     callsub dynalloc,                   |   Free allocated file.      +
               (=al1(s99vrbun),          |   Unallocate function.      +
               =al1(s99nomnt,0),0,       |   Request-block flags.      +
               pwa_err_msg,              |   Return message area.      +
               =a(l'pwa_err_msg),        |   Length of message area.   +
               pwa_err_msg_len,          |   Length of returned msg.   +
               pwa_textunits),vl         |   Free by DDNAME.
     rbit      pwa_1,pwa_1_allocated         Reset allocated flag.
     rbit      pwa_2,pwa_2_free_on_terminate
     errexit (treg,r15,nz),code=0        |   If failure, exit w/code.
     l  r15,&w.stow_rc                   |   Pick up STOW's ret-code.
     st   r15,pwa_save_r15               | Preserve r15 for errexit
     if (treg,r15,z)                     |   If DELETE successful.
       callsub message,(fi00301,pwa_member,"deleted ",pwa_dsname)
     elseif (c,r15,eq,=f'8')             |   ElseIf member not found.
       callsub message,(fi00104,pwa_member,pwa_dsname)
     else                                |   Else, DELETE failed.
       callsub message,(fi00127,pwa_member,pwa_dsname,&w.stow_rc)
     endif                               |   EndIf.
     l    r15,pwa_save_r15               | Rest r15 for debug analysis
     errexit code=0                      |   Exit with return-code.
   endif                                 | EndIf.
   eject
*---------------------------------------------------------------------*
*  Handle the delete function for a sequential data set.
*---------------------------------------------------------------------*
   aif (not &security_check).skip2
   callsub security_check,("ALTER")      | Check RACF access.
.skip2 anop
*
*  If (allocated & ¬(SHR | PASS)) then override to DELETE and free it.
*
   if (tbit,pwa_1_allocated),and,                         If allocated +
               (cli,pwa_status,ne,pwa_status_shr),and,      and ¬SHR   +
               (cli,pwa_ndisp,ne,pwa_ndisp_pass)            and ¬PASS.
     mvc &w.ddname,&s.ddname             |   Use DDNAME allocated to.
     mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname
     mvc &w.ndisp_delete,&s.ndisp_delete |
     mvc &w.unalloc,&s.unalloc           |
     plist (&w.ndisp_delete,&w.ddname,&w.unalloc),vl,pl=pwa_textunits
     callsub dynalloc,                   |   Free allocated file.      +
               (=al1(s99vrbun),          |   Unallocate function.      +
               =al1(s99nomnt,0),0,       |   Request-block flags.      +
               pwa_err_msg,              |   Return message area.      +
               =a(l'pwa_err_msg),        |   Length of message area.   +
               pwa_err_msg_len,          |   Length of returned msg.   +
               pwa_textunits),vl         |   Textunits
     if    (treg,r15,z)                  |   If successful, then.
       st   r15,pwa_save_r15             | Preserve r15 for errexit
       rbit    pwa_1,pwa_1_allocated           Reset allocated flag.
       callsub message,(fi00300,pwa_dsname,,0,=cl8" ",,0,"deleted ")
       l    r15,pwa_save_r15             | Rest r15 for debug analysis
       errexit code=0                    |     Exit w/return-code.
     else                                |   Else.
       rbit    pwa_1,pwa_1_allocated           Reset allocated flag.
       rbit    pwa_2,pwa_2_free_on_terminate
     endif                               |   EndIf.
   endif                                 | EndIf.
*---------------------------------------------------------------------*
*  If still allocated to dataset, free it.
*---------------------------------------------------------------------*
   if (tbit,pwa_1_allocated)            | If allocated to dataset.
     mvc &w.ddname,&s.ddname             |   Use DDNAME allocated to.
     mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname
     plist (&w.ddname),vl,pl=pwa_textunits
     callsub dynalloc,                   |   Free allocated file.      +
               (=al1(s99vrbun),          |   Unallocate function.      +
               =al1(s99nomnt,0),0,       |   Request-block flags.      +
               pwa_err_msg,              |   Return message area.      +
               =a(l'pwa_err_msg),        |   Length of message area.   +
               pwa_err_msg_len,          |   Length of returned msg.   +
               pwa_textunits),vl         |   Free by DDNAME.
     rbit      pwa_1,pwa_1_allocated         Reset allocated flag.
     rbit      pwa_2,pwa_2_free_on_terminate
     errexit (treg,r15,nz),code=0        |   If failure, exit w/code.
   endif                                 | EndIf.
   eject
*---------------------------------------------------------------------*
*  Allocate to the dataset with (OLD,DELETE) and free it.
*---------------------------------------------------------------------*
   rbit    pwa_1,pwa_1_ds_not_existing     Reset ds-not-existing flag.
   mvc     &w.dsname,&s.dsname           | Copy DSNAME text unit.
   mvc     &w.ret_ddname,&s.ret_ddname   | Copy retrun DDNAME t.u.
   mvc     s99tupar-s99tunit+&w.dsname(44),pwa_dsname
   mvc     &w.stat_old,&s.stat_old       |
   mvc     &w.disp_delete,&s.disp_delete |
   plist (&w.ret_ddname,&w.dsname,&w.stat_old,&w.disp_delete),vl,      +
               pl=pwa_textunits
   callsub dynalloc,                     | Allocate to the dataset...  +
               (=al1(s99vrbal),          |     Using DSNAME allocation.+
               =al1(s99nomnt,0),         |     nomount,         @CNENQ +
               =al4(0),                  |     No authorized flags.    +
               pwa_err_msg,              |     Return message area.    +
               =a(l'pwa_err_msg),        |     Length of message area. +
               pwa_err_msg_len,          |     Length of returned msg. +
               pwa_textunits),vl         |     TextUnits
   errexit (treg,r15,nz),code=0          | If failure, exit w/code.
   mvc     pwa_ddname,s99tupar-s99tunit+&w.ret_ddname
*                                        |
   mvc &w.ddname,&s.ddname               | Use DDNAME allocated to.
   mvc (s99tupar-s99tunit)+&w.ddname(8),pwa_ddname
   mvc &w.unalloc,&s.unalloc             |
   plist (&w.ddname,&w.unalloc),vl,pl=pwa_textunits
   callsub dynalloc,                     | Free allocated file.        +
               (=al1(s99vrbun),          |   Unallocate function.      +
               =al1(s99nomnt,0),0,       |   Request-block flags.      +
               pwa_err_msg,              |   Return message area.      +
               =a(l'pwa_err_msg),        |   Length of message area.   +
               pwa_err_msg_len,          |   Length of returned msg.   +
               pwa_textunits),vl         |     TextUnits
   errexit (treg,r15,nz),code=0          | If failure, exit w/code.
   rbit    pwa_1,pwa_1_allocated         | Reset allocated flag.
   rbit    pwa_2,pwa_2_free_on_terminate
   callsub message,(fi00300,pwa_dsname,,0,=cl8" ",,0,"deleted ")
 endblk block=delete
*---------------------------------------------------------------------*
*  Storage for dynamic de-allocation of OS data sets.
*---------------------------------------------------------------------*
                ssd
&s.ndisp_delete text_unit dunovdsp,x'04'    Override NDISP=DELETE.
&s.unalloc      text_unit dununalc          Force unallocation.
&s.dsname       text_unit dundsnam,cl44" "  dsname=<blanks>
&s.ddname       text_unit dunddnam,cl8" "   ddname=<blanks>
&s.stat_old     text_unit dalstats,x'01'    DISP=OLD,
&s.disp_delete  text_unit dalndisp,x'04'         DELETE)
&s.ret_ddname   text_unit dalrtddn,cl8" "   Return-DDNAME.
                endssd
                swa
&w.ddname       ds        cl(l'&s.ddname)
&w.dsname       ds        cl(l'&s.dsname)
&w.ret_ddname   ds        cl(l'&s.ret_ddname)
&w.unalloc      ds        cl(l'&s.unalloc)
&w.stat_old     ds        cl(l'&s.stat_old)
&w.disp_delete  ds        cl(l'&s.disp_delete)
&w.ndisp_delete ds        cl(l'&s.ndisp_delete)
&w.stow_rc      ds        f
                endswa
                eject
***********************************************************************
*                                                                     *
*  Subroutine: READLINE                                               *
*  Abstract:   Obtain the next line from an already open file.        *
*                                                                     *
***********************************************************************
 block name=readline,type=subroutine,amode=31
*---------------------------------------------------------------------*
*  Insure that attempting to read the next sequential line is an okay
*  thing to do, considering the current type and status of the file
*  and the access mode requested when the file was opened.  The error
*  status flag has already been checked, at the beginning of the main
*  routine.
*---------------------------------------------------------------------*
   if (tbit,pwa_1_open,off)
     callsub message,(fi00114,"READLINE",8)
     errexit code=0
   elseif (tbit,pwa_1_eof)
     callsub message,(fi00200)      | Build end-of-file message.
     errexit code=&fi_end_of_file   | Exit w/end-of-file return-code.
   elseif (cli,pwa_oo_mode,ne,&fi_oo_input)
     callsub message,(fi00008)
     errexit code=0
   endif
*---------------------------------------------------------------------*
*  OK, get the next record.
*---------------------------------------------------------------------*
   la    r8,pwa_dcb
   using ihadcb,r8
   if (cli,pwa_oc2_library,eq,&fi_oc2_library),                        +
               name=get_record        | If OPTION=LIBRARY:
     if        not,(tbit,pwa_2_valid_find_active)
       callsub message,(fi00039)      |   Find required.
       errexit code=0                 |
     endif                            |
     l32   r0,pwa_bent_current_remaining  r0 = residual in block.
     if np                            |   If none left:
       l     r2,pwa_bent_current      |     Establish base
       using bent_start,r2            |     for BENT.
       l     r2,bent_next             |     Make next BENT
       st    r2,pwa_bent_current      |     the current one.
       block amode=24                 |
        check bent_decb               |      Check for complete.
       endblk                         |
       leave (tbit,pwa_1_eof),if=get_record Leave if EOF.
       lh    r0,dcbblksi              |     Calculate
       l     r1,bent_decb+16          |     size of
       sh    r0,14(,r1)               |     block read.
       st    r0,pwa_bent_current_remaining  Set this as size remaining.
       la    r1,bent_data_start       |     r1 -> first record in blk.
       st    r1,pwa_bent_current_cursor     Set this as cursor.
       drop  r2                       |     Drop base for bent.
     else                             |   Else:
       l     r1,pwa_bent_current_cursor     r1 -> next record in blk.
     endif                            |   Endif.
   else                               | Else:
     block amode=24                   |
      get   (r8)                      |   GET it.  R1 -> the record.
     endblk                           |
   endif                              | Endif
   errexit (tbit,pwa_1_error),code=&fi_severe
   if    (tbit,pwa_1_eof)             |
     callsub message,(fi00200)        | Build end-of-file message.
     errexit code=&fi_end_of_file     | Exit w/end-of-file return-code
   endif                              |
   eject                              |
*---------------------------------------------------------------------*
*  Set R4/R5 = Address/Length of the current logical record.
*---------------------------------------------------------------------*
   lr   r4,r1                       | Address of new record
   xr r5,r5                         | R5 := length of record.
   if (tbit,dcbrecfm,dcbrecf)       | If fixed-length records.
     if (tbit,dcbrecfm,dcbrecbr)    |   If blocked records.
       icm r5,b'0011',dcblrecl      |     R5 := length of record.
     else                           |   Else.
       icm r5,b'0011',dcbblksi      |     R5 := length of block.
     endif                          |   EndIf.
     la   r6,0(r5,r4)               |   R6 -> Past end of record.
     s    r6,=f'8'                  |   R6 -> Last eight characters.
     lr   r0,r5                     |   R0 := data length.
   else                             | Else variable-length records.
     icm  r5,b'0011',0(r4)          |   R5 := length of record.
     lr   r0,r5                     |   R0 := data length.
     sh   r5,=h'4'                  |   Subtract the RDW's length.
     la   r4,4(,r4)                 |   R4 -> logical record's text.
     lr   r6,r4                     |   R6 -> First eight characters.
   endif                            | EndIf.
   if (cli,pwa_oc2_library,eq,&fi_oc2_library)
     l     r15,pwa_bent_current_cursor
     ar    r15,r0                   |
     st    r15,pwa_bent_current_cursor
     l     r15,pwa_bent_current_remaining
     sr    r15,r0                   |
     st    r15,pwa_bent_current_remaining
   endif                            |
*---------------------------------------------------------------------*
*  Copy the current line to the caller's storage area.
*---------------------------------------------------------------------*
   l    r14,fi_rl_area              | R14 -> target area for record.
   l    r6,fi_rl_length             | R6  -> length to return.
   l    r15,fi_rl_area_size         | R15 -> length of target area.
   l    r15,0(r15)                  | R15 := length of target area.
   if   (cr,r15,gt,r5)              | If more than enough room.
     lr  r15,r5                     |   Only use the exact amount.
   endif                            | EndIf.
   st   r15,0(,r6)                  | Save length of current record.
*                                   |
   if   (treg,r5,p)                 | If anything to copy, then.
    la   r0,256                     |  Use for increments/decrements.
    loop while,(cr,r5,ge,r0),and,(cr,r15,ge,r0)
     mvc   0(256,r14),0(r4)         |    Move 256 bytes.
     if    (tbit,pwa_2_ascii)       |    If file is in ASCII.
      tr   0(256,r14),&s.ascii_to_ebcdic   Convert to ebcdic.
     endif                          |    EndIf.
     ar    r14,r0                   |    Bump target pointer.
     sr    r15,r0                   |    Decrement target length.
     ar    r4,r0                    |    Bump source pointer.
     sr    r5,r0                    |    Decrement source length.
    endloop while                   |  EndLoop.
    if (treg,r15,p),and,(treg,r5,p) |  If anything left.
     bctr r15,0                     |   Subtract 1 for EX instr.
     exi  r15,(mvc,0(0,r14),0(r4))  |   copy record to target area.
     if    (tbit,pwa_2_ascii)       |    If file is in ASCII.
      exi  r15,(tr,0(0,r14),&s.ascii_to_ebcdic)  Convert to ebcdic.
     endif                          |    EndIf.
     la   r15,1(,r15)               |   Add 1 back for comparison.
    endif                           |  EndIf.
    if   (cr,r15,lt,r5)             |  If record was truncated.
     callsub message,(fi00201,"Input ",0(r6))  Format a message.
     errexit code=0                 |   Exit with return-code.
    endif                           |  EndIf.
   endif                            | EndIf.
*---------------------------------------------------------------------*
*  If OPTION=LIBRARY and there is not data remaining in current BENT,
*  start a new READ.
*---------------------------------------------------------------------*
   if          (cli,pwa_oc2_library,eq,&fi_oc2_library),and,           +
               not,(tbit,pwa_1_eof),and,                               +
               (clc,pwa_bent_current_remaining,eq,=f'0')
    l     r2,pwa_bent_current
    block amode=24
     read  bent_decb-bent_start(,r2),sf,mf=e
    endblk
   endif
*---------------------------------------------------------------------*
   drop    r8
   callsub message,(fi00000)        | Successful completion.
 endblk block=readline
            ssd
&s.ascii_to_ebcdic ds    0cl256
         SMLIST CONVERT=NO            |
             dc c'................'   0
             dc c'................'   1
             dc c' !"#$%&&''()*+,-./' 2
             dc c'0123456789:;<=>?'   3
             dc c'@ABCDEFGHIJKLMNO'   4
             dc c'PQRSTUVWXYZÝ\¨¬_'   5
             dc c'`abcdefghijklmno'   6
             dc c'pqrstuvwxyz{|}~.'   7
             dc c'................'   8
             dc c'................'   9
             dc c' !"#$%&&''()*+,-./' a
             dc c'0123456789:;<=>?'   b
             dc c'@ABCDEFGHIJKLMNO'   c
             dc c'PQRSTUVWXYZÝ\¨¬_'   d
             dc c'`abcdefghijklmno'   e
             dc c'pqrstuvwxyz{|}~.'   f
         SMLIST CONVERT=YES           |
           endssd
 eject
***********************************************************************
*                                                                     *
*  Subroutine: WRITELINE                                              *
*  Abstract:   Obtain the next line from an already open file.        *
*                                                                     *
***********************************************************************
 block name=writeline,type=subroutine,amode=31
*---------------------------------------------------------------------*
*  Insure that attempting to read the next sequential line is an okay
*  thing to do, considering the current type and status of the file
*  and the access mode requested when the file was opened.  The error
*  status flag has already been checked, at the beginning of the main
*  routine.
*---------------------------------------------------------------------*
   if (tbit,pwa_1_open,off)
     callsub message,(fi00114,"WRITELINE",9)
     errexit code=0                   |
   elseif (cli,pwa_oo_mode,ne,&fi_oo_output)
     callsub message,(fi00012)        |
     errexit code=0                   |
   endif                              |
*---------------------------------------------------------------------*
*  OK, write the record using PUT-Locate, as follows:
*    .. If writing VL records, stuff length from caller into DCBLRECL.
*    .. Issue PUT. R1 will contain address of place to put the record
*       upon return.
*    .. Move record into buffer.
*---------------------------------------------------------------------*
   la    r8,pwa_dcb                   | r8 -> Working output DCB.
   using ihadcb,r8                    | Establish addressability.
   l     r6,fi_wl_line                | r6 -> Text of new output line.
   l     r7,fi_wl_length              | r7 -> Length of new line.
   icm   r7,b'1111',0(r7)             | r7 := Length of new line.
   slr   r5,r5                        | r5 := Truncation-flag register.
*                                     |
   if (tbit,dcbrecfm,dcbrecv)         | If variable-length output
     la  r7,4(r7)                     |   Adjust length for RDW.
     if  (c,r7,gt,pwa_lrecl)          |   If too large for dataset.
       callsub message,(fi00201,"Output",pwa_lrecl)
       lr      r5,r15                 |      Remember truncation.
       l       r7,pwa_lrecl           |      Use maximum length.
     endif                            |   EndIf.
     sth   r7,dcblrecl                |   Stuff record length into DCB.
     block amode=24                   |   Block-Amode24.
      put pwa_dcb                     |     Obtain next record buffer.
      lr  r2,r1                       |     r2 -> output record buffer.
     endblk                           |   Endblk-Amode24.
     errexit (tbit,pwa_1_error),code=&fi_severe
     mvc     0(2,r2),dcblrecl         |   Set record length.
     xc      2(2,r2),2(r2)            |   Clear reserved portion.
     la      r14,4(r2)                |   r14 -> past RDW in buffer.
     s       r7,=f'4'                 |   Adjust source length for RDW.
     lr      r15,r7                   |   Dest length = source length
*    mvcl    r14,r6 <---- used to be this Move record to buffer.
     if   (treg,r7,p)                 |   If anything to copy, then.
      la   r0,256                     |    For increments/decrements.
      loop while,(cr,r7,ge,r0),and,(cr,r15,ge,r0)
       mvc   0(256,r14),0(r6)         |      Move 256 bytes.
       if    (tbit,pwa_2_ascii)       |      If file is in ASCII.
        tr   0(256,r14),&s.ebcdic_to_ascii    Convert to ascii.
       endif                          |      EndIf.
       ar    r14,r0                   |      Bump target pointer.
       sr    r15,r0                   |      Decrement target length.
       ar    r6,r0                    |      Bump source pointer.
       sr    r7,r0                    |      Decrement source length.
      endloop while                   |    EndLoop.
      if (treg,r15,p)                 |    If anything left.
       bctr r15,0                     |     Subtract 1 for EX instr.
       exi  r15,(mvc,0(0,r14),0(r6))  |     copy record to target area.
       if    (tbit,pwa_2_ascii)       |      If file is in ASCII.
        exi  r15,(tr,0(0,r14),&s.ebcdic_to_ascii)    Convert to ascii.
       endif                          |      EndIf.
      endif                           |    EndIf.
     endif                            |   EndIf.
     ltr     r15,r5                   |   Get truncation return-code.
     errexit nz,code=0                |   Exit if truncated.
   else                               | Else, fixed-length output.
     block amode=24                   |   Block-Amode24.
      put pwa_dcb                     |     Obtain next record buffer.
      lr  r2,r1                       |     r2 -> output record buffer.
     endblk                           |   Endblk-Amode24.
     errexit (tbit,pwa_1_error),code=&fi_severe
     if  (c,r7,gt,pwa_lrecl)          |   If too large for dataset.
       callsub message,(fi00201,"Output",pwa_lrecl)
       lr      r5,r15                 |      Remember truncation.
       l       r7,pwa_lrecl           |      Use maximum length.
     endif                            |   EndIf.
     lr      r14,r2                   |   Move buffer addr to r14
     lh      r15,dcblrecl             |   Dest length = fixed LRECL.
*    icm     r7,b'1000',=c' '         |   Using blank for a pad char.
*    mvcl    r14,r6 <---- used to be this Move record to buffer.
     if   (treg,r7,p),or,(treg,r15,p) |   If anything to copy, then.
      la   r0,256                     |    For increments/decrements.
      loop while,(cr,r7,ge,r0),and,(cr,r15,ge,r0)
       mvc   0(256,r14),0(r6)         |      Move 256 bytes.
       if    (tbit,pwa_2_ascii)       |      If file is in ASCII.
        tr   0(256,r14),&s.ebcdic_to_ascii    Convert to ascii.
       endif                          |      EndIf.
       ar    r14,r0                   |      Bump target pointer.
       sr    r15,r0                   |      Decrement target length.
       ar    r6,r0                    |      Bump source pointer.
       sr    r7,r0                    |      Decrement source length.
      endloop while                   |    EndLoop.
      if (treg,r15,p),and,(treg,r7,p) |    If anything left.
       lr  r1,r15                     |     r1 := dest length.
       if  (cr,r1,gt,r7)              |     if more than source len
        lr  r1,r7                     |      use source len
       endif                          |     endif
       bctr r1,0                      |     Subtract 1 for EX instr.
       exi  r1,(mvc,0(0,r14),0(r6))   |     copy record to target area.
       if    (tbit,pwa_2_ascii)       |      If file is in ASCII.
        exi  r1,(tr,0(0,r14),&s.ebcdic_to_ascii)    Convert to ascii.
       endif                          |      EndIf.
       la   r1,1(,r1)                 |     Add 1 back for updates.
       ar   r14,r1                    |     Bump target pointer.
       sr   r15,r1                    |     Decrement target length.
       ar   r6,r1                     |     Bump source pointer.
       sr   r7,r1                     |     Decrement source length.
      endif                           |    EndIf.
      if (treg,r15,p)                 |    If padding required.
       loop while,(cr,r15,ge,r0)      |     Loop for big chunks.
        mvc  0(256,r14),=cl256' '     |      Fill w/blanks.
        ar   r14,r0                   |      Bump target pointer.
        sr   r15,r0                   |      Decrement target length.
       endloop while                  |     EndLoop.
       if (treg,r15,p)                |     If anything left.
        bctr r15,0                    |      Subtract 1 for EX instr.
        exi  r15,(mvc,0(0,r14),=cl256' ')    Pad remainder w/blanks.
       endif                          |     EndIf.
      endif                           |    EndIf.
     endif                            |   EndIf.
     ltr     r15,r5                   |   Get truncation return-code.
     errexit nz,code=0                |   Exit if truncated.
   endif                              | EndIf.
   callsub message,(fi00000)          | Successful completion.
 endblk block=writeline               |
             ssd
&s.ebcdic_to_ascii ds    0cl256
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
             dc x'2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E'   0
             dc x'2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E'   1
             dc x'2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E'   2
             dc x'2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E'   3
             dc x'202E2E2E2E2E2E2E2E2E2E2E3C282B7C'   4
             dc x'262E2E2E2E2E2E2E2E2E21242A293B5E'   5
             dc x'2D2F2E2E2E2E2E2E2E2E7C2C255F3E3F'   6
             dc x'2E2E2E2E2E2E2E2E2E603A2340273D22'   7
             dc x'2E6162636465666768692E7B2E282B2B'   8
             dc x'2E6A6B6C6D6E6F7071722E7D2E292E2E'   9
             dc x'2E2E737475767778797A2E2E2E5B2E2E'   A
             dc x'303132333435363738392E2E2E5D2E2D'   B
             dc x'7B4142434445464748492E2E2E2E2E2E'   C
             dc x'7D4A4B4C4D4E4F5051522E2E2E2E2E2E'   D
             dc x'5C00535455565758595A2E2E2E2E2E2E'   E
             dc x'303132333435363738392E2E2E2E2E2E'   F
             endssd
             swa
&w.putbuf    ds   a
&w.length    ds   f
             endswa
 eject                                |
***********************************************************************
*                                                                     *
*  Subroutine: GET_INFO                                               *
*  Abstract:   Return selected information to the caller.             *
*                                                                     *
***********************************************************************
 block name=get_info,type=subroutine  |
* *-------------------------------------------------------------------*
* * Return info for each information sub-code parameter.
* *-------------------------------------------------------------------*
  la     r7,fi_gi_function            | r7 -> 1st info subcode parm.
  using  fi_gi_function,r7            | Address get_info parms.
  loop   until                        | Loop for each gi_function parm.
   l       r2,fi_gi_function          |   R2 -> information sub-code.
   l       r1,0(,r2)                  |   R1 := information sub-code.
   caseblk reg=r1,wreg=r1,mult=1      |   Case on information sub-code.
   case &fi_gi_msg                    | *-------------------------> MSG
     if not,((tbit,fi_gi_function,x'80',off),and,    make sure area,   +
               (tbit,fi_gi_area,x'80',off),and,      area_size, and    +
               (tbit,fi_gi_area_size,x'80',off))     length are present
       callsub message,(fi00006,"GET_INFO (MSG)",14)
       errexit code=0                 |
     endif                            |   EndIf.
     lm r2,r3,fi_gi_area              |   R2/R3 -> text area, length.
     l  r3,0(r3)                      |   R3 := length of text area.
     lm r4,r5,pwa_msg_data            |   R4/R5 -> message text/length.
     if (treg,r4,z),or,(treg,r5,z)    |   If no message then.
       slr  r4,r4                     |     Ensure both address and
       slr  r5,r5                     |     length are all zeros.
     else                             |   Else.
       l  r5,0(r5)                    |     R5 := length of message.
       if (cr,r5,gt,r3)               |     If too long to fit in area.
         lr r5,r3                     |       Reduce to exact length.
       endif                          |     EndIf.
     endif                            |   EndIf.
     l    r1,fi_gi_length             |   R1 -> message length parm.
     st   r5,0(r1)                    |   Save length of returned msg.
     icm  r5,8,=c' '                  |   Pad copied text with blanks.
     mvcl r2,r4                       |   Copy information to caller.
     if   (tbit,fi_gi_length,x'80',on)    If we used the last parm.
      leave loop=*                    |    We're done.
     endif                            |   EndIf.
     la   r7,4*4(,r7)                 |   Point r7 past parms we used.
   case &fi_gi_name                   | *------------------------> NAME
     if not,((tbit,fi_gi_function,x'80',off),and,    make sure area,   +
               (tbit,fi_gi_area,x'80',off),and,      area_size, and    +
               (tbit,fi_gi_area_size,x'80',off))     length are present
       callsub message,(fi00006,"GET_INFO (NAME)",15)
       errexit code=0                 |
     endif                            |   EndIf.
     lm r2,r4,fi_gi_area              |   R2/R4 -> area/length/retlen.
     la r5,=f'0'                      |   Set up zero-length.
     if (cli,pwa_member,ne,c' ')      |   If there is a member name.
       la r5,=f'1'                    |     R1 := length of ( or ).
     endif                            |   EndIf.
     lr        r14,r2                 |   r14 -> area.
     l         r15,0(r3)              |   r15 := length of area.
     slr       r0,r0                  |   r0 -> Null source string.
     slr       r1,r1                  |   r1 := Null source length.
     icm       r1,b'1000',=c' '       |   Insert blank for padding.
     mvcl      r14,r0                 |   Clear area w/blanks.
     st_format id=st,string=(0(r2),0(r3)),resultlen=0(r4),             +
               control="{CL44 TRIM}{CL?}{CL8 T}{CL?}",                 +
               source=(pwa_dsname,"(",0(r5),pwa_member,")",0(r5))
     if (c,r15,eq,=f'&st_truncated')  |   If filename truncated.
       callsub message,(fi00021)      |     Issue a message and quit.
       errexit code=0                 |
     elseif (treg,r15,nz)             |   ElseIf a problem occurred.
       callsub message,(fi00003)      |     Internal error.
       errexit code=0                 |
     endif                            |   EndIf.
     if   (tbit,fi_gi_length,x'80',on)    If we used the last parm.
      leave loop=*                    |    We're done.
     endif                            |   EndIf.
     la   r7,4*4(,r7)                 |   Point r7 past parms we used.
   case &fi_gi_ddname                 | *----------------------> DDNAME
     if not,((tbit,fi_gi_function,x'80',off),and,    make sure area,   +
               (tbit,fi_gi_area,x'80',off),and,      area_size, and    +
               (tbit,fi_gi_area_size,x'80',off))     length are present
       callsub message,(fi00006,"GET_INFO (DDNAME)",17)
       errexit code=0                 |
     endif                            |   EndIf.
     lm r2,r4,fi_gi_area              |   R2/R4 -> area/length/retlen.
     lr        r14,r2                 |   r14 -> area.
     l         r15,0(r3)              |   r15 := length of area.
     slr       r0,r0                  |   r0 -> Null source string.
     slr       r1,r1                  |   r1 := Null source length.
     icm       r1,b'1000',=c' '       |   Insert blank for padding.
     mvcl      r14,r0                 |   Clear area w/blanks.
     st_format id=st,string=(0(r2),0(r3)),resultlen=0(r4),             +
               control="{CL? TRIM}",                                   +
               source=(pwa_ddname,=a(l'pwa_ddname))
     if (c,r15,eq,=f'&st_truncated')  |   If filename truncated.
       callsub message,(fi00021)      |     Issue a message and quit.
       errexit code=0                 |
     elseif (treg,r15,nz)             |   ElseIf a problem occurred.
       callsub message,(fi00003)      |     Internal error.
       errexit code=0                 |
     endif                            |   EndIf.
     if   (tbit,fi_gi_length,x'80',on)    If we used the last parm.
      leave loop=*                    |    We're done.
     endif                            |   EndIf.
     la   r7,4*4(,r7)                 |   Point r7 past parms we used.
   case &fi_gi_volume                 | *----------------------> VOLUME
     if not,((tbit,fi_gi_function,x'80',off),and,    make sure area,   +
               (tbit,fi_gi_area,x'80',off),and,      area_size, and    +
               (tbit,fi_gi_area_size,x'80',off))     length are present
       callsub message,(fi00006,"GET_INFO (VOLUME)",17)
       errexit code=0                 |
     endif                            |   EndIf.
     lm r2,r4,fi_gi_area              |   R2/R4 -> area/length/retlen.
     lr        r14,r2                 |   r14 -> area.
     l         r15,0(r3)              |   r15 := length of area.
     slr       r0,r0                  |   r0 -> Null source string.
     slr       r1,r1                  |   r1 := Null source length.
     icm       r1,b'1000',=c' '       |   Insert blank for padding.
     mvcl      r14,r0                 |   Clear area w/blanks.
     st_format id=st,string=(0(r2),0(r3)),resultlen=0(r4),             +
               control="{CL? TRIM}",                                   +
               source=(pwa_volser,=a(l'pwa_volser))
     st   r15,pwa_save_r15            | Preserve r15 for errexit
     if (c,r15,eq,=f'&st_truncated')  |   If filename truncated.
       callsub message,(fi00021)      |     Issue a message and quit.
       l    r15,pwa_save_r15          | Rest r15 for debug analysis
       errexit code=0                 |
     elseif (treg,r15,nz)             |   ElseIf a problem occurred.
       callsub message,(fi00003)      |     Internal error.
       l    r15,pwa_save_r15          | Rest r15 for debug analysis
       errexit code=0                 |
     endif                            |   EndIf.
     if   (tbit,fi_gi_length,x'80',on)    If we used the last parm.
      leave loop=*                    |    We're done.
     endif                            |   EndIf.
     la   r7,4*4(,r7)                 |   Point r7 past parms we used.
   case &fi_gi_lrecl                  | *-----------------------> LRECL
     if not,(tbit,fi_gi_function,x'80',off)           make sure area
       callsub message,(fi00006,"GET_INFO (LRECL)",16)    is present.
       errexit code=0                 |
     endif                            |   EndIf.
     if (tbit,pwa_1_open,off) If file is not OPEN.
       callsub message,(fi00114,"GET_INFO (LRECL)",16)
       errexit code=0                 |     Exit w/return-code.
     else                             |   Else.
       l     r2,fi_gi_area            |     R2 -> Halfword for LRECL.
       l     r1,pwa_lrecl             |     R1 := actual lrecl.
       stcm  r1,b'0011',0(r2)         |     Copy lrecl value to area.
     endif                            |   EndIf.
     if   (tbit,fi_gi_area,x'80',on)  |   If we used the last parm.
      leave loop=*                    |    We're done.
     endif                            |   EndIf.
     la   r7,2*4(,r7)                 |   Point r7 past parms we used.
   case &fi_gi_recfm                  | *-----------------------> RECFM
     if not,(tbit,fi_gi_function,x'80',off)           make sure area
       callsub message,(fi00006,"GET_INFO (RECFM)",16)    is present
       errexit code=0                 |
     endif                            |   EndIf.
     if (tbit,pwa_1_open,off) If file is not OPEN.
       callsub message,(fi00114,"GET_INFO (RECFM)",16)
       errexit code=0                 |     Exit w/return-code.
     else                             |   Else.
       l     r2,fi_gi_area            |     R2 -> Return area.
       mvc   0(8,r2),=cl8' '          |     Blank out unused positions.
       la    r3,pwa_dcb               |     R3 -> File's open DCB.
       using ihadcb,r3                |     Establish addressability.
       if  (tbit,dcbrecfm,dcbrecf)    |     If FIXED length records.
         mvi 0(r2),c"F"               |       Return an 'F'.
       else                           |     Else.
         mvi 0(r2),c"V"               |       Return a 'V'.
       endif                          |     EndIf.
       if  (tbit,dcbrecfm,DCBRECBR)   |     If BLOCKED records.
         mvi 1(r2),c"B"               |       Return a 'B'.
       endif                          |     EndIf.
       if  (tbit,dcbrecfm,dcbrecca)   |     IF ASA control char
        mvi 2(r2),c"A"                |       Return an "A".
       elseif  (tbit,dcbrecfm,dcbreccm)     ElseIF Machine control char
        mvi 2(r2),c"M"                |       Return an "M".
       endif                          |     EndIf.
     endif                            |   EndIf.
     if   (tbit,fi_gi_area,x'80',on)  |   If we used the last parm.
      leave loop=*                    |    We're done.
     endif                            |   EndIf.
     la   r7,2*4(,r7)                 |   Point r7 past parms we used.
   case &fi_gi_idstring               | *--------------------> IDSTRING
     if not,(tbit,fi_gi_function,x'80',off)            make sure area
       callsub message,(fi00006,"GET_INFO (IDSTRING)",19)  is present.
       errexit code=0                 |
     endif                            |   EndIf.
     if (tbit,pwa_1_open,off) If file is not OPEN.
       callsub message,(fi00114,"GET_INFO (IDSTRING)",19)
       errexit code=0                 |     Exit w/return-code.
     else                             |   Else.
       l r2,fi_gi_area                |     R2 -> Return area.
       mvc 0(8,r2),=cl8' '            |     Initialize it to blanks.
       if (cli,pwa_member,ne,c' ')    |     If there is a member name.
         mvc 0(8,r2),pwa_member       |       Copy member name.
       else                           |     Else.
         ds  0h                       |       Do nothing.
       endif                          |     EndIf.
     endif                            |   EndIf.
     if   (tbit,fi_gi_area,x'80',on)  |   If we used the last parm.
      leave loop=*                    |    We're done.
     endif                            |   EndIf.
     la   r7,2*4(,r7)                 |   Point r7 past parms we used.
   case other                         | *---------------------> *ERROR*
       callsub message,(fi00022,0(r2))
       errexit code=0
   endcase                            | EndCase
  endloop until,leave                 | EndLoop.
 endblk block=get_info                |
           swa
           endswa
 eject
***********************************************************************
*                                                                     *
*  Subroutine: SET_STATUS                                             *
*  Abstract:   Set status information about the current file based on *
*              the provided parameters.                               *
*                                                                     *
***********************************************************************
 block name=set_status,type=subroutine
*---------------------------------------------------------------------*
*  Call the routine that sets the specified status.
*---------------------------------------------------------------------*
   l       r2,fi_ss_function          | R2 -> status sub-code.
   l       r1,0(,r2)                  | R1 := status sub-code.
   caseblk reg=r1,wreg=r1,mult=1      | Case on status sub-code.
   case &fi_ss_end_of_file            | *-----------------> END_OF_FILE
     if (cli,pwa_oo_mode,eq,&fi_oo_input)    If INPUT mode.
       sbit pwa_1,pwa_1_eof           |        Mark end-of-file.
     elseif (cli,pwa_oo_mode,eq,&fi_oo_output) If OUTPUT mode.
       if (cli,pwa_member,ne,c" "),and,        If a member written to  +
               (tbit,pwa_1_ds_not_existing,off) existing pds.
         if (tbit,pwa_1_member)                  If replaced.
           la r6,=cl8"replaced"       |            R6 -> "REPLACED"
         else                         |          Else, created.
           la r6,=cl8"created "       |            R6 -> "CREATED "
         endif                        |          EndIf.
         callsub message,(fi00301,pwa_member,0(r6),pwa_dsname)
       else                           |        ELSE
         if (tbit,pwa_1_ds_not_existing) if dataset created.
           la r6,=cl8"created "       |            R6 -> "CREATED "
         else                         |          Else, replaced.
           la r6,=cl8"replaced"       |            R6 -> "REPLACED"
         endif                        |          EndIf.
         la r5,=f'0'                  |          Set up zero-length.
         if (cli,pwa_member,ne,c' ')  |          If a member name.
           la r5,=f'1'                |            R5 := length of "(".
         endif                        |          EndIf.
         callsub message,(fi00300,    |                                +
               pwa_dsname,"(",0(r5),pwa_member,")",0(r5),0(r6))
       endif                          |        EndIf.
     endif                            |      EndIf.
     errexit code=&fi_end_of_file     |      Exit w/EOF return-code.
   case other                         | *---------------------> *ERROR*
     callsub message,(fi00031,0(r2))  |   Issue an error message.
     errexit code=0                   |   Exit w/return-code.
   endcase                            | EndCase
   callsub message,(fi00000)          | Successful completion.
 endblk block=set_status
***********************************************************************
*                                                                     *
*  Subroutine: GET_REFERENCE                                          *
*  Abstract:   Return reference string to the caller.                 *
*                                                                     *
***********************************************************************
 block name=get_reference,type=subroutine  |
* *-------------------------------------------------------------------*
* * Return reference string.
* *-------------------------------------------------------------------*
  l      r7,fi_gr_reference           | r7 -> reference string.
  mvc   0(l'pwa_fi_reference,r7),pwa_fi_reference
 endblk block=get_reference           |
*                                     |   to caller.
 eject
***********************************************************************
*                                                                     *
*  Subroutine: FIND                                                   *
*  Abstract:   Process FIND function.                                 *
*                                                                     *
***********************************************************************
 block name=find,type=subroutine,amode=31,options=codebase
*  *------------------------------------------------------------------*
*  * Make sure file is open and OPTION=LIBRARY is specified.
*  *------------------------------------------------------------------*
   if (tbit,pwa_1_open,off)           |  If not open:
     callsub message,(fi00114,"FIND",4) Fuss.
     errexit code=0                   |    Exit.
   elseif (cli,pwa_oc2_library,ne,&fi_oc2_library) If LIBRARY option.
     callsub message,(fi00042,"FIND",4)  Elseif not OPTION=LIBRARY:
     errexit code=0                   |    Fuss and exit.
   endif                              |  Endif.
*  *------------------------------------------------------------------*
*  * Initialize.
*  *------------------------------------------------------------------*
   fill  pwa_member,x'40'             |  Blank out member name.
   sbit  pwa_1_eof                    |  Indicate EOF.
   rbit  pwa_2_valid_find_active      |  Indicate no active FIND.
*  *------------------------------------------------------------------*
*  * Move member name to PWA.
*  *------------------------------------------------------------------*
   l     r2,fi_fd_length              |  r2 -> length.
   l     r15,0(,r2)                   |  r15 = length.
   if (treg,r15,np)                   |  if not positive:
     callsub message,(fi00014)        |    Save error message
     errexit code=0                   |    and exit.
   elseif (chi,r15,gt,l'pwa_member)   |  Else if too long:
     callsub message,(fi00015,0(,r2)) |    Save error message
     errexit code=0                   |    and exit.
   endif                              |  Endif.
   bctr  r15,0                        |  Sub 1 for ex.
   l     r1,fi_fd_member              |  r1 -> requested member.
   exi   r15,(mvc,pwa_member,0(r1))   |  Move it to pwa.
   tr   pwa_member,fold               |  Fold member-name to caps.
   trt  pwa_member,lettrdig           |  Scan for invalid characters.
   if  (nz,and,(cli,0(r1),ne,c' ')),or,(cli,pwa_member,ge,c'0')
     callsub message,(fi00016,pwa_member) Name must not start with
     errexit code=0                   |   number or be blank.
   endif                              |
*  *------------------------------------------------------------------*
*  * Find member.
*  *------------------------------------------------------------------*
   block amode=24                     |  Block amode=24.
     find  pwa_dcb,pwa_member,d       |    Find member.
     st    r0,&w.reason               |    Save reason.
     st    r15,&w.rc                  |    Save return code.
   endblk                             |  Endif.
   l     r0,&w.reason                 |  r0 = reason.
   l     r15,&w.rc                    |  r15 = return code.
   if (treg,r15,z)                    |  If find successful:
     sbit  pwa_2_valid_find_active    |    Indicate valid find active.
     rbit  pwa_1_eof                  |    Reset EOF.
*    *----------------------------------------------------------------*
*    * Do initial reads.  Set current as final BENT with remaining
*    * of zero so that first FI_READLINE will wrap to first BENT
*    * and do a CHECK.
*    *----------------------------------------------------------------*
     fill  pwa_bent_current_remaining |    No date in current buffer.
     l     r3,pwa_bent_buffer_address |    Establish base for
     using bent_start,r3              |    buffer entries.
     loop until                       |    Loop starting reads:
      st    r3,pwa_bent_current       |      Current will be last buff.
      mvc   bent_decb,&psd.decb       |      Move base DECB to entry.
      block amode=24                  |      Block amode=24.
       read  bent_decb,sf,pwa_dcb,bent_data_start,mf=e   Read block.
      endblk                          |      Endblk.
      l     r3,pwa_bent_buffer_address       Point to next buffer.
     endloop until,(c,r3,eq,pwa_bent_buffer_address)
     drop  r3                         |    Endloop.  Drop entry base.
*    *----------------------------------------------------------------*
   elseif (chi,r15,eq,4),and,(treg,r0,z) Else if member not found:
     callsub message,(fi00040,pwa_member)  Save message.
     errexit code=&fi_not_found       |    Exit.
   else                               |  Else:
     callsub message,(fi00041,pwa_member,&w.rc,&w.reason)
     errexit code=0                   |    Save message and exit.
   endif                              |  Endif.
*  *------------------------------------------------------------------*
   callsub message,(fi00000)          |  Successful completion.
 endblk block=find                    |
         swa                          |
&w.rc                          ds f   |
&w.reason                      ds f   |
         endswa                       |
 eject
 title "SRVFIOS - Internal subroutines called by Function routines"
***********************************************************************
*                                                                     *
*  Subroutine: PARSE_FILENAME                                         *
*  Abstract:   Scan the file-specification to validate it as an OS    *
*              data set name and to split the dsname from the member. *
*                                                                     *
***********************************************************************
 block name=parse_filename,type=subroutine
   fill pwa_dsname,c' '           |   Blank out the data set name.
   mvc  pwa_member,=cl8' '        |   Blank out the member name.
*---------------------------------------------------------------------*
*  R4 -> file-specification.  R5 := file specification's length.
*---------------------------------------------------------------------*
   l     r4,fi_filename           | R4 := file-specification's text.
   la    r4,0(,r4)                | Clear high-bit.
   leave block=*,(treg,r4,z)      | Return now if null.
   l  r5,fi_namelength            | R5 -> length of file-specification.
   l  r5,0(,r5)                   | R5 := length of file-specification.
   if (treg,r5,np)                | If zero-length filename.
     callsub message,(fi00011)    |   Issue a message and quit.
     errexit code=0               |
   endif                          | EndIf.
*---------------------------------------------------------------------*
*  If the file is identified by DDNAME, copy it to the PWA.
*---------------------------------------------------------------------*
   if (cli,pwa_oc_ident,eq,&fi_oc_fileid)
     st        r5,&w.length         | Save length for parmlist access.
     st_format id=st,string=pwa_ddname,control='{?cl? caps trim}',     +
               source=(=a(l'pwa_ddname),0(r4),&w.length)
     st   r15,pwa_save_r15          | Preserve r15 for errexit
     if (c,r15,eq,=f'&st_truncated')  if longer than 8 characters.
       callsub message,(fi00025,=a(l'pwa_ddname),(r4),&w.length)
       l    r15,pwa_save_r15        | Restore r15 for debug analysis
       errexit code=0               |
     elseif (treg,r15,nz)           | Else.
       callsub message,(fi00003)    |   Unknown error.
       l    r15,pwa_save_r15        | Restore r15 for debug analysis
       errexit code=0               |   Return to caller.
     endif                          | EndIf.
     leave block=*
   endif
   eject
*---------------------------------------------------------------------*
*  If the file-spec is quoted, remove quotes.  Else obtain prefix.
*---------------------------------------------------------------------*
   fill    &w.prefix,c' '         | No dsname prefix being used, yet.
   la      r5,0(r5,r4)            | R5 -> past end of file-spec.
   loop    until                  | Scan back for final non-blank.
    bctr  r5,0                    |  Back up one character.
   endloop until,(cr,r5,le,r4),or,(cli,0(r5),gt,c' ')
   if (cli,0(r4),eq,c'''')        | If file-spec is quoted, then.
     la r4,1(,r4)                 |   Advance past starting quote.
     if (cli,0(r5),eq,c'''')      |   If trailing quote is present.
       bctr  r5,0                 |     Remove trailing quote.
     endif                        |   EndIf.
     if (cr,r4,gt,r5)             |   If zero-length filename.
       callsub message,(fi00011)  |     Issue a message and quit.
       errexit code=0             |
     endif                        |   EndIf.
   else                           | Else -- it needs to be prefixed --
     es_get_prefix id=es,prefix=&w.prefix
     if (cli,&w.prefix,ne,c' ')   |   If a prefix was obtained.
       la      r15,&w.prefix+7    |      Point to end of 8-byte field.
       loop    bct                |      Loop back to a non-blank.
         leave loop=*,(cli,0(r15),ne,c' ')
       endloop bct,r15            |      EndLoop.
       mvi     1(r15),c'.'        |      Put '.' on end of prefix.
     endif                        |   EndIf.
   endif                          |
   eject
*---------------------------------------------------------------------*
*  Copy the data set name to PWA storage and fold it to uppercase.
*---------------------------------------------------------------------*
   lr   r7,r4                     | R7 -> Start of data set name.
   loop while,(cr,r7,le,r5)
     leave loop=*,(cli,0(r7),le,c' ')
     leave loop=*,(cli,0(r7),eq,c'(')
     la r7,1(,r7)                 |   Advance to next character.
   endloop while                  | EndLoop.
   sr r7,r4                       | R7 := length of dsname.
   if (treg,r7,np)                | If zero-length filename.
     callsub message,(fi00011)    |   Issue a message and quit.
     errexit code=0               |
   endif                          | EndIf.
   st        r7,&w.length         | Save length for plist access.
   st_format id=st,string=pwa_dsname,                                  +
               control="{?CL0}{@1CL9 CAPS TRIM}{CL? CAPS}",            +
               source=(=a(l'pwa_dsname),,&w.prefix,0(r4),&w.length)
   st   r15,pwa_save_r15          | Preserve r15 for errexit
   if (c,r15,eq,=f'&st_truncated')  if longer than 44 characters.
     callsub message,(fi00018,=a(l'pwa_dsname),(r4),&w.length)
     l    r15,pwa_save_r15        | Restore r15 for debug analysis
     errexit code=0               |
   elseif (treg,r15,nz)           | Else.
     callsub message,(fi00003)    |   Unknown error.
     l    r15,pwa_save_r15        | Restore r15 for debug analysis
     errexit code=0               |   Return to caller.
   endif                          | EndIf.
   la   r4,0(r7,r4)               | R4 -> past DSNAME in file-spec.
   eject
*---------------------------------------------------------------------*
*  Validate the entire (possibly prefixed) data set name's syntax.
*---------------------------------------------------------------------*
   la   r6,pwa_dsname             | R6 -> start of DSNAME.
   la   r7,l'pwa_dsname(,r6)      | R7 -> past end of DSNAME.
   loop until                     | Loop over data set name.
     lr r3,r6                     |   R3 -> Current character.
     loop while,(cr,r3,lt,r7)     |   Scan ahead for '.'.
       leave loop=*,(cli,0(r3),eq,c' ')  leave if past end of dsname.
       leave loop=*,(cli,0(r3),eq,c'.')  leave if at the dot.
       la    r3,1(,r3)            |      Advance to next character.
     endloop while                |   EndLoop
     sr  r3,r6                    |   R3 := length of qualifier.
     st  r3,&w.length             |   Save for parm access.
*                                 |
     if (treg,r3,np)              |   If zero-length qualifier.
       callsub message,(fi00020)  |     Issue a message and quit.
       errexit code=0             |
     elseif (c,r3,gt,=f'8')       |   ElseIf qualifier longer than 8.
       callsub message,(fi00019,0(r6),&w.length)
       errexit code=0             |
     endif                        |   EndIf.
*                                 |
     bctr r3,0                    |   Subtract 1 for EX instruction.
     exi  r3,(trt,0(0,r6),lettrdig)   scan for invalid characters.
     if   nz,or,(cli,0(r6),ge,c'0')   if invalid characters found.
       callsub message,(fi00017,0(r6),&w.length)
       errexit code=0             |
     else                         |   Else.
       la    r6,1(r3,r6)          |     Advance to the dot.
       leave loop=*,(cr,r6,ge,r7) |     Leave if no dot.
       leave loop=*,(cli,0(r6),eq,c' ') leave if past end of dsname.
       la    r6,1(,r6)            |     Advance beyond the dot.
     endif                        |   EndIf.
   endloop until,leave            | EndLoop.
   eject
*---------------------------------------------------------------------*
*  If a member name was specified, parse it.
*---------------------------------------------------------------------*
   if (cr,r4,gt,r5)               | If nothing is left.
     mvc pwa_member,=cl8' '       |   Blank out the member name.
   else                           | Else rest of stuff is (member).
     if (cli,0(r5),eq,c')')       |   If closing parenthesis there.
       bctr  r5,0                 |     Backup by one char.
     endif                        |   EndIf.
     slr   r5,r4                  |   R5 := member name's length.
     la    r4,1(,r4)              |   Advance past open parenthesis.
     if    (treg,r5,np)           |   If zero-length member name.
       callsub message,(fi00014)  |     Issue a message and quit.
       errexit code=0             |
     elseif (c,r5,gt,=f'8')       |   ElseIf too long.
       callsub message,(fi00015,8)      issue a message and quit.
       errexit code=0             |
     else                         |   Else.
       la   r0,pwa_member         |     R0 -> destination of move.
       la   r1,l'pwa_member       |     R1 := destination length.
       icm  r5,8,=c' '            |     Pad move with blanks.
       mvcl r0,r4                 |     Move member name.
       tr   pwa_member,fold       |     Fold member-name to caps.
       trt  pwa_member,lettrdig   |     Scan for invalid characters.
       if  (nz,and,(cli,0(r1),ne,c' ')),or,(cli,pwa_member,ge,c'0')
         callsub message,(fi00016,pwa_member)
         errexit code=0           |
       endif                      |
     endif                        |   EndIf.
   endif                          | EndIf.
 endblk block=parse_filename
*---------------------------------------------------------------------*
* Working storage for parsing data set names and DDNAMES.
*---------------------------------------------------------------------*
           swa
&w.length  ds f
&w.prefix  ds cl9
           endswa
           eject
***********************************************************************
*                                                                     *
*  Subroutine: Allocate_File                                          *
*  Abstract:   Allocate the specified file.                           *
*                                                                     *
***********************************************************************
 block type=subroutine,name=allocate_file
* *-------------------------------------------------------------------*
* * If a DDNAME was specified, use dynamic allocation to obtain info
* * about the file.  If the DDNAME is already allocated, process the
* * returned information and then return.  If the DDNAME is not already
* * allocated, continue on t0 the next section of code.
* *
* * NOTE: Because the START function picks through caller-supplied text
* *       units for information, the DDNAME being used may have come
* *       from there instead of the FILE= operand.  If so, and if the
* *       DDNAME is already allocated, we will pick the pre-existing
* *       allocation with that DDNAME and the FILE=<dsname> operand
* *       will not get used.  If the DDNAME is not already allocated,
* *       we'll make a new allocation in the next section of code.
* *
* *-------------------------------------------------------------------*
  if (clc,pwa_ddname,ne,=cl8' ')        | If FILE=<ddname> then
    mvc &w.ddname,da_ir_ddname          | Copy DDNAME text unit.
    mvc &w.ret_dsorg,da_ir_ret_dsorg    | Set up return-DSORG  t.u.
    mvc &w.ret_dsname,da_ret_dsname     | Set up return-DSNAME t.u.
    mvc &w.ret_member,da_ret_member     | Set up return-MEMBER t.u.
    mvc &w.ret_status,da_ret_status     | Set up return-STATUS t.u.
    mvc &w.ret_attrs,da_ret_attrs       | Set up return-ATTRS    @DD
    mvc &w.ret_ndisp,da_ret_ndisp       | Set up return-DISP   t.u.
    mvc s99tupar-s99tunit+&w.ddname(8),pwa_ddname
    plist (&w.ddname,&w.ret_dsorg,&w.ret_dsname,&w.ret_member,         +
               &w.ret_attrs,&w.ret_status),vl,pl=pwa_textunits
    callsub dynalloc,                   | Invoke dynamic allocation    +
               (=al1(s99vrbin),         |     information retrieval.   +
               =al1(s99nomnt,0),        |     nomount,          @CNENQ +
               =al4(0),                 |     No authorized flags.     +
               pwa_err_msg,             |     Return message area.     +
               =a(l'pwa_err_msg),       |     Length of message area.  +
               pwa_err_msg_len,         |     Length of returned msg.  +
               pwa_textunits),vl        |     TextUnits.
    if (treg,r15,z)                     | If DDNAME allocated then.
      sbit  pwa_1,pwa_1_allocated       |   DDNAME is allocated.
      mvc   pwa_dsname,s99tupar-s99tunit+&w.ret_dsname
      mvc   pwa_member,s99tupar-s99tunit+&w.ret_member
      mvc   pwa_ndisp,s99tupar-s99tunit+&w.ret_ndisp
      mvc   pwa_status,s99tupar-s99tunit+&w.ret_status
      lm    r1,r3,=a(da_dsorg_table,2+4,da_dsorg_table_e)
      loop  bxle
        leave loop=*,(clc,0(2,r1),eq,s99tupar-s99tunit+&w.ret_dsorg)
      endloop bxle,r1,r2
      mvc   pwa_dsorg,2(r1)             |   Copy char DSORG to pwa.
      if    (tbit,s99tupar-s99tunit+&w.ret_attrs,x'80',on) Concat'd?
       sbit  pwa_2_concatenated         |   Note in PWA
       mvc   pwa_dsorg,=c'PS  '         |   Force it to sequential.
       fill  pwa_member,c' '            |   Destroy member name
      endif                             |
      if (clc,=c'****',eq,pwa_dsorg)    |   If DSORG = undefined.
        if  (cli,pwa_oo_mode,eq,&fi_oo_output)   If OUTPUT mode.
          mvc pwa_dsorg,=c'PS  '        |         Make it PS.
        endif                           |       EndIf.
      endif                             |   EndIf.
*
*     If the data set is sequential, but a member name was returned
*     that looks like a generation reference, then blank out the member
*     name and pretend we didn't see it.  A generation reference must
*     be an optional sign followed by digits, padded with blanks.
*     If this is the case, the data set name returned has the GxxxxVyy
*     qualifier on it anyways so there is no need for a member name.
*
      if (clc,=c'PS',eq,pwa_dsorg),and,(cli,pwa_member,ne,c' ')
        la r2,pwa_member                |     r2 -> Start of member.
        la r3,pwa_member+l'pwa_member   |     r3 -> Past end of fiel
        if (cli,0(r2),eq,c'+'),or,(cli,0(r2),eq,c'-')
          la r2,1(,r2)                  |       Advance past sign.
        endif                           |     EndIf.
        loop while,(cr,r2,lt,r3)        |     Loop over <digits>.
          leave loop=*,(cli,0(r2),lt,c'0'),or,(cli,0(r2),gt,c'9')
          la    r2,1(,r2)               |       Advance 1 char.
        endloop while                   |     EndLoop.
        loop while,((cr,r2,lt,r3),and,(cli,0(r2),eq,c' '))
          la    r2,1(,r2)               |       Advance 1 char.
        endloop while                   |     EndLoop.
        if (cr,r2,eq,r3)                |     If Ý+|-¨<digit><blank>
          mvc pwa_member,=cl8' '        |       Blank out member.
        endif                           |     EndIf.
      endif                             |   EndIf.
      leave block=*                     |   Return to caller.
    endif                               |   EndIf.
  endif                                 | EndIf.
* *-------------------------------------------------------------------*
* * Either no DDNAME was specified or the specified DDNAME was not
* * pre-allocated.  If a DSNAME was specified, attempt to allocate to
* * it and retrieve information.  Again, caller-supplied text units are
* * not used for allocation to a pre-existing data set.
* *-------------------------------------------------------------------*
  if (cli,pwa_dsname,ne,c' ')           | If dsname was specified.
    fill  pwa_textunits,x'00'           |   Clear text unit pointers.
    la    r7,pwa_textunits              |   r7 -> text unit pointers.
    using &s.dsntup,r7                  |
    mvc   &w.dsname,da_dsname           |   Copy DSNAME text unit.
    mvc   s99tupar-s99tunit+&w.dsname(44),pwa_dsname
    la    r14,&w.dsname                 |
    st    r14,&s.dsntup_dsname          |
    if    (cli,pwa_member,ne,c' ')      |   If MEMBER specified.
      mvc   &w.member,da_member         |     Copy MEMBER text unit.
      mvc   s99tupar-s99tunit+&w.member(8),pwa_member
      la    r14,&w.member               |
      st    r14,&s.dsntup_member        |
    endif                               |   EndIf.
    if    (cli,pwa_ddname,ne,c' ')      |   If DDNAME specified.
      mvc   &w.ddname,da_ddname         |     Copy DDNAME text unit.
      mvc   s99tupar-s99tunit+&w.ddname(8),pwa_ddname
      la    r14,&w.ddname               |
      st    r14,&s.dsntup_ddname        |
    else                                |   Else
      mvc   &w.ret_ddname,da_ret_ddname |     Set up return-DDNAME t.u.
      la    r14,&w.ret_ddname           |
      st    r14,&s.dsntup_ret_ddname    |
    endif                               |   EndIf.
    mvc   &w.ret_dsorg,da_ds_ret_dsorg  |   Set up return-DSORG t.u.
    la    r14,&w.ret_dsorg              |
    st    r14,&s.dsntup_ret_dsorg       |
    mvc   &w.stat_shr,da_stat_shr       |   Set up DISP=SHR
    la    r14,&w.stat_shr               |
    st    r14,&s.dsntup_statshr         |
    oi    &s.dsntup_final,x'80'         |   Set final text unit pointer
    callsub dynalloc,(=al1(s99vrbal),   |   Use DSNAME allocation.     +
               =al1(s99nomnt,0),        |    nomount,           @CNENQ +
               =al4(0),                 |    No authorized flags.      +
               pwa_err_msg,             |    Return message area.      +
               =a(l'pwa_err_msg),       |    Length of message area.   +
               pwa_err_msg_len,         |    Length of returned msg.   +
               pwa_textunits),vl        |
    if    (c,r15,lt,=f'&fi_error')      |   If allocation succeeded.
      sbit  pwa_1,pwa_1_allocated       |     Allocation has been done.
      sbit  pwa_2_free_on_terminate     |     Free on term if AUTOFREE.
      mvi   pwa_status,pwa_status_shr   |     Using SHR.
      mvi   pwa_ndisp,pwa_ndisp_keep    |     Defaulting to KEEP.
      if (%l32,r1,&s.dsntup_ret_ddname,nz)
        mvc pwa_ddname,s99tupar-s99tunit+&w.ret_ddname
      endif                               | Endif.
      lm    r1,r3,=a(da_dsorg_table,2+4,da_dsorg_table_e)
      loop  bxle
        leave loop=*,(clc,0(2,r1),eq,s99tupar-s99tunit+&w.ret_dsorg)
      endloop bxle,r1,r2
      mvc   pwa_dsorg,2(r1)             |     Copy char DSORG to pwa.
      if (clc,=c'****',eq,pwa_dsorg)    |     If DSORG = undefined.
        if  (cli,pwa_oo_mode,eq,&fi_oo_output) If OUTPUT mode.
          mvc pwa_dsorg,=c'PS  '        |         Make it PS.
        endif                           |       EndIf.
      endif                             |     EndIf.
      leave block=*                     |     Done with allocation.
    elseif (tbit,pwa_1_ds_not_existing,OFF) ElseIf not DS not found
      errexit code=0                    |     Return w/alloc error.
    elseif (cli,pwa_oc_disp,eq,&fi_oc_existing),or,                    +
               (cli,pwa_oo_mode,eq,&fi_oo_input)
      errexit code=0                    |     Return w/alloc error.
    endif                               |   EndIf.
  endif                                 | EndIf.
* *-------------------------------------------------------------------*
* * If this request is for INPUT or for an EXISTING data set, it has
* * failed.  If a DSNAME was specified, its already been taken care
* * of and we never got here (see code a few lines above).
* * The specified DDNAME (if any) is not allocated and the specified
* * DSNAME (if any) does not already exist.
* *-------------------------------------------------------------------*
  if (cli,pwa_oo_mode,eq,&fi_oo_input),or,                             +
               (cli,pwa_oc_disp,eq,&fi_oc_existing)
    if (cli,pwa_dsname,ne,c' ')         |   If dsname specified.
      errexit code=0                    |     Shouldn't get here.
    elseif (cli,pwa_ddname,ne,c' ')     |   ElseIf ddname specified.
      callsub message,(fi00026,pwa_ddname)    Issue an error message.
      errexit code=0                    |     Exit w/error code.
    else                                |   Else, ddname|dsname req'd
      callsub message,(fi00011)         |     Issue an error message.
      errexit code=0                    |     Exit w/error code.
    endif                               |   EndIf.
  endif                                 | EndIf.
* *-------------------------------------------------------------------*
* *                                                                   *
* * The specified file must be created.                               *
* *                                                                   *
* * NOTE: Caller-supplied text-units do get used here                 *
* *                                                                   *
* *-------------------------------------------------------------------*
  sbit    pwa_1_ds_not_existing         | dataset not pre-existing.
  mvi     pwa_status,pwa_status_new     | Creating a NEW dataset.
  callsub suggest_blocksize,            | Suggest a blocksize based    +
               (pwa_avglrecl,           | on the device we probably    +
               6,                       | will be allocated on.        +
               pwa_volser,              |                              +
               pwa_suggested_blksize)   |
  l       r1,pwa_maxlrecl               | r1 := lrecl value.
  if      (tbit,pwa_recfm,dcbrecf)      | If RECFM=F
   if     (c,r1,gt,pwa_suggested_blksize)  If lrecl > blksize
    st    r1,pwa_suggested_blksize      |   Bump blksize.
   endif                                |  EndIf.
  else                                  | Else, RECFM = V
   la     r1,4(,r1)                     |
   if     (c,r1,gt,pwa_suggested_blksize)  If lrecl+4 > blksize
    st    r1,pwa_suggested_blksize      |   Bump blksize.
   endif                                |  EndIf.
  endif                                 | EndIf.
* *-------------------------------------------------------------------*
* * Create the internally supplied text units for this allocation.
* *-------------------------------------------------------------------*
  fill  pwa_textunits,x'00'          | Clear garbage out of tup list.
  la    r7,pwa_textunits             | r7 -> textunit pointer array.
  using &s.newtup,r7                 | Overlay with new ds pointers.
  mvc   &w.dsorg,da_dsorg            | Copy default DSORG=PS textunit.
  mvc   pwa_dsorg,=c"PS   "          | Indicate PS in pwa.
  la    r14,&w.dsorg                 | Add dsorg
  st    r14,&s.newtup_dsorg          |
* *
* * If a DDNAME was specified, use it.  Otherwise, let the system
* * generate one and return it in &w.ret_ddname.
* *
  if (cli,pwa_ddname,ne,c' ')        | If ddname specified.
    mvc   &w.ddname,da_ddname        |   Copy DDNAME text unit.
    mvc   s99tupar-s99tunit+&w.ddname(8),pwa_ddname
    la    r14,&w.ddname              |
    st    r14,&s.newtup_ddname       |
  else                               | Else.
    mvc   &w.ret_ddname,da_ret_ddname    Set up return-DDNAME t.u.
    la    r14,&w.ret_ddname          |   Add ret_ddname
    st    r14,&s.newtup_ret_ddname   |
  endif                              | EndIf.
* *
* * If a dataset name was supplied, allocate a new data set with that
* * name.  Include the member name text unit as well if a member name
* * was specified.  If no data set name was provided, let the system
* * generate one and return it in &w.ret_dsname.
* *
  if (cli,pwa_dsname,ne,c' ')        | If dsname specified.
    mvc   &w.dsname,da_dsname        |   Copy DSNAME text unit.
    mvc   s99tupar-s99tunit+&w.dsname(44),pwa_dsname
    la    r14,&w.dsname              |   Add dsn=dsname
    st    r14,&s.newtup_dsname       |
    if (cli,pwa_member,ne,c' ')      |   If member specified.
      mvc   &w.dsorg+6(2),da_PO      |     Set DSORG textunit to PO.
      mvc   pwa_dsorg,=c"PO   "      |     Indicate PO in pwa.
      mvc   &w.member,da_member      |     Copy MEMBER text unit.
      mvc   s99tupar-s99tunit+&w.member(8),pwa_member
      la    r14,&w.member            |     Add member
      st    r14,&s.newtup_member     |
      mvc   &w.dirblks,da_dirblks    |
      la    r14,&w.dirblks           |     Add dirblks
      st    r14,&s.newtup_dirblks    |
    endif                            |   EndIf.
  else                               | Else: filetemp | sysout | etc.
    mvc   &w.ret_dsname,da_ret_dsname_al  Set up return-DSNAME t.u.
    la    r14,&w.ret_dsname          |    Add ret_dsname
    st    r14,&s.newtup_ret_dsname   |
  endif                              | EndIf.
* *
* * If this is a SYSOUT file, specify sysout and do not any text units
* * that would normally be used to allocate space on disk.  For all
* * other files, provide those things instead.
* *
  if (cli,pwa_oc2_sysoutx,eq,&fi_oc2_sysout),or,                       +
               (cli,pwa_sysoutclass,ne,c' ')
    mvc   &w.sysout,da_sysout        |   Set up SYSOUT textunit.
    la    r14,&w.sysout              |   Add sysout
    st    r14,&s.newtup_sysout       |
  else                               | Else
    callsub suggest_blockcounts,        |                              +
               (pwa_suggested_blksize,  |                              +
               pwa_avglrecl,            |                              +
               pwa_sizeinit,            |                              +
               pwa_sizeincr,            |                              +
               pwa_primary_blocks,      |                              +
               pwa_secondary_blocks)    |
    mvc   &w.statnew,da_statnew      |
    la    r14,&w.statnew             |   Add disp=new
    st    r14,&s.newtup_statnew      |
    mvc   &w.conddisp,da_conddisp    |
    la    r14,&w.conddisp            |   Add conditional disposition
    st    r14,&s.newtup_conddisp     |
    mvc   &w.blkalloc,da_blkalloc    |
    mvc   s99tupar-s99tunit+&w.blkalloc(3),pwa_suggested_blksize+1
    la    r14,&w.blkalloc            | Add blkalloc
    st    r14,&s.newtup_blkalloc     |
    mvc   &w.prispace,da_prispace
    mvc   s99tupar-s99tunit+&w.prispace(3),pwa_primary_blocks+1
    la    r14,&w.prispace            |   Add primary space allocation
    st    r14,&s.newtup_prispace     |
    mvc   &w.secspace,da_secspace
    mvc   s99tupar-s99tunit+&w.secspace(3),pwa_secondary_blocks+1
    la    r14,&w.secspace            |   Add secondary space allocation
    st    r14,&s.newtup_secspace     |
    mvc   &w.unit,da_unit            |
    la    r14,&w.unit                |   Add unit=SYSALLDA or WKUNIT
    st    r14,&s.newtup_unit         |
  endif                              | EndIf.
* *
* * Determine the normal disposition of the data set: if a dsname was
* * provided that does not start with an ampersand ('&') and FILETEMP
* * was not specified, use DISP=CATLG.  Otherwise, consider it a
* * temporary work data set and use DISP=DELETE.  SYSOUT files cannot
* * specify a disposition (mutually exclusive text-units).
* *
  if (clc,&s.newtup_sysout,eq,=f'0') | If NOT a SYSOUT file.
    if (cli,pwa_dsname,ne,c' '),     |   If DSNAME specified and is not+
               and,(cli,pwa_dsname,ne,c'&&'),        temporary, and if +
               and,(cli,pwa_oc_filetempx,ne,&fi_oc_filetemp)  ¬FILETEMP
      mvc &w.normdisp,da_normdisp    |     Set normal disp=catlg.
      mvi pwa_ndisp,pwa_ndisp_catlg  |     Allocating with CATLG.
    else                             |   Else
      mvc &w.normdisp,da_normdispdel |     Set normal disp=delete.
      mvi pwa_ndisp,pwa_ndisp_delete |     Allocating with DELETE.
    endif                            |   EndIf.
    la  r14,&w.normdisp              |     Add normal disposition
    st  r14,&s.newtup_normdisp       |      text unit.
  endif                              | EndIf.
* *
* * Fill in remaining text units used for all new allocations.
* *
  mvc   &w.blksize,da_blksize
  mvc   s99tupar-s99tunit+&w.blksize(2),pwa_suggested_blksize+2
  la    r14,&w.blksize               | Add blksize
  st    r14,&s.newtup_blksize        |
  mvc   &w.lrecl,da_lrecl            | Copy LRECL textunit.
  if    (tbit,pwa_1_vb),or,          | If we want VB in created        +
               (clc,pwa_avglrecl,ne,pwa_maxlrecl)    dataset.
    mvc s99tupar-s99tunit+&w.lrecl(2),pwa_maxlrecl+2   Desired LRECL.
    mvc &w.recfm,da_recfm_vb         |                 Set RECFM = VB.
    if (cli,pwa_oc2_cc,eq,&fi_oc2_isocc) If ISOCC requested:
      mvc  &w.recfm,da_recfm_vba     |    Set RECFM=VBA.
    endif                            |   Endif.
  else                               | Else (we want FB).
    mvc s99tupar-s99tunit+&w.lrecl(2),pwa_avglrecl+2   Desired LRECL.
    mvc &w.recfm,da_recfm_fb         |                 Set RECFM = FB.
    if (cli,pwa_oc2_cc,eq,&fi_oc2_isocc)   If ISOCC requested:
      mvc  &w.recfm,da_recfm_fba     |     Set RECFM=FBA.
    endif                            |   Endif.
  endif                              | EndIf.
  la    r14,&w.lrecl                 | Add lrecl
  st    r14,&s.newtup_lrecl          |
  la    r14,&w.recfm                 | Add recfm
  st    r14,&s.newtup_recfm          |
* *-------------------------------------------------------------------*
* * Append the caller's list (if any) of text unit pointers to ours.
* * Any duplicates of text units we supply can replace ours.
* *-------------------------------------------------------------------*
  la r6,&s.newtup_final              | r6 -> last internal text unit.
  la r5,&s.newtup_final              | r5 -> current final tu pointer.
  l  r2,fi_info                      | r2 -> INFO parameter.
  la r2,0(,r2)                       | Clear high-order bit.
  if (treg,r2,nz)                    | If INFO was specified.
    loop until                       |   Loop thru INFO parmlist
      l  r3,0(r2)                    |     Get a parm address
      la r3,0(r3)                    |     Clear its VL bit
      if (treg,r3,nz)                |     If non-null pointer then.
        la r15,&s.newtup             |       r15 -> 1st text unit ptr.
        loop while,(cr,r15,le,r6)    |       loop over internal tup's.
          l  r1,0(,r15)              |         r1 -> text unit.
          la r1,0(,r1)               |         Clear high-bit.
          if (treg,r1,nz)            |         If TUP not null.
            if (clc,0(2,r1),eq,0(r3))            If same text unit keys
              st    r3,0(r15)        |             Use theirs instead.
              slr   r3,r3            |             Done with this one.
              leave loop=*           |             Quit looking.
            endif                    |           EndIf.
          endif                      |         EndIf.
          la  r15,4(,r15)            |         r15 -> Next TU pointer.
        endloop while                |       EndLoop.
      endif                          |     EndIf.
      if (treg,r3,nz)                |     If still non-null then.
        if (c,r5,gt,pwa_textunits_end)       If textunit list full
          callsub message,(fi00035,50)         Max # exceeded.
          errexit code=0             |         Return w/error.
        endif                        |       EndIf.
        st r3,4(,r5)                 |         Stuff in DYNALLOC parms
        la r5,4(,r5)                 |         Update to last TU ptr.
      endif                          |       EndIf.
      leave loop=*,(tbit,0(r2),x'80')      Leave if that was the end.
      la    r2,4(,r2)                |     Update INFO list pointer.
    endloop until,leave              |   EndLoop.
  endif                              | EndIf.
  sbit    0(r5),x'80'                | Mark final textunit pointer.
* *-------------------------------------------------------------------*
* * Invoke dynamic allocation to create the output data set.
* *-------------------------------------------------------------------*
   l    r3,&s.newtup_unit            | Set addr of UNITNAME
   st   r3,pwa_unitname_textunit     |  textunit (for error msg. later)
   callsub dynalloc,(=al1(s99vrbal), | Use dsname allocation.          +
               =al1(s99nomnt,0),     | nomount,                 @CNENQ +
               =al4(0),              | no authorized flags.           2+
               pwa_err_msg,          | Return message area.           3+
               =a(l'pwa_err_msg),    | Length of message area.        4+
               pwa_err_msg_len,      | Length of returned msg.        5+
               pwa_textunits),vl     | Text unit pointer list.        6
   if (c,r15,ge,=f'&fi_error')       | If allocation failed.
     errexit code=0                  |   Exit w/error message.
   endif                             | EndIf.
   sbit  pwa_1,pwa_1_allocated       | Allocation has been done.
   sbit  pwa_2_free_on_terminate     | Free on terminate if AUTOFREE.
* *-------------------------------------------------------------------*
* * Retrieve information from ret_ text units that were specified.
* *-------------------------------------------------------------------*
   if (%l32,r1,&s.newtup_ret_ddname,nz)
     mvc pwa_ddname,s99tupar-s99tunit+&w.ret_ddname
   endif                               | Endif.
   if (%l32,r1,&s.newtup_ret_dsname,nz)
     mvc  pwa_dsname,s99tupar-s99tunit+&w.ret_dsname
   endif                               | Endif.
 endblk block=Allocate_File
                 swa
&w.blkalloc      ds  cl(l'da_blkalloc)     |
&w.blksize       ds  cl(l'da_blksize)      |
&w.conddisp      ds  cl(l'da_conddisp)     |
&w.ddname        ds  cl(l'da_ddname)       |
&w.dirblks       ds  cl(l'da_dirblks)      |
&w.statnew       ds  cl(l'da_statnew)      |
&w.dsname        ds  cl(l'da_dsname)       |
&w.dsorg         ds  cl(l'da_dsorg)        |
&w.lrecl         ds  cl(l'da_lrecl)        |
&w.member        ds  cl(l'da_member)       |
&w.normdisp      ds  cl(l'da_normdisp)     |
&w.normdispdel   ds  cl(l'da_normdispdel)  |
&w.prispace      ds  cl(l'da_prispace)     |
&w.recfm         ds  cl(l'da_recfm_fb)     |
&w.ret_attrs     ds  cl(l'da_ret_attrs)    |
&w.ret_ddname    ds  cl(l'da_ret_ddname)   |
&w.ret_dsname    ds  cl(l'da_ret_dsname)   |
&w.ret_dsorg     ds  cl(l'da_ds_ret_dsorg) |
&w.ret_member    ds  cl(l'da_ret_member)   |
&w.ret_ndisp     ds  cl(l'da_ret_ndisp)    |
&w.ret_status    ds  cl(l'da_ret_status)   |
&w.secspace      ds  cl(l'da_secspace)     |
&w.stat_shr      ds  cl(l'da_stat_shr)     |
&w.sysout        ds  cl(l'da_sysout)       |
&w.unit          ds  cl(l'da_unit)         |
                 endswa                    |
&s.dsntup             dsect   Text unit ptrs (plist) for existing alloc
&s.dsntup_dsname      ds a          |  dsname.
&s.dsntup_member      ds a          |  member name.
&s.dsntup_ddname      ds a          |  ddname.
&s.dsntup_statshr     ds a          |  status = new.
&s.dsntup_ret_ddname  ds a          |  return ddname.
&s.dsntup_ret_dsorg   ds a          |  return dsorg.
&s.dsntup_final       equ *-4       | Final pointer (internal)
*
&s.newtup             dsect   Text unit ptrs (plist) for new ds alloc
&s.newtup_ddname      ds a          |  ddname.
&s.newtup_dsname      ds a          |  dsname.
&s.newtup_member      ds a          |  member name.
&s.newtup_sysout      ds a          |  sysout specification.
&s.newtup_dirblks     ds a          |  directory blocks
&s.newtup_ret_dsname  ds a          |  return dsname
&s.newtup_ret_ddname  ds a          |  return ddname
&s.newtup_statnew     ds a          |  status = new.
&s.newtup_normdisp    ds a          |  normal disp=<catlg|delete>
&s.newtup_conddisp    ds a          |  cond disp=delete
&s.newtup_blkalloc    ds a          |  SPACE=(blksize,
&s.newtup_prispace    ds a          |          (primary,
&s.newtup_secspace    ds a          |          secondary))
&s.newtup_dsorg       ds a          |  DSORG = PS or PO.
&s.newtup_unit        ds a          |  UNIT = SYSDA(*default*)
&s.newtup_lrecl       ds a          |  LRECL = <calculated>.
&s.newtup_blksize     ds a          |  BLKSIZE = <calculated>.
&s.newtup_recfm       ds a          |  RECFM = FB or VB.
&s.newtup_final       equ *-4       | Final pointer (internal)
srvfios             csect ,

              eject
***********************************************************************
*                                                                     *
*  Subroutine: DYNALLOC                                               *
*                                                                     *
*  Abstract:   This routine builds a dynamic allocation request       *
*              block, invokes DYNALLOC, and constructs a message      *
*              describing the results of the operation.               *
*                                                                     *
*  Parameters: (Verb,Flag1,Flag2,MsgArea,AreaLen,MsgLen,TextUnit1,... *
*                                                                     *
*              The parameter list passed to this routine *must* be    *
*              terminated with a 1 in the high-order bit of the last  *
*              parameter, and must contain at least one textunit.     *
*                                                                     *
*              Parameter  Description                                 *
*              ---------  ------------------------------------------- *
*              Verb       Value to use for S99VERB.                   *
*              Flag1      Value to use for S99FLAG1.                  *
*              Flag2      Value to use for S99FLAG2.                  *
*              MsgArea    Area in which to build Info/Error message.  *
*              AreaLen    Length of MsgArea.                          *
*              MsgLen     Length of resulting message.                *
*              TextUnits  List of text-unit pointers, with final      *
*                         pointer denoted by 1 in hoigh order bit.    *
*                                                                     *
*  Return Codes: R15 = return code implied by the message issued.     *
*                                                                     *
***********************************************************************
 block type=subroutine,name=dynalloc
*---------------------------------------------------------------------*
*  Build the DYNALLOC request block and invoke dynamic allocation.
*---------------------------------------------------------------------*
   lr      r8,r1                  | R8 -> Parameter list passed in.
   fill    &w.rb,x'00'            | Clear request block to zeros.
   la      r7,&w.rb               | R7 -> Dynamic allocation RB.
   using   s99rb,r7               | Establish addressability.
   mvi     s99rbln,20             | Set request block's length.
   lm      r1,r3,0(r8)            | R1,2,3 -> Verb,Flag1,Flag2.
   mvc     s99verb,0(r1)          | Copy allocation VERB.
   mvc     s99flag1,0(r2)         | Copy allocation FLAGS1 field.
   mvc     s99flag2,0(r3)         | Copy allocation FLAGS2 field.
   l       r1,6*4(,r8)            | R1 -> Text Unit pointers.
   la      r1,0(,r1)              | Clear high-order bit.
   st      r1,s99txtpp            | Set text unit pointers address.
*                                 |
   plist    (s99rb),vl            | R1 -> RB pointer -> Request block.
   dynalloc ,                     | Invoke dynamic allocation.
   leave    block=*,(treg,r15,z)  | Return if successful.
   eject
*---------------------------------------------------------------------*
*  Analyze DYNALLOC's error and reason codes to form a message.
*---------------------------------------------------------------------*
   if (c,r15,eq,=f'8')            | If denied by installation exit.
     callsub message,(fi00109)    |   Allocation denied.
     leave   block=*              |   Return to caller.
   endif                          | EndIf.
*                                 |
   l16 r1,s99error                | Set R1 to the error code.
   n   r1,=x'00000f00'            | Isolate error code's class.
   l16 r0,s99error                | Put error code in register.
*                                 |
   if  (ch,r0,eq,=x'0204')        | If not enough storage.
     callsub message,(fi00009)    |   Issue an error message.
   elseif (ch,r0,eq,=x'0210')     | ElseIf allocated to another user.
     callsub message,(fi00110,pwa_dsname)
   elseif (ch,r0,eq,=x'0218')     | ElseIf no acceptable volumes
     callsub message,(fi00122)    |
   elseif (ch,r0,eq,=x'021c')     | ElseIf invalid unitname
     fill  pwa_unitname,c' '          | Clear working unitname
     l     r14,pwa_unitname_textunit  | Get textunit address
     lh    r15,4(,r14)                | Get unitname length
     bctr  r15,0                      | Fix length for EXECUTE
     exi   r15,(mvc,pwa_unitname(0),6(r14))   VL move for unitname
     callsub message,(fi00123,pwa_unitname)   Issue error message.
   elseif (ch,r0,eq,=x'0220')     | ElseIf volume not available
     callsub message,(fi00124,pwa_volser)
   elseif (ch,r0,eq,=x'035C')     | ElseIf invalid PARM value.
     l16 r2,s99info               |   R2 := key of bad text unit.
     if (ch,r2,eq,=al2(daldsnam)) |   If bad data set name.
       callsub message,(fi00002,pwa_dsname)
     else                         |   Else.
       callsub message,(fi00113,s99error,s99info)
     endif                        |   EndIf.
   elseif (ch,r0,eq,=x'043C')     | ElseIf too-many-datasets.
     callsub message,(fi00121)    |   Issue an error message.
   elseif (ch,r0,eq,=x'0238')     | ElseIf TIOT is full.
     callsub message,(fi00121)    |   Issue an error message.
   elseif (ch,r0,eq,=x'47AC')     | ElseIf RACF failure on DEFINE.
     callsub message,(fi00120,pwa_userid,"CREATE",6,pwa_dsname)
   elseif (ch,r1,eq,=x'0700')     | ElseIf a class 7 error code.
     if (cli,s99error,eq,x'17')   |   If a LOCATE error.
       if (cli,s99error+1,eq,x'08')     if could not find file.
         callsub message,(fi00111,pwa_dsname)
         sbit  pwa_1,pwa_1_ds_not_existing
       else                       |     Else.
         callsub message,(fi00113,s99error,s99info) dynalloc error.
       endif                      |     EndIf.
     elseif (cli,s99error,eq,x'47')   elseif a dasdm allocate error.
         callsub message,(fi00113,s99error,s99info) dynalloc error.
     elseif (cli,s99error,eq,x'57')   elseif a catalog error.
       callsub message,(fi00113,s99error,s99info) dynalloc error.
     elseif (cli,s99error,eq,x'67')   elseif an obtain error.
       callsub message,(fi00113,s99error,s99info) dynalloc error.
     elseif (cli,s99error,eq,x'77')   elseif a subsystem error.
       callsub message,(fi00113,s99error,s99info) dynalloc error.
     elseif (cli,s99error,eq,x'87')   elseif a scheduler jcl error.
       callsub message,(fi00113,s99error,s99info) dynalloc error.
     else                         |   Else.
       callsub message,(fi00113,s99error,s99info) unknown error.
     endif                        |   EndIf.
   else                           | Else.
     callsub message,(fi00112,pwa_dsname,s99error,s99info)
   endif                          | EndIf.
*
*  The last operation before this point was a call to MESSAGE, so R15
*  has been set to the return-code we want.
*
 endblk block=dynalloc
*---------------------------------------------------------------------*
* Working storage for invoking DYNALLOC.
*---------------------------------------------------------------------*
                swa
&w.rb           ds   cl(s99rbend-s99rb)   | DYNALLOC request block.
                endswa
 aif (not &security_check).skip4
          eject
***********************************************************************
*                                                                     *
*  Subroutine: Security_Check,(ACCESS)                                *
*  Abstract  : Attempt to see if the current user/group has access to *
*              the file about to be opened.  This check is done to    *
*              avoid abend 913s.  If the check cannot be done, just   *
*              continue on and hope for the best.                     *
*                                                                     *
***********************************************************************
 block type=subroutine,name=security_check,parms=(Access),             +
               options=(*swa,(parms,prefix,(using,r8)))
*---------------------------------------------------------------------*
*  Use RACROUTE to determine if the current userid has access to the
*  data set about to be opened.  If not, issue a message and don't
*  open it.
*---------------------------------------------------------------------*
   l  r5,&spl.Access                     | R5 -> C"Access type".
   la r5,0(,r5)                          | Clear high-order bit.
   if (clc,=c"READ",eq,0(r5))            | If checking READ access.
     la    r4,=f'4'                      |   r4 -> length of READ.
     la    r2,x'02'                      |   r2 := X'02' for READ.
   elseif (clc,=c"ALTER",eq,0(r5))       | ElseIf ALTER access.
     la    r4,=f'5'                      |   r4 -> length of ALTER.
     la    r2,x'80'                      |   r2 := X'04' for ALTER.
   elseif (clc,=c"UPDATE",eq,0(r5))      | ElseIf UPDATE access.
     la    r4,=f'6'                      |   r4 -> length of UPDATE.
     la    r2,x'04'                      |   r2 := X'04' for UPDATE.
   elseif (clc,=c"CONTROL",eq,0(r5))     | ElseIf CONTROL access.
     la    r4,=f'7'                      |   r4 -> length of CONTROL.
     la    r2,x'08'                      |   r2 := X'04' for CONTROL.
   else                                  | Else....just use READ....
     la    r5,=c"READ"                   |   r5 -> "READ".
     la    r4,=f'4'                      |   r4 -> length of READ.
     la    r2,x'02'                      |   r2 := X'02' for READ.
   endif                                 | EndIf.
*                                        |
   mvc &w.racroute,&s.racroute           | Copy RACROUTE parm list.
   racroute    entity=(pwa_dsname),      |                             +
               volser=pwa_volser,        | Check access authority to   +
               attr=(r2),                | the data set about to be    +
               request=AUTH,             | opened for input or output. +
               worka=&w.rac_workarea,    |                             +
               mf=(e,&w.racroute)        |
   leave       block=*,(treg,r15,z)      | Return if access is okay.
   leave       block=*,(c,r15,eq,=f'4')  | Return if not denied.
   stm         r15,r0,&w.codes           | Save return/reason codes.
   if          (c,r15,eq,=f'8')          | If access was denied.
     callsub message,(fi00120,pwa_userid,(r5),(r4),pwa_dsname)
     errexit code=0                      |
   else                                  | Else, unexpected returncode.
     callsub message,(fi00036,pwa_dsname,&w.codes,&w.codes+4)
     errexit code=0                      |
   endif                                 | EndIf.
 endblk block=security_check
*---------------------------------------------------------------------*
* Local constants and variables for checking dataset authorization.
*---------------------------------------------------------------------*
                ssd
&s.racroute     racroute mf=l,request=AUTH,class="DATASET",dstype=N
&s.racroute_l   equ      *-&s.racroute
                endssd
                swa
&w.codes        ds      2f
&w.rac_workarea ds      cl512
&w.racroute     ds      cl(&s.racroute_l)
                endswa
.skip4 anop
 eject                                |
***********************************************************************
*                                                                     *
*  Subroutine: Read_JFCB                                              *
*  Abstract:   Read a copy of the dataset's JFCB into the PWA.        *
*  NOTICE:     THIS ROUTINE SHOULD NOT DO ANYTHING ELSE.              *
*                                                                     *
***********************************************************************
 block type=subroutine,name=read_jfcb,amode=31
   la    r8,pwa_dcb                   | r8 -> working DCB storage.
   using ihadcb,r8                    | Establish addressability.
*                                     |
   if    (clc,=c'PO',eq,pwa_dsorg)    | If looking at a PDS.
     mvc pwa_dcb(&psd.podcb_len),&psd.podcb Copy static po DCB to swa
   else                               | Else, it must be sequential.
     mvc pwa_dcb(&psd.psdcb_len),&psd.psdcb Copy static ps DCB to swa
   endif                              | EndIf.
*                                     |
   mvc   dcbddnam(8),pwa_ddname       | Stuff w/DDname
   la    r1,pwa_jfcb                  | Set up for RDJFCB:
   st    r1,pwa_exlst                 | Build exitlist of 1 entry,
   mvi   pwa_exlst,x'87'              | (type 07 w/ VL bit)
   la    r1,pwa_exlst                 |  and set exlst address in DCB.
   stcm  r1,b'0111',dcbexlsa          |
   mvc   &w.rdjfcb,&s.rdjfcb          | Copy RDJFCB parms to SWA
   block amode=24                     |
    rdjfcb pwa_dcb,mf=(e,&w.rdjfcb)   | Copy JFCB to our storage
    lr     r5,r15                     |
   endblk                             |
   if    (treg,r5,nz)                 | If it didn't work,
    callsub message,                  |  OPEN wouldn't work either.    +
               (fi00102,pwa_dsname)   |  Issue error message.
    errexit code=0                    |
   endif                              |
   la    r7,pwa_jfcb                  | Base on JFCB
   using infmjfcb,r7                  |
   sbit  jfcbtsdm,jfcnwrit            | Don't write JFCB back to SWA
 endblk block=read_jfcb
               ssd    ,                   |
&s.rdjfcb      rdjfcb *,mf=l              |
&s.rdjfcb_l    equ    *-&s.rdjfcb         |
               endssd ,                   |
               swa    ,                   |
&w.rdjfcb      ds     cl(&s.rdjfcb_l)     |
               endswa ,                   |
 eject
***********************************************************************
*                                                                     *
*  Subroutine: Does_Member_Exist                                      *
*  Abstract:   Determine using BPAM FIND whether a member exists.     *
*              On exit, R15 = zero if member found, else R15 = 8.     *
*              The dataset's JFCB must already be read in with PO.    *
*  NOTICE:     THIS ROUTINE SHOULD NOT DO ANYTHING ELSE.              *
*                                                                     *
***********************************************************************
 block name=does_member_exist,type=subroutine,amode=31,options=codebase
   la    r8,pwa_dcb                   | r8 -> PO dcb connected to JFCB.
   using ihadcb,r8                    | Establish addressability.
   la    r7,pwa_jfcb                  | r7 -> JFCB already read in.
   using infmjfcb,r7                  | Establish addressability.
   mvc   jfcbelnm,=cl8' '             | Clear the member name.
   mvc   pwa_open(open_l),&psd.open   | Copy OPEN parm list to PWA.
   block amode=24                     | Block Amode-24.
     open  (pwa_dcb,input),type=j,mf=(e,pwa_open)
   endblk                             | EndBlk Amode-24.
   if (tbit,dcboflgs,dcbofopn,off)    | If OPEN failed.
     callsub message,(fi00102,pwa_dsname) Issue an error message.
     errexit code=0                   |    Exit with error-code.
   endif                              | Endif.
   block amode=24                     |
     find  pwa_dcb,pwa_member,d       | Make BPAM find member
     lr    r2,r15                     | Copy returncode before CLOSE
     if    (treg,r2,nz)               | If it wasn't zero
       la    r2,8                     |  force it to be 8.
     endif                            |
     plist (pwa_dcb),vl               | Set parms in working stg.
     close (pwa_dcb),mf=(e,(1))       | Close PO DCB
     callsub free_buffer_pool,(pwa_dcb)   Free its buffer pool
   endblk                             |
 endblk rc=(r2)                       | Return the answer.
         eject                        |
*---------------------------------------------------------------------*
*
*  Subroutine: Suggest_Blocksize
*  Abstract:   This routine will attempt to derive a blocksize that
*              will efficiently fit <n> blocks on a track, using the
*              average record length provided by the caller.
*  Inputs:     On entry, R1 points to the following parameter list:
*                +0 -- Address of average record length (fullword)
*                +4 -- Requested number of blocks per track (fullword)
*                +8 -- Address of volume for target device or spaces
*                +c -- Address of fullword to return blocksize into
*  Outputs:    Result fullword at parmlist+c% filled in
*  Special
*  Notes:      . This routine uses DEVTYPE, and hopefully uses the
*                right method for determining an optimum blocksize.
*              . This routine presently uses #_blks_per_track (an
*                equate) for carving up a DASD track.
*---------------------------------------------------------------------*
         space 1                      |
 block name=suggest_blocksize,type=subroutine
  lm    r3,r6,0(r1)                   | Load up parameters
  mvi   &w.f1,x'00'                   |
  la    r7,&w.devtype_results         | Base on DEVTYPE answer area
  l     r2,cvtptr                     |  Base on CVT
  using cvt,r2                        |
  using dvarea,r7                     |
  if    (clc,=cl6' ',eq,0(r5))        | If no volume provided,
   mvc   dvatrkln,=al2(47476)         |  Assume 3380 tracklength,
   mvc   &w.ucbad,cvtsysad            |   devicetype of what we IPLed
  else                                | Otherwise look up volume's UCB:
   loop  until                        |  Loop calling IOSVSUCB:
    l     r15,cvtucbsc                |
    callx (r15),(&w.ucbwa,=al1(ucb3dacc),&w.ucbad)
    leave loop=*,(treg,r15,nz)        |   Leave if no more UCBs
    l     r3,&w.ucbad                 |   Get returned UCB address
    using ucbob,r3                    |
    if    (clc,ucbvoli,eq,0(r5))      |   If we found our volume
     st    r3,&w.ucbad                |    Save UCB address for TRKCALC
     sbit  &w.f1,&w.f1hit             |     and note that we found it.
     leave loop=*                     |
    endif                             |
   endloop until,leave                |
   drop  r2,r3                        | Drop CVT, UCB bases
   if    (tbit,&w.f1,&w.f1hit,off)    | If we didn't find the volume
    callsub message,(fi00030,&w.volser)  it isn't mounted.
    errexit code=0                    |
   endif                              |
   mvc   &w.devtype(len_devtype),&s.devtype  now we can issue devtype.
   devtype  ,(&w.devtype_results,24),  |                               +
               ucblist=(&w.ucbad,1),  |                                +
               mf=(e,&w.devtype)      |
   if    (treg,r15,nz)                |
    st   r15,pwa_save_r15             | Preserve r15 for errexit
    callsub message,(fi00028)         |  don't try division with it.
    l    r15,pwa_save_r15             | Rest r15 for debug analysis
    errexit code=0                    |
   endif                              |
  endif                               |
* *-------------------------------------------------------------------*
* * DEVTYPE returned the track size. We know the average recordlength.
* * Determine how large a block must be to fit 4 on a track.  Since
* * together DEVTYPE and TRKCALC aren't too smart, we have to loop
* * asking TRKCALC 'how about this one' til we get the answer we want.
* *-------------------------------------------------------------------*
  l16   r1,dvatrkln                   | Watch it: this is unsigned!
  l32   r0,0(r4)                      | Check # blocks per track:
  if    (z)                           | If it's zero,
   callsub message,(fi00028)          |  don't try division with it.
   errexit code=0                     |
  endif                               |
  l32   r0,0(r3)                      | Check average LRECL:
  if    (z)                           | If it's zero,
   callsub message,(fi00029)          |  don't try division with it.
   errexit code=0                     |
  endif                               |
  xr    r0,r0                         | Clear R0 before division
  d     r0,0(r4)                      | Divide by # blocks per track:
*                                     |  R1 now = 1/4 track length.
  xr    r0,r0                         | Clear R0 before division
  d     r0,0(r3)                      | Divide by average LRECL:
*                                     |  R1 now = # recs per block.
  m     r0,0(r3)                      | R1 is now trimmed blocksize.
  lr    r2,r1                         | Copy to R2 to save past TRKCALC
  mvc   &w.trkcalc(len_trkcalc),&s.trkcalc
  l     r14,&w.ucbad                  |   Get returned UCB address
  using ucbob,r14                     |
  mvc   pwa_UCBTBYT4,UCBTBYT4         |  Copy device type to PWA field.
  drop  r14                           |  Drop UCB addressing.
  loop  until                         |
   trkcalc     functn=trkcap,         |  Will this one fit like we     +
               type=pwa_UCBTBYT4,     |   want?                        +
               dd=(r2),               |                                +
               r=1,                   |                                +
               regsave=yes,           |                                +
               mf=(e,&w.trkcalc)      |
   if    (treg,r15,nz)                |
    st   r15,pwa_save_r15             | Preserve r15 for errexit
    callsub message,(fi00028)         |
    l    r15,pwa_save_r15             | Restore r15 for debug analysis
    errexit code=0                    |
   endif                              |
   leave loop=*,(c,r0,ge,0(r4))       |  If hit, leave loop.
   s     r2,0(r3)                     |  Knock some off the LRECL
  endloop until,leave                 | and try again.
  st    r2,0(r6)                      | Only a suggestion.
  drop  r7                            |
  xr    r15,r15                       |
 endblk rc=(r15)                      |
         space 1                      |
  ssd   ,                             |
&s.devtype devtype ,(*,*),ucblist=yes,mf=l
len_devtype equ     *-&s.devtype      |
&s.trkcalc trkcalc mf=l               |
len_trkcalc equ     *-&s.trkcalc      |
  endssd ,                            |
         space 1                      |
  swa   ,                             |
&w.devtype ds    0f,cl(len_devtype)   |
&w.trkcalc ds    0f,cl(len_trkcalc)   |
&w.devtype_results ds    6f           |
&w.ucbad   ds    a                    |
&w.ucbwa   ds    cl100                |
&w.volser  ds    cl6                  |
&w.f1      ds    x                    |
&w.f1hit   equ   x'80'                |
  endswa ,                            |
         eject                        |
*---------------------------------------------------------------------*
*
*  Subroutine: suggest_blockcounts (blksize,avglrecl,recsinit,recsincr,
*                              priblks,secblks)
*              will efficiently fit <n> blocks on a track, using the
*  Abstract:   Compute primary and secondary block counts (priblks and
*              secblks) for a new data set allocation based on the
*              specified blocksize, average record length, and expected
*              data set sizes (recsinit and recsincr).
*---------------------------------------------------------------------*
 block type=subroutine,name=suggest_blockcounts,                       +
               options=(*swa,loadbase,(parms,(using,r5),prefix)),      +
               parms=(blksize,avglrecl,recsinit,                       +
               recsincr,priblks,secblks)
   l     r1,&spl.blksize             |
   l     r1,0(,r1)                   | r1 = blocksize.
   l     r2,&spl.avglrecl            | r2 -> average record length.
   xr    r0,r0                       | Clear R0 before division.
   d     r0,0(,r2)                   | R1 = records per block.
*                                    |
   l     r3,&spl.recsinit            |
   l     r3,0(,r3)                   | r3 := initial #records.
   xr    r2,r2                       | Clear R2 before division.
   dr    r2,r1                       | R3 = # blocks primary.
   if    (treg,r2,nz)                | If there was a remainder
     la    r3,1(r3)                  |   Round up the quotient.
   endif                             | EndIf.
   l     r14,&spl.priblks            | r14 -> primary blocks parm.
   st    r3,0(,r14)                  | Save primary allocation blks
*
   xr    r2,r2                       | Clear R2 before division.
   l     r14,&spl.secblks            | r14 -> primary blocks parm.
   st    r2,0(,r14)                  | Set secondary #blks = 0.
   l     r3,&spl.recsincr            |
   l32   r3,0(r3)                    | r3 := record increment amount.
   if    (nz)                        | If secondary space requested.
     dr    r2,r1                     |   r3 := recsincr/(recs per blk)
     if    (treg,r2,nz)              |   If there was a remainder.
       la    r3,1(r3)                |     Round up the quotient.
     endif                           |   EndIf.
     st    r3,0(,r14)                |   R3 = # blocks secondary
   endif                             | EndIf.
 endblk block=suggest_blockcounts
         eject                        |
*---------------------------------------------------------------------*
*
*  Subroutine: SPFEDIT_ENQ
*  Abstract:   This routine will attempt to ENQ on major name SPFEDIT,
*              minor name of the dataset and member name.  This routine
*              should be called whenever a PDS member is opened OUTPUT.
*  Inputs:     On entry, R1 points to the following parameter list:
*                +0 -- Address of dataset name
*                +4 -- Address of member name
*  Outputs:    R15 = 0 if ENQ was successful
*              R15 = 8 if ENQ was held by another user
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=spfedit_enq,type=subroutine
  lm    r2,r3,0(r1)                   |
  mvc   &w.enq(l_enq),&s.enq          |
  fill  &w.rname,c' '                 |
  mvc   &w.rname(44),0(r2)            |
  mvc   &w.rname+44(8),0(r3)          |
  enq   (,&w.rname),mf=(e,&w.enq)     |
  if    (treg,r15,nz)                 |
   la    r15,8                        |
  else                                |
   sbit pwa_2,pwa_2_member_enq        |
  endif                               |
 endblk rc=(r15)                      |
     ssd   ,                          |
&s.enq   enq   (&psd.spfedit,*-*,e,52,systems),ret=use,mf=l
l_enq    equ   *-&s.enq               |
     endssd ,                         |
     swa   ,                          |
&w.enq   ds    0f,cl(l_enq)           |
&w.rname ds    cl52                   |
     endswa ,                         |
         eject                        |
*---------------------------------------------------------------------*
*
*  Subroutine: SPFEDIT_DEQ
*  Abstract:   This routine will DEQ unconditionally on major name
*              SPFEDIT, minor name of the dataset and member name.
*              should be called whenever a PDS member is opened OUTPUT.
*  Inputs:     On entry, R1 points to the following parameter list:
*                +0 -- Address of dataset name
*                +4 -- Address of member name
*  Outputs:    None.
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=spfedit_deq,type=subroutine
  lm    r2,r3,0(r1)                   |
  mvc   &w.deq(l_deq),&s.deq          |
  fill  &w.rname,c' '                 |
  mvc   &w.rname(44),0(r2)            |
  mvc   &w.rname+44(8),0(r3)          |
  deq   (,&w.rname),mf=(e,&w.deq)     |
  rbit  pwa_2,pwa_2_member_enq
 endblk
     ssd   ,
&s.deq   deq   (&psd.spfedit,*-*,52,systems),ret=have,mf=l
l_deq    equ   *-&s.deq
     endssd ,
     swa   ,
&w.deq   ds    0f,cl(l_deq)
&w.rname ds    cl52
     endswa ,
     eject ,
*---------------------------------------------------------------------*
*
*  Subroutine: Free_Buffer_Pool
*  Abstract:   This routine serves as an intelligent FREEPOOL, taking
*              into account that the File Handler may have been running
*              in key zero (hence subpool 0 is actually subpool 252).
*  Inputs:     On entry, R1 points to the following parameter list:
*                +0 -- Address of DCB to free buffers for.
*  Outputs:    Buffers freed
*  Special
*  Notes:      See below.
*
*---------------------------------------------------------------------*
         SPACE 1
 block type=subroutine,name=free_buffer_pool,amode=24
         SPACE 1
* *-------------------------------------------------------------------*
* *  Even though OPEN acquired our QSAM buffer pool for us, we are
* *  responsible for freemaining it.  Worse, if we are running in
* *  key0/supv state, the buffers must be freemained from subpool
* *  252 instead of zero. Unfortunately, the FREEPOOL macro is not
* *  smart enough to handle this, so we must hardcode the FREEPOOL
* *  code ourselves.  The buffer control block pointed to by the
* *  DCB describes the storage to be freemained.  (There is no
* *  mapping macro for the BUFCB.)
* *-------------------------------------------------------------------*
* *  Format of BUFCB:
* *    +0 -- Addr of buffer area (follows the BUFCB)
* *    +4 -- Flags. X'40' sez the BUFCB is 16 bytes long.
* *    +5 -- No. of buffers
* *    +6 -- Length of 1 buffer
* *-------------------------------------------------------------------*
  l     r5,0(r1)                      | Get DCB address from parameters
  using ihadcb,r5                     |
  l24   r4,dcbbufca                   | Get BUFCB address
  leave block=*,(z),or,               | Leave if address is zero or    *
               (tbit,dcbbufca+2,x'01')   already marked invalid
  oi    dcbbufca+2,x'01'              | Mark DCBBUFCA invalid
  l8    r3,5(r4)                      | Get no. of buffers
  mh    r3,6(r4)                      | Times buffer size
  la    r3,8(r3)                      | Include length of header
  if    (tbit,4(r4),x'40')            | 16-byte header?
   la    r3,8(r3)                     |  Add that in, too.
  endif                               |
* *-------------------------------------------------------------------*
* *  If we are running in key zero, any storage acquired in subpool
* *  zero will actually be in subpool 252.
* *-------------------------------------------------------------------*
*                                     |  Are we supervisor state?
  testauth     fctn=0,                |     (Don't look at APF bit)    *
               state=yes,             |     (Require supv. state)      *
               rblevel=1              |
  if    (treg,r15,z)                  | If so, check PSW key:
*  *------------------------------------------------------------------*
*  * TESTAUTH sez we're in supervisor state.
*  *------------------------------------------------------------------*
   xr    r2,r2                        |  IPK puts key in R2 bits 24-27
   ipk   ,                            |   leaving the rest of R2 alone.
   if    (treg,r2,z)                  |  If R2 is still zero:
*   *-----------------------------------------------------------------*
*   * Supervisor state, key zero.  Set up FREEMAIN for subpool 252.
*   *-----------------------------------------------------------------*
    icm   r3,b'1000',=al1(252)        |   Freemain from subpool 252.
   endif                              |
  else                                | Otherwise (prob state, key=??)
   testauth    fctn=0,                |  See what kinda key we're in   *
               key=yes,               |     (Require system key)       *
               rblevel=1              |
   if    (treg,r15,z)                 |  If a system key, see if key 0.
*   *-----------------------------------------------------------------*
*   * Problem state, but an authorized key.
*   *-----------------------------------------------------------------*
    xr    r2,r2                       |  Clear R2 before IPK uses it
    modeset mode=sup                  |  Make the IPK inst. work
    ipk   ,                           |  Get the PSW key
    modeset mode=prob                 |  That's enough of that.
    if    (treg,r2,z)                 |  If R2 is still zero, we need
*    *----------------------------------------------------------------*
*    * Problem state, key zero.  Set up FREEMAIN for subpool 252.
*    *----------------------------------------------------------------*
     icm   r3,b'1000',=al1(252)       |   to freemain from subpool 252.
    endif                             |
   endif                              |
  endif                               |
  lr    r0,r3                         | Copy subpool/length
  lr    r1,r4                         | Copy area address
  freemain r,lv=(0),a=(1)             | Free those buffers.
  drop  r5                            | Drop DCB base
 endblk                               | That's it.
         eject                        |
***********************************************************************
*                                                                     *
*  Subroutine: EOF                                                    *
*  Abstract:   Set the end-of-file indicator.                         *
*  NOTE:       AMODE = whatever it is entered with.                   *
*                                                                     *
***********************************************************************
 block name=eof,type=subroutine,options=(*nosubopts,custom)
   balr  r15,0                        |
   using *,r15                        |
   sbit  pwa_1,pwa_1_eof              |
   bsm   0,r14                        |
   drop  r15                          |
 endblk block=eof                     |
 space 1                              |
***********************************************************************
*                                                                     *
*  Subroutine: SYNAD                                                  *
*  Abstract:   Handle an OS input/output error.                       *
*                                                                     *
***********************************************************************
 block name=synad,type=subroutine,amode=24,options=codebase
   synadaf acsmeth=qsam            |
   l       r13,4(,r13)             | R13 -> PWA.
   la      r2,50(,r1)              | R2 -> Synad message text.
   l16     r3,0(r1)                | R3 := Length of message buffer.
   sh      r3,=h'50'               | R3 := length of message text.
*                                  |
   la      r4,pwa_err_msg          | R4 -> PWA storage for message.
   la      r5,l'pwa_err_msg        | R5 := Length of message storage.
   l       r15,fi00202             | R15 -> SYNAD message prefix.
   la      r14,4(r15)              | R14 -> message prefix text.
   l       r15,0(r15)              | R15 := message prefix length.
   if      (cr,r5,gt,r15)          | If enough storage for entire msg.
     lr    r5,r15                  |   Use exact length.
   endif                           | EndIf.
   st      r5,pwa_err_msg_len      | Save length before doing MVCL.
   mvcl    r4,r14                  | Copy message prefix to the PWA.
*                                  |
   la      r5,l'pwa_err_msg        | R5 := Length of message storage.
   s       r5,pwa_err_msg_len      | R5 := Remaining length.
   if      (cr,r5,gt,r3)           | If enough storage for entire msg.
     lr    r5,r3                   |   Use exact length.
   endif                           | EndIf.
   l       r1,pwa_err_msg_len      | R1 := message prefix length.
   ar      r1,r5                   | Add SYNAD message's length.
   st      r1,pwa_err_msg_len      | Save length before doing MVCL.
*                                  |
   mvcl    r4,r2                   | Copy message prefix to the PWA.
*                                  |
   l       r13,8(,r13)             | R13 -> SYNAD's save area.
   synadrls                        | Release the SYNAD data areas.
   sbit    pwa_1,pwa_1_error          |
 endblk block=synad                   |
             eject
*---------------------------------------------------------------------*
*
*  Subroutine: MESSAGE
*  Abstract:   Format a message and exit the program.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=message
   lr  r2,r1                       | R2 -> Parameter list.
   l   r4,0(r2)                    | R4 -> Message's ADCON.
   l   r4,0(r4)                    | R4 -> Message Length, Text.
*---------------------------------------------------------------------*
*  Invoke the string-formatter to put together the message.
*---------------------------------------------------------------------*
   mvi &w.formatted,c'N'           | Message not yet formatted.
   if (clc,pwa_st_sptoken,ne,=f'0')   if string-handler is started.
     lr    r1,r2                   |    R1 -> parm before 1st arg.
     loop  while,(tbit,0(r1),x'80',off) while not at last parameter.
       la    r1,4(,r1)             |     Advance to next parameter.
     endloop while                 |    EndLoop.
     sr        r1,r2               |    R1 := length of plist.
     srl       r1,2                |    R1 := number of source args.
     st        r1,&w.count         |    Save #arguments for ST_FORMAT.
     es_clear_debug_info id=es,action=inhibit
     st_format id=st,string=pwa_err_msg,resultlen=pwa_err_msg_len,     +
               control=(4(r4),0(r4)),sourcelist=(4(r2),&w.count)
     if        (%st_success)          |   If successful format.
       mvi     &w.formatted,c'Y'      |     Set formatted-flag.
     else                             |   Else.
       sth                r15,&w.rc   |     Save bad return-code.
       es_save_debug_info id=es,text="ST_FORMAT failed while attempting+
                to format a message: return code follows."
       es_save_debug_info id=es,hex=(&w.rc,=a(l'&w.rc)),label="RETCODE"
       es_save_debug_info id=es,text=(4(r4),0(r4)),label="MESSAGE"
       es_display_debug_info id=es
     endif                            |   EndIf.
     es_clear_debug_info id=es,action=enable
   endif                           | EndIf.
*---------------------------------------------------------------------*
*  If the message could not be formatted, use the unformatted version.
*---------------------------------------------------------------------*
   if (cli,&w.formatted,ne,c'Y')   | If message not formatted.
     l    r5,0(r4)                 |   R5 := length of message text.
     la   r1,l'pwa_err_msg         |   R1 -> Length of target area.
     if   (cr,r5,gt,r1)            |   If too long to fit, then.
       lr r5,r1                    |     Use as much as possible.
     endif                         |   EndIf.
     st   r5,pwa_err_msg_len       |   Save length of message
     lr   r1,r5                    |   Set target to exact size.
     la   r4,4(r4)                 |   R4 -> message text.
     la   r0,pwa_err_msg           |   R0 -> Target area of move.
     mvcl r0,r4                    |   Copy message text.
   endif                           | EndIf.
*---------------------------------------------------------------------*
*  Set R15 = return-code associated with the new message.
*---------------------------------------------------------------------*
   la   r0,pwa_err_msg                | R4 -> Formatted message text.
   la   r1,pwa_err_msg_len            | R5 -> Length of formatted msg.
   stm  r0,r1,pwa_msg_data            | Save address/length of message.
*                                     |
   if (cli,pwa_err_msg+7,eq,c"I")     | If an information msg, then.
     la r15,0                         |   Exit with zero return-code.
   elseif (cli,pwa_err_msg+7,eq,c"W") | If a warning message, then.
     la r15,&fi_warning               |   Exit with the warning-code.
   elseif (cli,pwa_err_msg+7,eq,c"E") | ElseIf an error message, then.
     la r15,&fi_error                 |   Exit with the error-code.
   elseif (cli,pwa_err_msg+7,eq,c"X") | ElseIf invalid filename.
     la  r15,&fi_invalid_syntax       |   Exit with the syntax-code.
     mvi pwa_err_msg+7,c'e'           |   Change msg-severity to 'E'.
   elseif (cli,pwa_err_msg+7,eq,c"S") | ElseIf an error message, then.
     la r15,&fi_severe                |   Exit with the severe-code.
   else                               | Else
     la r15,&fi_critical              |   Exit with the critical-code.
   endif                              | EndIf.
 endblk block=message
*---------------------------------------------------------------------*
* Working storage for formatting messages.
*---------------------------------------------------------------------*
            swa
&w.count      ds     f                | Number of SOURCE arguments.
&w.rc         ds     h                | ST_FORMAT return-code.
&w.formatted  ds     c                | Successful format = Y.
            endswa
 eject
***********************************************************************
*                                                                     *
*  Error exit for all functions in the file handler.                  *
*                                                                     *
***********************************************************************
 block type=errexit,amode=31
*---------------------------------------------------------------------*
*  Save module/offset and registers.
*---------------------------------------------------------------------*
   stm   r0,r15,gdiregs          | Save registers at time of error.
   sm_lal r0,srvfios+4            | Point to module identification.
   st    r0,gdimodid             | Save in general debug area.
   if    (clc,=h'0',eq,0(r14))   | If CODE=00, then.
     sth r15,gdirc               |   Use R15 for final return code.
   else                          | Else.
     mvc gdirc,0(r14)            |   Set return code = CODE.
   endif                         | EndIf.
   sl    r14,=a(srvfios)         | Calculate offset at time of error.
   sth   r14,gdioffst            | Save in debug area.
   es_save_debug_info id=es,gdi=gdi
*---------------------------------------------------------------------*
*  Check the return-code, and save the debugging message accordingly.
*---------------------------------------------------------------------*
   lh    r3,gdirc                | R3 := return-code.
   if    (c,r3,ge,=f'&fi_error') | If an error or worse.
     sbit pwa_1,pwa_1_error          Remember it.
   endif                         | EndIf.
   caseblk reg=r3,mult=1         | Case on return-code.
     case &fi_success,           |   Success (Information msg).        +
               &fi_warning,      |   Warning message.                  +
               &fi_error,        |   Error message.                    +
               &fi_severe,       |   Severe error message.             +
               &fi_invalid_syntax,   Error (Syntax) message.           +
               &fi_critical,     |   Critical error message.           +
               &fi_end_of_file
       la r4,pwa_err_msg         |     R4 -> Formatted message text.
       la r5,pwa_err_msg_len     |     R5 -> Length of formatted msg.
     case &fi_invalid_fileid     |   Bad token value.
       l  r5,fi00001             |     R5 -> Length of message.
       la r4,4(r5)               |     R4 -> Message text.
     case other                  |   Unknown error-code.
       l  r5,fi00003             |     R5 -> Length of message.
       la r4,4(r5)               |     R4 -> Message text.
   endcase                       | EndCase.
   stm   r4,r5,pwa_msg_data      | Save address/length of message.
   es_save_debug_info id=es,text=((r4),(r5))
*---------------------------------------------------------------------*
*  Set the final return-code and exit.
*---------------------------------------------------------------------*
   lh    r15,gdirc               |
 endblk
 eject
*---------------------------------------------------------------------*
*
*  Static Data
*
*---------------------------------------------------------------------*
               psd
               ltorg
eyecatcher     dc     c"FIOS"               | PWA-block eyecatcher.
&psd.podcb     dcb    ddname=xxxxxxxx,dsorg=po,macrf=(r,w),synad=synad
&psd.podcb_len equ    *-&psd.podcb        |
&psd.psdcb     dcb    ddname=xxxxxxxx,dsorg=ps,macrf=(r),synad=synad
&psd.psdcb_len equ    *-&psd.psdcb        |
&psd.OPEN      open   *-*,mf=l              | OPEN parameter-list.
open_l         equ    *-&psd.open           | Length of OPEN plist.
         read   &psd.decb_start,sf,*-*,mf=l
&psd.decb equ   &psd.decb_start,*-&psd.decb_start
&psd.spfedit   dc     cl8"SPFEDIT "         | spf-edit qname.
*---------------------------------------------------------------------*
*  Static data for dynamic allocation (SVC 99) of OS data sets.
*---------------------------------------------------------------------*
da_sysout        text_unit dalsysou
da_ddname        text_unit dalddnam,cl8" "       ddname=<blanks>
da_dsname        text_unit daldsnam,cl44" "      dsname=<blanks>
da_member        text_unit dalmembr,cl8" "       member=<blanks>
da_stat_shr      text_unit dalstats,x"08"        disp=shr
da_ret_ddname    text_unit dalrtddn,cl8" "       return ddname.
da_ds_ret_dsorg  text_unit dalrtorg,xl2"0000"    return dsorg.
*
da_ir_ddname     text_unit dinddnam,cl8" "       ddname=<blanks>
da_ir_ret_dsorg  text_unit dinrtorg,xl2"0000"    return dsorg.
da_ret_dsname    text_unit dinrtdsn,cl44" "      return dsname.
da_ret_dsname_al text_unit dalrtdsn,cl44" "      return dsname (alloc).
da_ret_member    text_unit dinrtmem,cl8" "       return member.
da_ret_status    text_unit dinrtsta,X"00"        return status.
da_ret_ndisp     text_unit dinrtndp,X"00"        return normal disp.
da_ret_attrs     text_unit dinrtatt,x"00"        return attributes  @DD
da_statnew       text_unit dalstats,x"04"        disp=(new,
da_normdisp      text_unit dalndisp,x"02"              catlg,
da_normdispdel   text_unit dalndisp,x"04"              delete,
da_conddisp      text_unit dalcdisp,x"04"              delete)
da_blkalloc      text_unit dalblkln,x"000000"    space=(blocksize,
da_prispace      text_unit dalprime,x"000000"           (primary,
da_secspace      text_unit dalsecnd,x"000000"            secondary))
da_dirblks       text_unit daldir,x"00000A"      10 dir blks.
da_dsorg         text_unit daldsorg,x"4000"      dsorg=ps (x"0200"=po)
da_lrecl         text_unit dallrecl,x"0000"      lrecl=<calculated>.
da_blksize       text_unit dalblksz,x"0000"      blksize=<calculated>.
da_recfm_fb      text_unit dalrecfm,b"10010000"  recfm=FB.
da_recfm_vb      text_unit dalrecfm,b"01010000"  recfm=VB.
da_recfm_fba     text_unit dalrecfm,b"10010100"  recfm=FBA.
da_recfm_vba     text_unit dalrecfm,b"01010100"  recfm=VBA.
da_unit          text_unit dalunit,cl5"SYSDA"    unit=sysda
*
da_dsorg_table   equ  *
da_PO    dc   x'0200',c'PO  '   | Returned DSORG=PO.
         dc   x'0300',c'POU '   | Returned DSORG=POU.
         dc   x'4000',c'PS  '   | Returned DSORG=PS.
         dc   x'4100',c'PSU '   | Returned DSORG=PSU.
         dc   x'0000',c'****'   | Returned DSORG=****.
         dc   x'0004',c'TR  '   | Returned DSORG=TCAM.
         dc   x'0008',c'VSAM'   | Returned DSORG=VSAM.
         dc   x'0020',c'TQ  '   | Returned DSORG=TCAM msg queue.
         dc   x'0040',c'TX  '   | Returned DSORG=TCAM line group.
         dc   x'0400',c'MQ  '   | Returned DSORG=Message Queue.
         dc   x'0800',c'CQ  '   | Returned DSORG=DA Msg Queue.
         dc   x'1000',c'CX  '   | Returned DSORG=Comm Line group.
         dc   x'2000',c'DA  '   | Returned DSORG=Direct Access.
         dc   x'2100',c'DAU '   | Returned DSORG=DAU.
         dc   x'8000',c'IS  '   | Returned DSORG=ISAM.
         dc   x'8100',c'ISU '   | Returned DSORG=ISAM Unmovable.
da_dsorg_table_e equ  *
         dc   x'FFFF',c'????'   | Entry picked for unknown DSORG.
da_status_new    dc   x'04'     | Returned STATUS=NEW.
*
            macro
&label      trantab
            lcla &n
&label      ds   0xl256        |
.newrow     dc   al1(&n+0,&n+1,&n+2,&n+3,&n+4,&n+5,&n+6,&n+7)
            dc   al1(&n+8,&n+9,&n+10,&n+11,&n+12,&n+13,&n+14,&n+15)
&n          seta &n+16
            aif  (&n lt 256).newrow
            mend
fold        trantab            | Translate tbl for uppercase conv.
            org  fold+c"a"     | Fold lowercase 'a' - 'i'.
            dc   c"ABCDEFGHI"  |
            org  fold+c"j"     | Fold lowercase 'j' - 'r'.
            dc   c"JKLMNOPQR"  |
            org  fold+c"s"     | Fold lowercase 's' - 'z'.
            dc   c"STUVWXYZ"   |
            org  ,             |
lettrdig    dc   256x'ff'      |      Letter or Digit
            org  lettrdig+c"A" |
            dc   9x"00"        |      --- 'ABCDEFGHI'
            org  lettrdig+c"J" |
            dc   9x"00"        |      --- 'JKLMNOPQR'
            org  lettrdig+c"S" |
            dc   8x"00"        |      --- 'STUVWXYZ'
            org  lettrdig+c"#" |
            dc   1x"00"        |      --- '#'
            org  lettrdig+c"$" |
            dc   1x"00"        |      --- '$'
            org  lettrdig+c"@" |
            dc   1x"00"        |      --- '@'
            org  lettrdig+c"0" |
            dc   10x"00"       |      --- '0123456789'
            org  ,             |
            eject
*---------------------------------------------------------------------*
* Messages are made up of a message identifier followed by a control
* string.  The message identifier has the format
*
*   FInnnnns
*
* where the characters FI always begin a file-handler's message, nnnnn
* is the unique message number, and s indicates the message's severity.
*
* Severity                  Meaning
* --------   ---------------------------------------------
*    I       Informational.
*    W       Warning message.
*    E       An error occurred.
*    X       Filename syntactically invalid.
*    S       Severe error.  Execution cannot continue.
*    C       Critical error.  Indicates a probable programming error.
*
*---------------------------------------------------------------------*
            macro
            msg   &number,&severity,&text
            lclc  &msgid,&oldloc
&oldloc     setc  '&sysloc'
&msgid      setc  'fi&number'
&msgid      dc    a(msgt&sysndx)
xsmsgs      loctr ,
msgt&sysndx dc    al4(msgl&sysndx),c'&msgid&severity',c' ',c&text
msgl&sysndx equ   *-msgt&sysndx-4
&oldloc     loctr ,
            mend
*
 MSG 00000,I,"Successful completion of last operation."
 MSG 00001,C,"Invalid file identifier token."
 MSG 00002,X,"Not a syntactically valid file name: {CL44 TRIM}."
 MSG 00003,C,"Unknown error."
*
 MSG 00004,C,"Processing halted due to a previous error."
 MSG 00005,C,"Invalid function-code parameter: {I}."
 MSG 00006,C,"Wrong number of parameters for the {CL?} function."
 MSG 00007,C,"Invalid OPTIONS value: B""{BL?}""."
 MSG 00008,C,"Sequential input (READLINE) requires INPUT access mode."
 MSG 00009,S,"Not enough storage to operate."
 MSG 00010,S,"Error obtaining memory for BPAM buffer.  RC={I}."
*
 MSG 00011,X,"No file name specified."
 MSG 00012,C,"Sequential output (WRITELINE) requires OUTPUT access mode+
               ."
 MSG 00014,X,"Null member name specified."
 MSG 00015,X,"Member name is longer than {I} characters."
 MSG 00016,X,"Invalid member name: {CL8 T}."
 MSG 00017,X,"Invalid qualifier: {CL?}."
 MSG 00018,X,"Data set name is longer than {I} characters: {CL? T}."
 MSG 00019,X,"Qualifier in data set name is longer than 8 characters: {+
               CL?}."
 MSG 00020,X,"Zero length qualifier in data set name."
 MSG 00021,C,"File name truncated in GET_NAME function."
 MSG 00022,C,"Invalid information code ({I}) for the GET_INFO function.+
               "
 MSG 00023,C,"Unable to load the String Handler (SRVSTR)."
 MSG 00024,C,"Unable to start the String Handler."
 MSG 00025,X,"DDNAME is longer than {I} characters: {CL? T}."
 MSG 00026,E,"DDNAME {CL8 TRIM} is not allocated to any file."
 MSG 00028,C,"Internal error during blocksize calculation routine."
 MSG 00029,C,"Average record length of zero is invalid."
 MSG 00030,E,"Requested volume {CL6} is currently not available."
 MSG 00031,C,"Invalid status code ({I}) for the SET_STATUS function."
 MSG 00032,C,"Option EXISTING is required for INPUT files."
 MSG 00033,C,"Options {CL?} are mutually exclusive."
 MSG 00034,C,"RECORDLENGTH and FILESIZE parameters are for OUTPUT files+
                only."
 MSG 00035,S,"Maximum number of INFO parameters ({I}) exceeded."
 MSG 00036,S,"Unexpected return code from RACHECK for dataset {CL44 TRI+
               M}. RC={I} Reason={I}."
 MSG 00037,C,"Option LIBRARY and specifying a member name in a file nam+
               e are mutually exclusive."
 MSG 00038,C,"Option LIBRARY is only valid for a PDS or PDSE."
 MSG 00039,C,"FIND required before READLINE when option LIBRARY is used+
               ."
 MSG 00040,W,"Member {CL8 TRIM} not found."
 MSG 00041,E,"FIND failed for member {CL8 TRIM}. RC={I} Reason={I}."
 MSG 00042,S,"Function {CL?} is only allowed if OPTION=LIBRARY is speci+
               fied."
 MSG 00043,E,"Error releasing memory for BPAM buffer.  RC={I}."
*
 MSG 00101,E,"Unsupported data set organization ({CL4 T}) for {CL44 T}.+
               "
 MSG 00102,E,"Open failed for data set {CL44 T}."
 MSG 00103,E,"No member specified for PDS {CL44 T}."
 MSG 00104,E,"Member {CL8 T} not in {CL44 T}."
 MSG 00107,E,"Unsupported record format."
 MSG 00108,E,"Data set {CL44 T} is not partitioned, but member {CL8 T} +
               was specified."
 MSG 00109,E,"Allocation to was denied by installation exit."
 MSG 00110,E,"Data set {CL44 T} is allocated to another user."
 MSG 00111,E,"Could not find data set {CL44 T}."
 MSG 00112,E,"Could not allocate data set {CL44 T}: Dynamic Allocation *
               error({XL2},{XL2})."
 MSG 00113,E,"Dynamic allocation error ({XL2},{XL2}). "
 MSG 00114,S,"Function {CL?} not performed; file is not open."
 MSG 00115,S,"Maximum RECORDLENGTH of {I} less than average RECORDLENGT+
               H of {I}."
 MSG 00116,S,"Requested record format inconsistent with that of existin+
               g file."
 MSG 00117,E,"PDS member {CL8 TRIM} in dataset {CL44 T} already exists +
               and was not replaced."
 MSG 00118,E,"Requested output LRECL of {IL2} for PDS member does not m+
               atch existing PDS LRECL of {IL2}."
 MSG 00119,E,"Member {CL8} is currently in use by another user."
 MSG 00120,E,"User {CL7 T} has insufficient authority to {CL?} data set+
                {CL44 T}."
 MSG 00121,E,"Maximum number of allocations has been reached. Free unus+
               ed files and try again."
 msg 00122,e,"No acceptable volumes available for allocation."
 msg 00123,e,"Requested unit name of {CL8 T} is not available."
 msg 00124,e,"Requested volume {CL6 T} not available."
 msg 00125,e,"Existing BLKSIZE of {I} not an even multiple of {I}."
 msg 00126,w,"File is {CL?} OPEN: request denied."
 msg 00127,e,"Unable to delete member {CL8 T} from {CL44 T}: STOW DELET+
               E failed with RC={I}."
 msg 00128,e,"Dataset {CL44 T} already exists and was not replaced."
*
 MSG 00200,W,"End of file."
 MSG 00201,E,"{CL6 TRIM} record was truncated to {I} characters."
 MSG 00202,S,"Synad error: "
 MSG 00203,I,"PUT {CL8} B={XL4} D={CL?}."
*
 MSG 00300,I,"Dataset {CL44 TRIM}{CL?}{CL8 TRIM}{CL?} {CL8 TRIM}."
 MSG 00301,I,"Member {CL8 TRIM} {CL8 TRIM} in dataset {CL44 TRIM}."
            endpsd
            eject
***********************************************************************
*                                                                     *
*  Program Work Area                                                  *
*                                                                     *
***********************************************************************
                    pwa
pwa_visual          ds  cl(l'eyecatcher)
pwa_fileid          ds  a           | Unique file identifier.
pwa_esepa           ds  a           | Environment Support entry-point.
pwa_estkn           ds  f           | Environment Support token.
pwa_st_spepa        ds  a           | String Handler EPA.
pwa_st_sptoken      ds  f           | String Handler Token.
*                                   |
pwa_1               ds  x           | Housekeeping/status flags.
pwa_1_allocated     equ b'10000000' |   File has been allocated.
pwa_1_open          equ b'01000000' |   File has been opened.
pwa_1_error         equ b'00100000' |   Processing halted due to error.
pwa_1_eof           equ b'00010000' |   End of file has been reached.
pwa_1_vb            equ b'00001000' |   Caller has requested VB output
pwa_1_fb            equ b'00000100' |   Caller has requested FB output
pwa_1_ds_not_existing equ b'00000010' | Requested dataset not found
pwa_1_member        equ b'00000001' |   Requested member exists in PDS
*                                   |
pwa_2               ds  x           | More status flags:
pwa_2_member_enq    equ b'10000000' |   SPFEDIT ENQ done on member
pwa_2_sysinout      equ b'01000000' |   File is SYSIN | SYSOUT.
pwa_2_fios_supplies_dcb_attributes equ b'00100000'
pwa_2_concatenated  equ b'00010000' |   Allocation by DD is concat'd@DD
pwa_2_reference_supplied  equ b'00001000'  Reference supplied by caller
pwa_2_free_on_terminate   equ b'00000100'  Terminate should unallocate.
pwa_2_ascii               equ b'00000010'  File is ascii,caller ebcdic.
pwa_2_valid_find_active   equ b'00000001'  A valid find is active.
*                                   |
pwa_oc_mode         ds  x           | Option: &FI_OC_ INPUT/OUTPUT.
pwa_oc_ident        ds  x           | Option: &FI_OC_ DSNAME/DDNAME.
pwa_oc_filetempx    ds  x           | Option: &FI_OC_ FILETEMP.
pwa_oc_disp         ds  x           | Opt: EXISTING/NEW/REPLACE/APPEND.
pwa_oc_recfm        ds  x           | Option: &FI_OC_ FIXED/VARIABLE.
pwa_oc_open         ds  x           | Option: &FI_OC_ AUTOOPEN/MANUAL*.
pwa_oc_xopt         ds  x           | Option: &FI_OC_XOPT BYTE/WORD.
pwa_oc2_cc          ds  x           | Option: &FI_OC2_ ISOCC.
pwa_oc2_free        ds  x           | Option: &FI_OC2_ AUTO/MANUAL.
pwa_oc2_sysoutx     ds  x           | Option: &FI_OC2_ SYSOUT.
pwa_oc2_chkpdsmemx  ds  x           | Option: &FI_OC2_ ÝNO¨CHKPDSMEM.
pwa_oc2_library     ds  x           | Option: &FI_OC2_ ÝNO¨LIBRARY.
pwa_oo_mode         ds  x           | Option: &FI_OO_ INPUT/OUTPUT.
*                                   |
pwa_userid          ds  cl7         | Current userid, for messages.
pwa_spfedit_rname   equ *,52,c'c'   | RNAME for SPFEDIT pds members.
pwa_dsname          ds  cl44        |  Full dsn, padded w/blanks.
pwa_member          ds  cl8         |  Member name, padded w/blanks.
pwa_ddname          ds  cl8         | DDname allocated to dsname.
pwa_sysoutclass     ds  c           | SYSOUT(class) if OPTIONS(SYSOUT)
pwa_unitname        ds  cl8         | Unitname (only present for err)
pwa_volser          ds  cl6         | Volser of allocated file.
pwa_dsorg           ds  cl4         | DSORG returned by dynalloc.
pwa_recfm           ds  x           | Actual dataset RECFM.
pwa_lrecl           ds  f           | Actual dataset LRECL.
pwa_blksize         ds  f           | Actual dataset BLKSIZE.
*  BPAM buffer entry related.
pwa_bent_count             ds h     |
pwa_bent_size              ds f     |
pwa_bent_buffer_size       ds f     |
pwa_bent_buffer_address    ds a     |
pwa_bent_current           ds a     |
pwa_bent_current_cursor    ds a     |
pwa_bent_current_remaining ds f     |
*
pwa_status          ds  x           | Allocation status:
pwa_status_old      equ x'01'       |   OLD.
pwa_status_mod      equ x'02'       |   MOD.
pwa_status_new      equ x'04'       |   NEW.
pwa_status_shr      equ x'08'       |   SHR.
pwa_ndisp           ds  x           | Normal DISPosition value:
pwa_ndisp_uncatlg   equ x'01'       |   UNCATLG.
pwa_ndisp_catlg     equ x'02'       |   CATLG.
pwa_ndisp_delete    equ x'04'       |   DELETE.
pwa_ndisp_keep      equ x'08'       |   KEEP.
pwa_ndisp_pass      equ x'10'       |   PASS.
*                                   |
pwa_dcb             dcb ddname=xxxxxxxx,dsorg=ps,macrf=(r)
                    org pwa_dcb     | Overlay PS DCB with PO DCB.
                    dcb ddname=xxxxxxxx,dsorg=po,macrf=(r)
                    org ,           | Get back to right address.
pwa_open            ds  cl(open_l)  | OPEN parameter list.
*                                   |
pwa_current_record ds   a           | Address of next logical record.
*                                   |
pwa_avglrecl        ds  f           | Average LRECL
pwa_maxlrecl        ds  f           | Max. LRECL (=AVG if RECFM=FB)
pwa_sizeinit        ds  f           | Initial record count
pwa_sizeincr        ds  f           | Incremental record count
*                                   |
pwa_primary_blocks      ds  f       | Primary # blocks for allocation
pwa_secondary_blocks    ds  f       | Secondary # blocks for alloc.
*                                   |
pwa_suggested_blksize   ds  f       | Suggested output BLKSIZE.
pwa_recs_per_block      ds  f       | Number of records per block.
*                                   |
pwa_unitname_textunit   ds  a       | Address of caller's DALUNIT tu
*                                   |
pwa_msg_data        ds  2f          | Address/length of message.
pwa_err_msg_len     ds  f           | Short description of error,
pwa_err_msg         ds  cl256       | Error, Warning, or Info msg.
*                                   |
pwa_exlst           ds  f           | Exit-list for OPEN TYPE=J.
                    es_gdi dsect=no |
pwa_jfcb            ds  cl176       | JFCB work-area.               @DD
pwa_fi_reference    ds  cl70        | FI_START reference string
pwa_UCBTBYT4        ds  cl(l'UCBTBYT4)  Device type from UCB.
pwa_save_r15        ds  f           | Field to temporarily contain R15
                    ds  0f          | List of text unit pointers, with
pwa_textunits       ds  cl(50*4)    |   high bit set in final pointer.
pwa_textunits_end   ds  f
                    endpwa          |
                    eject           |
***********************************************************************
*  Buffer entry used for BPAM.
***********************************************************************
         vda gentype=dsect,id=bent_
bent_decb       ds   xl(l'&psd.decb)
bent_next       ds   a
bent_data_start ds   0d
bent_fixed_len  equ  *-bent_start
         endvda
                    eject           |
***********************************************************************
*  Environment Support Vector DSECT
***********************************************************************
              es_esv  ,             |
              eject                 |
***********************************************************************
*  MVS Router Parameter List used by RACROUTE.
***********************************************************************
              ichsafp ,             |
              eject                 |
***********************************************************************
*  DEVTYPE return area DSECT
***********************************************************************
              ihadva ,              |
***********************************************************************
*  Dynamic allocation DSECTs
***********************************************************************
              iefzb4d0              |
              iefzb4d2              |
              eject                 |
***********************************************************************
*  Data set control block DSECT
***********************************************************************
              dcbd     dsorg=ps     |
              iefucbob ,            |
jfcb          dsect                 | IEFJFCBN doesn't make a DSECT.
              IEFJFCBN list=yes     |
              cvt      dsect=yes    |
              eject                 |
***********************************************************************
*  Parameter list for all file servers.
***********************************************************************
              fi_parmlist           |
***********************************************************************
              end ,                 |
