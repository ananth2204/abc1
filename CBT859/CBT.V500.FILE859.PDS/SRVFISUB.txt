*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
SRVFISUB TITLE 'Batch job submit File service processor.'
         SRVMOD NAME=SRVFISUB,DATES='1987, 1990'
*---------------------------------------------------------------------*
*
*  Copyright (c) 1987 Clemson University
*
*  Program     SRVFISUB
*
*  Abstract    This server is the batch job submit file handler.  It
*              recognizes filename *SUBMIT* and only supports writing
*              to the file.  Writing to file *SUBMIT* causes the lines
*              written to be submitted to the system as a batch job.
*
*  Special     The JES2 internal reader interface used by this program
*  Note        is pretty obscure. It is a sanctioned interface, though
*              and is documented in manual GG22-9207 "JES2 Internal
*              Reader Processing".
*
*  Parameters:
*    Two parameters, FileID and FunctionCode, are required for each
*    call to the file manager.  Additional parameters are required for
*    different FunctionCodes.  The entire parameter list required for
*    each function is listed below.
*
*    START
*     CALLX SRVFISUB,(FileID,&START,ESV,Info,FileName,Length,Options)
*
*    TERMINATE
*     CALLX SRVFISUB,(FileID,&TERMINATE)
*
*    WRITELINE
*     CALLX SRVFISUB,(FileID,&FI_WRITELINE,Line,Length)
*
*    GET_INFO
*     CALLX SRVFISUB,(FileID,&FI_GET_INFO,InfoCode,**Info Dependent**)
*                                       &FI_GI_NAME,Area,Size,NameLen)
*                                       &FI_GI_MSG,Area,Size,MsgLen)
*                                       &FI_GI_LRECL,Lrecl)
*                                       &FI_GI_RECFM,Recfm)
*                                       &FI_GI_IDSTRING,IdString)
*    SET_STATUS
*     CALLX SRVFISUB,(FileID,&FI_SET_STATUS,Status,
*                     **Status Dependent**)
*
*  The meaning of each parameter is explained below.
*
*    FileID is a fullword used to uniquely identify the opened file.
*      It is initialized during the startup function.
*
*    FunctionCode is a fullword integer that specifies the function to
*      be performed.  Symbolic identifiers are provided for each
*      function and may be accessed by placing a COPY statement for
*      SRVFIMAC in the assembler program.  These symbols should be used
*      in place of actual integer values.  The following FunctionCodes
*      are supported:
*
*      &START
*        Open a jobstream file and assign to it a unique identifier:
*        FileID.  In addition to the FileID and FunctionCode
*        parameters, the parameters ESV, FileName, and NameLength are
*        required. The parameter Info is ignored, but its position in
*        the parameter list must be maintained.
*
*
*      &TERMINATE
*        Close the file and set FileID to zeros.
*
*      &FI_WRITELINE
*        Append a new line to the jobstream being written to the
*        system for batch execution.  Each line recieved by this
*        function is sent directly to the system, so the only way to
*        keep anything from being actually run is to write a /*PURGE
*        line.  If there are multiple JOB cards in the jobstream, each
*        one must have a /*PURGE card before the next one is processed
*        or it will be run anyways.
*
*      &FI_GET_INFO
*        Return information, selected by InfoCode, about the file.  The
*        following InfoCodes are supported:
*
*        &FI_GI_MSG
*          Return the most-recently generated message in Area.  If the
*          message is longer than Size, it will be truncated and no
*          indication will be returned.  The size of the returned
*          message (or Size, whichever is smaller) will be returned in
*          the MsgLen parameter.
*
*
*        &FI_GI_NAME
*          Return the fully qualified data set name, including member
*          name if the file is a PDS member.  The name will be returned
*          in Area, and will be truncated to Size if neccessary.  The
*          length of the file's name (or Size, whichever is smaller)
*          will be returned in the NameLen parameter.  If truncation
*          occurs, a message will be generated.
*
*        &FI_GI_LRECL
*          Return the logical record length of the file as a signed
*          halfword value in parameter Lrecl.
*
*        &FI_GI_RECFM
*          Return an eight (8) byte character string describing the
*          file's record format.  Currently, only the first character
*          is used: it is 'F' for fixed length records and 'V' for
*          varying length records.  All remaining characters are set to
*          blanks.
*
*        &FI_GI_IDSTRING
*          Return an eight (8) byte character string that can be used
*          for identification purposes.  This string is not unique.
*          For PDS members, IdString is the member name.  For
*          sequential data sets, it is currently set to blanks.
*
*  Program     reentrant, problem key and state, standard linkage,
*  Attributes  non-authorized, amode(any), rmode(any)
*
*  Change
*  History     06/23/89 MJM - NEW
*              04/23/90 MJM - Fixed a bug where the PWA never got   @C1
*                             freed on session termination.  SMCTRL @C1
*                             FREEPWA=YES was coded after the call  @C1
*                             to subroutine TERMINATE, which always @C1
*                             exits through the error exit.  Thus,  @C1
*                             the PWA was never marked for release. @C1
*                             I moved the SMCTRL instruction above  @C1
*                             the call to TERMINATE to fix this.    @C1
*              08/13/90 MJM - Added Dynamic allocation ERROR and    @C2
*                             INFO codes to message FS00004S.       @C2
*              06/01/06 MJM - Added DROPs for ESV addressing in
*                             error exits to resolve assembly errors.
*
*---------------------------------------------------------------------*
 EJECT
 COPY  SMSYMS         | Obtain Structured Macros symbols.
 COPY  SRVESMAC       | Obtain Environment Support symbols & macros.
 COPY  SRVFIMAC       | Obtain File Handler symbols & macros.
 COPY  SRVSTMAC       | Obtain String Handler symbols & macros.
*---------------------------------------------------------------------*
*
*  Macro:      TRIM
*  Purpose:    Set R15 := the length of a string with trailing blanks
*              removed.
*
*---------------------------------------------------------------------*
         MACRO
         TRIM &ADDR,&LEN
         LA   R14,&ADDR             | R14 -> Start of string.
         L    R15,&LEN              | R15 := Length of string.
         ALR  R15,R14               | R15 -> Past end of string.
         LOOP UNTIL                 | Loop backwards over string.
           BCTR R15,0               |   Back up by one character.
         ENDLOOP UNTIL,((CR,R15,LT,R14),OR,(CLI,0(R15),NE,C' '))
         LA      R15,1(,R15)        | R15 -> Past final non-blank.
         SLR     R15,R14            | R15 := trimmed length.
         MEND
*---------------------------------------------------------------------*
*
*  Macro:      MESSAGE (condition),(parameters)
*              MESSAGE (parameters)
*  Purpose:    Conditionally invoke the message subroutine.
*
*---------------------------------------------------------------------*
         MACRO
         MESSAGE
         AIF   (N'&SYSLIST EQ 1).CALL
         AIF   (N'&SYSLIST EQ 2).COND
         MNOTE 8,'WRONG NUMBER OF PARMS'
.CALL    CALLSUB MESSAGE,&SYSLIST(1)
         MEXIT
.COND    IF   &SYSLIST(1)
           CALLSUB MESSAGE,&SYSLIST(2)
         ENDIF
         MEND
 EJECT
***********************************************************************
**                                                                   **
**                                                                   **
**                         SRVFISUB Main Program                     **
**                                                                   **
**                                                                   **
***********************************************************************
 BLOCK NAME=SRVFISUB,TYPE=PROGRAM,AMODE=ANY,RMODE=24,R1SAVE=R9,        +
               CPYRGHT='COPYRIGHT (C) 1987 CLEMSON UNIVERSITY',        +
               OPTIONS=(*SRVPRC,LONG),SUBOPTS=(*SWA,LOADBASE)
*---------------------------------------------------------------------*
*  Establish addressability on data areas and validate the environment.
*---------------------------------------------------------------------*
   ST      R9,PWA_PARMLIST            | Save ParmList address in PWA.
   USING   FI_PARMLIST,R9             | Establish addressability.
   L       R8,PWAAESV                 | R8 -> Env Support Vector.
   USING   ESV,R8                     | Establish addressability.
   MVC     GDIRC,=H'0'                | Clear out return-code.
   CALLSUB CHECK_PARMS                | Check parms and environment.
*---------------------------------------------------------------------*
*  Use the FunctionCode to determine which subroutine to invoke.
*---------------------------------------------------------------------*
   L       R1,FI_FUNCTIONCODE         | R1 -> function code.
   L       R1,0(R1)                   | R1 := function code.
   CASEBLK REG=R1,MULT=1              | Case on FunctionCode.
     CASE &FI_START                   |   Open a new file.
       CALLSUB START                  |
     CASE &FI_TERMINATE               |   Close a file.
       SMCTRL  FREEPWA=YES            |     Release the PWA on exit @C1
       CALLSUB TERMINATE              |     Kill file and buffers.  @C1
     CASE &FI_WRITELINE               |   Write a line to end of file.
       CALLSUB WRITELINE              |
     CASE &FI_GET_INFO                |   Obtain information.
       CALLSUB GET_INFO               |
     CASE &FI_SET_STATUS              |   Set file status.
       CALLSUB SET_STATUS             |
     CASE OTHER                       |   Invalid function code.
       MESSAGE (FS00001,0(R2))        |
   ENDCASE                            | EndCase.
*                                     |
   LH   R15,GDIRC                     |
   DROP R8
 ENDBLK BLOCK=SRVFISUB                | Quit w/possible return code.
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: CHECK_PARMS                                            *
*  ABSTRACT:   Check parameters and calling environment.              *
*                                                                     *
***********************************************************************
 BLOCK NAME=CHECK_PARMS,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  Count the number of parameters passed in and save in PWA_#PARMS
*---------------------------------------------------------------------*
   LA   R1,FI_PARMLIST                | R1 -> first parameter.
   LOOP WHILE,(TBIT,0(R1),X'80',OFF)  | Loop over parameters.
     LA R1,4(,R1)                     |   Advance to next parameter.
   ENDLOOP WHILE                      | EndLoop.
   LA  R1,4(,R1)                      | Point past final parameter.
   SLR R1,R9                          | Get length of entire parmlist.
   SRL R1,2                           | Get number of parameters.
   ST  R1,PWA_#PARMS                  | Save in PWA for future use.
*---------------------------------------------------------------------*
*  If the function code is something other than start, check the
*  eye-catcher string and FileID.  If bad, the FileID is garbage.
*---------------------------------------------------------------------*
   L  R2,FI_FUNCTIONCODE              | R2 -> Fullword function code.
   L  R2,0(R2)                        | R2 := Fullword function code.
   IF (C,R2,NE,=F'&FI_START')         | If not startup function then.
     ERREXIT (CLC,PWA_VISUAL,NE,EYECATCHER),CODE=&FI_INVALID_FILEID
     ERREXIT (C,R13,NE,PWA_FILEID),CODE=&FI_INVALID_FILEID
     IF (TBIT,PWA_F,PWA_F_IN_ERROR)
       CASEBLK REG=R2,WREG=R2,MULT=1  |   Case on FunctionCode.
       CASE &FI_TERMINATE,&FI_GET_INFO      These are always ok.
       CASE OTHER                     |     Cannot do other functions.
         MESSAGE (FS00011)            |     Halted by previous error.
       ENDCASE                        |   EndCase.
     ENDIF                            |   Endif.
   ENDIF                              | Endif.
 ENDBLK BLOCK=CHECK_PARMS
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: START                                                  *
*  ABSTRACT:   Open a file for the type of access requested. Since    *
*              only OUTPUT_SEQUENTIAL is supported, insure that it    *
*              is what was requested.                                 *
*                                                                     *
***********************************************************************
 BLOCK NAME=START,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  Insure that all parameters were specified, and initialize PWA.
*---------------------------------------------------------------------*
   MVC     PWA_VISUAL,EYECATCHER      | Both the eyecatcher and the
   ST      R13,PWA_FILEID             | fileid are validity checks.
   MVI     PWA_F,X'00'                | Clear out state flags.
   MESSAGE (CLC,PWA_#PARMS,LT,=F'7'),(FS00002,'START',5)
*---------------------------------------------------------------------*
*  Process the OPTIONS parameter.
*---------------------------------------------------------------------*
*
*  Make sure that all reserved OPTIONS flags are zeros.
*
   L  R2,FI_OPTIONS                      | R2 -> options parameter.
   IF (TBIT,0(R2),&FI_OC_RESERVED,ANY)   | If any reserved options.
     MESSAGE (FS00014,(R2))              |   Issue an error message.
   ENDIF                                 | EndIf.
*
*  Separate the remaining flags to make checking for specific values
*  and combinations of values easier.
*
   MVC   &PWA.MODE,0(R2)                 | Save INPUT/OUTPUT flag.
   NI    &PWA.MODE,&FI_OC_MODE           | Mask off other bits.
   IF (CLI,&PWA.MODE,NE,&FI_OC_OUTPUT)   | If not OUTPUT mode.
     MESSAGE (FS00013)                   |   Issue an error message.
   ENDIF                                 | EndIf.
*---------------------------------------------------------------------*
*  Parse the file specification and open the file.
*---------------------------------------------------------------------*
   CALLSUB PARSE_FILESPEC              | Scan file-specification.
   CALLSUB OPEN_FILE                   | Open the specified file.
 ENDBLK BLOCK=START
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: PARSE_FILESPEC                                         *
*  ABSTRACT:   Parse the file-specification of the START function.    *
*                                                                     *
***********************************************************************
 BLOCK NAME=PARSE_FILESPEC,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  R4 -> file-specification.  R5 -> last character in file-spec.
*---------------------------------------------------------------------*
   L       R4,FI_FILENAME             | R4 -> file-spec's text.
   L       R5,FI_NAMELENGTH           | R5 -> length of file-spec.
   L       R5,0(,R5)                  | R5 := length of file-spec.
   LA      R0,=C'*SUBMIT*'            | R0 -> Only filespec allowed.
   LA      R1,8                       | R1 := length of '*SUBMIT*'.
   ICM     R1,B'1000',=C' '           | Pad comparison w/blanks.
   IF      (CLCL,R4,NE,R0)            | If not *SUBMIT* then.
     L       R4,FI_FILENAME           |   R4 -> file-spec's text.
     L       R5,FI_NAMELENGTH         |   R5 -> length of file-spec.
     MESSAGE (FS00100,0(R4),0(R5))    |   Issue syntax-error message.
   ENDIF                              | EndIf.
 ENDBLK BLOCK=PARSE_FILESPEC
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: OPEN_FILE                                              *
*  ABSTRACT:   Set up for writing a jobstream to the system.          *
*                                                                     *
***********************************************************************
 BLOCK NAME=OPEN_FILE,TYPE=SUBROUTINE,AMODE=31,OPTIONS=CODEBASE
*---------------------------------------------------------------------*
*  Dynamically allocate an internal reader.
*---------------------------------------------------------------------*
   LA    R6,O_DDNAME                | R6 -> DDNAME Text Unit.
   USING S99TUNIT,R6                | Establish addressability.
   MVC   S99TUKEY,=AL2(DALRTDDN)    |   Set return-ddname action key.
   MVC   S99TUNUM,=H'1'             |   Set number of parameters = 1.
   MVC   S99TULNG,=H'8'             |   Set length of return-area.
*                                   |
   LA    R7,O_RB                    | R7 -> Dynalloc request block.
   USING S99RB,R7                   | Establish addressability.
   FILL  O_RB,X'00'                 |   Clear request block to zeros.
   MVI   S99RBLN,S99RBEND-S99RB     |   Set request block's length.
   MVI   S99VERB,S99VRBAL           |   Set verb to 'allocate'.
   PLIST (O_CLASS,O_PROGRAM,O_FREE,O_DDNAME),VL,PL=O_TXTPTRS
   ST    R1,S99TXTPP                |   Set address of text unit plist.
*                                   |
   PLIST (O_RB),VL                  | R1 -> Request Block plist.
   DYNALLOC                         | Invoke the DYNALLOC SVC.
*                                   |
   IF (TREG,R15,Z),THEN             | If dynamic allocation succeeded.
     SBIT   PWA_F_ALLOCATED         |   Set allocated flag.
     FILL   PWA_DDNAME,C' '         |   Blank out DDNAME in the PWA.
     L16    R15,S99TULNG            |   R15 := length of DDNAME.
     IF     NZ,THEN                 |   If a non-null DDNAME.
       BCTR R15,0                   |     Subtract 1 for EX instr.
       EXI  R15,(MVC,PWA_DDNAME(0),S99TUPAR)  Copy DDNAME to the PWA.
     ENDIF                          |   EndIf.
   ELSE                             | Else, check error/reason codes.
     MVC PWA_S99ERROR,S99ERROR      | Remember the dynalloc error code.
     IF  (CLC,S99ERROR,EQ,=X'0204') | If Storage not available.
       CALLSUB MESSAGE,(FS00009)    |   Issue specific message.
     ELSEIF (CLC,S99ERROR,EQ,=X'0214') ElseIf No internal reader avail.
       CALLSUB MESSAGE,(FS00003)    |   Issue specific message.
     ELSEIF (CLC,S99ERROR,EQ,=X'0238') ElseIf TIOT is full.
       CALLSUB MESSAGE,(FS00020)    |   Issue specific message.
     ELSEIF (CLC,S99ERROR,EQ,=X'0470') ElseIf NOJCL userid.
       CALLSUB MESSAGE,(FS00019)    |   Issue specific message.
     ELSE                           | Else.
       CALLSUB MESSAGE,(FS00004,S99ERROR,S99INFO) Generic message.  @C2
     ENDIF                          | EndIf.
     DROP    R6,R7                  | Drop O_RB and Text Unit.
   ENDIF                            | EndIf.
*---------------------------------------------------------------------*
* Build an Access Control Block (ACB).
*---------------------------------------------------------------------*
   BLOCK AMODE=24,TYPE=INLINE       | Switch to amode 24.
     GENCB  BLK=ACB,DDNAME=(*,PWA_DDNAME),MF=(G,PWA_ACBPL,PWA_ACBPL_L),+
               MACRF=(ADR,SEQ,OUT),WAREA=(S,PWA_ACB),LENGTH=PWA_ACB_L
     ST     R15,PWA_RC              |  Save return-code.
   ENDBLK                           | Switch back to amode 31.
*                                   |
   IF (CLC,PWA_RC,NE,=F'0')         | If ACB generation failed, then.
     CALLSUB MESSAGE,(FS00005,PWA_RC)   Issue an error message.
   ELSE                             | Else.
     SBIT    PWA_F_ACB              |   Mark ACB as valid.
   ENDIF                            | EndIf.
*---------------------------------------------------------------------*
* Open the internal reader.
*---------------------------------------------------------------------*
   PLIST  (PWA_ACB),VL              | R1 -> 1 entry paramter list.
   BLOCK AMODE=24,TYPE=INLINE       | Switch to amode 24.
     OPEN   MF=(E,(1))              |   Open the internal reader.
     ST     R15,PWA_RC              |   Save return-code.
   ENDBLK                           | Switch back to amode 31.
*                                   |
   IF (CLC,PWA_RC,NE,=F'0')         | If OPEN failed, then.
     ST      R15,PWA_RC             |   Save bad return-code.
     CALLSUB MESSAGE,(FS00006,PWA_RC)   Issue an error message.
   ELSE                             | Else.
     SBIT    PWA_F_OPENED           |   Mark file as OPEN.
   ENDIF                            | EndIf.
*---------------------------------------------------------------------*
* Build the Request Parameter List (RPL).
*---------------------------------------------------------------------*
   BLOCK AMODE=24,TYPE=INLINE       | Switch to amode 24.
     GENCB  BLK=RPL,WAREA=(S,PWA_RPL),LENGTH=PWA_RPL_L,                +
               ACB=(S,PWA_ACB),OPTCD=(ADR,SEQ,SYN,NUP),                +
               AREA=(S,PWA_LINE),RECLEN=L'PWA_LINE,                    +
               MSGAREA=(S,PWA_MSG),MSGLEN=L'PWA_MSG,                   +
               MF=(G,PWA_RPLPL,PWA_RPLPL_L)
     ST     R15,PWA_RC              |   Save return-code.
   ENDBLK                           | Switch back to amode 31.
*                                   |
   IF (CLC,PWA_RC,NE,=F'0')         | If RPL generation failed, then.
     CALLSUB MESSAGE,(FS00008,PWA_RC)   Issue an error message.
   ELSE                             | Else.
     SBIT    PWA_F_RPL              |   Mark RPL as valid.
   ENDIF                            | EndIf.
*                                   |
   MVC  PWA_RELATIVE_JOB#,=F'1'     | Processing first JOB in stream.
   MVC  PWA_JOBID,=CL8'*NULL*'      | No job identifier assigned.
 ENDBLK BLOCK=OPEN_FILE
*---------------------------------------------------------------------*
*  Static data for opening a new jobstream file.
*---------------------------------------------------------------------*
             SSD
O_CLASS      DC   AL2(DALSYSOU,1,1),C'A'        | SYSOUT=(A,...
O_PROGRAM    DC   AL2(DALSPGNM,1,6),C'INTRDR'   |        ...INTRDR)
O_FREE       DC   AL2(DALCLOSE,0)               | FREE=CLOSE
             ENDSSD
*---------------------------------------------------------------------*
*  Working Storage for opening a new jobstream file.
*---------------------------------------------------------------------*
             SWA
O_RB         DS  CL(S99RBEND-S99RB)  | Dynalloc request block.
O_TXTPTRS    DS  CL(4*4)             | Parmlist for Text Unit Pointers.
O_DDNAME     DS  CL14                | TextUnit for returned DDNAME.
             ENDSWA
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: WRITELINE                                              *
*  ABSTRACT:   Write the next line to the opened jobstream.           *
*                                                                     *
***********************************************************************
 BLOCK NAME=WRITELINE,TYPE=SUBROUTINE,AMODE=31
*---------------------------------------------------------------------*
*  Validate the current file status and the parameter list.
*---------------------------------------------------------------------*
   IF (TBIT,PWA_F_OPENED,OFF)       | If file is not opened.
     MESSAGE (FS00012,'WRITELINE',9)    Issue an error message.
   ELSEIF (TBIT,PWA_F_RPL,OFF)      | ElseIf RPL not built.
     MESSAGE (FS00012,'WRITELINE',9)    Issue an error message.
   ELSEIF (CLI,&PWA.MODE,NE,&FI_OC_OUTPUT)
     MESSAGE (FS00013)
   ENDIF                            | EndIf.
*                                   |
   SBIT PWA_F_IN_PROGRESS           | A non-ended job is in progress.
   MVC  PWA_JOBID,=CL8'*NULL*'      | No job identifier assigned.
*---------------------------------------------------------------------*
*  Copy the output line to the RPL line-buffer.
*---------------------------------------------------------------------*
   LM   R0,R1,FI_WL_LINE            | R0 -> Text, R1 -> length.
   L    R1,0(,R1)                   | R1 := length.
   LA   R14,PWA_LINE                | R14 -> Output line area.
   LA   R15,L'PWA_LINE              | R15 := Length of area.
   ICM  R1,B'1000',=C' '            | Pad copy with blanks.
   RBIT PWA_F_TRUNCATED             | Nothing truncated yet.
   MVCL R14,R0                      | Copy output line to area.
   IF   CC4,THEN                    | If it was truncated, then.
     SBIT    PWA_F_TRUNCATED        |   Remember line truncated.
   ENDIF                            | EndIf.
*---------------------------------------------------------------------*
*  Write the line to the internal reader and, if truncated, issue msg.
*---------------------------------------------------------------------*
   BLOCK AMODE=24,TYPE=INLINE       | Switch to amode 24.
     PUT RPL=PWA_RPL                |   Write the new jobstream line.
     ST  R15,PWA_RC                 |   Save return code.
   ENDBLK                           | Switch back to amode 31.
*                                   |
   IF (CLC,PWA_RC,NE,=F'0')         | If write failed, then.
     ST      R15,PWA_RC             |   Save bad return code.
     CALLSUB MESSAGE,(FS00017,PWA_RC)   Issue an error message.
   ENDIF                            | EndIf.
*                                   |
   IF (TBIT,PWA_F_TRUNCATED)        | If line was truncated, then.
     CALLSUB MESSAGE,(FS00201,80)   |   Issue a warning message.
   ENDIF                            | EndIf.
 ENDBLK BLOCK=WRITELINE
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: SET_STATUS                                             *
*  ABSTRACT:   Set some item of the file's status.                    *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=SET_STATUS
   L       R2,FI_SS_FUNCTION         | R2 -> Status code to set.
   L       R1,0(,R2)                 | R1 := Status code.
   CASEBLK REG=R1,MULT=1             | Case on status code.
     CASE &FI_SS_END_OF_FILE         |   Set end-of-file status.
       CALLSUB ISSUE_ENDREQ          |     Tell JES about it.
       IF (CLC,PWA_JOBID,NE,=CL8'*NULL*')  If a job submitted.
         CALLSUB MESSAGE,(FS00200,PWA_JOBID) Issue submitted message.
       ENDIF                         |     EndIf.
     CASE OTHER                      |   Invalid status sub-code.
       CALLSUB MESSAGE,(FS00018,0(R2))     Issue an error message.
   ENDCASE                           | EndCase
 ENDBLK BLOCK=SET_STATUS
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: ISSUE_ENDREQ                                           *
*  ABSTRACT:   Write the current line to the internal reader.         *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=ISSUE_ENDREQ,AMODE=31
*---------------------------------------------------------------------*
*  Issue an ENDREQ to signify to JES that this is the end of the job.
*---------------------------------------------------------------------*
   LA     R7,PWA_RPL                 | R7 -> Request Parameter List.
   USING  IFGRPL,R7                  | Establish addressability.
*                                    |
   BLOCK  AMODE=24,TYPE=INLINE       | Switch to amode 24.
     ENDREQ RPL=(7)                  |   Tell JES this is end-of-job.
     ST     R15,PWA_RC               |   Save return code.
   ENDBLK                            | Switch back to amode 31.
*                                    |
   RBIT PWA_F_IN_PROGRESS            | No jobs currently in progress.
   MVC  PWA_JOBID,RPLRBAR            | Copy system-assigned jobid.
*                                    |
   L    R1,PWA_RELATIVE_JOB#         | R1 := number of jobs submitted.
   A    R1,=F'1'                     | Increment.
   ST   R1,PWA_RELATIVE_JOB#         | Save back in the PWA.
 ENDBLK BLOCK=ISSUE_ENDREQ
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: TERMINATE                                              *
*  ABSTRACT:   Close out and cleanup any/all files.                   *
*                                                                     *
***********************************************************************
 BLOCK NAME=TERMINATE,TYPE=SUBROUTINE,AMODE=31
   LEAVE   BLOCK=*,(NOT,(TBIT,PWA_F_OPENED))  | Leave if nothing to do.
   IF      (TBIT,PWA_F_IN_PROGRESS)           | If non-ended job, then.
     CALLSUB ISSUE_ENDREQ                     |   End the job.
   ENDIF                                      | EndIf.
*---------------------------------------------------------------------*
*  Close the internal reader, freeing it in the process.
*---------------------------------------------------------------------*
   PLIST  (PWA_ACB),VL               | R1 -> 1 entry paramter list.
   BLOCK  AMODE=24,TYPE=INLINE       | Switch to amode 24.
     CLOSE  MF=(E,(1))               |   Close internal reader.
     ST     R15,PWA_RC               |   Save return code.
   ENDBLK                            | Switch back to amode 31.
   RBIT   PWA_F_OPENED               | Indicate it is now closed.
*                                    |
   IF (CLC,PWA_JOBID,NE,=CL8'*NULL*')  If a job submitted.
     CALLSUB MESSAGE,(FS00200,PWA_JOBID) Issue submitted message.
   ENDIF                             | EndIf.
 ENDBLK BLOCK=TERMINATE
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: GET_INFO                                               *
*  ABSTRACT:   Return selected information to the caller.             *
*                                                                     *
***********************************************************************
 BLOCK NAME=GET_INFO,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  Make sure that the information sub-code parameter was supplied.
*---------------------------------------------------------------------*
   IF (CLC,PWA_#PARMS,LT,=F'3')       | If no function sub-code.
     CALLSUB MESSAGE,(FS00002,'GET_INFO',8)
     LEAVE   BLOCK=*                  |   Should never get here.
   ENDIF                              | EndIf.
*---------------------------------------------------------------------*
*  Call the routine that obtains the requested information.
*---------------------------------------------------------------------*
   L       R2,FI_GI_FUNCTION          | R2 -> information sub-code.
   L       R1,0(,R2)                  | R1 := information sub-code.
   CASEBLK REG=R1,WREG=R1,MULT=1      | Case on information sub-code.
     CASE &FI_GI_MSG                  |   Get last message issued.
       CALLSUB GET_INFO_MSG           |
     CASE &FI_GI_NAME                 |   Get file's full name.
       CALLSUB GET_INFO_NAME          |
     CASE &FI_GI_LRECL                |   Get logical record length.
       CALLSUB GET_INFO_LRECL         |
     CASE &FI_GI_RECFM                |   Get record format.
       CALLSUB GET_INFO_RECFM         |
     CASE &FI_GI_IDSTRING             |   Get identification string.
       CALLSUB GET_INFO_IDSTRING      |
     CASE OTHER                       |   Invalid information code.
       MESSAGE (FS00015,0(R2))        |
   ENDCASE                            | EndCase
 ENDBLK BLOCK=GET_INFO                |
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: GET_INFO_MSG                                           *
*  ABSTRACT:   Return the current message to the caller.              *
*                                                                     *
***********************************************************************
 BLOCK NAME=GET_INFO_MSG,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  Check the number of parameters. There must be exactly 6 parms.
*---------------------------------------------------------------------*
   IF (CLC,PWA_#PARMS,NE,=F'6')         | If not exactly 6 parameters.
     CALLSUB MESSAGE,(FS00002,'GET_INFO (MSG)',14)
     LEAVE   BLOCK=*                    |   Should never get here.
   ENDIF                                | EndIf.
*---------------------------------------------------------------------*
*  Copy the formatted message to the user's buffer.
*---------------------------------------------------------------------*
   LM   R2,R3,FI_GI_AREA            | R2/R3 -> text area, length.
   L    R3,0(R3)                    | R3 := length of text area.
   LM   R4,R5,PWA_MSG_DATA          | R4/R5 -> message text/length.
   L    R5,0(R5)                    | R5 := length of message.
   IF   (CR,R5,GT,R3)               | If too long to fit in area.
     LR R5,R3                       |   Reduce to exact length.
   ENDIF                            | EndIf.
   L    R1,FI_GI_LENGTH             | R1 -> message length parm.
   ST   R5,0(R1)                    | Save length of returned msg.
   ICM  R5,8,=C' '                  | Pad copied text with blanks.
   MVCL R2,R4                       | Copy information to caller.
 ENDBLK BLOCK=GET_INFO_MSG
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: GET_INFO_NAME                                          *
*  ABSTRACT:   Return the file's name to the caller.                  *
*                                                                     *
***********************************************************************
 BLOCK NAME=GET_INFO_NAME,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  Check the number of parameters. There must be exactly 6 parms.
*---------------------------------------------------------------------*
   IF (CLC,PWA_#PARMS,NE,=F'6')         | If not exactly 6 parameters.
     CALLSUB MESSAGE,(FS00002,'GET_INFO (NAME)',15)
     LEAVE   BLOCK=*                    |   Should never get here.
   ENDIF                                | EndIf.
*---------------------------------------------------------------------*
*  Return the filename '*SUBMIT*'.
*---------------------------------------------------------------------*
   LM   R2,R3,FI_GI_AREA                | R2/R3 -> text area, length.
   LA   R0,8                            | R0 := length of '*SUBMIT*'.
   LA   R1,=C'*SUBMIT*'                 | R1 -> file name.
   MVCL R2,R0                           | Copy to caller's area.
*                                       |
   IF   CC4,THEN                        | If message got truncated.
     CALLSUB MESSAGE,(FS00007)          |   Issue a message and quit.
   ENDIF                                | EndIf.
 ENDBLK BLOCK=GET_INFO_NAME
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: GET_INFO_LRECL                                         *
*  ABSTRACT:   Return the file's logical record length as a halfword. *
*                                                                     *
***********************************************************************
 BLOCK NAME=GET_INFO_LRECL,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  Check the number of parameters. There must be exactly 4 parms.
*---------------------------------------------------------------------*
   IF (CLC,PWA_#PARMS,NE,=F'4')         | If not exactly 4 parameters.
     CALLSUB MESSAGE,(FS00002,'GET_INFO (LRECL)',16)
     LEAVE   BLOCK=*             |   Should never get here.
   ENDIF                                | EndIf.
*---------------------------------------------------------------------*
*  Return the internal reader's record length: 80.
*---------------------------------------------------------------------*
   IF (TBIT,PWA_F,PWA_F_OPENED,OFF)
     CALLSUB MESSAGE,(FS00012,'GET_INFO (LRECL)',16)
     LEAVE   BLOCK=*                    |   Should never get here.
   ELSE                                 | Else.
     L     R2,FI_GI_AREA                |   R2 -> Halfword for LRECL.
     MVC   0(2,R2),=H'80'               |   Copy LRECL to parameter.
   ENDIF                                | EndIf.
 ENDBLK BLOCK=GET_INFO_LRECL
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: GET_INFO_RECFM                                         *
*  ABSTRACT:   Return the file's record format in an 8-byte field.    *
*                                                                     *
***********************************************************************
 BLOCK NAME=GET_INFO_RECFM,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  Check the number of parameters. There must be exactly 4 parms.
*---------------------------------------------------------------------*
   IF (CLC,PWA_#PARMS,NE,=F'4')         | If not exactly 4 parameters.
     CALLSUB MESSAGE,(FS00002,'GET_INFO (RECFM)',16)
     LEAVE   BLOCK=*                    |   Should never get here.
   ENDIF                                | EndIf.
*---------------------------------------------------------------------*
*  Return a single character indicating the file's record format.
*---------------------------------------------------------------------*
   IF (TBIT,PWA_F,PWA_F_OPENED,OFF)
     CALLSUB MESSAGE,(FS00012,'GET_INFO (RECFM)',16)
     LEAVE   BLOCK=*                    |   Should never get here.
   ELSE                                 | Else.
     L     R2,FI_GI_AREA                |   R2 -> Halfword for LRECL.
     MVC   0(8,R2),PWA_RECFM            |   Copy RECFM to Area.
   ENDIF                                | EndIf.
 ENDBLK BLOCK=GET_INFO_RECFM
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: GET_INFO_IDSTRING                                      *
*  ABSTRACT:   Return the 8-character system-assigned job identifier. *
*                                                                     *
***********************************************************************
 BLOCK NAME=GET_INFO_IDSTRING,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  Check the number of parameters. There must be exactly 4 parms.
*---------------------------------------------------------------------*
   IF (CLC,PWA_#PARMS,NE,=F'4')         | If not exactly 4 parameters.
     CALLSUB MESSAGE,(FS00002,'GET_INFO (IDSTRING)',19)
     LEAVE   BLOCK=*                    |   Should never get here.
   ENDIF                                | EndIf.
*                                       |
   L    R2,FI_GI_AREA                   | R2 -> 8-byte return area.
   MVC  0(8,R2),PWA_JOBID               | Copy job-identifier.
 ENDBLK BLOCK=GET_INFO_IDSTRING
 EJECT
***********************************************************************
*                                                                     *
*  SUBROUTINE: MESSAGE                                                *
*  ABSTRACT:   Format a message and exit the program.                 *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=MESSAGE
   LR   R2,R1                      | R2 -> Parameter list.
   L    R4,0(R2)                   | R4 -> Message's ADCON.
   L    R4,0(R4)                   | R4 -> Message Length, Text.
*---------------------------------------------------------------------*
*  Invoke the string-formatter to put together the message.
*---------------------------------------------------------------------*
   BLOCK TYPE=INLINE,NAME=FORMAT   | Block for formatting message.
    L     R3,PWAAESV               |   R3 -> Env. support vector.
    USING ESV,R3                   |   Establish addressability.
    CALLX ESVESEPA,(ESVESTKN,&ES_LOAD_MODULE,&STRING_HANDLER,PWA_STEPA)
    LEAVE BLOCK=*,(TREG,R15,NZ)    |   If string-handler not loaded.
    CALLX PWA_STEPA,(PWA_STTKN,&START,PWAAESV,4)
    LEAVE BLOCK=*,(TREG,R15,NZ)    |   If string-handler not started.
*                                  |
    PLIST (PWA_STTKN,&ST_FORMAT,PWA_MSG,=A(L'PWA_MSG),                 +
               PWA_MSG_LEN,4(R4),0(R4)),NOVL,PL=PWA_PLIST
*                                  |
    LR    R1,R2                    |   R1 -> parm before 1st arg.
    LA    R14,PWA_PLIST+(4*6)      |   R14 -> parm before 1st arg.
    LA    R15,L'PWA_PLIST+PWA_PLIST    R15 -> last available arg.
    LOOP  WHILE,(TBIT,0(R1),X'80',OFF) While not at last parameter.
      LEAVE LOOP=*,(CR,R14,GE,R15) |     R15 -> last available arg.
      LA    R1,4(,R1)              |     Advance to next parameter.
      LA    R14,4(,R14)            |     Advance to next parameter.
      MVC   0(4,R14),0(R1)         |     Save in plist.
    ENDLOOP WHILE                  |   EndLoop.
    OI    0(R14),X'80'             |   Flag it as last parm.
    CALLX PWA_STEPA,PL=PWA_PLIST   |   Invoke the format function.
    CALLX PWA_STEPA,(PWA_STTKN,&TERMINATE)
    CALLX ESVESEPA,(ESVESTKN,&ES_UNLOAD_MODULE,&STRING_HANDLER,        +
               PWA_STEPA)          |
    DROP  R3                       |   Clean up addressability.
    LA    R15,0                    |   Indicated string was formatted.
   ENDBLK BLOCK=FORMAT             | EndBlk.
*---------------------------------------------------------------------*
*  If the message could not be formatted, use the unformatted version.
*---------------------------------------------------------------------*
   IF (TREG,R15,NZ)                | If formatting failed, then.
     L    R5,0(R4)                 |   R5 := length of message text.
     LA   R1,L'PWA_MSG             |   R1 -> Length of target area.
     IF   (CR,R5,GT,R1)            |   If too long to fit, then.
       LR R5,R1                    |     Use as much as possible.
     ENDIF                         |   EndIf.
     ST   R5,PWA_MSG_LEN           |   Save length of message
     LR   R1,R5                    |   Set target to exact size.
     LA   R4,4(R4)                 |   R4 -> message text.
     LA   R0,PWA_MSG               |   R0 -> Target area of move.
     MVCL R0,R4                    |   Copy message text.
   ENDIF                           | EndIf.
*---------------------------------------------------------------------*
*  Invoke the error exit with the message's return-code.
*---------------------------------------------------------------------*
   IF (CLC,PWA_MSG(8),EQ,=C'FS00200I')  If end-of-job, then.
     ERREXIT CODE=&FI_END_OF_FILE     |   Exit with the warning-code.
   ELSEIF (CLI,PWA_MSG+7,EQ,C'W')     | If a warning message, then.
     ERREXIT CODE=&FI_WARNING         |   Exit with the warning-code.
   ELSEIF (CLI,PWA_MSG+7,EQ,C'E')     | ElseIf an error message, then.
     ERREXIT CODE=&FI_ERROR           |   Exit with the error-code.
   ELSEIF (CLI,PWA_MSG+7,EQ,C'S')     | ElseIf an error message, then.
     ERREXIT CODE=&FI_SEVERE          |   Exit with the severe-code.
   ELSEIF (CLI,PWA_MSG+7,EQ,C'X')     | ElseIf invalid filename.
     MVI     PWA_MSG+7,C'E'           |   Change to 'error' message.
     ERREXIT CODE=&FI_INVALID_SYNTAX  |   Exit with the syntax-code.
   ELSE                               | Else
     ERREXIT CODE=&FI_SEVERE          |   Exit with the error-code.
   ENDIF                              | EndIf.
 ENDBLK BLOCK=MESSAGE
 EJECT
***********************************************************************
*                                                                     *
*  Error exit for all functions in the file handler.                  *
*                                                                     *
***********************************************************************
 BLOCK TYPE=ERREXIT
*---------------------------------------------------------------------*
*  Save module/offset, registers, return-code.
*---------------------------------------------------------------------*
   STM   R0,R15,GDIREGS          | Save registers at time of error.
   SM_LAL R0,SRVFISUB+4          | Point to module identification.
   ST    R0,GDIMODID             | Save in general debug area.
   MVC   GDIRC,0(R14)            | Copy return code.
   SL    R14,=A(SRVFISUB)        | Calculate offset at time of error.
   STH   R14,GDIOFFST            | Save in debug area.
   L     R2,PWAAESV              |
   USING ESV,R2                  |
   CALLX ESVESEPA,(ESVESTKN,&ES_SAVE_DEBUG_INFO,&ES_DEBUG_ID_GDI,GDI)
*---------------------------------------------------------------------*
*  Check the return-code, and save the debugging message accordingly.
*---------------------------------------------------------------------*
   LH    R3,GDIRC                | R3 := return-code.
   CASEBLK REG=R3,MULT=1         | Case on return-code.
     CASE &FI_WARNING,&FI_ERROR,&FI_SEVERE,&FI_INVALID_SYNTAX,         +
               &FI_END_OF_FILE
       LA R4,PWA_MSG             |     R4 -> Formatted message text.
       LA R5,PWA_MSG_LEN         |     R5 -> Length of formatted msg.
     CASE OTHER                  |   Unknown error-code.
       L  R5,FS00000             |     R5 -> Length of message.
       LA R4,4(R5)               |     R4 -> Message text.
   ENDCASE                       | EndCase.
   STM   R4,R5,PWA_MSG_DATA      | Save address/length of message.
*                                |
   CALLX ESVESEPA,(ESVESTKN,&ES_SAVE_DEBUG_INFO,&ES_DEBUG_ID_TEXT,     +
               (R4),(R5))
*---------------------------------------------------------------------*
*  Set the final return-code and exit.
*---------------------------------------------------------------------*
   LH R15,GDIRC                  | R15 := Return-code for this call.
   IF (C,R15,GT,=F'&FI_WARNING') | If greater than a warning.
     SBIT PWA_F_IN_ERROR         |   Set the error flag in the PWA.
   ENDIF                         | EndIf.
   DROP R2
 ENDBLK
 EJECT
*---------------------------------------------------------------------*
*
*  Static Data
*
*---------------------------------------------------------------------*
               PSD
               LTORG
EYECATCHER     DC   C'SRVFISUB' | Value moved to PWA on initialize.
               EJECT
*---------------------------------------------------------------------*
* Messages are made up of a message identifier followed by a control
* string.  The message identifier has the format
*
*   FSnnnnns
*
* where the characters FS always begin a Submit-file Handler's message,
* nnnnn is the unique message number, and s indicates the message's
* severity.
*
* Severity                  Meaning
* --------   ---------------------------------------------
*    I       Informational.
*    W       Warning message.
*    E       An error occurred, but execution can continue.
*    S       Severe error.  Execution cannot continue.
*    X       Filename syntactically invalid.
*    C       Critical error.  Indicates a probable programming error.
*
*---------------------------------------------------------------------*
            MACRO
            MSG   &NUMBER,&SEVERITY,&TEXT
            LCLC  &MSGID,&OLDLOC
&OLDLOC     SETC  '&SYSLOC'
&MSGID      SETC  'FS&NUMBER'
&MSGID      DC    A(MSGT&SYSNDX)
XSMSGS      LOCTR ,
MSGT&SYSNDX DC    AL4(MSGL&SYSNDX)
            DC    C'&MSGID&SEVERITY '
            DC    C&TEXT
MSGL&SYSNDX EQU   *-MSGT&SYSNDX-4
&OLDLOC     LOCTR ,
            MEND
*
 MSG 00000,C,'Unknown error.'
 MSG 00001,C,'Invalid function-code parameter: {I}.'
 MSG 00002,C,'Wrong number of parameters for the {CL?} function.'
 MSG 00003,S,'No internal readers are available at this time.'
 MSG 00004,S,'Unable to allocate to an internal reader: DYNALLOC Error +
               ({XL2},{XL2}).'                                      @C2
 MSG 00005,S,'Unable to build an Access Control Block (ACB) for writing+
                to the internal reader. GENCB RC={I}.'
 MSG 00006,S,'Unable to open the internal reader for output.'
 MSG 00007,S,'File name truncated in GET_NAME function.'
 MSG 00008,S,'Unable to build a Request Parameter List (RPL) for writin+
               g to the internal reader. GENCB RC={I}.'
 MSG 00009,S,'Not enough storage to operate.'
 MSG 00011,C,'Processing halted due to a previous error.'
 MSG 00012,S,'Function {CL?} not performed; file is not open.'
 MSG 00013,C,'Sequential input not supported by SRVFISUB.'
 MSG 00014,C,'Unsupported file access mode: {I}.'
 MSG 00015,C,'Invalid information code ({I}) for the GET_INFO function.+
               '
 MSG 00016,S,'Function {CL?} not performed; file is not open.'
 MSG 00017,S,'Error while writing to internal reader. PUT RC={I}.'
 MSG 00018,C,'Invalid information code ({I}) for the SET_STATUS functio+
               n.'
 MSG 00019,S,'Not authorized to submit batch jobs.'
 MSG 00020,S,'Dynamic allocation limit exceeded: free one or more files.
               '
*
 MSG 00100,X,'File name "{CL?}" not supported by the Submit file handle+
               r; specify as "*SUBMIT*".'
 MSG 00200,I,'{CL8 T} submitted.'
 MSG 00201,W,'Output record was truncated to {I} characters.'
*
            ENDPSD
            EJECT
***********************************************************************
*                                                                     *
*  Program Work Area                                                  *
*                                                                     *
***********************************************************************
                     PWA
PWA_VISUAL           DS  CL(L'EYECATCHER)
PWA_FILEID           DS  A           | Unique file identifier.
PWA_#PARMS           DS  F           | Number of parms passed in.
PWA_PARMLIST         DS  A           | Address of parameter list.
PWA_RC               DS  F           | Return code from external fcns.
PWA_S99ERROR         DS  H           | Dynalloc's error-code.
*                                    |
&PWA.MODE            DS  X           | Access mode: INPUT/OUTPUT.
PWA_DDNAME           DS  CL8         | DDNAME of internal reader.
PWA_JOBID            DS  CL8         | Job identifier.
PWA_RELATIVE_JOB#    DS  F           | Relative JOB within jobstream.
*                                    |
PWA_STEPA            DS  A           | String-handler's entry-point.
PWA_STTKN            DS  F           | String-handler's token.
PWA_F                DS  X           | State information.
PWA_F_ALLOCATED      EQU B'10000000' |   Internal reader allocated.
PWA_F_ACB            EQU B'01000000' |   Internale reader allocated.
PWA_F_OPENED         EQU B'00100000' |   File successfully opened.
PWA_F_RPL            EQU B'00010000' |   Internale reader allocated.
PWA_F_IN_ERROR       EQU B'00001000' |   Halted due to an error.
PWA_F_TRUNCATED      EQU B'00000100' |   Output line truncated.
PWA_F_IN_PROGRESS    EQU B'00000010' |   Jobstream not ENDREQed yet.
*                                    |
PWA_ACB              ACB ,           |   Access Control Block.
PWA_ACB_L            EQU *-PWA_ACB   |   Length of access control block
                     DS  0F          |   Align to a fullword boundary.
PWA_ACBPL            DS  CL(PWA_ACBPL_L) Used by GENCB BLK=ACB.
*                                    |
PWA_RPL              RPL AM=VSAM     |   Request Parameter Block.
PWA_RPL_L            EQU *-PWA_RPL   |   Length of request parm block.
                     DS  0F          |   Align to a fullword boundary.
PWA_RPLPL            DS  CL(PWA_RPLPL_L) Used by GENCB BLK=RPL.
*                                    |
PWA_LINE#            DS  F           | Current line number.
PWA_LINE_LEN         DS  F           | Length of current input line.
PWA_LINE             DS  CL80        | Text of output line.
PWA_LRECL            DS  H           | Logical record length.
PWA_RECFM            DS  CL8         | Record format: 'F' or 'V'.
*                                    | Error tracking information.
PWA_PLIST            DS  CL(4*17)    |   Parameter list area.
PWA_REF              DS  F           |   Latest return/reason code.
PWA_MSG_DATA         DS  2F          |   Address/length of message.
PWA_MSG_LEN          DS  F           |   Short description of error.
PWA_MSG              DS  CL256       |   Error, Warning, or Info.
                     ES_GDI DSECT=NO |   Debugging area.
                     ENDPWA
                     EJECT
***********************************************************************
*  Parameter list for the File Handler.
***********************************************************************
           FI_PARMLIST         | File Handler parameter list.
           EJECT
           ES_ESV
           IEFZB4D0       ,    | Dynamic allocation (SVC99) data areas.
           IEFZB4D2       ,    | Dynamic allocation text unit keys.
           IFGRPL    DSECT=YES | Request parameter list mapping.
           END
