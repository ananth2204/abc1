*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
 TITLE 'SRVIMMAC: Item Manager Service Processor Symbols && Macros.'
*---------------------------------------------------------------------*
*
*  Copy File:  SRVIMMAC
*
*  Purpose:    Item Manager service processor symbols and macros.
*
*  Description: See "Service Processors User's Guide and Reference".
*
*  Change
*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution
*
*---------------------------------------------------------------------*
*
***********************************************************************
***********************************************************************
**                                                                   **
**                     Symbol Definitions                            **
**                                                                   **
***********************************************************************
***********************************************************************
 GBLC &ITEM_MANAGER
 GBLA &IM_START,&IM_TERMINATE,&IM_INITIALIZE,&IM_SAVE,&IM_RESET
 GBLA &IM_CREATE_ITEM_TYPE_DESCRIPTOR,&IM_CREATE_GROUP_DESCRIPTOR
 GBLA &IM_CREATE_LINKED_LIST_DESCRIPTOR
 GBLA &IM_CREATE_HASH_TABLE_DESCRIPTOR
 GBLA &IM_CREATE_BINARY_TREE_DESCRIPTOR,&IM_DESTROY
 GBLA &IM_GET_DANGEROUS_ADDRESSES,&IM_CONNECT,&IM_DISCONNECT,&IM_OBTAIN
 GBLA &IM_OBTAIN_BY_KEY
 GBLA &IM_OBTAIN_CURRENT_OF_ITEM_TYPE
 GBLA &IM_OBTAIN_CURRENT_OF_DESCRIPTOR
 GBLA &IM_OBTAIN_FIRST,&IM_OBTAIN_FINAL,&IM_OBTAIN_NEXT
 GBLA &IM_OBTAIN_PRIOR
 GBLA &IM_OBTAIN_OWNER,&IM_FIND,&IM_FIND_FIRST,&IM_FIND_FINAL
 GBLA &IM_FIND_BY_KEY
 GBLA &IM_FIND_CURRENT_OF_ITEM_TYPE
 GBLA &IM_FIND_CURRENT_OF_DESCRIPTOR
 GBLA &IM_FIND_NEXT,&IM_FIND_PRIOR,&IM_FIND_OWNER,&IM_GET,&IM_MODIFY
 GBLA &IM_STORE,&IM_ERASE
 GBLA &IM_SUCCESS
 GBLA &IM_INVALID_NUMBER_OF_PARMS
 GBLA &IM_INVALID_FUNCTION,&IM_FUNCTION_UNSUPPORTED_FOR_CLASS
 GBLA &IM_DIV_START_FAILED,&IM_MEMORY_MANAGER_LOAD_FAILED
 GBLA &IM_MEMORY_MANAGER_START_FAILED,&IM_ITEM_STORAGE_NOT_INITIALIZED
 GBLA &IM_SETUP_ALREADY_COMPLETE,&IM_TOO_LARGE_MAXIMUM_ITEM_TYPES
 GBLA &IM_STORAGE_NOT_AVAILABLE
 GBLA &IM_INTERNAL_ERROR,&IM_INVALID_TOKEN,&IM_DV_OPEN_WINDOW_FAILED
 GBLA &IM_DV_SAVE_FAILED,&IM_DV_RESET_FAILED,&IM_FUNCTION_REQUIRES_DIV
 GBLA &IM_INVALID_ITEM_TYPE_TOKEN,&IM_ITEM_SIZE_REQUIRED,&IM_NO_ROOM
 GBLA &IM_OFFSET_SPECIFIED_WHEN_SIZE_WAS_ZERO,&IM_LENGTH_REQUIRED
 GBLA &IM_INVALID_OFFSET,&IM_NOT_YET_SUPPORTED,&IM_MISSING_PARAMETER
 GBLA &IM_INVALID_ITEM_TYPE,&IM_INVALID_ITEM,&IM_INVALID_SIZE
 GBLA &IM_DESCRIPTION_TOO_LONG,&IM_LENGTH_PARM_ERROR
 GBLA &IM_#_LINKS_PARM_ERROR,&IM_LINKS_OFFSET_PARM_ERROR
 GBLA &IM_ITEM_CHARACTERISTICS_CHANGED,&IM_ITEM_LINKS_CHANGED
 GBLA &IM_INVALID_RETURN_AREA_SIZE,&IM_KEY_LENGTH_PARM_ERROR
 GBLA &IM_KEY_OFFSET_PARM_ERROR,&IM_INVALID_DESCRIPTOR_TOKEN
 GBLA &IM_INVALID_ITEM_TOKEN
 GBLA &IM_CURRENCY_ERROR,&IM_INVALID_LINK_NUMBER
 GBLA &IM_LINK_NOT_NULL,&IM_AT_END
 GBLA &IM_REQUIRES_PRIOR_LINK
 GBLA &IM_REQUIRES_FINAL_LINK
 GBLA &IM_REQUIRES_OWNER_LINK
 GBLA &IM_NOT_FOUND
 GBLA &IM_INVALID_SORT_TECHNIQUE
 GBLA &IM_PRTKN_INVALID
 GBLA &IM_PRTKN_REQUIRED
 GBLA &IM_HEADTKN_INVALID
 GBLA &IM_CURTKN_INVALID
 GBLA &IM_ITEMTYPE_MISMATCH
 GBLA &IM_CLASS_UNCLASSIFIED
 GBLA &IM_CLASS_ITEM_TYPE_DESCRIPTOR,&IM_CLASS_GROUP_DESCRIPTOR
 GBLA &IM_CLASS_FREESPACE,&IM_CLASS_DESCRIPTION
 GBLA &IM_CLASS_LINKED_LIST_DESCRIPTOR,&IM_CLASS_HASH_TABLE_DESCRIPTOR
 GBLA &IM_CLASS_BINARY_TREE_DESCRIPTOR,&IM_ADD_TO_DIRECTORY
 GBLA &IM_REMOVE_FROM_DIRECTORY,&IM_FIND_IN_DIRECTORY
 GBLA &IM_SORT
 GBLA &IM_SFD_TYPE_CHARACTER
 GBLA &IM_SFD_TYPE_CHAR
 GBLA &IM_SFD_TYPE_PACKED
 GBLA &IM_SFD_TYPE_ZONED
 GBLA &IM_SFD_TYPE_FIXED
 GBLA &IM_SFD_TYPE_BIT
 GBLA  &IM_SORT_TECHNIQUE_QUICK_SORT
 GBLA  &IM_SORT_TECHNIQUE_BUBBLE_SORT
*
* Entry point name for the Item Manager.
*
&ITEM_MANAGER                           SETC '''SRVIM   '''
*
* Function codes.
*
&IM_START                               SETA 1
&IM_TERMINATE                           SETA 2
&IM_INITIALIZE                          SETA 3
&IM_SAVE                                SETA 4
&IM_RESET                               SETA 5
&IM_CREATE_ITEM_TYPE_DESCRIPTOR         SETA 6
&IM_CREATE_GROUP_DESCRIPTOR             SETA 7
&IM_CREATE_LINKED_LIST_DESCRIPTOR       SETA 8
&IM_CREATE_HASH_TABLE_DESCRIPTOR        SETA 9
&IM_CREATE_BINARY_TREE_DESCRIPTOR       SETA 10
&IM_DESTROY                             SETA 20
&IM_CONNECT                             SETA 21
&IM_DISCONNECT                          SETA 22
&IM_ERASE                               SETA 23
&IM_GET                                 SETA 24
&IM_GET_DANGEROUS_ADDRESSES             SETA 25
&IM_MODIFY                              SETA 26
&IM_STORE                               SETA 27
&IM_ADD_TO_DIRECTORY                    SETA 28
&IM_REMOVE_FROM_DIRECTORY               SETA 29
&IM_FIND_IN_DIRECTORY                   SETA 30
&IM_SORT                                SETA 31
&IM_FIND                                SETA 50
&IM_FIND_BY_KEY                         SETA 51
&IM_FIND_CURRENT_OF_ITEM_TYPE           SETA 52
&IM_FIND_CURRENT_OF_DESCRIPTOR          SETA 53
&IM_FIND_FIRST                          SETA 54
&IM_FIND_FINAL                          SETA 55
&IM_FIND_NEXT                           SETA 56
&IM_FIND_PRIOR                          SETA 57
&IM_FIND_OWNER                          SETA 58
&IM_OBTAIN                              SETA 70
&IM_OBTAIN_BY_KEY                       SETA 71
&IM_OBTAIN_CURRENT_OF_ITEM_TYPE         SETA 72
&IM_OBTAIN_CURRENT_OF_DESCRIPTOR        SETA 73
&IM_OBTAIN_FIRST                        SETA 74
&IM_OBTAIN_FINAL                        SETA 75
&IM_OBTAIN_NEXT                         SETA 76
&IM_OBTAIN_PRIOR                        SETA 77
&IM_OBTAIN_OWNER                        SETA 78
*
* Return codes.
*
&IM_SUCCESS                             SETA  0
&IM_INVALID_NUMBER_OF_PARMS             SETA  2
&IM_INVALID_FUNCTION                    SETA  3
&IM_FUNCTION_UNSUPPORTED_FOR_CLASS      SETA  4
&IM_DIV_START_FAILED                    SETA  5
&IM_MEMORY_MANAGER_LOAD_FAILED          SETA  6
&IM_MEMORY_MANAGER_START_FAILED         SETA  7
&IM_ITEM_STORAGE_NOT_INITIALIZED        SETA  8
&IM_SETUP_ALREADY_COMPLETE              SETA  9
&IM_INTERNAL_ERROR                      SETA 11
&IM_INVALID_TOKEN                       SETA 12
&IM_STORAGE_NOT_AVAILABLE               SETA 14
&IM_DV_OPEN_WINDOW_FAILED               SETA 15
&IM_DV_SAVE_FAILED                      SETA 16
&IM_DV_RESET_FAILED                     SETA 17
&IM_FUNCTION_REQUIRES_DIV               SETA 18
&IM_INVALID_ITEM_TYPE_TOKEN             SETA 19
&IM_ITEM_SIZE_REQUIRED                  SETA 20
&IM_NO_ROOM                             SETA 21
&IM_OFFSET_SPECIFIED_WHEN_SIZE_WAS_ZERO SETA 22
&IM_LENGTH_REQUIRED                     SETA 23
&IM_INVALID_OFFSET                      SETA 24
&IM_NOT_YET_SUPPORTED                   SETA 25
&IM_MISSING_PARAMETER                   SETA 26
&IM_INVALID_ITEM_TYPE                   SETA 27
&IM_INVALID_ITEM                        SETA 28
&IM_INVALID_SIZE                        SETA 29
&IM_DESCRIPTION_TOO_LONG                SETA 30
&IM_LENGTH_PARM_ERROR                   SETA 31
&IM_#_LINKS_PARM_ERROR                  SETA 32
&IM_LINKS_OFFSET_PARM_ERROR             SETA 33
&IM_ITEM_CHARACTERISTICS_CHANGED        SETA 34
&IM_ITEM_LINKS_CHANGED                  SETA 35
&IM_INVALID_RETURN_AREA_SIZE            SETA 36
&IM_KEY_LENGTH_PARM_ERROR               SETA 37
&IM_KEY_OFFSET_PARM_ERROR               SETA 38
&IM_INVALID_DESCRIPTOR_TOKEN            SETA 39
&IM_INVALID_ITEM_TOKEN                  SETA 40
&IM_CURRENCY_ERROR                      SETA 41
&IM_INVALID_LINK_NUMBER                 SETA 42
&IM_LINK_NOT_NULL                       SETA 43
&IM_AT_END                              SETA 44
&IM_REQUIRES_PRIOR_LINK                 SETA 45
&IM_REQUIRES_FINAL_LINK                 SETA 46
&IM_REQUIRES_OWNER_LINK                 SETA 47
&IM_NOT_FOUND                           SETA 48
&IM_HEAD_NOT_VALID_FOR_THIS_DESCRIPTOR  SETA 49
&IM_INVALID_SFD                         SETA 50
&IM_INVALID_SORT_TECHNIQUE              SETA 51
&IM_PRTKN_INVALID                       SETA 52
&IM_PRTKN_REQUIRED                      SETA 53
&IM_HEADTKN_INVALID                     SETA 54
&IM_CURTKN_INVALID                      SETA 55
&IM_ITEMTYPE_MISMATCH                   SETA 56
    DEFUCOND MACRO=SRV##RC,NAME=IM_SUCCESS
    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_NUMBER_OF_PARMS
    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_FUNCTION
    DEFUCOND MACRO=SRV##RC,NAME=IM_FUNCTION_UNSUPPORTED_FOR_CLASS
    DEFUCOND MACRO=SRV##RC,NAME=IM_DIV_START_FAILED
    DEFUCOND MACRO=SRV##RC,NAME=IM_MEMORY_MANAGER_LOAD_FAILED
    DEFUCOND MACRO=SRV##RC,NAME=IM_MEMORY_MANAGER_START_FAILED
    DEFUCOND MACRO=SRV##RC,NAME=IM_ITEM_STORAGE_NOT_INITIALIZED
    DEFUCOND MACRO=SRV##RC,NAME=IM_SETUP_ALREADY_COMPLETE
    DEFUCOND MACRO=SRV##RC,NAME=IM_INTERNAL_ERROR
    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_TOKEN
    DEFUCOND MACRO=SRV##RC,NAME=IM_STORAGE_NOT_AVAILABLE
    DEFUCOND MACRO=SRV##RC,NAME=IM_DV_OPEN_WINDOW_FAILED
    DEFUCOND MACRO=SRV##RC,NAME=IM_DV_SAVE_FAILED
    DEFUCOND MACRO=SRV##RC,NAME=IM_DV_RESET_FAILED
    DEFUCOND MACRO=SRV##RC,NAME=IM_FUNCTION_REQUIRES_DIV
    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_ITEM_TYPE_TOKEN
    DEFUCOND MACRO=SRV##RC,NAME=IM_ITEM_SIZE_REQUIRED
    DEFUCOND MACRO=SRV##RC,NAME=IM_NO_ROOM
    DEFUCOND MACRO=SRV##RC,NAME=IM_OFFSET_SPECIFIED_WHEN_SIZE_WAS_ZERO
    DEFUCOND MACRO=SRV##RC,NAME=IM_LENGTH_REQUIRED
    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_OFFSET
    DEFUCOND MACRO=SRV##RC,NAME=IM_NOT_YET_SUPPORTED
    DEFUCOND MACRO=SRV##RC,NAME=IM_MISSING_PARAMETER
    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_ITEM_TYPE
    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_ITEM
    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_SIZE
    DEFUCOND MACRO=SRV##RC,NAME=IM_DESCRIPTION_TOO_LONG
    DEFUCOND MACRO=SRV##RC,NAME=IM_LENGTH_PARM_ERROR
    DEFUCOND MACRO=SRV##RC,NAME=IM_#_LINKS_PARM_ERROR
    DEFUCOND MACRO=SRV##RC,NAME=IM_LINKS_OFFSET_PARM_ERROR
    DEFUCOND MACRO=SRV##RC,NAME=IM_ITEM_CHARACTERISTICS_CHANGED
    DEFUCOND MACRO=SRV##RC,NAME=IM_ITEM_LINKS_CHANGED
    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_RETURN_AREA_SIZE
    DEFUCOND MACRO=SRV##RC,NAME=IM_KEY_LENGTH_PARM_ERROR
    DEFUCOND MACRO=SRV##RC,NAME=IM_KEY_OFFSET_PARM_ERROR
    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_DESCRIPTOR_TOKEN
    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_ITEM_TOKEN
    DEFUCOND MACRO=SRV##RC,NAME=IM_CURRENCY_ERROR
    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_LINK_NUMBER
    DEFUCOND MACRO=SRV##RC,NAME=IM_LINK_NOT_NULL
    DEFUCOND MACRO=SRV##RC,NAME=IM_AT_END
    DEFUCOND MACRO=SRV##RC,NAME=IM_REQUIRES_PRIOR_LINK
    DEFUCOND MACRO=SRV##RC,NAME=IM_REQUIRES_FINAL_LINK
    DEFUCOND MACRO=SRV##RC,NAME=IM_REQUIRES_OWNER_LINK
    DEFUCOND MACRO=SRV##RC,NAME=IM_NOT_FOUND
    DEFUCOND MACRO=SRV##RC,NAME=IM_HEAD_NOT_VALID_FOR_THIS_DESCRIPTOR
    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_SFD
    DEFUCOND MACRO=SRV##RC,NAME=IM_INVALID_SORT_TECHNIQUE
    DEFUCOND MACRO=SRV##RC,NAME=IM_PRTKN_INVALID
    DEFUCOND MACRO=SRV##RC,NAME=IM_PRTKN_REQUIRED
    DEFUCOND MACRO=SRV##RC,NAME=IM_HEADTKN_INVALID
    DEFUCOND MACRO=SRV##RC,NAME=IM_CURTKN_INVALID
    DEFUCOND MACRO=SRV##RC,NAME=IM_ITEMTYPE_MISMATCH
*
* Item classes.
*
&IM_CLASS_UNCLASSIFIED                  SETA  0
&IM_CLASS_ITEM_TYPE_DESCRIPTOR          SETA  1
&IM_CLASS_GROUP_DESCRIPTOR              SETA  2
&IM_CLASS_FREESPACE                     SETA  3
&IM_CLASS_DESCRIPTION                   SETA  4
&IM_CLASS_LINKED_LIST_DESCRIPTOR        SETA  5
&IM_CLASS_HASH_TABLE_DESCRIPTOR         SETA  6
&IM_CLASS_BINARY_TREE_DESCRIPTOR        SETA  7
*
* Types in Sort Field Descriptors (SFD).
*
&IM_SFD_TYPE_CHARACTER             SETA 1
&IM_SFD_TYPE_CHAR                  SETA 1
&IM_SFD_TYPE_PACKED                SETA 2
&IM_SFD_TYPE_ZONED                 SETA 3
&IM_SFD_TYPE_FIXED                 SETA 4
&IM_SFD_TYPE_BIT                   SETA 5
*
* Sort techinques.
*
&IM_SORT_TECHNIQUE_QUICK_SORT      SETA 1
&IM_SORT_TECHNIQUE_BUBBLE_SORT     SETA 2
                        EJECT
***********************************************************************
***********************************************************************
**                                                                   **
**                     Macro Definitions                             **
**                                                                   **
***********************************************************************
***********************************************************************
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_ID                                                      *
*                                                                     *
* Purpose: Establish default values for a specific service processor  *
*          and associate them with the specified ID name. The values  *
*          are stored in the following created global variables:      *
*                                                                     *
* Variable Name                     Description                       *
* -------------  ---------------------------------------------------- *
* #$&ID.$#IDMAC  Name of macro that created the ID: IM_ID.            *
* #$&ID.$#ESID   Service processor's Environment Support ID.          *
* #$&ID.$#EPN    Tag for Service processor's Entry Point Name.        *
* #$&ID.$#EPA    Tag for Service processor's Entry Point Address.     *
* #$&ID.$#TKN    Tag for Service processor's Entry Point Token.       *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=,&ESID=,        +
               &TKNCNVT=
.*
.* Invoke SRV##ID to create globals used by all ID's.
.*
         SRV##ID SET,                                                  +
               ID=&ID.,IDMAC=IM_ID,ESID=&ESID.,SPEPNAME=&SPEPNAME,     +
               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.
.*
.* Establish defaults for parameters specific to the item manager.
.*
&V_TKNCNVT       SETC '#$&ID.$#TKNCNVT'     Variable for TKNCNVT=.
                 GBLC &(&V_TKNCNVT)         Declare global variable.
&(&V_TKNCNVT)    SETC '&TKNCNVT'
.*
         MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_START                                                   *
* Purpose: Generate code to start a new item manager session.         *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_START &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,&OPTIONS=,&DIVEPA=,    +
               &DIVDDN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_START                  SETC in open code.
         LCLC  &OPTSTR
         LCLB  &O_READ_ONLY
         LCLB  &O_ACTUAL_ADDRESS
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ESVA=&ESVA.
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
         MVC   &#_IDTKN,=F'0'            | Insure TOKEN = 0.
.*
.* Decode the options and produce a byte flag for the parmlist.
.*
&I       SETA  1
.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT
         AIF   ('&OPTIONS(&I)' EQ 'READ_ONLY').OPT1
         AIF   ('&OPTIONS(&I)' EQ 'ACTUAL_ADDRESS').OPT2
         MNOTE 8,'Invalid option name: &OPTIONS(&I)'
.OPT1    ANOP
&O_READ_ONLY SETB 1
         AGO   .NEXTOPT         Go process the next option.
.OPT2    ANOP
&O_ACTUAL_ADDRESS SETB 1
         AGO   .NEXTOPT         Go process the next option.
.NEXTOPT ANOP
&I       SETA  &I+1             Increment index into options list.
         AGO   .OPTLOOP         Branch back to top of loop.
.PASTOPT ANOP
&OPTSTR  SETC '&O_READ_ONLY.&O_ACTUAL_ADDRESS'
&OPTSTR  SETC '&OPTSTR.000000'
         AIF  ('&OPTSTR' NE '00000000').NOT_NOP
&OPTSTR  SETC ''
         AGO  .PAST_OPTSTR_SET
.NOT_NOP ANOP
&OPTSTR  SETC '=B''&OPTSTR'''
.PAST_OPTSTR_SET ANOP
.*
.* Gnerate the appropriate IM_START call.
.*
         AIF   ('&DIVDDN' NE '').CALL4
         AIF   ('&DIVEPA' NE '').CALL3
         AIF   ('&OPTSTR' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_START,&#_IDESVA),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_START,&#_IDESVA,&OPTSTR),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_START,&#_IDESVA,&OPTSTR,         +
               &DIVEPA),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_START,&#_IDESVA,&OPTSTR,&DIVEPA, +
               &DIVDDN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_TERMINATE                                               *
* Purpose: Generate code to terminate an item manager session.        *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_TERMINATE &ID=,&SPEPA=,&SPTOKEN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_TERMINATE              SETC in open code.
.*
.* Obtain service processor ID values and terminate item manager.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
         CALLX &#_IDEPA,(&#_IDTKN,&IM_TERMINATE),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_INITIALIZE                                              *
* Purpose: Generate code to initialize the item managed storage.      *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_INITIALIZE &ID=,&SPEPA=,&SPTOKEN=,&ITDSTG=,&UAINCR=,       +
               &SYSINCR=,&DFLTINCR=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_INITIALIZE
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Generate the CALLX to initialize item managed storage.
.*
         AIF   ('&DFLTINCR' NE '').CALL5
         AIF   ('&SYSINCR' NE '').CALL4
         AIF   ('&UAINCR' NE '').CALL3
         AIF   ('&ITDSTG' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_INITIALIZE),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_INITIALIZE,&ITDSTG),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_INITIALIZE,&ITDSTG,              +
               &UAINCR),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_INITIALIZE,&ITDSTG,              +
               &UAINCR,&SYSINCR),VL
         MEXIT
.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&IM_INITIALIZE,&ITDSTG,              +
               &UAINCR,&SYSINCR,&DFLTINCR),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_SAVE                                                    *
* Purpose: Generate code to save item managed storage.                *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_SAVE &ID=,&SPEPA=,&SPTOKEN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_SAVE                   SETC in open code.
.*
.* Obtain service processor ID values and save IM stg.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
         CALLX &#_IDEPA,(&#_IDTKN,&IM_SAVE),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_RESET                                                   *
* Purpose: Generate code to reset item managed storage.               *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_RESET &ID=,&SPEPA=,&SPTOKEN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_RESET                  SETC in open code.
.*
.* Obtain service processor ID values and reset IM stg.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
         CALLX &#_IDEPA,(&#_IDTKN,&IM_RESET),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_ADD_TO_DIRECTORY                                        *
* Purpose: Generate code to add a token to the token directory.       *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_ADD_TO_DIRECTORY &ID=,&SPEPA=,                             +
               &SPTOKEN=,&NAME=,&TOKEN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_ADD_TO_DIRECTORY
         LCLC  &L_LENGTH
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&NAME' NE '').NAMEOK
         MNOTE 8,'NAME (address and length) is a required keyword.'
         MEXIT
.NAMEOK  AIF  ('&TOKEN' NE '').REQOKAY
         MNOTE 8,'TOKEN is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Process the NAME= keyword.
.*
          AIF   (N'&NAME EQ 2).NAMESL     Size and length specified.
          AIF   (N'&NAME EQ 1).LGLITCH    Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for NAME.'
          MEXIT
.NAMESL   ANOP
&L_LENGTH SETC '&NAME(2)'
          AGO .PASTNAME
.LGLITCH  ANOP
&L_LENGTH SETC '=A(L''&NAME(1))'
.PASTNAME ANOP
.*
.* Generate the appropriate call statement.
.*
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_ADD_TO_DIRECTORY,                +
               &L_LENGTH,&NAME(1),&TOKEN),VL
         MEXIT
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_FIND_IN_DIRECTORY                                       *
* Purpose: Generate code to find a token in the token directory.      *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_FIND_IN_DIRECTORY &ID=,&SPEPA=,                            +
               &SPTOKEN=,&NAME=,&TOKEN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_FIND_IN_DIRECTORY
         LCLC  &L_LENGTH
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&NAME' NE '').NAMEOK
         MNOTE 8,'NAME (address and length) is a required keyword.'
         MEXIT
.NAMEOK  AIF  ('&TOKEN' NE '').REQOKAY
         MNOTE 8,'TOKEN is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Process the NAME= keyword.
.*
          AIF   (N'&NAME EQ 2).NAMESL     Size and length specified.
          AIF   (N'&NAME EQ 1).LGLITCH    Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for NAME.'
          MEXIT
.NAMESL   ANOP
&L_LENGTH SETC '&NAME(2)'
          AGO .PASTNAME
.LGLITCH  ANOP
&L_LENGTH SETC '=A(L''&NAME(1))'
.PASTNAME ANOP
.*
.* Generate the appropriate call statement.
.*
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_IN_DIRECTORY,               +
               &L_LENGTH,&NAME(1),&TOKEN),VL
         MEXIT
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_REMOVE_FROM_DIRECTORY                                   *
* Purpose: Generate code to remove a name from the token directory.   *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_REMOVE_FROM_DIRECTORY &ID=,&SPEPA=,                        +
               &SPTOKEN=,&ITEMTYPE=,&NAME=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_REMOVE_FROM_DIRECTORY
         LCLC  &L_LENGTH
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&NAME' NE '').NAMEOK
         MNOTE 8,'NAME (address and length) is a required keyword.'
         MEXIT
.NAMEOK  ANOP
.REQOKAY ANOP
.*
.* Process the NAME= keyword.
.*
          AIF   (N'&NAME EQ 2).NAMESL     Size and length specified.
          AIF   (N'&NAME EQ 1).LGLITCH    Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for NAME.'
          MEXIT
.NAMESL   ANOP
&L_LENGTH SETC '&NAME(2)'
          AGO .PASTNAME
.LGLITCH  ANOP
&L_LENGTH SETC '=A(L''&NAME(1))'
.PASTNAME ANOP
.*
.* Generate the appropriate call statement.
.*
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_REMOVE_FROM_DIRECTORY,           +
               &L_LENGTH,&NAME(1)),VL
         MEXIT
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_CREATE_ITEM_TYPE_DESCRIPTOR                             *
* Purpose: Generate code to do what the macro's name says.            *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_CREATE_ITEM_TYPE_DESCRIPTOR &ID=,&SPEPA=,&SPTOKEN=,        +
               &ITEMTYPE=,&TEXT=,&OPTIONS=,&ITEMSZ=,&#LINKS=,          +
               &LINKSOFF=,&GROUPTKN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_CREATE_ITEM_TYPE_DESCRIPTOR    SETC in open code.
         LCLC  &L_ITEMSZ,&L_ITEMSZ_LENSIZE,&L_ITEMSZ_OFFSET
         LCLC  &L_#LINKS,&L_#LINKS_LENSIZE,&L_#LINKS_OFFSET
         LCLC  &L_LINKSOFF,&L_LINKSOFF_LENSIZE,&L_LINKSOFF_OFFSET
         LCLB  &O_FIRST_LINK_HAS_DESCRIPTION
         LCLC  &OPTSTR
         LCLA  &I
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&ITEMTYPE' NE '').REQOKAY
         MNOTE 8,'ITEMTYPE (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Decode the options and produce a byte flag for the parmlist.
.*
&I       SETA  1
.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT
         AIF   ('&OPTIONS(&I)' EQ 'FIRST_LINK_HAS_DESCRIPTION').OPT1
         MNOTE 8,'Invalid option name: &OPTIONS(&I)'
.OPT1    ANOP
&O_FIRST_LINK_HAS_DESCRIPTION SETB 1
         AGO   .NEXTOPT         Go process the next option.
.NEXTOPT ANOP
&I       SETA  &I+1             Increment index into options list.
         AGO   .OPTLOOP         Branch back to top of loop.
.PASTOPT ANOP
&OPTSTR  SETC '&O_FIRST_LINK_HAS_DESCRIPTION'
&OPTSTR  SETC '&OPTSTR.0000000'
         AIF  ('&OPTSTR' NE '00000000').NOT_NOP
&OPTSTR  SETC ''
         AGO  .PAST_OPTSTR_SET
.NOT_NOP ANOP
&OPTSTR  SETC '=B''&OPTSTR'''
.PAST_OPTSTR_SET ANOP
.*
.* Process the ItemLength parameters.
.*
         AIF   ('&ITEMSZ' NE '').ITEMSZ_NOT_NULL
         MNOTE 8,'ITEMSZ keyword is required.'
         AGO   .PAST_ITEMSZ
.ITEMSZ_NOT_NULL ANOP
         AIF   (N'&ITEMSZ NE 1).NOT_1_ITEMSZ
&L_ITEMSZ  SETC '&ITEMSZ'
         AGO   .PAST_ITEMSZ
.NOT_1_ITEMSZ ANOP
         AIF   ('&ITEMSZ(1)' NE 'IN_ITEM').ITEMSZ_ERROR
         AIF   (N'&ITEMSZ EQ 3).ITEMSZ_OK
.ITEMSZ_ERROR MNOTE 8,'Invalid ITEMSZ parameter.'
         AGO  .PAST_ITEMSZ
.ITEMSZ_OK ANOP
&L_ITEMSZ_LENSIZE SETC '&ITEMSZ(3)'
&L_ITEMSZ_OFFSET  SETC '&ITEMSZ(2)'
.PAST_ITEMSZ  ANOP
.*
.* Process the NumberLinks parameters.
.*
         AIF   ('&#LINKS' NE '').#LINKS_NOT_NULL
         AIF   ('&LINKSOFF' EQ '').PAST_#LINKS
         MNOTE 8,'#LINKS keyword is required if LNKSOFF keyword is spec+
               ified.'
         AGO   .PAST_#LINKS
.#LINKS_NOT_NULL ANOP
         AIF   (N'&#LINKS NE 1).NOT_1_#LINKS
&L_#LINKS  SETC '&#LINKS'
         AGO   .PAST_#LINKS
.NOT_1_#LINKS ANOP
         AIF   ('&#LINKS(1)' NE 'IN_ITEM').#LINKS_ERROR
         AIF   (N'&#LINKS EQ 3).#LINKS_OK
.#LINKS_ERROR MNOTE 8,'Invalid #LINKS parameter.'
         AGO  .PAST_#LINKS
.#LINKS_OK ANOP
&L_#LINKS_LENSIZE SETC '&#LINKS(3)'
&L_#LINKS_OFFSET  SETC '&#LINKS(2)'
.PAST_#LINKS  ANOP
.*
.* Process the LINKSOFF parameters.
.*
         AIF   ('&LINKSOFF' NE '').LINKSOFF_NOT_NULL
         AIF   ('&LINKSOFF' EQ '').PAST_LINKSOFF
         MNOTE 8,'LNKSOFF keyword is required if #LINKS keyword is spec+
               ified.'
         AGO   .PAST_LINKSOFF
.LINKSOFF_NOT_NULL ANOP
         AIF   (N'&LINKSOFF NE 1).NOT_1_LINKSOFF
&L_LINKSOFF SETC '&LINKSOFF'
         AGO   .PAST_LINKSOFF
.NOT_1_LINKSOFF ANOP
         AIF   ('&LINKSOFF(1)' NE 'IN_ITEM').LINKSOFF_ERROR
         AIF   (N'&LINKSOFF EQ 3).LINKSOFF_OK
.LINKSOFF_ERROR MNOTE 8,'Invalid LINKSOFF parameter.'
         AGO  .PAST_LINKSOFF
.LINKSOFF_OK ANOP
&L_LINKSOFF_LENSIZE SETC '&LINKSOFF(3)'
&L_LINKSOFF_OFFSET SETC '&LINKSOFF(2)'
.PAST_LINKSOFF ANOP
.*
.* Generate the appropriate call.
.*
         AIF   ('&L_LINKSOFF_OFFSET' NE '').CALL10
         AIF   ('&L_#LINKS_OFFSET' NE '').CALL9
         AIF   ('&L_ITEMSZ_OFFSET' NE '').CALL8
         AIF   ('&L_LINKSOFF' NE '').CALL7
         AIF   ('&L_#LINKS' NE '').CALL6
         AIF   ('&L_ITEMSZ' NE '').CALL5
         AIF   ('&GROUPTKN' NE '' ).CALL4
         AIF   ('&OPTSTR' NE '').CALL3
         AIF   ('&TEXT' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +
               &ITEMTYPE),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +
               &ITEMTYPE,&TEXT),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +
               &ITEMTYPE,&TEXT,&OPTSTR),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +
               &ITEMTYPE,&TEXT,&OPTSTR,&GROUPTKN),VL
         MEXIT
.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +
               &ITEMTYPE,&TEXT,&OPTSTR,&GROUPTKN,                      +
               &L_ITEMSZ),VL
         MEXIT
.CALL6   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +
               &ITEMTYPE,&TEXT,&OPTSTR,&GROUPTKN,                      +
               &L_ITEMSZ,&L_#LINKS),VL
         MEXIT
.CALL7   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +
               &ITEMTYPE,&TEXT,&OPTSTR,&GROUPTKN,                      +
               &L_ITEMSZ,&L_#LINKS,&L_LINKSOFF),VL
         MEXIT
.CALL8   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +
               &ITEMTYPE,&TEXT,&OPTSTR,&GROUPTKN,                      +
               &L_ITEMSZ,&L_#LINKS,&L_LINKSOFF,                        +
               &L_ITEMSZ_LENSIZE,&L_ITEMSZ_OFFSET),VL
         MEXIT
.CALL9   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +
               &ITEMTYPE,&TEXT,&OPTSTR,&GROUPTKN,                      +
               &L_ITEMSZ,&L_#LINKS,&L_LINKSOFF,                        +
               &L_ITEMSZ_LENSIZE,&L_ITEMSZ_OFFSET,                     +
               &L_#LINKS_LENSIZE,&L_#LINKS_OFFSET),VL
         MEXIT
.CALL10  CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_ITEM_TYPE_DESCRIPTOR,     +
               &ITEMTYPE,&TEXT,&OPTSTR,&GROUPTKN,                      +
               &L_ITEMSZ,&L_#LINKS,&L_LINKSOFF,                        +
               &L_ITEMSZ_LENSIZE,&L_ITEMSZ_OFFSET,                     +
               &L_#LINKS_LENSIZE,&L_#LINKS_OFFSET,                     +
               &L_LINKSOFF_LENSIZE,&L_LINKSOFF_OFFSET),VL
         MEXIT
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_CREATE_GROUP_DESCRIPTOR                                 *
* Purpose: Generate code to create a group descriptor.                *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_CREATE_GROUP_DESCRIPTOR &ID=,&SPEPA=,&SPTOKEN=,            +
               &DESCTKN=,&TEXT=,&STGINCR=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_CREATE_GROUP_DESCRIPTOR SETC in open code.
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (descriptor token) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Generate the appropriate call.
.*
         AIF   ('&STGINCR' NE '').CALL3
         AIF   ('&TEXT' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_GROUP_DESCRIPTOR,         +
               &DESCTKN),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_GROUP_DESCRIPTOR,         +
               &DESCTKN,&TEXT),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_GROUP_DESCRIPTOR,         +
               &DESCTKN,&TEXT,&STGINCR),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_CREATE_LINKED_LIST_DESCRIPTOR                           *
* Purpose: Generate code to create a list descriptor.                 *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_CREATE_LINKED_LIST_DESCRIPTOR &ID=,&SPEPA=,&SPTOKEN=,      +
               &DESCTKN=,&TEXT=,&OPTIONS=,                             +
               &FSTLNK#=,&FNLLNK#=,&NXTLNK#=,&PRLNK#=,&OWNLNK#=,       +
               &HEADTYPE=,&KEYOFF=,&KEYSZ=,&MEMTYPE=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_CREATE_LINKED_LIST_DESCRIPTOR SETC in open code.
         LCLB  &O_HEADS_IN_DESCRIPTOR
         LCLB  &O_DUPLICATE_KEYS_ALLOWED
         LCLC  &O_LIST_ORDER
         LCLC  &L_KEYSZ,&L_KEYSZ_OFFSET
         LCLB  &KEYED
         LCLC  &PLINK
&O_LIST_ORDER  SETC '000'
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (descriptor token) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Decode the options and produce a byte flag for the parmlist.
.*
&I       SETA  1
.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT
         AIF   ('&OPTIONS(&I)' EQ 'HEADS_IN_DESCRIPTOR').OPT1
         AIF   ('&OPTIONS(&I)' EQ 'DUPLICATE_KEYS_ALLOWED').OPT2
         AIF   ('&OPTIONS(&I)' EQ 'LIST_ORDER_FIRST').OPT3
         AIF   ('&OPTIONS(&I)' EQ 'LIST_ORDER_FINAL').OPT4
.*>>> NS AIF   ('&OPTIONS(&I)' EQ 'LIST_ORDER_NEXT').OPT5
.*>>> NS AIF   ('&OPTIONS(&I)' EQ 'LIST_ORDER_PRIOR').OPT6
.*>>> NS AIF   ('&OPTIONS(&I)' EQ 'LIST_ORDER_SORTED_ASCENDING').OPT7
.*>>> NS AIF   ('&OPTIONS(&I)' EQ 'LIST_ORDER_SORTED_DECENDING').OPT8
         MNOTE 8,'Invalid option name: &OPTIONS(&I)'
.OPT1    ANOP
&O_HEADS_IN_DESCRIPTOR SETB 1
         AGO   .NEXTOPT         Go process the next option.
.OPT2    ANOP
&O_DUPLICATE_KEYS_ALLOWED SETB 1
         AGO   .NEXTOPT         Go process the next option.
.OPT3    ANOP
&O_LIST_ORDER  SETC '000'
         AGO   .NEXTOPT         Go process the next option.
.OPT4    ANOP
&O_LIST_ORDER  SETC '001'
         AGO   .NEXTOPT         Go process the next option.
.OPT5    ANOP
&O_LIST_ORDER  SETC '010'
         AGO   .NEXTOPT         Go process the next option.
.OPT6    ANOP
&O_LIST_ORDER  SETC '011'
         AGO   .NEXTOPT         Go process the next option.
.OPT7    ANOP
&O_LIST_ORDER  SETC '100'
&KEYED   SETB  1
         AGO   .NEXTOPT         Go process the next option.
.OPT8    ANOP
&O_LIST_ORDER  SETC '101'
&KEYED   SETB  1
         AGO   .NEXTOPT         Go process the next option.
.NEXTOPT ANOP
&I       SETA  &I+1             Increment index into options list.
         AGO   .OPTLOOP         Branch back to top of loop.
.PASTOPT ANOP
&OPTSTR  SETC '&O_HEADS_IN_DESCRIPTOR'
&OPTSTR  SETC '&OPTSTR.&O_DUPLICATE_KEYS_ALLOWED'
&OPTSTR  SETC '&OPTSTR.000&O_LIST_ORDER'
         AIF  ('&OPTSTR' NE '00000000').NOT_NOP
&OPTSTR  SETC ''
         AGO  .PAST_OPTSTR_SET
.NOT_NOP ANOP
&OPTSTR  SETC '=B''&OPTSTR'''
.PAST_OPTSTR_SET ANOP
.*
.* Process the KeySz parameters.
.*
         AIF   ('&KEYSZ' EQ '').PAST_KEYSZ
         AIF   (N'&KEYSZ NE 1).NOT_1_KEYSZ
&L_KEYSZ   SETC '&KEYSZ'
         AGO   .PAST_KEYSZ
.NOT_1_KEYSZ ANOP
         AIF   ('&KEYSZ(1)' NE 'IN_ITEM').KEYSZ_ERROR
         AIF   (N'&KEYSZ EQ 2).KEYSZ_OK
.KEYSZ_ERROR MNOTE 8,'Invalid KEYSZ parameter.'
         AGO  .PAST_KEYSZ
.KEYSZ_OK ANOP
&L_KEYSZ_OFFSET   SETC '&KEYSZ(2)'
.PAST_KEYSZ   ANOP
.*
.* Generate the appropriate call.
.*
         ##PLIST START
         ##PLIST PARM,&#_IDTKN,&IM_CREATE_LINKED_LIST_DESCRIPTOR
         ##PLIST PARM,&DESCTKN
.*
         AIF   ('&MEMTYPE' NE '').CALL13
         AIF   ('&L_KEYSZ_OFFSET' NE '').CALL12
         AIF   ('&L_KEYSZ' NE '').CALL11
         AIF   ('&KEYOFF'  NE '').CALL10
         AIF   ('&HEADTYPE' NE '').CALL9
         AIF   ('&OWNLNK#' NE '').CALL8
         AIF   ('&PRLNK#' NE '').CALL7
         AIF   ('&NXTLNK#' NE '').CALL6
         AIF   ('&FNLLNK#' NE '').CALL5
         AIF   ('&FSTLNK#' NE '').CALL4
         AIF   ('&OPTIONS' NE '').CALL3
         AIF   ('&TEXT' NE '').CALL2
.CALL1   AGO   .CALLX
.CALL2   ##PLIST PARM,&TEXT
         AGO   .CALLX
.CALL3   ##PLIST PARM,&TEXT,&OPTSTR
         AGO   .CALLX
.CALL4   ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#
         AGO   .CALLX
.CALL5   ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#
         AGO   .CALLX
.CALL6   ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#
         AGO   .CALLX
.CALL7   ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#,&PRLNK#
         AGO   .CALLX
.CALL8   ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#,&PRLNK#
         ##PLIST PARM,&OWNLNK#
         AGO   .CALLX
.CALL9   ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#,&PRLNK#
         ##PLIST PARM,&OWNLNK#,&HEADTYPE
         AGO   .CALLX
.CALL10  ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#,&PRLNK#
         ##PLIST PARM,&OWNLNK#,&HEADTYPE,&KEYOFF
         AGO   .CALLX
.CALL11  ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#,&PRLNK#
         ##PLIST PARM,&OWNLNK#,&HEADTYPE,&KEYOFF,&L_KEYSZ
         AGO   .CALLX
.CALL12  ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#,&PRLNK#
         ##PLIST PARM,&OWNLNK#,&HEADTYPE,&KEYOFF,&L_KEYSZ
         ##PLIST PARM,&L_KEYSZ_OFFSET
         AGO   .CALLX
.CALL13  ##PLIST PARM,&TEXT,&OPTSTR,&FSTLNK#,&FNLLNK#,&NXTLNK#,&PRLNK#
         ##PLIST PARM,&OWNLNK#,&HEADTYPE,&KEYOFF,&L_KEYSZ
         ##PLIST PARM,&L_KEYSZ_OFFSET,&MEMTYPE
.CALLX   ##PLIST END,VL
         CALLX   &#_IDEPA
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_CREATE_HASH_TABLE_DESCRIPTOR                            *
* Purpose: Generate code to create a hash table descriptor.           *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_CREATE_HASH_TABLE_DESCRIPTOR &ID=,&SPEPA=,&SPTOKEN=,       +
               &DESCTKN=,&TEXT=,&OPTIONS=,&ENTRIES=,                   +
               &SYNLNK#=,&KEYOFF=,&KEYSZ=,&MEMTYPE=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_CREATE_HASH_TABLE_DESCRIPTOR SETC in open code.
         LCLB  &O_HEADS_IN_DESCRIPTOR
         LCLB  &O_DUPLICATE_KEYS_ALLOWED
         LCLC  &L_KEYSZ,&L_KEYSZ_OFFSET
         LCLB  &KEYED
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (descriptor token) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Decode the options and produce a byte flag for the parmlist.
.*
&I       SETA  1
.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT
         AIF   ('&OPTIONS(&I)' EQ 'DUPLICATE_KEYS_ALLOWED').OPT1
         MNOTE 8,'Invalid option name: &OPTIONS(&I)'
.OPT1    ANOP
&O_DUPLICATE_KEYS_ALLOWED SETB 1
         AGO   .NEXTOPT         Go process the next option.
.NEXTOPT ANOP
&I       SETA  &I+1             Increment index into options list.
         AGO   .OPTLOOP         Branch back to top of loop.
.PASTOPT ANOP
&OPTSTR  SETC '&O_DUPLICATE_KEYS_ALLOWED.0000000'
         AIF  ('&OPTSTR' NE '00000000').NOT_NOP
&OPTSTR  SETC ''
         AGO  .PAST_OPTSTR_SET
.NOT_NOP ANOP
&OPTSTR  SETC '=B''&OPTSTR'''
.PAST_OPTSTR_SET ANOP
.*
.* Process the KeySz parameters.
.*
         AIF   ('&KEYSZ' EQ '').PAST_KEYSZ
         AIF   (N'&KEYSZ NE 1).NOT_1_KEYSZ
&L_KEYSZ   SETC '&KEYSZ'
         AGO   .PAST_KEYSZ
.NOT_1_KEYSZ ANOP
         AIF   ('&KEYSZ(1)' NE 'IN_ITEM').KEYSZ_ERROR
         AIF   (N'&KEYSZ EQ 2).KEYSZ_OK
.KEYSZ_ERROR MNOTE 8,'Invalid KEYSZ parameter.'
         AGO  .PAST_KEYSZ
.KEYSZ_OK ANOP
&L_KEYSZ_OFFSET   SETC '&KEYSZ(2)'
.PAST_KEYSZ   ANOP
.*
.* Generate the appropriate call.
.*
         AIF   ('&MEMTYPE' NE '').CALL9
         AIF   ('&L_KEYSZ_OFFSET' NE '').CALL8
         AIF   ('&L_KEYSZ' NE '').CALL7
         AIF   ('&KEYOFF'  NE '').CALL6
         AIF   ('&SYNLNK#' NE '').CALL5
         AIF   ('&ENTRIES' NE '').CALL4
         AIF   ('&OPTIONS' NE '').CALL3
         AIF   ('&TEXT' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +
               &DESCTKN),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +
               &DESCTKN,&TEXT),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +
               &DESCTKN,&TEXT,&OPTSTR),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +
               &DESCTKN,&TEXT,&OPTSTR,                                 +
               &ENTRIES),VL
         MEXIT
.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +
               &DESCTKN,&TEXT,&OPTSTR,                                 +
               &ENTRIES,&SYNLNK#),VL
         MEXIT
.CALL6   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +
               &DESCTKN,&TEXT,&OPTSTR,                                 +
               &ENTRIES,&SYNLNK#,&KEYOFF),VL
         MEXIT
.CALL7   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +
               &DESCTKN,&TEXT,&OPTSTR,                                 +
               &ENTRIES,&SYNLNK#,&KEYOFF,&L_KEYSZ),VL
         MEXIT
.CALL8   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +
               &DESCTKN,&TEXT,&OPTSTR,                                 +
               &ENTRIES,&SYNLNK#,&KEYOFF,&L_KEYSZ,                     +
               &L_KEYSZ_OFFSET),VL
         MEXIT
.CALL9   CALLX &#_IDEPA,(&#_IDTKN,&IM_CREATE_HASH_TABLE_DESCRIPTOR,    +
               &DESCTKN,&TEXT,&OPTSTR,                                 +
               &ENTRIES,&SYNLNK#,&KEYOFF,&L_KEYSZ,                     +
               &L_KEYSZ_OFFSET,&MEMTYPE),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_CONNECT                                                 *
* Purpose: Generate code to connect an item.                          *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_CONNECT &ID=,&SPEPA=,&SPTOKEN=,                            +
               &DESCTKN=,&ITEMTKN=,&HEADTKN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_CONNECT SETC in open code.
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (descriptor token) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Generate the appropriate call.
.*
         AIF   ('&HEADTKN' NE '').CALL3
         AIF   ('&ITEMTKN' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_CONNECT,                         +
               &DESCTKN),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_CONNECT,                         +
               &DESCTKN,&ITEMTKN),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_CONNECT,                         +
               &DESCTKN,&ITEMTKN,&HEADTKN),VL
         MEXIT
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_DISCONNECT                                              *
* Purpose: Generate code to disconnect an item.                       *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_DISCONNECT &ID=,&SPEPA=,&SPTOKEN=,                         +
               &DESCTKN=,&ITEMTKN=,&HEADTKN=,&PRTKN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_DISCONNECT SETC in open code.
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (descriptor token) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Generate the appropriate call.
.*
         AIF   ('&PRTKN' NE '').CALL4
         AIF   ('&HEADTKN' NE '').CALL3
         AIF   ('&ITEMTKN' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_DISCONNECT,                      +
               &DESCTKN),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_DISCONNECT,                      +
               &DESCTKN,&ITEMTKN),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_DISCONNECT,                      +
               &DESCTKN,&ITEMTKN,&HEADTKN),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_DISCONNECT,                      +
               &DESCTKN,&ITEMTKN,&HEADTKN,&PRTKN),VL
         MEXIT
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_ERASE                                                   *
* Purpose: Generate code to erase an item.                            *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_ERASE &ID=,&SPEPA=,&SPTOKEN=,&ITEMTKN=,&OPTIONS=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_ERASE SETC in open code.
         LCLB  &O_BYPASS_LINKS_CHECK
         LCLC  &OPTSTR
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Decode the options and produce a byte flag for the parmlist.
.*
&I       SETA  1
.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT
         AIF   ('&OPTIONS(&I)' EQ 'BYPASS_LINKS_CHECK').OPT1
         AIF   ('&OPTIONS(&I)' EQ '*BYPASS').OPT2
         MNOTE 8,'Invalid option name: &OPTIONS(&I)'
.OPT1    ANOP
&O_BYPASS_LINKS_CHECK SETB 1
         AGO   .NEXTOPT         Go process the next option.
.OPT2    ANOP
&O_BYPASS_LINKS_CHECK SETB 1
         AGO   .NEXTOPT         Go process the next option.
.NEXTOPT ANOP
&I       SETA  &I+1             Increment index into options list.
         AGO   .OPTLOOP         Branch back to top of loop.
.PASTOPT ANOP
&OPTSTR  SETC '&O_BYPASS_LINKS_CHECK'
&OPTSTR  SETC '&OPTSTR.0000000'
         AIF  ('&OPTSTR' NE '00000000').NOT_NOP
&OPTSTR  SETC ''
         AGO  .PAST_OPTSTR_SET
.NOT_NOP ANOP
&OPTSTR  SETC '=B''&OPTSTR'''
.PAST_OPTSTR_SET ANOP
.*
.* Generate the appropriate call.
.*
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&OPTSTR' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_ERASE,&#_IDESVA),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_ERASE,                           +
               &OPTSTR),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_ERASE,                           +
               &OPTSTR,&ITEMTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_GET                                                     *
* Purpose: Generate code to get an item.                              *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_GET &ID=,&SPEPA=,&SPTOKEN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_GET                     SETC in open code.
         LCLC  &L_LENGTH
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&ITEM' NE '').ITEMOK
         MNOTE 8,'ITEM (address and length) is a required keyword.'
         MEXIT
.ITEMOK  ANOP
.*
.* Process the ITEM= keyword.
.*
          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.
          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for ITEM.'
          MEXIT
.ITEMSL   ANOP
&L_LENGTH SETC '&ITEM(2)'
          AGO .PASTITEM
.LGLITCH  ANOP
&L_LENGTH SETC '=A(L''&ITEM(1))'
.PASTITEM ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_GET,                             +
               &L_LENGTH,&ITEM(1)),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_GET,                             +
               &L_LENGTH,&ITEM(1),&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_GET,                             +
               &L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_GET_DANGEROUS_ADDRESSES                                 *
* Purpose: Generate code to get an item.                              *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_GET_DANGEROUS_ADDRESSES &ID=,&SPEPA=,&SPTOKEN=,&TKNCNVT=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_GET_DANGEROUS_ADDRESSES SETC in open code.
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Get TKNCNVT this macro call or the default from ID macro.
.*
&L_TKNCNVT SETC '&TKNCNVT'
         AIF   ('&TKNCNVT' NE '').TKNCNVT_OK
&V_TKNCNVT       SETC '#$&ID.$#TKNCNVT'     Variable for TKNCNVT=.
                 GBLC &(&V_TKNCNVT)         Declare global variable.
&L_TKNCNVT SETC '&(&V_TKNCNVT)'
.TKNCNVT_OK   ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&L_TKNCNVT' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_GET_DANGEROUS_ADDRESSES)
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_GET_DANGEROUS_ADDRESSES,         +
               &L_TKNCNVT),VL
         MEXIT
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_CONVERT_TOKEN_TO_ADDRESS                                *
* Purpose: Generate code to call TKNCNVT routine to convert a token   *
*          to an address.                                             *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_CONVERT_TOKEN_TO_ADDRESS &ID=,&SPEPA=,&SPTOKEN=,           +
               &TKNCNVT=,&ITEMTKN=,&ITEMADDR=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Get TKNCNVT this macro call or the default from ID macro.
.*
&L_TKNCNVT SETC '&TKNCNVT'
         AIF   ('&TKNCNVT' NE '').TKNCNVT_OK
&V_TKNCNVT       SETC '#$&ID.$#TKNCNVT'     Variable for TKNCNVT=.
                 GBLC &(&V_TKNCNVT)         Declare global variable.
&L_TKNCNVT SETC '&(&V_TKNCNVT)'
         AIF   ('&L_TKNCNVT' NE '').TKNCNVT_OK
         MNOTE 8,'TKNCNVT keyword is required on this macro or the asso+
               ciated IM_ID macro.'
.TKNCNVT_OK   ANOP
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&ITEMTKN' NE '').ITEMTKN_OK
         MNOTE 8,'ITEMTKN (item token) is a required keyword.'
         MEXIT
.ITEMTKN_OK ANOP
         AIF  ('&ITEMADDR' NE '').ITEMADDR_OK
         MNOTE 8,'ITEMADDR (item address) is a required keyword.'
         MEXIT
.ITEMADDR_OK ANOP
.*
.* Generate the call.
.*
         ##L   R0,&ITEMTKN.,WREG=R1   | Load token into r1.
         L     R1,&#_IDTKN            | Load token of item manager.
         CALLX &L_TKNCNVT             | Call conversion routine.
         ##ST  R1,&ITEMADDR           | Store result.
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_MODIFY                                                  *
* Purpose: Generate code to modify an item.                           *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_MODIFY &ID=,&SPEPA=,&SPTOKEN=,&ITEM=,&ITEMTKN=,&OPTIONS=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_MODIFY SETC in open code.
         LCLB  &O_BYPASS_LINKS_CHECK,&O_UPDATE_LINKS
         LCLC  &OPTSTR
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&ITEM' NE '').REQOKAY
         MNOTE 8,'ITEM (item address) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Decode the options and produce a byte flag for the parmlist.
.*
&I       SETA  1
.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT
         AIF   ('&OPTIONS(&I)' EQ 'BYPASS_LINKS_CHECK').OPT1
         AIF   ('&OPTIONS(&I)' EQ 'UPDATE_LINKS').OPT2
         MNOTE 8,'Invalid option name: &OPTIONS(&I)'
.OPT1    ANOP
&O_BYPASS_LINKS_CHECK SETB 1
         AGO   .NEXTOPT         Go process the next option.
.OPT2    ANOP
&O_UPDATE_LINKS   SETB 1
         AGO   .NEXTOPT         Go process the next option.
.NEXTOPT ANOP
&I       SETA  &I+1             Increment index into options list.
         AGO   .OPTLOOP         Branch back to top of loop.
.PASTOPT ANOP
&OPTSTR  SETC '&O_BYPASS_LINKS_CHECK'
&OPTSTR  SETC '&OPTSTR.&O_UPDATE_LINKS'
&OPTSTR  SETC '&OPTSTR.000000'
         AIF  ('&OPTSTR' NE '00000000').NOT_NOP
&OPTSTR  SETC ''
         AGO  .PAST_OPTSTR_SET
.NOT_NOP ANOP
&OPTSTR  SETC '=B''&OPTSTR'''
.PAST_OPTSTR_SET ANOP
.*
.* Generate the appropriate call.
.*
         AIF   ('&OPTSTR' NE '').CALL3
         AIF   ('&ITEMTKN' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_MODIFY,                          +
               &ITEM),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_MODIFY,                          +
               &ITEM,&OPTSTR,&ITEMTKN),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_MODIFY,                          +
               &ITEM,&OPTSTR,&ITEMTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_SORT                                                    *
* Purpose: Generate code to sort a structure.                         *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_SORT &ID=,&SPEPA=,&SPTOKEN=,                               +
               &DESCTKN=,&FIELDS=,&FIELDSLIST=,&HEADTKN=,&TECHNIQUE=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_SORT SETC in open code.
         LCLC  &L_FIELDSLIST
         LCLA  &L_TECHNIQUE
         GBLA  &IM_SORT_TECHNIQUE_QUICK_SORT
         GBLA  &IM_SORT_TECHNIQUE_BUBBLE_SORT
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (descriptor token) is a required keyword.'
         MEXIT
.REQOKAY ANOP
         AIF  ('&FIELDS' NE '' OR '&FIELDSLIST' NE '').FIELDS_OKAY
         MNOTE 8,'Either the FIELDS or the FIELDSLIST keyword is requir+
               ed.'
         MEXIT
.FIELDS_OKAY ANOP
         AIF  ('&FIELDS' EQ '' OR '&FIELDSLIST' EQ '').FIELDS_OKAY2
         MNOTE 8,'The FIELDS and the FIELDSLIST keywords are mutually e+
               xclusive.'
         MEXIT
.FIELDS_OKAY2 ANOP
.*
.*  Process the FIELDS or FIELDSLIST keyword.
.*
         AIF  ('&FIELDSLIST' EQ '').NOT_FIELDSLIST
&L_FIELDSLIST SETC '&FIELDSLIST'
         AGO  .PAST_FIELDS_PROCESS
.NOT_FIELDSLIST ANOP
&L_FIELDSLIST SETC 'IM_SORT__FIELDSLIST_&SYSNDX'
         PSD  TYPE=PARTIAL
         IM_SORT_FIELDSLIST NAME=&L_FIELDSLIST,FIELDS=&FIELDS
         ENDPSD
.PAST_FIELDS_PROCESS ANOP
.*
.*  Process TECHNIQUE.
.*
&L_TECHNIQUE  SETA 0
         AIF   ('&TECHNIQUE' EQ '').PAST_TECHNIQUE
         AIF   ('&TECHNIQUE' EQ 'QUICK_SORT').QUICK_SORT
         AIF   ('&TECHNIQUE' EQ 'BUBBLE_SORT').BUBBLE_SORT
         MNOTE 8,'Invalid TECHNIQUE &TECHNIQUE..'
         AGO   .PAST_TECHNIQUE
.QUICK_SORT ANOP
&L_TECHNIQUE SETA &IM_SORT_TECHNIQUE_QUICK_SORT
         AGO   .PAST_TECHNIQUE
.BUBBLE_SORT ANOP
&L_TECHNIQUE SETA &IM_SORT_TECHNIQUE_BUBBLE_SORT
.PAST_TECHNIQUE ANOP
.*
.* Generate the appropriate call.
.*
         AIF   (&L_TECHNIQUE NE 0).CALL3
         AIF   ('&HEADTKN' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_SORT,&DESCTKN,&L_FIELDSLIST),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_SORT,&DESCTKN,&L_FIELDSLIST,     +
               &HEADTKN),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_SORT,&DESCTKN,&L_FIELDSLIST,     +
               &HEADTKN,&L_TECHNIQUE),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_SORT_FIELDSLIST                                         *
* Purpose: Generate static SFD.                                       *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_SORT_FIELDSLIST &NAME=,&FIELDS=
           GBLA  &IM_SFD_TYPE_CHARACTER
           GBLA  &IM_SFD_TYPE_CHAR
           GBLA  &IM_SFD_TYPE_PACKED
           GBLA  &IM_SFD_TYPE_ZONED
           GBLA  &IM_SFD_TYPE_FIXED
           GBLA  &IM_SFD_TYPE_BIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&NAME' NE '').NAME_OK
         MNOTE 8,'NAME (fields list name) is a required keyword.'
         MEXIT
.NAME_OK ANOP
         AIF  ('&FIELDS' NE '').FIELDS_OKAY
         MNOTE 8,'FIELDS (sort fields) is a required keyword.'
         MEXIT
.FIELDS_OKAY ANOP
.*
.*  Generate fields table.
.*
         DS    0F                     Fullword alignment.
&NAME    DC    CL4'SFD '              Control block identification.
&CNT     SETA  N'&FIELDS
         DC    F'&CNT'                Number of entries in array.
&CNT     SETA  1
.LOOP    ANOP
         AIF   (N'&FIELDS(&CNT) GE 2 AND N'&FIELDS(&CNT) LE 4).FIELD_OK
         MNOTE 8,'Incorrect number of fields - &FIELDS(&CNT).'
         AGO   .NEXT
.FIELD_OK ANOP
         DC    A(&FIELDS(&CNT,1))     Offset of field.
         AIF   ('&FIELDS(&CNT,2)' EQ '').NO_LEN
         DC    A(&FIELDS(&CNT,2))     Length of field, or bit-mask.
         AGO   .PAST_LEN
.NO_LEN  DC    A(L'&FIELDS(&CNT,1))   Length of field.
.PAST_LEN ANOP
         AIF   ('&FIELDS(&CNT,3)' NE '' AND '&FIELDS(&CNT,3)' NE 'CHAR'+
               ).NOT_CHAR_A
         DC    H'&IM_SFD_TYPE_CHARACTER' Type character.
         AGO   .PAST_TYPE
.NOT_CHAR_A AIF  ('&FIELDS(&CNT,3)' NE 'PACKED').NOT_PACKED_A
         DC    H'&IM_SFD_TYPE_PACKED'    Type packed.
         AGO   .PAST_TYPE
.NOT_PACKED_A AIF  ('&FIELDS(&CNT,3)' NE 'ZONED').NOT_ZONED_A
         DC    H'&IM_SFD_TYPE_ZONED'     Type zoned.
         AGO   .PAST_TYPE
.NOT_ZONED_A AIF  ('&FIELDS(&CNT,3)' NE 'FIXED').NOT_FIXED_A
         DC    H'&IM_SFD_TYPE_FIXED'     Type fixed.
         AGO   .PAST_TYPE
.NOT_FIXED_A AIF  ('&FIELDS(&CNT,3)' NE 'BIT').NOT_BIT_A
         DC    H'&IM_SFD_TYPE_BIT'       Type bit.
         AIF   ('&FIELDS(&CNT,2)' EQ '').NO_MASK
         AGO   .PAST_TYPE
.NO_MASK ANOP
         MNOTE 8,'Bit mask required as second parameter'
         AGO   .PAST_TYPE
.NOT_BIT_A ANOP
         MNOTE 8,'Invalid type &FIELDS(&CNT,3) in field &FIELDS(&CNT).'
.PAST_TYPE  ANOP
         AIF   ('&FIELDS(&CNT,4)' EQ 'DESCENDING').DESCENDING
         AIF   ('&FIELDS(&CNT,4)' EQ '' OR '&FIELDS(&CNT,4)' EQ 'ASCEND+
               ING').ASCENDING
         MNOTE 8,'Invalid order &FIELDS(&CNT,4) in field &FIELDS(&CNT).+
               '
.ASCENDING  ANOP
         DC    X'00'                     Order ascending.
         AGO   .PAST_ORDER
.DESCENDING ANOP
         DC    X'80'                     Order descending.
.PAST_ORDER ANOP
         DC    X'00'                  Not used.
.NEXT    ANOP
&CNT     SETA  &CNT+1
         AIF   (&CNT LE N'&FIELDS).LOOP
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_SORT_FIELDS START name                                  *
*           IM_SORT_FIELD OFFSET,LENGTH,TYPE,ORDER                    *
*           IM_SORT_FIELD OFFSET,LENGTH,TYPE,ORDER                    *
*           IM_SORT_FIELD OFFSET,LENGTH,TYPE,ORDER                    *
*           ...                                                       *
*          IM_SORT_FIELDS END                                         *
* Purpose: Generate static SFD.                                       *
*                                                                     *
*---------------------------------------------------------------------*
           MACRO
           IM_SORT_FIELDS &TYPE,&NAME
           GBLC &SF_NAME
           GBLA &SF_CNT
           AIF  ('&TYPE' EQ 'START').T_START
           AIF  ('&TYPE' EQ 'END').T_END
           MNOTE 8,'Invalid type for IM_SORT_FIELDS macro'
           MEXIT
.T_START   ANOP
&SF_NAME   SETC  '&NAME'
           DS    0F                           Fullword alignment.
&NAME      DC    CL4'SFD '                    Control block id.
&NAME._CNT DC    F'0'                         #entries in array.
&SF_CNT    SETA  0
           MEXIT
.T_END     ANOP
           ORG   &SF_NAME._CNT                Org to #entries.
&SF_NAME._#FIELDS EQU  &SF_CNT                Equate with #fields.
           DC    F'&SF_CNT'                   Set correct value.
           ORG   ,                            Resume location counter.
           MEND
           MACRO
           IM_SORT_FIELD &OFFSET,&LENGTH,&TYPE,&ORDER
           GBLA  &IM_SFD_TYPE_CHARACTER
           GBLA  &IM_SFD_TYPE_CHAR
           GBLA  &IM_SFD_TYPE_PACKED
           GBLA  &IM_SFD_TYPE_ZONED
           GBLA  &IM_SFD_TYPE_FIXED
           GBLA  &IM_SFD_TYPE_BIT
           LCLC  &T
&T         SETC  '&TYPE'
           AIF   ('&TYPE' NE '').HAVE_TYPE
&T         SETC  'CHAR'
.HAVE_TYPE ANOP
           GBLA &SF_CNT
&SF_CNT    SETA &SF_CNT+1
           DC   A(&OFFSET)                    Offset of field.
           DC   A(&LENGTH)                    Length/Mask for field.
           DC   H'&(IM_SFD_TYPE_&T.)'         Data type for field.
           AIF  ('&ORDER' EQ '').A
           AIF  ('&ORDER' EQ 'A' OR '&ORDER' EQ 'ASCENDING').A
           AIF  ('&ORDER' EQ 'D' OR '&ORDER' EQ 'DESCENDING').D
           MNOTE 8,'Invalid sort direction: &ORDER.'
.A         ANOP
           DC    X'00'                        Order ascending.
           AGO   .PAST_ORD
.D         ANOP
           DC    X'80'                        Order descending.
.PAST_ORD  ANOP
           DC    X'00'                        Not used.
.MEXIT     MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_FIND                                                    *
* Purpose: Generate code to FIND an item.                             *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_FIND &ID=,&SPEPA=,&SPTOKEN=,&ITEMTKN=,&ACTUALSZ=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_FIND                    SETC in open code.
         LCLC  &L_LENGTH
.*
.* FIND service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&ITEMTKN' NE '').REQOKAY
         MNOTE 8,'ITEMTKN (item token) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND,&ITEMTKN),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND,&ITEMTKN,&ACTUALSZ),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_FIND_BY_KEY                                             *
* Purpose: Generate code to find by key.                              *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_FIND_BY_KEY &ID=,&SPEPA=,                                  +
               &SPTOKEN=,&DESCTKN=,&KEY=,                              +
               &ITEMTKN=,&ACTUALSZ=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_FIND_BY_KEY
         LCLC  &K_LENGTH
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&KEY' NE '').KEYOK
         MNOTE 8,'KEY (search key) is a required keyword.'
         MEXIT
.KEYOK   AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Process the KEY= keyword.
.*
          AIF   (N'&KEY EQ 2).KEYSL       Size and length specified.
          AIF   (N'&KEY EQ 1).KYLITCH     Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for KEY.'
          MEXIT
.KEYSL    ANOP
&K_LENGTH SETC '&KEY(2)'
          AGO .PASTKEY
.KYLITCH  ANOP
&K_LENGTH SETC '=A(L''&KEY(1))'
.PASTKEY ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_BY_KEY,                     +
               &DESCTKN,&K_LENGTH,&KEY(1)),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_BY_KEY,                     +
               &DESCTKN,&K_LENGTH,&KEY(1),                             +
               &ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_BY_KEY,                     +
               &DESCTKN,&K_LENGTH,&KEY(1),                             +
               &ACTUALSZ,&ITEMTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_FIND_CURRENT_OF_ITEM_TYPE                               *
* Purpose: Generate code to find current of item type.                *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_FIND_CURRENT_OF_ITEM_TYPE &ID=,&SPEPA=,                    +
               &SPTOKEN=,&ITEMTYPE=,&ITEMTKN=,&ACTUALSZ=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_FIND_CURRENT_OF_ITEM_TYPE
         LCLC  &L_LENGTH
.*
.* FIND service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&ITEMTYPE' NE '').REQOKAY
         MNOTE 8,'ITEMTYPE (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_CURRENT_OF_ITEM_TYPE,       +
               &ITEMTYPE),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_CURRENT_OF_ITEM_TYPE,       +
               &ITEMTYPE,&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_CURRENT_OF_ITEM_TYPE,       +
               &ITEMTYPE,&ACTUALSZ,&ITEMTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_FIND_CURRENT_OF_DESCRIPTOR                              *
* Purpose: Generate code to find current of descriptor.               *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_FIND_CURRENT_OF_DESCRIPTOR &ID=,&SPEPA=,                   +
               &SPTOKEN=,&DESCTKN=,&ITEMTKN=,&ACTUALSZ=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_FIND_CURRENT_OF_DESCRIPTOR
         LCLC  &L_LENGTH
.*
.* FIND service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.PASTITEM ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_CURRENT_OF_DESCRIPTOR,      +
               &DESCTKN),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_CURRENT_OF_DESCRIPTOR,      +
               &DESCTKN,&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_CURRENT_OF_DESCRIPTOR,      +
               &DESCTKN,&ACTUALSZ,&ITEMTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_FIND_NEXT                                               *
* Purpose: Generate code to find the next item for a descriptor.      *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_FIND_NEXT &ID=,&SPEPA=,                                    +
               &SPTOKEN=,&DESCTKN=,&ITEMTKN=,&ACTUALSZ=,               +
               &HEADTKN=,&CURTKN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_FIND_NEXT
         LCLC  &L_LENGTH
.*
.* FIND service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&HEADTKN' NE '').CALL5
         AIF   ('&CURTKN' NE '').CALL4
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_NEXT,                       +
               &DESCTKN),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_NEXT,                       +
               &DESCTKN,&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_NEXT,                       +
               &DESCTKN,&ACTUALSZ,&ITEMTKN),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_NEXT,                       +
               &DESCTKN,&ACTUALSZ,&ITEMTKN,&CURTKN),VL
         MEXIT
.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_NEXT,                       +
               &DESCTKN,&ACTUALSZ,&ITEMTKN,&CURTKN,&HEADTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_FIND_PRIOR                                              *
* Purpose: Generate code to find the prior item for a descriptor.     *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_FIND_PRIOR &ID=,&SPEPA=,                                   +
               &SPTOKEN=,&DESCTKN=,&ITEMTKN=,&ACTUALSZ=,               +
               &CURTKN=,&HEADTKN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_FIND_PRIOR
         LCLC  &L_LENGTH
.*
.* FIND service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&HEADTKN' NE '').CALL5
         AIF   ('&CURTKN' NE '').CALL4
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_PRIOR,                      +
               &DESCTKN),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_PRIOR,                      +
               &DESCTKN,&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_PRIOR,                      +
               &DESCTKN,&ACTUALSZ,&ITEMTKN),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_PRIOR,                      +
               &DESCTKN,&ACTUALSZ,&ITEMTKN,&CURTKN),VL
         MEXIT
.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_PRIOR,                      +
               &DESCTKN,&ACTUALSZ,&ITEMTKN,&CURTKN,&HEADTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_FIND_OWNER                                              *
* Purpose: Generate code to find the owner item for a descriptor.     *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_FIND_OWNER &ID=,&SPEPA=,                                   +
               &SPTOKEN=,&DESCTKN=,&ITEMTKN=,&ACTUALSZ=,&CURTKN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_FIND_OWNER
         LCLC  &L_LENGTH
.*
.* FIND service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&CURTKN' NE '').CALL4
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_OWNER,                      +
               &DESCTKN),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_OWNER,                      +
               &DESCTKN,&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_OWNER,                      +
               &DESCTKN,&ACTUALSZ,&ITEMTKN),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_OWNER,                      +
               &DESCTKN,&ACTUALSZ,&ITEMTKN,&CURTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_FIND_FIRST                                              *
* Purpose: Generate code to find the first item for a descriptor.     *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_FIND_FIRST &ID=,&SPEPA=,                                   +
               &SPTOKEN=,&DESCTKN=,&ITEMTKN=,&ACTUALSZ=,&HEADTKN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_FIND_FIRST
         LCLC  &L_LENGTH
.*
.* FIND service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&HEADTKN' NE '').CALL4
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FIRST,                      +
               &DESCTKN),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FIRST,                      +
               &DESCTKN,&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FIRST,                      +
               &DESCTKN,&ACTUALSZ,&ITEMTKN),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FIRST,                      +
               &DESCTKN,&ACTUALSZ,&ITEMTKN,&HEADTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_FIND_FINAL                                              *
* Purpose: Generate code to find the final item for a descriptor.     *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_FIND_FINAL &ID=,&SPEPA=,                                   +
               &SPTOKEN=,&DESCTKN=,&ITEMTKN=,&ACTUALSZ=,&HEADTKN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_FIND_FINAL
         LCLC  &L_LENGTH
.*
.* FIND service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&HEADTKN' NE '').CALL4
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FINAL,                      +
               &DESCTKN),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FINAL,                      +
               &DESCTKN,&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FINAL,                      +
               &DESCTKN,&ACTUALSZ,&ITEMTKN),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_FIND_FINAL,                      +
               &DESCTKN,&ACTUALSZ,&ITEMTKN,&HEADTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_OBTAIN                                                  *
* Purpose: Generate code to obtain an item.                           *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_OBTAIN &ID=,&SPEPA=,&SPTOKEN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_OBTAIN                  SETC in open code.
         LCLC  &L_LENGTH
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&ITEM' NE '').ITEMOK
         MNOTE 8,'ITEM (address and length) is a required keyword.'
         MEXIT
.ITEMOK  AIF  ('&ITEMTKN' NE '').REQOKAY
         MNOTE 8,'ITEMTKN (item token) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Process the ITEM= keyword.
.*
          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.
          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for ITEM.'
          MEXIT
.ITEMSL   ANOP
&L_LENGTH SETC '&ITEM(2)'
          AGO .PASTITEM
.LGLITCH  ANOP
&L_LENGTH SETC '=A(L''&ITEM(1))'
.PASTITEM ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN,&ITEMTKN,                 +
               &L_LENGTH,&ITEM(1)),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN,&ITEMTKN,                 +
               &L_LENGTH,&ITEM(1),&ACTUALSZ),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_OBTAIN_BY_KEY                                           *
* Purpose: Generate code to obtain by key.                            *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_OBTAIN_BY_KEY &ID=,&SPEPA=,                                +
               &SPTOKEN=,&DESCTKN=,&KEY=,                              +
               &ITEM=,&ITEMTKN=,&ACTUALSZ=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_OBTAIN_BY_KEY
         LCLC  &L_LENGTH,&K_LENGTH
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&KEY' NE '').KEYOK
         MNOTE 8,'KEY (search key) is a required keyword.'
         MEXIT
.KEYOK   AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Process the KEY= keyword.
.*
          AIF   (N'&KEY EQ 2).KEYSL       Size and length specified.
          AIF   (N'&KEY EQ 1).KYLITCH     Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for KEY.'
          MEXIT
.KEYSL    ANOP
&K_LENGTH SETC '&KEY(2)'
          AGO .PASTKEY
.KYLITCH  ANOP
&K_LENGTH SETC '=A(L''&KEY(1))'
.PASTKEY ANOP
.*
.* Process the ITEM= keyword.
.*
          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.
          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for ITEM.'
          MEXIT
.ITEMSL   ANOP
&L_LENGTH SETC '&ITEM(2)'
          AGO .PASTITEM
.LGLITCH  ANOP
&L_LENGTH SETC '=A(L''&ITEM(1))'
.PASTITEM ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_BY_KEY,                   +
               &DESCTKN,&K_LENGTH,&KEY(1),                             +
               &L_LENGTH,&ITEM(1)),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_BY_KEY,                   +
               &DESCTKN,&K_LENGTH,&KEY(1),                             +
               &L_LENGTH,&ITEM(1),&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_BY_KEY,                   +
               &DESCTKN,&K_LENGTH,&KEY(1),                             +
               &L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_OBTAIN_CURRENT_OF_ITEM_TYPE                             *
* Purpose: Generate code to obtain current of item type.              *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_OBTAIN_CURRENT_OF_ITEM_TYPE &ID=,&SPEPA=,                  +
               &SPTOKEN=,&ITEMTYPE=,&ITEM=,&ITEMTKN=,&ACTUALSZ=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_OBTAIN_CURRENT_OF_ITEM_TYPE
         LCLC  &L_LENGTH
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&ITEM' NE '').ITEMOK
         MNOTE 8,'ITEM (address and length) is a required keyword.'
         MEXIT
.ITEMOK  AIF  ('&ITEMTYPE' NE '').REQOKAY
         MNOTE 8,'ITEMTYPE (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Process the ITEM= keyword.
.*
          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.
          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for ITEM.'
          MEXIT
.ITEMSL   ANOP
&L_LENGTH SETC '&ITEM(2)'
          AGO .PASTITEM
.LGLITCH  ANOP
&L_LENGTH SETC '=A(L''&ITEM(1))'
.PASTITEM ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_CURRENT_OF_ITEM_TYPE,     +
               &ITEMTYPE,&L_LENGTH,&ITEM(1)),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_CURRENT_OF_ITEM_TYPE,     +
               &ITEMTYPE,&L_LENGTH,&ITEM(1),&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_CURRENT_OF_ITEM_TYPE,     +
               &ITEMTYPE,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_OBTAIN_CURRENT_OF_DESCRIPTOR                            *
* Purpose: Generate code to obtain current of descriptor.             *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_OBTAIN_CURRENT_OF_DESCRIPTOR &ID=,&SPEPA=,                 +
               &SPTOKEN=,&DESCTKN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_OBTAIN_CURRENT_OF_DESCRIPTOR
         LCLC  &L_LENGTH
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&ITEM' NE '').ITEMOK
         MNOTE 8,'ITEM (address and length) is a required keyword.'
         MEXIT
.ITEMOK  AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Process the ITEM= keyword.
.*
          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.
          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for ITEM.'
          MEXIT
.ITEMSL   ANOP
&L_LENGTH SETC '&ITEM(2)'
          AGO .PASTITEM
.LGLITCH  ANOP
&L_LENGTH SETC '=A(L''&ITEM(1))'
.PASTITEM ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_CURRENT_OF_DESCRIPTOR,    +
               &DESCTKN,&L_LENGTH,&ITEM(1)),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_CURRENT_OF_DESCRIPTOR,    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_CURRENT_OF_DESCRIPTOR,    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_OBTAIN_NEXT                                             *
* Purpose: Generate code to obtain the next item for a descriptor.    *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_OBTAIN_NEXT &ID=,&SPEPA=,                                  +
               &SPTOKEN=,&DESCTKN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=,        +
               &CURTKN=,&HEADTKN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_OBTAIN_NEXT
         LCLC  &L_LENGTH
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&ITEM' NE '').ITEMOK
         MNOTE 8,'ITEM (address and length) is a required keyword.'
         MEXIT
.ITEMOK  AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Process the ITEM= keyword.
.*
          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.
          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for ITEM.'
          MEXIT
.ITEMSL   ANOP
&L_LENGTH SETC '&ITEM(2)'
          AGO .PASTITEM
.LGLITCH  ANOP
&L_LENGTH SETC '=A(L''&ITEM(1))'
.PASTITEM ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&HEADTKN' NE '').CALL5
         AIF   ('&CURTKN' NE '').CALL4
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_NEXT,                     +
               &DESCTKN,&L_LENGTH,&ITEM(1)),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_NEXT,                     +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_NEXT,                     +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_NEXT,                     +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN,         +
               &CURTKN),VL
         MEXIT
.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_NEXT,                     +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN,         +
               &CURTKN,&HEADTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_OBTAIN_PRIOR                                            *
* Purpose: Generate code to obtain the prior item for a descriptor.   *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_OBTAIN_PRIOR &ID=,&SPEPA=,                                 +
               &SPTOKEN=,&DESCTKN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=,        +
               &CURTKN=,&HEADTKN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_OBTAIN_PRIOR
         LCLC  &L_LENGTH
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&ITEM' NE '').ITEMOK
         MNOTE 8,'ITEM (address and length) is a required keyword.'
         MEXIT
.ITEMOK  AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Process the ITEM= keyword.
.*
          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.
          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for ITEM.'
          MEXIT
.ITEMSL   ANOP
&L_LENGTH SETC '&ITEM(2)'
          AGO .PASTITEM
.LGLITCH  ANOP
&L_LENGTH SETC '=A(L''&ITEM(1))'
.PASTITEM ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&HEADTKN' NE '').CALL5
         AIF   ('&CURTKN' NE '').CALL4
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_PRIOR,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1)),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_PRIOR,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_PRIOR,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_PRIOR,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN,         +
               &CURTKN),VL
         MEXIT
.CALL5   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_PRIOR,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN,         +
               &CURTKN,&HEADTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_OBTAIN_OWNER                                            *
* Purpose: Generate code to obtain the owner item for a descriptor.   *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_OBTAIN_OWNER &ID=,&SPEPA=,                                 +
               &SPTOKEN=,&DESCTKN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=,&CURTKN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_OBTAIN_OWNER
         LCLC  &L_LENGTH
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&ITEM' NE '').ITEMOK
         MNOTE 8,'ITEM (address and length) is a required keyword.'
         MEXIT
.ITEMOK  AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Process the ITEM= keyword.
.*
          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.
          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for ITEM.'
          MEXIT
.ITEMSL   ANOP
&L_LENGTH SETC '&ITEM(2)'
          AGO .PASTITEM
.LGLITCH  ANOP
&L_LENGTH SETC '=A(L''&ITEM(1))'
.PASTITEM ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&CURTKN' NE '').CALL4
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_OWNER,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1)),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_OWNER,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_OWNER,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_OWNER,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN,         +
               &CURTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_OBTAIN_FIRST                                            *
* Purpose: Generate code to obtain the first item associated with     *
*          a descriptor.
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_OBTAIN_FIRST &ID=,&SPEPA=,                                 +
               &SPTOKEN=,&DESCTKN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=,        +
               &HEADTKN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_OBTAIN_FIRST
         LCLC  &L_LENGTH
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&ITEM' NE '').ITEMOK
         MNOTE 8,'ITEM (address and length) is a required keyword.'
         MEXIT
.ITEMOK  AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Process the ITEM= keyword.
.*
          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.
          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for ITEM.'
          MEXIT
.ITEMSL   ANOP
&L_LENGTH SETC '&ITEM(2)'
          AGO .PASTITEM
.LGLITCH  ANOP
&L_LENGTH SETC '=A(L''&ITEM(1))'
.PASTITEM ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&HEADTKN' NE '').CALL4
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FIRST,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1)),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FIRST,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FIRST,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FIRST,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN,         +
               &HEADTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_OBTAIN_FINAL                                            *
* Purpose: Generate code to obtain the final item associated with     *
*          a descriptor.
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_OBTAIN_FINAL &ID=,&SPEPA=,                                 +
               &SPTOKEN=,&DESCTKN=,&ITEM=,&ITEMTKN=,&ACTUALSZ=,        +
               &HEADTKN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_OBTAIN_FINAL
         LCLC  &L_LENGTH
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
         AIF  ('&ITEM' NE '').ITEMOK
         MNOTE 8,'ITEM (address and length) is a required keyword.'
         MEXIT
.ITEMOK  AIF  ('&DESCTKN' NE '').REQOKAY
         MNOTE 8,'DESCTKN (item type) is a required keyword.'
         MEXIT
.REQOKAY ANOP
.*
.* Process the ITEM= keyword.
.*
          AIF   (N'&ITEM EQ 2).ITEMSL     Size and length specified.
          AIF   (N'&ITEM EQ 1).LGLITCH    Use length attribute.
          MNOTE 8,'Wrong number of parameters specified for ITEM.'
          MEXIT
.ITEMSL   ANOP
&L_LENGTH SETC '&ITEM(2)'
          AGO .PASTITEM
.LGLITCH  ANOP
&L_LENGTH SETC '=A(L''&ITEM(1))'
.PASTITEM ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&HEADTKN' NE '').CALL4
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&ACTUALSZ' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FINAL,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1)),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FINAL,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FINAL,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN),VL
         MEXIT
.CALL4   CALLX &#_IDEPA,(&#_IDTKN,&IM_OBTAIN_FINAL,                    +
               &DESCTKN,&L_LENGTH,&ITEM(1),&ACTUALSZ,&ITEMTKN,         +
               &HEADTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_STORE                                                   *
* Purpose: Generate code to store an item.                            *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         IM_STORE &ID=,&SPEPA=,&SPTOKEN=,&ITEM=,&ITEMTKN=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN
         GBLA  &IM_STORE                   SETC in open code.
         LCLC  &L_ITEM,&L_ITEMLEN
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=IM_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.* Check for the presence of required keywords.
.*
           AIF  ('&ITEM' NE '').ITEM
           MNOTE 8,'ITEM (address only) is a required keyword.'
           MEXIT
.ITEM      AIF (N'&ITEM EQ 1).ITEMONLY
           AIF (N'&ITEM EQ 2).ITEMLEN
           MNOTE 8,'Specify ITEM=item or ITEM=(item,length)'
           MEXIT
.ITEMONLY  ANOP
&L_ITEM    SETC  '&ITEM'
&L_ITEMLEN SETC  ''
           AGO   .ITEMOK
.ITEMLEN   ANOP
&L_ITEM    SETC  '&ITEM(1)'
&L_ITEMLEN SETC  '&ITEM(2)'
.ITEMOK    ANOP
.*
.* Generate the appropriate call statement.
.*
         AIF   ('&ITEMTKN' NE '').CALL3
         AIF   ('&L_ITEMLEN' NE '').CALL2
.CALL1   CALLX &#_IDEPA,(&#_IDTKN,&IM_STORE,&L_ITEM),VL
         MEXIT
.CALL2   CALLX &#_IDEPA,(&#_IDTKN,&IM_STORE,&L_ITEM,&L_ITEMLEN),VL
         MEXIT
.CALL3   CALLX &#_IDEPA,(&#_IDTKN,&IM_STORE,&L_ITEM,&L_ITEMLEN,        +
               &ITEMTKN),VL
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   IM_TEXT                                                    *
* Purpose: Generate the DC instructions for a description string.     *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
&NAME    IM_TEXT &STRING
&NAME    DC    AL1(##_&NAME._LENGTH)
         DC    C&STRING
##_&NAME._LENGTH EQU *-&NAME-1
         MEND
*---------------------------------------------------------------------*
*
*  Macro       IM_SFD
*
*  Abstract    This is the mapping macro for Sort Field Definitions
*              used by the IM_SORT function.
*
*---------------------------------------------------------------------*
         MACRO
         IM_SFD &DSECT=YES,&ID=SFD_
&I       SETC  '&ID'                  |
&CSECT   SETC  '&SYSECT'              |
         AIF   ('&DSECT' NE 'YES').NO_DSECT
&I.START DSECT                        | Start of TGX.
         AGO   .PAST_HEADER           |
.NO_DSECT ANOP                        |
&I.START DS    0F                     | Start of TGX.
.PAST_HEADER ANOP                     |
&I.ID                         DS CL4  | ID
&I.ID_TEXT                EQU C'SFD ' | Text of ID.
&I.ELEMENTS_IN_ARRAY          DS F    | Number of elements in array.
&I.SIZE_FIXED  EQU *-&I.START         | Size of fixed part of item.
&I.FIXED_PART  EQU &I.START,&I.SIZE_FIXED,C'X' Fixed part.
&I.ARRAY_START EQU *                  | Start of array.
&I.ELEMENT     EQU *                  | Definition of an element.
&I.OFFSET                  DS F       | Offset of field in item.
&I.LENGTH                  DS F       | Length of field in item.
&I.MASK    EQU &I.LENGTH              | For type BIT, last byte of
*                                     |   length is a mask, with bit(s)
*                                     |   to test turned on.
&I.TYPE                    DS H       | Type of field.
*                                     |  See &SFD_TYPE_... globals.
&I.F                       DS B       | Flag.
&I.F_DESCENDING       EQU B'10000000' |  Sort descending.
                           DS X       | Not used.
&I.SIZE_ELEMENT EQU *-&I.ELEMENT      | Size of one element of array.
         AIF   ('&DSECT' NE 'YES').MEXIT
&CSECT   CSECT ,                      |
.MEXIT   MEND                         |
