*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
         SMLIST CONVERT=YES           |
         srvmod name=srvdt,dates='1989, 1990, 1995'
         gblc  &srv_modname
         copy  ##prmopt
SRVDT TITLE "MVS Date/Time Service Processor"
*---------------------------------------------------------------------*
*
*  Copyright (C) Clemson University Research Foundation 1989, 1990.
*
*  Program     SRVDT, MVS Date/Time Service Processor.
*
*  Abstract    This service processor is environment-independent
*              and provides standardized Date/Time services.
*
*  Parameters:
*
*    DT_ID              ID=procid,
*                       ,SPepname=DT_epname
*                       ,SPepa=DT_epa
*                       ,SPtoken=DT_token
*                       ,ESID=esid_name
*                       ,ESVA=esva
*
*    DT_Start           ID=procid
*                       ,Format=American | European
*
*       CALLX  DT_epa,(DT_token,&DT_START,esva,gregorian_format)
*
*    DT_Terminate       ID=procid
*
*       CALLX  DT_epa,(DT_token,&DT_TERMINATE)
*
*    DT_Get_Current     ID=procid
*                       ,Date=(dateaddr,format)
*                       ,Time=(timeaddr,format)
*
*       CALLX  DT_epa,(DT_token,&DT_GET_CURRENT,
*                   dateaddr,format,timeaddr,format)
*
*    DT_Convert         ID=procid
*                       ,Fromdate=(input_date,format)
*                       ,Todate=(output_date,format)
*                       ,Fromtime=(input_time,format)
*                       ,Totime=(output_time,format)
*
*       CALLX  DT_epa,(DT_token,&DT_CONVERT,
*                       input_date,format,output_date,format,
*                       input_time,format,output_time,format)
*
* (continued)
*---------------------------------------------------------------------*
          eject
*---------------------------------------------------------------------*
*
*    DT_Add             ID=procid
*                       ,Datein=(date,format)
*                       ,Timein=(time,format)
*                       ,Interval=(interval,format)
*                       ,Dateout=(date,format)
*                       ,Timeout=(time,format)
*
*       CALLX  DT_epa,(DT_token,&DT_ADD,
*                       datein,format,timein,format,
*                       interval,format,
*                       dateout,format,timeout,format)
*
*    DT_Subtract        ID=procid
*                       ,Datein=(date,format)
*                       ,Timein=(time,format)
*                       ,Interval=(interval,format)
*                       ,Dateout=(date,format)
*                       ,Timeout=(time,format)
*
*       CALLX  DT_epa,(DT_token,&DT_Subtract,
*                       datein,format,timein,format,
*                       interval,format,
*                       dateout,format,timeout,format)
*
*    DT_Duration        ID=procid
*                       ,Date1=(date1,format)
*                       ,Date2=(date2,format)
*                       ,Time1=(time1,format)
*                       ,Time2=(time2,format)
*                       ,Interval=(interval,format)
*
*       CALLX  DT_epa,(DT_token,&DT_SUBTRACT,
*                       date1,format,date2,format,
*                       time1,format,time2,format,
*                       interval,format)
*
*    For complete descriptions of each function and parameter, refer
*    to the Service Processors Users Guide And Reference.
*
*---------------------------------------------------------------------*
          eject
*---------------------------------------------------------------------*
*
*  Return codes:
*
*   For a complete list of possible return codes for each function,
*   refer to the Service Processors Users Guide And Reference.
*
*  Program     Reentrant, problem key and state, server linkage,
*  Attributes  non-authorized, AMODE(any), RMODE(any)
*
*  Change
*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution
*
*  Method of
*  Operation   Refer to the code
*
*
*  Special Notes: None
*
*
*---------------------------------------------------------------------*
 space 1                              |
 print off                            |
 copy  smsyms                         | Structured Macros symbols.
 copy  smpucond                       | DEFUCOND user conditions.
 copy  srvesmac                       | Environment support symbols.
 copy  srvstmac                       | String Formatter symbols.
 copy  srvdtmac                       | Date/Time symbols.
 print on,gen                         |
 eject                                |
**--------------------------------------------------------------------*
**
**               Date/Time Conversion Aid Macros
**
**--------------------------------------------------------------------*
 space 1                              |
          macro                       |
  Convert_Juldate_To_Days &Juldate=,&Work=,&Days=
.*--------------------------------------------------------------------*
.* Macro:      Convert_Juldate_To_Days
.* Purpose:    Convert a Julian date into the number of days since
.*             January 1, 0000.  The answer is placed in a register.
.* Syntax:     Convert_Juldate_To_Days Juldate=address
.*                                     Work=doubleword,
.*                                     Days=register (don't use R1!)
.* Notes:      The code generated by this macro uses R0, R1, & R15.
.*             If you code a register in the address (ex. you want to
.*             convert the field at 0(R2), code it as 0(4,R2) since
.*             the macro uses ZAP to copy the field.
.*--------------------------------------------------------------------*
.*xc    &work.(4),&work               |
.*mvc   &work+4(4),&juldate           |
  zap   &work,&juldate                | Copy juldate, clear hi word
  cvb   r1,&work                      |
  st    r1,&work                      |
  callsub Convert_Ijuldate_To_Gregorian,                               *
               (pwa_i_month,pwa_i_day,pwa_i_year,&work),novl
  callsub Convert_Gregorian_To_Days,(*,*,*,*),novl
  l     &days,&work                   |
          mend                        |
          macro                       |
  Convert_Days_To_DT_Units  &reg=R0   |
.*--------------------------------------------------------------------*
.* Macro:      Convert_Days_To_DT_Units
.* Purpose:    Convert a number of days since 1/1/0000 (like that pro-
.*             duced by Convert_Juldate_To_Days) to a number of micro-
.*             seconds.  The result appears in the register pair named
.*             by 'reg=', which must denote an even-numbered register.
.* Syntax:     Convert_Days_To_DT_Units  reg=register | _R0_
.* Notes:      This routine will multiply the number of days since
.*             Jan. 1, 0000  by the number of microseconds in a day:
.*                   24   *   60   *   60   *   10**6
.*             This won't fit into a fullword, so it is reduced to:
.*                -> 8*3  *  4*15  *  4*15  *  (15625 * 2**6)
.*                ->  3   *   15   *   15   *   15625   *   2**13
.*             The 2**13 is handled by a double shift.
.*--------------------------------------------------------------------*
  m     &reg.,=a(3*15*15*15625)       | Multiply days by (...)
  sldl  &reg.,13                      | Multiply by 2**13
          mend                        |
         macro                        |
  Convert_DT_Units_To_Days  &Units=,&Reg=R0
.*--------------------------------------------------------------------*
.* Macro:      Convert_DT_Units_To_Days
.* Purpose:    Convert a number of microseconds since 1/1/0000 to the
.*             number of days since 1/1/0000.
.* Syntax:     Convert_DT_Units_To_Days Days=address,
.*                                      Reg=register | _R0_
.* Notes:      This routine will multiply the number of days since
.*             Jan. 1, 0000  by the number of microseconds in a day:
.*                   24   *   60   *   60   *   10**6
.*             This won't fit into a fullword, so it is reduced to:
.*                -> 8*3  *  4*15  *  4*15  *  (15625 * 2**6)
.*                ->  3   *   15   *   15   *   15625   *   2**13
.*             The 2**13 is handled by a double shift.
.*          .. The result will be in (reg+1) at the end, as the quot-
.*             ient of the 'divide' at the end.  Ex: if "REG=R0" is
.*             used, the answer appears in R1.
.*--------------------------------------------------------------------*
  lclc   &reg2                        |
  aif    ('&reg'(1,1) ne 'R').regerr  |
  aif    ('&reg' eq 'R0').setr0       |
  aif    ('&reg' eq 'R2').setr2       |
  aif    ('&reg' eq 'R4').setr4       |
  aif    ('&reg' eq 'R6').setr6       |
  aif    ('&reg' eq 'R8').setr8       |
  aif    ('&reg' eq 'R10').setr10     |
  aif    ('&reg' eq 'R12').setr12     |
  aif    ('&reg' eq 'R14').setr14     |
.regerr  mnote 8,"Register specification of &REG is invalid."
         mexit                        |
.setr0   anop ,                       |
&reg2    setc  'R1'                   |
         ago   .code                  |
.setr2   anop ,                       |
&reg2    setc  'R3'                   |
         ago   .code                  |
.setr4   anop ,                       |
&reg2    setc  'R5'                   |
         ago   .code                  |
.setr6   anop ,                       |
&reg2    setc  'R7'                   |
         ago   .code                  |
.setr8   anop ,                       |
&reg2    setc  'R9'                   |
         ago   .code                  |
.setr10  anop ,                       |
&reg2    setc  'R11'                  |
         ago   .code                  |
.setr12  anop ,                       |
&reg2    setc  'R13'                  |
         ago   .code                  |
.setr14  anop ,                       |
&reg2    setc  'R15'                  |
.code    anop  ,                      |
   lm    &reg.,&reg2.,&units          | Load doubleword units value
   srdl  &reg.,13                     | Divide by 2**13
   d     r0,=a(3*15*15*15625)         |  then by remaining
         mend  ,                      |
         macro                        |
  Convert_Days_To_Juldate &Days=R1,&Work=,&Juldate=
.*--------------------------------------------------------------------*
.* Macro:      Convert_Days_To_Juldate
.* Purpose:    Convert number of days since 1/1/0000 to a Julian date.
.* Syntax:     Convert_Days_To_Juldate Days=register | _R1_,
.*                                     Work=doubleword,
.*                                     Juldate=julian_date_address
.* Notes:      The code generated by this macro uses R0, R1, R14 & R15.
.*--------------------------------------------------------------------*
  st    r1,&work                      |
  callsub Convert_Days_To_Gregorian,  |                                *
               (pwa_i_month,pwa_i_day,pwa_i_year,&work),novl
  callsub Convert_Gregorian_To_Ijuldate,(*,*,*,*),novl
  l     r1,&work                      |
  cvd   r1,&work                      |
  l     r1,&work+4                    |
  st    r1,&juldate                   |
         mend                         |
         macro                        |
  Validate_Packed_Data   &Data=,&Len=,&Type=DATE
.*--------------------------------------------------------------------*
.* Macro:      Validate_Packed_Data
.* Purpose:    Attempt to ensure packed-decimal input is valid and
.*             won't cause an 0C7.
.* Syntax:     Validate_Packed_Data Data=<RX address>,Len=<integer>
.* Notes:      The code generated by this macro uses R15, R1, and R2.
.*             If someone wants to make the macro smart enough to pick
.*             apart any form of RX address someday, the use of field
.*             pwa_packed_validation can be removed.
.*        ---> Don't use R15 to point to the input field: the macro
.*             wipes out the contents of R15.
.*             Thanks to John Fisher (FISHER@RPIECS) for the basic
.*             routine.
.*--------------------------------------------------------------------*
    gbla  &dt_invalid_input_date      | Globals for the errexit
    gbla  &dt_invalid_input_time      |
    gbla  &dt_invalid_input_interval  |
    lcla  &errcode                    | Local errexit code
.*--------------------------------------------------------------------*
  sr    r2,r2                         | Clear R2
  la    r15,pwa_packed_validation+&len.-1   | Get addr end of input
  mvc   pwa_packed_validation(&len.),&data  | Copy input to workarea
  trt   pwa_packed_validation(&len.),psd_packed_table | Check out data:
  cr    r1,r15                        | R1 should -> last byte: else,
  jne   inv&sysndx                    |  it's an error.
  l     r15,=a(jmp&sysndx)
  ar    r15,r2
  br    r15
jmp&sysndx  ds  0h                    | If we got a hit, check it out.
  j     inv&sysndx                    | Byte of 00: no sign on it.
  j     inv&sysndx                    | Byte of 04: it's not valid.
  j     ok&sysndx                     | Byte of 08: it's a valid sign.
inv&sysndx ds 0h                      |
         aif   ('&type' ne 'DATE').chktime
&errcode seta  &dt_invalid_input_date
         ago   .errex
.chktime aif   ('&type' ne 'TIME').chkint
&errcode seta  &dt_invalid_input_time
         ago   .errex
.chkint  aif   ('&type' ne 'INTERVAL').badtype
&errcode seta  &dt_invalid_input_interval
         ago   .errex
.badtype mnote 8,"Invalid data type of &TYPE.: must be DATE, TIME or IN*
               TERVAL".
         mexit
.errex   anop
  errexit code=&errcode               | Generate error rtn. call
ok&sysndx  ds 0h                      |
         mend                         |
 eject                                |
**--------------------------------------------------------------------*
**
**  Identify the service processors that Date/Time will use.
**
**--------------------------------------------------------------------*
       space 1                        |
 es_id         id=ES,                 |                                *
               spepa=pwa_ES_epa,      |                                *
               sptoken=pwa_ES_token,  |                                *
               esva=pwaaesv           |
       space 1                        |
 st_id         id=ST,                 |                                *
               spepname=&String_Handler,                               *
               spepa=pwa_ST_epa,      |                                *
               sptoken=pwa_ST_token,  |                                *
               sizelength=2,          |                                *
               esid=ES                |
       space 1                        |
 title "SRVDT -- Initialization"      |
 block name=&srv_modname,type=program,amode=31,rmode=any,              *
               options=(*srvprc,noclearpwa,long,loctr,                 *
               (parms,(using,r11),(count,pwa_number_of_parms),         *
               copy,(copyerror,,&dt_invalid_number_of_parms),vl)),     *
               parmmap=(parmlist,prm_max_len),                         *
               basereg=(r12,r9,r8),   |                                *
               subopts=(*swa,loadbase)
* *-------------------------------------------------------------------*
* * If the function code is something other than start, make sure that
* * the PWA contains the eye-catcher string and the correct value for
* * DT_ID.   If not, then the DT_ID passed in is garbage.
* *-------------------------------------------------------------------*
  l     r1,pwa_number_of_parms        |
  errexit (ch,r1,lt,=y(prm_min_#)),   | Choke for too few parms        *
               code=&dt_invalid_number_of_parms
  l     r1,prm_functioncode           | Load the function code into
  l     r1,0(,r1)                     |   a register for testing.
  if (c,r1,ne,=f'&DT_start')          | If not startup function then
   errexit ((clc,pwa_visual,ne,eyecatcher),or,(c,r13,ne,pwa_DT_id)),   +
               code=&DT_invalid_DT_id |  go off and croak.
  endif                               | Endif.
   title "SRVDT -- DT_Start Function" |
* *-------------------------------------------------------------------*
* * Select the code to process the function.
* *-------------------------------------------------------------------*
  caseblk reg=r1                      | Start of function case block.
  space 1                             |
*  *------------------------------------------------------------------*
*  *
*  * Start function.
*  *
*  *------------------------------------------------------------------*
   case &DT_start                     |  Start function.
*   *-----------------------------------------------------------------*
*   * Set the eyecatcher and the DT_ID fields.   These are checked
*   * each time the PL server is entered to avoid integrity
*   * problems.
*   *-----------------------------------------------------------------*
    mvc   pwa_visual,eyecatcher       |   Both the eyecatcher and the
    st    r13,pwa_DT_id               |   DT_ID are for validity checks
    xc    pwa_clear_start(pwa_clear_length),pwa_clear_start
*   *-----------------------------------------------------------------*
*   * Make sure that a valid number of parameters are specified.
*   *-----------------------------------------------------------------*
    l     r3,pwa_number_of_parms      |   Load r3 with number of parms.
    errexit    (ch,r3,lt,=y(prm_start_min_#)),or,   Error if out       +
               (ch,r3,gt,=y(prm_start_max_#)),      of bounds.         +
               code=&DT_invalid_number_of_parms
    space 1                           |
    l    r1,prm_start_esv             |
    l    r1,0(,r1)                    |
    st   r1,pwa_esv                   |
    using esv,r1                      |
    mvc   pwa_es_epa,esvesepa         |
    mvc   pwa_es_token,esvestkn       |
    drop  r1                          |
         space 1                      |
*   *-----------------------------------------------------------------*
*   * Always start a String Formatter session.
*   *-----------------------------------------------------------------*
    sbit  pwaf1sst                    | Note we started a String Hdlr
    ES_Load_Module  id=ES,spid=ST     | Load string formatter.
    errexit    (treg,r15,nz),         |                                *
               code=&DT_environment_support_error
    ST_Start   ID=ST                  | Start string formatter.
    errexit    (treg,r15,nz),         |                                *
               code=&DT_string_handler_error
*   *-----------------------------------------------------------------*
*   * Set Gregorian and Leading_Zeros options.
*   *-----------------------------------------------------------------*
    if    (clc,pwa_number_of_parms,gt,=a(prm_start_min_#))
     l32   r1,prm_start_options       |
     if    nz                         |
      if    (tbit,0(r1),x'80')        |
       sbit  pwaf1eur                 |
      endif                           |
      if    (tbit,0(r1),x'40')        |
       sbit  pwaf1lz                  |
      endif                           |
     endif                            |
    endif                             |
*   *-----------------------------------------------------------------*
   title "SRVDT -- DT_Terminate Function"
*  *------------------------------------------------------------------*
*  *
*  * Terminate function.
*  *
*  *------------------------------------------------------------------*
   case &DT_terminate                 |
*   *-----------------------------------------------------------------*
*   * If a String Handler session was started, shut it down.
*   *-----------------------------------------------------------------*
    if    (tbit,pwaf1sst)             |
     ST_Terminate ID=ST               |
     rbit  pwaf1sst                   | (In case someone needs to know)
     ES_Unload_Module  id=ES,spid=ST  | Get rid of ST's loadmodule
    endif                             |
*   *-----------------------------------------------------------------*
*   * Indicate PWA should be freed.
*   *-----------------------------------------------------------------*
    smctrl freepwa=yes                |   Free the PWA on return.
*   *-----------------------------------------------------------------*
   title "SRVDT -- DT_Get_Current Function"
*  *------------------------------------------------------------------*
*  *
*  *   Get_Current function.
*  *
*  *------------------------------------------------------------------*
   case &DT_Get_Current               |
    space 1                           |
    es_get_time  id=ES,               |   Get current date/time from   *
               time=pwa_ES_current_time,      Environment Support      *
               date=pwa_ES_current_date
    errexit  (treg,r15,nz),           |                                *
               code=&DT_Environment_Support_Error
    space 1                           |
    callsub  call_convert_input,      |       Convert date and time    *
               (pwa_dt_format_time,   |       to format requested by   *
               pwa_ES_current_date,   |              caller.           *
               &dt_ES_format,         |                                *
               pwa_ES_current_time,   |                                *
               &dt_ES_format)         |
    space 1                           |
    lm    r2,r5,prm_get_current_date  |
    callsub  call_convert_output,     | Convert internal format        *
               (pwa_dt_format_time,   | to format requested by         *
               (r2),(r3),(r4),(r5)),  |        caller.                 *
               novl                   |
*  *------------------------------------------------------------------*
   title "SRVDT -- DT_Convert Function"
*  *------------------------------------------------------------------*
*  *
*  *   Convert function.
*  *
*  *------------------------------------------------------------------*
   case &DT_Convert                   |
    space 1                           |
    lm    r2,r5,prm_convert_fromdate
    callsub  call_convert_input,      |       Convert date and time    *
               (pwa_dt_format_time,   |       to internal format.      *
               (r2),(r3),(r4),(r5)),  |                                *
               novl                   |
    space 1                           |
    lm    r2,r5,prm_convert_todate    |
    callsub  call_convert_output,     |       Convert internal format  *
               (pwa_dt_format_time,   |       to format requested by   *
               (r2),(r3),(r4),(r5)),  |               caller.          *
               novl                   |
*  *------------------------------------------------------------------*
   title "SRVDT -- DT_Add Function"   |
*  *------------------------------------------------------------------*
*  *
*  *   Add function.
*  *
*  *------------------------------------------------------------------*
   case &DT_Add                       |
    rbit  pwaf1rev                    | See if anyone sets reverse-sign
*   *-----------------------------------------------------------------*
*   *  First, convert input date and/or time values to internal format.
*   *-----------------------------------------------------------------*
    lm    r2,r5,prm_add_datein        |
    callsub  call_convert_input,      |       Convert date and time    *
               (pwa_dt_format_time,   |       to internal format.      *
               (r2),(r3),(r4),(r5)),  |                                *
               novl                   |
*   *-----------------------------------------------------------------*
*   *  Next, convert interval to internal format.
*   *-----------------------------------------------------------------*
    lm    r2,r3,prm_add_interval
    callsub  call_convert_input_interval,     Convert input interval   *
               (pwa_dt_format_interval,(r2),(r3)), to internal format. *
               novl                   |
*   *-----------------------------------------------------------------*
*   *  Add input date/time and converted interval.
*   *-----------------------------------------------------------------*
    lm    r14,r15,pwa_dt_format_interval
    lm    r0,r1,pwa_dt_format_time    |
    if    (tbit,pwaf1rev,off)         | If sign not reversed
     ar    r0,r14                     | Add-logical upper half
     alr   r1,r15                     | Add-logical lower half
     if    not,(cc12)                 | If overflow in low half
      ah    r0,=h'1'                  |  carry a 1 to high 4 bytes.
     endif                            |
    else
     slr   r1,r15                     | Subtract-logical lower half
     if    (cc12)                     |
      sh    r0,=h'1'                  |
     endif                            |
     sr    r0,r14                     |
    endif
    stm   r0,r1,pwa_dt_format_time    | Save result for output cnvt.
       eject ,                        |
*   *-----------------------------------------------------------------*
*   *  Now, convert result to output format and return to caller.
*   *-----------------------------------------------------------------*
    lm    r2,r5,prm_add_dateout       |
    callsub  call_convert_output,     |       Convert internal format  *
               (pwa_dt_format_time,   |       to format requested by   *
               (r2),(r3),(r4),(r5)),  |               caller.          *
               novl                   |
*  *------------------------------------------------------------------*
   title "SRVDT -- DT_Subtract Function"
*  *------------------------------------------------------------------*
*  *
*  *   Subtract function.
*  *
*  *------------------------------------------------------------------*
   case &DT_Subtract                  |
    rbit  pwaf1rev                    | See if anyone sets reverse-sign
*   *-----------------------------------------------------------------*
*   *  First, convert input date and/or time values to internal format.
*   *-----------------------------------------------------------------*
    lm    r2,r5,prm_subtract_datein   |
    callsub  call_convert_input,      |       Convert date and time    *
               (pwa_dt_format_time,   |       to internal format.      *
               (r2),(r3),(r4),(r5)),  |                                *
               novl                   |
*   *-----------------------------------------------------------------*
*   *  Next, convert interval to internal format.
*   *-----------------------------------------------------------------*
    lm    r2,r3,prm_subtract_interval |
    callsub  call_convert_input_interval,     Convert input interval   *
               (pwa_dt_format_interval,(r2),(r3)), to internal format. *
               novl                   |
*   *-----------------------------------------------------------------*
*   *  Subtract input date/time and converted interval.
*   *-----------------------------------------------------------------*
    lm    r14,r15,pwa_dt_format_interval
    lm    r0,r1,pwa_dt_format_time    |
    if    (tbit,pwaf1rev)             | Sign rev'd due to negative int?
     ar    r0,r14                     |  Add-logical upper half
     alr   r1,r15                     |  Add-logical lower half
     if    not,(cc12)                 |  If overflow in low half
      ah    r0,=h'1'                  |   carry a 1 to high 4 bytes.
     endif                            |
    else
     slr   r1,r15                     | Subtract-logical lower half
     if    (cc12)                     |
      sh    r0,=h'1'                  |
     endif                            |
     sr    r0,r14                     |
    endif
    stm   r0,r1,pwa_dt_format_time    | Save result for output cnvt.
        eject ,
*   *-----------------------------------------------------------------*
*   *  Now, convert result to output format and return to caller.
*   *-----------------------------------------------------------------*
    lm    r2,r5,pRM_subtract_dateout  |
    callsub  call_convert_output,     |       Convert internal format  *
               (pwa_dt_format_time,   |       to format requested by   *
               (r2),(r3),(r4),(r5)),  |               caller.          *
               novl                   |
*---------------------------------------------------------------------*
   title "SRVDT -- DT_Duration Function"
*  *------------------------------------------------------------------*
*  *
*  *   Duration function.
*  *
*  *------------------------------------------------------------------*
   case &DT_Duration                  |
*   *-----------------------------------------------------------------*
*   *  First, convert input date and/or time values to internal format.
*   *-----------------------------------------------------------------*
    lm    r2,r5,prm_duration_date1    |
    callsub  call_convert_input,      |       Convert date and time    *
               (pwa_dt_format_time,   |       to internal format.      *
               (r2),(r3),(r4),(r5)),  |                                *
               novl                   |
*   *-----------------------------------------------------------------*
*   * Convert 2nd set of date/time values to internal format.
*   *-----------------------------------------------------------------*
    lm    r2,r5,prm_duration_date2    |
    callsub  call_convert_input,      |       Convert date and time    *
               (pwa_dt_format_time2,  |       to internal format.      *
               (r2),(r3),(r4),(r5)),  |                                *
               novl                   |
            eject ,
*   *-----------------------------------------------------------------*
*   *  Now, see what the difference between them is.
*   *-----------------------------------------------------------------*
    if    (clc,pwa_dt_format_time,gt,pwa_dt_format_time2)
     lm    r0,r1,pwa_dt_format_time   |  Get larger value in R0-R1
     lm    r14,r15,pwa_dt_format_time2
    else                              |
     lm    r0,r1,pwa_dt_format_time2  |
     lm    r14,r15,pwa_dt_format_time |
    endif                             |
    slr   r1,r15                      | Duration-logical lower half
    if    (cc12)                      |
     sh    r0,=h'1'                   |
    endif                             |
    sr    r0,r14                      |
    stm   r0,r1,pwa_dt_format_time    | Save result for output cnvt.
*   *-----------------------------------------------------------------*
*   *  Now, convert result to output format and return to caller.
*   *-----------------------------------------------------------------*
    lm    r2,r3,prm_duration_duration |
    callsub  call_convert_output_interval,    Convert internal format  *
               (pwa_dt_format_time,   |       to format requested by   *
               (r2),(r3)),novl        |               caller.
*---------------------------------------------------------------------*
  endcase                             |
 endblk rc=0                          | If no errexit, end RC zero.
 title "Format Validation Routines"   |
*---------------------------------------------------------------------*
*
*  All format validation routines have the following characteristics:
*    .. Each uses field PWA_Validate_R14 to save R14.
*    .. R14-R2 may be destroyed.  R15 will contain a return code.
*    .. Each of these subroutines uses *nosubopts: hence, they run
*       under the procedure base(s) of the mainline.
*    .. Each format validation routine will attempt to fully validate
*       a date or time format: once passed by one of these routines, a
*       date/time converter should not need to do its own validation.
*    .. Some of these routines may use PWA fields: cases are noted as
*       they occur.  Results stored in the PWA may be used by callers.
*
*---------------------------------------------------------------------*
 space 3                              |
*---------------------------------------------------------------------*
*  Subroutine: Validate_Julian_Formats
*     Purpose: Ensure CPL_Date points to valid Julian date of one of
*              the supported Julian formats:
*                Julian   -- 7-digit date (1989359)
*                Juliand  -- 7-digit w/decimal (1989.359)
*                Sjulian  -- 5-digit date (89359)
*                Sjuliand -- 5-digit w/decimal (89.359)
*       Input: On entry, R1 points to a CPL.
*      Output: R15 = 0 if date is valid, else R15 = 8.
*---------------------------------------------------------------------*
 block name=validate_julian_formats,  |                                *
               type=subroutine,       |                                *
               options=*nosubopts,    |                                *
               save=(r14,pwa_validate_r14)
  using cpl,r1                        |
  la    r15,8                         | Set default failure RC.
  l     r14,cpl_date                  | Point to date to validate
  drop  r1
  if    (tbit,pwa_julian_flags,pwa_julian)    Julian (C'yyyyddd'):
   if    (%trt,0(7,r14),ne,psd_numeric_table)    If not numeric, rc 8.
    leave block=*                     |
   endif                              |
  elseif (tbit,pwa_julian_flags,pwa_sjulian)  Sjulian (C'yyddd'):
   if    (%trt,0(5,r14),ne,psd_numeric_table)    If not numeric, rc 8.
    leave block=*                     |
   endif                              |
  elseif (tbit,pwa_julian_flags,pwa_juliand)  Juliand (C'yyyy.ddd'):
   if    (%trt,0(4,r14),ne,psd_numeric_table),or,      If not numeric, *
               (%trt,5(3,r14),ne,psd_numeric_table),or,  w/decimal,    *
               (cli,4(r14),ne,c'.')   |
    leave block=*                     |
   endif                              |
  elseif (tbit,pwa_julian_flags,pwa_sjuliand) Sjuliand (C'yy.ddd'):
   if    (%trt,0(2,r14),ne,psd_numeric_table),or,   If not numeric,    *
               (%trt,3(3,r14),ne,psd_numeric_table),or,  w/decimal,    *
               (cli,2(r14),ne,c'.')   |
    leave block=*                     |
   endif                              |
  endif                               | If we got this far,
  xr    r15,r15                       |   it must be OK.
 endblk rc=(r15)                      |
 eject                                |
*---------------------------------------------------------------------*
*  Subroutine: Validate_Gregorian_Formats
*     Purpose: Ensure CPL_Date points to a valid Gregorian date of one
*              of the following formats:
*                Gregorian  -- Normal Gregorian (12/25/1989, 1/3/1990,
*                              4/15/1991 and 03/04/1990 are all valid)
*                Sgregorian -- Short Gregorian (12/25/89,1/3/90,4/15/91
*                              03/04/90 are all valid)
*                Sortdate   -- Sortable date w/dashes (1989-12-25)
*                Ssortdate  -- Short sortable date (19-12-25)
*       Input: On entry, R1 points to a CPL.
*      Output: R15 = 0 if date is valid, else R15 = 8.
*        Note: This routine fills in the following PWA fields:
*              PWA_Numeric_Day   PWA_Numeric_Month  PWA_Numeric_Year
*---------------------------------------------------------------------*
 block name=validate_gregorian_formats,                                *
               type=subroutine,       |                                *
               options=*nosubopts,    |                                *
               save=(r14,pwa_validate_r14)
  using cpl,r1                        |
  la    r15,8                         | Set default 'failure' rc.
  l     r14,cpl_date                  | Point to incoming date
  drop  r1                            |
  mvc   pwa_numeric_day,=c'00'        | Set all day, month, year digits
  mvc   pwa_numeric_month,=c'00'      |  to c'00's
  mvc   pwa_numeric_year,=c'0000'     |
  if    (tbit,pwa_gregorian_flags,pwa_gregorian),or,  C'mm/dd/yyyy' or *
               (tbit,pwa_gregorian_flags,pwa_sgregorian)  C'mm/dd/yy':
   if    (%trt,0(2,r14),eq,psd_numeric_table),and,  Is 1st thing       *
               (cli,2(r14),eq,c'/')   |            2 digits long?
    if   (tbit,pwaf1eur)              |  If European format
     mvc  pwa_numeric_day(2),0(r14)   |   it's the day,
    else                              |  else
     mvc  pwa_numeric_month(2),0(r14) |   it's the month.
    endif                             |
    la   r14,3(r14)                   |  Point past it.
   elseif (%trt,0(1,r14),eq,psd_numeric_table),and,  Else is 1st thing *
               (cli,1(r14),eq,c'/')   |                1 digit long?
    if   (tbit,pwaf1eur)              |  If European format
     mvc  pwa_numeric_day+1(1),0(r14) |   it's the day,
    else                              |  else
     mvc  pwa_numeric_month+1(1),0(r14)   it's the month.
    endif                             |
    la   r14,2(r14)                   |  Point past it.
   else                               | Else
    leave block=*                     |  invalid format.
   endif                              |
   if    (%trt,0(2,r14),eq,psd_numeric_table),and,  Is 2nd thing       *
               (cli,2(r14),eq,c'/')   |            2 digits long?
    if   (tbit,pwaf1eur)              |  If European format
     mvc  pwa_numeric_month(2),0(r14) |   it's the month,
    else                              |  else
     mvc  pwa_numeric_day(2),0(r14)   |   it's the day.
    endif                             |
    la   r14,3(r14)                   |  Point past it.
   elseif (%trt,0(1,r14),eq,psd_numeric_table),and,  Else is 2nd thing *
               (cli,1(r14),eq,c'/')   |                1 digit long?
    if   (tbit,pwaf1eur)              |  If European format
     mvc  pwa_numeric_month+1(1),0(r14)   it's the month,
    else                              |  else
     mvc  pwa_numeric_day+1(1),0(r14) | it's the day.
    endif                             |
    la   r14,2(r14)                   |  Point past it.
   else                               | Else
    leave block=*                     |  invalid format.
   endif                              |
   if    (tbit,pwa_gregorian_flags,pwa_sgregorian)  If short-Gregorian
    leave block=*,(%trt,0(2,r14),ne,psd_numeric_table)  Need 2 digits
    mvc   pwa_numeric_year(2),psd_default_century    Force 20th century
    mvc   pwa_numeric_year+2(2),0(r14)                and append years.
   else                               | Otherwise (normal Gregorian)
    leave block=*,(%trt,0(4,r14),ne,psd_numeric_table)  Need 4 digits
    mvc   pwa_numeric_year,0(r14)     |             Move 4 year digits.
   endif                              |
      eject ,                         |
  elseif (tbit,pwa_gregorian_flags,pwa_sortdate)      C'yyyy-mm-dd':
   if          (%trt,0(4,r14),ne,psd_numeric_table),or,                *
               (%trt,5(2,r14),ne,psd_numeric_table),or,                *
               (cli,4(r14),ne,c'-'),or,                                *
               (cli,7(r14),ne,c'-'),or,                                *
               (%trt,8(2,r14),ne,psd_numeric_table)
    leave block=*                     |
   endif                              |
   mvc   pwa_numeric_year,0(r14)      |
   mvc   pwa_numeric_month,5(r14)     |
   mvc   pwa_numeric_day,8(r14)       |
  elseif (tbit,pwa_gregorian_flags,pwa_ssortdate) C'yy-mm-dd':
   if          (%trt,0(2,r14),ne,psd_numeric_table),or,                *
               (%trt,3(2,r14),ne,psd_numeric_table),or,                *
               (cli,2(r14),ne,c'-'),or,                                *
               (cli,5(r14),ne,c'-'),or,                                *
               (%trt,6(2,r14),ne,psd_numeric_table)
    leave block=*                     |
   endif                              |
   mvc   pwa_numeric_year(2),psd_default_century
   mvc   pwa_numeric_year+2(2),0(r14) |
   mvc   pwa_numeric_month,3(r14)     |
   mvc   pwa_numeric_day,6(r14)       |
  endif                               |
  xr    r15,r15                       | Hmmm, must be OK.
 endblk rc=(r15)                      |
 eject                                |
*---------------------------------------------------------------------*
*  Subroutine: Validate_Normal_Formats
*     Purpose: Ensure CPL_Date points to valid Normal date of the form
*              'dd mon yyyy' (ex. C'01 Jan 1990'), or a valid Snormal
*              date of the form 'dd mmm yy' (ex. 01 Jan 90').
*       Input: On entry, R1 points to a CPL.
*      Output: R15 = 0 if date is valid, else R15 = 8.
*       Notes: The following PWA fields are used by this routine:
*                   pwa_text_month           pwa_i_month
*                   pwa_numeric_day          pwa_i_day
*                   pwa_numeric_year         pwa_i_year
*---------------------------------------------------------------------*
 block name=validate_normal_formats,  |                                *
               type=subroutine,       |                                *
               options=*nosubopts,    |                                *
               save=(r14,pwa_validate_r14)
  using cpl,r1                        |
  l     r14,cpl_date                  |
  la    r15,8
  drop  r1
* *-------------------------------------------------------------------*
  if    (tbit,pwa_normal_flags,pwa_normal)             C'dd mon yyyy':
   if       ((%trt,0(1,r14),ne,psd_numeric_table),and,                 *
               (cli,0(r14),ne,c' ')),or,                               *
               (%trt,1(1,r14),ne,psd_numeric_table),or,                *
               (cli,2(r14),ne,c' '),or,                                *
               (cli,6(r14),ne,c' '),or,                                *
               (%trt,7(4,r14),ne,psd_numeric_table)
    leave block=*                     |
   endif                              |
   mvc   pwa_numeric_year,7(r14)      | Get years from input date
   mvc   pwa_numeric_day(2),0(r14)    | Extract the days.
   mvc   pwa_text_month(3),3(r14)     | Extract out the month.
* *-------------------------------------------------------------------*
  elseif (tbit,pwa_normal_flags,pwa_snormal)        C'dd mon yy':
   if       ((%trt,0(1,r14),ne,psd_numeric_table),and,                 *
               (cli,0(r14),ne,c' ')),or,                               *
               (%trt,1(1,r14),ne,psd_numeric_table),or,                *
               (cli,2(r14),ne,c' '),or,                                *
               (cli,6(r14),ne,c' '),or,                                *
               (%trt,7(2,r14),ne,psd_numeric_table)
    leave block=*                     |
   endif                              |
   mvc   pwa_numeric_year(2),psd_default_century Force 20th century
   mvc   pwa_numeric_year+2(2),7(r14) |        and append years.
   mvc   pwa_numeric_day(2),0(r14)    | Extract the days.
   mvc   pwa_text_month,3(r14)        |
        eject ,
* *-------------------------------------------------------------------*
  elseif (tbit,pwa_normal_flags,pwa_sasdate7)        C'ddmonyy':
   if       ((%trt,0(2,r14),ne,psd_numeric_table),or,                  *
               (%trt,5(2,r14),ne,psd_numeric_table))
    leave block=*                     |
   endif                              |
   mvc   pwa_numeric_year(2),psd_default_century Force 20th century
   mvc   pwa_numeric_year+2(2),5(r14) |        and append years.
   mvc   pwa_numeric_day(2),0(r14)    | Extract the days.
   mvc   pwa_text_month,2(r14)        |
* *-------------------------------------------------------------------*
  elseif (tbit,pwa_normal_flags,pwa_sasdate9)       C'ddmonyyyy':
   if       ((%trt,0(2,r14),ne,psd_numeric_table),or,                  *
               (%trt,5(4,r14),ne,psd_numeric_table))
    la    r15,8                       |
    leave block=*                     |
   endif                              |
   mvc   pwa_numeric_day(2),0(r14)    | Extract the days.
   mvc   pwa_numeric_year,5(r14)      | Move years.
   mvc   pwa_text_month,2(r14)        |
* *-------------------------------------------------------------------*
  elseif (tbit,pwa_normal_flags,pwa_yyyymmmdd)      C'yyyymondd':   @cx
   if       ((%trt,0(4,r14),ne,psd_numeric_table),or,               @cx*
               (%trt,7(2,r14),ne,psd_numeric_table))                @cx
    la    r15,8                       |                             @cx
    leave block=*                     |                             @cx
   endif                              |                             @cx
   mvc   pwa_numeric_year,0(r14)      | Move years.                 @cx
   mvc   pwa_text_month,4(r14)        |                             @cx
   mvc   pwa_numeric_day(2),7(r14)    | Extract the days.           @cx
  endif                               |                             @cx
* *-------------------------------------------------------------------*
* lr    r1,r14                        | Restore CPL basereg
  if    (cli,pwa_numeric_day,eq,c' ') | If first character is blank
   mvi   pwa_numeric_day,c'0'         |  add a leading zero.
  endif                               |
  oi    pwa_text_month,x'40'          | Ensure 1st letter is caps
  nc    pwa_text_month+1(2),=x'bfbf'  |  and others are lowercase.
  pack  pwa_d,pwa_numeric_year        | Pack years,
  cvb   r0,pwa_d                      |  then convert to integer.
  st    r0,pwa_i_year                 | Save R1 past subroutine call
  pack  pwa_d,pwa_numeric_day         | Pack days,
  cvb   r0,pwa_d                      |  then convert to integer.
  st    r0,pwa_i_day                  |
  la    r14,psd_month_table           | Look up month name
  using month_table,r14               |
  la    r15,mt_#_entries              |
  loop  bct                           |
   leave loop=*,(clc,pwa_text_month(3),eq,mt_month_name)
   la    r14,mt_length(,r14)          |
  endloop bct,r15                     |
  if    (treg,r15,z)                  | If R15 went to zero
   la    r15,8                        |  Invalid month name.
   leave block=*                      |
  endif                               |
  lh    r0,mt_month_num               | Move month number to PWA
  st    r0,pwa_i_month                |  for caller.
  xr    r15,r15                       | Success if we got this far.
  drop  r14                           |
 endblk rc=(r15)                      |
 eject                                |
*---------------------------------------------------------------------*
*  Subroutine: Validate_Text_Formats
*     Purpose: Ensure CPL_Date points to valid text date of the form:
*                Text  -- 'December 25, 1989'
*                Textd -- 'Monday, December 25, 1989'
*       Input: On entry, R1 points to a CPL.
*      Output: R15 = 0 if date is valid, else R15 = 8.
*       Notes: The following PWA fields are used by this routine:
*                   pwa_text_month     pwa_numeric_year
*                   pwa_numeric_day    pwa_text_weekday
*---------------------------------------------------------------------*
 block name=validate_text_formats,    |                                *
               type=subroutine,       |                                *
               options=*nosubopts,    |                                *
               save=(r14,pwa_validate_r14)
  using cpl,r1                        |
  la    r14,r1                        | Save CPL address past TRT's
  l     r15,cpl_date                  |
  drop  r1
* *-------------------------------------------------------------------*
* * Validations: Monthname exists in table
* *              Days numeric, 1 or 2 digits, not more than is valid
* *                for month
* *              Year numeric
* *-------------------------------------------------------------------*
* *  If 'textd' format requested, extract and validate weekday.
* *-------------------------------------------------------------------*
  if    (tbit,pwa_text_flags,pwa_textd)  Is there a weekday up front?
   fill  pwa_text_weekday,c' '        |
   la    r1,pwa_text_weekday          |
   la    r2,pwa_text_weekday+l'pwa_text_weekday
   loop  while,(cli,0(r15),ne,c' '),and,  Extract it til ' ' or ','    *
               (cli,0(r15),ne,c','),and,                               *
               (cr,r1,le,r2)          |
    mvc   0(1,r1),0(r15)              |    Move a byte
    ni    0(r1),x'bf'                 |    Make it lowercase
    la    r15,1(,r15)                 |    Next byte
    la    r1,1(,r1)                   |
   endloop while                      |
   lr    r2,r15                       | Save addr of weekday's end
   oi    pwa_text_weekday,x'40'       | Make 1st char uppercase
   la    r14,psd_weekday_table        | Look it up
   la    r15,7                        |
   loop  bct                          |
    leave loop=*,(clc,pwa_text_weekday,eq,1(r14))    Hit? OK.
    la    r14,l'psd_weekday_table(,r14)
   endloop bct,r15                    |
   if    (treg,r15,z)                 | Nothing found?
    la    r15,8                       |  This date's not valid textd.
    leave block=*                     |
   endif                              |
   loop  while,(cli,0(r2),eq,c' '),or,(cli,0(r2),eq,c',')
    la    r2,1(,r2)                   |  Scan past delimiters
   endloop while                      |
   lr    r15,r2                       |  Save pointer to month
  endif                               |
     eject ,
* *-------------------------------------------------------------------*
* *  Extract month.
* *-------------------------------------------------------------------*
  fill  pwa_text_month,c' '           |
  la    r1,pwa_text_month             |
  la    r2,pwa_text_month+l'pwa_text_month
  loop  while,(cli,0(r15),ne,c' '),and,(cr,r1,lt,r2)  Extract month:
   mvc   0(1,r1),0(r15)               |  Move a byte
   ni    0(r1),x'bf'                  |  Make it lowercase
   la    r1,1(,r1)                    |  Next byte.
   la    r15,1(,r15)                  |
  endloop while                       |
  oi    pwa_text_month,x'40'          | Make 1st byte uppercase
* *-------------------------------------------------------------------*
* *  Skip blanks, then extract and validate day.
* *-------------------------------------------------------------------*
  loop  while,(cli,0(r15),eq,c' ')    | Scan to start of numeric day
   la    r15,1(,r15)                  |
  endloop while                       |
  if    (cli,1(r15),eq,c',')          | If day looks like 1 digit
   mvi   pwa_numeric_day,c'0'         |  Put a 0 on front of our copy
   mvc   pwa_numeric_day+1(1),0(r15)  |  Copy the digit
   la    r15,2(,r15)                  |   and point past the comma,
  elseif (cli,2(r15),eq,c',')         | If day looks like 2 digits
   mvc   pwa_numeric_day(2),0(r15)    |  Copy both digits
   la    r15,3(,r15)                  |   and point past the comma
  else                                | Otherwise, dunno what this is,
   la    r15,8                        |  so fail validation.
   leave block=*                      |
  endif                               |
  if    (%trt,pwa_numeric_day,ne,psd_numeric_table)   Day not numeric?
   la    r15,8                        |                Reject it.
   leave block=*                      |
  endif                               |
* *-------------------------------------------------------------------*
* *  Skip blanks, then extract and validate year.
* *-------------------------------------------------------------------*
  loop  while,(cli,0(r15),eq,c' ')    |
   la    r15,1(,r15)                  |
  endloop while                       |
  mvc   pwa_numeric_year,0(r15)       | Get 4 digits worth.
  if    (%trt,pwa_numeric_year,ne,psd_numeric_table)  Not numeric?
   la    r15,8                        |                Reject it.
   leave block=*                      |
  endif                               |
  xr    r15,r15                       | Must be OK if it got here.
 endblk rc=(r15)                      |
 eject                                |
*---------------------------------------------------------------------*
*  Subroutine: Validate_HHMMSS_Formats
*     Purpose: Ensure CPL_Time points to valid time value of one of the
*              following forms:
*       Input: On entry, R1 points to a CPL.
*      Output: R15 = 0 if date is valid, else R15 = 8.
*       Notes: The following PWA fields are used by this routine:
*---------------------------------------------------------------------*
 block name=validate_HHMMSS_formats,  |                                *
               type=subroutine,       |                                *
               options=*nosubopts,    |                                *
               save=(r14,pwa_validate_r14)
  using cpl,r1                        |
  la    r15,8                         | Save CPL address past TRT's
  l     r14,cpl_time                  |
  drop  r1
* *-------------------------------------------------------------------*
* * Validations: Hours numeric, not > c'24', followed by c':'
* *              Minutes numeric, not > c'60', maybe followed by c':'
* *              Seconds numeric, not > c'60', maybe followed by c'.'
* *              Hundredths numeric if present
* *              If civilian: hours not > 12, time followed by AM/PM
* *-------------------------------------------------------------------*
  if    (cli,0(r14),eq,c' ')          |  If leading char is blank
   if    (%trt,1(1,r14),ne,psd_numeric_table)  If 2nd char not numeric
    leave block=*                     |
   endif                              |
  else                                |
   if          (%trt,0(2,r14),ne,psd_numeric_table),or,  | HH numeric  *
               (clc,0(2,r14),gt,=c'24')                  | HH not > 24
    leave block=*                     |
   endif                              |
  endif                               |
  if           (cli,2(r14),ne,c':'),or,                  | : after HH  *
               (%trt,3(2,r14),ne,psd_numeric_table),or,  | MM numeric  *
               (clc,3(2,r14),gt,=c'60')                  | MM not > 60
   leave block=*                      |
  endif                               |
  if           (tbit,pwa_hhmmss_flags,pwa_hhmm,off),and, | If not HHMM:*
               ((cli,5(r14),ne,c':'),or,                 | : after MM  *
               (%trt,6(2,r14),ne,psd_numeric_table),or,  | SS numeric  *
               (clc,6(2,r14),gt,=c'60'))                 | SS not > 60
   leave block=*                      |
  endif                               |
  if           (tbit,pwa_hhmmss_flags,pwa_hhmmssth),and, | If HHMMSSTH:*
               ((%trt,9(2,r14),ne,psd_numeric_table),or, | TH numeric  *
               ((cli,8(r14),ne,c':'),and,(cli,8(r14),ne,c'.')))  : or .
   leave block=*                      |
  endif                               |
  if           (tbit,pwa_hhmmss_flags,pwa_civilian),and, | If Civilian *
               ((clc,0(2,r14),gt,=c'12'),or,             | PM if HH>12 *
               ((clc,=c' AM',ne,8(r14)),and,(clc,=c' PM',ne,8(r14))))
   leave block=*                      |
  endif                               |
  xr    r15,r15                       |
 endblk rc=(r15)                      |
 eject                                |
*---------------------------------------------------------------------*
*  Subroutine: Validate_Delta_Formats
*     Purpose: Ensure CPL_Time points to valid Delta-format time value
*              as follows:  <dddd>d-hh<:mm<:ss<.th>>>
*       Input: On entry, R1 points to a CPL.
*      Output: R15 = 0 if date is valid, else R15 = 8.
*       Notes: The following PWA fields are used by this routine:
*        PWA_Number_Of_Days  PWA_Number_Of_Hours  PWA_Number_Of_Minutes
*             PWA_Number_Of_Seconds   PWA_Number_Of_Hundredths
*---------------------------------------------------------------------*
 block name=validate_delta_format,    |                                *
               type=subroutine,       |                                *
               options=*nosubopts,    |                                *
               save=(r14,pwa_validate_r14)
  lr    r4,r1
  using cpl,r4                        |
  l     r15,cpl_interval              |
* *-------------------------------------------------------------------*
* * Validations: Any value before '-' is 1-5 numeric digits
* *              Hours numeric, not > c'24', followed by c':'
* *              Minutes numeric, not > c'60', maybe followed by c':'
* *              Seconds numeric, not > c'60', maybe followed by c'.'
* *              Hundredths numeric if present
* *              If civilian: hours not > 12, time followed by AM/PM
* *-------------------------------------------------------------------*
  xc    pwa_interval_numbers(l_interval_numbers),pwa_interval_numbers
  la    r14,1(,r15)                   |
  la    r2,5                          |
  loop  bct                           | Scan for a '-':
   leave loop=*,(cli,0(r14),eq,c'-')  |  Quit if we found one,
   la    r14,1(,r14)                  |  else keep looking.
  endloop bct,r2                      |
  lnr   r14,r2                        | Length is (maxlen + 1 - R2):
  ah    r14,=h'6'                     | R14 is now length of operand
  st    r14,pwa_f                     | Save
  if    (treg,r2,nz)                  | If we got a hit
   bctr  r14,0                        |  Decrement length for execute
   exi   r14,(trt,0(0,r15),psd_numeric_table)    Check for numerics:
   if    ne                           |
    la    r15,8                       |
    leave block=*                     |
   endif                              |
   fill  pwa_edit,c'0',length=5       | Initialize interval_days
   la    r1,pwa_edit+5                | Point to field_end+1
   s     r1,pwa_f                     | Knock off bytes_remaining in
*                                     | original field, then move only
   exi   r14,(mvc,0(0,r1),0(r15))     | the number of bytes provided.
   la    r15,1+1(r14,r15)             | Point past the '-'
   pack  pwa_d,pwa_edit(5)            | Convert to packed,
   cvb   r1,pwa_d                     |  then to integer,
   st    r1,pwa_number_of_days        |   then save number of days.
  endif                               | That's it for 'days'.
* *-------------------------------------------------------------------*
        eject ,                       |
  if    (%trt,0(2,r15),ne,psd_numeric_table)
   la    r15,8                        |
   leave block=*                      |
  endif                               |
  mvc   pwa_edit(2),0(r15)            |
  pack  pwa_d,pwa_edit(2)             |
  cvb   r1,pwa_d                      |
  st    r1,pwa_number_of_hours        |
  if    (cli,2(r15),eq,c':')          | If something follows hours:
   if    (%trt,3(2,r15),ne,psd_numeric_table)
    la    r15,8                       |  It better be numeric
    leave block=*                     |
   endif                              |
   mvc   pwa_edit(2),3(r15)           |
   pack  pwa_d,pwa_edit(2)            |
   cvb   r1,pwa_d                     |
   st    r1,pwa_number_of_minutes     |
   if    (cli,5(r15),eq,c':')         | If something follows minutes:
    if    (%trt,6(2,r15),ne,psd_numeric_table)
     la    r15,8                      |
     leave block=*                    |
    endif                             |
    mvc   pwa_edit(2),6(r15)          |
    pack  pwa_d,pwa_edit(2)           |
    cvb   r1,pwa_d                    |
    st    r1,pwa_number_of_seconds    |
    if    (cli,8(r15),eq,c'.')        | If something follows seconds:
     if    (%trt,9(2,r15),ne,psd_numeric_table)
      la    r15,8                     |
      leave block=*                   |
     endif                            |
     mvc   pwa_edit(2),9(r15)         |
     pack  pwa_d,pwa_edit(2)          |
     cvb   r1,pwa_d                   |
     st    r1,pwa_number_of_hundredths
    elseif (cli,8(r15),ne,c' ')       |
     la    r15,8                      |
     leave block=*                    |
    endif                             |
   elseif (cli,5(r15),ne,c' ')        |
    la    r15,8                       |
    leave block=*                     |
   endif                              |
  elseif (cli,2(r15),ne,c' ')         |
   la    r15,8                        |
   leave block=*                      |
  endif                               |
* *-------------------------------------------------------------------*
  xr    r15,r15                       |
  drop  r4                            |
 endblk rc=(r15)                      |
 title "Drive Input Format Routines"  |
*---------------------------------------------------------------------*
*
*  Subroutine: Call_Convert_Input
*  Abstract:   This routine will call the appropriate input date and
*              time formatting routines based on the caller's request.
*              This routine is called from the main case block, as well
*              as from other internal routines.
*  Inputs:     On entry, R1 points to the following parameter list:
*                +0 -- Internal format date/time doubleword
*                +4 -- Place to get date value to convert
*                +8 -- Format for input date value
*                +C -- Place to get time value to convert
*               +10 -- Format for input time value
*                  (This parameter list is known as a "converter para-
*                  meter list", or "CPL", and is common to all of the
*                  date and time format conversion subroutines.)
*  Outputs:    Appropriate routine(s) called
*  Special
*  Notes:      . As new input formatting routines are coded, add add'l
*                CASE statements and setup code to this subroutine.
*              . This routine only saves R14.  The routines that it
*                calls are responsible for handling their own regs.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Call_Convert_Input,type=subroutine,                        *
               options=(*nosubopts),                                   *
               save=(r14,pwa_call_convert_r14)
         space 1                      |
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              | Zero out internal-format time
  xc    0(8,r15),0(r15)               |  / date doubleword.
  fill  pwa_flags,x'00',length=l_flags
* *-------------------------------------------------------------------*
* * Set up for time conversion routines.  This allows less duplication
* * of code in the actual converter routines.
* *-------------------------------------------------------------------*
  block name=input_time_conversion    |
   mvi   pwa_hhmmss_flags,x'00'       |
*  *------------------------------------------------------------------*
*  * Special cases: If date is requested in DT_ES_Format or time is
*  * requested in  DT_TODclock format, call one convert routine to
*  * handle both and quit. This eliminates a subroutine call during
*  * input conversion.
*  *------------------------------------------------------------------*
   l32   r14,cpl_date_format          | Get date format
   if    (nz)                         | If nonzero
    l     r14,0(,r14)                 |  Get the value
    if    (c,r14,eq,=a(&dt_es_format))   If it ES_format?
     callsub Convert_Date_From_ES_Format   Call combined converter
     leave block=Call_Convert_Input   |    and exit input conversion.
    endif                             |
   endif                              |
*                                     |
   l32   r14,cpl_time                 | See if time parm present
   leave block=*,(z)                  | Not there? Get out.
   l32   r14,cpl_time_format          | Make sure we got a format
   errexit (z),code=&dt_invalid_time_format  No? No defaults.
   l     r14,0(,r14)                  | Get the format value
   if    (c,r14,eq,=a(&dt_todclock))  | Is it TODCLOCK request?
    callsub  Convert_Time_From_TODclock    Call combined converter
    leave block=Call_Convert_Input    |     and exit input conversion.
   elseif (c,r14,eq,=a(&dt_seconds_since_1970))
    callsub Convert_Time_From_SecondsSince1970
    leave block=Call_Convert_Input    |     and exit input conversion.
   endif                              |
*  *------------------------------------------------------------------*
*  * Normal setup for time format processing.
*  *------------------------------------------------------------------*
   loop  until                        |
    l32   r14,cpl_time_format         | Point to input time format
    l     r14,0(,r14)                 | Get it (we know it's nonzero)
    caseblk  reg=r14                  |
     case &dt_hhmm                    |
      sbit  pwa_hhmmss_flags,pwa_hhmm |
     case &dt_hhmmss                  |
      sbit  pwa_hhmmss_flags,pwa_hhmmss
     case &dt_hhmmssth                |
      sbit  pwa_hhmmss_flags,pwa_hhmmssth
     case &dt_civilian                |
      sbit  pwa_hhmmss_flags,pwa_civilian
     case &dt_general_input           |
      sbit  pwa_general_flags,pwa_general_input
     case &dt_unspecified             |
      leave block=Input_Time_Conversion
     case other                       |
    endcase                           |
    eject ,                           |
*  *------------------------------------------------------------------*
*  * Call requested time conversion routine.  Note that some of these
*  * routines may issue a LEAVE when completed, since they handle the
*  * date conversion as well.
*  *------------------------------------------------------------------*
    l32   r14,cpl_time_format         | Get addr of output time format
    l     r14,0(,r14)                 | Get the format
    caseblk  reg=r14                  | Set up and call format routine:
     case &dt_es_format,&dt_Hundredths   Convert to Envir. Support fmt:
      callsub Convert_Time_From_Hundredths
     case &dt_hhmm,&dt_hhmmss,&dt_hhmmssth,&dt_civilian
      callsub Convert_Time_From_HHMMSS
     case &dt_general_input           | Multiple-choice format
      callsub Convert_Time_From_General_Input
      la    r15,8                     |  Force loop to be redriven
*                                     |
     case other                       | Unknown time format:
      l     r15,cpl_time_format       |  Point to format address
      l     r15,0(,r15)               |  Load format into R15
      errexit code=&dt_invalid_time_format Return error to caller.
    endcase                           |
   endloop until,(treg,r15,z)         |
  endblk                              |
         eject                        |
* *-------------------------------------------------------------------*
* *  Set up for date conversion routines. This allows less duplication
* *  of code in the converter routines themselves.  Note that this is
* *  enclosed in a Loop Until: this is for the DT_General_Input format,
* *  which may cause the block to be redriven once the true format is
* *  recognized.
* *-------------------------------------------------------------------*
  block name=input_date_conversion    |
   loop  until                        |
    fill  pwa_flags,x'00',length=(l_flags)
    l32   r14,cpl_date                | Get pointer to input date
    leave block=*,(z)                 | Get out if no date present.
    l32   r14,cpl_date_format         | Get input date format
    errexit (z),name=&dt_invalid_date_format  Croak if no format
    l     r14,0(,r14)                 | Get the format
    caseblk  reg=r14                  | Set up for converter routines:
     case &dt_julian                  |
      sbit  pwa_julian_flags,pwa_julian
     case &dt_juliand                 |
      sbit  pwa_julian_flags,pwa_juliand
     case &dt_pjulian,&dt_es_format   |
      sbit  pwa_julian_flags,pwa_pjulian
     case &dt_ijulian                 |
      sbit  pwa_julian_flags,pwa_ijulian
     case &dt_sjulian                 |
      sbit  pwa_julian_flags,pwa_sjulian
     case &dt_sjuliand                |
      sbit  pwa_julian_flags,pwa_sjuliand
     case &dt_gregorian               |
      sbit  pwa_gregorian_flags,pwa_gregorian
     case &dt_sgregorian              |
      sbit  pwa_gregorian_flags,pwa_sgregorian
     case &dt_normal                  |
      sbit  pwa_normal_flags,pwa_normal
     case &dt_snormal                 |
      sbit  pwa_normal_flags,pwa_snormal
     case &dt_sasdate7                |
      sbit  pwa_normal_flags,pwa_sasdate7
     case &dt_sasdate9                |
      sbit  pwa_normal_flags,pwa_sasdate9
     case &dt_yyyymmmdd               |                             @cx
      sbit  pwa_normal_flags,pwa_yyyymmmdd                          @cx
     case &dt_text                    |
      sbit  pwa_text_flags,pwa_text   |
     case &dt_textd                   |
      sbit  pwa_text_flags,pwa_textd  |
     case &dt_sortdate                |
      sbit  pwa_gregorian_flags,pwa_sortdate
     case &dt_ssortdate               |
      sbit  pwa_gregorian_flags,pwa_ssortdate
     case &dt_general_input           |
      sbit  pwa_general_flags,pwa_general_input
     case &dt_unspecified             | Not provided: leave.
      leave block=Input_Date_Conversion
     case  other                      | Not listed here: Do nothing.
    endcase                           |
    eject ,                           |
*   *-----------------------------------------------------------------*
*   * Call requested date conversion routine.
*   *-----------------------------------------------------------------*
    lr    r1,r4                       | Restore CPL address in R1
    l32   r14,cpl_date_format         | Get input date format
    l     r14,0(,r14)                 | Get value (we know it's NZ)
    caseblk  reg=r14                  | Set up and call format routine:
     case &dt_ijulian,&dt_pjulian,&dt_julian,&dt_juliand,              *
               &dt_sjulian,&dt_sjuliand,&dt_es_format
      callsub Convert_Date_From_Julian
     case &dt_gregorian,&dt_sgregorian,  Gregorian and Sortdate formats*
               &dt_sortdate,&dt_ssortdate
      callsub Convert_Date_From_Gregorian
     case &dt_normal,&dt_snormal,     |  Normal format (01 Oct 1989)   *
               &dt_sasdate7,&dt_sasdate9,                              *
               &dt_yyyymmmdd          |                             @cx
      callsub Convert_Date_From_Normal
     case &dt_text,&dt_textd          |  Text (October 1, 1989)
      callsub Convert_Date_From_Text  |
     case &dt_number_of_days          |  No. of days since 1/1/0000
      callsub Convert_Date_From_Number
     case &dt_general_input           | Multiple-choice format
      callsub Convert_Date_From_General_Input
      la    r15,8                     |  Force loop to be redriven
*                                     |
     case other                       | Unknown date format:
      l     r15,cpl_date_format       |  Point to format address
      l     r15,0(,r15)               |  Load format into R15
      errexit code=&dt_invalid_date_format Return error to caller.
    endcase                           |
   endloop until,(treg,r15,z)         |
  endblk                              |
  drop  r4                            |
         space 1                      |
 endblk                               |
         title "Drive Input Interval Routines"
*---------------------------------------------------------------------*
*
*  Subroutine: Call_Convert_Input_Interval
*  Abstract:   This routine will call the appropriate input interval
*              formatting routines based on the caller's request. This
*              routine is called from the main case block, as well
*              as from other internal routines.
*  Inputs:     On entry, R1 points to the following parameter list:
*                +0 -- Internal format date/time doubleword
*                +4 -- Place to get interval value to convert
*                +8 -- Format for input interval value
*                +C -- Unused
*               +10 -- Unused
*                  (This parameter list is known as a "converter para-
*                  meter list", or "CPL", and is common to all of the
*                  date and time format conversion subroutines.)
*  Outputs:    Appropriate routine(s) called
*  Special
*  Notes:      . As new input formatting routines are coded, add add'l
*                CASE statements and setup code to this subroutine.
*              . This routine only saves R14.  The routines that it
*                calls are responsible for handling their own regs.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Call_Convert_Input_Interval,type=subroutine,               *
               options=(*nosubopts),                                   *
               save=(r14,pwa_call_convert_r14)
         space 1                      |
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              | Zero out internal-format time
  xc    0(8,r15),0(r15)               |  / date doubleword.
  fill  pwa_flags,x'00',length=l_flags
* *-------------------------------------------------------------------*
* * Set up for interval conversion routines.  This allows less
* * duplication of code in the actual converter routines.
* *-------------------------------------------------------------------*
  block name=input_interval_conversion
   fill  pwa_flags,x'00',length=(l_flags)
   l32   r14,cpl_interval             | See if interval provided
   errexit (z),code=&dt_invalid_input_interval   It better be there
   l32   r14,cpl_interval_format      | Point to input inteval format
   errexit (z),code=&dt_invalid_interval_format  It better be there
   l     r14,0(,r14)                  | Get the format
*  *------------------------------------------------------------------*
*  * Normal setup for interval format processing.
*  *------------------------------------------------------------------*
   caseblk  reg=r14                   |
    case &dt_delta                    |
     sbit  pwa_interval_flags,pwa_delta      dd:hh:mm:ss.th format
    case &dt_days                     |
     sbit  pwa_day_flags,pwa_days     |
    case &dt_pdays                    |
     sbit  pwa_day_flags,pwa_pdays    |
    case &dt_idays                    |
     sbit  pwa_day_flags,pwa_idays    |
    case &dt_hours                    |
     sbit  pwa_hour_flags,pwa_hours   |
    case &dt_phours                   |
     sbit  pwa_hour_flags,pwa_phours  |
    case &dt_ihours                   |
     sbit  pwa_hour_flags,pwa_ihours  |
    case &dt_minutes                  |
     sbit  pwa_minute_flags,pwa_minutes
    case &dt_pminutes                 |
     sbit  pwa_minute_flags,pwa_pminutes
    case &dt_iminutes                 |
     sbit  pwa_minute_flags,pwa_iminutes
    case &dt_seconds                  |
     sbit  pwa_second_flags,pwa_seconds
    case &dt_pseconds                 |
     sbit  pwa_second_flags,pwa_pseconds
    case &dt_iseconds                 |
     sbit  pwa_second_flags,pwa_iseconds
    case &dt_hundredths               |
     sbit  pwa_interval_flags,pwa_hundredths
    case &dt_phundredths              |
     sbit  pwa_interval_flags,pwa_phundredths
    case &dt_ihundredths              |
     sbit  pwa_interval_flags,pwa_ihundredths
    case &dt_todclock                 |                             @cy
     sbit  pwa_interval_flags,pwa_todclock                          @cy
    case other                        |
   endcase                            |
*  *------------------------------------------------------------------*
*  * Call requested interval conversion routine.
*  *------------------------------------------------------------------*
   l32   r14,cpl_interval_format      | Get addr of interval format
   l     r14,0(,r14)                  | Get format in R14.
   caseblk  reg=r14                   | Set up and call format routine:
    case       &dt_hundredths,&dt_phundredths,&dt_ihundredths,         *
               &dt_hours,&dt_phours,&dt_ihours,                        *
               &dt_minutes,&dt_pminutes,&dt_iminutes,                  *
               &dt_seconds,&dt_pseconds,&dt_iseconds,                  *
               &dt_days,&dt_pdays,&dt_idays
     callsub Convert_Integer_Interval_To_Internal
    case &dt_delta                    |
     callsub Convert_Delta_Interval_To_Internal
    case &dt_todclock                 |                             @cy
     l     r1,cpl_interval            | Get the TODclock interval value
     lm    r14,r15,0(r1)              |  high-order word
     if    (treg,r14,m)               | Is it negative?
      lcr   r14,r14                   |  Flip it
      lcr   r15,r15                   |  Flip it
      if    (cc3)                     |  Overflow from lo-order word?
       la    r14,1(,r14)              |   Need to carry a bit to hi.
      endif                           |
      stm   r14,r15,0(r1)             |  and put it back
*                                     |  (where cnvt_from_tod wants it)
      sbit  pwaf1rev                  |    and note sign was reversed.
     endif                            |
*>>>>callsub Convert_Time_From_TODclock Don't do this, see comments @cy
*    *----------------------------------------------------------------*
*    * The usual TOD input routine adds the TOD's base time (1/1/1970)
*    * to the value you send it.  Since all we want is the interval,
*    * we want to skip that.  With that out of the way, converting a
*    * TOD value to DT's internal format is just a doubleword shift,
*    * so instead of a separate routine, we just do it inline here.
*    *----------------------------------------------------------------*
     l     r15,cpl_interval           | Get address of TOD value
     lm    r14,r15,0(r15)             | Get TOD-clock value
     srdl  r14,12                     | Convert to microseconds
     l     r1,cpl_internal            | Get ptr to internal fmt answer
     stm   r14,r15,0(r1)              | Save results
*                                     |
    case other                        | Unknown time format:
     l     r15,cpl_interval_format    |  Point to format address
     l     r15,0(,r15)                |  Load format into R15
     errexit code=&dt_invalid_interval_format Return error to caller.
   endcase                            |
  endblk                              |
 endblk                               |
 title "Drive Output Format Routines" |
*---------------------------------------------------------------------*
*
*  Subroutine: Call_Convert_Output
*  Abstract:   This routine will call the appropriate output date and
*              time formatting routines based on the caller's request.
*              This routine is called from the main case block, as well
*              as from other internal routines.
*  Inputs:     On entry, R1 points to the following parameter list:
*                +0 -- Internal format date/time doubleword
*                +4 -- Place to store converted date value
*                +8 -- Format for converted date value
*                +C -- Place to store converted time value
*               +10 -- Format for converted time value
*                  (This parameter list is known as a "converter para-
*                  meter list", or "CPL", and is common to all of the
*                  date and time format conversion subroutines.)
*  Outputs:    Appropriate routine(s) called
*  Special
*  Notes:      . As new output formatting routines are coded, add add'l
*                CASE statements and setup code to this subroutine.
*              . This routine only saves R14.  The routines that it
*                calls are responsible for handling their own regs.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Call_Convert_Output,type=subroutine,                       *
               options=(*nosubopts),                                   *
               save=(r14,pwa_call_convert_r14)
         space 1                      |
  lr    r4,r1                         | Copy CPL base.  Note that R1
  using cpl,r4                        | should be preserved into the
*                                     | CASEBLK, since the CPL can be
*                                     | passed to the converter rtns.
*                                     | with fewer instructions.
  fill  pwa_flags,x'00',length=l_flags
* *-------------------------------------------------------------------*
* * Set up for time conversion routines.  This allows less duplication
* * of code in the actual converter routines.
* *-------------------------------------------------------------------*
  block name=output_time_conversion   |
   mvi   pwa_hhmmss_flags,x'00'       |
*  *------------------------------------------------------------------*
*  * Special case: If either date or time are requested in DT_ES_Format
*  * or DT_TODclock format, call one convert routine to handle both and
*  * quit. This eliminates a subroutine call during output conversion.
*  *------------------------------------------------------------------*
   l32   r14,cpl_date_format          |
   if    (nz)                         |
    l     r14,0(,r14)                 |
    if    (c,r14,eq,=a(&dt_es_format))
     callsub Convert_Date_To_ES_Format  Call combined converter
     leave block=Call_Convert_Output  |    and exit input conversion.
    endif                             |
   endif                              |
*                                     |
   l32   r14,cpl_time                 |
   leave block=*,(z)                  | No time, go on to dates.
   l32   r14,cpl_time_format          |
   errexit (z),code=&dt_invalid_time_format  No format, go choke.
   l     r14,0(,r14)                  | Get the format
   if    (c,r14,eq,=a(&dt_todclock))  | If caller wants TODCLOCK
    callsub  Convert_Time_To_TODclock |     Call combined converter
    leave block=Call_Convert_Output   |      and exit input conversion.
   elseif (c,r14,eq,=a(&dt_seconds_since_1970))
    callsub Convert_Time_To_SecondsSince1970
    leave block=Call_Convert_Output   |
   endif                              |
*  *------------------------------------------------------------------*
   l32   r14,cpl_time_format          | Point to input time format
   l     r14,0(,r14)                  | Get the format value for CASEs
*  *------------------------------------------------------------------*
*  * Normal setup for time conversion.
*  *------------------------------------------------------------------*
   caseblk  reg=r14                   |
    case &dt_hhmm                     |
     sbit  pwa_hhmmss_flags,pwa_hhmm  |
    case &dt_hhmmss                   |
     sbit  pwa_hhmmss_flags,pwa_hhmmss
    case &dt_hhmmssth                 |
     sbit  pwa_hhmmss_flags,pwa_hhmmssth
    case &dt_civilian                 |
     sbit  pwa_hhmmss_flags,pwa_civilian
    case &dt_hours
     sbit  pwa_hour_flags,pwa_hours
    case &dt_phours
     sbit  pwa_hour_flags,pwa_phours
    case &dt_ihours
     sbit  pwa_hour_flags,pwa_ihours
    case &dt_minutes
     sbit  pwa_minute_flags,pwa_minutes
    case &dt_pminutes
     sbit  pwa_minute_flags,pwa_pminutes
    case &dt_iminutes
     sbit  pwa_minute_flags,pwa_iminutes
    case &dt_seconds
     sbit  pwa_second_flags,pwa_seconds
    case &dt_pseconds
     sbit  pwa_second_flags,pwa_pseconds
    case &dt_iseconds
     sbit  pwa_second_flags,pwa_iseconds
    case &dt_unspecified              |
     leave block=Output_Time_Conversion
    case other                        |
   endcase                            |
   eject ,                            |
*  *------------------------------------------------------------------*
*  * Call requested time conversion routine.  Note that some of these
*  * routines may issue a LEAVE when completed, since they handle the
*  * date conversion as well.
*  *------------------------------------------------------------------*
   l32   r14,cpl_time_format          | Get addr of output time format
   l     r14,0(,r14)                  |  Get format in R14.
   caseblk  reg=r14                   | Set up and call format routine:
    case &dt_Hundredths,&dt_es_format | .01-secs since midnight
     callsub Convert_Time_To_Hundredths
*   case &dt_es_format                | Environment Support format
*    callsub Convert_Date_To_ES_Format
*    leave   block=*                  |  (Get out: routine does both.)
    case &dt_hhmm,&dt_hhmmss,&dt_hhmmssth,&dt_civilian,                *
               &dt_hours,&dt_phours,&dt_ihours,                        *
               &dt_minutes,&dt_pminutes,&dt_iminutes,                  *
               &dt_seconds,&dt_pseconds,&dt_iseconds
     callsub Convert_Time_To_HHMMSS   |
*                                     |
    case other                        | Unknown time format:
     l     r15,cpl_time_format        |  Point to format address
     l     r15,0(,r15)                |  Load format into R15
     errexit code=&dt_invalid_time_format Return error to caller.
   endcase                            |
  endblk                              |
         eject                        |
* *-------------------------------------------------------------------*
* *  Set up for date conversion routines. This allows less duplication
* *  of code in the converter routines themselves.
* *-------------------------------------------------------------------*
  block name=output_date_conversion   |
   fill  pwa_flags,x'00',length=(l_flags)
   l32   r14,cpl_date                 |
   leave block=*,(z)                  | No time present: exit.
   l32   r14,cpl_date_format          |
   errexit (z),name=&dt_invalid_date_format
   l     r14,0(,r14)                  |
   caseblk  reg=r14                   | Set up for converter routines:
    case &dt_julian                   |
     sbit  pwa_julian_flags,pwa_julian
    case &dt_juliand                  |
     sbit  pwa_julian_flags,pwa_juliand
    case &dt_pjulian,&dt_es_format    |
     sbit  pwa_julian_flags,pwa_pjulian
    case &dt_ijulian                  |
     sbit  pwa_julian_flags,pwa_ijulian
    case &dt_sjulian                  |
     sbit  pwa_julian_flags,pwa_sjulian
    case &dt_sjuliand                 |
     sbit  pwa_julian_flags,pwa_sjuliand
    case &dt_gregorian                |
     sbit  pwa_gregorian_flags,pwa_gregorian
    case &dt_sgregorian               |
     sbit  pwa_gregorian_flags,pwa_sgregorian
    case &dt_normal                   |
     sbit  pwa_normal_flags,pwa_normal
    case &dt_snormal                  |
     sbit  pwa_normal_flags,pwa_snormal
    case &dt_sasdate7                 |
     sbit  pwa_normal_flags,pwa_sasdate7
    case &dt_sasdate9                 |
     sbit  pwa_normal_flags,pwa_sasdate9
    case &dt_yyyymmmdd                |                             @cx
     sbit  pwa_normal_flags,pwa_yyyymmmdd                           @cx
    case &dt_text                     |
     sbit  pwa_text_flags,pwa_text    |
    case &dt_textd                    |
     sbit  pwa_text_flags,pwa_textd   |
    case &dt_weekday                  |
     sbit  pwa_text_flags,pwa_weekday |
    case &dt_weekday3                 |
     sbit pwa_text_flags,pwa_weekday3 |
    case &dt_sortdate                 |
     sbit  pwa_gregorian_flags,pwa_sortdate
    case &dt_ssortdate                |
     sbit  pwa_gregorian_flags,pwa_ssortdate
    case &dt_days                     |
     sbit  pwa_day_flags,pwa_days     |
    case &dt_pdays                    |
     sbit  pwa_day_flags,pwa_pdays    |
    case &dt_idays                    |
     sbit  pwa_day_flags,pwa_idays    |
    case &dt_month                    |
     sbit  pwa_month_flags,pwa_month  |
    case &dt_pmonth                   |
     sbit  pwa_month_flags,pwa_pmonth |
    case &dt_imonth                   |
     sbit  pwa_month_flags,pwa_imonth |
    case &dt_monthname                |
     sbit  pwa_month_flags,pwa_monthname
    case &dt_monthname3               |
     sbit  pwa_month_flags,pwa_monthname3
    case &dt_year                     |
     sbit  pwa_year_flags,pwa_year    |
    case &dt_year2                    |
     sbit  pwa_year_flags,pwa_year2   |
    case &dt_pyear                    |
     sbit  pwa_year_flags,pwa_pyear   |
    case &dt_iyear                    |
     sbit  pwa_year_flags,pwa_iyear   |
    case &dt_unspecified              |
     leave block=Output_Date_Conversion
    case  other                       |
   endcase                            |
   eject ,                            |
*  *------------------------------------------------------------------*
*  * Call requested date conversion routine.
*  *------------------------------------------------------------------*
   lr    r1,r4                        | Restore CPL address in R1
   l32   r14,cpl_date_format          |
   l     r14,0(,r14)                  |
   caseblk  reg=r14                   | Set up and call format routine:
    case &dt_ijulian,&dt_pjulian,&dt_julian,&dt_juliand,               *
               &dt_sjulian,&dt_sjuliand,&dt_es_format
     callsub Convert_Date_To_Julian   | Various Julian dates
    case &dt_gregorian,&dt_sgregorian,                                 *
               &dt_sortdate,&dt_ssortdate
     callsub Convert_Date_To_Gregorian  Gregorian, Sortdate formats
    case &dt_normal,&dt_snormal,      |                                *
               &dt_sasdate7,&dt_sasdate9,                              *
               &dt_yyyymmmdd                                        @cx
     callsub Convert_Date_To_Normal   | Normal format (01 Oct 1989)
    case &dt_text,&dt_textd,          |                                *
               &dt_weekday,&dt_weekday3
     callsub Convert_Date_To_Text     | Text (October 1, 1989)
    case &dt_number_of_days           | No. of days since 1/1/0000
     callsub Convert_Date_To_Number   |
    case &dt_days,&dt_pdays,&dt_idays |
     callsub Convert_Date_To_Days     |
    case &dt_month,&dt_pmonth,&dt_imonth,                              *
               &dt_monthname,&dt_monthname3
     callsub Convert_Date_To_Months   |
    case &dt_year,&dt_year2,&dt_pyear,&dt_iyear
     callsub Convert_Date_To_Years    |
*                                     |
    case other                        | Unknown date format:
     l     r15,cpl_date_format        |  Point to format address
     l     r15,0(,r15)                |  Load format into R15
     errexit code=&dt_invalid_date_format Return error to caller.
   endcase                            |
  endblk                              |
  drop  r4                            |
         space 1                      |
 endblk                               |
         title "Drive Output Interval Routines"
*---------------------------------------------------------------------*
*
*  Subroutine: Call_Convert_Output_Interval
*  Abstract:   This routine will call the appropriate output interval
*              formatting routines based on the caller's request. This
*              routine is called from the main case block, as well
*              as from other internal routines.
*  Inputs:     On entry, R1 points to the following parameter list:
*                +0 -- Internal format date/time doubleword
*                +4 -- Place to get interval value to convert
*                +8 -- Format for input interval value
*                +C -- Unused
*               +10 -- Unused
*                  (This parameter list is known as a "converter para-
*                  meter list", or "CPL", and is common to all of the
*                  date and time format conversion subroutines.)
*  Outputs:    Appropriate routine(s) called
*  Special
*  Notes:      . As new output formatting routines are coded, add add'l
*                CASE statements and setup code to this subroutine.
*              . This routine only saves R14.  The routines that it
*                calls are responsible for handling their own regs.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Call_Convert_Output_Interval,type=subroutine,              *
               options=(*nosubopts),                                   *
               save=(r14,pwa_call_convert_r14)
         space 1                      |
  lr    r4,r1                         |
  using cpl,r4                        |
  fill  pwa_flags,x'00',length=l_flags
* *-------------------------------------------------------------------*
* * Set up for time conversion routines.  This allows less duplication
* * of code in the actual converter routines.
* *-------------------------------------------------------------------*
  block name=output_interval_conversion
   fill  pwa_flags,x'00',length=(l_flags)
   l32   r14,cpl_interval             | See if interval was provided
   errexit (z),code=&dt_invalid_input_interval    It better be there
   l32   r14,cpl_interval_format      | Point to input inteval format
   errexit (z),code=&dt_invalid_interval_format   It better be there
   l     r14,0(,r14)                  | Get the format
*  *------------------------------------------------------------------*
*  * Normal setup for interval format processing.
*  *------------------------------------------------------------------*
   caseblk  reg=r14                   |
    case &dt_delta                    |
     sbit  pwa_interval_flags,pwa_delta      dd:hh:mm:ss.th format
    case &dt_days                     |
     sbit  pwa_day_flags,pwa_days     |
    case &dt_pdays                    |
     sbit  pwa_day_flags,pwa_pdays    |
    case &dt_idays                    |
     sbit  pwa_day_flags,pwa_idays    |
    case &dt_hours                    |
     sbit  pwa_hour_flags,pwa_hours   |
    case &dt_phours                   |
     sbit  pwa_hour_flags,pwa_phours  |
    case &dt_ihours                   |
     sbit  pwa_hour_flags,pwa_ihours  |
    case &dt_minutes                  |
     sbit  pwa_minute_flags,pwa_minutes
    case &dt_pminutes                 |
     sbit  pwa_minute_flags,pwa_pminutes
    case &dt_iminutes                 |
     sbit  pwa_minute_flags,pwa_iminutes
    case &dt_seconds                  |
     sbit  pwa_second_flags,pwa_seconds
    case &dt_pseconds                 |
     sbit  pwa_second_flags,pwa_pseconds
    case &dt_iseconds                 |
     sbit  pwa_second_flags,pwa_iseconds
    case &dt_hundredths               |
     sbit  pwa_interval_flags,pwa_hundredths
    case &dt_phundredths              |
     sbit  pwa_interval_flags,pwa_phundredths
    case &dt_ihundredths              |
     sbit  pwa_interval_flags,pwa_ihundredths
    case &dt_todclock                 |
     sbit  pwa_interval_flags,pwa_todclock
    case other                        |
   endcase                            |
*  *------------------------------------------------------------------*
*  * Call requested interval conversion routine.
*  *------------------------------------------------------------------*
   l32   r14,cpl_interval_format      | Get addr of interval format
   l     r14,0(,r14)                  |  Get format in R14.
   caseblk  reg=r14                   | Set up and call format routine:
    case       &dt_hundredths,&dt_phundredths,&dt_ihundredths,         *
               &dt_hours,&dt_phours,&dt_ihours,                        *
               &dt_minutes,&dt_pminutes,&dt_iminutes,                  *
               &dt_seconds,&dt_pseconds,&dt_iseconds,                  *
               &dt_days,&dt_pdays,&dt_idays
     callsub Convert_Internal_To_Integer_Interval
    case &dt_delta                    |
     callsub Convert_Internal_To_Delta_Interval
    case &dt_todclock                 |                             @cy
     callsub Convert_Time_To_Todclock |                             @cy
*                                     |
    case other                        | Unknown time format:
     l     r15,cpl_interval_format    |  Point to format address
     l     r15,0(,r15)                |  Load format into R15
     errexit code=&dt_invalid_interval_format Return error to caller.
   endcase                            |
  endblk                              |
 endblk                               |
 title "Convert Environment Support Format To Internal Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_From_ES_Format
*  Abstract:   This routine converts a date and time from the format
*              returned by ES_Get_Time (see below) to a doubleword
*              number of microseconds since Jan. 1, 0000.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Doubleword at (parmlist+8%) filled in
*  Special     This routine was adapted from a routine provided in
*  Notes:      Dave Crow's presentation "Setting A Computer's Clock
*              Correctly" at SHARE 67 in Atlanta.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_From_ES_Format,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
  l32   r2,cpl_date                   | Point to input date
  if    (nz)                          |
   Convert_Juldate_To_Days Juldate=0(4,r2),                            *
               Work=pwa_d,            |                                *
               Days=R1                |
   Convert_Days_To_DT_Units reg=R0    |
  endif                               |
  l     r15,4(,r2)                    | Get time in .01-seconds
  m     r14,=a(10000)                 | Make it microseconds
* *-------------------------------------------------------------------*
* * Perform doubleword integer add.
* *-------------------------------------------------------------------*
  ar    r0,r14                        | Add-logical upper half
  alr   r1,r15                        | Add-logical lower half
  if    not,(cc12)                    | If overflow in low half
   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.
  endif                               |
  l     r15,cpl_internal              | Point to place to put result
  stm   r0,r1,0(r15)                  | Save result for caller
  drop  r4                            |
 endblk rc=0                          | Return to caller
 title "Convert Internal Format To Environment Support Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_To_ES_Format
*  Abstract:   This routine converts an internal DT-format time into
*              a yyyy.ddd date and .01-sec-from-midnight time.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Environment Support format date and time filled in
*  Special     Adapted from routine provided in Dave Crow's talk at
*  Notes:        Share 67, Atlanta (O317 Setting A Computer's Clock
*                Correctly)
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_To_ES_Format,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              |
  Convert_DT_Units_To_Days  Reg=R0,   |                                *
               Units=0(r15)           |
*                                     | R1 is now # days since 1/1/0000
  lr    r2,r0                         | Save remainder (microseconds)
  l     r3,4(,r15)                    | Get lo-order half of msec stamp
  sll   r3,(32-13)                    | Shift mics to hi end of r3
  srdl  r2,(32-13)                    | Shift both back
  d     r2,=a(10000)                  | Make into .01-sec units
  l     r2,cpl_date                   | Point to date/time return area
  st    r3,4(,r2)                     | Return the time at +4
  Convert_Days_To_Juldate  Days=R1,   | Return the date at +0          *
               Work=pwa_d,            |                                *
               Juldate=0(,r2)         |
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Hundredths Format Time To Internal Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Time_From_Hundredths
*  Abstract:   This routine adds the integer .01-second units to the
*              internal-format time value.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Hundredths format date and time filled in
*  Special     Adapted from routine provided in Dave Crow's talk at
*  Notes:        Share 67, Atlanta (O317 Setting A Computer's Clock
*                Correctly)
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Time_From_Hundredths,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
  l32   r15,cpl_time                  | Get time in .01-seconds
  if    (nz)                          |
   l     r15,0(,r15)                  | Get the value
   m     r14,=a(10000)                | Make it microseconds
  endif                               |
* *-------------------------------------------------------------------*
* * Add time to existing (if any) internal-format time.
* *-------------------------------------------------------------------*
  l     r1,cpl_internal               | Get addr of internal-fmt time
  lm    r0,r1,0(r1)                   | Get the value in a reg pair
  ar    r0,r14                        | Add-logical upper half
  alr   r1,r15                        | Add-logical lower half
  if    not,(cc12)                    | If overflow in low half
   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.
  endif                               |
  l     r15,cpl_internal              | Point to place to put result
  stm   r0,r1,0(r15)                  | Save result for caller
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Internal Format To Hundredths Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Time_To_Hundredths
*  Abstract:   This routine converts an internal DT-format time into
*              a .01-sec-from-midnight time.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Hundredths-format time filled in
*  Special     Adapted from routine provided in Dave Crow's talk at
*  Notes:        Share 67, Atlanta (O317 Setting A Computer's Clock
*                Correctly)
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Time_To_Hundredths,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              |
  Convert_DT_Units_To_Days  Reg=R0,   | We want remainder in R0        *
               Units=0(r15)           |
*                                     | R1 is now # days since 1/1/0000
  lr    r2,r0                         | Save remainder (microseconds)
  l     r3,4(,r15)                    | Get lo-order half of msec stamp
  sll   r3,(32-13)                    | Shift mics to hi end of r3
  srdl  r2,(32-13)                    | Shift both back
  d     r2,=a(10000)                  | Make into .01-sec units
  l     r15,cpl_time                  | Point to time dest. field
  st    r3,0(,r15)                    |  and save into time area.
  drop  r4                            |
 endblk rc=0                          |
 title "Convert TODclock Format Time To Internal Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Time_From_TODclock
*  Abstract:   This routine converts a S/370 time-of-day clock value
*              to the internal-format date and time value.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    TODclock format date and time filled in
*  Special     Adapted from routine provided in Dave Crow's talk at
*  Notes:        Share 67, Atlanta (O317 Setting A Computer's Clock
*                Correctly)
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Time_From_TODclock,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_time                  | Get address of TOD value
  lm    r14,r15,0(r15)                | Get TOD-clock value
  srdl  r14,12                        | Convert to microseconds
  lm    r0,r1,psd_mics_lower_limit      Get TOD's true begin date
  alr   r1,r15                        | Perform doubelword add
  if    not,(cc12)                    |
   ah    r0,=h'1'                     |
  endif                               |
  ar    r0,r14                        |
  l     r15,cpl_internal              |
  stm   r0,r1,0(r15)                  |
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Internal Format To TODclock Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Time_To_TODclock
*  Abstract:   This routine converts an internal DT-format date and
*              time value into a S/370 time-of-day clock value.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    TODclock-format time filled in
*  Special     Adapted from routine provided in Dave Crow's talk at
*  Notes:        Share 67, Atlanta (O317 Setting A Computer's Clock
*                Correctly)
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Time_To_TODclock,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              |
  errexit      (clc,0(8,r15),lt,psd_mics_lower_limit),or,              *
               (clc,0(8,r15),gt,psd_mics_upper_limit),                 *
               code=&dt_out_of_range  |
  lm    r0,r1,0(r15)                  |   Get internal-format stamp
  lm    r14,r15,psd_mics_lower_limit      Get equiv. TOD zero value
  slr   r1,r15                        |   Convert
  if    (cc12)                        |
   sh    r0,=h'1'                     |
  endif                               |
  sr    r0,r14                        |
  sldl  r0,12                         | Shift microsecs to bit 51
  l     r15,cpl_time                  |
  stm   r0,r1,0(r15)                  |
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Julian Format Time To Internal Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_From_Julian
*  Abstract:   This routine converts various formats of Julian date to
*              the internal format.  The following types of Julian date
*              are presently supported:
*                .. &DT_Julian   (ex. C'1989351')
*                .. &DT_Juliand  (ex. C'1989.351')
*                .. &DT_Ijulian  (ex. F'1989351')
*                .. &DT_Pjulian  (ex. P'1989351')
*                .. &DT_Sjulian  (ex. C'89351')
*                .. &DT_Sjuliand (ex. C'89.351')
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Julian format date converted to internal format.
*  Notes:      Only R14 is saved and restored.
*              Options=*NoSubOpts removed due to size constraints
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_From_Julian,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
  l32   r3,cpl_date                   | Get date in .01-seconds
* *-------------------------------------------------------------------*
* * Look at pwa_julian_flags and perform appropriate conversion.
* * (Pjulian format does not need special attention.)
* *-------------------------------------------------------------------*
  if     (tbit,pwa_julian_flags,pwa_ijulian)
*  *------------------------------------------------------------------*
*  * Ijulian date.  Convert to decimal.
*  *------------------------------------------------------------------*
   l     r15,0(,r3)                   |
   cvd   r15,pwa_d                    |
   mvc   pwa_f,pwa_d+4                |
*   *-----------------------------------------------------------------*
*   * Pjulian date.  Ensure packed-decimal, then copy to workarea.
*   *-----------------------------------------------------------------*
  elseif (tbit,pwa_julian_flags,pwa_pjulian)
   Validate_Packed_Data Data=0(r3),Len=4,Type=DATE
   mvc   pwa_f,0(r3)                  |
  else                                |
   if    (tbit,pwa_julian_flags,pwa_julian)
*   *----------------------------------------------------------------*
*   * Julian date.  Validity-check, then pack into workarea.
*   *----------------------------------------------------------------*
    callsub validate_julian_formats   |
    errexit (treg,r15,nz),code=&dt_invalid_input_date
    mvc   pwa_d(7),0(r3)              |
   elseif (tbit,pwa_julian_flags,pwa_sjulian)
*   *----------------------------------------------------------------*
*   * Sjulian date.  Validity-check, then pack into workarea.
*   *----------------------------------------------------------------*
    callsub validate_julian_formats   |
    errexit (treg,r15,nz),code=&dt_invalid_input_date
    mvc   pwa_d(2),psd_default_century
    mvc   pwa_d+2(5),0(r3)            |
         eject ,
   elseif (tbit,pwa_julian_flags,pwa_juliand)
*   *----------------------------------------------------------------*
*   * Juliand date.  Validity-check, then pack into workarea.
*   *----------------------------------------------------------------*
    callsub validate_julian_formats   |
    errexit (treg,r15,nz),code=&dt_invalid_input_date
    mvc   pwa_d(4),0(r3)              |  Move the years
    mvc   pwa_d+4(3),5(r3)            |  Append the days
   elseif (tbit,pwa_julian_flags,pwa_sjuliand)
*   *-----------------------------------------------------------------*
*   * Sjuliand date.  Validity-check, then pack into workarea.
*   *-----------------------------------------------------------------*
    callsub validate_julian_formats   |
    errexit (treg,r15,nz),code=&dt_invalid_input_date
    mvc   pwa_d(2),psd_default_century
    mvc   pwa_d+2(2),0(r3)            |
    mvc   pwa_d+4(3),3(r3)            |
   endif                              |
   pack   pwa_f(4),pwa_d(7)           |
  endif                               |
  if    (cp,pwa_f,ne,=p'0')           | If date isn't zero
   Convert_Juldate_To_Days Juldate=pwa_f,  Convert it,                 *
               Work=pwa_d,            |                                *
               Days=R1                |
  else                                |
   xr    r1,r1                        | else force a zero.
  endif                               |
  Convert_Days_To_DT_Units reg=R0     |
* *-------------------------------------------------------------------*
* * Add date to existing (if any) internal-format time.
* *-------------------------------------------------------------------*
  l     r15,cpl_internal              | Get addr of internal-fmt time
  lm    r14,r15,0(r15)                | Get the value in a reg pair
  ar    r0,r14                        | Add-logical upper half
  alr   r1,r15                        | Add-logical lower half
  if    not,(cc12)                    | If overflow in low half
   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.
  endif                               |
  l     r15,cpl_internal              | Point to place to put result
  stm   r0,r1,0(r15)                  | Save result for caller
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Internal Format To Julian Format Date"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_To_Julian
*  Abstract:   This routine converts an internal-format date to various
*              Julian date formats.  The following types of Julian date
*              are presently supported:
*                .. &DT_Julian   (ex. C'1989351')
*                .. &DT_Juliand  (ex. C'1989.351')
*                .. &DT_Ijulian  (ex. F'1989351')
*                .. &DT_Pjulian  (ex. P'1989351')
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Julian format date filled in
*  Special     Adapted from routine provided in Dave Crow's talk at
*  Notes:        Share 67, Atlanta (O317 Setting A Computer's Clock
*                Correctly)
*              Only R14 is saved and restored. R15-R4 are destroyed.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_To_Julian,type=subroutine,                    *
               options=(*nosubopts),                                   *
               save=(r14,pwa_converter_r14)
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              |
  Convert_DT_Units_To_Days  Reg=R0,   |                                *
               Units=0(r15)           |
*                                     | R1 is now # days since 1/1/0000
  Convert_Days_To_Juldate  Days=R1,   |                                *
               Work=pwa_d,            |                                *
               Juldate=pwa_f          |
* *-------------------------------------------------------------------*
* * Look at pwa_julian_flags and perform appropriate conversion.
* *-------------------------------------------------------------------*
  l     r2,cpl_date                   | Point to result area
  if    (tbit,pwa_julian_flags,pwa_ijulian)
*  *------------------------------------------------------------------*
*  * Perform Ijulian conversion.
*  *------------------------------------------------------------------*
   zap   pwa_d,pwa_f                  |
   cvb   r1,pwa_d                     |
   st    r1,0(,r2)                    |
  elseif (tbit,pwa_julian_flags,pwa_pjulian)
*  *------------------------------------------------------------------*
*  * Perform Pjulian conversion.
*  *------------------------------------------------------------------*
   mvc   0(4,r2),pwa_f                |
  elseif (tbit,pwa_julian_flags,pwa_julian)
*  *------------------------------------------------------------------*
*  * Perform Julian conversion.
*  *------------------------------------------------------------------*
   mvc   pwa_edit(8),=x'4021202020202020'
   ed    pwa_edit(8),pwa_f            |
   mvc   0(7,r2),pwa_edit+1           |
   oi    0(r2),x'f0'                  |
        eject ,
  elseif (tbit,pwa_julian_flags,pwa_sjulian)
*  *------------------------------------------------------------------*
*  * Perform Sjulian conversion.
*  *------------------------------------------------------------------*
   mvc   pwa_edit(6),=x'402120202020' |
   ed    pwa_edit(6),pwa_f+1          |
   mvc   0(5,r2),pwa_edit+1           |
   oi    0(r2),x'f0'                  |
  elseif (tbit,pwa_julian_flags,pwa_juliand)
*  *------------------------------------------------------------------*
*  * Perform Juliand conversion.
*  *------------------------------------------------------------------*
   mvc   pwa_edit(9),=x'40212020204b202020'
   ed    pwa_edit(9),pwa_f            |
   mvc   0(8,r2),pwa_edit+1           |
   oi    0(r2),x'f0'                  |
  elseif (tbit,pwa_julian_flags,pwa_sjuliand)
*  *------------------------------------------------------------------*
*  * Perform Sjuliand conversion.
*  *------------------------------------------------------------------*
   mvc   pwa_edit(7),=x'4021204b202020'
   ed    pwa_edit(7),pwa_f+1          |
   mvc   0(6,r2),pwa_edit+1           |
   oi    0(r2),x'f0'                  |
  endif                               |
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Gregorian Format Time To Internal Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_From_Gregorian
*  Abstract:   This routine converts an American (mm/dd/yyyy) or an
*              English (dd/mm/yyyy) format Gregorian date to the
*              internal format.  It also converts the Sortdate and
*              short Sortdate formats.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Gregorian format date converted to internal format.
*  Notes:      Only R14 is saved and restored. R15-R4 are destroyed.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_From_Gregorian,type=subroutine,               *
               options=(*nosubopts),                                   *
               save=(r14,pwa_converter_r14)
  lr    r4,r1                         |
  using cpl,r4                        |
  callsub validate_gregorian_formats  |
  errexit (treg,r15,nz),code=&dt_invalid_input_date
*---------------------------------------------------------------------*
*  Extract months and days.
*---------------------------------------------------------------------*
  pack  pwa_d,pwa_numeric_year        | Pack years,
  cvb  r1,pwa_d                       | Convert year to integer.
  st   r1,pwa_i_year                  |
  pack  pwa_d,pwa_numeric_month       | Pack months,
  cvb  r1,pwa_d                       | Convert month to integer.
  st   r1,pwa_i_month                 |
  pack  pwa_d,pwa_numeric_day         | Pack days,
  cvb  r1,pwa_d                       | Convert day to integer.
  st   r1,pwa_i_day                   |
  callsub Convert_Gregorian_To_Days,  |                                *
               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *
               novl                   |
  l     r1,pwa_number_of_days         |
  Convert_Days_To_DT_Units  reg=r0    |
  l     r15,cpl_internal              |
  lm    r14,r15,0(r15)                | Get the value in a reg pair
  ar    r0,r14                        | Add-logical upper half
  alr   r1,r15                        | Add-logical lower half
  if    not,(cc12)                    | If overflow in low half
   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.
  endif                               |
  l     r15,cpl_internal              | Point to place to put result
  stm   r0,r1,0(r15)                  | Save result for caller
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Internal Format Time To Gregorian Date"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_To_Gregorian
*  Abstract:   This routine will convert the internal-format timestamp
*              to a Gregorian format.  The following are supported:
*              .. &DT_Gregorian  -- C'mm/dd/yyyy'  or  C'dd/mm/yyyy'
*              .. &DT_Sgregorian -- C'mm/dd/yy'    or  C'dd/mm/yy'
*              .. &DT_Sortdate   -- C'yyyy-mm-dd'
*              .. &DT_Ssortdate  -- C'yy-mm-dd'
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Internal format date converted to Gregorian format.
*  Notes:      Only R14 is saved and restored. R15-R4 are destroyed.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_To_Gregorian,type=subroutine,                 *
               options=(*nosubopts),                                   *
               save=(r14,pwa_converter_r14)
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              |
  Convert_DT_Units_To_Days  Units=0(r15),Reg=R0
  st    r1,pwa_number_of_days         |
  callsub Convert_Days_To_Gregorian,  |                                *
               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days)
  l    r1,pwa_i_year                  |
  cvd  r1,pwa_d                       | Convert years to packed,
  mvc  pwa_edit(6),=xl6'402120202020' | then edit and save result.
  ed   pwa_edit(6),pwa_d+5            |
  mvc  pwa_numeric_year,pwa_edit+2    |
  l    r1,pwa_i_day                   |
  cvd  r1,pwa_d                       | Convert days to packed,
  mvc  pwa_edit(6),=xl6'402120202020' | then edit and save result.
  ed   pwa_edit(6),pwa_d+5            |
  mvc  pwa_numeric_day,pwa_edit+4     |
  l    r1,pwa_i_month                 |
  cvd  r1,pwa_d                       | Convert months to packed,
  mvc  pwa_edit(6),=xl6'402120202020' | then edit and save result.
  ed   pwa_edit(6),pwa_d+5            |
  mvc  pwa_numeric_month,pwa_edit+4   |
  l     r15,cpl_date                  |
  if  not,(tbit,pwa_gregorian_flags,(pwa_gregorian+pwa_sgregorian),off)
   mvi   2(r15),c'/'                  |
   mvi   5(r15),c'/'                  |
   if    (tbit,pwa_gregorian_flags,pwa_gregorian)
    mvc   6(4,r15),pwa_numeric_year   |
   elseif (tbit,pwa_gregorian_flags,pwa_sgregorian)
    mvc   6(2,r15),pwa_numeric_year+2 |
   endif                              |
   if    (tbit,pwaf1eur)              |
    mvc   0(2,r15),pwa_numeric_day    |
    mvc   3(2,r15),pwa_numeric_month  |
   else                               |
    mvc   0(2,r15),pwa_numeric_month  |
    mvc   3(2,r15),pwa_numeric_day    |
   endif                              |
  elseif (tbit,pwa_gregorian_flags,pwa_sortdate)
   mvc   0(4,r15),pwa_numeric_year    |
   mvi   4(r15),c'-'                  |
   mvc   5(2,r15),pwa_numeric_month   |
   mvi   7(r15),c'-'                  |
   mvc   8(2,r15),pwa_numeric_day     |
  elseif (tbit,pwa_gregorian_flags,pwa_ssortdate)
   mvc   0(2,r15),pwa_numeric_year+2  |
   mvi   2(r15),c'-'                  |
   mvc   3(2,r15),pwa_numeric_month   |
   mvi   5(r15),c'-'                  |
   mvc   6(2,r15),pwa_numeric_day     |
  endif                               |
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Number_Of_Days Format To Internal Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_From_Number
*  Abstract:   This routine converts an input number of days since Jan.
*              1, 0000 to internal format.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Number of days converted to internal format.
*  Notes:      Only R14 is saved and restored. R15-R4 are destroyed.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_From_Number,type=subroutine,                  *
               options=(*nosubopts),                                   *
               save=(r14,pwa_converter_r14)
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r1,cpl_date                   |
  l     r1,0(,r1)                     |
  Convert_Days_To_DT_Units  reg=r0    |
  l     r15,cpl_internal              |
  lm    r14,r15,0(r15)                | Get the value in a reg pair
  ar    r0,r14                        | Add-logical upper half
  alr   r1,r15                        | Add-logical lower half
  if    not,(cc12)                    | If overflow in low half
   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.
  endif                               |
  l     r15,cpl_internal              | Point to place to put result
  stm   r0,r1,0(r15)                  | Save result for caller
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Internal Format Date To Number Of Days"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_To_Number
*  Abstract:   This routine will convert the internal-format timestamp
*              to the number of days since Jan. 1, 0000.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Internal format date converted to number-of-days format.
*  Notes:      Only R14 is saved and restored. R15-R4 are destroyed.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_To_Number,type=subroutine,                    *
               options=(*nosubopts),                                   *
               save=(r14,pwa_converter_r14)
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              |
  Convert_DT_Units_To_Days  Units=0(r15),Reg=R0
  l     r15,cpl_date                  |
  st    r1,0(,r15)                    |
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Normal Format Time To Internal Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_From_Normal
*  Abstract:   This routine converts a normal-format date to the inter-
*              format.  The following are supported:
*              .. &DT_Normal   -- C"dd mmm yyyy"
*              .. &DT_Snormal  -- C"dd mmm yy"
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Normal format date converted to internal format.
*  Notes:      Only R14 is saved and restored. R15-R4 are destroyed.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_From_Normal,type=subroutine,                  *
               options=(*nosubopts),                                   *
               save=(r14,pwa_converter_r14)
  lr    r4,r1                         |
  using cpl,r4                        |
  callsub validate_normal_formats     | Validate, fill in PWA values
  errexit (treg,r15,nz),code=&dt_invalid_input_date
  callsub Convert_Gregorian_To_Days,  |                                *
               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *
               novl                   |
  l     r1,pwa_number_of_days         |
  Convert_Days_To_DT_Units  reg=r0    |
  l     r15,cpl_internal              |
  lm    r14,r15,0(r15)                | Get the value in a reg pair
  ar    r0,r14                        | Add-logical upper half
  alr   r1,r15                        | Add-logical lower half
  if    not,(cc12)                    | If overflow in low half
   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.
  endif                               |
  l     r15,cpl_internal              | Point to place to put result
  stm   r0,r1,0(r15)                  |
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Internal Format Time To Normal Date"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_To_Normal
*  Abstract:   This routine converts an internal format timestamp to
*              'normal' format.  The following are supported:
*              .. &DT_Normal   -- C"dd mmm yyyy"
*              .. &DT_Snormal  -- C"dd mmm yy"
*              .. &DT_Sasdate9 -- C"ddmmmyyyy"
*              .. &DT_Sasdate7 -- C"ddmmmyy"
*              .. &DT_yyyymmmdd -- C"yyyymmmdd"
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Internal format date converted to normal format.
*  Notes:      Only R14 is saved and restored. R15-R4 are destroyed.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_To_Normal,type=subroutine,                    *
               options=(*nosubopts),                                   *
               save=(r14,pwa_converter_r14)
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              |
  Convert_DT_Units_To_Days  Units=0(r15),Reg=R0
  st    r1,pwa_number_of_days         |
  callsub Convert_Days_To_Gregorian,  |                                *
               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *
               novl                   |
  l     r1,pwa_i_year                 |
  cvd   r1,pwa_d                      | Convert years to packed,
  mvc   pwa_edit(6),=x'402120202020'  |  then edit and save result.
  ed    pwa_edit(6),pwa_d+5           |
  mvc   pwa_numeric_year,pwa_edit+2   |
  l     r1,pwa_i_day                  | Convert days to packed,
  cvd   r1,pwa_d                      |  then edit and save result.
  mvc   pwa_edit(4),=xl4'40212020'    |
  ed    pwa_edit(4),pwa_d+6           |
  mvc   pwa_numeric_day,pwa_edit+2    |
  l     r0,pwa_i_month                | Look up month:
  la    r14,psd_month_table           |
  using month_table,r14               |
  fill  pwa_text_month,c' '           |
  la    r15,mt_#_entries              |
  loop  bct                           |
   leave loop=*,(ch,r0,eq,mt_month_num)
   la    r14,mt_length(,r14)          |
  endloop bct,r15                     |
  mvc  pwa_text_month(3),mt_month_name
  drop  r14                           |
  l     r2,cpl_date                   |
  if    (tbit,pwa_normal_flags,pwa_normal)  Build normal format date
   fill  0(r2),c' ',length=11         |
   mvc   0(2,r2),pwa_numeric_day      |
   mvc   3(3,r2),pwa_text_month       |
   mvc   7(4,r2),pwa_numeric_year     |
  elseif (tbit,pwa_normal_flags,pwa_snormal)  Build short-normal date
   fill  0(r2),c' ',length=9          |
   mvc   0(2,r2),pwa_numeric_day      |
   mvc   3(3,r2),pwa_text_month       |
   mvc   7(2,r2),pwa_numeric_year+2   |
  elseif (tbit,pwa_normal_flags,pwa_sasdate7)  Build SAS DATE7. date
   mvc   0(2,r2),pwa_numeric_day      |
   mvc   2(3,r2),pwa_text_month       |
   mvc   5(2,r2),pwa_numeric_year+2   |
  elseif (tbit,pwa_normal_flags,pwa_sasdate9)  Build SAS DATE9. date
   mvc   0(2,r2),pwa_numeric_day      |
   mvc   2(3,r2),pwa_text_month       |
   mvc   5(4,r2),pwa_numeric_year     |
  elseif (tbit,pwa_normal_flags,pwa_yyyymmmdd) Build YYYYMMMDD date @cx
   mvc   0(4,r2),pwa_numeric_year     |                             @cx
   mvc   4(3,r2),pwa_text_month       |                             @cx
   mvc   7(2,r2),pwa_numeric_day      |                             @cx
  endif                               |
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Date From General_Input Format To Internal Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_From_General_Input
*  Abstract:   This routine determines if the input date value is
*              a recognized format: if so, it is converted to the
*              internal format.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Date converted and added to internal format date/time.
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_From_General_Input,                           *
               type=subroutine        |
  lr    r5,r1                         | Save incoming CPL address
  plist (*,*,*,*,*),novl              | Build partial CPL for
  mvc   0(20,r1),0(r5)                |
  lr    r4,r1                         |  validation routines
  using cpl,r4                        | Save CPL ptr, base on it
* *-------------------------------------------------------------------*
* *  Date validation calls.
* *-------------------------------------------------------------------*
  block name=date_validation          |
   l     r15,cpl_date                 |
   l32   r1,0(r15)                    |
   if    z                            | Leave if date absent. Note that
    xr    r15,r15                     |  this causes the code after the
    leave block=*                     |   next ENDBLK to do the right
   endif                              |    thing if DATE wasn't coded.
   lr    r1,r4                        |
*  *----------------------------------------------------------------*
*  *  Julian date validation first.
*  *----------------------------------------------------------------*
   mvi   pwa_julian_flags,pwa_julian  | Tell validate rtn what to do
   callsub validate_julian_formats    | Check it out
   if    (treg,r15,z)                 | If it was OK
    la    r1,&dt_julian               |  return format to caller.
    leave block=*                     |
   endif                              |
*  *----------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_julian_flags,pwa_juliand |
   callsub validate_julian_formats    |
   if    (treg,r15,z)                 |
    la    r1,&dt_juliand              |
    leave block=*                     |
   endif                              |
*  *----------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_julian_flags,pwa_sjulian |
   callsub validate_julian_formats    |
   if    (treg,r15,z)                 |
    la    r1,&dt_sjulian              |
    leave block=*                     |
   endif                              |
*  *------------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_julian_flags,pwa_sjuliand
   callsub validate_julian_formats    |
   if    (treg,r15,z)                 |
    la    r1,&dt_sjuliand             |
    leave block=*                     |
   endif                              |
*  *------------------------------------------------------------------*
*  *  Gregorian date validation.
*  *------------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_gregorian_flags,pwa_gregorian
   callsub validate_gregorian_formats |
   if    (treg,r15,z)                 |
    la    r1,&dt_gregorian            |
    leave block=*                     |
   endif                              |
*  *----------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_gregorian_flags,pwa_sgregorian
   callsub validate_gregorian_formats |
   if    (treg,r15,z)                 |
    la    r1,&dt_sgregorian           |
    leave block=*                     |
   endif                              |
*  *----------------------------------------------------------------*
*  *  Normal date validation.
*  *----------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_normal_flags,pwa_normal  |
   callsub validate_normal_formats    |
   if    (treg,r15,z)                 |
    la    r1,&dt_normal               |
    leave block=*                     |
   endif                              |
*  *------------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_normal_flags,pwa_snormal |
   callsub validate_normal_formats    |
   if    (treg,r15,z)                 |
    la    r1,&dt_snormal              |
    leave block=*                     |
   endif                              |
*  *------------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_normal_flags,pwa_sasdate9
   callsub validate_normal_formats    |
   if    (treg,r15,z)                 |
    la    r1,&dt_sasdate9             |
    leave block=*                     |
   endif                              |
*  *------------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_normal_flags,pwa_sasdate7
   callsub validate_normal_formats    |
   if    (treg,r15,z)                 |
    la    r1,&dt_sasdate7             |
    leave block=*                     |
   endif                              |
*  *------------------------------------------------------------------*
   lr    r1,r4                        |                             @cx
   mvi   pwa_normal_flags,pwa_yyyymmmdd                             @cx
   callsub validate_normal_formats    |                             @cx
   if    (treg,r15,z)                 |                             @cx
    la    r1,&dt_yyyymmmdd            |                             @cx
    leave block=*                     |                             @cx
   endif                              |                             @cx
*  *------------------------------------------------------------------*
*  *  Text date validation.
*  *------------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_text_flags,pwa_text      |
   callsub validate_text_formats      |
   if    (treg,r15,z)                 |
    la    r1,&dt_text                 |
    leave block=*                     |
   endif                              |
*  *------------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_text_flags,pwa_textd     |
   callsub validate_text_formats      |
   if    (treg,r15,z)                 |
    la    r1,&dt_textd                |
    leave block=*                     |
   endif                              |
*  *------------------------------------------------------------------*
*  *  Sortdate format validation.
*  *------------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_gregorian_flags,pwa_sortdate
   callsub validate_gregorian_formats |
   if    (treg,r15,z)                 |
    la    r1,&dt_sortdate             |
    leave block=*                     |
   endif                              |
*  *----------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_gregorian_flags,pwa_ssortdate
   callsub validate_gregorian_formats |
   if    (treg,r15,z)                 |
    la    r1,&dt_ssortdate            |
    leave block=*                     |
   endif                              |
*  *----------------------------------------------------------------*
  endblk                              |
  if    (treg,r15,z)                  | If returncode is zero
   leave block=*,(treg,r1,z)          |  Leave if no input (this OK?)
   st    r1,pwa_actual_format         |  Save format we found
   la    r1,pwa_actual_format         |  Point to it
   st    r1,cpl_date_format-cpl(,r5)  |  Change the original format
  else                                | Otherwise (all tests failed)
   errexit code=&dt_invalid_input_date    Return 'unknown format'.
  endif                               |
 endblk rc=(r15)                      | Just leave.  This will cause
*                                     | the caseblock loop in Call_
*                                     | Convert_Input to redrive the
*                                     | conversion routines.
 title "Convert Time From General_Input Format To Internal Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Time_From_General_Input
*  Abstract:   This routine determines if the input time value is
*              a recognized format: if so, it is converted to the
*              internal format.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Date converted and added to internal format date/time.
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Time_From_General_Input,                           *
               type=subroutine        |
  lr    r5,r1                         | Save incoming CPL address
  plist (*,*,*,*,*),novl              | Build partial CPL for
  mvc   0(20,r1),0(r5)                |
  lr    r4,r1                         |  validation routines
  using cpl,r4                        | Save CPL ptr, base on it
* *-------------------------------------------------------------------*
* *  Time validation calls.
* *-------------------------------------------------------------------*
  block name=time_validation          |
*  *------------------------------------------------------------------*
*  *  HHMMSS date validation first.
*  *------------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_hhmmss_flags,pwa_hhmmssth
   callsub validate_hhmmss_formats    |
   if    (treg,r15,z)                 |
    la    r1,&dt_hhmmssth             |
    leave block=*                     |
   endif                              |
*  *------------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_hhmmss_flags,pwa_civilian
   callsub validate_hhmmss_formats    |
   if    (treg,r15,z)                 |
    la    r1,&dt_civilian             |
    leave block=*                     |
   endif                              |
*  *------------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_hhmmss_flags,pwa_hhmmss  |
   callsub validate_hhmmss_formats    |
   if    (treg,r15,z)                 |
    la    r1,&dt_hhmmss               |
    leave block=*                     |
   endif                              |
*  *------------------------------------------------------------------*
   lr    r1,r4                        |
   mvi   pwa_hhmmss_flags,pwa_hhmm    |
   callsub validate_hhmmss_formats    |
   if    (treg,r15,z)                 |
    la    r1,&dt_hhmm                 |
    leave block=*                     |
   endif                              |
*  *------------------------------------------------------------------*
  endblk                              |
  drop  r4                            |
  if    (treg,r15,z)                  | If returncode is zero
   leave block=*,(treg,r1,z)          |  Leave if no input (this OK?)
   st    r1,pwa_actual_format         |
   la    r1,pwa_actual_format         |
   st    r1,cpl_time_format-cpl(,r5)  |  Get address of original format
  else                                | Otherwise (all tests failed)
   errexit code=&dt_invalid_input_time    Return 'unknown format'.
  endif                               |
 endblk rc=(r15)                      | Just leave.  This will cause
 title "Convert Time From HH:MM:SS.TH Format To Internal Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Time_From_HHMMSS
*  Abstract:   This routine converts anm input time of the format
*              hh:mm:ss.th or hh:mm:ss:th to the internal format.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Time converted and added to internal format time.
*  Special
*  Notes:      This subroutine only saves R14. It destroys R0, R1, R2
*              and R15.
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Time_From_HHMMSS,type=subroutine,                  *
               options=(*nosubopts),                                   *
               save=(r14,pwa_converter_r14)
  lr   r4,r1                          |
  using cpl,r4                        |
  callsub validate_HHMMSS_formats     |
  errexit (treg,r15,nz),code=&dt_invalid_input_time
  l    r15,cpl_time                   |
* *-------------------------------------------------------------------*
* * Reduce time as requested to .01-second units, then add to the
* * internal-format time pointed to by the CPL.
* *-------------------------------------------------------------------*
  pack  pwa_d,0(2,r15)                | Pack the hours
  cvb   r0,pwa_d                      | Convert to integer in R0
  mh    r0,=h'60'                     | Turn into minutes
  pack  pwa_d,3(2,r15)                | Pack the minutes
  cvb   r1,pwa_d                      | Change to integer in R1
  ar    r0,r1                         | Add to accumulated minutes
  mh    r0,=h'60'                     | Turn accum. into seconds
  if    (tbit,pwa_hhmmss_flags,pwa_hhmm,off)  If seconds present
   pack  pwa_d,6(2,r15)               | Pack the seconds
   cvb   r1,pwa_d                     | Change to integer in R1
   ar    r0,r1                        | Add to accumulated seconds
  endif                               |
  mh    r0,=h'100'                    | Turn accum. into .01-seconds
  if    (tbit,pwa_hhmmss_flags,pwa_hhmmssth)
   pack  pwa_d,9(2,r15)               | Pack the hundredths
   cvb   r1,pwa_d                     | Change to integer in R1
   ar    r0,r1                        | Add to accum'd .01-seconds
  endif                               |
  if    (tbit,pwa_hhmmss_flags,pwa_civilian),and,  If civilian time    *
               (clc,=c' PM',eq,8(r15)),and,         and it's afternoon *
               (clc,=c'12',ne,0(r15)) |              and past 12:00
   a     r0,=f'4320000'               | Add 1/2 day of .01-sec units
  endif                               |
  lr    r1,r0                         |
  m     r0,=f'10000'                  |
  l     r2,cpl_internal               |
  lm    r14,r15,0(r2)                 |
  ar    r0,r14                        | Add-logical upper half
  alr   r1,r15                        | Add-logical lower half
  if    not,(cc12)                    | If overflow in low half
   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.
  endif                               |
  stm    r0,r1,0(r2)                  | Save result for caller
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Time From Internal Format To HH:MM:SS:TH Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Time_To_HHMMSS
*  Abstract:   This routine converts the internal-format time to
*              hh:mm:ss.th format.  This routine also handles the
*              following variations:
*              . &DT_HHMM     -- hh:mm format
*              . &DT_HHMMSS   -- hh:mm:ss format
*              . &DT_CIVILIAN -- hh:mm:ss AM/PM format
*              . &DT_HOURS,&DT_PHOURS,&DT_IHOURS
*              . &DT_MINUTES,&DT_PMINUTES,&DT_IMINUTES
*              . &DT_SECONDS,&DT_PSECONDS,&DT_ISECONDS
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Time converted to requested format.
*  Special
*  Notes:      This subroutine only saves R14. It destroys R0, R1, R2
*              and R15.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Time_To_HHMMSS,type=subroutine,                    *
               options=(*nosubopts),                                   *
               save=(r14,pwa_converter_r14)
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              |
  Convert_DT_Units_To_Days  Reg=R0,   | We want remainder in R0        *
               Units=0(r15)           |
*                                     | R1 is now # days since 1/1/0000
  lr    r2,r0                         | Save remainder (microseconds)
  l     r3,4(,r15)                    | Get lo-order half of msec stamp
  sll   r3,(32-13)                    | Shift mics to hi end of r3
  srdl  r2,(32-13)                    | Shift both back
  d     r2,=a(10000)                  | Make into .01-sec units in R3.
  lr    r1,r3                         |
  xr    r0,r0                         | Clear R0 for division
  la    r15,100                       | Get mod(.01-secs / 100)
  dr    r0,r15                        | Quotient (R1) = seconds,
  cvd   r0,pwa_d                      | remainder (R0) = hundredths.
  mvc   pwa_edit(4),=x'40212020'      |
  ed    pwa_edit(4),pwa_d+6           |
  mvc   pwa_numeric_hundredths,pwa_edit+2
  xr    r0,r0                         | Clear R0 for division
  la    r15,60                        | Get mod(seconds/60)
  dr    r0,r15                        | Quotient (R1) = minutes,
  cvd   r0,pwa_d                      | remainder (R0) = seconds.
  mvc   pwa_edit(4),=x'40212020'      |
  ed    pwa_edit(4),pwa_d+6           |
  mvc   pwa_numeric_second,pwa_edit+2 |
* *-------------------------------------------------------------------*
* * If partial "seconds" format requested, return it now and get out.
* *-------------------------------------------------------------------*
  if   (cli,pwa_second_flags,ne,x'00')
   l     r15,cpl_time                 |
   if    (tbit,pwa_second_flags,pwa_iseconds)
    sth   r0,0(r15)                   |
   elseif (tbit,pwa_second_flags,pwa_pseconds)
    mvc   0(2,r15),pwa_d+6            |
   elseif (tbit,pwa_second_flags,pwa_seconds)
    mvc   0(2,r15),pwa_numeric_second |
   endif                              |
   leave block=*                      |
  endif                               |
* *-------------------------------------------------------------------*
* *  Produce minutes and hours.
* *-------------------------------------------------------------------*
  xr    r0,r0                         | Clear R0 for division
  la    r15,60                        | Get mod(minutes/60)
  dr    r0,r15                        | Quotient (R1) = hours
  cvd   r0,pwa_d                      | remainder (R0) = minutes.
  mvc   pwa_edit(4),=x'40212020'      |
  ed    pwa_edit(4),pwa_d+6           |
  mvc   pwa_numeric_minute,pwa_edit+2 |
* *-------------------------------------------------------------------*
* * If partial "minutes" format requested, return it now and get out.
* *-------------------------------------------------------------------*
  if   (cli,pwa_minute_flags,ne,x'00')
   l     r15,cpl_time                 |
   if    (tbit,pwa_minute_flags,pwa_iminutes)
    sth   r0,0(r15)                   |
   elseif (tbit,pwa_minute_flags,pwa_pminutes)
    mvc   0(2,r15),pwa_d+6            |
   elseif (tbit,pwa_minute_flags,pwa_minutes)
    mvc   0(2,r15),pwa_numeric_minute |
   endif                              |
   leave block=*                      |
  endif                               |
* *-------------------------------------------------------------------*
  cvd   r1,pwa_d                      | Convert quotient to hours
  if    (tbit,pwaf1lz)                |
   mvc   pwa_edit(4),=x'40212020'     |    (w/ leading zeros)
  else                                |
   mvc   pwa_edit(4),=x'40202120'     |    (w/o leading zeros)
  endif                               |
  ed    pwa_edit(4),pwa_d+6           |
  mvc   pwa_numeric_hour,pwa_edit+2   |
* *-------------------------------------------------------------------*
* * If partial "hours" format requested, return it now and get out.
* *-------------------------------------------------------------------*
  if   (cli,pwa_hour_flags,ne,x'00')   |
   l     r15,cpl_time                 |
   if    (tbit,pwa_hour_flags,pwa_ihours)
    sth   r1,0(r15)                   |
   elseif (tbit,pwa_hour_flags,pwa_phours)
    mvc   0(2,r15),pwa_d+6            |
   elseif (tbit,pwa_hour_flags,pwa_hours)
    mvc   0(2,r15),pwa_numeric_hour   |
   endif                              |
   leave block=*                      |
  endif                               |
* *-------------------------------------------------------------------*
* * Process "full" output time formats.
* *-------------------------------------------------------------------*
  if    (tbit,pwa_hhmmss_flags,pwa_civilian) If civilian time requested
   mvc   pwa_civilian_hour,pwa_numeric_hour  Default to 'normal' hours
   if    (ch,r1,ge,=h'12')            |      If hours are at least 12
    sbit  pwa_hhmmss_flags,pwa_afternoon  Note we need to say PM later
    if    (ch,r1,gt,=h'12')           |   If more than 12 ...
     lr    r0,r1                      |
     sh    r0,=h'12'                  |    Knock 12 off hours
     cvd   r0,pwa_d                   |    Pack, edit, etc.
     if    (tbit,pwaf1lz)             |
      mvc   pwa_edit(4),=x'40212020'  |     (w/ leading zeros)
     else                             |
      mvc   pwa_edit(4),=x'40202120'  |     (w/o leading zeros)
     endif                            |
     ed    pwa_edit(4),pwa_d+6        |
     mvc   pwa_civilian_hour,pwa_edit+2    and save civilian_hour.
    endif                             |
   endif                              |
  endif                               |
  l     r15,cpl_time                  | Start building formatted time
  if    (tbit,pwa_hhmmss_flags,pwa_civilian) If civilian time requested
   mvc   0(2,r15),pwa_civilian_hour   |  Move whatever's in civ. hour
  else                                | Otherwise
   mvc   0(2,r15),pwa_numeric_hour    |  Move normal hour.
  endif                               |
  mvi   2(r15),c':'                   | Append a ":"
  mvc   3(2,r15),pwa_numeric_minute   | Add on the minutes
  if    not,(tbit,pwa_hhmmss_flags,pwa_hhmm) If we want more than hh:mm
   mvi   5(r15),c':'                  |  Append a ":"
   mvc   6(2,r15),pwa_numeric_second  |  Add on the seconds
   if    (tbit,pwa_hhmmss_flags,pwa_hhmmssth)  If we want .01-secs
    mvi   8(r15),c'.'                 |   Append a "."
    mvc   9(2,r15),pwa_numeric_hundredths  and hang the hundredths on
   elseif (tbit,pwa_hhmmss_flags,pwa_civilian)  Elseif we want civ.time
    if    (tbit,pwa_hhmmss_flags,pwa_afternoon)  If it's PM
     mvc   8(3,r15),=c' PM'           |           say so,
    else                              |          otherwise
     mvc   8(3,r15),=c' AM'           |           it's AM.
    endif                             |
   endif                              |
  endif                               |
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Time From Seconds since 1970 Format To Internal Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Time_From_SecondsSince1970
*  Abstract:   This routine converts an input time of the format
*              #seconds since Jan 1, 1970, 00:00:00.0 to internal.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Time converted and added to internal format time.
*  Special
*  Notes:      This subroutine only saves R14. It destroys R0, R1, R2
*              and R15.
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Time_From_SecondsSince1970,type=subroutine,        *
               options=(*nosubopts),                                   *
               save=(r14,pwa_converter_r14)
  lr    r4,r1                         |
  using cpl,r4                        |
  l32   r15,cpl_time                  | Get time in SecsSince1970 fmt.
  if    (nz)                          |
   l     r15,0(,r15)                  | Get the value
   m     r14,=f'1000000'              | Make it microseconds
  endif                               |
  lm    r0,r1,psd_mics_circa_1970     | Get value for start of 1970.
  alr   r15,r1                        | Perform doubelword add
  if    not,(cc12)                    |
   ah    r14,=h'1'                    |
  endif                               |
  ar    r14,r0                        |
* *-------------------------------------------------------------------*
* * Add time to existing (if any) internal-format time.
* *-------------------------------------------------------------------*
  l     r1,cpl_internal               | Get addr of internal-fmt time
  lm    r0,r1,0(r1)                   | Get the value in a reg pair
  ar    r0,r14                        | Add-logical upper half
  alr   r1,r15                        | Add-logical lower half
  if    not,(cc12)                    | If overflow in low half
   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.
  endif                               |
  l     r15,cpl_internal              | Point to place to put result
  stm   r0,r1,0(r15)                  | Save result for caller
  drop  r4                            |
 endblk block=Convert_Time_From_SecondsSince1970,rc=0
 title "Convert Time From Internal Format To SecsSince1970 Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Time_To_SecondsSince1970
*  Abstract:   This routine converts the internal-format time to
*              #seconds since 1970.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Time converted to requested format.
*  Special
*  Notes:      This subroutine only saves R14. It destroys R0, R1, R2
*              and R15.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Time_To_SecondsSince1970,type=subroutine,          *
               options=(*nosubopts),                                   *
               save=(r14,pwa_converter_r14)
  lr    r4,r1                         |
  using cpl,r4                        |
*
* Set r0:r1 = #microseconds since 1970.
*
  l     r15,cpl_internal              |
  lm    r0,r1,0(r15)                  |   Get internal-format stamp
  lm    r14,r15,psd_mics_circa_1970   |   Get value for start of 1970.
  slr   r1,r15                        |   Convert
  if    (cc12)                        |     #microseconds
   sh    r0,=h'1'                     |     since 1970-01-01
  endif                               |     to #microseconds
  sr    r0,r14                        |     since 1970-01-01
*
* Convert #microseconds since 1970-01-01 to #seconds since 1970.
*
  d     r0,=f'1000000'                | Convert to seconds.
  l     r15,cpl_time                  |
  st    r1,0(r15)                     |
  drop  r4                            |
 endblk block=Convert_Time_To_SecondsSince1970,rc=0
 title "Convert Date From Text Format To Internal Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_From_Text
*  Abstract:   This routine converts an input date of the format
*              'monthname nn, year' to the internal format.
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Date converted and added to internal format time.
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_From_Text,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
  callsub validate_text_formats       |
  errexit (treg,r15,nz),code=&dt_invalid_input_date
* *-------------------------------------------------------------------*
* *  Lookup and validate month, then produce Gregorian date to convert.
* *-------------------------------------------------------------------*
  la    r2,psd_month_table            | Look text month up
  using month_table,r2                |
  la    r15,mt_#_entries              |
  loop  bct                           |
   leave loop=*,(clc,pwa_text_month,eq,mt_month_name)
   la    r2,mt_length(,r2)            |
  endloop bct,r15                     |
  errexit (treg,r15,z),code=&dt_invalid_input_date   Month not found.
  lh    r1,mt_month_num               |
  st    r1,pwa_i_month                |
  pack  pwa_d,pwa_numeric_year        | Pack year
  cvb   r1,pwa_d                      | Convert to integer
  st    r1,pwa_i_year                 |  and save for later.
  pack  pwa_d,pwa_numeric_day         | Validate # days in month
  cvb   r15,pwa_d                     |
  st    r15,pwa_i_day                 |
  callsub Convert_Gregorian_To_Days,  |                                *
               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *
               novl                   |
  l     r1,pwa_number_of_days         |
  xr    r0,r0                         |
  Convert_Days_To_DT_Units reg=r0     |  then convert to internal fmt.
  l     r2,cpl_internal               |
  lm    r14,r15,0(r2)                 |
  ar    r0,r14                        | Add-logical upper half
  alr   r1,r15                        | Add-logical lower half
  if    not,(cc12)                    | If overflow in low half
   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.
  endif                               |
  stm   r0,r1,0(r2)                   | Save result for caller
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Date From Internal Format To Text Or Textd Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_To_Text
*  Abstract:   This routine converts the internal-format date to
*              'monthname nn, year' format. This routine also handles
*              the following variations:
*              . &DT_TEXTD    -- 'weekday, monthname nn, year' format
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Date,converted to requested format.
*  Special
*  Notes:      None.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_To_Text,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              |
  Convert_DT_Units_To_Days  Reg=R0,   |                                *
               Units=0(r15)           |
*                                     | R1 is now # days since 1/1/0000
  st    r1,pwa_number_of_days         |
* *-------------------------------------------------------------------*
* * If output date format includes a weekday, find it now.  If the
* * weekday is all the caller wanted, return it and get out.
* *-------------------------------------------------------------------*
  if  not,(tbit,pwa_text_flags,pwa_textd+pwa_weekday+pwa_weekday3,off)
   l     r1,pwa_number_of_days        | Get number-of-days mod 7
   xr    r0,r0                        |
   d     r0,=f'7'                     |
   la    r14,psd_weekday_table        | Look up weekday
   la    r15,7                        |
   loop  bct                          |
    leave loop=*,(clm,r0,b'0001',eq,0(r14))
    la    r14,l'psd_weekday_table(,r14)
   endloop bct,r15                    |
   mvc   pwa_text_weekday,1(r14)      |  Save weekday text for later.
   if  not,(tbit,pwa_text_flags,pwa_weekday+pwa_weekday3,off)
    l     r15,cpl_date                |      If weekday format wanted:
    if    (tbit,pwa_text_flags,pwa_weekday3)  If 3-char weekday format
     la    r1,3                       |        Length to move = 3
    else                              |       Otherwise
     la    r1,l'pwa_text_weekday      |        Length is max length.
    endif                             |
    bctr  r1,0                        |
    exi   r1,(mvc,0(0,r15),pwa_text_weekday)  Return weekday to caller
    leave block=*                     |       and exit now.
   endif                              |
  endif                               |
* *-------------------------------------------------------------------*
* * The following code is for the &dt_text and &dt_textd formats. The
* * "weekday" is already known if the call is for &dt_textd.
* *-------------------------------------------------------------------*
  callsub Convert_Days_To_Gregorian,  |                                *
               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *
               novl                   |
  l     r1,pwa_i_year                 | Edit out years, then save
  cvd   r1,pwa_d                      |
  mvc   pwa_edit(6),=x'402120202020'  |  for String Handler later.
  ed    pwa_edit(6),pwa_d+5           |
  mvc   pwa_numeric_year,pwa_edit+2   |
  la    r14,psd_month_table           |
  using month_table,r14               |
  l     r1,pwa_i_month                |
  la    r15,mt_#_entries              |
  loop  bct                           |
   leave loop=*,(ch,r1,eq,mt_month_num)
   la    r14,mt_length(,r14)          |
  endloop bct,r15                     |
  mvc   pwa_text_month,mt_month_name  |
  drop  r14                           |
  l     r1,pwa_i_day                  |
  cvd   r1,pwa_d                      | Change to packed, then
  if    (tbit,pwaf1lz)
   mvc   pwa_edit(4),=x'40212020'     |  edit for return to caller.
  else
   mvc   pwa_edit(4),=x'40202120'     |  edit for return to caller.
  endif
  ed    pwa_edit(4),pwa_d+6           |
  mvc   pwa_numeric_day,pwa_edit+2    |
  if    (cli,pwa_numeric_day,eq,c' ') | If day now has a leading space
   mvc   pwa_numeric_day(1),pwa_numeric_day+1   Slide day digit left 1
   mvi   pwa_numeric_day+1,c' '       |         position; pad w/space.
  endif                               |
  fill  pwa_format_string,c' '        |
  if    (tbit,pwa_text_flags,pwa_text)  Assemble formatted text date
   st_format   id=ST,                 |                                *
               string=pwa_format_string,                               *
               resultlen=pwa_format_length,                            *
               control="{CL9 T} {CL2 T}, {CL4}",                       *
               source=(pwa_text_month,pwa_numeric_day,pwa_numeric_year)
   errexit (treg,r15,nz),code=&dt_string_handler_error
   l     r15,cpl_date                 |
   lh    r1,pwa_format_length         |
   bctr  r1,0                         |
   exi   r1,(mvc,0(0,r15),pwa_format_string)
  elseif (tbit,pwa_text_flags,pwa_textd) Assemble formatted textd date
   st_format   id=ST,                 | Format it                      *
               string=pwa_format_string,                               *
               resultlen=pwa_format_length,                            *
               control="{CL9 T}, {CL9 T} {CL2 T}, {CL4}",              *
               source=(pwa_text_weekday,pwa_text_month,pwa_numeric_day,*
               pwa_numeric_year)      |
   errexit (treg,r15,nz),code=&dt_string_handler_error
   l     r15,cpl_date                 |
   lh    r1,pwa_format_length         |
   bctr  r1,0                         |
   exi   r1,(mvc,0(0,r15),pwa_format_string)
  endif                               |
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Internal Format Date To Days-In-Month"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_To_Days
*  Abstract:   This routine returns the number of days in the current
*              month.  There is no corresponding input date routine.
*              .. &DT_Days     -- C"dd mmm yyyy"
*              .. &DT_Pdays    -- C"dd mmm yy"
*              .. &DT_Idays
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Days-in-month returned to caller in requested format.
*  Notes:      None
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_To_Days,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              |
  Convert_DT_Units_To_Days  Units=0(r15),Reg=R0
  st    r1,pwa_number_of_days         |
  callsub Convert_Days_To_Gregorian,  |                                *
               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *
               novl                   |
  l     r1,pwa_i_day                  |
  l     r15,cpl_date                  |
  if    (tbit,pwa_day_flags,pwa_idays)
   sth   r1,0(,r15)                   |
  elseif (tbit,pwa_day_flags,pwa_pdays)
   cvd   r1,pwa_d                     |
   mvc   0(2,r15),pwa_d+6             |
  elseif (tbit,pwa_day_flags,pwa_days)
   cvd   r1,pwa_d                     |
   mvc   pwa_edit(4),=xl4'40212020'   |
   ed    pwa_edit(4),pwa_d+6          |
   mvc   0(2,r15),pwa_edit+2          |
  endif                               |
 endblk rc=0                          |
 title "Convert Internal Format Time To Month Name Or Number"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_To_Months
*  Abstract:   This routine converts an internal format timestamp to
*              the name or number of the current month.  There is no
*              corresponding input routine.  The following formats
*              are supported by this routine:
*              .. &DT_Month       -- CL2'12'
*              .. &DT_Pmonth      -- PL2'12'
*              .. &DT_Imonth      -- H'12'
*              .. &DT_Monthname   -- CL9"December"
*              .. &DT_Monthname3  -- CL3"Dec"
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Internal format date converted as requested.
*  Notes:      None
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_To_Months,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              |
  Convert_DT_Units_To_Days  Units=0(r15),Reg=R0
  st    r1,pwa_number_of_days         |
  callsub Convert_Days_To_Gregorian,  |                                *
               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *
               novl                   |
  l     r0,pwa_i_month                | Look up month:
  l     r15,cpl_date                  |
  if    (tbit,pwa_month_flags,pwa_imonth)
   sth   r0,0(,r15)                   |
  elseif (tbit,pwa_month_flags,pwa_pmonth)
   cvd   r0,pwa_d                     |
   mvc   0(2,r15),pwa_d+6             |
  elseif (tbit,pwa_month_flags,pwa_month)
   mvc   pwa_edit(4),=x'40212020'     |
   cvd   r0,pwa_d                     |
   ed    pwa_edit(4),pwa_d+6          |
   mvc   0(2,r15),pwa_edit+2          |
  else                                | Must be monthname or monthname3
   la    r14,psd_month_table          |
   using month_table,r14              |
   la    r15,mt_#_entries             |
   loop  bct                          |
    leave loop=*,(ch,r0,eq,mt_month_num)
    la    r14,mt_length(,r14)         |
   endloop bct,r15                    |
   mvc  pwa_text_month(3),mt_month_name
   l     r2,cpl_date                  |
   if    (tbit,pwa_month_flags,pwa_monthname)
    mvc   0(9,r2),mt_month_name       |
   elseif (tbit,pwa_month_flags,pwa_monthname3)
    mvc   0(3,r2),mt_month_name       |
   endif                              |
   drop  r14                          |
  endif                               |
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Internal Format Time To Years"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Date_To_Years
*  Abstract:   This routine converts an internal format timestamp to
*              the year represented.  The following are supported:
*              .. &DT_Years    -- C"1989"
*              .. &DT_Pyears   -- PL4'1989'
*              .. &DT_Iyears   -- H'1989'
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Internal format date converted as requested.
*  Notes:      None
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Date_To_Years,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              |
  Convert_DT_Units_To_Days  Units=0(r15),Reg=R0
  st    r1,pwa_number_of_days         |
  callsub Convert_Days_To_Gregorian,  |                                *
               (pwa_i_month,pwa_i_day,pwa_i_year,pwa_number_of_days),  *
               novl                   |
  l     r1,pwa_i_year                 |
  l     r15,cpl_date                  |
  if    (tbit,pwa_year_flags,pwa_iyear)
   sth   r1,0(,r15)                   |
  elseif (tbit,pwa_year_flags,pwa_pyear)
   cvd   r1,pwa_d                     |
   mvc   0(4,r15),pwa_d+4             |
  else                                | Must be year or year2
   cvd   r1,pwa_d                     |
   mvc   pwa_edit(6),=x'402120202020' |
   ed    pwa_edit(6),pwa_d+5          |
   if    (tbit,pwa_year_flags,pwa_year)
    mvc   0(4,r15),pwa_edit+2         |
   elseif (tbit,pwa_year_flags,pwa_year2)
    mvc   0(2,r15),pwa_edit+4         |
   endif                              |
  endif                               |
  drop  r4                            |
 endblk rc=0                          |
 title "Convert Integer Intervals To Internal Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Integer_Interval_To_Internal
*  Abstract:   This routine converts various integer interval input
*              values to internal format. This routine handles the
*              following variations:
*              . &DT_DAYS       -- CL5 number of days
*              . &DT_PDAYS      -- PL4 number of days
*              . &DT_IDAYS      -- Halfword number of days
*              . &DT_HOURS      -- CL5 number of hours
*              . &DT_PHOURS     -- PL4 number of hours
*              . &DT_IHOURS     -- Halfword number of hours
*              . &DT_MINUTES    -- CL5 number of minutes
*              . &DT_PMINUTES   -- PL4 number of minutes
*              . &DT_IMINUTES   -- Halfword number of minutes
*              . &DT_SECONDS    -- CL5 number of seconds
*              . &DT_PSECONDS   -- PL4 number of seconds
*              . &DT_ISECONDS   -- Halfword number of seconds
*              . &DT_HUNDREDTHS -- fullword number of hundredths
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Interval, converted to requested format.
*  Special
*  Notes:      In order to convert a number of hours, minutes, etc. to
*              a number of microseconds, this routine has to multiply
*              some potentially large values together, but System/370
*              does not support a doubleword integer multiply.  This
*              is done as follows:
*              .. R1 will contain a 'multiplier' that will partially
*                 convert the input interval to microseconds.
*              .. R2 contains the rest of the multiplier, in the form
*                 of a power-of-2 exponent to do a double shift with.
*
*              This routine is called by Convert_Delta_To_Interval.
*
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Integer_Interval_To_Internal,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r3,cpl_interval               |
* *-------------------------------------------------------------------*
* *  First, determine values to multiply and shift by.
* *-------------------------------------------------------------------*
  if    (cli,pwa_day_flags,ne,x'00')  |
   if    (tbit,pwa_day_flags,pwa_days)    5-digit character days?
    errexit (%trt,0(5,r3),ne,psd_numeric_table),                       *
               code=&dt_invalid_input_interval
    pack  pwa_d,0(5,r3)               |
    cvb   r15,pwa_d                   |
   elseif (tbit,pwa_day_flags,pwa_pdays)  PL4 packed-decimal days?
    Validate_Packed_Data Data=0(r3),Len=4,Type=INTERVAL
    zap   pwa_d,0(4,r3)               |    Trusting, aren't we?
    cvb   r15,pwa_d                   |
   elseif (tbit,pwa_day_flags,pwa_idays)  Halfword integer days?
    lh    r15,0(,r3)                  |
   endif                              |
* *-------------------------------------------------------------------*
  elseif (cli,pwa_hour_flags,ne,x'00')
   if    (tbit,pwa_hour_flags,pwa_hours)  5-digit character hours?
    errexit (%trt,0(5,r3),ne,psd_numeric_table),                       *
               code=&dt_invalid_input_interval
    pack  pwa_d,0(5,r3)               |
    cvb   r15,pwa_d                   |
   elseif (tbit,pwa_hour_flags,pwa_phours) PL4 packed-decimal hours?
    Validate_Packed_Data Data=0(r3),Len=4,Type=INTERVAL
    zap   pwa_d,0(4,r3)               |    Trusting, aren't we?
    cvb   r15,pwa_d                   |
   elseif (tbit,pwa_hour_flags,pwa_ihours) Halfword integer hours?
    lh    r15,0(,r3)                  |
   endif                              |
* *-------------------------------------------------------------------*
  elseif (cli,pwa_minute_flags,ne,x'00')
   if    (tbit,pwa_minute_flags,pwa_minutes) 5-digit character minutes?
    errexit (%trt,0(5,r3),ne,psd_numeric_table),                       *
               code=&dt_invalid_input_interval
    pack  pwa_d,0(5,r3)               |
    cvb   r15,pwa_d                   |
   elseif (tbit,pwa_minute_flags,pwa_pminutes) PL4 packed minutes?
    Validate_Packed_Data Data=0(r3),Len=4,Type=INTERVAL
    zap   pwa_d,0(4,r3)               |    Trusting, aren't we?
    cvb   r15,pwa_d                   |
   elseif (tbit,pwa_minute_flags,pwa_iminutes) Halfword int. minutes?
    lh    r15,0(,r3)                  |
   endif                              |
* *-------------------------------------------------------------------*
  elseif (cli,pwa_second_flags,ne,x'00')
   if    (tbit,pwa_second_flags,pwa_seconds) 5-digit character seconds?
    errexit (%trt,0(5,r3),ne,psd_numeric_table),                       *
               code=&dt_invalid_input_interval
    pack  pwa_d,0(5,r3)               |
    cvb   r15,pwa_d                   |
   elseif (tbit,pwa_second_flags,pwa_pseconds) PL4 packed seconds?
    Validate_Packed_Data Data=0(r3),Len=4,Type=INTERVAL
    zap   pwa_d,0(4,r3)               |    Trusting, aren't we?
    cvb   r15,pwa_d                   |
   elseif (tbit,pwa_second_flags,pwa_iseconds) Halfword int. seconds?
    lh    r15,0(,r3)                  |
   endif                              |
* *-------------------------------------------------------------------*
  elseif (cli,pwa_hundredth_flags,ne,x'00')
    errexit (%trt,0(5,r3),ne,psd_numeric_table),                       *
               code=&dt_invalid_input_interval
   if    (tbit,pwa_hundredth_flags,pwa_hundredths) 5-digit?
    pack  pwa_d,0(5,r3)               |
    cvb   r15,pwa_d                   |
   elseif (tbit,pwa_hundredth_flags,pwa_phundredths) PL4 packed?
    Validate_Packed_Data Data=0(r3),Len=4,Type=INTERVAL
    zap   pwa_d,0(4,r3)               |    Trusting, aren't we?
    cvb   r15,pwa_d                   |
   elseif (tbit,pwa_hundredth_flags,pwa_ihundredths) Halfword integer?
    lh    r15,0(,r3)                  |
   endif                              |
  endif                               |
* *-------------------------------------------------------------------*
* *  At this point, the integer equivalent of our input is in R15.
* *  We now need to come up with a value to turn R15's contents
* *  into microseconds.
* *-------------------------------------------------------------------*
  if    (cli,pwa_day_flags,ne,x'00')  | Days: multiply by 8640000
   lh    r1,=h'16875'                 |        which is 16875
   la    r2,9                         |         times 512 (2**9).
  elseif (cli,pwa_hour_flags,ne,x'00')  Hours: multiply by 360000
   lh    r1,=h'5625'                  |         which is 5625
   la    r2,6                         |           times 64 (2**6).
  elseif (cli,pwa_minute_flags,ne,x'00')  Minutes: Times 6000,
   la    r1,375                       |             which is 375
   la    r2,4                         |              times 16 (2**4).
  elseif (cli,pwa_second_flags,ne,x'00')  Seconds: Times 100,
   la    r1,25                        |             which is 25
   la    r2,2                         |              times 4 (2**2).
  else ,                              |   Hundredths: Times 1,
   la    r1,1                         |             which is 1
   xr    r2,r2                        |             times 1 (2**0).
  endif                               |
  m     r0,=f'10000'                  | Multiply multiplier by 10000.
*                                     | The largest possible answer
*                                     | here is 87,890,625, or 53D1AC1,
*                                     | so we don't need to worry about
*                                     | the contents of R0.
  mr    r14,r1                        | Multiply R14-R15 by multiplier,
  sldl  r14,0(r2)                     | then mult. by power of 2 in R2.
  l     r2,cpl_internal               | Get addr of internal interval
  lm    r0,r1,0(r2)                   | Get the value so far
  ar    r0,r14                        | Add-logical upper half
  alr   r1,r15                        | Add-logical lower half
  if    not,(cc12)                    | If overflow in low half
   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.
  endif                               |
  stm   r0,r1,0(r2)                   | Save result for caller
 endblk rc=0                          |
 title "Convert Internal Format To Integer Interval"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Internal_To_Integer_Interval
*  Abstract:   This routine converts an internal-format interval to
*              assorted integer intervals. This routine can produce
*              the following variations:
*              . &DT_DAYS       -- CL5 number of days
*              . &DT_PDAYS      -- PL4 number of days
*              . &DT_IDAYS      -- Halfword number of days
*              . &DT_HOURS      -- CL5 number of hours
*              . &DT_PHOURS     -- PL4 number of hours
*              . &DT_IHOURS     -- Halfword number of hours
*              . &DT_MINUTES    -- CL5 number of minutes
*              . &DT_PMINUTES   -- PL4 number of minutes
*              . &DT_IMINUTES   -- Halfword number of minutes
*              . &DT_SECONDS    -- CL5 number of seconds
*              . &DT_PSECONDS   -- PL4 number of seconds
*              . &DT_ISECONDS   -- Halfword number of seconds
*              . &DT_HUNDREDTHS -- CL5 number of hundredths
*              . &DT_PHUNDREDTHS -- PL4  number of hundredths
*              . &DT_IHUNDREDTHS -- halfword number of hundredths
*  Inputs:     On entry, R1 points to a converter parameter list.
*  Outputs:    Interval, converted to requested format and subtracted
*              from the internal value pointed to by the CPL.
*  Special
*  Notes:      In order to convert a number of hours, minutes, etc. to
*              a number of microseconds, this routine has to multiply
*              some potentially large values together, but System/370
*              does not support a doubleword integer multiply.  This
*              is done as follows:
*              .. R1 will contain a 'multiplier' that will partially
*                 convert the input interval to microseconds.
*              .. R2 contains the rest of the multiplier, in the form
*                 of a power-of-2 exponent to do a double shift with.
*---------------------------------------------------------------------*
         space 1                      |
 block name=Convert_Internal_To_Integer_Interval,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
  l     r15,cpl_internal              |
  lm    r14,r15,0(r15)                | Get the value
* *-------------------------------------------------------------------*
* *  First, determine values to divide and shift by.
* *-------------------------------------------------------------------*
  if    (cli,pwa_day_flags,ne,x'00')  | Days: multiply by 8640000
   lh    r1,=h'16875'                 |           which is 16875
   la    r2,9                         |           times 512 (2**9).
  elseif (cli,pwa_hour_flags,ne,x'00')  Hours: multiply by 360000
   lh    r1,=h'5625'                  |             which is 5625
   la    r2,6                         |             times 64 (2**6).
  elseif (cli,pwa_minute_flags,ne,x'00') Minutes: Times 6000,
   la    r1,375                       |          which is 375
   la    r2,4                         |          times 16 (2**4).
  elseif (cli,pwa_second_flags,ne,x'00') Seconds: Times 100,
   la    r1,25                        |            which is 25
   la    r2,2                         |            times 4 (2**2).
  else                                |   Hundredths: Times 1,
   la    r1,1                         |             which is 1
   xr    r2,r2                        |             times 1 (2**0).
  endif                               |
  m     r0,=f'10000'                  | Multiply divisor by 15625.
*                                     | The largest possible answer
*                                     | here is 87,890,625, or 53D1AC1,
*                                     | so we don't need to worry about
*                                     | the contents of R0.
  srdl  r14,0(r2)                     | Divide by power of 2 in R2,
  dr    r14,r1                        | then divide R14-R15 by divisor.
* *-------------------------------------------------------------------*
* * Now, convert quotient in R15 to format requested by caller.
* *-------------------------------------------------------------------*
  if           (tbit,pwa_day_flags,pwa_days),or,                       *
               (tbit,pwa_hour_flags,pwa_hours),or,                     *
               (tbit,pwa_minute_flags,pwa_minutes),or,                 *
               (tbit,pwa_second_flags,pwa_seconds),or,                 *
               (tbit,pwa_hundredth_flags,pwa_hundredths)
   errexit     (c,r15,gt,=f'99999'),  |                                *
               code=&dt_overflow      |
   cvd   r15,pwa_d                    |
   l     r1,cpl_interval              |
   unpk  0(5,r1),pwa_d+5(3)           |
   oi    4(r1),x'f0'                  |
  elseif       (tbit,pwa_day_flags,pwa_pdays),or,                      *
               (tbit,pwa_hour_flags,pwa_phours),or,                    *
               (tbit,pwa_minute_flags,pwa_pminutes),or,                *
               (tbit,pwa_second_flags,pwa_pseconds),or,                *
               (tbit,pwa_hundredth_flags,pwa_phundredths)
   errexit   (c,r15,gt,=f'9999999'),  |                                *
               code=&dt_overflow      |
   cvd   r15,pwa_d                    |
   l     r1,cpl_interval              |
   mvc   0(4,r1),pwa_d+4              |
  elseif       (tbit,pwa_day_flags,pwa_idays),or,                      *
               (tbit,pwa_hour_flags,pwa_ihours),or,                    *
               (tbit,pwa_minute_flags,pwa_iminutes),or,                *
               (tbit,pwa_second_flags,pwa_iseconds),or,                *
               (tbit,pwa_hundredth_flags,pwa_ihundredths)
   errexit    (c,r15,gt,=f'32767'),   |                                *
               code=&dt_overflow      |
   l     r1,cpl_interval              |
   sth   r15,0(,r1)                   |
  endif                               |
 endblk rc=0                          |
 title "Convert Delta-Format Interval To Internal Format"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Delta_Interval_To_Internal
*  Abstract:   This routine converts a DT_Delta format interval value
*              to the internal format.
*  Input:      On entry, R1 points to a converter parameter list. See
*              the "CPL" DSECT.
*  Outputs:    Interval converted to internal format
*  Special     The DT_Delta format is composed of sections. The general
*  Notes:      format is  "<ddddd>-hh<:mm<:ss<.th>>>", where the parts
*              enclosed in <>'s are optional. See Validate_Delta_Format
*              for further details.
*
*---------------------------------------------------------------------*
         SPACE 1
 block name=Convert_Delta_Interval_To_Internal,type=subroutine
  lr    r4,r1
  using cpl,r4
  callsub Validate_Delta_Format
  errexit (treg,r15,nz),code=&dt_invalid_input_interval
* *-------------------------------------------------------------------*
* *  Validate_Delta_Format has filled in the following PWA variables:
* *    PWA_Number_Of_Days  PWA_Number_Of_Hours  PWA_Number_Of_Minutes
* *         PWA_Number_Of_Seconds   PWA_Number_Of_Hundredths
* *-------------------------------------------------------------------*
  l     r1,pwa_number_of_days         | Get number of days
  mh    r1,=h'24'                     | Turn into hours
  lr    r2,r1                         | Save in R2
  l     r1,pwa_number_of_hours        | Get number of hours
  alr   r1,r2                         | Add days-as-hours
  mh    r1,=h'60'                     | Turn into minutes
  lr    r2,r1                         | Save in R2
  l     r1,pwa_number_of_minutes      | Get number of minutes
  alr   r1,r2                         | Add days+hours_as_minutes
* *-------------------------------------------------------------------*
* *  R1 now contains the delta value in minutes.  Convert this value
* *  to microseconds now, then convert seconds and hundredths to
* *  microseconds separately and add them together.  This avoids some
* *  overflow problems with large (over 25000 days) delta values.
* *-------------------------------------------------------------------*
  m     r0,=f'60000000'               | Turn into microseconds in R0-R1
*                                     |
  l     r15,pwa_number_of_seconds     | Get number of seconds
  mh    r15,=h'100'                   |
  al    r15,pwa_number_of_hundredths  |
  m     r14,=f'10000'                 | Turn seconds, hundredths into
*                                     |    microseconds in R14-R15.
  alr   r1,r15                        | Add lo-order halves together
  if    not,(cc12)                    | If there was an overflow
   ah    r0,=h'1'                     |  Add 1 to upper half.
  endif                               |
  alr   r0,r14                        | Add hi-order halves together.
*                                     |
  l     r2,cpl_internal               | Get addr of internal interval
  lm    r14,r15,0(r2)                 | Get the value so far
  ar    r0,r14                        | Add-logical upper half
  alr   r1,r15                        | Add-logical lower half
  if    not,(cc12)                    | If overflow in low half
   ah    r0,=h'1'                     |  carry a 1 to high 4 bytes.
  endif                               |
  stm   r0,r1,0(r2)                   | Save result for caller
 endblk rc=0                          |
 title "Convert Internal Format To Delta-Format Interval"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Internal_To_Delta_Interval
*  Abstract:   This routine converts an internal format value to
*              DT_Delta format.
*  Input:      On entry, R1 points to a converter parameter list. See
*              the "CPL" DSECT.
*  Outputs:    Internal-format value converted and returned to caller.
*  Special     The DT_Delta format is composed of sections. The general
*  Notes:      format is  "<ddddd>-hh<:mm<:ss<.th>>>", where the parts
*              enclosed in <>'s are optional. See Validate_Delta_Format
*              for further details.
*
*---------------------------------------------------------------------*
dt_delta_days       equ   0           | Handy local values.
dt_delta_dash       equ   5           |
dt_delta_hours      equ   6           |
dt_delta_colon1     equ   8           |
dt_delta_minutes    equ   9           |
dt_delta_colon2     equ  11           |
dt_delta_seconds    equ  12           |
dt_delta_period     equ  14           |
dt_delta_hundredths equ  15           |
* *-------------------------------------------------------------------*
         SPACE 1
 block name=Convert_Internal_To_Delta_Interval,type=subroutine
  lr    r4,r1                         |
  using cpl,r4                        |
* *-------------------------------------------------------------------*
* *  Whack the interval up into days, hours, minutes, etc.  This is
* *  done by a BIG whack up front, then two sets of little whacks,
* *  to avoid division overflows due to large doubleword integers.
* *-------------------------------------------------------------------*
  l     r15,cpl_internal              | Point to internal-format value
  lm    r14,r15,0(r15)                | Get the value
  d     r14,=f'60000000'              | WHACK! Convert to minutes
  lr    r3,r14                        | Save remainder for later
* *-------------------------------------------------------------------*
  xr    r14,r14                       | Clear R14
  d     r14,=f'1440'                  | Divide r14-r15 by minutes/day
  st    r15,pwa_number_of_days        |  in a day; save quotient
  lr    r15,r14                       | Remainder is new divisor
  xr    r14,r14                       | Clear R14
  d     r14,=f'60'                    | Divide R14-R15 by minutes/hour
  st    r15,pwa_number_of_hours       |  in a day; save quotient
  st    r14,pwa_number_of_minutes     | Remainder is minutes.
* *-------------------------------------------------------------------*
  lr    r15,r3                        | Copy seconds-as-microseconds
  xr    r14,r14                       | Clear R14
  d     r14,=f'10000'                 | Make .01-sec units, toss rmdr.
  xr    r14,r14                       | Clear R14
  d     r14,=f'100'                   | Split into seconds
  st    r15,pwa_number_of_seconds     |  and hundredths.
  st    r14,pwa_number_of_hundredths  |
          eject ,                     |
* *-------------------------------------------------------------------*
* *  Now, convert days, hours, etc. to character digits and build
* *  delta-format interval in caller's storage.  (w/leading zeros)
* *-------------------------------------------------------------------*
  l     r3,cpl_interval               | Point to caller's storage
  l     r1,pwa_number_of_days         | Get days
  errexit      (c,r1,gt,=f'99999'),   |                                *
               code=&dt_overflow      |
  cvd   r1,pwa_d                      | Convert to packed
  unpk  dt_delta_days(5,r3),pwa_d+5(3)  Unpk directly to caller's stg
  oi    4(r3),x'f0'                   | Clean up last digit
  mvi   dt_delta_dash(r3),c'-'        |
*                                     |
  l     r1,pwa_number_of_hours        | Get hours
  cvd   r1,pwa_d                      | Convert to packed
  unpk  pwa_edit(5),pwa_d+5(3)        | Unpack to intermediate area
  oi    pwa_edit+4,x'f0'              | Clean up behind UNPK
  mvc   dt_delta_hours(2,r3),pwa_edit+3
  mvi   dt_delta_colon1(r3),c':'      |             | Append a ':'
*                                     |
  l     r1,pwa_number_of_minutes      |
  cvd   r1,pwa_d                      |
  unpk  pwa_edit(5),pwa_d+5(3)        |
  oi    pwa_edit+4,x'f0'              |
  mvc   dt_delta_minutes(2,r3),pwa_edit+3
  mvi   dt_delta_colon2(r3),c':'      |
*                                     |
  l     r1,pwa_number_of_seconds      |
  cvd   r1,pwa_d                      |
  unpk  pwa_edit(5),pwa_d+5(3)        |
  oi    pwa_edit+4,x'f0'              |
  mvc   dt_delta_seconds(2,r3),pwa_edit+3
  mvi   dt_delta_period(r3),c'.'      |
*                                     |
  l     r1,pwa_number_of_hundredths   |
  cvd   r1,pwa_d                      |
  unpk  pwa_edit(5),pwa_d+5(3)        |
  oi    pwa_edit+4,x'f0'              |
  mvc   dt_delta_hundredths(2,r3),pwa_edit+3
* *-------------------------------------------------------------------*
 endblk rc=0                          |
 title "Convert Integer Julian Date To Gregorian Date"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Ijuldate_To_Gregorian
*  Abstract:   Convert a Julian date into a Gregorian date.  This is
*              generally done in preparation to call Convert_Gregorian_
*              To_Days.
*  Input:      On entry, R1 points to the following parameter list:
*                + 00 -- Fullword month value to be returned
*                + 04 -- Fullword day value to be returned
*                + 08 -- Fullword year value to be returned
*                + 12 -- Fullword Ijulian date to convert
*  Output:     Parameters at +0, +4, +8 filled in.
*
*  Notes:      . This subroutine uses Algorithm 398, "Tableless Date
*                Conversion", from "Collected Algorithms From
*                Communications Of The ACM".  This procedure uses the
*                "full" algorithm (not the short one that assumes that
*                "1900 < year < 2100"), modified slightly to abbreviate
*                the leapyear check.  The routine (coded as a rexx
*                procedure) works as follows:
*
*                   convert: procedure
*                     parse upper arg j
*                     jy = j % 1000
*                     jd = j // 1000
*                     t = 0
*                     if (jy // 4) = 0 then t = 1
*                     if (jy // 100) = 0 then t = 0
*                     if (jy // 400) = 0 then t = 1
*                     d = jd
*                     if jd > 59 + t then d = jd + 2 - t
*                     m = ((d + 91) * 100) % 3055
*                     d = (d + 91) - (m * 3055) % 100
*                     m = m - 2
*                     return (m,d,y)
*
* See "Convert_Gregorian_To_Ijuldate" for the converse of this routine.
*
* This routine uses R2-R5 in addition to the usual work registers.
* These are the only registers saved and restored.
*
*---------------------------------------------------------------------*
 block name=Convert_Ijuldate_To_Gregorian,type=subroutine
  lr    r7,r1                         | Copy parameter list pointer
  lm    r2,r5,0(r7)                   | Load parameter addresses
  l     r1,0(,r5)                     | Get Ijulian date
* *-------------------------------------------------------------------*
* *                   jy = j % 1000
* *                   jd = j // 1000
* *-------------------------------------------------------------------*
  xr    r0,r0                         | Set up for division
  d     r0,=f'1000'                   | Divide into years, days
  st    r1,0(,r4)                     | Return year value now.
  st    r0,pwa_converter_j            | Save days in local storage
  lr    r14,r1                        | Save years
* *-------------------------------------------------------------------*
* *                   t = 0
* *                   if (jy // 4) = 0 then t = 1
* *                   if (jy // 100) = 0 then t = 0
* *                   if (jy // 400) = 0 then t = 1
* *-------------------------------------------------------------------*
  xr    r6,r6                         | Use r6 for "t": set to zero
  xr    r0,r0                         | R1 contains years
  d     r0,=f'4'                      | Divide years by 4
  if    (treg,r0,z)                   | If no remainder,
   la    r6,1                         |  t = 1 for leapyear.
  endif                               |
  lr    r1,r14                        | Get years back
  xr    r0,r0                         |
  d     r0,=f'100'                    | Divide years by 100:
  if    (treg,r0,z)                   | If no remainder
   xr    r6,r6                        |  t = 0 for no leapyear.
  endif                               |
  lr    r1,r14                        | Get years back
  xr    r0,r0                         |
  d     r0,=f'400'                    | Divide years by 400:
  if    (treg,r0,z)                   | If no remainder,
   la    r6,1                         |  t = 1 for leapyear.
  endif                               |
* *-------------------------------------------------------------------*
* *                   d = jd
* *                   if jd > 59 + t then d = jd + 2 - t
* *-------------------------------------------------------------------*
  l     r1,pwa_converter_j            | Get Julian day value
  la    r0,59                         | Get a 59
  ar    r0,r6                         | Add whatever t is to it
  if    (cr,r1,gt,r0)                 | If jd is more than that
   la    r1,2(,r1)                    |  Add 2, then
   sr    r1,r6                        |   subtract t.
  endif                               |
  st    r1,pwa_converter_d            | Save as d.
* *-------------------------------------------------------------------*
* *                   m = ((d + 91) * 100) % 3055
* *-------------------------------------------------------------------*
  la    r1,91(,r1)                    | R1 = d: add 91 to it
  mh    r1,=h'100'                    | Get (d + 91) * 100
  xr    r0,r0                         | Set up for division
  d     r0,=f'3055'                   | Divide by 3055, toss remainder
  st    r1,pwa_converter_m            | Save as m.
* *-------------------------------------------------------------------*
* *                   d = (d + 91) - (m * 3055) % 100
* *                   m = m - 2
* *-------------------------------------------------------------------*
  lr    r15,r1                        | Get a copy of m in r15
  l     r1,pwa_converter_d            | Get d
  la    r1,91(,r1)                    | R1 = (d + 91)
  mh    r15,=h'3055'                  | R15 = (m * 3055)
  xr    r14,r14                       | Set up for division
  d     r14,=f'100'                   | R15 = (m * 3055) % 100
  sr    r1,r15                        | R1 = d (the whole thing).
  st    r1,0(,r3)                     | Return d to caller
  l     r1,pwa_converter_m            | Get m
  sh    r1,=h'2'                      | m = m - 2
  st    r1,0(,r2)                     | Return m to caller
 endblk rc=0                          |
 title "Convert Gregorian Date To Integer Julian Date"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Gregorian_To_Ijuldate
*  Abstract:   Convert a Gregorian date into a Julian date.  This is
*              generally done when preparing a Julian-format date for
*              output.
*  Input:      On entry, R1 points to the following parameter list:
*                + 00 -- Fullword month value to convert
*                + 04 -- Fullword day value to be convert
*                + 08 -- Fullword year value to be convert
*                + 12 -- Fullword Ijulian date to be returned
*  Output:     Parameter at +12 filled in.
*
*  Notes:      . This subroutine uses Algorithm 398, "Tableless Date
*                Conversion", from "Collected Algorithms From
*                Communications Of The ACM".  This procedure is
*                actually the "companion" procedure that converts a
*                day-of-year given a month, day and year.  The
*                algorithm (coded as a rexx procedure) works as
*                follows:
*
*                  convert: procedure
*                   parse upper arg m, d, y
*                   t = 0
*                   if (y // 4) = 0 then t = 1
*                   if (y // 400) = 0 then t = 0
*                   day = ((3055 * (m + 2)) % 100)        ,  <1>
*                            - (((m + 10) % 13) * 2 + 91)  , <2>
*                            + (t * (m + 10) % 13) + d       <3>
*                   j = y * 1000 + day
*                   return (j)
*
*                (The three lines in the large formula are computed
*                separately, then combined at the end.)
*
*                Note that the original algorithm gave the "day"
*                formula as:
*                  iday(y,m,d) = 3055*(m+2)/100-(m+10)/13*2-91
*                         + (1-(y-y/4*4+3)/4 + (y-y/100*100+99/100)
*                         - (y-y/400*400+399/400) * (m+10)/13+d
*                The three routines in the middle (.../4, .../100 and
*                .../400) determine whether it's a leapyear or not,
*                and introduce a 1 if it's a leapyear and the date
*                needs adjustment. (I think this is because the author
*                wanted to be clever and write a one-line routine.)
*                This is replaced by "t", which is derived beforehand.
*                Also, the constant '91' is added to intermediate value
*                <2>, which is then subtracted off to produce the final
*                result.
*
* See "Convert_Ijuldate_To_Gregorian" for the converse of this routine.
*
* This routine uses R2-R7 in addition to the usual work registers.
* These are the only registers saved and restored.
*
*---------------------------------------------------------------------*
 block name=Convert_Gregorian_To_Ijuldate,type=subroutine
  lr    r7,r1                         | Copy parmlist pointer
  lm    r2,r5,0(r7)                   | Get parameter addresses
* *-------------------------------------------------------------------*
* *                 t = 0
* *                 if (y // 4) = 0 then t = 1
* *                 if (y // 100) = 0 then t = 0
* *                 if (y // 400) = 0 then t = 1
* *-------------------------------------------------------------------*
  xr    r6,r6                         | Use R6 as "t"
  l     r1,0(,r4)                     | Get input year value
  xr    r0,r0                         | Set up for division
  d     r0,=f'4'                      | If (y // 4) = 0
  if    (treg,r0,z)                   |
   la    r6,1                         |   then t = 1.
  endif                               |
  l     r1,0(,r4)                     | Get year value back
  xr    r0,r0                         | Set up for division
  d     r0,=f'100'                    | If (y // 100) = 0
  if    (treg,r0,z)                   |
   xr    r6,r6                        |   then t = 0.
  endif                               |
  l     r1,0(,r4)                     | Get year value back
  xr    r0,r0                         | Set up for division
  d     r0,=f'400'                    | If (y // 400) = 0
  if    (treg,r0,z)                   |
   la    r6,1                         |   then t = 1.
  endif                               |
* *-------------------------------------------------------------------*
* *                 day = ((3055 * (m + 2)) % 100)        ,  <1>
* *                          - (((m + 10) % 13) * 2 + 91) ,  <2>
* *                          + (t * (m + 10) % 13) + d       <3>
* *-------------------------------------------------------------------*
  l     r1,0(,r2)                     | Step <1>:
  la    r1,2(,r1)                     | Get month value, add 2
  mh    r1,=h'3055'                   | Multiply by 3055
  xr    r0,r0                         |
  d     r0,=f'100'                    | Divide by 100; ignore remainder
  st    r1,pwa_converter_work         | Save intermediate result.
* *-------------------------------------------------------------------*
  l     r1,0(,r2)                     | Step <2>:
  la    r1,10(,r1)                    | Get month value ,add 10
  xr    r0,r0                         | Set up for division
  d     r0,=f'13'                     | Divide by 13, toss remainder
  lr    r15,r1                        | Save ((m + 10) % 13) in r15
  sll   r1,1                          | Multiply by 2
  ah    r1,=h'91'                     | << Is this in the right place?
  st    r1,pwa_converter_work2        | Save intermediate result.
* *-------------------------------------------------------------------*
  lr    r1,r15                        | Step <3>:
  mr    r0,r6                         | Get ((m + 10) % 13) * t
  a     r1,0(,r3)                     | Add "d": R1 is 3rd intermediate
* *-------------------------------------------------------------------*
  a     r1,pwa_converter_work         | Add 1st intermediate value
  s     r1,pwa_converter_work2        | Subtract 2nd intermediate value
  l     r15,0(,r4)                    | Get year from caller
  mh    r15,=h'1000'                  | Decimal shift
  ar    r15,r1                        | Add days we derived
  st    r15,0(,r5)                    | Return ijulian date to caller.
* *-------------------------------------------------------------------*
 endblk rc=0                          |
 space 1                              |
 title "Convert Gregorian Date To Number Of Days Since 1/1/0000"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Gregorian_To_Days
*  Abstract:   Convert a Gregorian date to the number of days since
*              January 1, 0000.
*  Input:      On entry, R1 points to the following parameter list:
*                +00 -- Address of "m": fullword month value
*                +04 -- Address of "d": fullword day within month
*                +08 -- Address of "y": fullword year value
*                +12 -- Address of "j": fullword to return # days in.
*  Output:     Parameter "j" at parmlist+12 filled in.
*
*  Notes:      . This subroutine uses Algorithm 199, "Conversions
*                Between Calendar Date And Julian Day Number", from
*                "Collected Algorithms From Communications Of The ACM".
*                Procedure "JDAY" is used here to convert a Gregorian
*                date (months, days, and year) into the number of days
*                since Jan. 1, 0000.  Note that the constant '1721119',
*                which would convert a Gregorian date to a true Julian
*                number of days, is not used here.
*
*                Procedure JDAY works as follows:
*                  If M > 2 then M = M - 3;
*                  Else Do;
*                    M = M + 9;
*                    Y = Y - 1;
*                  End;
*                  C = Y / 100;  YA = Y - (100 * C);
*                  J = (146097 * C)/4 + (1461 * YA)/4 +
*                      ((153 * M) + 2)/5 + D;
*                  Return (J);
*
* See "Convert_Days_To_Gregorian" for the converse of this routine.
*
* This routine uses R2-R5 in addition to the usual work registers.
* These are the only registers saved and restored.
*
*---------------------------------------------------------------------*
 block name=Convert_Gregorian_To_Days,type=subroutine,                 *
               options=(*nosubopts),                                   *
               save=(r2,r5,pwa_iconvert_regs)
  lr    r5,r1                         | Save parmlist pointer
  lm    r2,r4,0(r5)                   | Get addresses of m, d, and y
  mvc   pwa_converter_m,0(r2)         | Copy month value to workarea
  mvc   pwa_converter_d,0(r3)         | Copy day value to workarea
  mvc   pwa_converter_y,0(r4)         | Copy year value to workarea
*---------------------------------------------------------------------*
*                  If M > 2 then M = M - 3;
*                  Else Do;
*                    M = M + 9;
*                    Y = Y - 1;
*                  End;
*---------------------------------------------------------------------*
  l     r1,pwa_converter_m            | Get M
  if    (ch,r1,gt,=h'2')              | If M > 2
   sh    r1,=h'3'                     |  M = M - 3
  else                                | Else Do
   la    r1,9(,r1)                    |  M = M + 9
   l     r15,pwa_converter_y          |  Get Y
   bctr  r15,0                        |  Y = Y - 1
   st    r15,pwa_converter_y          |  Put Y back
  endif                               | End
  st    r1,pwa_converter_m            | Put M back regardless
*---------------------------------------------------------------------*
*                  C = Y / 100;  YA = Y - (100 * C);
*---------------------------------------------------------------------*
  xr    r0,r0                         | Clear even reg for division
  l     r1,pwa_converter_y            | Get Y
  d     r0,=f'100'                    | C = Y / 100
  st    r1,pwa_converter_c            | Put quotient in C.
  mh    r1,=h'100'                    | YA = Y - (100 * C)
  l     r15,pwa_converter_y           | Get Y
  sr    r15,r1                        | Subtract (100 * C)
  st    r15,pwa_converter_ya          | Save as YA.
*---------------------------------------------------------------------*
*                  J = (146097 * C)/4 + (1461 * YA)/4 +
*                      ((153 * M) + 2)/5 + D;
*---------------------------------------------------------------------*
*   (1). Compute (146097 * C) / 4
*---------------------------------------------------------------------*
  l     r1,pwa_converter_c            | Get C
  m     r0,=f'146097'                 | Multiply by 146097
  srl   r1,2                          | Cheap divide by 4
  st    r1,pwa_converter_work         | Save intermediate result.
*---------------------------------------------------------------------*
*   (2). Compute (1461 * YA) / 4
*---------------------------------------------------------------------*
  l     r1,pwa_converter_ya           | Get YA
  mh    r1,=h'1461'                   | Multiply
  srl   r1,2                          | Cheap divide by 4
  a     r1,pwa_converter_work         | Add to intermediate result.
  st    r1,pwa_converter_work         |
*---------------------------------------------------------------------*
*   (3). Compute ((153 * M) + 2) / 5  + D
*---------------------------------------------------------------------*
  l     r1,pwa_converter_m            | Get M
  mh    r1,=h'153'                    | Multiply
  la    r1,2(,r1)                     | Add 2
  xr    r0,r0                         | Clear even reg for division
  d     r0,=f'5'                      | Divide by 5
  a     r1,pwa_converter_d            | Add D
*---------------------------------------------------------------------*
*   Return (j)
*---------------------------------------------------------------------*
  a     r1,pwa_converter_work         | Add accumulator
  l     r15,12(,r5)                   | Get pointer to j from parms
  st    r1,0(,r15)                    | Return j to caller
 endblk rc=0                          |
 space 1                              |
 title "Convert Number Of Days Since 1/1/0000 To Gregorian Date"
*---------------------------------------------------------------------*
*
*  Subroutine: Convert_Days_To_Gregorian
*  Abstract:   Convert a the number of days since January 1, 0000 to a
*              Gregorian date.
*  Input:      On entry, R1 points to the following parameter list:
*                +00 -- Address of "m": fullword month value to return
*                +04 -- Address of "d": fullword day of month to return
*                +08 -- Address of "y": fullword year value to return
*                +12 -- Address of "j": fullword number of days.
*  Output:     Parameters "m", "d", "y" filled in.
*
*  Notes:      . This subroutine uses Algorithm 199, "Conversions
*                Between Calendar Date And Julian Day Number", from
*                "Collected Algorithms From Communications Of The ACM".
*                Procedure "JDATE" is used here to convert the number
*                of days since Jan. 1, 0000 to a Gregorian date.  Note
*                Note that the constant '1721119', which would convert
*                the true Julian number of days into a Gregorian date,
*                is not used here.
*
*                Procedure JDATE works as follows:
*                  y = ((4 * j) - 1) / 146097;
*                  j = (4 * j) - 1 - (146097 * y);
*                  d = j / 4;
*                  j = ((4 * d) + 3) / 1461;
*                  d = (4 * d) + 3 - (1461 * j);
*                  d = (d + 4) / 4;
*                  m = ((5 * d) - 3) / 153;
*                  d = (5 * d) - 3 - (153 * m);
*                  d = (d + 5) / 5;
*                  y = (100 * y) + j;
*                  if m < 10 then m = m + 3;
*                  else do;
*                    m = m - 9;
*                    y = y + 1
*                  end;
*                  return (m, d, y);
*
* See "Convert_Gregorian_To_Days" for the converse of this routine.
*
* This routine uses R2-R5 in addition to the usual work registers.
* These are the only registers saved and restored.
*
*---------------------------------------------------------------------*
 block name=Convert_Days_To_Gregorian,type=subroutine,                 *
               options=(*nosubopts),                                   *
               save=(r2,r5,pwa_iconvert_regs)
  lr    r5,r1                         | Save parmlist pointer
  l     r1,12(,r5)                    | Get address of J
  mvc   pwa_converter_j,0(r1)         | Copy J to local variable
*---------------------------------------------------------------------*
*                  y = ((4 * j) - 1) / 146097;
*                  j = (4 * j) - 1 - (146097 * y);
*                  d = j / 4;
*  Note: If an input date of zero is passed, the value returned is
*        forced to Jan. 1, 0000.  If a date of zero is allowed to go
*        through the formula, unusual things occur.
*---------------------------------------------------------------------*
*                                     | y = ((4 * j) - 1) / 146097:
  l32   r1,pwa_converter_j            | Get j
  if    (z)                           |-------------------------------*
   lm    r2,r4,0(r5)                  | If input date is zero, force
   la    r1,1                         |  results to 1/1/0000 and exit.
   xr    r0,r0                        |
   st    r1,0(,r2)                    |   Set month to 1
   st    r1,0(,r3)                    |   Set day to 1
   st    r0,0(,r4)                    |   Set year to zero
   leave block=*                      |     and exit.
  endif                               |-------------------------------*
  sll   r1,2                          | Cheap multiply by 4
  bctr  r1,0                          | Subtract 1
  lr    r2,r1                         | Save intermediate result
  xr    r0,r0                         | Clear R0 for division
  d     r0,=f'146097'                 | Divide by 146097
  st    r1,pwa_converter_y            | Save quotient in Y.
*                                     | j = (4 * j) - 1 - (146097 * y):
  m     r0,=f'146097'                 | As long as we got Y in R1 ...
  sr    r2,r1                         | And (4 * j) - 1 in R2 ...
  st    r2,pwa_converter_j            | Save new value of j.
*                                     | d = j / 4
  srl   r2,2                          | As long as we got j in R2,
  st    r2,pwa_converter_d            | divide by 4 and stuff it.
*---------------------------------------------------------------------*
*                  j = ((4 * d) + 3) / 1461;
*                  d = (4 * d) + 3 - (1461 * j);
*                  d = (d + 4) / 4;
*---------------------------------------------------------------------*
*                                     | j = ((4 * d) + 3) / 1461
  lr    r1,r2                         | As long as we got d in R2
  sll   r1,2                          | (d * 4)
  la    r1,3(,r1)                     | Add 3
  lr    r2,r1                         | Save intermediate value
  xr    r0,r0                         | Clear R0 for division
  la    r15,1461                      | Shame there's no DH instruction
  dr    r0,r15                        | Divide by 1461
  st    r1,pwa_converter_j            | Stuff quotient in J.
*                                     | d = (4 * d) + 3 - (1461 * j)
  mh    r1,=h'1461'                   | R1 = (1461 * j)
  sr    r2,r1                         | R2 = (d * 4) + 3; now R2 = d
*                                     | d = (d + 4) / 4
  la    r2,4(,r2)                     | Add 4 to "d"
  srl   r2,2                          | Cheap divide by 4
  st    r2,pwa_converter_d            | Save value of d.
*---------------------------------------------------------------------*
*                  m = ((5 * d) - 3) / 153;
*                  d = (5 * d) - 3 - (153 * m);
*                  d = (d + 5) / 5;
*---------------------------------------------------------------------*
*                                     | m = ((5 * d) - 3) / 153;
  lr    r1,r2                         | As long as we got d in R2 ...
  mh    r1,=h'5'                      | (d * 5)
  sh    r1,=h'3'                      | Subtract 3
  lr    r2,r1                         | Save intermediate value
  xr    r0,r0                         | Clear R0 for division
  la    r15,153                       | Shame there's no DH instruction
  dr    r0,r15                        | Divide by 153
  st    r1,pwa_converter_m            | Stuff quotient in J.
*                                     | d = (5 * d) - 3 - (153 * m);
  mh    r1,=h'153'                    | R1 = (153 * m)
  sr    r2,r1                         | R2 = (5 * d) - 3; now R2 = d
*                                     | d = (d + 5) / 5;
  la    r1,5(,r2)                     | Add 5 to "d"
  xr    r0,0                          | Clear R0 for division
  d     r0,=f'5'                      | Divide by 5
  st    r1,pwa_converter_d            | Save value of d.
*---------------------------------------------------------------------*
*                  y = (100 * y) + j;
*---------------------------------------------------------------------*
  l     r1,pwa_converter_y            | Get value of y
  mh    r1,=h'100'                    | (100 * y)
  a     r1,pwa_converter_j            | Add j
  st    r1,pwa_converter_y            | Save value of y.
*---------------------------------------------------------------------*
*                  if m < 10 then m = m + 3;
*                  else do;
*                    m = m - 9;
*                    y = y + 1
*                  end;
*---------------------------------------------------------------------*
  l     r1,pwa_converter_m            | Get value of m
  if    (ch,r1,lt,=h'10')             | If m < 10
   la    r1,3(,r1)                    |   Add 3 to it
  else                                | Else do:
   sh    r1,=h'9'                     |   Subtract 9
   l     r15,pwa_converter_y          |   Add 1 to y.
   la    r15,1(,r15)                  |
   st    r15,pwa_converter_y          |
  endif                               |
  st    r1,pwa_converter_m            | Save m regardless.
*---------------------------------------------------------------------*
*                  return (m, d, y);
*---------------------------------------------------------------------*
  lm    r2,r4,0(r5)                   | Get pointers to m, d, y parms
  mvc   0(4,r2),pwa_converter_m       | Return m to caller
  mvc   0(4,r3),pwa_converter_d       | Return d to caller
  mvc   0(4,r4),pwa_converter_y       | Return y to caller
 endblk ,                             | That's it.
 title "General Error Exit: Save Info In Debug Area"
*---------------------------------------------------------------------*
*
*  Errexit:    Unnamed
*  Purpose:    Save debugging information and exit with the return
*              code pointed to by r14 at entry to this exit.
*  Notes:      For some cases, various registers may point to info we
*              want to display.  For example, when the MSGMOD errors
*              are detected, R4 points to the module name in error.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block type=errexit                   |
* es_display_debug_info_and_abend id=es << TESTING >>
* *-------------------------------------------------------------------*
* * Save module/offset, registers, return-code.
* *-------------------------------------------------------------------*
  st    r15,pwa_reason                | Save possible return-code.
  stm   r0,r15,gdiregs                | Save registers at time of error
  la    r0,4(,r12)                    | Point to module identification.
  st    r0,gdimodid                   | Save in general debug area.
  mvc   gdirc,0(r14)                  | Copy return code.
  slr   r14,r12                       | Calculate offset at time of err
  sth   r14,gdioffst                  | Save in debug area.
  l     r2,pwaaesv                    | Point r2 to ESV.
  using esv,r2                        | Establish base for ESV.
  callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_gdi,gdi)
* *-------------------------------------------------------------------*
* * Look at the error code.  If add'l information would be useful,
* * stuff into the debug area.
* *-------------------------------------------------------------------*
  lh    r15,gdirc                     | Get return code.
  caseblk reg=r15,mult=1              | Case on return-code.
    case &dt_invalid_function         |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               psd_invalid_function,=a(l'psd_invalid_function))
    case &dt_invalid_number_of_parms  |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               psd_invalid_#_parms,=a(l'psd_invalid_#_parms))
    case &dt_invalid_dt_id            |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               psd_invalid_dt_id,=a(l'psd_invalid_dt_id))
    case &dt_environment_support_error
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               psd_env_support_error,=a(l'psd_env_support_error))
    case &dt_string_handler_error     |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               psd_string_handler_error,=a(l'psd_string_handler_error))
    case &dt_invalid_date_format      |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               psd_invalid_date_format,=a(l'psd_invalid_date_format))
    case &dt_invalid_time_format      |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               psd_invalid_time_format,=a(l'psd_invalid_time_format))
    case &dt_invalid_interval_format  |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               psd_invalid_interval_format,                            *
               =a(l'psd_invalid_interval_format))
    case &dt_invalid_input_time       |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               psd_invalid_input_time,=a(l'psd_invalid_input_time))
    case &dt_invalid_input_date       |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               psd_invalid_input_date,=a(l'psd_invalid_input_date))
    case &dt_invalid_input_interval   |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               psd_invalid_input_interval,                             *
               =a(l'psd_invalid_input_interval))
    case &dt_overflow                 |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               psd_overflow,          |                                *
               =a(l'psd_overflow))    |
    case &dt_out_of_range             |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               psd_out_of_range,      |                                *
               =a(l'psd_out_of_range))
    case other                        |  Don't bother w/other errors.
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               psd_undetermined_error,=a(l'psd_undetermined_error))
  endcase                             | EndCase.
  drop r2                             |
* *-------------------------------------------------------------------*
* * Set the return-code and exit.
* *-------------------------------------------------------------------*
  lh    r15,gdirc                     | Set return code.
 endblk rc=(r15)                      |
 eject                                |
 title "Program Static Data"          |
                psd                   |
eyecatcher      dc   cl8"DT_SP"       | Eyecatcher value for dumps.
*                                     |
psd_mics_lower_limit dc xl8'00d4ff0e7fb74000' Jan. 1, 1900 @00:00:00.00
psd_mics_circa_1970  dc xl8'00dcd81ec873e000' Jan  1, 1970 @00:00:00.00
psd_mics_upper_limit dc xl8'00e4ff0e7fb73e10' Sep 17, 2042 @23:53:47.37
*                                     |
psd_month_table ds   0cl11            |
         dc   al2(01),cl9"January  "  |
         dc   al2(02),cl9"February "  |
         dc   al2(03),cl9"March    "  |
         dc   al2(04),cl9"April    "  |
         dc   al2(05),cl9"May      "  |
         dc   al2(06),cl9"June     "  |
         dc   al2(07),cl9"July     "  |
         dc   al2(08),cl9"August   "  |
         dc   al2(09),cl9"September"  |
         dc   al2(10),cl9"October  "  |
         dc   al2(11),cl9"November "  |
         dc   al2(12),cl9"December "  |
*                                     |
psd_weekday_table  ds    0cl10        | Jan. 1 0000 was a Tuesday
         dc   al1(0),cl9"Tuesday  "   |
         dc   al1(1),cl9"Wednesday"   |
         dc   al1(2),cl9"Thursday "   |
         dc   al1(3),cl9"Friday   "   |
         dc   al1(4),cl9"Saturday "   |
         dc   al1(5),cl9"Sunday   "   |
         dc   al1(6),cl9"Monday   "   |
*                                     |
psd_numeric_table  dc   256x'ff'      | Numeric translate-n-test table
          org  psd_numeric_table+c'0' | Set table to find anything
          dc   10x'00'                |  but c'0'-c'9'.
          org  ,                      |
*---------------------------------------------------------------------*
*
*  The packed-decimal translate-and-test table works as follows:
*    .. Valid non-sign bytes have a value of x'00' in the table.
*    .. Valid sign bytes have a value of x'08' in the table. These
*       should only occur as the last byte in the field being tested.
*    .. All other bytes have a value of x'04' in the table. If one of
*       these is found, the packed-decimal number is not legal.
*  The table is used by macro "Validate_Packed_Data".
*
*---------------------------------------------------------------------*
*                          0 1 2 3 4 5 6 7 8 9 a b c d e f
psd_packed_table dc  xl16'00000000000000000000080808080808' 0
                 dc  xl16'00000000000000000000080808080808' 1
                 dc  xl16'00000000000000000000080808080808' 2
                 dc  xl16'00000000000000000000080808080808' 3
                 dc  xl16'00000000000000000000080808080808' 4
                 dc  xl16'00000000000000000000080808080808' 5
                 dc  xl16'00000000000000000000080808080808' 6
                 dc  xl16'00000000000000000000080808080808' 7
                 dc  xl16'00000000000000000000080808080808' 8
                 dc  xl16'00000000000000000000080808080808' 9
                 dc  xl16'04040404040404040404040404040404' a
                 dc  xl16'04040404040404040404040404040404' b
                 dc  xl16'04040404040404040404040404040404' c
                 dc  xl16'04040404040404040404040404040404' d
                 dc  xl16'04040404040404040404040404040404' e
                 dc  xl16'04040404040404040404040404040404' f
psd_default_century      dc  c"19"    |
psd_invalid_function     dc  c"Unsupported function."
psd_invalid_#_parms      dc  c"Invalid number of parameters."
psd_invalid_dt_id        dc  c"Invalid token provided."
psd_env_support_error    dc  c"Environment support error."
psd_string_handler_error dc  c"String handler error."
psd_invalid_time_format  dc  c"Unsupported time format."
psd_invalid_date_format  dc  c"Unsupported date format."
psd_invalid_interval_format  dc  c"Unsupported interval format."
psd_invalid_input_time  dc  c"Invalid time value for specified format."
psd_invalid_input_date  dc  c"Invalid date value for specified format."
psd_invalid_input_interval dc  c"Invalid interval value for specified f*
               ormat."
psd_overflow             dc  c"Output value is too large for requested *
               format."
psd_out_of_range         dc  c"Date/time value is not within acceptable*
                range for requested format."
psd_undetermined_error   dc  c"Undetermined error."
*                                     |
                ltorg ,               |
                endpsd                |
 title "Dsects"                       |
          es_esv ,                    |
          space 2                     |
*---------------------------------------------------------------------*
*  Converter Parameter List DSECT.  This parameter list is common to
*  all conversion routines.  It is generally built by a CALLSUB in the
*  mainline, then based in each converter subroutine as necessary.
*---------------------------------------------------------------------*
cpl       dsect ,                     | Converter Parameter List:
cpl_internal     ds   a               |   Internal-format time value
cpl_interval     ds   0a              |   Interval to convert from/to
cpl_date         ds   a               |   Date to convert from or to
cpl_interval_format ds  0a            |   Format of interval
cpl_date_format  ds   a               |   Format of date
cpl_time         ds   a               |   Time to convert from or to
cpl_time_format  ds   a               |   Format of time
*---------------------------------------------------------------------*
*  Month Table DSECT.  Used to map psd_month_table for month lookups.
*---------------------------------------------------------------------*
month_table dsect ,                   |
mt_month_num   ds   al2               | Character month number
mt_month_name  ds   cl9               | Character name of month
mt_length      equ  *-month_table     | Length of a month table entry
mt_#_entries   equ  12                | Number of month table entries
*                                     |  (until the calendar changes)
          eject                       |
 title "Parameter List"               |
parmlist                      dsect , |
prm_DT_id                     ds a    | DT_identifier === PWA base
prm_functioncode              ds a    | Function to be performed
prm_min_#                     equ (*-parmlist)/4
prm_function_dept             equ *   | Function-dependent parameters
*---------------------------------------------------------------------*
*
*                  Start function parameters
*
*---------------------------------------------------------------------*
                  org prm_function_dept
prm_start_esv                 ds a    | Environment Support Vector.
prm_start_min_#               equ (*-parmlist)/4
prm_start_options             ds a    | Address of option byte
prm_start_max_#               equ (*-parmlist)/4
*---------------------------------------------------------------------*
*
*                 Terminate function parameters
*
*---------------------------------------------------------------------*
               org prm_function_dept  |
prm_terminate_#               equ (*-parmlist)/4
*---------------------------------------------------------------------*
*
*                 Get_Current function parameters
*
*---------------------------------------------------------------------*
               org prm_function_dept  |
prm_get_current   ds    0f            | Parameters for DT_GET_CURRENT.
*                                     | Note: The order of these para-
*                                     | meters must not change, unless
*                                     | the instruction commented as
*                                     | <<Format-dependent>> changes.
prm_get_current_date          ds   a  |
prm_get_current_date_format   ds   a  |
prm_get_current_time          ds   a  |
prm_get_current_time_format   ds   a  |
prm_get_current_#             equ (*-parmlist)/4
*---------------------------------------------------------------------*
*
*                  Convert function parameters
*
*---------------------------------------------------------------------*
                org prm_function_dept |
prm_convert       ds    0f            | Parameters for DT_CONVERT.
*                                     | Note: The order of these para-
*                                     | meters must not change, unless
*                                     | the instruction commented as
*                                     | <<Format-dependent>> changes.
prm_convert_fromdate          ds   a  |
prm_convert_fromdate_format   ds   a  |
prm_convert_fromtime          ds   a  |
prm_convert_fromtime_format   ds   a  |
prm_convert_todate            ds   a  |
prm_convert_todate_format     ds   a  |
prm_convert_totime            ds   a  |
prm_convert_totime_format     ds   a  |
prm_convert_#                 equ (*-parmlist)/4
*---------------------------------------------------------------------*
*
*                     Add function parameters
*
*---------------------------------------------------------------------*
                org prm_function_dept |
prm_add           ds    0f            | Parameters for DT_ADD
*                                     | Note: The order of these para-
*                                     | meters must not change, unless
*                                     | the instruction commented as
*                                     | <<Format-dependent>> changes.
prm_add_datein                ds   a  |
prm_add_datein_format         ds   a  |
prm_add_timein                ds   a  |
prm_add_timein_format         ds   a  |
prm_add_interval              ds   a  |
prm_add_interval_format       ds   a  |
prm_add_dateout               ds   a  |
prm_add_dateout_format        ds   a  |
prm_add_timeout               ds   a  |
prm_add_timeout_format        ds   a  |
*---------------------------------------------------------------------*
*
*                   Subtract function parameters
*
*---------------------------------------------------------------------*
                org prm_function_dept |
prm_subtract      ds    0f            | Parameters for DT_SUBTRACT
*                                     | Note: The order of these para-
*                                     | meters must not change, unless
*                                     | the instruction commented as
*                                     | <<Format-dependent>> changes.
prm_subtract_datein           ds   a  |
prm_subtract_datein_format    ds   a  |
prm_subtract_timein           ds   a  |
prm_subtract_timein_format    ds   a  |
prm_subtract_interval         ds   a  |
prm_subtract_interval_format  ds   a  |
prm_subtract_dateout          ds   a  |
prm_subtract_dateout_format   ds   a  |
prm_subtract_timeout          ds   a  |
prm_subtract_timeout_format   ds   a  |
*---------------------------------------------------------------------*
*
*                   Duration function parameters
*
*---------------------------------------------------------------------*
                org prm_function_dept |
prm_duration      ds    0f            | Parameters for DT_duration
*                                     | Note: The order of these para-
*                                     | meters must not change, unless
*                                     | the instruction commented as
*                                     | <<Format-dependent>> changes.
prm_duration_date1            ds   a  |
prm_duration_date1_format     ds   a  |
prm_duration_time1            ds   a  |
prm_duration_time1_format     ds   a  |
prm_duration_date2            ds   a  |
prm_duration_date2_format     ds   a  |
prm_duration_time2            ds   a  |
prm_duration_time2_format     ds   a  |
prm_duration_duration         ds   a  |
prm_duration_duration_format  ds   a  |
*---------------------------------------------------------------------*
                  org ,               |
prm_max_len       equ   *-parmlist    |
prm_max_#         equ  (*-parmlist)/4 |
*                                     |
 title "Program Work Area"            |
               PWA                    |
pwa_area       ds    0f               | Beginning of visible PWA stg.
pwa_visual     ds    cl8              | Character string 'DIV_SP'.
pwa_DT_id      ds    a                | Pointer to program work area.
pwa_clear_start equ  *                | This area cleared by DT_START.
pwa_ES_epa     ds    f                | Environment Support EPA.
pwa_ES_token   ds    f                | Environment Support PWA token.
pwa_ESV        ds    f                | Environment Support vector addr
pwa_ST_epa     ds    f                | String Formatter EPA.
pwa_ST_token   ds    f                | String Formatter PWA token.
*                                     |  is that spec'd by SizeLength.
pwa_clear_end  equ  *                 | End area cleared by DT_START.
pwa_clear_length   equ   pwa_clear_end-pwa_clear_start
*                                     |
pwa_validate_r14      ds  f           | Validate rtns save R14 here
pwa_call_convert_r14  ds  f           | Call_Convert rtns save R14 here
pwa_converter_R14     ds  f           | Convert_From, _To routines' R14
pwa_iconvert_regs     ds  6f          | Convert_Gregorian_To_Ijuldate,
*                                     |  Convert_Ijuldate_To_Gregorian
*                                     |   save their registers here.
*                                     |
*---------------------------------------------------------------------*
*  Assorted work variables.
*---------------------------------------------------------------------*
pwa_converter_d   ds  f               | These are used by routines
pwa_converter_m   ds  f               | Convert_Gregorian_To_Ijuldate &
pwa_converter_y   ds  f               |  Convert_Ijuldate_To_Gregorian.
pwa_converter_ya  ds  f               |
pwa_converter_c   ds  f               |
pwa_converter_work ds f               |
pwa_converter_work2 ds f              |
pwa_converter_j   ds  f               |
*---------------------------------------------------------------------*
pwa_ES_current_date  ds   f           |
pwa_ES_current_time  ds   f           |
pwa_DT_format_time   ds   d           |
pwa_DT_format_time2  ds   d           |
pwa_DT_format_interval ds d           |
pwa_d                ds   d           | Work doubleword.
pwa_f                ds   f           | Work word.
pwa_i_month          ds   f           |
pwa_i_day            ds   f           |
pwa_i_year           ds   f           |
pwa_interval_numbers     ds   0f      |
pwa_number_of_days       ds   f       |
pwa_number_of_hours      ds   f       |
pwa_number_of_minutes    ds   f       |
pwa_number_of_seconds    ds   f       |
pwa_number_of_hundredths ds   f       |
l_interval_numbers       equ  *-pwa_interval_numbers
pwa_actual_format    ds   f           |
*pwa_convert_parameters ds cl16        |
pwa_edit             ds   cl16        | Place to EDIT stuff.
pwa_packed_validation ds  cl16        |
pwa_text_month       ds   cl9         |
pwa_text_weekday     ds   cl9         |
pwa_numeric_month    ds   cl2         |
pwa_numeric_day      ds   cl2         |
pwa_numeric_year     ds   cl4         |
pwa_numeric_hour     ds   cl2         |
pwa_numeric_minute   ds   cl2         |
pwa_numeric_second   ds   cl2         |
pwa_numeric_hundredths ds cl2         |
pwa_civilian_hour    ds   cl2         |
*                                     |
pwa_reason     ds    f                |
pwa_number_of_parms ds  f             | Number of parms.
pwa_format_length   ds  h             |
pwa_format_string   ds  cl40          |
*                                     |
pwaf1        ds    x                  | General flag byte:
pwaf1sst     equ   x'80' |1... ....|  | .. String Handler started
pwaf1eur     equ   x'40' |.1.. ....|  | .. English-fmt Gregorian dates
pwaf1lz      equ   x'20' |..1. ....|  | .. Leading zeros on everything
pwaf1rev     equ   x'10' |...1 ....|  | .. Sign reversed, ADD=SUB, etc:
*                                     |    see DT_ADD, DT_SUBTRACT in
*                                     |    main CASEBLK.
*                                     |
pwa_flags    ds    0c                 |
*                                     |
pwa_julian_flags        ds   x        |
pwa_julian              equ  x'80'    |
pwa_juliand             equ  x'40'    |
pwa_ijulian             equ  x'20'    |
pwa_pjulian             equ  x'10'    |
pwa_sjulian             equ  x'08'    |
pwa_sjuliand            equ  x'04'    |
*                                     |
pwa_gregorian_flags     ds   x        |
pwa_gregorian           equ  x'80'    |
pwa_sgregorian          equ  x'40'    |
pwa_sortdate            equ  x'20'    |
pwa_ssortdate           equ  x'10'    |
*                                     |
pwa_normal_flags        ds   x        |
pwa_normal              equ  x'80'    |
pwa_snormal             equ  x'40'    |
pwa_sasdate7            equ  x'20'    |
pwa_sasdate9            equ  x'10'    |
pwa_yyyymmmdd           equ  x'08'    |                             @cx
*                                     |
pwa_text_flags          ds   x        |
pwa_text                equ  x'80'    |
pwa_textd               equ  x'40'    |
pwa_weekday             equ  x'20'    |
pwa_weekday3            equ  x'10'    |
*                                     |
pwa_day_flags           ds   x        |
pwa_days                equ  x'80'    |
pwa_pdays               equ  x'40'    |
pwa_idays               equ  x'20'    |
*                                     |
pwa_year_flags           ds   x       |
pwa_year                 equ  x'80'   |
pwa_year2                equ  x'40'   |
pwa_pyear                equ  x'20'   |
pwa_iyear                equ  x'10'   |
*                                     |
pwa_month_flags         ds   x        |
pwa_month               equ  x'80'    |
pwa_pmonth              equ  x'40'    |
pwa_imonth              equ  x'20'    |
pwa_monthname           equ  x'10'    |
pwa_monthname3          equ  x'08'    |
*                                     |
pwa_hour_flags          ds   x        |
pwa_hours               equ  x'80'    |
pwa_phours              equ  x'40'    |
pwa_ihours              equ  x'20'    |
*                                     |
pwa_minute_flags        ds   x        |
pwa_minutes             equ  x'80'    |
pwa_pminutes            equ  x'40'    |
pwa_iminutes            equ  x'20'    |
*                                     |
pwa_second_flags        ds   x        |
pwa_seconds             equ  x'80'    |
pwa_pseconds            equ  x'40'    |
pwa_iseconds            equ  x'20'    |
*                                     |
pwa_hundredth_flags     ds   x        |
pwa_hundredths          equ  x'80'    |
pwa_phundredths         equ  x'40'    |
pwa_ihundredths         equ  x'20'    |
*                                     |
pwa_hhmmss_flags        ds   x        |
pwa_hhmm                equ  x'80'    | HH:MM format
pwa_hhmmss              equ  x'40'    | HH:MM:SS format
pwa_hhmmssth            equ  x'20'    | HH:MM:SS.TH format
pwa_civilian            equ  x'10'    | Civilian (HH:MM:SS AM/PM)
pwa_afternoon           equ  x'01'    | Note that time is "PM"
*                                     |
pwa_general_flags       ds   x        |
pwa_general_input       equ  x'80'    |
*                                     |
pwa_interval_flags      ds   x        | << Nobody looks at these! <<
*wa_hundredths          equ  x'80'    | These values may be used here
*wa_phundredths         equ  x'40'    |
*wa_ihundredths         equ  x'20'    |
pwa_delta               equ  x'08'    |
pwa_todclock            equ  x'04'    |
*                                     |
l_flags           equ   *-pwa_flags   |
*                                     |
pwa_sourceparm_count ds f             | Count of parms in sourcelist.
*                                     |
               es_gdi dsect=no        | General debugging information.
pwa_area_l     equ   *-pwa_area       | Length of visible PWA stg.
               endpwa                 |
               end   ,                |
