*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
SRVST     TITLE 'String Handler'
         SRVMOD NAME=SRVST,DATES='1987, 1989, 1995'
         gblc  &srv_modname
*---------------------------------------------------------------------*
*
*  Copyright (C) Clemson University Research Foundation 1987, 1989.
*
*  Program     SRVST, String Handler
*
*  Abstract    This server provides common functions for string
*              manipulation.  Because most high-level languages have
*              string manipulation functions as part of their
*              definition, the functions in this server are most useful
*              for assembler language programs.
*
*  Parameters:
*    Two parameters, StringTkn, and FunctionCode, are required for each
*    call to the symbol manager.  Additional parameters are required
*    for different FunctionCodes.  The entire parameter list required
*    for each function is listed below.
*
*    START
*      CALLX SRVST,(StringTkn,&START,ESV,SizeLength)
*
*    TERMINATE
*      CALLX SRVST,(StringTkn,&TERMINATE)
*
*    FORMAT
*      CALLX SRVST,(StringTkn,&ST_FORMAT,String,StringLen,ResultLen,
*                    Control,ControlLen,Arg1,...)
*   or CALLX SRVST,(StringTkn,&ST_FORMAT2,String,StringLen,ResultLen,
*                    Control,ControlLen,ArgList,ArgCount)
*
*    CONVERSION FUNCTIONS
*      CALLX SRVST,(StringTkn,&ST_STRING_TO_INTEGER,
*                    String,StringLen,Integer)
*      CALLX SRVST,(StringTkn,&ST_INTEGER_TO_STRING,
*                    Integer,String,StringLen,ResultLen)
*
*  The meaning of each parameter is explained below.
*
*    StringTkn is a fullword used to identify the string session
*      in progress.  It is initialized during the startup function.
*
*    FunctionCode is a fullword integer that specifies the function to
*      be performed.  Symbolic identifiers are provided for each
*      function and may be accessed by placing a COPY statement for
*      SRVSTMAC in the assembler program.  These symbols should be
*      used in place of actual integer values.  The following
*      FunctionCodes are supported:
*
*      &START
*        Begin a new string-handler session.  In addition to the
*        StringTkn and FunctionCode parameters, the parameter ESV
*        is required and the parameter SizeLength is optional.
*
*      &TERMINATE
*        Terminate the string-handler session identified by StringTkn.
*
*      &FORMAT
*        Build a formatted string based on control information and
*        supplied arguments.  This function is most useful for
*        processing messages and lines of output text files.
*
*      &STRING_TO_INTEGER
*        Convert an integer literal to its equivalent fullword signed
*        binary value.  The literal is an optional sign character
*        ('+' or '-') followed by a sequence of digits.  Blanks
*        appearing before or after the sign or digit-sequence are
*        ignored.
*
*  SizeLength
*    A fullword integer indicating the size, in bytes, of the length
*    specifier for strings on which the service processor will operate.
*    It must be 1, 2, 3, or 4 to designate byte, halfword, 3-byte, or
*    fullword lengths.
*
*  String
*    An area of storage for assembling a string to return to the
*    calling program, or providing the source data for conversion
*    from string data to some other data-type.
*
*  StringLen
*    A unsigned <SizeLength> byte integer specifying the length of
*    the String area.
*
*  ResultLen
*    A an unsigned <SizeLength> byte integer set by the string-handler
*    to indicate the length of the string returned in String.
*
*  Control
*    A string containing text and imbedded format information that is
*    used to control the formatting process.  The format information
*    if used to determine how many Arg-n arguments are needed.
*
*  ControlLen
*    A an unsigned <SizeLength> byte integer specifying the length of
*    the control string.
*
*  Arg1, ...
*    Data to be formatted.  The type and length of the data is
*    specified in the control string.
*
*  ArgList
*    References a separatly built variable-length parameter list that
*    contains the arguments Arg1, Arg2, ....
*
*  ArgCount
*    A fullword integer equal to the number of parameters in ArgList.
*
*  Integer
*    A fullword signed binary integer value that is either input for
*    a function (i.e. &ST_INTEGER_TO_STRING) or returned by a function
*    (i.e. &ST_STRING_TO_INTEGER).
*
*  Program     reentrant, problem key and state, standard linkage,
*  Attributes  non-authorized, amode(31), rmode(any)
*
*  Change
*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution
*
*---------------------------------------------------------------------
 EJECT
*
* COPY statements for SMSYMS, SRVESMAC, and SRVSTMAC.
*
 PRINT   OFF
   COPY  SMSYMS               | Copy Structured Macros symbols.
   COPY  SMPUCOND             | Copy User-conditions.
   COPY  SRVESMAC             | Copy Environment Support symbols.
   COPY  SRVSTMAC             | Copy String Handler symbols.
 PRINT   ON
 EJECT
*---------------------------------------------------------------------*
* Main program - Uses the FunctionCode to invoke the right function.
*---------------------------------------------------------------------*
 BLOCK NAME=&srv_modname,TYPE=PROGRAM,AMODE=31,RMODE=ANY,R1SAVE=R11,   +
               OPTIONS=(*SRVPRC,NOVL,LONG),                            +
               SUBOPTS=(*SWA,LOADBASE)
   USING   PARMLIST,R11         | Establish addressability.
   MVC     GDIRC,=H'0'          | Initialize the return-code.
*---------------------------------------------------------------------*
*  Count the number of parameters passed in.
*---------------------------------------------------------------------*
   LA   R1,PARMLIST                   | R1 -> first parameter.
   LOOP WHILE,(TBIT,0(R1),X'80',OFF)  | Loop over parameters.
     LA R1,4(,R1)                     |   Advance to next parameter.
   ENDLOOP WHILE                      | EndLoop.
   LA  R1,4(,R1)                      | Point past final parameter.
   SLR R1,R11                         | Get length of entire parmlist.
   SRL R1,2                           | Get number of parameters.
   ST  R1,&PWA.#PARMS                 | Save in PWA for future use.
*---------------------------------------------------------------------*
*  Use the function code to determine what routine to invoke.
*---------------------------------------------------------------------*
   L       R1,PRM_FUNCTIONCODE  | Load the function code into
   L       R1,0(,R1)            |   a register for testing.
   CASEBLK REG=R1               | Case on FunctionCode.
     CASE &START                |   Start a new string handler session.
       CALLSUB START_STRING_HANDLER
     CASE &TERMINATE            |   Destroy an existing symbol table.
       SMCTRL FREEPWA=YES       |     Free the PWA on return.
     CASE &ST_FORMAT,&ST_FORMAT2    Format a string for output.
       CALLSUB FORMAT_STRING    |
     CASE &ST_INTEGER_TO_STRING |   Convert a fullword to a string.
       CALLSUB INTEGER_TO_STRING
     CASE &ST_STRING_TO_INTEGER |   Convert a string to a fullword.
       CALLSUB STRING_TO_INTEGER,     Invoke conversion function with: +
               (*PRM_STI_STRING,        Source text of integer,        +
               *PRM_STI_LENGTH,         Length of source text, and     +
               *PRM_STI_INTEGER)        Return-integer area.
       ERREXIT (TREG,R15,NZ),CODE=00  Errexit w/R15 as return-code.
     CASE OTHER                 |   Invalid Function Code.
       ERREXIT CODE=&ST_INVALID_FUNCTION
   ENDCASE                      | EndCase.
   LH   R15,GDIRC               | Pick up non-terminating RC.
 ENDBLK BLOCK=&srv_modname,RC=(R15)
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: START_STRING_HANDLER                                   *
*  Abstract:   Begin a new string handler session, establishing the   *
*              size of string-length values (halfword lengths, etc).  *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=START_STRING_HANDLER
*---------------------------------------------------------------------*
*  Process the optional SIZELENGTH parameter.
*---------------------------------------------------------------------*
   LA  R1,2                       | Default := halfword lengths.
   IF  (CLC,&PWA.#PARMS,GE,=F'4') | If SizeLength parameter present.
     L  R1,PRM_S_SIZELENGTH       |   R1 -> SizeLength's Value.
     LA R1,0(,R1)                 |   Clear high-bit.
     IF (TREG,R1,NZ)              |   If SizeLength specified.
       L R1,0(R1)                 |     R1 := SizeLength's Value.
       ERREXIT ((C,R1,LT,=F'1'),OR,(C,R1,GT,=F'4')),                   +
               CODE=&ST_INVALID_SIZELENGTH
     ENDIF                        |   EndIf.
   ENDIF                          | EndIf.
   ST R1,&PWA.SIZELENGTH          | Save sizelength's value.
   S  R1,=F'1'                    | R1 := offset into bit-mask array.
   LA R1,&PSD.BIT_MASK(R1)        | R1 -> bit-mask for ICM/STCM's.
   L8 R0,0(R1)                    | R0 := bit-mask for ICM/STCM's.
   ST R0,&PWA.SIZEMASK            | Save for getting/setting lengths.
 ENDBLK BLOCK=START_STRING_HANDLER
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: FORMAT_STRING                                          *
*  Abstract:   See "Service Processors User's Guide and Reference",   *
*              ST_FORMAT function for a description of this routine.  *
*                                                                     *
***********************************************************************
 BLOCK NAME=FORMAT_STRING,TYPE=SUBROUTINE
   L       R6,&PWA.#PARMS         | R6 := number of parameters passed.
   ERREXIT (C,R6,LT,=F'7'),CODE=&ST_WRONG_NUMBER_OF_PARAMETERS
*---------------------------------------------------------------------*
*  Initialize PWA variables for tracking the Control string position.
*---------------------------------------------------------------------*
   L   R1,PRM_F_CONTROL           | R1 -> Control string.
   L   R2,PRM_F_CONTROL_LEN       | R2 -> Control string's length.
   SLR R3,R3                      | Clear for the ICM below.
   L   R15,&PWA.SIZEMASK          | R15 := length-mask.
   EXI R15,(ICM,R3,0,0(R2))       | R3 := Length of control string.
   SL  R3,=F'1'                   | R3 := Offset to last byte.
   ALR R3,R1                      | R3 -> Last byte.
   ST  R1,&PWA.CONTROL_START      | Save start-of-control address.
   ST  R1,&PWA.CONTROL_CURRENT    | Save current Control position.
   ST  R3,&PWA.CONTROL_END        | Save end-of-control address.
*---------------------------------------------------------------------*
*  Initialize PWA variables for tracking the String position.
*---------------------------------------------------------------------*
   L   R1,PRM_F_STRING            | R1 -> target String.
   L   R2,PRM_F_STRING_LEN        | R2 -> Length of target String.
   SLR R3,R3                      | Clear R3 for ICM below.
   L   R15,&PWA.SIZEMASK          | R15 := length-mask.
   EXI R15,(ICM,R3,0,0(R2))       | R3 := Length of String area.
   SL  R3,=F'1'                   | R3 := Offset to last byte.
   ALR R3,R1                      | R3 -> Last byte.
   ST  R1,&PWA.STRING_START       | Save start-of-String address.
   ST  R1,&PWA.STRING_CURRENT     | Save Current String position.
   ST  R1,&PWA.STRING_HIGHWATER   | Save Highwater String position.
   ST  R3,&PWA.STRING_END         | Save End of String address.
*---------------------------------------------------------------------*
*  Initialize PWA variables for tracking the current Argument.
*---------------------------------------------------------------------*
   L   R1,PRM_FUNCTIONCODE            | R1 -> Function code passed in.
   L   R1,0(,R1)                      | R1 := Function code.
*                                     |
   S   R6,=F'7'                       | R6 := #parms after control_len.
   IF  (TREG,R6,NP)                   | If no <argument>s passed in.
     SLR  R7,R7                       |   R7 -> null parameter list.
   ELSEIF (C,R1,EQ,=F'&ST_FORMAT')    | ElseIf FORMAT parmlist.
     LA   R7,PRM_F_ARGLIST            |   R7 -> First argument.
   ELSEIF (C,R1,EQ,=F'&ST_FORMAT2')   | ElseIf FORMAT2 parmlist.
     IF (C,R6,NE,=F'2')               |   If ArgCount is missing.
       ERREXIT CODE=&ST_WRONG_NUMBER_OF_PARAMETERS
     ELSE                             |   Else.
       L   R6,PRM_F_ARGCOUNT          |     R6 -> Number of arguments.
       IF  (TREG,R6,NZ)               |     If parameter not missing.
         L  R6,0(,R6)                 |       R6 := number <arguments>.
       ENDIF                          |     EndIf.
       L   R7,PRM_F_ARGLIST           |     R7 -> First argument.
     ENDIF                            |   EndIf.
   ENDIF                              | EndIf.
*                                     |
   STM R6,R7,&PWA.ARGUMENT_LIST       | Save <arg> count/address.
   EJECT
*---------------------------------------------------------------------*
*  Loop over the Control string to produce the result in String.
*---------------------------------------------------------------------*
   LOOP UNTIL                     | Loop over control string.
     L       R2,&PWA.CONTROL_CURRENT            R2 -> Current txt.
     LEAVE   LOOP=*,(C,R2,GT,&PWA.CONTROL_END)  Done if @ end.
     CALLSUB FIND_CONTROL_CHARACTER,('{',&W.TEXT_LENGTH)
     L       R3,&W.TEXT_LENGTH    |             R3 := Length to '{'.
     CALLSUB COPY_TO_STRING,((R2),(R3))         Copy text.
     ALR     R2,R3                |             R2 -> Format-spec.
     ST      R2,&PWA.CONTROL_CURRENT            Update Current pos.
     LEAVE   LOOP=*,(C,R2,GT,&PWA.CONTROL_END)  Done if @ end.
     CALLSUB PROCESS_FORMAT_SPECIFICATION       Format data.
   ENDLOOP UNTIL,LEAVE            | EndLoop.
   L   R2,&PWA.STRING_HIGHWATER   | R2 := Last byte formatted, + 1.
   SL  R2,&PWA.STRING_START       | R2 := Length formatted.
   L   R1,PRM_F_FMT_LEN           | R1 -> Formatted string length parm.
   IF  (TREG,R1,NZ)               | If parameter is not missing.
     L   R15,&PWA.SIZEMASK        |   R15 := length-mask.
     EXI R15,(STCM,R2,0,0(R1))    |   Save as target string's length.
   ENDIF                          | EndIf.
 ENDBLK BLOCK=FORMAT_STRING
*---------------------------------------------------------------------*
* Working storage for the ST_FORMAT function.
*---------------------------------------------------------------------*
                SWA
&W.TEXT_LENGTH  DS    F    | Length of text up to format-specification.
                ENDSWA
                EJECT
**********************************************************************
*                                                                    *
*  Subroutine: FIND_CONTROL_CHARACTER,(Char,OffsetFromCurrent)       *
*  Abstract:   Using the &PWA.CONTROL_xxx markers, scan the Control  *
*              string from the current position towards the end to   *
*              locate the next occurance of the specified character. *
*              Return the offset from &PWA.CONTROL_CURRENT to the    *
*              located character. (The offset can also be thought of *
*              as the length of the Control string's text up to the  *
*              character).  If the character is not found, it will   *
*              be assumed to magically have been appended to the end *
*              of the Control string.                                *
*                                                                    *
**********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=FIND_CONTROL_CHARACTER
   LM    R8,R9,0(R1)                | R8->Char, R9->OffsetFromCurrent.
*---------------------------------------------------------------------*
*  Point R1 (via the TRT instruction) to the next control character
*  or past the end of the entire control string if there is not one.
*---------------------------------------------------------------------*
   L     R7,&PWA.CONTROL_CURRENT    | R7 -> Current Control position.
   L     R6,&PWA.CONTROL_END        | R6 -> Last control byte.
*
*  Scan loop below does the same thing as the TRTs below.  It
*  is shorter, but is it faster? NO! STROBE SAYS IT TAKES LONGER.
*
*  LR    R1,R7                      | R1 -> CURRENT CONTROL CHARACTER.
*  LOOP  WHILE,(CR,R1,LE,R6),AND,(CLC,0(1,R1),NE,0(R8))
*   LA   R1,1(,R1)                  |
*  ENDLOOP WHILE                    |
*  SLR   R1,R7                      | R1 := OFFSETFROMCURRENT.
*  ST    R1,0(,R9)                  | SAVE IN CALLER'S PARM.
*  LEAVE BLOCK=*                    | RETURN TO CALLER.
*
   SR    R6,R7                      | R6 := length remaining - 1.
   LA    R6,1(,R6)                  | R6 := Length remaining.
   LR    R5,R7                      | R5 -> Current control character.
   L8    R4,0(R8)                   | R4 := Desired character.
   LA    R4,&PWA.TRANTAB(R4)        | R4 -> Table position.
   MVI   0(R4),X'FF'                | Flag as character we want.
   LOOP  WHILE,(C,R6,GT,=F'256')    | Scan in 256-byte chunks.
     TRT   0(256,R5),&PWA.TRANTAB   |   Scan for wanted character.
     LEAVE LOOP=*,NZ                |   Exit if found.
     A     R5,=F'256'               |   Advance to next 256-byte chunk.
     S     R6,=F'256'               |   Subtract length covered.
   ENDLOOP WHILE                    | EndLoop.
   IF (C,R6,LE,=F'256')             | If Char was NOT found,
     BCTR R6,0                      |   Subtract 1 for the EX instr.
     EXI  R6,(TRT,0(0,R5),&PWA.TRANTAB) Scan for wanted Char.
     IF   Z,THEN                    |   If NOT found then
       L  R1,&PWA.CONTROL_END       |     R1 -> last byte in control.
       A  R1,=F'1'                  |     R1 -> past end of control.
     ENDIF                          |   EndIf.
   ENDIF                            | EndIf.
   MVI   0(R4),X'00'                | Reset translate table character.
*---------------------------------------------------------------------*
*  Calculate the offset from &PWA.CONTROL_CURRENT to 0(R1) and return.
*---------------------------------------------------------------------*
   SLR  R1,R7                       | R1 := Offset to '{' character.
   ST   R1,0(,R9)                   | Save as OffsetFromCurrent.
 ENDBLK BLOCK=FIND_CONTROL_CHARACTER
 EJECT
**********************************************************************
*                                                                    *
*  Subroutine: PROCESS_FORMAT_SPECIFICATION                          *
*  Abstract:   When this routine is called, &PWA.CONTROL_CURRENT     *
*              points to the start of a format specification.  This  *
*              routine decodes the entire specification, updates     *
*              &PWA.CONTROL_CURRENT to the position following the    *
*              format specification, and then performs the indicated *
*              formatting function.                                  *
*                                                                    *
**********************************************************************
 BLOCK NAME=PROCESS_FORMAT_SPECIFICATION,TYPE=SUBROUTINE
   L       R8,&PWA.CONTROL_CURRENT       | R8 -> Current position.
   LA      R8,1(,R8)                     | R8 -> Past initial '{' char.
   ERREXIT (CL,R8,GT,&PWA.CONTROL_END),CODE=&ST_FORMAT_SPEC_NOT_ENDED
   ST      R8,&PWA.FS_CURRENT            | Set current fmt-spec pos.
*---------------------------------------------------------------------*
*  If it is the special format specification '{{', process it now.
*---------------------------------------------------------------------*
   IF (CLI,0(R8),EQ,C'{')                | If spec is equal to '{{'.
     LA      R7,1                        |   R7 := length to copy.
     CALLSUB COPY_TO_STRING,((R8),(R7))  |   Copy 1 '{'.
     LA      R8,1(,R8)                   |   R8 -> Past '{{'.
     ST      R8,&PWA.CONTROL_CURRENT     |   Update Control position.
     LEAVE   BLOCK=*                     |   Return to caller.
   ENDIF                                 | EndIf.
*--------------------------------------------------------------------*
*  Find the end of the format specification and decode its contents.
*---------------------------------------------------------------------*
   CALLSUB FIND_CONTROL_CHARACTER,('}',&PWA.FS_LENGTH)
   L       R9,&PWA.CONTROL_CURRENT       | R9 -> '{' character.
   AL      R9,&PWA.FS_LENGTH             | R9 -> '}' character.
   ERREXIT (CL,R9,GT,&PWA.CONTROL_END),CODE=&ST_FORMAT_SPEC_NOT_ENDED
   BCTR    R9,0                          | R9 -> Before final '}' char.
   ST      R9,&PWA.FS_END                | Save end of spec position.
   MVI     &PWA.FS_FIELDS,X'00'          | No fields specified so far.
*                                        |
   CALLSUB GETFMT_LEADING_PAD            | Scan leading '0' field.
   CALLSUB GETFMT_WIDTH                  | Scan width field.
   CALLSUB GETFMT_PRECISION              | Scan .precision field.
   CALLSUB GETFMT_COLUMN                 | Scan @column field.
   CALLSUB GETFMT_TYPE                   | Scan Type field.
   CALLSUB GETFMT_LENGTH                 | Scan Length field.
   CALLSUB GETFMT_MULTIPLE               | Scan Multiple field.
   CALLSUB GETFMT_KEYWORDS               | Scan Keywords field.
*                                        |
   LA      R8,2(,R9)                     | R8 -> Past '}' character.
   ST      R8,&PWA.CONTROL_CURRENT       | Update Control position.
*---------------------------------------------------------------------*
*  Check to make sure that things were specified right.
*---------------------------------------------------------------------*
   IF (TBIT,&PWA.FS_FIELDS,&PWA.FSF_TYPE,OFF)  | If type not specified.
     IF (CLI,&PWA.FS_FIELDS,EQ,X'00')          |   If nothing there.
       ERREXIT CODE=&ST_FORMAT_SPEC_EMPTY      |     Invalid fmt-spec.
     ELSEIF (CLI,&PWA.FS_FIELDS,NE,&PWA.FSF_COLUMN) If not {@column}.
       ERREXIT CODE=&ST_FORMAT_TYPE_REQUIRED   |     Invalid fmt-spec.
     ENDIF                                     |   EndIf.
   ENDIF                                       | EndIf.
*---------------------------------------------------------------------*
*  Perform column-adjustment based on the @column format specification.
*---------------------------------------------------------------------*
   CALLSUB ADJUST_COLUMN_POSITION
   LEAVE   BLOCK=*,(CLI,&PWA.FS_FIELDS,EQ,&PWA.FSF_COLUMN)
*---------------------------------------------------------------------*
*  Set the default justification if needed.
*---------------------------------------------------------------------*
   L32   R7,&PWA.FSV_TYPE              | R7 := Type-index.
   USING TYPE_ENTRY,R7                 | Establish addressability.
   IF (CLI,&PWA.FSV_LEFT,NE,C'Y'),AND,(CLI,&PWA.FSV_RIGHT,NE,C'Y'),    +
               AND,(CLI,&PWA.FSV_CENTER,NE,C'Y')
    IF (CLI,TE_JUSTIFY,EQ,C'R')
     MVI &PWA.FSV_RIGHT,C'Y'
    ELSEIF (CLI,TE_JUSTIFY,EQ,C'C')
     MVI &PWA.FSV_CENTER,C'Y'
    ELSE
     MVI &PWA.FSV_LEFT,C'Y'
    ENDIF
   ENDIF                               | EndIf.
*---------------------------------------------------------------------*
*  Format the source argument(s).
*---------------------------------------------------------------------*
   L32    R15,TE_ROUTINE               | R15 -> Formatting routine.
   BASR   R14,R15                      | Format source data.
*
   IF (TBIT,&PWA.FS_FIELDS,&PWA.FSF_MULTIPLE,ON)
    L    R2,&PWA.FSV_MULTIPLE          |  r2 := #elements.
    LOOP UNTIL                         |  Loop over elements.
     S     R2,=F'1'                    |   Just did one.
     LEAVE LOOP=*,(NP)                 |   Done if no more.
     L     R0,&PWA.FSV_SOURCE          |   r0 -> source address.
     A     R0,&PWA.FSV_LENGTH          |   r0 -> next source element.
     ST    R0,&PWA.FSV_SOURCE          |   Update source address.
     IF (CLI,&PWA.FSV_CSV,EQ,C'Y')     |   If CSV requested.
      LA      R3,1                     |       Set length to 1.
      CALLSUB COPY_TO_STRING,(',',(R3)),NOVL   Insert comma.
     ENDIF                             |   EndIf.
     L32   R15,TE_ROUTINE              |   R15 -> Formatting routine.
     BASR  R14,R15                     |   Format source data.
    ENDLOOP UNTIL,LEAVE                |  EndLoop over elements.
   ENDIF                               | EndIf (multiple)
*
 ENDBLK BLOCK=PROCESS_FORMAT_SPECIFICATION
 EJECT
**********************************************************************
*                                                                    *
*  Subroutine: GETFMT_LEADING_PAD                                    *
*  Abstract:   Obtain the leading pad character.                     *
*                                                                    *
**********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=GETFMT_LEADING_PAD
   L       R8,&PWA.FS_CURRENT          | R8->Current. R9->Limit.
   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END) Return if past end.
*                                      |
   MVI &PWA.FSV_LEADING_PAD,C' '       | Set default pad character.
   IF  (CLI,0(R8),EQ,C'0')             | If padding with zeros.
     LA   R8,1(,R8)                    |   Point past the '0'.
     ST   R8,&PWA.FS_CURRENT           |   Update current position.
     MVI  &PWA.FSV_LEADING_PAD,C'0'    |   Set pad character.
     SBIT &PWA.FS_FIELDS,&PWA.FSF_LEADING_PAD
   ENDIF                               | EndIf.
 ENDBLK BLOCK=GETFMT_LEADING_PAD       |
**********************************************************************
*                                                                    *
*  Subroutine: GETFMT_WIDTH                                          *
*  Abstract:   Obtain the width field of a format-specification.     *
*                                                                    *
**********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=GETFMT_WIDTH
   L       R8,&PWA.FS_CURRENT              | R8->Current. R9->Limit.
   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Return if past end.
   CALLSUB GETFMT_INTEGER,(&PWA.FSV_WIDTH) | Parse <digits> or '?'.
   IF (TREG,R15,Z)                         | If a value was obtained.
     SBIT &PWA.FS_FIELDS,&PWA.FSF_WIDTH    |   Width was specified.
   ELSE                                    | Else not specified.
     MVC  &PWA.FSV_WIDTH,=F'0'             |   Set default width.
   ENDIF                                   | EndIf.
 ENDBLK BLOCK=GETFMT_WIDTH
**********************************************************************
*                                                                    *
*  Subroutine: GETFMT_PRECISION                                      *
*  Abstract:   Obtain the precision field of a format-specification. *
*                                                                    *
**********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=GETFMT_PRECISION
   L       R8,&PWA.FS_CURRENT              | R8->Current. R9->Limit.
   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Return if past end.
   LEAVE   BLOCK=*,(CLI,0(R8),NE,C'.')     | Leave if no .precision.
   SBIT    &PWA.FS_FIELDS,&PWA.FSF_PRECISION .precision was specified.
   LA      R8,1(,R8)                       | Advance past the '.'.
   ST      R8,&PWA.FS_CURRENT              | Update current position.
*
   CALLSUB GETFMT_INTEGER,(&PWA.FSV_PRECISION)
   ERREXIT (TREG,R15,NZ),CODE=&ST_FORMAT_MISSING_PRECISION_VALUE
   L32     R1,&PWA.FSV_PRECISION
   ERREXIT NP,CODE=&ST_FORMAT_PRECISION_TOO_SMALL
 ENDBLK BLOCK=GETFMT_PRECISION
 EJECT
**********************************************************************
*                                                                    *
*  Subroutine: GETFMT_COLUMN                                         *
*  Abstract:   Obtain the column field of a format-specification.    *
*                                                                    *
**********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=GETFMT_COLUMN
   L       R8,&PWA.FS_CURRENT              | R8->Current. R9->Limit.
   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Return if past end.
   LEAVE   BLOCK=*,(CLI,0(R8),NE,C'@')     | Return if @column ¬there.
   SBIT    &PWA.FS_FIELDS,&PWA.FSF_COLUMN  | @column field is present.
   MVI     &PWA.FSV_COLUMN,C'@'            | Default = EndOfString.
   LA      R8,1(,R8)                       | Advance to next char.
   ST      R8,&PWA.FS_CURRENT              | Update current position.
   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Leave if past end.
*                                          |
   IF (CLI,0(R8),EQ,C'+'),OR,(CLI,0(R8),EQ,C'-')
     MVC   &PWA.FSV_COLUMN(1),0(R8)        |   Relative Column#.
     LA    R8,1(,R8)                       |   Advance to next char.
     ST    R8,&PWA.FS_CURRENT              |   Update current position.
   ENDIF                                   | EndIf.
*                                          |
   CALLSUB GETFMT_INTEGER,(&PWA.FSV_COLUMN+1)
*                                          |
   IF (TREG,R15,NZ)                        | If no value was specified.
     IF (CLI,&PWA.FSV_COLUMN,NE,C'@')      |   If +/- was specified.
       ERREXIT CODE=&ST_FORMAT_MISSING_COLUMN_VALUE
     ENDIF                                 |   EndIf.
   ELSEIF (CLI,&PWA.FSV_COLUMN,EQ,C'@')    | ElseIf not relative col#.
     MVI &PWA.FSV_COLUMN,C'='              |   Set to absolute column#.
   ENDIF                                   | EndIf.
 ENDBLK BLOCK=GETFMT_COLUMN
 EJECT
**********************************************************************
*                                                                    *
*  Subroutine: GETFMT_TYPE                                           *
*  Abstract:   Obtain the type field of a format-specification.      *
*                                                                    *
**********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=GETFMT_TYPE
   L       R8,&PWA.FS_CURRENT              | R8->Current. R9->Limit.
   LEAVE   BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Leave if past end.
   SBIT    &PWA.FS_FIELDS,&PWA.FSF_TYPE    | Type *must* be there.
*                                          |
   LM     R15,R1,=A(&PSD.TYPES-TYPE_ENTRY_L,TYPE_ENTRY_L,&PSD.TYPES_E)
   USING  TYPE_ENTRY,R15                   | Establish addressability.
   LOOP   BXH,R15,R0                       | Loop over valid types.
     LEAVE LOOP=*,(CLC,TE_CHAR,EQ,0(R8))   |   Leave if valid type.
   ENDLOOP BXH                             | EndLoop.
   ERREXIT (CR,R15,GT,R1),CODE=&ST_FORMAT_UNSUPPORTED_TYPE
   STCM    R15,B'1111',&PWA.FSV_TYPE       | Save type's entry address.
*                                          |
   IF (CLI,&PWA.FSV_LEADING_PAD,EQ,C'0')   | If leading pad = '0'.
     IF (C,R15,NE,=A(&PSD.TYPE_I)),AND,    |   If not signed-integer or+
               (C,R15,NE,=A(&PSD.TYPE_U)),AND,   unsigned-integer or   +
               (C,R15,NE,=A(&PSD.TYPE_A))  |     address.
       ERREXIT CODE=&ST_FORMAT_PAD_TYPE_CONFLICT   Illegal pad-char.
     ENDIF                                 |   EndIf.
   ENDIF                                   | EndIf.
*                                          |
   LM R2,R3,&PWA.ARGUMENT_LIST             | R2:=count, R3->current.
   IF (TREG,R2,NP),OR,(TREG,R3,Z),THEN     | If no more <arguments>.
     ERREXIT CODE=&ST_FORMAT_MISSING_ARGUMENT  Exit with error code.
   ENDIF                                   | EndIf.
   MVC     &PWA.FSV_SOURCE,0(R3)           | Copy <argument> address.
   LA      R3,4(,R3)                       | Point to next <argument>.
   BCTR    R2,0                            | Subtract 1 from count.
   STM     R2,R3,&PWA.ARGUMENT_LIST        | Update current arg.
*                                          |
   LA      R8,1(,R8)                       | Advance to next char.
   ST      R8,&PWA.FS_CURRENT              | Update current position.
 ENDBLK BLOCK=GETFMT_TYPE
 EJECT
**********************************************************************
*                                                                    *
*  Subroutine: GETFMT_LENGTH                                         *
*  Abstract:   Obtain the length field of a format-specification.    *
*                                                                    *
**********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=GETFMT_LENGTH
   L     R8,&PWA.FS_CURRENT                  | R8->Current. R9->Limit.
   L32   R7,&PWA.FSV_TYPE                    | R7 -> Type Entry.
   USING TYPE_ENTRY,R7                       | Get addressability.
   MVC   &PWA.FSV_LENGTH,TE_DEFAULT          | Set default length.
   LEAVE BLOCK=*,((C,R8,GT,&PWA.FS_END),OR,(CLI,0(R8),NE,C'L'))
*                                            |
   SBIT    &PWA.FS_FIELDS,&PWA.FSF_LENGTH    | Llength was specified.
   LA      R8,1(,R8)                         | Advance past the 'L'.
   ST      R8,&PWA.FS_CURRENT                | Update position.
   CALLSUB GETFMT_INTEGER,(&PWA.FSV_LENGTH)  | Obtain integer value.
   ERREXIT (TREG,R15,NZ),CODE=&ST_FORMAT_MISSING_LENGTH_VALUE
   L32     R1,&PWA.FSV_LENGTH                | R1 := Specified len.
   ERREXIT M,CODE=&ST_FORMAT_LENGTH_TOO_SMALL
   ERREXIT (CLM,R1,B'1111',LT,TE_MIN),CODE=&ST_FORMAT_LENGTH_TOO_SMALL
   ERREXIT (CLM,R1,B'1111',GT,TE_MAX),CODE=&ST_FORMAT_LENGTH_TOO_LARGE
 ENDBLK BLOCK=GETFMT_LENGTH
 EJECT
**********************************************************************
*                                                                    *
*  Subroutine: GETFMT_MULTIPLE                                       *
*  Abstract:   Obtain the multiple field of a format-specification.  *
*                                                                    *
**********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=GETFMT_MULTIPLE
   L     R8,&PWA.FS_CURRENT                  | R8->Current. R9->Limit.
   L32   R7,&PWA.FSV_TYPE                    | R7 -> Type Entry.
   USING TYPE_ENTRY,R7                       | Get addressability.
   LEAVE BLOCK=*,((C,R8,GT,&PWA.FS_END),OR,(CLI,0(R8),NE,C'M'))
*                                            |
   SBIT    &PWA.FS_FIELDS,&PWA.FSF_MULTIPLE  | Mmultiple was specified.
   LA      R8,1(,R8)                         | Advance past the 'M'.
   ST      R8,&PWA.FS_CURRENT                | Update position.
   CALLSUB GETFMT_INTEGER,(&PWA.FSV_MULTIPLE)  Obtain integer value.
   ERREXIT (TREG,R15,NZ),CODE=&ST_FORMAT_MISSING_MULTIPLE_VALUE
   L32     R1,&PWA.FSV_MULTIPLE              | R1 := Specified len.
   ERREXIT M,CODE=&ST_FORMAT_MULTIPLE_TOO_SMALL
 ENDBLK BLOCK=GETFMT_MULTIPLE
 EJECT
**********************************************************************
*                                                                    *
*  Subroutine: GETFMT_KEYWORDS                                       *
*  Abstract:   Obtain the keywords field of a format-specification.  *
*                                                                    *
**********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=GETFMT_KEYWORDS
   FILL  &PWA.FSV_KEYWORDS,C'N',LENGTH=(&PWA.FSV_KEYWORDS_LEN,S)
   L     R8,&PWA.FS_CURRENT              | R8->Current position.
   LEAVE BLOCK=*,(C,R8,GT,&PWA.FS_END)   | Leave if past end.
*                                        |
   IF (CLI,0(R8),NE,C' '),THEN           | If no blank after TYPE.
     ERREXIT CODE=&ST_FORMAT_UNSUPPORTED_ITEM
   ENDIF                                 | EndIf.
   LA   R8,1(,R8)                        | Advance past 1st blank.
*                                        |
   LOOP NAME=KWD_LOOP,WHILE,(C,R8,LE,&PWA.FS_END)
     LOOP WHILE,(CLI,0(R8),EQ,C' ')      |   Scan for a non-blank.
       LA    R8,1(,R8)                   |     Advance to next char.
       LEAVE LOOP=KWD_LOOP,(C,R8,GT,&PWA.FS_END)
     ENDLOOP WHILE                       |   EndLoop.
     SBIT  &PWA.FS_FIELDS,&PWA.FSF_KEYWORDS  At least one KWD.
*                                        |
     LR   R7,R8                          |   Use R7 to find end-of-kwd.
     LOOP WHILE,(C,R7,LE,&PWA.FS_END)    |   Scan for a delimiter.
       L8    R1,0(R7)                    |     R1 := actual character.
       LA    R1,CLASSIFICATION(R1)       |     R1 -> char's class.
       LEAVE LOOP=*,(CLI,0(R1),EQ,DELIMITER)   Leave if delimiter.
       LA    R7,1(,R7)                   |     Advance to next char.
     ENDLOOP WHILE                       |   EndLoop.
     SLR     R7,R8                       |   R7 := keyword's length.
     ERREXIT (TREG,R7,NP),CODE=&ST_FORMAT_UNSUPPORTED_ITEM
*                                        |
     LA   R14,GFK_TABLE                  |   R14 -> Keyword table.
     LR   R15,R7                         |   Use R15 for Executed
     BCTR R15,0                          |     comparison instructions.
     LOOP WHILE,(CLC,=X'00',NE,2(R14))   |   Loop over keywords.
       IF (C,R7,LE,=F'256'),AND,(CLM,R7,B'0001',EQ,2(R14))
         EXI   R15,(CLC,0(0,R8),3(R14))  |     Compare keyword entry.
         LEAVE LOOP=*,EQ                 |     Leave loop if match.
       ENDIF                             |   EndIf.
       L8    R1,2(R14)                   |   R1 := keyword's length.
       LA    R14,3(R1,R14)               |   R14 -> Next table entry.
     ENDLOOP WHILE                       |   EndLoop.
*                                        |
     ERREXIT (CLI,2(R14),EQ,X'00'),CODE=&ST_FORMAT_UNSUPPORTED_KEYWORD
     L16 R1,0(R14)                       |   R1 := keyword offset
     LA  R1,&PWA.FSV_KEYWORDS(R1)        |   R1 -> keyword's flag.
     MVI 0(R1),C'Y'                      |   Set keyword's flag.
     LA R8,0(R7,R8)                      |   Advance past the word.
     ST R8,&PWA.FS_CURRENT               |   Save current position.
*                                        |
     IF (CLI,&PWA.FSV_FILL,EQ,C'Y')      |   If FILL keyword
       CALLSUB GETFMT_FILL_OPERANDS      |     Get optional operand(s).
       L       R8,&PWA.FS_CURRENT        |     Obtain new position.
       IF      (%L32,R1,&PWA.FSV_FILL_LENGTH,NP)  If no valid filler.
         MVC &PWA.FSV_FILL_LENGTH,=F'2'  |          Set default filler
         MVC &PWA.FSV_FILL_VALUE(2),=C' .'          to FILL( .)
       ENDIF                             |        EndIf.
     ENDIF                               |   EndIf.
   ENDLOOP WHILE                         | EndLoop.
   ST R8,&PWA.FS_CURRENT                 | Save current position.
*  *------------------------------------------------------------------*
*  * LEFT, RIGHT and CENTER are mutually exclusive.
*  *------------------------------------------------------------------*
   IF (CLI,&PWA.FSV_LEFT,EQ,C'Y')
    IF (CLI,&PWA.FSV_CENTER,EQ,C'Y'),OR,(CLI,&PWA.FSV_RIGHT,EQ,C'Y')
     ERREXIT CODE=&ST_FORMAT_KEYWORD_CONFLICT  |   Not allowed.
    ENDIF
   ELSEIF (CLI,&PWA.FSV_RIGHT,EQ,C'Y')
    IF (CLI,&PWA.FSV_CENTER,EQ,C'Y'),OR,(CLI,&PWA.FSV_LEFT,EQ,C'Y')
     ERREXIT CODE=&ST_FORMAT_KEYWORD_CONFLICT  |   Not allowed.
    ENDIF
   ELSEIF (CLI,&PWA.FSV_CENTER,EQ,C'Y')
    IF (CLI,&PWA.FSV_LEFT,EQ,C'Y'),OR,(CLI,&PWA.FSV_RIGHT,EQ,C'Y')
     ERREXIT CODE=&ST_FORMAT_KEYWORD_CONFLICT  |   Not allowed.
    ENDIF
   ENDIF
*  *------------------------------------------------------------------*
*  * RIGHT and CENTER are not allowed with MULTIPLE or CSV.
*  *------------------------------------------------------------------*
   IF (CLI,&PWA.FSV_CENTER,EQ,C'Y'),OR,(CLI,&PWA.FSV_RIGHT,EQ,C'Y')
    IF (TBIT,&PWA.FS_FIELDS,&PWA.FSF_MULTIPLE,ON)
     ERREXIT CODE=&ST_FORMAT_MULTIPLE_NOT_ALLOWED  Not allowed.
    ENDIF
    IF (CLI,&PWA.FSV_CSV,EQ,C'Y'),OR,(CLI,&PWA.FSV_QST,EQ,C'Y')
     ERREXIT CODE=&ST_FORMAT_KEYWORD_CONFLICT   |   Not allowed.
    ENDIF
   ENDIF
*  *------------------------------------------------------------------*
*  * QST only valid for type character.
*  *------------------------------------------------------------------*
   L32   R7,&PWA.FSV_TYPE              | R7 := Type-index.
   USING TYPE_ENTRY,R7                 | Establish addressability.
   IF (CLI,&PWA.FSV_QST,EQ,C'Y'),AND,(CLI,TE_CHAR,NE,C'C')
    ERREXIT CODE=&ST_FORMAT_QST_TYPE_CONFLICT
   ENDIF
   DROP R7
 ENDBLK BLOCK=GETFMT_KEYWORDS
 EJECT
*---------------------------------------------------------------------*
*  Local static data for a keyword-table.
*---------------------------------------------------------------------*
           SSD
           MACRO
&LABEL     KEYWORD &OFFSET,&STRING
           AIF  ('&STRING' EQ '').NULLSTR
&LABEL     DC   AL2(&OFFSET)
           DC   AL1(L'STR&SYSNDX)
STR&SYSNDX DC   C&STRING
           MEXIT
.NULLSTR   ANOP
&LABEL     DC   AL2(0),AL1(0)
           MEND
GFK_TABLE  DS   0X
           KEYWORD &PWA.FSV_LEFT-&PWA.FSV_KEYWORDS,'LEFT'
           KEYWORD &PWA.FSV_RIGHT-&PWA.FSV_KEYWORDS,'RIGHT'
           KEYWORD &PWA.FSV_TRIM-&PWA.FSV_KEYWORDS,'TRIM'
           KEYWORD &PWA.FSV_TRIM-&PWA.FSV_KEYWORDS,'T'
           KEYWORD &PWA.FSV_RELATIVE-&PWA.FSV_KEYWORDS,'RELATIVE'
           KEYWORD &PWA.FSV_RELATIVE-&PWA.FSV_KEYWORDS,'REL'
           KEYWORD &PWA.FSV_RELATIVE-&PWA.FSV_KEYWORDS,'R'
           KEYWORD &PWA.FSV_CAPS-&PWA.FSV_KEYWORDS,'CAPITALIZE'
           KEYWORD &PWA.FSV_CAPS-&PWA.FSV_KEYWORDS,'CAPS'
           KEYWORD &PWA.FSV_C1ST-&PWA.FSV_KEYWORDS,'C1ST'
           KEYWORD &PWA.FSV_CENTER-&PWA.FSV_KEYWORDS,'CENTER'
           KEYWORD &PWA.FSV_FILL-&PWA.FSV_KEYWORDS,'FILL'
           KEYWORD &PWA.FSV_FILL-&PWA.FSV_KEYWORDS,'F'
           KEYWORD &PWA.FSV_CSV-&PWA.FSV_KEYWORDS,'CSV'
           KEYWORD &PWA.FSV_QST-&PWA.FSV_KEYWORDS,'QST'
           KEYWORD 0
           ENDSSD
           EJECT
**********************************************************************
*                                                                    *
* Subroutine : GETFMT_FILL_OPERANDS                                  *
* Abstract   : Scan from Current up to (but not including) End to    *
*              extract any operands to the FILL keyword in a         *
*              format-specification.  The syntax being parsed is     *
*              FILLÝ(string)¨  where                                 *
*                                                                    *
*                string => word                                      *
*                        | ?ÝLÝ1 | nn | ?¨¨ /* default length: 1 */  *
*                        | ÝC|X¨"string"    /* default type  : C */  *
*                word   => any character sequence that does not look *
*                          like anything else.                       *
*                                                                    *
*              Either single or double quotes may be used to delimit *
*              string, so long as they are matched properly.  If a   *
*              quote of the same type as the delimiter is used w/in  *
*              the string, two quotes must be used to represent one. *
*                                                                    *
*              The maximum length for a fill value from any source   *
*              is 256 bytes.  A zero-length filler is replaced by    *
*              the default fill string: " .".                        *
*                                                                    *
**********************************************************************
 BLOCK NAME=GETFMT_FILL_OPERANDS,TYPE=SUBROUTINE
   L      R8,&PWA.FS_CURRENT             | R8->Current position.
   LEAVE  BLOCK=*,(C,R8,GT,&PWA.FS_END)  | Leave if past end.
   LEAVE  BLOCK=*,(CLI,0(R8),NE,C'(')    | Leave if no operands.
*                                        |
   LA   R8,1(,R8)                        | R8 -> Past opening paren.
   LA   R7,0(,R8)                        | Use R7 to find non-blank.
   LOOP WHILE,(C,R7,LE,&PWA.FS_END)      | Scan for a non-blank.
     LEAVE LOOP=*,(CLI,0(R7),NE,C' ')    |   Leave if one found.
     LA    R7,1(,R7)                     |   Advance to next char.
   ENDLOOP WHILE                         | EndLoop.
   LA   R6,1(,R7)                        | Use R6 to find end-of-fill.
   LOOP WHILE,(C,R6,LE,&PWA.FS_END)      | Scan for a closing paren.
     LEAVE LOOP=*,(CLI,0(R6),EQ,C')')    |   Leave if one found.
     LA    R6,1(,R6)                     |   Advance to next char.
   ENDLOOP WHILE                         | EndLoop.
   ERREXIT (C,R6,GT,&PWA.FS_END),CODE=&ST_FORMAT_SPEC_NOT_ENDED
*                                        |
   BLOCK NAME=FILL_QUOTE,TYPE=INLINE     | Begin quoted-string checks.
     LR  R5,R7                           |   r5 -> 1st nonblank.
     IF  (CLI,0(R5),EQ,C'C')             |   If character = "C"
       LA    R5,1(,R5)                   |     Advance 1 position.
     ENDIF                               |   EndIf.
     LEAVE BLOCK=*,(CR,R5,GE,R6)         |   Leave if not quoted-string
     LEAVE BLOCK=*,(CLI,0(R5),NE,C''''),AND,(CLI,0(R5),NE,C'"')
     LA    R4,1(,R5)                     |   R4 -> 1st char past quote
     LA    R3,&PWA.FSV_FILL_VALUE        |   R3 -> Current value posn.
     LA    R2,L'&PWA.FSV_FILL_VALUE-1(R3)    R2 -> Value Limit.
     LOOP  UNTIL                         |   Loop over quoted string.
       LEAVE BLOCK=*,(CR,R4,GE,R6)       |     Leave if not ended.
       IF (CLC,0(1,R4),EQ,0(R5))         |     If char = opening-quote
         LA    R4,1(,R4)                 |       R4 -> Next char.
         LEAVE LOOP=*,(CR,R4,GE,R6),OR,(CLC,0(1,R4),NE,0(R5))
       ENDIF                             |     EndIf
       ERREXIT (CR,R3,GT,R2),CODE=&ST_FORMAT_FILL_TOO_LONG
       MVC   0(1,R3),0(R4)               |     Copy one character.
       LA    R3,1(,R3)                   |     R3 -> Next value posn.
       LA    R4,1(,R4)                   |     R4 -> Next source char.
     ENDLOOP UNTIL,LEAVE                 |   EndLoop
     LOOP WHILE,(CR,R4,LT,R6)            |   Loop over remaining stuff.
       LEAVE BLOCK=*,(CLI,0(R4),NE,C' ') |     Must be all blanks.
     ENDLOOP WHILE                       |   EndIf.
     LA    R0,&PWA.FSV_FILL_VALUE        |   R0 -> Start of fill value
     SLR   R3,R0                         |   R3 := Fill value length.
     LEAVE BLOCK=*,(TREG,R3,NP)          |   Leave if null-string.
     ST    R3,&PWA.FSV_FILL_LENGTH       |   Save in the PWA.
     LA    R8,1(,R6)                     |   R8 -> past closing ")".
     ST    R8,&PWA.FS_CURRENT            |   Save current position.
     LEAVE BLOCK=GETFMT_FILL_OPERANDS    |   Return to caller.
   ENDBLK BLOCK=FILL_QUOTE               | End quoted-string checks.
*                                        |
   BLOCK NAME=FILL_HEX,TYPE=INLINE       | Begin hex-string checks.
     LEAVE BLOCK=*,(CLI,0(R7),NE,C'X')   |   Leave if not "X".
     LA    R5,1(,R7)                     |   r5 -> char after "X".
     LEAVE BLOCK=*,(CR,R5,GE,R6)         |   Leave if nothing else.
     LEAVE BLOCK=*,(CLI,0(R5),NE,C''''),AND,(CLI,0(R5),NE,C'"')
     LA    R4,1(,R5)                     |   R4 -> 1st char past quote
     LA    R3,&PWA.FSV_FILL_VALUE        |   R3 -> Current value posn.
     LA    R2,L'&PWA.FSV_FILL_VALUE-1(R3)    R2 -> Value Limit.
     LOOP  UNTIL                         |   Loop over hex-string.
       LEAVE   BLOCK=*,(CR,R4,GE,R6)     |     Leave if not ended.
       LEAVE   LOOP=*,(CLC,0(1,R4),EQ,0(R5))   Leave on end-quote.
       ERREXIT (CR,R3,GE,R2),CODE=&ST_FORMAT_FILL_TOO_LONG
       MVC     &W.CHAR+0(1),0(R4)        |     Copy 1st of hex-pair.
       LA      R4,1(,R4)                 |     Advance to next.
       LEAVE   BLOCK=*,(CR,R4,GE,R6)     |     Leave if no 2nd-half.
       LEAVE   BLOCK=*,(CLC,0(1,R4),EQ,0(R5))  Leave if no 2nd-half.
       MVC     &W.CHAR+1(1),0(R4)        |     Copy 2nd of hex-pair.
       LA      R4,1(,R4)                 |     Advance to next.
       TR      &W.CHAR,&PSD.HEX_TAB      |     Translate for convert.
       LEAVE   BLOCK=*,(CLI,&W.CHAR+0,EQ,X'00') Leave if bad hex-char.
       LEAVE   BLOCK=*,(CLI,&W.CHAR+1,EQ,X'00') Leave if bad hex-char.
       PACK    &W.HEX,&W.CHAR_PLUS       |      Pack w/garbage byte.
       MVC     0(1,R3),&W.HEX            |     Copy one character.
       LA      R3,1(,R3)                 |     R3 -> Next value posn.
     ENDLOOP UNTIL,LEAVE                 |   EndLoop
     LA   R4,1(,R4)                      |   R4 -> past end-quote.
     LOOP WHILE,(CR,R4,LT,R6)            |   Loop over remaining stuff.
       LEAVE BLOCK=*,(CLI,0(R4),NE,C' ') |     Must be all blanks.
     ENDLOOP WHILE                       |   EndIf.
     LA    R0,&PWA.FSV_FILL_VALUE        |   R0 -> Start of fill value
     SLR   R3,R0                         |   R3 := Fill value length.
     LEAVE BLOCK=*,(TREG,R3,NP)          |   Leave if null-string.
     ST    R3,&PWA.FSV_FILL_LENGTH       |   Save in the PWA.
     LA    R8,1(,R6)                     |   R8 -> past closing ")".
     ST    R8,&PWA.FS_CURRENT            |   Save current position.
     LEAVE BLOCK=GETFMT_FILL_OPERANDS    |   Return to caller.
   ENDBLK BLOCK=FILL_HEX                 | End hex-string checks.
*                                        |
   BLOCK NAME=FILL_REF,TYPE=INLINE       | Begin reference (?) checks.
     LEAVE BLOCK=*,(CLI,0(R7),NE,C'?')   |   Leave if not "?".
     LA    R5,1(,R7)                     |   R5 -> next char.
     LM    R3,R4,&PWA.ARGUMENT_LIST      |   R3:=count, R4->A(<arg>).
     IF    (TREG,R3,NP),OR,(CLC,=A(0),EQ,0(R4))  If no argument.
       ERREXIT CODE=&ST_FORMAT_MISSING_ARGUMENT  Exit with error code.
     ENDIF                               |   EndIf.
     L     R2,0(R4)                      |   R2 -> Fill string.
     LA    R4,4(,R4)                     |   R4 -> Next argument.
     BCTR  R3,0                          |   Subtract 1 from count.
     STM   R3,R4,&PWA.ARGUMENT_LIST      |   Update current args.
     MVC   &PWA.FSV_FILL_LENGTH,=F'1'    |   Default length = 1.
     IF    (CR,R5,LT,R6),AND,(CLI,0(R5),EQ,C'L')
       LA  R5,1(,R5)                     |     Advance past "L".
       IF  (CR,R5,LT,R6)                 |     If more stuff, then.
         ST      R5,&PWA.FS_CURRENT      |       Update current posn.
         CALLSUB GETFMT_INTEGER,(&PWA.FSV_FILL_LENGTH)
         L       R5,&PWA.FS_CURRENT      |       R5 -> past length.
       ENDIF                             |     EndIf.
     ENDIF                               |   EndIf.
     LOOP WHILE,(CR,R5,LT,R6)            |   Loop over remaining stuff.
       LEAVE LOOP=*,(CLI,0(R5),NE,C' ')  |     Must be all blanks.
     ENDLOOP WHILE                       |   EndIf.
     L     R1,&PWA.FSV_FILL_LENGTH       |   R1 := filler length.
     ERREXIT (C,R1,GT,=A(L'&PWA.FSV_FILL_VALUE)),                      +
               CODE=&ST_FORMAT_FILL_TOO_LONG
     IF    (TREG,R1,NP),OR,(CR,R5,NE,R6) |   If null-string or badchars
       SL  R4,=F'4'                      |     Restore argument_list
       LA  R3,1(,R3)                     |     to the values it had
       STM R3,R4,&PWA.ARGUMENT_LIST      |     before this block.
       LEAVE BLOCK=*                     |     Don't use as ? filler.
     ENDIF                               |   EndIf.
     BCTR  R1,0                          |   Subtract 1 for EXI.
     EXI   R1,(MVC,&PWA.FSV_FILL_VALUE(0),0(R2))  Copy filler.
     LA    R8,1(,R6)                     |   R8 -> past closing ")".
     ST    R8,&PWA.FS_CURRENT            |   Update current posn.
     LEAVE BLOCK=GETFMT_FILL_OPERANDS    |   Return to caller.
   ENDBLK BLOCK=FILL_REF                 | End reference (?) checks.
*                                        |
   LA      R5,1(,R6)                     | R5 -> past closing ")".
   ST      R5,&PWA.FS_CURRENT            | Update current position.
   SR      R6,R8                         | R6 := Length w/in (...).
   ERREXIT (C,R6,GT,=A(L'&PWA.FSV_FILL_VALUE)),                        +
               CODE=&ST_FORMAT_FILL_TOO_LONG
   ST      R6,&PWA.FSV_FILL_LENGTH       | Save Length of filler.
   IF      (TREG,R6,P)                   | If positive.
     BCTR  R6,0                          |    Subtract 1 for EXI.
     EXI   R6,(MVC,&PWA.FSV_FILL_VALUE(0),0(R8))  Copy fill string.
   ENDIF                                 | EndIf.
 ENDBLK BLOCK=GETFMT_FILL_OPERANDS
              SWA
&W.CHAR_PLUS  DS 0CL3
&W.CHAR       DS  CL2                   | Source chars being converted
              DS  CL1                   | Garbage for PACK to eat.
&W.HEX        DS  XL2                   | 1st-byte = hex-equivalent.
              ENDSWA
              EJECT
**********************************************************************
*                                                                    *
* Subroutine : GETFMT_INTEGER(Value)                                 *
* Abstract   : Scan from Current up to (but not including) End to    *
*              extract a format-specification's integer value.  The  *
*              value must be a '?' or a sequence of digits.  Value   *
*              will be set to the integer value specified, or if a   *
*              '?' was provided, the current argument's value (which *
*              must be a <sizelength> signed binary integer).        *
*                                                                    *
**********************************************************************
 BLOCK NAME=GETFMT_INTEGER,TYPE=SUBROUTINE
   L       R9,0(R1)                      | R9 -> Return value.
   L       R8,&PWA.FS_CURRENT            | R8 -> Current character.
   IF      (C,R8,GT,&PWA.FS_END)         | If past end, then
     LA    R15,4                         |   Indicate no value.
     LEAVE BLOCK=*                       |   Return to caller.
   ENDIF                                 | EndIf.
*                                        |
   L8 R3,0(R8)                           | R3 := actual character.
   LA R3,CLASSIFICATION(R3)              | R3 -> character's class.
   IF (CLI,0(R3),EQ,C'D')                | If string of <digits>.
     LR    R3,R8                         |   Use R3 to scan ahead.
     LOOP  WHILE,(C,R3,LE,&PWA.FS_END)   |   Loop over digit-sequence.
       L8    R2,0(R3)                    |     R2 := actual character.
       LA    R2,CLASSIFICATION(R2)       |     R2 -> character's class.
       LEAVE LOOP=*,(CLI,0(R2),NE,C'D')  |     Leave on non-<digit>.
       LA    R3,1(,R3)                   |     Advance to next char.
     ENDLOOP WHILE                       |   EndLoop.
     SLR     R3,R8                       |   R3 := length of <digits>.
     ERREXIT (C,R3,GT,=F'16'),CODE=&ST_MAGNITUDE
     BCTR    R3,0                        |   Subtract 1 for EX instr.
     EXI     R3,(PACK,GSI_DECIMAL,0(0,R8))   Convert to packed-decimal.
     ERREXIT (CP,GSI_DECIMAL,GT,=P'2147483648'),  If too large for a   +
               CODE=&ST_MAGNITUDE        |          fullword, error.
     LA      R8,1(R3,R8)                 |   Advance past <digits>.
     ST      R8,&PWA.FS_CURRENT          |   Update current position.
     CVB     R3,GSI_DECIMAL              |   Convert to binary.
     STCM    R3,B'1111',0(R9)            |   Save value.
     LA      R15,0                       |   Successful return-code.
   ELSEIF (CLI,0(R8),EQ,C'?')            | ElseIf a referenced value.
     LA R8,1(,R8)                        |   Advance to next char.
     ST R8,&PWA.FS_CURRENT               |   Update current position.
*                                        |   ...look for <digits>
     L8 R3,0(R8)                         |   R3 := actual character.
     LA R3,CLASSIFICATION(R3)            |   R3 -> character's class.
     IF (CLI,0(R3),NE,C'D')              |   If not a <digit>.
       MVC  &W.SIZEMASK,&PWA.SIZEMASK    |     Use global SIZELENGTH
       MVC  &W.SIZELENGTH,&PWA.SIZELENGTH      to obtain length value.
     ELSE                                |   Else, a string of <digits>
       LR    R3,R8                       |     Use R3 to scan ahead.
       LOOP  WHILE,(C,R3,LE,&PWA.FS_END) |     Loop over digits.
         L8    R2,0(R3)                  |       R2 := actual char.
         LA    R2,CLASSIFICATION(R2)     |       R2 -> char's class
         LEAVE LOOP=*,(CLI,0(R2),NE,C'D')        Leave on non-<digit>.
         LA    R3,1(,R3)                 |       Advance to next char.
       ENDLOOP WHILE                     |     EndLoop.
       SLR     R3,R8                     |     R3 := length, <digits>.
       ERREXIT (C,R3,GT,=F'16'),CODE=&ST_INVALID_SIZELENGTH
       BCTR    R3,0                      |     Subtract 1 for EX instr.
       EXI     R3,(PACK,GSI_DECIMAL,0(0,R8))   Convert, packed-decimal
       ERREXIT (CP,GSI_DECIMAL,GT,=P'2147483648'),  If too large for a +
               CODE=&ST_INVALID_SIZELENGTH          fullword, error.
       LA      R8,1(R3,R8)               |     Advance past <digits>.
       ST      R8,&PWA.FS_CURRENT        |     Update current position.
       CVB     R3,GSI_DECIMAL            |     Convert to binary.
       ERREXIT ((C,R3,LT,=F'1'),OR,(C,R3,GT,=F'4')),                   +
               CODE=&ST_INVALID_SIZELENGTH
       ST      R3,&W.SIZELENGTH          |     R3 = SIZELENGTH override
       S       R3,=F'1'                  |     R3 := offset, bit-mask.
       LA      R3,&PSD.BIT_MASK(R3)      |     R3 -> bit-mask to use.
       L8      R0,0(R3)                  |     R0 := bit-mask.
       ST      R0,&W.SIZEMASK            |     Save for getting length.
     ENDIF                               |   EndIf.
*                                        |
     LM R6,R7,&PWA.ARGUMENT_LIST         |   R6:=count, R7->A(<arg>).
     IF (TREG,R6,NP),OR,(TREG,R7,Z)      |   If no more <arguments>.
       ERREXIT CODE=&ST_FORMAT_MISSING_ARGUMENT  Exit with error code.
     ENDIF                               |   EndIf.
     L     R2,0(,R7)                     |   R2 -> <argument>'s value.
     LA    R7,4(,R7)                     |   Point to next <argument>.
     BCTR  R6,0                          |   Subtract 1 from count.
     STM   R6,R7,&PWA.ARGUMENT_LIST      |   Update current arg.
     XR    R3,R3                         |   Use R3 to load integer.
     L     R15,&W.SIZEMASK               |   R15 := length-mask.
     EXI   R15,(ICM,R3,0,0(R2))          |   R3  := <argument> value.
     L     R15,&W.SIZELENGTH             |   R15 := #bytes in R3.
     SLL   R15,3                         |   R15 := #bits in R3.
     LCR   R15,R15                       |   R15 := #bits ....
     A     R15,=F'32'                    |       .... to sign-extend.
     SLL   R3,0(R15)                     |   Shift value to sign-bit.
     SRA   R3,0(R15)                     |   Shift back, keeping sign.
     STCM  R3,B'1111',0(R9)              |   Save sign-extended value.
     LA    R15,0                         |   Successful return-code.
   ELSE                                  | Else.
     LA    R15,4                         |   Indicate no value.
   ENDIF                                 | EndIf.
 ENDBLK BLOCK=GETFMT_INTEGER
                SWA
GSI_DECIMAL     DS   D         | Packed-decimal value.
&W.SIZELENGTH   DS   F         | Size of string length-specifiers.
&W.SIZEMASK     DS   F         | Mask for <sizelength> values.
                ENDSWA
             EJECT
**********************************************************************
*                                                                    *
* Subroutine: ADJUST_COLUMN_POSITION                                 *
* Abstract:   Implement the @column portion of format-specifications *
*                                                                    *
**********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=ADJUST_COLUMN_POSITION
   LEAVE BLOCK=*,(TBIT,&PWA.FS_FIELDS,&PWA.FSF_COLUMN,OFF)
*                                        |
   IF (CLI,&PWA.FSV_COLUMN,EQ,C'@')      | If Highwater column wanted.
     MVC &PWA.STRING_CURRENT,&PWA.STRING_HIGHWATER
     LEAVE BLOCK=*                       |   Return to caller.
   ENDIF                                 | EndIf.
*                                        |
   IF (CLI,&PWA.FSV_COLUMN,EQ,C'=')      | If absolute column#.
     L32 R9,&PWA.FSV_COLUMN+1            |   R9 := Column# specified.
   ELSE                                  | Else, +/- relative column#.
     L32  R8,&PWA.FSV_COLUMN+1           |   R8 := Column# specified.
     L    R9,&PWA.STRING_CURRENT         |   R9 := current position.
     SL   R9,&PWA.STRING_START           |   R9 := current offset.
     LA   R9,1(,R9)                      |   R9 := current column#.
     IF   (CLI,&PWA.FSV_COLUMN,EQ,C'+')  |   If +relative column.
       AR   R9,R8                        |     Add to current column#.
     ELSEIF (CLI,&PWA.FSV_COLUMN,EQ,C'-')    ElseIf -relative column#.
       SR   R9,R8                        |     Subtract from column#.
     ELSE                                |   Else.
       ERREXIT CODE=&ST_INTERNAL_ERROR   |     Internal error.
     ENDIF                               |   EndIf.
   ENDIF                                 | EndIf.
*                                        |
   ERREXIT (TREG,R9,NP),CODE=&ST_FORMAT_COLUMN_TOO_SMALL
   BCTR    R9,0                          | Change to an offset.
   AL      R9,&PWA.STRING_START          | Add to start-address.
   ERREXIT (C,R9,GT,&PWA.STRING_END),CODE=&ST_FORMAT_COLUMN_TOO_LARGE
   ST    R9,&PWA.STRING_CURRENT          | Save as new column.
   IF    (C,R9,GT,&PWA.STRING_HIGHWATER) | If a new high-water mark.
     ST  R9,&PWA.STRING_HIGHWATER        |   Update Highwater mark.
   ENDIF                                 | EndIf.
 ENDBLK BLOCK=ADJUST_COLUMN_POSITION
             EJECT
**********************************************************************
*                                                                    *
* FORMAT_ADDRESS: Format the next argument as an address.            *
*                                                                    *
**********************************************************************
 BLOCK NAME=FORMAT_ADDRESS,TYPE=SUBROUTINE
   L32  R2,&PWA.FSV_SOURCE    | R2 -> Source data to format.
   L32  R3,&PWA.FSV_LENGTH    | R3 -> Length of source data.
*---------------------------------------------------------------------*
*  Convert entire address to an eight-byte text string w/leading zeros.
*---------------------------------------------------------------------*
   IF  (TREG,R3,NZ),THEN      | If any data to convert, then
     BCTR R3,0                |   Subtract 1 for EX instr.
     EXI  R3,(MVC,&PWA.WORK0,0(R2))
     LA   R3,1(,R3)           |   Use a garbage sign-byte.
     EXI  R3,(UNPK,DECIMAL9,&PWA.WORK0)
     TR   DECIMAL,HEXCHARS    |   Convert ABCDEF to printables.
   ELSE                       | Else
     MVC  DECIMAL,=8X'F0'     |   Pretend all zeros were converted.
   ENDIF                      | EndIf
*---------------------------------------------------------------------*
*  Set up R2 and R3 for addr/length of formatted address.  Point to
*  1st non-zero byte or the last byte if all zeros.
*---------------------------------------------------------------------*
   SLL  R3,1                  | R3 := length of formatted address.
   LA   R2,DECIMAL+L'DECIMAL  |
   SR   R2,R3                 | R2 -> 1st byte of formatted address.
   IF   (CLI,&PWA.FSV_LEADING_PAD,NE,C'0')
     S    R3,=F'1'            |
     XR   R14,R14             | R2 -> 1st non-zero digit or last
     ICM  R15,15,=X'F0000000' |       digit in number if all zeros.
     CLCL R2,R14              | R3 := length of whatever remains
     LA   R3,1(,R3)           |       from R2 to the end of number.
   ENDIF                      |
*---------------------------------------------------------------------*
*  Pad to the left with blanks/zeros if right-justified and then copy
*  the formatted address to the target area.
*---------------------------------------------------------------------*
   CALLSUB PAD_LEFT,((R3)),NOVL
   CALLSUB COPY_TO_STRING,((R2),(R3)),NOVL
   CALLSUB PAD_RIGHT,((R3)),NOVL
 ENDBLK BLOCK=FORMAT_ADDRESS
 EJECT
**********************************************************************
*                                                                    *
* FORMAT_BINARY: Format a bit-string.                                *
*                                                                    *
**********************************************************************
 BLOCK NAME=FORMAT_BINARY,TYPE=SUBROUTINE
   L32  R2,&PWA.FSV_SOURCE       | R2 -> Source data to format.
   L32  R3,&PWA.FSV_LENGTH       | R3 := Length of source data.
*---------------------------------------------------------------------*
*  Determine the formatted data's length and insert pad characters
*  if neccessary to get the correct justification.
*---------------------------------------------------------------------*
   LR      R4,R3                 | R4 := source bit-string length.
   SLL     R4,3                  | R4 := length of formatted result.
   CALLSUB PAD_LEFT,((R4)),NOVL  | Insert leading pad characters.
*---------------------------------------------------------------------*
*  Loop over the source data, formatting/moving a byte at a time.
*---------------------------------------------------------------------*
   LOOP BCT                   | Loop over the source data.
     ICM   R14,1,0(R2)        |   R11 := byte to format.
     LA    R1,8               |   R1  := number of bits.
     LOOP  BCT                |   Loop over bits in byte.
       SRDL R14,1             |     Shift next bit into R15.
       SRL  R15,31            |     Shift to low bit.
       O    R15,=C'...0'      |     Create a character 0 or 1.
       STC  R15,&PWA.WORK8-1(R1)    Save the new character.
     ENDLOOP BCT,R1           |   EndLoop.
     CALLSUB COPY_TO_STRING,(&PWA.WORK8,L'&PWA.WORK8),NOVL
     LA      R2,1(,R2)        |   Point to next byte to format.
   ENDLOOP BCT,R3             | EndLoop.
*---------------------------------------------------------------------*
*  Pad with trailing spaces if necessary.
*---------------------------------------------------------------------*
   CALLSUB PAD_RIGHT,((R4)),NOVL | Pad with trailing spaces.
 ENDBLK BLOCK=FORMAT_BINARY
 EJECT
**********************************************************************
*                                                                    *
* FORMAT_CHARACTER: Move a character string into the target string.  *
*                                                                    *
**********************************************************************
 BLOCK NAME=FORMAT_CHARACTER,TYPE=SUBROUTINE
   L32  R2,&PWA.FSV_SOURCE    | R2 -> Source data to format.
   L32  R3,&PWA.FSV_LENGTH    | R3 := Length of source data.
*---------------------------------------------------------------------*
*  If a precision was specified, set the source length to the minimum
*  of the actual source-length and the precision.
*---------------------------------------------------------------------*
   IF (TBIT,&PWA.FS_FIELDS,&PWA.FSF_PRECISION) If .precision specified.
     IF  (C,R3,GT,&PWA.FSV_PRECISION)     |   If sourcelen > precision.
       L  R3,&PWA.FSV_PRECISION           |    Use specified precision.
     ENDIF                                |   EndIf.
   ENDIF                                  | EndIf.
*---------------------------------------------------------------------*
*  If the trim function was requested, adjust the length of the source
*  string to leave off trailing blanks.  The length may go to zero
*  when doing this.
*---------------------------------------------------------------------*
   IF (CLI,&PWA.FSV_TRIM,EQ,C'Y')             | If TRIM specified.
     IF (TREG,R3,P)                           |   If anything to trim.
       LA   R15,0(R3,R2)                      |     R15 -> past end.
       LOOP BCT                               |   Scan backwards.
         BCTR  R15,0                          |     Back up 1 char.
         LEAVE LOOP=*,(CLI,0(R15),NE,C' ')    |     Leave on nonblank.
       ENDLOOP BCT,R3                         |   EndLoop.
     ENDIF                                    | EndIf.
   ENDIF                                      | EndIf.
*---------------------------------------------------------------------*
* If QST was specified, quote the text as we copy.
*---------------------------------------------------------------------*
   IF (CLI,&PWA.FSV_QST,EQ,C'Y')        | If QST specified.
    MVC  &W.OUTADDR,&PWA.STRING_CURRENT |  Save start position.
    L    R8,&PWA.STRING_CURRENT         |  R8 -> current target pos.
    L    R9,&PWA.STRING_END             |  R9 -> last target byte.
    IF (CR,R8,LE,R9)                    |  If room.
     MVI 0(R8),C''''                    |   Add opening quote to
     LA  R8,1(,R8)                      |   target.
    ENDIF                               |  EndIf.
    LOOP WHILE,(TREG,R3,P),AND,(CR,R8,LE,R9)  While source & room.
     MVC  0(1,R8),0(R2)                 |      Copy source to target.
     LA   R8,1(,R8)                     |      Bump target position.
     IF   (CLI,0(R2),EQ,C''''),AND,(CR,R8,LE,R9)  If quote & room.
      MVI  0(R8),C''''                  |          Add quote to target.
      LA   R8,1(,R8)                    |          Bump target position
     ENDIF                              |         EndIf.
     LA   R2,1(,R2)                     |      Bump source position.
     BCTR R3,0                          |      One less source char.
    ENDLOOP WHILE                       |     EndLoop
    IF (TREG,R3,P),OR,(CR,R8,GE,R9)     |  If no room.
     ERREXIT CC4,CODE=&ST_TRUNCATED.    |   We're done.
    ENDIF                               |  EndIf.
    MVI 0(R8),C''''                     |  Add closing quote.
    LA  R8,1(,R8)                       |  Bump target position.
    ST  R8,&PWA.STRING_CURRENT          |  Update current position.
    IF (C,R8,GT,&PWA.STRING_HIGHWATER)  |  If a new high-water mark.
     ST R8,&PWA.STRING_HIGHWATER        |   Update Highwater mark.
    ENDIF                               |  EndIf.
    S   R8,&W.OUTADDR                   |  R8 := formatted length.
    ST  R8,&W.OUTLEN                    |
*---------------------------------------------------------------------*
*   Otherwise, copy string directly.
*---------------------------------------------------------------------*
   ELSE
    CALLSUB PAD_LEFT,((R3)),NOVL
    MVC     &W.OUTADDR,&PWA.STRING_CURRENT
    ST      R3,&W.OUTLEN
    CALLSUB COPY_TO_STRING,((R2),0(R3)),NOVL
    CALLSUB PAD_RIGHT,((R3)),NOVL
   ENDIF                                      | EndIf.
*---------------------------------------------------------------------*
*  Capitalize the new copy of the character string if requested.
*---------------------------------------------------------------------*
   L  R8,&W.OUTADDR
   L  R3,&W.OUTLEN
   IF (CLI,&PWA.FSV_CAPS,EQ,C'Y')   | If CAPS specified.
     LOOP  WHILE,(C,R3,GT,=F'256')  |   Loop over large chunks.
       TR  0(256,R8),FOLD           |     Fold segment to caps.
       LA  R8,256(,R8)              |     Advance to next segment.
       S   R3,=F'256'               |     Adjust remaining len.
     ENDLOOP WHILE                  |   EndLoop.
     IF (TREG,R3,P)                 |   If anything left.
       BCTR R3,0                    |     Subtract 1 for EX instr.
       EXI  R3,(TR,0(0,R8),FOLD)    |     Fold segment to caps.
     ENDIF                          |   EndIf.
   ELSEIF (CLI,&PWA.FSV_C1ST,EQ,C'Y') ElseIf cap 1st letter
     TR 0(1,R8),FOLD                |   Capitalize 1st letter of fld.
   ENDIF                            | EndIf.
 ENDBLK BLOCK=FORMAT_CHARACTER
           SWA
&W.OUTLEN  DS   F
&W.OUTADDR DS   A
           ENDSWA
 EJECT
**********************************************************************
*                                                                    *
* FORMAT_SIGNED_INTEGER: Format 1,2,3,4 byte signed binary integer.  *
*                                                                    *
**********************************************************************
 BLOCK NAME=FORMAT_SIGNED_INTEGER,TYPE=SUBROUTINE
   L32  R2,&PWA.FSV_SOURCE    | R2 -> Source data to format.
   L32  R3,&PWA.FSV_LENGTH    | R3 := Length of source data.
*---------------------------------------------------------------------*
*  Get the integer, sign extended, into a register and convert to
*  decimal. Then convert it to printable characters -- inserting a
*  sign if needed.
*---------------------------------------------------------------------*
   IF (TREG,R3,P),THEN        | If any data to convert, then
     BCTR R3,0                |    Subtract 1 for EX instr.
     XC   &PWA.WORK4,&PWA.WORK4 |  Clear out holding area.
     EXI  R3,(MVC,&PWA.WORK0,0(R2)) Copy number over.
     L    R5,&PWA.WORK4       |    Load number into R5.
     LA   R3,1(,R3)           |    Add 1 back to length.
     SLL  R3,3                |    Convert to number-of-bits.
     LCR  R3,R3               |    Change to a negative number to
     A    R3,=F'32'           |    subtract from total number of bits.
     SRA  R5,0(R3)            |    Sign-extend to a fullword integer.
     CVD  R5,DECIMAL          |    Convert the integer to decimal.
     UNPK &PWA.WORK16,DECIMAL |    Convert decimal to printable.
   ELSE                       | Else
     FILL &PWA.WORK16,X'F0'   |   Pretend all zeros were converted.
   ENDIF                      | EndIf
*---------------------------------------------------------------------*
*  Set up R2 and R3 for addr/length of formatted integer.  Point to
*  1st non-zero byte or the last byte if all zeros.  Don't worry about
*  leading-zeros ... they will be taken care of by pad_left.
*---------------------------------------------------------------------*
   LA   R3,L'&PWA.WORK16      | R3 := length of formatted integer.
   LA   R2,&PWA.WORK          | R2 -> 1st byte of formatted integer.
   S    R3,=F'1'              |
   XR   R14,R14               | R2 -> 1st non-zero digit or last
   ICM  R15,15,=X'F0000000'   |       digit in number if all zeros.
   CLCL R2,R14                | R3 := length of whatever remains
   LA   R3,1(,R3)             |       from R2 to the end of number.
*---------------------------------------------------------------------*
*  If the number is negative, insert a minus sign in front of it.  The
*  number cannot possibly be as long as 16 bytes in length, so it is
*  safe to assume that there will be room in the formatted field of
*  DECIMAL16 to insert the minus sign.  Set the four-bit sign to a
*  hexadecimal 'F' so that the last digit will print.
*---------------------------------------------------------------------*
   L8  R1,DECIMAL+L'DECIMAL-1  | Pick up last digit of integer.
   N   R1,=F'15'               | Throw away all but sign.
   IF (CLM,R1,1,EQ,=X'0D')     | If negative, then
     S   R2,=F'1'              |   Retract start-of-number pointer.
     A   R3,=F'1'              |   Add 1 to total length of integer.
     MVI 0(R2),C'-'            |   Insert minus sign.
   ENDIF                       | EndIf.
   OI &PWA.WORK16+15,X'F0'     | Make last digit printable.
*---------------------------------------------------------------------*
*  If the integer is to be printed as a 'relative' number, then append
*  a -st, -nd, -rd, or -th suffix as appropriate.
*---------------------------------------------------------------------*
   IF (CLI,&PWA.FSV_RELATIVE,EQ,C'Y')  If relative numbers.
     A    R3,=F'2'             |   Add 2 to total length of integer.
     SLR  R4,R4                |   Clear out R4 for division.
     LPR  R5,R5                |   Force integer to be positive.
     D    R4,=F'10'            |   Divide by 10 to get remainder in R4.
     IF   (C,R4,EQ,=F'1')      |   If it ends w/a 1, then.
       MVC &PWA.SUFFIX,=C'st'  |     Use the -st suffix.
     ELSEIF (C,R4,EQ,=F'2')    |   Else if it ends w/a 2, then.
       MVC &PWA.SUFFIX,=C'nd'  |     Use the -nd suffix.
     ELSEIF (C,R4,EQ,=F'3')    |   Else if it ends w/a 3, then.
       MVC &PWA.SUFFIX,=C'rd'  |     Use the -rd suffix.
     ELSE                      |   Else
       MVC &PWA.SUFFIX,=C'th'  |     Use the -th suffix.
     ENDIF                     |
   ENDIF                       | EndIf.
*---------------------------------------------------------------------*
*  Pad to the left with blanks/zeros if right-justified and then copy
*  the formatted integer to the target area.
*---------------------------------------------------------------------*
   CALLSUB PAD_LEFT,((R3)),NOVL
   CALLSUB COPY_TO_STRING,((R2),(R3)),NOVL
   CALLSUB PAD_RIGHT,((R3)),NOVL
 ENDBLK BLOCK=FORMAT_SIGNED_INTEGER
 EJECT
**********************************************************************
*                                                                    *
* FORMAT_UNSIGNED_INTEGER: Format an unsigned binary integer.        *
*                                                                    *
**********************************************************************
 BLOCK NAME=FORMAT_UNSIGNED_INTEGER,TYPE=SUBROUTINE
   L32  R2,&PWA.FSV_SOURCE          | R2 -> Source data to format.
   L32  R3,&PWA.FSV_LENGTH          | R3 := Length of source data.
*---------------------------------------------------------------------*
*  Get the integer into a register and convert to decimal.  Since the
*  CVD instruction converts from signed-binary to decimal, the result
*  may need to be adjusted to make it right.
*---------------------------------------------------------------------*
   XC   &PWA.WORK4,&PWA.WORK4       | Clear out holding area.
   LM   R4,R5,=D'0'                 | Clear out R4/R5 entirely.
   BCTR R3,0                        | R3 := offset into ICM mask table.
   LA   R3,&PSD.BIT_MASK(R3)        | R3 -> Bit mask to use.
   L8   R15,0(R3)                   | R15 := Bit mask to use.
   EXI  R15,(ICM,R5,0,0(R2))        | R5 := Number to convert.
   SLDL R4,1                        | Shift high-bit to R4.
   SRL  R5,1                        | Shift rest of number back.
   CVD  R5,DECIMAL                  | Convert the integer to decimal.
   IF   (TREG,R4,NZ)                | If high-order bit was on.
     AP DECIMAL,=P'2147483648'      |   Add X'80000000' back to number.
   ENDIF                            | EndIf.
   UNPK &PWA.WORK16,DECIMAL         | Convert decimal to printable.
*---------------------------------------------------------------------*
*  Set up R2 and R3 for addr/length of formatted integer.  Point to
*  1st non-zero byte or the last byte if all zeros.  Don't worry about
*  leading-zeros ... they will be taken care of by pad_left.
*---------------------------------------------------------------------*
   LA   R3,L'&PWA.WORK16      | R3 := length of formatted integer.
   LA   R2,&PWA.WORK          | R2 -> 1st byte of formatted integer.
   S    R3,=F'1'              |
   XR   R14,R14               | R2 -> 1st non-zero digit or last
   ICM  R15,15,=X'F0000000'   |       digit in number if all zeros.
   CLCL R2,R14                | R3 := length of whatever remains
   LA   R3,1(,R3)             |       from R2 to the end of number.
   OI   &PWA.WORK16+15,X'F0'  | Make last digit printable.
*---------------------------------------------------------------------*
*  If the integer is to be printed as a 'relative' number, then append
*  a -st, -nd, -rd, or -th suffix as appropriate.
*---------------------------------------------------------------------*
   IF (CLI,&PWA.FSV_RELATIVE,EQ,C'Y')  If relative numbers.
     A    R3,=F'2'             |   Add 2 to total length of integer.
     SLR  R4,R4                |   Clear out R4 for division.
     LPR  R5,R5                |   Force integer to be positive.
     D    R4,=F'10'            |   Divide by 10 to get remainder in R4.
     IF   (C,R4,EQ,=F'1')      |   If it ends w/a 1, then.
       MVC &PWA.SUFFIX,=C'st'  |     Use the -st suffix.
     ELSEIF (C,R4,EQ,=F'2')    |   Else if it ends w/a 2, then.
       MVC &PWA.SUFFIX,=C'nd'  |     Use the -nd suffix.
     ELSEIF (C,R4,EQ,=F'3')    |   Else if it ends w/a 3, then.
       MVC &PWA.SUFFIX,=C'rd'  |     Use the -rd suffix.
     ELSE                      |   Else
       MVC &PWA.SUFFIX,=C'th'  |     Use the -th suffix.
     ENDIF                     |
   ENDIF                       | EndIf.
*---------------------------------------------------------------------*
*  Pad to the left with blanks/zeros if right-justified and then copy
*  the formatted integer to the target area.
*---------------------------------------------------------------------*
   CALLSUB PAD_LEFT,((R3)),NOVL
   CALLSUB COPY_TO_STRING,((R2),(R3)),NOVL
   CALLSUB PAD_RIGHT,((R3)),NOVL
 ENDBLK BLOCK=FORMAT_UNSIGNED_INTEGER
 EJECT
**********************************************************************
*                                                                    *
* FORMAT_HEX_CHARACTER: Format a hexadecimal character string.       *
*                                                                    *
**********************************************************************
 BLOCK NAME=FORMAT_HEX_CHARACTER,TYPE=SUBROUTINE
   L32  R2,&PWA.FSV_SOURCE    | R2 -> Source data to format.
   L32  R3,&PWA.FSV_LENGTH    | R3 := Length of source data.
*---------------------------------------------------------------------*
*  Determine the formatted data's length and insert pad characters
*  if neccessary to get the correct justification.
*---------------------------------------------------------------------*
   LR      R4,R3                 | R4 := source bit-string length.
   SLL     R4,1                  | R4 := length of formatted result.
   CALLSUB PAD_LEFT,((R4)),NOVL  | Insert leading pad characters.
*---------------------------------------------------------------------*
*  Loop over the source data, formatting/moving a byte at a time.
*---------------------------------------------------------------------*
   LA   R5,2
   IF   (TREG,R3,NZ)             | If any hex data then.
     LOOP BCT                    |   Loop over the source data.
       MVC   &PWA.WORK1,0(R2)    |     Copy byte to be formatted.
       UNPK  DECIMAL9,&PWA.WORK2 |     Unpack, along with junk-byte.
       TR    DECIMAL,HEXCHARS    |     Convert ABCDEF to printables.
       CALLSUB COPY_TO_STRING,(DECIMAL+6,(R5)),NOVL
       LA    R2,1(,R2)           |     Point to next byte to format.
     ENDLOOP BCT,R3              |   EndLoop.
   ENDIF                         | EndIf.
   CALLSUB PAD_RIGHT,((R4)),NOVL | Add trailing spaces.
 ENDBLK BLOCK=FORMAT_HEX_CHARACTER
 EJECT
**********************************************************************
*                                                                    *
* Subroutine: PAD_LEFT(formatted-length)                             *
* Abstract: Insert the appropriate number of leading blanks/zeros    *
*           to cause right-justification or centering to work out.   *
*           The parameter is call-by-value.  R1 -> directly to the   *
*           formatted-length value.                                  *
*                                                                    *
**********************************************************************
 BLOCK NAME=PAD_LEFT,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  If right-justification or centering is enabled and if the target
*  field width is greater than the width of the formatted data, then
*  padding to the left is required.
*---------------------------------------------------------------------*
  IF (CLI,&PWA.FSV_CENTER,EQ,C'Y'),OR,(CLI,&PWA.FSV_RIGHT,EQ,C'Y')
     L     R8,&PWA.STRING_CURRENT  R8 -> current target position.
     L     R9,&PWA.STRING_END  |   R9 -> last target byte.
     SLR   R9,R8               |   R9 := length of target - 1.
     AL    R9,=F'1'            |   R9 := length of target area.
     IF (C,R9,GT,&PWA.FSV_WIDTH)   If enough room for data.
       L   R9,&PWA.FSV_WIDTH   |     Set length = specified width.
     ENDIF                     |   EndIf.
     L     R1,0(R1)            |   R1 := Length of formatted data.
     IF (CR,R9,GT,R1)          |   If one or more pad chars needed.
       SR R9,R1                |     R9 = number of pad characters.
       IF (CLI,&PWA.FSV_CENTER,EQ,C'Y') If centering text.
         LR  R15,R9            |
         XR  R14,R14           |       Divide pad-length by two.
         D   R14,=F'2'         |
         LR  R9,R15            |
       ENDIF                   |     EndIf.
       XR   R14,R14            |
       XR   R15,R15            |
       ICM  R15,8,&PWA.FSV_LEADING_PAD Get leading pad character.
       MVCL R8,R14             |
       ST   R8,&PWA.STRING_CURRENT   Update current target position.
       IF   (C,R8,GT,&PWA.STRING_HIGHWATER)  If a new high-water mark.
         ST R8,&PWA.STRING_HIGHWATER   Update Highwater mark.
       ENDIF                   |     EndIf.
     ENDIF                     |   EndIf.
   ENDIF                       | EndIf
 ENDBLK BLOCK=PAD_LEFT
 EJECT
**********************************************************************
*                                                                    *
* Subroutine: COPY_TO_STRING,(Text,*Length*)                         *
* Abstract:   Move formatted data described by addr/length parms     *
*             to the target string.  The length parameter is passed  *
*             by value -- that is, it is actually in the parameter   *
*             list itself instead of following normal conventions.   *
*                                                                    *
**********************************************************************
 BLOCK NAME=COPY_TO_STRING,TYPE=SUBROUTINE
   LM    R0,R1,0(R1)          | R0 -> text, R1 -> length of text.
*---------------------------------------------------------------------*
*  Copy the formatted data pointed to by R0 with length (R1).
*---------------------------------------------------------------------*
   L     R8,&PWA.STRING_CURRENT R8 -> current target position.
   L     R9,&PWA.STRING_END   | R9 -> last target byte.
   SLR   R9,R8                | R9 := length of target - 1.
   AL    R9,=F'1'             | R9 := length of target area.
   IF    (CR,R9,GT,R1)        | If enough room in target area.
     LR  R9,R1                |   R9 := length of data to move.
   ENDIF                      | EndIf.
   STM   R8,R9,MF_TARGET      | Save target area address, length.
   MVCL  R8,R0                | Copy the formatted bit-string.
   ST    R8,&PWA.STRING_CURRENT Update current target position.
   ERREXIT CC4,CODE=&ST_TRUNCATED.
   ERREXIT CC1,CODE=&ST_OVERLAP.
   IF (C,R8,GT,&PWA.STRING_HIGHWATER)  If a new high-water mark.
     ST R8,&PWA.STRING_HIGHWATER   Update Highwater mark.
   ENDIF                      | EndIf.
 ENDBLK BLOCK=COPY_TO_STRING
           SWA
MF_TARGET  DS      2F
           ENDSWA
 EJECT
**********************************************************************
*                                                                    *
* PAD_RIGHT: Add the appropriate number of trailing characters to    *
*            cause left-justification or centering to work out.      *
*            The parameter is call-by-value.  R1 -> directly to the  *
*            formatted-length value.                                 *
*                                                                    *
**********************************************************************
 BLOCK NAME=PAD_RIGHT,TYPE=SUBROUTINE
*---------------------------------------------------------------------*
*  If left-justification, centering, or filling is enabled and if the
*  target field width is greater than the width of the formatted data,
*  then padding to the RIGHT is required.
*---------------------------------------------------------------------*
   IF (CLI,&PWA.FSV_LEFT,EQ,C'Y'),OR,(CLI,&PWA.FSV_CENTER,EQ,C'Y'),OR, +
               (CLI,&PWA.FSV_FILL,EQ,C'Y')
     L   R8,&PWA.STRING_CURRENT       R8 -> current target position.
     L   R9,&PWA.STRING_END       |   R9 -> last target byte.
     SLR R9,R8                    |   R9 := length of target - 1.
     AL  R9,=F'1'                 |   R9 := length of target area.
     L   R15,&PWA.FSV_WIDTH       |   R15 := number of pad characters
     IF  (C,R15,GT,0(R1))         |   If one or more pad chars needed.
       S R15,0(R1)                |     R15 := number of pad chars.
       IF  (CLI,&PWA.FSV_CENTER,EQ,C'Y')  If centering.
         XR  R14,R14              |
         D   R14,=F'2'            |       Divide pad-length by 2 and
         AR  R15,R14              |       Add back the remainder.
       ENDIF                      |     EndIf.
       IF (CR,R15,LT,R9)          |     If pad-length < available room.
         LR   R9,R15              |       Use pad-length.
       ENDIF                      |     EndIf.
       LA   R1,0(R9,R8)           |     R1 -> past end of pad/fill area
       ST   R1,&PWA.STRING_CURRENT      Update current target position.
       IF   (C,R1,GT,&PWA.STRING_HIGHWATER)  If a new high-water mark.
         ST R1,&PWA.STRING_HIGHWATER      Update Highwater mark.
       ENDIF                      |     EndIf.
*---------------------------------------------------------------------*
*      Now perform actual padding or filling operation.
*---------------------------------------------------------------------*
       IF (CLI,&PWA.FSV_FILL,EQ,C'Y')   If fill-string.
         LA   R1,0(R8,R9)         |       R1 -> past end.
         SL   R1,&PWA.FSV_FILL_LENGTH     R1 -> MVC target.
         L    R2,&PWA.FSV_FILL_LENGTH     R2 := l'filler
         BCTR R2,0                |       Subtract 1 for EXIs
         LOOP WHILE,(CR,R1,GE,R8) |       Loop backwards.
           EXI R2,(MVC,0(0,R1),&PWA.FSV_FILL_VALUE)  Move 1 fill segmt
           SL  R1,&PWA.FSV_FILL_LENGTH               Back up 1 segmt.
         ENDLOOP WHILE            |       EndLoop.
         AL  R1,&PWA.FSV_FILL_LENGTH      Add back l'filler.
         IF  (CR,R1,NE,R8)        |       If not an exact fit.
           SR   R1,R8             |         R1 := remaining length.
           MVI  0(R8),C' '        |         Fill in remainder.
           IF   (C,R1,GT,=F'1')   |         If more than 1 char.
             BCTR R1,0            |          Subtract 1 for MVI above.
             BCTR R1,0            |          Subtract 1 for EXI.
             EXI  R1,(MVC,1(0,R8),0(R8))     Fill remaining area.
           ENDIF                  |         EndIf.
         ENDIF                    |       EndIf.
       ELSE                       |     Else.
         XR   R14,R14             |
         XR   R15,R15             |
         ICM  R15,8,=C' '         |       Get trailing pad character.
         MVCL R8,R14              |
       ENDIF                      |     EndIf.
     ENDIF                        |   EndIf.
   ENDIF                          | EndIf
 ENDBLK BLOCK=PAD_RIGHT
 TITLE 'String Server - Conversion routines.'
***********************************************************************
*                                                                     *
*  Subroutine: STRING_TO_INTEGER                                      *
*  Abstract:   Convert a string of digits, with optional leading      *
*              sign, to an integer fullword.                          *
*  Parameters: (Address, Length, Integer)                             *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=STRING_TO_INTEGER
   LM  R2,R4,0(R1)                    | R2/R3 -> String/Length.
   SLR R1,R1                          | Clear out for an ICM instr.
   L   R15,&PWA.SIZEMASK              | R15 := length-mask.
   EXI R15,(ICM,R1,0,0(R3))           | R1 := string-length.
   LR  R3,R1                          | R3 := string-length.
*---------------------------------------------------------------------*
*  If the first non-blank character is a sign, remember it.
*---------------------------------------------------------------------*
   LOOP WHILE,((C,R3,GT,=F'1'),AND,(CLI,0(R2),EQ,C' '))
     LA   R2,1(,R2)                   |   R2 -> past leading blank.
     BCTR R3,0                        |   Adjust remaining length.
   ENDLOOP WHILE                      | EndLoop while.
*                                     |
   LA R5,X'0C'                        | R5 := Zoned sign-nibble.
   IF (C,R3,GT,=F'1')                 | If non-null string.
     IF (CLI,0(R2),EQ,C'+')           |   If first character is '+'.
       LA   R2,1(,R2)                 |     R2 -> past leading '+'.
       BCTR R3,0                      |     Adjust remaining length.
     ELSEIF (CLI,0(R2),EQ,C'-')       |   ElseIf first char is '-'.
       LA   R2,1(,R2)                 |     R2 -> past leading '+'.
       BCTR R3,0                      |     Adjust remaining length.
       LA R5,X'0D'                    |     Switch to a minus sign.
     ENDIF                            |   EndIf.
   ENDIF                              | EndIf.
*---------------------------------------------------------------------*
*  Strip leading and trailing blanks from the remaining string.
*---------------------------------------------------------------------*
   LOOP WHILE,((C,R3,GT,=F'1'),AND,(CLI,0(R2),EQ,C' '))
     LA   R2,1(,R2)                   |   R2 -> past leading blank.
     BCTR R3,0                        |   Adjust remaining length.
   ENDLOOP WHILE                      | EndLoop while.
   LOOP WHILE,((C,R3,GT,=F'1'),AND,(CLI,0(R2),EQ,C'0'))
     LA   R2,1(,R2)                   |   R2 -> past leading zero.
     BCTR R3,0                        |   Adjust remaining length.
   ENDLOOP WHILE                      | EndLoop while.
*                                     |
   LA   R3,0(R3,R2)                   | R3 -> past end of string.
   LOOP UNTIL                         | Loop backwards.
     BCTR R3,0                        |   Back up by one character.
   ENDLOOP UNTIL,((CR,R3,LT,R2),OR,(CLI,0(R3),NE,C' '))
   LA      R3,1(,R3)                  | R3 -> past trimmed string.
   SLR     R3,R2                      | R3 := trimmed length.
*---------------------------------------------------------------------*
*  Check the adjusted source-string for validity.
*---------------------------------------------------------------------*
   IF (C,R3,LT,=F'1')                 | If nothing left, then.
     L     R15,=F'&ST_INVALID_SOURCE_FORMAT'
     LEAVE BLOCK=*                    |   Return with error-code.
   ENDIF                              | EndIf.
*                                     |
   LA   R14,0(R3,R2)                  | R14 -> past last character.
   LOOP WHILE,(CR,R14,GT,R2)          | Loop over digits.
     BCTR   R14,0                     |   Back up to previous char.
     L8     R1,0(R14)                 |   R1 := character.
     LA     R1,CLASSIFICATION(R1)     |   R1 := character's class.
     IF     (CLI,0(R1),NE,DIGIT)      |   If not a digit, then.
       L     R15,=F'&ST_INVALID_SOURCE_FORMAT'
       LEAVE BLOCK=*                  |     Return with error-code.
     ENDIF                            |   EndIf.
   ENDLOOP WHILE                      | EndLoop.
*                                     |
   IF (C,R3,GT,=F'16')                | If too many digits, then
     L     R15,=F'&ST_MAGNITUDE'      |   Magnitude too big to handle.
     LEAVE BLOCK=*                    |   Return with error-code.
   ENDIF                              | EndIf.
*                                     |
   BCTR R3,0                          | Subtract 1 for the EX instr.
*---------------------------------------------------------------------*
*  Pack the source text to a decimal number and check its size.
*---------------------------------------------------------------------*
   EXI  R3,(PACK,STI_DECIMAL,0(0,R2)) | Pack into decimal fmt.
   ICM  R0,1,STI_DECIMAL+7            | Pick up last digit of number.
   N    R0,=X'000000F0'               | Discard all but the digit.
   OR   R0,R5                         | Insert sign-nibble.
   STCM R0,1,STI_DECIMAL+7            | Put signed-digit back.
   IF (CP,STI_DECIMAL,GT,=P'2147483647'),OR,                           +
               (CP,STI_DECIMAL,LT,=P'-2147483648')
     L     R15,=F'&ST_MAGNITUDE'      |      Indicate magnitude error.
     LEAVE BLOCK=*
   ENDIF
*---------------------------------------------------------------------*
*  Attempt to convert the decimal number to binary.
*---------------------------------------------------------------------*
   CVB  R1,STI_DECIMAL                | Convert to binary.
   ST   R1,0(R4)                      | Save in return-parameter.
   LA   R15,0                         | Indicate successful conversion.
 ENDBLK BLOCK=STRING_TO_INTEGER
             SWA
STI_DECIMAL  DS   D                   |
             ENDSWA
             EJECT
***********************************************************************
*                                                                     *
*  Subroutine: INTEGER_TO_STRING(Integer,String,Length,ResultLen)     *
*  Abstract:   Convert a signed fullword binary integer to a string.  *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=INTEGER_TO_STRING
   IF (CLC,&PWA.#PARMS,NE,=F'6')      | If #parms ¬= 6, then.
     ERREXIT CODE=&ST_WRONG_NUMBER_OF_PARAMETERS
   ENDIF                              | EndIf.
*                                     |
   L    R1,PRM_ITS_INTEGER            | R1 -> INTEGER to convert.
   ICM  R1,B'1111',0(R1)              | R1 := INTEGER to convert.
   CVD  R1,DECIMAL                    | Convert INTEGER to decimal.
   UNPK &PWA.WORK16,DECIMAL           | Convert decimal to STRING.
   OI   &PWA.WORK16+15,X'F0'          | Make last digit printable.
*                                     |
   LA   R4,&PWA.WORK                  | R4 -> new STRING.
   LA   R5,L'&PWA.WORK16-1            | R5 := length(new STRING) - 1.
   XR   R14,R14                       | R14 -> Null string.
   ICM  R15,15,=X'F0000000'           | R15 := C'0'.
   CLCL R4,R14                        | Set R4/R5 := address/length of
   LA   R5,1(,R5)                     | string from 1st non-zero digit.
*                                     |
   L8 R6,DECIMAL+L'DECIMAL-1          | R6 := last digit of decimal.
   N  R6,=F'15'                       | Throw away all but sign.
   IF (CLM,R6,1,EQ,=X'0D')            | If INTEGER was negative, then
     S   R4,=F'1'                     |   Retract start-of-number.
     A   R5,=F'1'                     |   Add 1 to total length.
     MVI 0(R4),C'-'                   |   Insert minus sign.
   ENDIF                              | EndIf.
*                                     |
   L       R15,&PWA.SIZEMASK          | R15 := length-mask.
   L       R14,PRM_ITS_RESLEN         | R14 -> result-length parm.
   EXI     R15,(STCM,R5,0,0(R14))     | Save result-length.
*                                     |
   L       R2,PRM_ITS_STRING          | R2 -> STRING return area.
   L       R1,PRM_ITS_LENGTH          | R1 -> STRING return area len.
   SLR     R3,R3                      | Clear R3 for ICM below.
   EXI     R15,(ICM,R3,0,0(R1))       | R3 := length of return area.
   IF      (CR,R3,GT,R5)              | If larger than needed.
     LR    R3,R5                      |   Use exact length needed.
   ENDIF                              | EndIf.
   MVCL    R2,R4                      | Copy formatted text to STRING.
   ERREXIT CC4,CODE=&ST_TRUNCATED.    | Error if not enough room.
 ENDBLK BLOCK=INTEGER_TO_STRING
 EJECT
**********************************************************************
*                                                                    *
* Error Exit: Save debugging information and perform any needed      *
*             clean-up.  If CODE=xx is non-zero, it is used for the  *
*             value of GDIRC. If it is zero, R15 is used for GDIRC.  *
*                                                                    *
**********************************************************************
 BLOCK TYPE=ERREXIT
*---------------------------------------------------------------------*
*  Save module/offset, registers, return-code.
*---------------------------------------------------------------------*
   STM   R0,R15,GDIREGS          | Save registers at time of error.
   SM_LAL R0,&srv_modname+4      | Point to module identification.
   ST    R0,GDIMODID             | Save in general debug area.
   IF    (CLC,=H'0',EQ,0(R14))   | If CODE=00, then.
     STH R15,GDIRC               |   GDIRC := R15.
   ELSE                          | Else.
     MVC   GDIRC,0(R14)          |   GDIRC := CODE.
   ENDIF                         | EndIf.
   SL    R14,=A(&srv_modname)    | Calculate offset at time of error.
   STH   R14,GDIOFFST            | Save in debug area.
   L     R2,PWAAESV              |
   USING ESV,R2                  |
   CALLX ESVESEPA,(ESVESTKN,&ES_SAVE_DEBUG_INFO,&ES_DEBUG_ID_GDI,GDI), +
               VL
   DROP  R2                      |
*---------------------------------------------------------------------*
*  If the format function was in progress, save the length of the
*  incompletely formatted string.
*---------------------------------------------------------------------*
   L  R1,PRM_FUNCTIONCODE
   L  R1,0(R1)
   IF (C,R1,EQ,=F'&ST_FORMAT'),OR,(C,R1,EQ,=F'&ST_FORMAT2')
     L   R1,PRM_F_STRING        |   R1 -> Target string.
     L   R0,&PWA.STRING_HIGHWATER   R0 := Last byte formatted, + 1.
     IF (C,R0,LT,&PWA.STRING_CURRENT) If highwater not up-to-date.
       L R0,&PWA.STRING_CURRENT |       Use current position instead.
     ENDIF                      |   EndIf.
     SLR R0,R1                  |   R0 := Length formatted.
     L   R1,PRM_F_FMT_LEN       |   R1 -> Formatted string length parm.
     IF (TREG,R1,NZ)            |   If parameter is not missing.
       L   R15,&PWA.SIZEMASK    |     R15 := length-mask.
       EXI R15,(STCM,R0,0,0(R1))      Save as target string's length.
     ENDIF                      |   EndIf.
   ENDIF                        | EndIf.
*---------------------------------------------------------------------*
*  Pick up the return-code and exit the string-handler entirely.
*---------------------------------------------------------------------*
   LH   R15,GDIRC               |
 ENDBLK                         | Exit entire program w/return code.
 EJECT
*---------------------------------------------------------------------*
*
*  Static Data
*
*---------------------------------------------------------------------*
                 PSD
                 LTORG
&PSD.BIT_MASK    DC  B'0001',B'0011',B'0111',B'1111'
*
         MACRO
&LABEL   TE  &TYPE,&JUSTIFY,&MIN,&MAX,&DEFAULT,&ROUTINE
         GBLC &PWA
&LABEL   DC  C'&TYPE'            | Format-spec letter for this type.
         DC  C'&JUSTIFY'         | Default justification for this type.
         DC  AL4(&MIN)           | Minimum length for this type.
         DC  AL4(&MAX)           | Maximum length for this type.
         DC  AL4(&DEFAULT)       | Default length for this type.
         DC  AL4(&ROUTINE)       | A(routine to format this type).
         MEND
*
*                      Min   Max   Dflt    Formatting
&PSD.TYPES EQU *  T J -----Lengths-----    Subroutine
*
&PSD.TYPE_A    TE A,R,00001,00004,00004,FORMAT_ADDRESS
&PSD.TYPE_B    TE B,L,00001,00256,00001,FORMAT_BINARY
&PSD.TYPE_C    TE C,L,00000,65535,00001,FORMAT_CHARACTER
&PSD.TYPE_I    TE I,R,00001,00004,00004,FORMAT_SIGNED_INTEGER
&PSD.TYPE_U    TE U,R,00001,00004,00004,FORMAT_UNSIGNED_INTEGER
&PSD.TYPE_X    TE X,L,00000,65535,00001,FORMAT_HEX_CHARACTER
&PSD.TYPES_E   EQU *-TYPE_ENTRY_L
*
CLASSIFICATION  DC   256C';'       <- default value = delimiter.
DELIMITER       EQU  C';'
LETTER          EQU  C'L'
DIGIT           EQU  C'D'
                ORG  CLASSIFICATION+C' '
                DC   C';'
                ORG  CLASSIFICATION+C'a'
                DC   C'LLLLLLLLL'          LETTERS: abcdefghi
                ORG  CLASSIFICATION+C'j'
                DC   C'LLLLLLLLL'          LETTERS: jklmnopqr
                ORG  CLASSIFICATION+C's'
                DC   C'LLLLLLLL'           LETTERS: stuvwxyz
                ORG  CLASSIFICATION+C'A'
                DC   C'LLLLLLLLL'          LETTERS: ABCDEFGHI
                ORG  CLASSIFICATION+C'J'
                DC   C'LLLLLLLLL'          LETTERS: JKLMNOPQR
                ORG  CLASSIFICATION+C'S'
                DC   C'LLLLLLLL'           LETTERS: STUVWXYZ
                ORG  CLASSIFICATION+C'0'
                DC   C'DDDDDDDDDD'         DIGITS: 0123456789
                ORG
*---------------------------------------------------------------------*
*  Translation table for folding character strings to uppercase.
*---------------------------------------------------------------------*
FOLD        DC  256AL1(*-FOLD) | Translate tbl for uppercase conv.
            ORG FOLD+C'a'      | Fold lowercase 'a' - 'i'.
            DC  C'ABCDEFGHI'   |
            ORG FOLD+C'j'      | Fold lowercase 'j' - 'r'.
            DC  C'JKLMNOPQR'   |
            ORG FOLD+C's'      | Fold lowercase 's' - 'z'.
            DC  C'STUVWXYZ'    |
            ORG  ,
*---------------------------------------------------------------------*
*  Translation tables for converting char-to-hex and hex-to-char.
*---------------------------------------------------------------------*
&PSD.HEX_TAB  DC  256X'00'
              ORG &PSD.HEX_TAB+C'a'
              DC  X'FAFBFCFDFEFF'
              ORG &PSD.HEX_TAB+C'A'
              DC  X'FAFBFCFDFEFF'
              ORG &PSD.HEX_TAB+C'0'
              DC  C'0123456789'
*
              DC   C'0123456789ABCDEF'
HEXCHARS      EQU  *-256
              ENDPSD
              EJECT
*---------------------------------------------------------------------*
*
*  Program Work Area
*
*---------------------------------------------------------------------*
                  PWA
&PWA.#PARMS       DS   F         | Number of parameters passed in.
&PWA.SIZELENGTH   DS   F         | Size of string length-specifiers.
&PWA.SIZEMASK     DS   F         | Mask for <sizelength> values.
*---------------------------------------------------------------------*
* General use work area for performing conversions.
*---------------------------------------------------------------------*
&PWA.WORK         DS   0D,CL16   | &PWA.WORK for conversions.
                  ORG  &PWA.WORK |
&PWA.WORK0        DS   0CL1      | Conversion &PWA.WORK, with L'=1.
&PWA.WORK1        DS   0CL1      |
&PWA.WORK2        DS   0CL2      |
&PWA.WORK3        DS   0CL3      |
&PWA.WORK4        DS   0CL4      |
&PWA.WORK8        DS   0CL8      | Conversion &PWA.WORK, with L'=8.
&PWA.WORK9        DS   0CL9      | Conversion &PWA.WORK, with L'=9.
&PWA.WORK16       DS   0CL16     | Conversion &PWA.WORK, with L'=16.
                  ORG  ,         |
&PWA.SUFFIX       DS   CL2       | st/nd/th suffix for integers.
DECIMAL           DS   0D,CL9    | Packed decimal holding area.
                  ORG  DECIMAL   |
DECIMAL9          DS   0CL9      |
                  ORG  ,         |
&PWA.TRANTAB      DS   CL256     | General purpose tranlation table.
FUNCTION_SPECIFIC DS   0D        | Function-specific work areas.
*---------------------------------------------------------------------*
* Format-string function's work area.
*---------------------------------------------------------------------*
&PWA.STRING_START     DS  A           | A(String).
&PWA.STRING_CURRENT   DS  A           | A(current position in String).
&PWA.STRING_HIGHWATER DS  A           | A(last char in String).
&PWA.STRING_END       DS  A           | A(last char in String).
*                                     |
&PWA.CONTROL_START    DS  A           | A(Control string).
&PWA.CONTROL_CURRENT  DS  A           | A(current position in Control).
&PWA.CONTROL_END      DS  A           | A(last char in Control).
&PWA.CONTROL_LEN      DS  F           | Length of Control string.
*                                     |
&PWA.ARGUMENT_LIST DS     2F          | <Argument> count/current.
*                                     |
&PWA.ST_FS_WORK       EQU *           | Workarea for 1 format-spec.
&PWA.FS_CURRENT       DS  A           | A(current position in spec).
&PWA.FS_LENGTH        DS  F           | Length from '{' to '}'.
&PWA.FS_END           DS  A           | A(end of specification).
&PWA.FS_FIELDS        DS  B           | Format-specification fields:
&PWA.FSF_LEADING_PAD  EQU B'10000000' |   Leading '0' was specified.
&PWA.FSF_WIDTH        EQU B'01000000' |   Width was specified.
&PWA.FSF_PRECISION    EQU B'00100000' |   Precision was specified.
&PWA.FSF_COLUMN       EQU B'00010000' |   Column was specified.
&PWA.FSF_TYPE         EQU B'00001000' |   Type was specified.
&PWA.FSF_LENGTH       EQU B'00000100' |   Length was specified.
&PWA.FSF_MULTIPLE     EQU B'00000010' |   Multiple was specified.
&PWA.FSF_KEYWORDS     EQU B'00000001' |   Keyword(s) were specified.
&PWA.FSV_LEADING_PAD  DS  B           | Leading pad character.
&PWA.FSV_WIDTH        DS  F           | Width value.
&PWA.FSV_PRECISION    DS  F           | Precision value.
&PWA.FSV_COLUMN       DS  C,FL4       | Column sign, value.
&PWA.FSV_TYPE         DS  A           | Address of TYPE_ENTRY.
&PWA.FSV_SOURCE       DS  A           | Address of source argument.
&PWA.FSV_LENGTH       DS  F           | Length value.
&PWA.FSV_MULTIPLE     DS  F           | Multiple value.
&PWA.FSV_KEYWORDS     EQU *           | Keyword-specified flags.
&PWA.FSV_CAPS         DS  C           |   Y|N                      CAPS
&PWA.FSV_C1ST         DS  C           |   Y|N                      C1ST
&PWA.FSV_CENTER       DS  C           |   Y|N                    CENTER
&PWA.FSV_LEFT         DS  C           |   Y|N                      LEFT
&PWA.FSV_RELATIVE     DS  C           |   Y|N                  RELATIVE
&PWA.FSV_RIGHT        DS  C           |   Y|N                     RIGHT
&PWA.FSV_TRIM         DS  C           |   Y|N                      TRIM
&PWA.FSV_FILL         DS  C           |   Y|N                      FILL
&PWA.FSV_CSV          DS  C           |   Y|N                       CSV
&PWA.FSV_QST          DS  C           |   Y|N                       QST
&PWA.FSV_KEYWORDS_LEN EQU *-&PWA.FSV_KEYWORDS
&PWA.FSV_FILL_LENGTH  DS  F           | Fill string length.
&PWA.FSV_FILL_VALUE   DS  CL256       | Fill string value.
&PWA.ST_FS_WORK_L     EQU *-&PWA.ST_FS_WORK
*---------------------------------------------------------------------*
* Debugging information in case of error.
*---------------------------------------------------------------------*
                  ES_GDI DSECT=NO
                  ENDPWA
                  EJECT
*---------------------------------------------------------------------*
* Mapping DSECT for one type-entry in the PSD Type-table.
*---------------------------------------------------------------------*
TYPE_ENTRY       DSECT
TE_CHAR          DS CL1  | Format-spec letter for this type.
TE_JUSTIFY       DS CL1  | Default justification: Left/Center/Right.
TE_MIN           DS FL4  | Minimum length for this type.
TE_MAX           DS FL4  | Maximum length for this type.
TE_DEFAULT       DS FL4  | Default length for this type.
TE_ROUTINE       DS AL4  | Address of routine to format this type.
TYPE_ENTRY_L     EQU     *-TYPE_ENTRY
*---------------------------------------------------------------------*
* Environment Support Vector.
*---------------------------------------------------------------------*
                  ES_ESV
                  EJECT
*---------------------------------------------------------------------*
* Parameter list for the string handler
*---------------------------------------------------------------------*
PARMLIST          DSECT              |
PRM_STRINGTKN     DS  A              | String handler work area.
PRM_FUNCTIONCODE  DS  A              | Function to be performed.
PRM_FUNCTION_DEPT EQU *              | Function dependent parameters.
*
* Parameters for FunctionCode START.
*
PRM_S_ESV         DS  A              | Server Global Area.
PRM_S_SIZELENGTH  DS  A              | Length of size-'bytes'.
*
* Parameters for FunctionCode FORMAT.
*
                  ORG PRM_FUNCTION_DEPT
PRM_F_STRING      DS  A              | Target str for format results.
PRM_F_STRING_LEN  DS  A              | Length of entire target area.
PRM_F_FMT_LEN     DS  A              | Length of formatted string.
PRM_F_CONTROL     DS  A              | Formatting control string.
PRM_F_CONTROL_LEN DS  A              | Length of control string.
PRM_F_ARGLIST     DS  A              | Separatly built argument plist.
PRM_F_ARGCOUNT    DS  A              | Number of arguments in ARGLIST.
*
* Parameters for FunctionCode String_to_Integer.
*
                  ORG PRM_FUNCTION_DEPT
PRM_STI_STRING    DS  A              | Source string of digits.
PRM_STI_LENGTH    DS  A              | Length of source string.
PRM_STI_INTEGER   DS  A              | Resulting binary integer.
                  ORG
*
* Parameters for FunctionCode Integer_to_String.
*
                  ORG PRM_FUNCTION_DEPT
PRM_ITS_INTEGER   DS  A              | Integer value to convert.
PRM_ITS_STRING    DS  A              | Area to place converted integer.
PRM_ITS_LENGTH    DS  A              | Length of target string.
PRM_ITS_RESLEN    DS  A              | Length of result.
                  ORG
                  END
