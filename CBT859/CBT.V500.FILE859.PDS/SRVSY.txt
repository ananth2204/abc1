*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
SRVSY     TITLE 'Symbol Manager'
         SRVMOD NAME=SRVSY,DATES='1987'
         gblc  &srv_modname
*---------------------------------------------------------------------*
*
*  Copyright (C) Clemson University Research Foundation 1987.
*
*  Program     SRVSY, Symbol Manager
*
*  Abstract    This processor is designed to manage symbols for an
*              application.  It does the housekeeping of storing the
*              symbols away and looking them up later, as well as
*              other related functions.
*
*              A symbol has two distinct parts contributing to its
*              definition:
*
*              Name       : The actual text string that the symbol
*                           represents.
*              Attributes : An an application-defined area containing
*                           information about the symbol.
*  Parameters:
*
*    The TableID and FunctionCode parameters are required for each call
*    to the symbol manager.  In addition to these two parameters, each
*    function has its own parameter list containing both required and
*    optional parameters.
*
*    A call to the symbol-manager always looks like the following:
*
*    CALLX SRVSY,(TableId,<function-code>,<other-parameters>)
*
*    Function specific parameter lists:
*
*    (TableId,&START,ESV,AttrSize,Caps,HashSize,MemIncr)
*
*      Create a new symbol table and assign to it a unique identifier
*      which is returned in TableID.
*
*    (TableId,&TERMINATE)
*
*      Delete the identified symbol table and set TableID to zeros.
*
*    (TableID,&SY_TRACE,OnOff)
*
*      Turn tracing on/off.
*
*    (TableId,&SY_OPEN_BLOCK,Block#,NestLevel)
*    (TableId,&SY_ENTER_BLOCK,Block#,NestLevel)
*    (TableId,&SY_EXIT_BLOCK,Block#,NestLevel)
*
*      o Create and activate a new block, returning its unique block
*        number and its nesting level.
*      o Activate an existing block, returning its nesting level.
*        The block to be opened must be a child of the currently
*        active block.
*      o Inactivate the current block, returning to its parent as the
*        current active block.  The block# and level of the parent
*        are returned.  The block and all of its symbols are retained
*        and it may be re-activated.
*
*    (TableID,&SY_INSTALL     ,Name,Length,Handle,Attr,NamePtr)
*    (TableID,&SY_LOCATE      ,Name,Length,Handle,Attr,NamePtr)
*    (TableID,&SY_LOCATE_NEXT ,Name,Length,Handle,Attr,NamePtr)
*    (TableID,&SY_UPDATE      ,Name,Length,Handle,Attr,NamePtr)
*    (TableID,&SY_DELETE      ,Name,Length,Handle)
*
*      A symbol may be identified to the symbol-manager either by
*      providing its Name and Length, or by providing its Handle.
*      If the Name/Length are provided, the Handle will be passed
*      back to the caller.  If the Handle is provided, NamePtr and
*      Length will be passed back to the caller.
*
*      o Install a new symbol in the table, giving it an initial
*        attribute.  If the symbol is already in the table, return
*        the existing attribute for it and indicate via return-code
*        that it was already there.
*      o Locate a symbol in the symbol table by name or handle, and
*        return its attribute.
*      o Remove the specified symbol from the symbol table.
*      o Replace the identified symbol's attribute with the one
*        provided.
*
*    The meaning of each parameter is explained below:
*
*    TableID
*      A fullword used to uniquely identify the symbol table being
*      managed.  It is initialized during the startup function.
*
*    FunctionCode
*      A fullword integer that specifies the function to be performed.
*      Symbolic identifiers are provided for each function and may be
*      accessed by placing a COPY statement for SRVSYMAC in the
*      assembler program.  These symbols should be used in place of
*      actual integer values.
*
*    HashSize
*      A fullword signed integer specifying the number of slots to
*      reserve in the internal hash table.
*
*    Caps
*      An optional parameter containing the string 'CAPS' or 'ASIS' to
*      indicate that symbols should (not) be captialized when installed
*      in the symbol table.  If CAPS is specified, symbol-table lookups
*      will be case-insensitive.  The Name parameter (text passed in
*      from the user's storage) is never modified.  Values 'ON' and
*      'OFF' are also accepted as synonyms for 'CAPS' and 'ASIS'.
*
*    MemIncr
*      A fullword integer specifying the increment, in bytes, that the
*      symbol manager should use when obtaining storage.  This number
*      can be used for tuning the symbol manager when a very small or
*      very large amount of symbol storage is expected to be needed.
*
*    Name
*      A text string representing the name being placed in the table or
*      being searched for.  On installation, the name is copied to
*      storage owned by the symbol-manager.  The caller's copy of the
*      string is never modified.
*
*    Length
*      The length of the symbol being operated upon.  This parameter
*      is updated if the symbol was looked up using its Handle.
*
*    Attr
*      A caller-supplied value whose length is specified during
*      startup.
*
*    Handle
*      A fullword providing an alternate method of identifying a
*      symbol.  The symbol-manager assigns a unique value to each
*      symbol installed in the table.  Because they are fixed in
*      length, Handles provide an easy way for applications to
*      pass symbols around.
*
*    NamePtr
*      If a symbol is located using its Handle, NamePtr will be set to
*      point to the text of the symbol's name.  The text pointed to
*      will be the copy stored within the symbol-table and thus may
*      be capitalized.
*
*  Return codes:
*
*  Program     reentrant, problem key and state, standard linkage,
*  Attributes  non-authorized, amode(any), rmode(any)
*
*  Change
*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution
*
*---------------------------------------------------------------------
 EJECT
 COPY  SMSYMS                    | Structured Macros symbols.
 COPY  SRVESMAC                  | Environment Support symbols.
 COPY  SRVMMMAC                  | Memory Manager symbols.
 COPY  SRVSYMAC                  | Symbol Manger symbols.
 COPY  SRVSTMAC                  | String Handler symbols.
 BLOCK NAME=&srv_modname,TYPE=PROGRAM,AMODE=31,RMODE=ANY,              +
               PARMMAP=(PARMLIST,PARMLIST_L),                          +
               OPTIONS=(*SRVPRC,LONG,                                  +
               (PARMS,COPY,VL,                                         +
               (COPYERROR,,&SY_INVALID_NUMBER_OF_PARMS),               +
               (COUNT,PWA_#PARMS),                                     +
               (USING,R9))),                                           +
               SUBOPTS=(*SWA,LOADBASE)
*
   ES_ID   ID=ES,SPEPA=&PWA.ES_SPEPA,SPTOKEN=&PWA.ES_SPTOKEN,          +
               ESVA=PWAAESV
   MM_ID   ID=MM,SPEPNAME=&MEMORY_MANAGER
   ST_ID   ID=ST,SPEPNAME=&STRING_HANDLER,SIZELENGTH=4
*---------------------------------------------------------------------*
*  If the function code is something other than start, make sure that
*  the PWA contains the eye-catcher string and the correct value for
*  tableid. If not, then the tableid passed in is garbage.
*---------------------------------------------------------------------*
   L  R7,PRM_FUNCTIONCODE          | Load the function code into
   L  R7,0(,R7)                    | a register for testing.
   IF (C,R7,NE,=F'&START')         | If not startup function then
     IF ((CLC,&PWA.VISUAL,NE,EYECATCHER),OR,(C,R13,NE,&PWA.TABLEID))
       ERREXIT CODE=&SY_INVALID_SYMBOL_TABLE
     ELSEIF (NOT,((C,R9,EQ,=F'&TERMINATE'),OR,(TBIT,&PWA.F_USEABLE)))
       ERREXIT CODE=&SY_SYMBOL_TABLE_NOT_USEABLE
     ENDIF                            |   Endif.
   ENDIF                              | Endif.
   EJECT
*---------------------------------------------------------------------*
*  If the FunctionCode is one of Install, Locate, Delete or Update
*  then perform the operations common to all of them.
*---------------------------------------------------------------------*
   CASEBLK REG=R7,WREG=R1              | Case on FunctionCode.
     CASE &SY_INSTALL,&SY_LOCATE,&SY_DELETE,&SY_UPDATE
       ERREXIT (CLC,&PWA.OPEN_BLOCKS,EQ,=F'0'),CODE=&SY_NO_BLOCKS_OPEN
*                                      |
       L   R2,PRM_SY_NAME              |    R2 -> symbol's name.
       LA  R2,0(R2)                    |    Clear high-order bit.
       L   R5,PRM_SY_LENGTH            |    R5 -> symbol's length.
       L   R5,0(,R5)                   |    R5 := symbol's length.
       IF  ((TREG,R2,NZ),AND,(TREG,R5,NZ))  If a symbol's name given.
         SLR R4,R4                     |      Set R4 := Mod(length,4).
         D   R4,=F'4'                  |          R5 := Length / 4.
         XR  R15,R15                   |      Clear the accumulator.
         IF  (TREG,R5,P)               |      If more than 4 chars.
           LOOP BCT                    |        Loop 4-at-a-time.
             MVC  &PWA.WORK1,0(R2)     |          Copy 4 chars.
             TR   &PWA.WORK1,FOLD      |          Fold to capitals.
             X    R15,&PWA.WORK1       |          XOR with accumulator.
             LA   R2,4(,R2)            |          Advance to next 4
           ENDLOOP BCT,R5              |        EndLoop.
         ENDIF                         |      EndIf.
         IF (TREG,R4,P)                |      If any characters left.
           MVC  &PWA.WORK1,=F'0'       |        Clear for XOR instr.
           BCTR R4,0                   |        Subtract 1 for EX.
           EXI  R4,(MVC,&PWA.WORK1(0),0(R2))    Copy char(s).
           TR   &PWA.WORK1,FOLD        |        Fold to capitals.
           X    R15,&PWA.WORK1         |        XOR with accumulator.
         ENDIF                         |      EndIf.
         XR   R14,R14                  |      Clear out upper word.
         D    R14,&PWA.HASHSIZE        |      R14 := Mod(R15,Hash).
         LPR  R15,R14                  |      Set R15 = ABS(Remainder).
         MH   R15,=AL2(BLOCK_HASH_L)   |      Adjust R15 to offset.
         ST   R15,&PWA.HASHVALUE       |      Save in PWA.
       ENDIF                           |
     CASE OTHER                        | -- Ignore other functioncodes.
   ENDCASE                             | EndCase.
   EJECT
*---------------------------------------------------------------------*
*  Invoke the routines needed to accomplish the specified function.
*---------------------------------------------------------------------*
   CASEBLK REG=R7,WREG=R1              | Case on FunctionCode.
     CASE &START                       | SY_START:
       CALLSUB START                   |   Create a new symbol table.
     CASE &TERMINATE                   | SY_TERMINATE:
       CALLSUB TERMINATE               |   Delete a symbol table.
     CASE &SY_TRACE                    | SY_TRACE:
       CALLSUB SET_TRACE,(*PRM_T_ONOFF)    Set TRACE to ON or OFF.
     CASE &SY_OPEN_BLOCK               | SY_OPEN_BLOCK:
       CALLSUB OPEN_BLOCK              |   Create a new scope.
     CASE &SY_ENTER_BLOCK              | SY_ENTER_BLOCK:
       CALLSUB ENTER_BLOCK             |   Enter an existing block.
     CASE &SY_EXIT_BLOCK               | SY_EXIT_BLOCK:
       CALLSUB EXIT_BLOCK              |   Exit the current block.
     CASE &SY_INSTALL                  | SY_INSTALL:
       CALLSUB INSTALL_SYMBOL          |   Install a new symbol.
     CASE &SY_LOCATE                   | SY_LOCATE:
       CALLSUB LOCATE_SYMBOL           |   Locate an existing symbol.
     CASE &SY_DELETE                   | SY_DELETE:
       CALLSUB DELETE_SYMBOL           |   Delete a symbol.
     CASE &SY_UPDATE                   | SY_UPDATE:
       CALLSUB UPDATE_SYMBOL           |   Update a symbol's attribute.
     CASE OTHER                        | <invalid function code>.
       ERREXIT CODE=&SY_INVALID_FUNCTION
   ENDCASE                             |
 ENDBLK BLOCK=&srv_modname,RC=0
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: START                                                  *
*  Abstract:   Process the optional startup parameters, establish a   *
*              memory heap, and allocate the root symbol block.       *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=START
*---------------------------------------------------------------------*
*  All fields in the PWA have already been initialized to zeros by
*  the block macro.  Initialize those fields that must be non-zero
*---------------------------------------------------------------------*
   L     R1,PWAAESV                | R1 -> Environment Support Vector.
   USING ESV,R1                    | Establish addressability.
   MVC   &PWA.ES_SPEPA,ESVESEPA    | Copy Environment Support's EPA.
   MVC   &PWA.ES_SPTOKEN,ESVESTKN  | Copy Environment Support's EPA.
   DROP  R1                        | Drop addressability.
*                                  |
   MVC  &PWA.VISUAL,EYECATCHER     | Both the eyecatcher and the
   ST   R13,&PWA.TABLEID           | tableid are for validity checks.
   SBIT &PWA.F_USEABLE             | Reset whenever table is corrupt.
   RBIT &PWA.F_TRACE               | Tracing is not active.
   MVC  &PWA.ATTRSIZE,=F'0'        | Default attribute size.
   MVI  &PWA.CAPS,C'N'             | Default CAPS mode = ASIS.
   MVC  &PWA.HASHSIZE,=F'101'      | Default # hash slots.
   MVC  &PWA.MEMINCR,=F'4096'      | Default memory increment value.
*---------------------------------------------------------------------*
*  Evaluate the optional parameters of the START function.
*---------------------------------------------------------------------*
   LM R2,R6,PRM_S_ATTRSIZE           | R2:R6 -> optional parameters:
*                                    |
   IF (TREG,R2,NZ)                   | If ATTRSIZE parameter present.
     MVC &PWA.ATTRSIZE,0(R2)         |   Copy it to the PWA.
   ENDIF                             | EndIf.
*                                    |
   IF (TREG,R3,NZ)                   | If CAPS parameter present.
     CALLSUB SET_CAPS,((R3))         |   Set current CAPS mode.
   ENDIF                             | EndIf.
*                                    |
   IF (TREG,R4,NZ)                   | If HASHSIZE parameter present.
     L       R4,0(,R4)               |   R4 := HashSize.
     ERREXIT (TREG,R4,NP),CODE=&SY_INVALID_HASHSIZE
     ST      R4,&PWA.HASHSIZE        |   Save HashSize value.
   ENDIF                             | EndIf.
*                                    |
   IF (TREG,R5,NZ)                   | If MEMINCR parameter present.
     L       R5,0(,R5)               |   R5 := MemIncr.
     ERREXIT (TREG,R5,NP),CODE=&SY_INVALID_INCREMENT
     ST      R5,&PWA.MEMINCR         |   Save MemIncr value.
   ENDIF                             | EndIf.
*                                    |
   IF (TREG,R6,NZ)                   | If TRACE parameter present.
     CALLSUB SET_TRACE,(0(R6))       |   Set tracing ON | OFF.
   ENDIF                             | EndIf.
   EJECT
*---------------------------------------------------------------------*
*  Load the memory manager and begin a new heap.
*---------------------------------------------------------------------*
   ES_LOAD_MODULE ID=ES,SPID=MM      | Load the Memory Manager.
   ERREXIT        (TREG,R15,NZ),CODE=&SY_MEMORY_PROBLEM
   MM_START       ID=MM,INCREMENT=&PWA.MEMINCR
   ERREXIT        (TREG,R15,NZ),CODE=&SY_MEMORY_PROBLEM
*---------------------------------------------------------------------*
*  Create the root symbol-table block.  The block's entire contents,
*  and thus its block number and nesting level, will equal zeros.
*---------------------------------------------------------------------*
   MVC     &PWA.HIGH_BLOCK#,=F'0'   | Cause 1st block# to equal 0.
   MVC     &PWA.NEST_LEVEL,=F'0'    | Cause 1st block's nest level = 0.
   L       R3,&PWA.HASHSIZE         | R3 := # hash slots needed.
   MH      R3,=AL2(BLOCK_HASH_L)    | R3 := Size of hash-table.
   LA      R3,BLOCK_L(,R3)          | R3 := Size of a block node.
   ST      R3,&PWA.BLOCK_SIZE       | Save total block-node size.
   MM_OBTAIN_STORAGE ID=MM,         | Obtain storage for a block       +
               SIZE=&PWA.BLOCK_SIZE,    using calculated size.         +
               ADDRESS=&PWA.ROOT_BLOCK
   MVC     &PWA.OPEN_BLOCKS,&PWA.ROOT_BLOCK
   ERREXIT (C,R15,EQ,=A(&MM_STORAGE_NOT_AVAILABLE)),                   +
               CODE=&SY_STORAGE_NOT_AVAILABLE
   ERREXIT (TREG,R15,NZ),CODE=&SY_MEMORY_PROBLEM
*---------------------------------------------------------------------*
*  Issue a trace message showing initialization values.
*---------------------------------------------------------------------*
   IF (CLI,&PWA.CAPS,EQ,C'Y')
     LA  R2,=C'CAPS'
   ELSE
     LA  R2,=C'ASIS'
   ENDIF
   CALLSUB TRACE,(TM_START,&PWA.ATTRSIZE,0(R2),&PWA.HASHSIZE,          +
               &PWA.MEMINCR)
 ENDBLK BLOCK=START
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: TERMINATE                                              *
*  Abstract:  Terminate the memory manager to free all storage, wipe  *
*             out the contents of the PWA, and indicate that it       *
*             should be freed.                                        *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=TERMINATE
   CALLSUB      TRACE,(TM_TERMINATE)    | Issue a TRACE message.
*                                       |
   IF (CLC,&PWA.MM_SPEPA,NE,=F'0')      | If Memory Manager loaded.
     IF (CLC,&PWA.MM_SPTOKEN,NE,=F'0')  |   If Memory Manager started.
       MM_TERMINATE ID=MM               |     Terminate Memory Manager.
     ENDIF                              |   EndIf.
     ES_UNLOAD_MODULE ID=ES,SPID=MM     |   Unload Memory Manager.
   ENDIF                                | EndIf.
*                                       |
   IF (CLC,&PWA.ST_SPEPA,NE,=F'0')      | If String Handler loaded.
     IF (CLC,&PWA.ST_SPTOKEN,NE,=F'0')  |   If String Handler started.
       ST_TERMINATE ID=ST               |     Terminate String Handler.
     ENDIF                              |   EndIf.
     ES_UNLOAD_MODULE ID=ES,SPID=ST     |   Unload String Handler.
   ENDIF                                | EndIf.
*                                       |
   FILL    &PWA.AREA,X'00',LENGTH=(&PWA.AREA_L,MEDIUM)
   SMCTRL  FREEPWA=YES                  | Free the PWA on return.
 ENDBLK BLOCK=TERMINATE
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: SET_CAPS                                               *
*  Abstract:   Set the current CAPS mode according to the provided    *
*              parameter.                                             *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=SET_CAPS
   L   R1,0(,R1)                          | Point to only parameter.
   MVC &PWA.WORK1,0(R1)                   | Copy CAPS parameter to PWA.
   OC  &PWA.WORK1,=CL4' '                 | Convert to capitals.
   IF  (CLC,&PWA.WORK1(2),EQ,=C'ON')      | If equal to 'ON'.
     MVI  &PWA.CAPS,C'Y'                  |   Set mode to CAPS on.
   ELSEIF (CLC,&PWA.WORK1(2),EQ,=C'NO')   | If equal to 'NO'.
     MVI  &PWA.CAPS,C'N'                  |   Set mode to CAPS off.
   ELSEIF (CLC,&PWA.WORK1(3),EQ,=C'YES')  | ElseIf equal to 'YES'.
     MVI  &PWA.CAPS,C'Y'                  |   Set mode to CAPS on.
   ELSEIF (CLC,&PWA.WORK1(3),EQ,=C'OFF')  | ElseIf equal to 'OFF'.
     MVI  &PWA.CAPS,C'N'                  |   Set mode to CAPS off.
   ELSEIF (CLC,&PWA.WORK1(4),EQ,=C'CAPS') | ElseIf equal to 'CAPS'.
     MVI  &PWA.CAPS,C'Y'                  |   Set mode to CAPS on.
   ELSEIF (CLC,&PWA.WORK1(4),EQ,=C'ASIS') | ElseIf equal to 'ASIS'.
     MVI  &PWA.CAPS,C'N'                  |   Set mode to CAPS off.
   ELSE                                   | Else.
     ERREXIT CODE=&SY_INVALID_CAPS_PARAMETER  Return with error-code.
   ENDIF                                  | EndIf.
 ENDBLK BLOCK=SET_CAPS
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: SET_TRACE                                              *
*  Abstract:   Turn on/off the trace function.                        *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=SET_TRACE
*---------------------------------------------------------------------*
*  Set the trace flag.
*---------------------------------------------------------------------*
   L     R1,0(R1)                     | R1 -> Trace parameter.
   IF    (TREG,R1,Z),THEN             | If no Trace parameter.
     SBIT  &PWA.F_TRACE               |   Turn tracing on.
   ELSE                               | Else.
     MVC &PWA.WORK1(3),0(R1)          |   Copy parameter to PWA.
     OC  &PWA.WORK1,=CL4' '           |   Convert to capitals.
     IF  (CLC,&PWA.WORK1(2),EQ,=C'ON') |  If trace parameter = 'ON'.
       SBIT  &PWA.F_TRACE             |     Turn tracing on.
     ELSEIF (CLC,&PWA.WORK1(3),EQ,=C'OFF') ElseIf it = 'OFF'.
       RBIT  &PWA.F_TRACE             |   Turn tracing off.
     ENDIF                            |   EndIf.
   ENDIF                              | EndIf.
*---------------------------------------------------------------------*
*  If tracing is active, insure that the string handler is accessable.
*  Otherwise, insure that it is not tying up space.
*---------------------------------------------------------------------*
   L  R3,&PWA.ST_SPEPA                | R3 -> Str Handler, if loaded.
   IF (TBIT,&PWA.F_TRACE),THEN        | If tracing is active then.
     IF (TREG,R3,Z),THEN              |   If string Handler not loaded.
       ES_LOAD_MODULE ID=ES,SPID=ST   |     Load String Handler.
       ST_START       ID=ST           |     Start String Handler.
     ENDIF                            |   EndIf.
     CALLSUB TRACE,(TM_TRACE)         |   Issue TRACE on message.
   ELSEIF (TREG,R3,NZ)                | ElseIf String Handler loaded.
     ST_TERMINATE     ID=ST           |   Terminate String Handler.
     ES_UNLOAD_MODULE ID=ES,SPID=ST   |   Unload String Handler.
   ENDIF                              | EndIf.
 ENDBLK BLOCK=SET_TRACE
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: OPEN_BLOCK                                             *
*  Abstract  : Allocate a new block, assign it a block number and     *
*              level, and return its address.                         *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=OPEN_BLOCK
*--------------------------------------------------------------------*
*  Attempt to allocate storage for the new block.
*--------------------------------------------------------------------*
   MM_OBTAIN_STORAGE ID=MM,SIZE=&PWA.BLOCK_SIZE,ADDRESS=&PWA.WORK1
   ERREXIT (C,R15,EQ,=A(&MM_STORAGE_NOT_AVAILABLE)),                   +
               CODE=&SY_STORAGE_NOT_AVAILABLE
   ERREXIT (TREG,R15,NZ),CODE=&SY_MEMORY_PROBLEM
   L       R3,&PWA.WORK1           | R3 -> new block.
*--------------------------------------------------------------------*
*  The new block is the child of the currently active block.  Link
*  it to its parent and siblings, and make it the currently active
*  block.
*--------------------------------------------------------------------*
   L     R1,&PWA.OPEN_BLOCKS        | R1 -> front of active-block list.
   ST    R1,BLOCK_PARENT-BLOCK(,R3) | Point to the new block's parent.
   USING BLOCK,R1                   | Get addressability on parent.
   IF    (CLC,BLOCK_CHILD,EQ,=F'0') | If this is the first child, then.
     ST  R3,BLOCK_CHILD             |   Set as first in child-list.
   ELSE                             | Else.
     L   R2,BLOCK_CHILDL            |   Point to last child in list.
     ST  R3,BLOCK_SIBLING-BLOCK(,R2)    Make sibling of last child.
   ENDIF                            | EndIf.
   ST    R3,BLOCK_CHILDL            | New block is the last child.
   ST    R3,&PWA.OPEN_BLOCKS        | Make the new block active.
   DROP  R1                         | Change addressability to
   USING BLOCK,R3                   | that of the new block node.
*--------------------------------------------------------------------*
*  Assign the block a number.
*--------------------------------------------------------------------*
   L       R1,&PWA.HIGH_BLOCK#     | R1 := Highest block# so far.
   LA      R1,1(,R1)               | Bump the highest block#.
   ST      R1,BLOCK_NUMBER         | Assign it to current block.
   ST      R1,&PWA.HIGH_BLOCK#     | Save for next time.
*--------------------------------------------------------------------*
*  Assign the block its nesting level.
*--------------------------------------------------------------------*
   L       R1,&PWA.NEST_LEVEL      | R1 := Current nesting level.
   LA      R1,1(,R1)               | Bump the current nesting level.
   ST      R1,BLOCK_LEVEL          | Assign it to current block.
   ST      R1,&PWA.NEST_LEVEL      | Save for next time.
   CALLSUB TRACE,(TM_BLOCK,'Create',BLOCK_NUMBER,&PWA.NEST_LEVEL)
*--------------------------------------------------------------------*
*  Return the opened block's number and the new nesting level.
*--------------------------------------------------------------------*
   L       R1,PRM_BL_BLOCK#        | R1 -> Block # parameter.
   IF      (TREG,R1,NZ)            | If Block# parameter present.
     MVC   0(4,R1),BLOCK_NUMBER    |   Copy opened block's number.
   ENDIF                           | EndIf.
   L       R1,PRM_BL_NESTLEVEL     | R1 -> NestLevel parameter.
   IF      (TREG,R1,NZ)            | If NestLevel parameter present.
     MVC   0(4,R1),&PWA.NEST_LEVEL |   Copy uncovered nesting level.
   ENDIF                           | EndIf.
   DROP    R3                      | Clean up on addressability.
 ENDBLK BLOCK=OPEN_BLOCK
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: ENTER_BLOCK                                            *
*  Abstract  : Open an existing block that is either a child of the   *
*              currently active block or is the root-block.           *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=ENTER_BLOCK
   L     R3,PRM_BL_BLOCK#           Pick up address of block# desired.
*--------------------------------------------------------------------*
*  If there is no block active, activate the root block.  Otherwise
*  activate a child of the currently active block.
*--------------------------------------------------------------------*
   L     R4,&PWA.OPEN_BLOCKS        | Point to 1st active block.
   USING BLOCK,R4                   | Establish addressability.
   IF    (TREG,R4,Z)                | If no active blocks, then.
     L   R4,&PWA.ROOT_BLOCK         |   Point to the root-block.
     IF  (TREG,R3,NZ)               |   If a block# was provided, then.
       ERREXIT (CLC,0(R3),NE,BLOCK_NUMBER),CODE=&SY_CANNOT_OPEN_BLOCK
     ENDIF                          |   EndIf.
   ELSE                             | Else.
     L   R4,BLOCK_CHILD             |   Point to 1st child in list.
     IF  (TREG,R3,NZ)               |   If a block# was provided, then.
       LOOP WHILE,((TREG,R4,NZ),AND,(CLC,0(R3),NE,BLOCK_NUMBER))
         L  R4,BLOCK_SIBLING        |      Point to next child in list.
       ENDLOOP WHILE                |     EndLoop.
     ENDIF                          |   EndIf.
     ERREXIT (TREG,R4,Z),CODE=&SY_CANNOT_OPEN_BLOCK
   ENDIF                            | EndIf.
   ST  R4,&PWA.OPEN_BLOCKS          | Set current active block.
   CALLSUB TRACE,(TM_BLOCK,'Open  ',BLOCK_NUMBER,&PWA.NEST_LEVEL)
*--------------------------------------------------------------------*
*  Return the newly activated block's number and nest level.
*--------------------------------------------------------------------*
   L       R1,PRM_BL_BLOCK#        | R1 -> Block # parameter.
   IF      (TREG,R1,NZ)            | If Block# parameter present.
     MVC   0(4,R1),BLOCK_NUMBER    |   Copy opened block's number.
   ENDIF                           | EndIf.
   L       R1,PRM_BL_NESTLEVEL     | R1 -> NestLevel parameter.
   IF      (TREG,R1,NZ)            | If NestLevel parameter present.
     MVC   0(4,R1),&PWA.NEST_LEVEL |   Copy uncovered nesting level.
   ENDIF                           | EndIf.
   DROP    R4                      | Clean up on addressability.
 ENDBLK BLOCK=ENTER_BLOCK
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: EXIT_BLOCK                                             *
*  Abstract  : Remove the block on top of the active list, but do NOT *
*              delete it.                                             *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=EXIT_BLOCK
*--------------------------------------------------------------------*
*  If any blocks are active, remove the one in front of the list.
*--------------------------------------------------------------------*
   L       R2,&PWA.OPEN_BLOCKS           | Point to 1st active block.
   USING   BLOCK,R2                      | Establish addressability.
   ERREXIT (TREG,R2,Z),CODE=&SY_NO_BLOCKS_OPEN
   MVC     &PWA.OPEN_BLOCKS,BLOCK_PARENT | Remove from active list.
*--------------------------------------------------------------------*
*  Decrement the current nesting level.
*--------------------------------------------------------------------*
   L       R1,&PWA.NEST_LEVEL          | Load into a reg for subtract.
   S       R1,=F'1'                    | Decrement current nest level.
   ST      R1,&PWA.NEST_LEVEL          | Save adjusted nest level.
*--------------------------------------------------------------------*
*  Return the closed block's number and the uncovered nesting level.
*--------------------------------------------------------------------*
   L       R1,PRM_BL_BLOCK#            | R1 -> Block # parameter.
   IF      (TREG,R1,NZ)                | If Block# parameter present.
     MVC   0(4,R1),BLOCK_NUMBER        |   Copy closed block's number.
   ENDIF                               | EndIf.
   L       R1,PRM_BL_NESTLEVEL         | R1 -> NestLevel parameter.
   IF      (TREG,R1,NZ)                | If Block# parameter present.
     MVC   0(4,R1),&PWA.NEST_LEVEL     |   Copy new nesting level.
   ENDIF                               | EndIf.
   CALLSUB TRACE,(TM_BLOCK,'Close ',BLOCK_NUMBER,&PWA.NEST_LEVEL)
   DROP    R2                          | Clean up on addressability.
 ENDBLK BLOCK=EXIT_BLOCK
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: INSTALL_SYMBOL                                         *
*  Abstract:   Install a new symbol into the symbol table.            *
*  Parameters:                                                        *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=INSTALL_SYMBOL
   ERREXIT (CLC,PWA_#PARMS,LT,=F'4'),CODE=&SY_INVALID_NUMBER_OF_PARMS
   ERREXIT (CLC,PWA_#PARMS,GT,=F'7'),CODE=&SY_INVALID_NUMBER_OF_PARMS
   L       R3,&PWA.OPEN_BLOCKS     | Point to current block.
   USING   BLOCK,R3                | Establish addressability.
*--------------------------------------------------------------------*
*  If the symbol is in the current block, copy attribute and leave.
*--------------------------------------------------------------------*
   CALLSUB FIND_SYMBOL,(BLOCK)     | Attempt to find symbol in block.
   IF (TREG,R15,NZ),THEN           | If the symbol was located.
     L     R4,0(R15)               |   R4 -> Name node containing it.
     USING NAME,R4                 |   Establish addressability.
     L     R6,PRM_SY_ATTR          |   R6 -> Attribute to return.
     L     R7,&PWA.ATTRSIZE        |   R7 := Attribute's length.
     IF ((TREG,R6,NZ),AND,(TREG,R7,P)) If okay to copy attribute.
       LA    R0,NAME_TEXT          |     R0 -> Symbol's Text.
       A     R0,NAME_SIZE          |     R0 -> Symbol's Attribute.
       LR    R1,R7                 |     R1 := Source length for MVCL.
       MVCL  R6,R0                 |     Copy Attribute to return-parm.
     ENDIF                         |   EndIf.
     ERREXIT CODE=&SY_SYMBOL_ALREADY_INSTALLED
   ELSE
*--------------------------------------------------------------------*
*    Allocate memory for holding the new symbol's node.
*--------------------------------------------------------------------*
     L       R4,PRM_SY_LENGTH  |   R4 -> Symbol's length.
     L       R4,0(,R4)         |   R4 := Symbol's length.
     A       R4,&PWA.ATTRSIZE  |   R4 := Symbol's Length + Attr Size.
     LA      R4,NAME_L(R4)     |   R4 := Total size to allocate.
     ST      R4,&PWA.WORK1     |   Save length of new NAME.
     MM_OBTAIN_STORAGE ID=MM,SIZE=&PWA.WORK1,ADDRESS=&PWA.WORK2
     ERREXIT (C,R15,EQ,=A(&MM_STORAGE_NOT_AVAILABLE)),                 +
               CODE=&SY_STORAGE_NOT_AVAILABLE
     ERREXIT (TREG,R15,NZ),CODE=&SY_MEMORY_PROBLEM
     L       R4,&PWA.WORK2     |   Point to newly allocated stg.
     USING   NAME,R4           |   Establish addressability.
*--------------------------------------------------------------------*
*    Insert the new symbol's node.
*--------------------------------------------------------------------*
     ST      R3,NAME_BLOCK     |   Save parent-block pointer of name.
     L       R5,&PWA.HASHVALUE |   Pick up symbol's hash value.
     LA      R5,BLOCK_HASH(R5) |   Point to hash-bucket for symbol.
     L       R1,0(R5)          |   Point to current 1st node.
     ST      R1,NAME_LINK      |   Copy hash chain head pointer.
     ST      R4,0(R5)          |   Place new item in front of list.
*--------------------------------------------------------------------*
*    Copy the supplied symbol to the new block.
*--------------------------------------------------------------------*
     L       R6,PRM_SY_NAME    |   R6 -> Symbol's name.
     L       R7,PRM_SY_LENGTH  |   R7 -> length of symbol's text.
     MVC     NAME_SIZE,0(R7)   |   Save in the NAME.
     LA      R0,NAME_TEXT      |   R0 -> Target for move long.
     L       R1,NAME_SIZE      |   R1 := Length of symbol's text.
     L       R7,NAME_SIZE      |   R7 := Length of symbol's text.
     MVCL    R0,R6             |   Copy the symbol into blk.
*--------------------------------------------------------------------*
*    After the MVCL instr, R0 will point to the location following the
*    last byte of the copied text.  Copy the attribute to this
*    position, if attributes are non-zero in length.
*--------------------------------------------------------------------*
     L  R1,&PWA.ATTRSIZE       |   R1 := MVCL length for attribute.
     IF (TREG,R1,P)            |   If attribute length positive.
       L  R6,PRM_SY_ATTR       |     R6 -> Supplied Attribute.
       IF (TREG,R6,NZ)         |     If an attribute was supplied.
         LR   R7,R1            |       R7 := MVCL source length.
         MVCL R0,R6            |       Copy attribute to NAME node.
       ENDIF                   |     EndIf.
     ENDIF                     |   EndIf.
*--------------------------------------------------------------------*
*    If CAPS mode is on, fold the symbol's text to upper case.
*--------------------------------------------------------------------*
     IF (CLI,&PWA.CAPS,EQ,C'Y') |  If current mode = CAPS then.
       LA   R14,NAME_TEXT      |     R14 -> curent segment of text.
       L    R15,NAME_SIZE      |     R15 := remaining length.
       LOOP WHILE,(C,R15,GT,=F'256') Loop over big chunks.
         TR 0(256,R14),FOLD    |       Fold segment to uppercase.
         A  R14,=F'256'        |       Advance to next big chunk.
         S  R15,=F'256'        |       Adjust remaining length.
       ENDLOOP WHILE           |     EndLoop.
       IF (TREG,R14,P)         |     If more characters left.
         BCTR R15,0            |       Subtract 1 for EX instr.
         EXI  R15,(TR,0(0,R14),FOLD)    Fold last chunk to upper.
       ENDIF                   |     EndIf.
     ENDIF                     |   EndIf.
   ENDIF                       | EndIf
*--------------------------------------------------------------------*
*  If the Handle parameter was supplied, set its value.
*--------------------------------------------------------------------*
   L   R2,PRM_SY_HANDLE        | R2 -> Handle parameter.
   IF  (TREG,R2,NZ)            | If not a null parameter.
     ST  R4,0(R2)              |   Save name-node address.
   ENDIF                       | EndIf.
*--------------------------------------------------------------------*
*  If the NamePtr parameter was supplied, set its value.
*--------------------------------------------------------------------*
   L   R2,PRM_SY_NAMEPTR       | Point to return name pointer.
   IF  (TREG,R2,NZ)            | If NamePtr parm given.
     LA  R1,NAME_TEXT          |   R1 -> Internal name text storage.
     ST  R1,0(R2)              |   Save address of symbol's name.
   ENDIF                       | EndIf.
*                              |
   CALLSUB TRACE_SYMBOL,('Install   ',NAME)
   DROP R3,R4                  | Clean up on addressability.
 ENDBLK BLOCK=INSTALL_SYMBOL
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: LOCATE_SYMBOL                                          *
*  Abstract:   Locate an existing symbol in the symbol table.         *
*  Parameters:                                                        *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=LOCATE_SYMBOL
   ERREXIT (CLC,PWA_#PARMS,LT,=F'4'),CODE=&SY_INVALID_NUMBER_OF_PARMS
   ERREXIT (CLC,PWA_#PARMS,GT,=F'7'),CODE=&SY_INVALID_NUMBER_OF_PARMS
*--------------------------------------------------------------------*
*  Scan the active block list for a block containing the symbol.
*--------------------------------------------------------------------*
   L       R3,&PWA.OPEN_BLOCKS     | Point to current block.
   USING   BLOCK,R3                | Establish addressability.
   LOOP    WHILE,(TREG,R3,NZ)      | While there are blocks to search.
     CALLSUB FIND_SYMBOL,(BLOCK)   |   Attempt to find symbol in block.
     LEAVE   LOOP=*,(TREG,R15,NZ)  |   Leave if symbol was found.
     L       R3,BLOCK_PARENT       |   Advance to next block.
   ENDLOOP WHILE                   | EndLoop.
   ERREXIT (TREG,R15,Z),CODE=&SY_SYMBOL_NOT_FOUND
*--------------------------------------------------------------------*
*  If the symbol was found, the return-code from FIND_SYMBOL, R15,
*  will point to a pointer to the NAME node containing it.
*--------------------------------------------------------------------*
   L     R4,0(R15)                   | R4 -> Name node containing it.
   USING NAME,R4                     | Establish addressability.
   L     R6,PRM_SY_ATTR              | R6 -> Attribute to return.
   L     R7,&PWA.ATTRSIZE            | R7 := Attribute's length.
   IF ((TREG,R6,NZ),AND,(TREG,R7,P)) | If okay to copy attribute.
     LA    R0,NAME_TEXT              |   R0 -> Symbol's Text.
     A     R0,NAME_SIZE              |   R0 -> Symbol's Attribute.
     LR    R1,R7                     |   R1 := Source length for MVCL.
     MVCL  R6,R0                     |   Copy Attribute to return-parm.
   ENDIF                             | EndIf.
   CALLSUB TRACE_SYMBOL,('Locate    ',NAME)
   DROP  R3,R4                       | Clean up on addressability.
 ENDBLK BLOCK=LOCATE_SYMBOL
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: DELETE_SYMBOL                                          *
*  Abstract:   DELETE an existing symbol in the symbol table.         *
*  Parameters:                                                        *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=DELETE_SYMBOL
   ERREXIT (CLC,PWA_#PARMS,LT,=F'4'),CODE=&SY_INVALID_NUMBER_OF_PARMS
   ERREXIT (CLC,PWA_#PARMS,GT,=F'5'),CODE=&SY_INVALID_NUMBER_OF_PARMS
*--------------------------------------------------------------------*
*  Scan the active block list for a block containing the symbol.
*--------------------------------------------------------------------*
   L       R3,&PWA.OPEN_BLOCKS     | Point to current block.
   USING   BLOCK,R3                | Establish addressability.
   LOOP    WHILE,(TREG,R3,NZ)      | While there are blocks to search.
     CALLSUB FIND_SYMBOL,(BLOCK)   |   Attempt to find symbol in block.
     LEAVE   LOOP=*,(TREG,R15,NZ)  |   Leave if symbol was found.
     L       R3,BLOCK_PARENT       |   Advance to next block.
   ENDLOOP WHILE                   | EndLoop.
   ERREXIT (TREG,R15,Z),CODE=&SY_SYMBOL_NOT_FOUND
*--------------------------------------------------------------------*
*  If the symbol was found, the return-code from FIND_SYMBOL, R15,
*  will point to a pointer to the NAME node containing it.
*--------------------------------------------------------------------*
   L       R4,0(R15)               | R4 -> Name node containing it.
   USING   NAME,R4                 | Establish addressability.
   MVC     0(4,R15),NAME_LINK      | Un-link the node from the chain.
   CALLSUB TRACE_SYMBOL,('Delete    ',NAME)
   MM_RELEASE_STORAGE ID=MM,SIZE=NAME_SIZE,ADDRESS=NAME
   ERREXIT            (TREG,R15,NZ),CODE=&SY_MEMORY_PROBLEM
   DROP    R4                      | Clean up on addressability.
 ENDBLK BLOCK=DELETE_SYMBOL
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: UPDATE_SYMBOL                                          *
*  Abstract:   Replace an existing symbol's attribute.                *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=UPDATE_SYMBOL
   ERREXIT (CLC,PWA_#PARMS,LT,=F'4'),CODE=&SY_INVALID_NUMBER_OF_PARMS
   ERREXIT (CLC,PWA_#PARMS,GT,=F'7'),CODE=&SY_INVALID_NUMBER_OF_PARMS
*--------------------------------------------------------------------*
*  Scan the active block list for a block containing the symbol.
*--------------------------------------------------------------------*
   L       R3,&PWA.OPEN_BLOCKS     | Point to current block.
   USING   BLOCK,R3                | Establish addressability.
   LOOP    WHILE,(TREG,R3,NZ)      | While there are blocks to search.
     CALLSUB FIND_SYMBOL,(BLOCK)   |   Attempt to find symbol in block.
     LEAVE   LOOP=*,(TREG,R15,NZ)  |   Leave if symbol was found.
     L       R3,BLOCK_PARENT       |   Advance to next block.
   ENDLOOP WHILE                   | EndLoop.
   ERREXIT (TREG,R15,Z),CODE=&SY_SYMBOL_NOT_FOUND
*--------------------------------------------------------------------*
*  If the symbol was found, the return-code from FIND_SYMBOL, R15,
*  will point to a pointer to the NAME node containing it.
*--------------------------------------------------------------------*
   L     R4,0(R15)                   | R4 -> Name node containing it.
   USING NAME,R4                     | Establish addressability.
   L  R6,PRM_SY_ATTR                 | R6 -> Attribute to copy.
   L  R7,&PWA.ATTRSIZE               | R7 := Attribute's length.
   IF ((TREG,R7,P),AND,(TREG,R6,NZ)) | If okay to copy attribute.
     LA    R0,NAME_TEXT              |   R0 -> Symbol's Text.
     A     R0,NAME_SIZE              |   R0 -> Symbol's Attribute.
     LR    R1,R7                     |   R1 := Dest length for MVCL.
     MVCL  R0,R6                     |   Copy Attribute to return-parm.
   ENDIF                             | EndIf.
   CALLSUB TRACE_SYMBOL,('SetAttr  ',NAME)
   DROP  R3,R4                       | Clean up on addressability.
 ENDBLK BLOCK=UPDATE_SYMBOL
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: FIND_SYMBOL                                            *
*  Abstract:   Scan the specified block for the symbol supplied by    *
*              the application program.  If found, the address of     *
*              the link pointer to the Name node will be returned in  *
*              R15.  This will either be the address of the header    *
*              link in the chain or the link of the previous name's   *
*              node.                                                  *
*  Parameters: Block Address.                                         *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=FIND_SYMBOL
   L  R3,0(R1)                         | R3 -> BLOCK node.
   L  R4,PRM_SY_NAME                   | R4 -> Text of symbol.
   L  R5,PRM_SY_LENGTH                 | R5 -> Length of symbol.
*---------------------------------------------------------------------*
*  If no (symbol,length) was supplied, use the Handle.
*---------------------------------------------------------------------*
   IF (TREG,R4,NZ)                     | If (Symbol,Length) supplied.
     ERREXIT (TREG,R5,Z),CODE=&SY_INVALID_NAME  No length supplied.
     ICM     R0,B'1111',0(R5)          |        R0 := supplied length.
     ERREXIT NP,CODE=&SY_INVALID_NAME  |        Non-positive length.
   ELSE                                | Else, use the handle.
     L  R3,PRM_SY_HANDLE               |   R3 -> Handle, if any.
     LA R3,0(R3)                       |   CLEAR HIGH ORDER BIT.
     ERREXIT (TREG,R3,Z),CODE=&SY_MISSING_NAME
     ERREXIT (CLC,=F'0',EQ,0(R3)),CODE=&SY_MISSING_NAME
     L       R4,PRM_SY_NAMEPTR         |   R4 -> Return name pointer.
     IF      (TREG,R4,NZ)              |   If NamePtr parm given.
       L     R1,0(R3)                  |     R1 -> Name node.
       USING NAME,R1                   |     Establish addressability.
       LA    R0,NAME_TEXT              |     Save address of name in
       ST    R0,0(R4)                  |     NamePtr.
       IF    (TREG,R5,NZ)              |     If Length parameter given.
         MVC 0(4,R5),NAME_SIZE         |       Save length of name.
       ENDIF                           |     EndIf.
       DROP  R1                        |     Clean up addressability.
     ENDIF                             |   EndIf.
     LEAVE BLOCK=*                     |   Return from subroutine.
   ENDIF                               | EndIf.
*---------------------------------------------------------------------*
*  Scan through the Name nodes of the application symbol's hash-bucket.
*---------------------------------------------------------------------*
   LA    R3,BLOCK_HASH-BLOCK(,R3) | Point to the hash table.
   A     R3,&PWA.HASHVALUE        | R3 -> Hash bucket header link.
   L     R5,0(R3)                 | R5 -> Current NAME node.
   USING NAME,R5                  | Establish addressability.
   LOOP WHILE,(TREG,R5,NZ)        | While more elements, loop.
     L   R14,PRM_SY_NAME          |   R14 -> Test Symbol Name.
     L   R15,PRM_SY_LENGTH        |   R15 -> Test Symbol Length.
     ICM R15,15,0(R15)            |   R15 := Test Symbol Length.
     LA  R6,NAME_TEXT             |   R6 -> Name Symbol's text.
     L   R7,NAME_SIZE             |   R7 := Name Symbol's Length.
     IF  (CR,R15,EQ,R7)           |   If lengths are equal then.
       IF  (CLI,&PWA.CAPS,EQ,C'N') |    If current mode = ASIS.
         LEAVE LOOP=*,(CLCL,R6,EQ,R14)    If equal, leave loop now.
       ELSE                       |     Else must fold to uppercase.
         LOOP WHILE,(C,R7,GE,=F'256')     While big hunks to compare.
           MVC   &PWA.SEGMENT,0(R14)        Copy hunk to PWA.
           TR    &PWA.SEGMENT,FOLD |        Fold to upper-case.
           LEAVE LOOP=*,(CLC,&PWA.SEGMENT,NE,0(R6)) Stop compare if NE.
           S     R7,=F'256'       |         Adjust remaining length.
           A     R14,=F'256'      |         Adjust source-pointer.
           A     R6,=F'256'       |         Adjust Symbol pointer.
         ENDLOOP WHILE            |       EndLoop.
         IF (C,R7,LT,=F'256')     |       If comparison not aborted.
           LEAVE LOOP=*,(TREG,R7,Z)         Leave if symbols equal.
           BCTR  R7,0             |         Subtract 1 for EX instr.
           EXI   R7,(MVC,&PWA.SEGMENT(0),0(R14))
           EXI   R7,(TR,&PWA.SEGMENT(0),FOLD)
           EXI   R7,(CLC,&PWA.SEGMENT(0),0(R6))
           LEAVE LOOP=*,EQ        |         Leave if symbols equal.
         ENDIF                    |       EndIf.
       ENDIF                      |     EndIf.
     ENDIF                        |   EndIf.
     LA    R3,NAME_LINK           |   Remember pointer to next node.
     L     R5,NAME_LINK           |   Point to next NAME element.
   ENDLOOP WHILE                  | EndWhile
   IF (TREG,R5,Z)                 | If the symbol was not located.
     LR  R3,R5                    |   Set A(LinkPtr) := 0;
   ELSE                           | Else.
     L   R2,PRM_SY_HANDLE         |   Point to handle parameter.
     IF  (TREG,R2,NZ)             |   If not a null parameter.
       ST  R5,0(R2)               |     Save name-node address.
     ENDIF                        |   EndIf.
     L   R2,PRM_SY_NAMEPTR        |   Point to return name pointer.
     IF  (TREG,R2,NZ)             |   If NamePtr parm given.
       LA  R0,NAME_TEXT           |     Save address of symbol's name.
       ST  R0,0(R2)               |
     ENDIF                        |   EndIf.
   ENDIF                          | EndIf.
   DROP R5                        | Clean up on addressability.
 ENDBLK BLOCK=FIND_SYMBOL,RC=((R3))
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: TRACE_SYMBOL                                           *
*  Abstract:   Format and issue a trace message for the given name    *
*              node.                                                  *
*  Parameters: (TextStr, NAME)                                        *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=TRACE_SYMBOL
   L       R2,0(R1)                     | R2 -> Function Name.
   L       R3,4(R1)                     | R3 -> Name node.
   USING   NAME,R3                      | Establish addressability.
   L       R4,NAME_BLOCK                | R4 -> Parent block.
   USING   BLOCK,R4                     | Establish addressability.
   LA      R5,=C' '                     | Symbol length <= 60.
   IF      (CLC,NAME_SIZE,GT,=F'60')    | If not true, then.
     LA    R5,=C'+'                     |   Indicate > 60.
   ENDIF                                | EndIf.
   CALLSUB TRACE,(TM_SYMBOL,0(R2),BLOCK_NUMBER,BLOCK_LEVEL,            +
               NAME_TEXT,NAME_SIZE,0(R5))
   IF (CLC,&PWA.ATTRSIZE,NE,=F'0')      | If symbols have attributes.
     LA      R6,NAME_TEXT                 |
     AL      R6,NAME_SIZE                 | R6 -> Attribute value.
     LA      R7,=C' '                     | Attribute length <= 30.
     IF      (CLC,&PWA.ATTRSIZE,GT,=F'30') | If not true, then.
       LA    R7,=C'+'                     |   Indicate > 30.
     ENDIF                                | EndIf.
     CALLSUB TRACE,(TM_ATTR,0(R6),&PWA.ATTRSIZE,0(R7))
   ENDIF
 ENDBLK BLOCK=TRACE_SYMBOL
 EJECT
***********************************************************************
*                                                                     *
*  Subroutine: TRACE                                                  *
*  Abstract:   Format and issue a trace message with the provided     *
*              arguments.                                             *
*  Parameters: (MessageAddr, formatting arguments)                    *
*                                                                     *
***********************************************************************
 BLOCK TYPE=SUBROUTINE,NAME=TRACE
   LEAVE BLOCK=*,(TBIT,&PWA.F_TRACE,OFF)
*---------------------------------------------------------------------*
*  Invoke the String Handler format function to format a message.
*---------------------------------------------------------------------*
   LR    R2,R1                      | R2 -> Parameter List.
   LOOP  WHILE,(TBIT,0(R1),X'80',OFF) While not at last parameter.
     LA    R1,4(,R1)                |   Advance to next parameter.
   ENDLOOP WHILE                    | EndLoop.
   SLR     R1,R2                    | R1 := length of argument list.
   SRL     R1,2                     | R1 := number of arguments.
   ST      R1,&W.ARGCOUNT           | Save argument count.
*                                   |
   L         R3,0(R2)               | R3 -> Trace message to format.
   ST_FORMAT ID=ST,STRING=&W.DATA,RESULTLEN=&W.LEN,                    +
               CONTROL=(4(R3),0(R3)),SOURCELIST=(4(R2),&W.ARGCOUNT)
*---------------------------------------------------------------------*
*    Issue the error message formatted above.
*---------------------------------------------------------------------*
   ES_DISPLAY_MESSAGE ID=ES,MESSAGE=(&W.DATA,&W.LEN)
 ENDBLK BLOCK=TRACE
 SPACE
*---------------------------------------------------------------------*
* Working storage needed for the FORMAT interface.
*---------------------------------------------------------------------*
             SWA
&W.ARGCOUNT  DS  F              | Amount formatted in last call.
&W.LEN       DS  F              | Length of formatted message.
&W.DATA      DS  CL255          | Target area for formatted message.
             ENDSWA
             EJECT
***********************************************************************
*                                                                     *
*  Exit with a return code equal to the current contents of R14.      *
*                                                                     *
***********************************************************************
 BLOCK TYPE=ERREXIT
*---------------------------------------------------------------------*
*  Save module/offset, registers, return-code.
*---------------------------------------------------------------------*
   STM   R0,R15,GDIREGS          | Save registers at time of error.
   SM_LAL R0,&srv_modname+4      | Point to module identification.
   ST    R0,GDIMODID             | Save in general debug area.
   MVC   GDIRC,0(R14)            | Copy return code.
   SL    R14,=A(&srv_modname)    | Calculate offset at time of error.
   STH   R14,GDIOFFST            | Save in debug area.
   ES_SAVE_DEBUG_INFO ID=ES,GDI=GDI
*---------------------------------------------------------------------*
*  Exit with the terminating return code.
*---------------------------------------------------------------------*
   L       R2,PRM_FUNCTIONCODE
   CALLSUB TRACE,(TM_ERROR,0(R2),GDIRC)
   LH   R15,GDIRC                   | Set return-code on exit.
 ENDBLK
 EJECT
*---------------------------------------------------------------------
*
*  Static Data
*
*---------------------------------------------------------------------
                 PSD
EYECATCHER       DC   C'SYM '      | Value moved to PWA on initialize.
MAX_NAME_LENGTH  DC   F'16777215'  | Maximum length of a symbol name.
                 MACRO
&LABEL           TRANTAB
                 LCLA &N
&LABEL           DS 0XL256        |
.NEWROW          DC AL1(&N+0,&N+1,&N+2,&N+3,&N+4,&N+5,&N+6,&N+7)
                 DC AL1(&N+8,&N+9,&N+10,&N+11,&N+12,&N+13,&N+14,&N+15)
&N               SETA &N+16
                 AIF  (&N LT 256).NEWROW
                 MEND
FOLD             TRANTAB           | Translate tbl for uppercase conv.
                 ORG  FOLD+C'a'    | Fold lowercase 'a' - 'i'.
                 DC   C'ABCDEFGHI' |
                 ORG  FOLD+C'j'    | Fold lowercase 'j' - 'r'.
                 DC   C'JKLMNOPQR' |
                 ORG  FOLD+C's'    | Fold lowercase 's' - 'z'.
                 DC   C'STUVWXYZ'  |
                 ORG
                 MACRO
&LABEL           MSG  &TEXT
&LABEL           DC   A(L'MSG&SYSNDX)
MSG&SYSNDX       DC   C&TEXT
                 MEND
TM_START  MSG 'SRVSY: Start : Attrsize={I} Mode={CL4} HashSize={I}, Mem+
               Incr={I}.'
TM_TERMINATE MSG 'SRVSY: Terminate.'
TM_SYMBOL MSG 'SRVSY: {CL10 T R} :{03I}/{03I}: "{.60CL? T}"{C T}.'
TM_ATTR   MSG '       Attribute {.60XL? T}{C T}.'
TM_TRACE  MSG 'SRVSY: Trace : ON.'
TM_BLOCK  MSG 'SRVSY: {CL6 T}Block : BlockNumber={I} New NestLevel={I}.+
               '
TM_ERROR  MSG 'SRVSY: Ending from function {I} with error code {IL2}.'
                 LTORG
                 ENDPSD
                 EJECT
*---------------------------------------------------------------------*
*
*  Program Work Area
*
*---------------------------------------------------------------------*
                  PWA
&PWA.AREA         DS  0F           | Beginning of visible PWA stg.
&PWA.VISUAL       DS  CL4          | Character string 'SYM '.
&PWA.TABLEID      DS  A            | Unique table identifier.
PWA_#PARMS        DS  F            | Number of parameters passed in.
&PWA.ES_SPEPA     DS  A            | Environment Support's EPA.
&PWA.ES_SPTOKEN   DS  F            | Environment Support's TOKEN.
&PWA.F            DS  X            | Housekeeping flags.
&PWA.F_USEABLE    EQU X'80'        | Symbol table is useable.
&PWA.F_TRACE      EQU X'40'        | Tracing is active.
&PWA.CAPS         DS  C            | Caps mode ON/OFF = Y | N.
&PWA.MEMINCR      DS  F            | Memory heap increment.
&PWA.ATTRSIZE     DS  F            | Size of a symbol's attribute.
&PWA.HIGH_BLOCK#  DS  F            | Block# of newest block.
&PWA.NEST_LEVEL   DS  F            | Nesting level of current block.
&PWA.BLOCK_SIZE   DS  F            | Total size of a block node.
&PWA.HASHSIZE     DS  A            | Number of hash slots in a block.
&PWA.HASHVALUE    DS  F            | Current symbol's Hash value.
&PWA.ROOT_BLOCK   DS  A            | Root block of symbol-table.
&PWA.OPEN_BLOCKS  DS  A            | List of open blocks.
&PWA.WORK1        DS  F            |
&PWA.WORK2        DS  F            |
&PWA.SEGMENT      DS  CL256        | Area for folding to CAPS.
                  ES_GDI DSECT=NO  | Debugging information.
&PWA.AREA_L       EQU *-&PWA.AREA  | Length of visible PWA stg.
                  ENDPWA
                  EJECT
*---------------------------------------------------------------------
*
*  Symbol Table DSECTs.
*
*---------------------------------------------------------------------
BLOCK         DSECT                   | Describes one block's symbols.
BLOCK_PARENT  DS     A                | Link to parent block.
BLOCK_SIBLING DS     A                | Link to next sibling block.
BLOCK_CHILD   DS     A                | Link to first child block.
BLOCK_CHILDL  DS     A                | Link to last child block.
BLOCK_NUMBER  DS     A                | Unique block identifier.
BLOCK_LEVEL   DS     A                | Nesting level of this block.
BLOCK_HASH    DS     0A               | Hash array for name lists.
BLOCK_HASH_L  EQU    4                | Size of one hash-slot.
BLOCK_L       EQU    *-BLOCK          | Length of structure.
*
NAME          DSECT                   | Describes one symbol.
NAME_LINK     DS     A                | Pointer to next NAME.
NAME_BLOCK    DS     A                | Pointer to owning block.
NAME_SIZE     DS     F                | Size of name's text string.
NAME_TEXT     DS     0C               | Actual text of symbol's name.
NAME_ATTR     DS     0X               | Application supplied attribute.
NAME_L        EQU    *-NAME           | Length of one name block.
              EJECT
*---------------------------------------------------------------------
*  Environment Support Vector
*---------------------------------------------------------------------
              ES_ESV
              EJECT
*---------------------------------------------------------------------
*  Parameter list for the symbol manager
*---------------------------------------------------------------------
PARMLIST          DSECT
PRM_TABLEID       DS  A             | Table identifier === PWA base.
PRM_FUNCTIONCODE  DS  A             | Function to be performed.
PRM_SPECIFIC      EQU *             | Function dependent parameters:
                  ORG PRM_SPECIFIC  | SY_START parameters:
PRM_S_ESV         DS  A             |   Server Global Area.
PRM_S_ATTRSIZE    DS  A             |   Size of Attr field of symbols.
PRM_S_CAPS        DS  A             |   Default Caps mode.
PRM_S_HASHSIZE    DS  A             |   Number of hash table slots.
PRM_S_MEMINCR     DS  A             |   Increment value for memory mgr.
PRM_S_TRACE       DS  A             |   Trace 'ON' or trace 'OFF'.
                  ORG PRM_SPECIFIC  | SY_TRACE parameters:
PRM_T_ONOFF       DS  A             |   'ON' or 'OFF' for tracing.
                  ORG PRM_SPECIFIC  | SY_OPEN_BLOCK and SY_CLOSE_BLOCK:
PRM_BL_BLOCK#     DS  A             |   Return Block# of new block.
PRM_BL_NESTLEVEL  DS  A             |   Return nesting of new block.
                  ORG PRM_SPECIFIC  | SY_INSTALL LOCATE UPDATE DELETE:
PRM_SY_NAME       DS  A             |   Symbol's name.
PRM_SY_LENGTH     DS  A             |   Symbol's length.
PRM_SY_HANDLE     DS  A             |   Symbol's handle.
*                                   |   Not used by SY_DELETE:
PRM_SY_ATTR       DS  A             |     Symbol's attribute value.
PRM_SY_NAMEPTR    DS  A             |     Address of symbol's name.
                  ORG ,             | Get back to right address.
PARMLIST_L        EQU *-PARMLIST    | Total size of parmlist.
                  END
