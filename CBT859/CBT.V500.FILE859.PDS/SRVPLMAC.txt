*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
 TITLE 'SRVPLMAC: Item Manager Service Processor Symbols && Macros.'
*---------------------------------------------------------------------*
*
*  Copy File:  SRVPLMAC
*
*  Purpose:    Print_Line service processor symbols and macros.
*
*  Description: See "Service Processors User's Guide and Reference".
*
*  Change
*  History:    09/12/89 JCB - New
*              05/02/95 MGG - Added file handler support.
*              09/06/95 MSA - Added keyword REFERENCE to PL_START and
*                             added macro PL_GET_REFERENCE.
*              11/14/96 REM - Added PL_INVALID_MAXLINESIZE,
*                             PL_INVALID_LRECL, and
*                             PL_LINE_WRAPPING codes.
*
*---------------------------------------------------------------------*
*
***********************************************************************
***********************************************************************
**                                                                   **
**                     Symbol Definitions                            **
**                                                                   **
***********************************************************************
***********************************************************************
 GBLC &PRINT_LINE,&MVS_PRINT_LINE
 GBLA &PL_START,&PL_TERMINATE
 GBLA &PL_SET_HEADER,&PL_SET_FORMATTED_HEADER,&PL_RESET_HEADER
 GBLA &PL_SET_FOOTER,&PL_SET_FORMATTED_FOOTER,&PL_RESET_FOOTER
 GBLA &PL_RESERVE_FOOTER
 GBLA &PL_PAGE_BREAK,&PL_PRINT,&PL_PRINT_FORMATTED
 GBLA &PL_QUERY_LINES_LEFT
 GBLA &PL_GET_INFO
 GBLA &PL_GET_REFERENCE
*
 GBLA &PL_SUCCESS
 GBLA &PL_INVALID_FUNCTION
 GBLA &PL_INVALID_NUMBER_OF_PARMS
 GBLA &PL_INVALID_PL_ID
 GBLA &PL_MEMORY_MANAGER_ERROR
 GBLA &PL_CANNOT_OPEN_DCB
 GBLA &PL_FILE_HANDLER_ERROR
 GBLA &PL_ENVIRONMENT_SUPPORT_ERROR
 GBLA &PL_STRING_HANDLER_ERROR
 GBLA &PL_PRINT_LINE_TRUNCATED
 GBLA &PL_PAGE_OVERFLOW
 GBLA &PL_HEADER_NOT_FOUND
 GBLA &PL_FOOTER_NOT_FOUND
 GBLA &PL_INVALID_PAGEDISP
 GBLA &PL_INVALID_SIZELENGTH
 GBLA &PL_MISSING_PARAMETER
 GBLA &PL_HEADER_LINE_TRUNCATED
 GBLA &PL_FOOTER_LINE_TRUNCATED
 GBLA &PL_INVALID_GI_SUBCODE
 GBLA &PL_INVALID_MAXLINESIZE
 GBLA &PL_INVALID_LRECL
 GBLA &PL_LINE_WRAPPING
 GBLA &PL_INTERNAL_ERROR
*
 GBLA &PL_GI_LRECL
 GBLA &PL_GI_RECFM
 GBLA &PL_GI_FIMSG
 GBLA &PL_GI_FIRC
*
* Entry point name for the Item Manager.
*
&PRINT_LINE                             SETC '''SRVPL   '''
&MVS_PRINT_LINE                         SETC '''SRVPLMVS'''
*
* Function codes.
*
&PL_START                               SETA 1
&PL_TERMINATE                           SETA 2
&PL_SET_HEADER                          SETA 3
&PL_SET_FORMATTED_HEADER                SETA 4
&PL_RESET_HEADER                        SETA 5
&PL_SET_FOOTER                          SETA 6
&PL_SET_FORMATTED_FOOTER                SETA 7
&PL_RESET_FOOTER                        SETA 8
&PL_RESERVE_FOOTER                      SETA 9
&PL_PAGE_BREAK                          SETA 10
&PL_PRINT                               SETA 11
&PL_PRINT_FORMATTED                     SETA 12
&PL_QUERY_LINES_LEFT                    SETA 13
&PL_GET_INFO                            SETA 14
&PL_GET_REFERENCE                       SETA 15
*
* Informational codes for use with PL_GET_INFO.
*
&PL_GI_LRECL            SETA 1          Get the file's logical rec len.
&PL_GI_FIMSG            SETA 2          Get file handler's message.
&PL_GI_FIRC             SETA 3          Get file handler's retcode.
&PL_GI_RECFM            SETA 4          Get the file's record format.
*
* Return codes.
*
&PL_SUCCESS                             SETA  0
&PL_INVALID_FUNCTION                    SETA  1
&PL_INVALID_NUMBER_OF_PARMS             SETA  2
&PL_INVALID_PL_ID                       SETA  3
&PL_MEMORY_MANAGER_ERROR                SETA  4
&PL_CANNOT_OPEN_DCB                     SETA  5
&PL_FILE_HANDLER_ERROR                  SETA  5 Same as CANNOT_OPEN_DCB
&PL_ENVIRONMENT_SUPPORT_ERROR           SETA  6
&PL_STRING_HANDLER_ERROR                SETA  7
&PL_PRINT_LINE_TRUNCATED                SETA  8
&PL_PAGE_OVERFLOW                       SETA  9
&PL_HEADER_NOT_FOUND                    SETA 10
&PL_FOOTER_NOT_FOUND                    SETA 11
&PL_INVALID_PAGEDISP                    SETA 12
&PL_INVALID_SIZELENGTH                  SETA 13
&PL_MISSING_PARAMETER                   SETA 14
&PL_HEADER_LINE_TRUNCATED               SETA 15
&PL_FOOTER_LINE_TRUNCATED               SETA 16
&PL_INVALID_GI_SUBCODE                  SETA 17
&PL_INVALID_MAXLINESIZE                 SETA 18
&PL_INVALID_LRECL                       SETA 19
&PL_LINE_WRAPPING                       SETA 20
&PL_INTERNAL_ERROR                      SETA 21
*
* DEFUCOND macros to facilitate checking return codes. If new return
* codes are added, don't forget to add a DEFUCOND for them.
*
   DEFUCOND MACRO=SRV##RC,NAME=PL_SUCCESS
   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_FUNCTION
   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_NUMBER_OF_PARMS
   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_PL_ID
   DEFUCOND MACRO=SRV##RC,NAME=PL_MEMORY_MANAGER_ERROR
   DEFUCOND MACRO=SRV##RC,NAME=PL_CANNOT_OPEN_DCB
   DEFUCOND MACRO=SRV##RC,NAME=PL_FILE_HANDLER_ERROR
   DEFUCOND MACRO=SRV##RC,NAME=PL_ENVIRONMENT_SUPPORT_ERROR
   DEFUCOND MACRO=SRV##RC,NAME=PL_STRING_HANDLER_ERROR
   DEFUCOND MACRO=SRV##RC,NAME=PL_PRINT_LINE_TRUNCATED
   DEFUCOND MACRO=SRV##RC,NAME=PL_PAGE_OVERFLOW
   DEFUCOND MACRO=SRV##RC,NAME=PL_HEADER_NOT_FOUND
   DEFUCOND MACRO=SRV##RC,NAME=PL_FOOTER_NOT_FOUND
   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_PAGEDISP
   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_SIZELENGTH
   DEFUCOND MACRO=SRV##RC,NAME=PL_MISSING_PARAMETER
   DEFUCOND MACRO=SRV##RC,NAME=PL_HEADER_LINE_TRUNCATED
   DEFUCOND MACRO=SRV##RC,NAME=PL_FOOTER_LINE_TRUNCATED
   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_GI_SUBCODE
   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_MAXLINESIZE
   DEFUCOND MACRO=SRV##RC,NAME=PL_INVALID_LRECL
   DEFUCOND MACRO=SRV##RC,NAME=PL_LINE_WRAPPING
*
* Miscellaneous definitions.
*
 GBLA   &PL_DEFAULT_PAGESIZE
 GBLA   &PL_DEFAULT_MAXLINESIZE
 GBLA   &PL_DEFAULT_SIZELENGTH
&PL_DEFAULT_PAGESIZE        SETA  66
&PL_DEFAULT_MAXLINESIZE     SETA  133
&PL_DEFAULT_SIZELENGTH      SETA  4
                        EJECT
***********************************************************************
***********************************************************************
**                                                                   **
**                     Macro Definitions                             **
**                                                                   **
***********************************************************************
***********************************************************************
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_ID                                                      *
*                                                                     *
* Purpose: Establish default values for a specific service processor  *
*          and associate them with the specified ID name. The values  *
*          are stored in the following created global variables:      *
*                                                                     *
* Variable Name                     Description                       *
* -------------  ---------------------------------------------------- *
* #$&ID.$#IDMAC  Name of macro that created the ID: PL_ID.            *
* #$&ID.$#ESID   Service processor's Environment Support ID.          *
* #$&ID.$#EPN    Tag for Service processor's Entry Point Name.        *
* #$&ID.$#EPA    Tag for Service processor's Entry Point Address.     *
* #$&ID.$#TKN    Tag for Service processor's Entry Point Token.       *
* #$&ID.$#EMC    Tag for Service processor's error macro name.        *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_ID &ID=,&ESVA=,&SPEPNAME=,&SPEPA=,&SPTOKEN=,&ESID=,        *
               &SIZELENGTH=,&ERRMAC=
         LCLC  &L_EPNAME
         GBLC  &PRINT_LINE
.*
.* If no EPNAME was specified, use the generic PrintLine.
.*
&L_EPNAME SETC '&SPEPNAME'
          AIF  ('&L_EPNAME' NE '').PAST_EPN
&L_EPNAME SETC '&PRINT_LINE'
.PAST_EPN ANOP
.*
.* Invoke SRV##ID to create globals used by all ID's.
.*
         SRV##ID SET,                                                  +
               ID=&ID.,IDMAC=PL_ID,ESID=&ESID.,SPEPNAME=&L_EPNAME,     +
               SPEPA=&SPEPA,SPTOKEN=&SPTOKEN.,ERRMAC=&ERRMAC.
.*
.* Establish defaults for parameters specific to the string handler.
.*
&PL_SIZELENGTH   SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.
                 GBLC &(&PL_SIZELENGTH)     Declare global variable.
&(&PL_SIZELENGTH) SETC '4'                  Set sizelength's default.
                 AIF  ('&SIZELENGTH' EQ '').GOT_SIZELENGTH
                 AIF  (T'&SIZELENGTH EQ 'N').SL_NUMERIC
                 MNOTE 8,'If SIZELENGTH is specified on the ST_ID macro+
               , it must be a self-defining numeric value.'
                 AGO   .GOT_SIZELENGTH
.SL_NUMERIC      ANOP
&(&PL_SIZELENGTH) SETC '&SIZELENGTH'        Copy value (or nulls).
.GOT_SIZELENGTH  ANOP
         MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_START                                                   *
* Purpose: Generate code to start a new Print_Line session.           *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_START &ID=,&SPEPA=,&SPTOKEN=,&ESVA=,&ERRMAC=,              +
               &DDNAME=,                                               *
               &SIZELENGTH=,                                           *
               &PAGESIZE=60,                                           *
               &MAXLNSZ=133,                                           *
               &OPTIONS=,                                              *
               &REFERENCE=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_START                  SETC in open code.
         LCLA  &I
         LCLB  &OPT_FOLD
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN,ESVA),                    +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ESVA=&ESVA.,ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
         MVC   &#_IDTKN,=F'0'            | Insure TOKEN = 0.
.*
.* Validate the incoming parameters.
.*
.*
.* Decode the options and produce a byte flag for the parmlist.
.*
&I       SETA  1
.OPTLOOP AIF   (&I GT N'&OPTIONS).PASTOPT
         AIF   ('&OPTIONS(&I)' EQ 'FOLD').OPT1
         MNOTE 8,'Invalid option name: &OPTIONS(&I)'
.OPT1    ANOP
&OPT_FOLD SETB 1
         AGO   .NEXTOPT         Go process the next option.
.*
.*  Add additional options here.
.*
.NEXTOPT ANOP
&I       SETA  &I+1             Increment index into options list.
         AGO   .OPTLOOP         Branch back to top of loop.
.PASTOPT ANOP
&OPTSTR  SETC '&OPT_FOLD'
&OPTSTR  SETC '&OPTSTR.0000000'
         AIF  ('&OPTSTR' NE '00000000').NOT_NOP
&OPTSTR  SETC ''
         AGO  .PAST_OPTSTR_SET
.NOT_NOP ANOP
&OPTSTR  SETC '=B''&OPTSTR'''
.PAST_OPTSTR_SET ANOP
.*
         AIF   ('&DDNAME' NE '').DDOK
         MNOTE 8,'DDname must be specified.'
         MEXIT
.DDOK    ANOP
.*       AIF   (T'&PAGESIZE EQ 'N' AND &PAGESIZE LE 66).PGSZOK
.*       MNOTE 8,'Pagesize must be numeric and have a value of 66 or le
.*             ss.'
.*       MEXIT
.PGSZOK  ANOP
.*       AIF   (T'&MAXLNSZ EQ 'N' AND &MAXLNSZ LE 255).LNSZOK
.*       MNOTE 8,'MaxLnSz must be numeric and have a value of 255 or le
.*             ss.'
.*       MEXIT
.LNSZOK  ANOP
.*
.* Obtain the value for the SIZELENGTH keyword.
.*
&PL_SIZELENGTH   SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.
                 GBLC &(&PL_SIZELENGTH)     Declare global variable.
&L_SIZELENGTH    SETC '&(&PL_SIZELENGTH)'   Set default value.
                 AIF  ('&L_SIZELENGTH' EQ '').SL_OKAY
                 AIF  ('&SIZELENGTH' EQ '').SL_DONE
                 AIF  ('&L_SIZELENGTH' EQ '&SIZELENGTH').SL_DONE
*                MNOTE 4,'Warning: SIZELENGTH was specified with a diff
*              erent value on the ST_ID ID=&ID. instruction.'
.SL_OKAY         ANOP
&L_SIZELENGTH    SETC '&SIZELENGTH'
&(&PL_SIZELENGTH) SETC '&SIZELENGTH'     Set default value.
.SL_DONE         ANOP
.*
.* Generate the PL_START call.
.*
.*       CALLX &#_IDEPA,(&#_IDTKN,&PL_START,&#_IDESVA,&DDNAME,
.*             &PAGESIZE,&MAXLNSZ,&(&PL_SIZELENGTH)),VL
         ##PLIST START
         ##PLIST PARM,&#_IDTKN
         ##PLIST PARM,&PL_START
         ##PLIST PARM,&#_IDESVA
         ##PLIST PARM,&DDNAME
         ##PLIST PARM,&PAGESIZE
         ##PLIST PARM,&MAXLNSZ
         ##PLIST PARM,&(&PL_SIZELENGTH)
         AIF   ('&OPTSTR' EQ '' AND '&REFERENCE' EQ '').CALLEND
         ##PLIST PARM,&OPTSTR
         AIF   ('&REFERENCE' EQ '').CALLEND
         ##PLIST PARM,&REFERENCE
.CALLEND ANOP ,
         ##PLIST END,VL
         CALLX  &#_IDEPA
         AIF    ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_TERMINATE                                               *
* Purpose: Generate code to terminate a Print_Line session.           *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_TERMINATE &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_TERMINATE              SETC in open code.
.*
.* Obtain service processor ID values and terminate service processor.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
         CALLX &#_IDEPA,(&#_IDTKN,&PL_TERMINATE),VL
         AIF    ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_SET_HEADER                                              *
* Purpose: Establish a header line from a simple print line.          *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_SET_HEADER &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                +
               &LINE=0,                                                +
               &STRING=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_SET_HEADER
         LCLC  &S_ADDR,&S_LEN
         LCLC  &V_STRING(2),&PL_SIZELENGTH
         LCLC  &L_STRING(2)
         LCLA  &N
         LCLC  &KEYWORD
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE
         MNOTE 8,'SRV##ID unable to set global variables.'
         MEXIT
.VALIDATE ANOP
.*
.* Validate incoming parameters.
.*
         AIF   (T'&LINE EQ 'N').LINEOK
         AIF   ('&LINE' NE '').LINEOK
.LINEBAD MNOTE 8,'Line must be specified as the address of a fullword o*
               r a numeric value.'
         MEXIT
.LINEOK  ANOP
&PL_SIZELENGTH SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.
               GBLC &(&PL_SIZELENGTH)     Declare global variable.
.*
.* If STRING= is missing, supply default values.
.*
&L_STRING(1)    SETC '&STRING(1)'
&L_STRING(2)    SETC '&STRING(2)'
                AIF ('&L_STRING(1)' NE '').STRING_NBLK
&V_STRING(1)    SETC '#$&ID.$#STRING1'     Variable for STRING=.
&V_STRING(2)    SETC '#$&ID.$#STRING2'     Variable for STRING=.
                GBLC &(&V_STRING(1))       Declare global variable.
                GBLC &(&V_STRING(2))       Declare global variable.
&L_STRING(1)    SETC '&(&V_STRING(1))'     Copy default value.
&L_STRING(2)    SETC '&(&V_STRING(2))'     Copy default value.
.STRING_NBLK    ANOP
.*
.*
.* Process the STRING keyword to get an address and length.
.*
&KEYWORD      SETC 'STRING'
              AIF ('&L_STRING(1)' EQ '').NO_STRING
              AIF ('&L_STRING(1)'(1,1) EQ '''').STR_LITERAL
              AIF ('&L_STRING(2)' EQ '').STR_TAGONLY
.STR_TAGLEN   ANOP
&S_ADDR       SETC '&L_STRING(1)'         | Set addr.
&S_LEN        SETC '&L_STRING(2)'         | Set len.
              AGO  .PAST_STRING           |
.STR_TAGONLY  AIF  ('&(&PL_SIZELENGTH)' EQ '').NO_SIZELENGTH
&S_ADDR       SETC '&L_STRING(1)'         | Set addr to tag_name.
&S_LEN        SETC '=AL&(&PL_SIZELENGTH).(L''&L_STRING(1))'
              AGO  .PAST_STRING           |
.STR_LITERAL  ANOP                        |
&S_ADDR         SETC '&L_STRING(1)'         | Set addr to value.
&L              SETA 0                      | Length counter = 0.
&I              SETA 2                      | Index counter -> past '.
.STR_LOOP       AIF  (&I GE K'&S_ADDR).STR_ELOOP     Loop over STRING.
                AIF  ('&S_ADDR'(&I,1) NE '''').STR_TXT If doubled.
&I              SETA &I+1                   |             Advance.
.STR_TXT        ANOP                        |          EndIf.
&L              SETA &L+1                   |   Add one to length.
&I              SETA &I+1                   |   Advance.
                AGO  .STR_LOOP              | End of counting loop.
.STR_ELOOP      ANOP                        |
&S_LEN          SETC '=AL&(&PL_SIZELENGTH).(&L)' Set length parameter.
                AGO  .PAST_STRING
.NO_STRING    MNOTE 8,'STRING is a required keyword.'
              MEXIT
.PAST_STRING  ANOP
.*
.* Generate the call to PL_SET_HEADER.
.*
.CALL    ANOP
         CALLX &#_IDEPA,(&#_IDTKN,&PL_SET_HEADER,                      +
               &LINE,&S_ADDR,&S_LEN),VL
         AIF    ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
         MEXIT
.NO_SIZELENGTH ANOP
         MNOTE 8,'Explicit lengths must be specified unless the SIZELEN+
               GTH keyword has been coded on the ST_ID macro.'
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_SET_FORMATTED_HEADER                                    *
* Purpose: Establish a header line from a format string and a set     *
*          of substitution values.                                    *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_SET_FORMATTED_HEADER &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,      *
               &LINE=0,                                                *
               &CONTROL=,                                              *
               &SOURCE=,                                               *
               &PAGENUM=0
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_SET_FORMATTED_HEADER
         LCLC  &C_ADDR,&C_LEN
         LCLC  &V_CONTROL(2),&PL_SIZELENGTH
         LCLC  &L_CONTROL(2)
         LCLA  &N
         LCLC  &KEYWORD
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE
         MNOTE 8,'SRV##ID unable to set global variables.'
         MEXIT
.VALIDATE ANOP
.*
.*
.* Validate incoming parameters.
.*
         AIF   (T'&LINE EQ 'N').LINEOK
         AIF   ('&LINE' NE '').LINEOK
.LINEBAD MNOTE 8,'Line must be specified as the address of a fullword o*
               r a numeric value.'
         MEXIT
.LINEOK  ANOP
.*
&PL_SIZELENGTH SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.
               GBLC &(&PL_SIZELENGTH)     Declare global variable.
.*
.* If CONTROL= is missing, supply default values.
.*
&L_CONTROL(1)   SETC '&CONTROL(1)'
&L_CONTROL(2)   SETC '&CONTROL(2)'
                AIF ('&L_CONTROL(1)' NE '').CONTROL_NBLK
&V_CONTROL(1)   SETC '#$&ID.$#CONTROL1'    Variable for CONTROL=.
&V_CONTROL(2)   SETC '#$&ID.$#CONTROL2'    Variable for CONTROL=.
                GBLC &(&V_CONTROL(1))      Declare global variable.
                GBLC &(&V_CONTROL(2))      Declare global variable.
&L_CONTROL(1)   SETC '&(&V_CONTROL(1))'    Copy default value.
&L_CONTROL(2)   SETC '&(&V_CONTROL(2))'    Copy default value.
.CONTROL_NBLK   ANOP
.*
.*
.* Process the CONTROL keyword to get an address and length.
.*
&KEYWORD      SETC 'CONTROL'
              AIF ('&CONTROL' EQ '').NO_CONTROL
              AIF (N'&CONTROL EQ 1).CTL_TAGONLY  CONTROL=tag.
              AIF (N'&CONTROL EQ 2).CTL_TAGLEN   CONTROL=(tag,len).
              MNOTE 8,'Too many subparameters for CONTROL keyword.'
              MEXIT
.*
.CTL_TAGLEN   ANOP
&C_ADDR       SETC '&CONTROL(1)'          | Set addr.
&C_LEN        SETC '&CONTROL(2)'          | Set len.
              AGO  .PAST_CONTROL          |
.CTL_TAGONLY  AIF  ('&(&PL_SIZELENGTH)' EQ '').NO_SIZELENGTH
              AIF  ('&CONTROL'(1,1) EQ '''').CTL_LITERAL
&C_ADDR       SETC '&CONTROL'             | Set addr to tag_name.
&C_LEN        SETC '=AL&(&PL_SIZELENGTH).(L''&CONTROL)' Get tag length.
              AGO  .PAST_CONTROL          |
.CTL_LITERAL  ANOP                        |
&C_ADDR       SETC '&CONTROL'             | Set addr to actual literal.
&L            SETA 0                      | Length counter = 0.
&I            SETA 2                      | Index counter -> past '.
.CTL_LOOP     AIF  (&I GE K'&C_ADDR).CTL_ELOOP       Loop over CONTROL.
              AIF  ('&C_ADDR'(&I,1) NE '''').CTL_TXT If doubled quotes.
&I            SETA &I+1                   |            Advance past '.
.CTL_TXT      ANOP                        |          EndIf.
&L            SETA &L+1                   |   Add one to length.
&I            SETA &I+1                   |   Advance to next position.
              AGO  .CTL_LOOP              | End of counting loop.
.CTL_ELOOP    ANOP                        |
&C_LEN        SETC '=AL&(&PL_SIZELENGTH).(&L)' Set length parameter.
              AGO  .PAST_CONTROL
.NO_CONTROL   MNOTE 8,'CONTROL is a required keyword.'
              MEXIT
.PAST_CONTROL ANOP
.*
.* Generate the format call to the CONTROL handler.
.*
         ##PLIST START
         ##PLIST PARM,&#_IDTKN
         ##PLIST PARM,&PL_SET_FORMATTED_HEADER
         ##PLIST PARM,&LINE
         ##PLIST PARM,&C_ADDR
         ##PLIST PARM,&C_LEN
         ##PLIST PARM,&PAGENUM
&N       SETA  1
.PL_LOOP ANOP
         AIF   (&N GT N'&SOURCE).PL_LOOPEND
         ##PLIST PARM,&SOURCE(&N)
&N       SETA  &N+1
         AGO   .PL_LOOP
.PL_LOOPEND ANOP ,
         ##PLIST END,VL
         CALLX  &#_IDEPA
         AIF    ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
         MEXIT
.NO_SIZELENGTH ANOP
         MNOTE 8,'Explicit lengths must be specified unless the SIZELEN+
               GTH keyword has been coded on the ST_ID macro.'
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_RESET_HEADER                                            *
* Purpose: Delete the definition for one or all header lines.         *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_RESET_HEADER &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,              +
               &LINE=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_RESET_HEADER
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE
         MNOTE 8,'SRV##ID unable to set global variables.'
         MEXIT
.VALIDATE ANOP
.*
.* Validate incoming parameters.
.*
         AIF   (T'&LINE EQ 'N').LINEOK
         AIF   ('&LINE' NE '').LINEOK
.LINEBAD MNOTE 8,'Line must be specified as the address of a fullword o*
               r a numeric value.'
         MEXIT
.LINEOK  ANOP
.*
.* Generate the call to PL_RESET_HEADER.
.*
.CALL    ANOP
         CALLX &#_IDEPA,(&#_IDTKN,&PL_RESET_HEADER,                    +
               &LINE),VL
         AIF    ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_SET_FOOTER                                              *
* Purpose: Establish a footer line from a simple print line.          *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_SET_FOOTER &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                +
               &LINE=0,                                                +
               &STRING=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_SET_FOOTER
         LCLC  &S_ADDR,&S_LEN
         LCLC  &V_STRING(2),&PL_SIZELENGTH
         LCLC  &L_STRING(2)
         LCLA  &N
         LCLC  &KEYWORD
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE
         MNOTE 8,'SRV##ID unable to set global variables.'
         MEXIT
.VALIDATE ANOP
.*
.* Validate incoming parameters.
.*
         AIF   (T'&LINE EQ 'N').LINEOK
         AIF   ('&LINE' NE '').LINEOK
.LINEBAD MNOTE 8,'Line must be specified as the address of a fullword o*
               r a numeric value.'
         MEXIT
.LINEOK  ANOP
&PL_SIZELENGTH SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.
               GBLC &(&PL_SIZELENGTH)     Declare global variable.
.*
.* If STRING= is missing, supply default values.
.*
&L_STRING(1)    SETC '&STRING(1)'
&L_STRING(2)    SETC '&STRING(2)'
                AIF ('&L_STRING(1)' NE '').STRING_NBLK
&V_STRING(1)    SETC '#$&ID.$#STRING1'     Variable for STRING=.
&V_STRING(2)    SETC '#$&ID.$#STRING2'     Variable for STRING=.
                GBLC &(&V_STRING(1))       Declare global variable.
                GBLC &(&V_STRING(2))       Declare global variable.
&L_STRING(1)    SETC '&(&V_STRING(1))'     Copy default value.
&L_STRING(2)    SETC '&(&V_STRING(2))'     Copy default value.
.STRING_NBLK    ANOP
.*
.*
.* Process the STRING keyword to get an address and length.
.*
&KEYWORD      SETC 'STRING'
              AIF ('&L_STRING(1)' EQ '').NO_STRING
              AIF ('&L_STRING(1)'(1,1) EQ '''').STR_LITERAL
              AIF ('&L_STRING(2)' EQ '').STR_TAGONLY
.STR_TAGLEN   ANOP
&S_ADDR       SETC '&L_STRING(1)'         | Set addr.
&S_LEN        SETC '&L_STRING(2)'         | Set len.
              AGO  .PAST_STRING           |
.STR_TAGONLY  AIF  ('&(&PL_SIZELENGTH)' EQ '').NO_SIZELENGTH
&S_ADDR       SETC '&L_STRING(1)'         | Set addr to tag_name.
&S_LEN        SETC '=AL&(&PL_SIZELENGTH).(L''&L_STRING(1))'
              AGO  .PAST_STRING           |
.STR_LITERAL  ANOP                        |
&S_ADDR         SETC '&L_STRING(1)'         | Set addr to value.
&L              SETA 0                      | Length counter = 0.
&I              SETA 2                      | Index counter -> past '.
.STR_LOOP       AIF  (&I GE K'&S_ADDR).STR_ELOOP     Loop over STRING.
                AIF  ('&S_ADDR'(&I,1) NE '''').STR_TXT If doubled.
&I              SETA &I+1                   |             Advance.
.STR_TXT        ANOP                        |          EndIf.
&L              SETA &L+1                   |   Add one to length.
&I              SETA &I+1                   |   Advance.
                AGO  .STR_LOOP              | End of counting loop.
.STR_ELOOP      ANOP                        |
&S_LEN          SETC '=AL&(&PL_SIZELENGTH).(&L)' Set length parameter.
                AGO  .PAST_STRING
.NO_STRING    MNOTE 8,'STRING is a required keyword.'
              MEXIT
.PAST_STRING  ANOP
.*
.* Generate the call to PL_SET_FOOTER.
.*
.CALL    ANOP
         CALLX &#_IDEPA,(&#_IDTKN,&PL_SET_FOOTER,                      +
               &LINE,&S_ADDR,&S_LEN),VL
         AIF    ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
         MEXIT
.NO_SIZELENGTH ANOP
         MNOTE 8,'Explicit lengths must be specified unless the SIZELEN+
               GTH keyword has been coded on the ST_ID macro.'
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_SET_FORMATTED_FOOTER                                    *
* Purpose: Establish a footer line from a format string and a set     *
*          of substitution values.                                    *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_SET_FORMATTED_FOOTER &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,      *
               &LINE=0,                                                *
               &CONTROL=,                                              *
               &SOURCE=,                                               *
               &PAGENUM=0
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_SET_FORMATTED_FOOTER
         LCLC  &C_ADDR,&C_LEN
         LCLC  &V_CONTROL(2),&PL_SIZELENGTH
         LCLC  &L_CONTROL(2)
         LCLA  &N
         LCLC  &KEYWORD
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE
         MNOTE 8,'SRV##ID unable to set global variables.'
         MEXIT
.VALIDATE ANOP
.*
.*
.* Validate incoming parameters.
.*
         AIF   (T'&LINE EQ 'N').LINEOK
         AIF   ('&LINE' NE '').LINEOK
.LINEBAD MNOTE 8,'Line must be specified as the address of a fullword o*
               r a numeric value.'
         MEXIT
.LINEOK  ANOP
.*
&PL_SIZELENGTH SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.
               GBLC &(&PL_SIZELENGTH)     Declare global variable.
.*
.* If CONTROL= is missing, supply default values.
.*
&L_CONTROL(1)   SETC '&CONTROL(1)'
&L_CONTROL(2)   SETC '&CONTROL(2)'
                AIF ('&L_CONTROL(1)' NE '').CONTROL_NBLK
&V_CONTROL(1)   SETC '#$&ID.$#CONTROL1'    Variable for CONTROL=.
&V_CONTROL(2)   SETC '#$&ID.$#CONTROL2'    Variable for CONTROL=.
                GBLC &(&V_CONTROL(1))      Declare global variable.
                GBLC &(&V_CONTROL(2))      Declare global variable.
&L_CONTROL(1)   SETC '&(&V_CONTROL(1))'    Copy default value.
&L_CONTROL(2)   SETC '&(&V_CONTROL(2))'    Copy default value.
.CONTROL_NBLK   ANOP
.*
.*
.* Process the CONTROL keyword to get an address and length.
.*
&KEYWORD      SETC 'CONTROL'
              AIF ('&L_CONTROL(1)' EQ '').NO_CONTROL
              AIF ('&L_CONTROL(1)'(1,1) EQ '''').CTL_LITERAL
              AIF ('&L_CONTROL(2)' EQ '').CTL_TAGONLY
.CTL_TAGLEN   ANOP
&C_ADDR       SETC '&L_CONTROL(1)'        | Set addr.
&C_LEN        SETC '&L_CONTROL(2)'        | Set len.
              AGO  .PAST_CONTROL          |
.CTL_TAGONLY  AIF  ('&(&PL_SIZELENGTH)' EQ '').NO_SIZELENGTH
&C_ADDR       SETC '&L_CONTROL(1)'        | Set addr to tag_name.
&C_LEN        SETC '=AL&(&PL_SIZELENGTH).(L''&L_CONTROL(1))'
              AGO  .PAST_CONTROL          |
.CTL_LITERAL  ANOP                        |
&C_ADDR         SETC '&L_CONTROL(1)'        | Set addr to value.
&L              SETA 0                      | Length counter = 0.
&I              SETA 2                      | Index counter -> past '.
.CTL_LOOP       AIF  (&I GE K'&C_ADDR).CTL_ELOOP     Loop over CONTROL.
                AIF  ('&C_ADDR'(&I,1) NE '''').CTL_TXT If doubled.
&I              SETA &I+1                   |             Advance.
.CTL_TXT        ANOP                        |          EndIf.
&L              SETA &L+1                   |   Add one to length.
&I              SETA &I+1                   |   Advance.
                AGO  .CTL_LOOP              | End of counting loop.
.CTL_ELOOP      ANOP                        |
&C_LEN          SETC '=AL&(&PL_SIZELENGTH).(&L)' Set length parameter.
                AGO  .PAST_CONTROL
.NO_CONTROL   MNOTE 8,'CONTROL is a required keyword.'
              MEXIT
.PAST_CONTROL ANOP
.*
.* Generate the format call to the CONTROL handler.
.*
         ##PLIST START
         ##PLIST PARM,&#_IDTKN
         ##PLIST PARM,&PL_SET_FORMATTED_FOOTER
         ##PLIST PARM,&LINE
         ##PLIST PARM,&C_ADDR
         ##PLIST PARM,&C_LEN
         ##PLIST PARM,&PAGENUM
&N       SETA  1
.PL_LOOP ANOP
         AIF   (&N GT N'&SOURCE).PL_LOOPEND
         ##PLIST PARM,&SOURCE(&N)
&N       SETA  &N+1
         AGO   .PL_LOOP
.PL_LOOPEND ANOP ,
         ##PLIST END,VL
         CALLX  &#_IDEPA
         AIF    ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
         MEXIT
.NO_SIZELENGTH ANOP
         MNOTE 8,'Explicit lengths must be specified unless the SIZELEN+
               GTH keyword has been coded on the ST_ID macro.'
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_RESET_FOOTER                                            *
* Purpose: Delete the definition for one or all footer lines.         *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_RESET_FOOTER &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,              +
               &LINE=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_RESET_FOOTER
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE
         MNOTE 8,'SRV##ID unable to set global variables.'
         MEXIT
.VALIDATE ANOP
.*
.* Validate incoming parameters.
.*
         AIF   (T'&LINE EQ 'N').LINEOK
         AIF   ('&LINE' NE '').LINEOK
.LINEBAD MNOTE 8,'Line must be specified as the address of a fullword o*
               r a numeric value.'
         MEXIT
.LINEOK  ANOP
.*
.* Generate the call to PL_RESET_FOOTER.
.*
.CALL    ANOP
         CALLX &#_IDEPA,(&#_IDTKN,&PL_RESET_FOOTER,                    +
               &LINE),VL
         AIF    ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
         MEXIT
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_RESERVE_FOOTER                                          *
* Purpose: Reserve space at the bottom of a page for the footer.      *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_RESERVE_FOOTER &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,            *
               &LINES=0
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_RESERVE_FOOTER
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE
         MNOTE 8,'SRV##ID unable to set global variables.'
         MEXIT
.VALIDATE ANOP
.*
.* Validate incoming parameters.
.*
.*       AIF   (T'&LINES EQ 'N').LINEOK
.LINEOK  ANOP
.*
.* Generate the call to PL_RESERVE_FOOTER.
.*
.CALL    ANOP
         CALLX &#_IDEPA,(&#_IDTKN,&PL_RESERVE_FOOTER,                  +
               &LINES),VL
         AIF    ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_PAGE_BREAK                                              *
* Purpose: Force a page break to occur.                               *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_PAGE_BREAK &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                *
               &LINES=0
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_PAGE_BREAK
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' EQ 'SUCCESS').CALL
         MNOTE 8,'SRV##ID unable to set global variables.'
         MEXIT
.*
.* Generate the call to PL_PAGE_BREAK.
.*
.CALL    ANOP
         CALLX &#_IDEPA,(&#_IDTKN,&PL_PAGE_BREAK),VL
         AIF    ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_PRINT                                                   *
* Purpose: Print an unformatted data line.                            *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_PRINT &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                     +
               &STRING=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_PRINT
         LCLC  &S_ADDR,&S_LEN
         LCLC  &V_STRING(2),&PL_SIZELENGTH
         LCLC  &L_STRING(2)
         LCLA  &N
         LCLC  &KEYWORD
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC
         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE
         MNOTE 8,'SRV##ID unable to set global variables.'
         MEXIT
.VALIDATE ANOP
.*
.* Validate incoming parameters.
.*
&PL_SIZELENGTH SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.
               GBLC &(&PL_SIZELENGTH)     Declare global variable.
.*
.* If STRING= is missing, supply default values.
.*
&L_STRING(1)    SETC '&STRING(1)'
&L_STRING(2)    SETC '&STRING(2)'
                AIF ('&L_STRING(1)' NE '').STRING_NBLK
&V_STRING(1)    SETC '#$&ID.$#STRING1'     Variable for STRING=.
&V_STRING(2)    SETC '#$&ID.$#STRING2'     Variable for STRING=.
                GBLC &(&V_STRING(1))       Declare global variable.
                GBLC &(&V_STRING(2))       Declare global variable.
&L_STRING(1)    SETC '&(&V_STRING(1))'     Copy default value.
&L_STRING(2)    SETC '&(&V_STRING(2))'     Copy default value.
.STRING_NBLK    ANOP
.*
.*
.* Process the STRING keyword to get an address and length.
.*
&KEYWORD      SETC 'STRING'
              AIF ('&L_STRING(1)' EQ '').NO_STRING
              AIF ('&L_STRING(1)'(1,1) EQ '''').STR_LITERAL
              AIF ('&L_STRING(2)' EQ '').STR_TAGONLY
.STR_TAGLEN   ANOP
&S_ADDR       SETC '&L_STRING(1)'         | Set addr.
&S_LEN        SETC '&L_STRING(2)'         | Set len.
              AGO  .PAST_STRING           |
.STR_TAGONLY  AIF  ('&(&PL_SIZELENGTH)' EQ '').NO_SIZELENGTH
&S_ADDR       SETC '&L_STRING(1)'         | Set addr to tag_name.
&S_LEN        SETC '=AL&(&PL_SIZELENGTH).(L''&L_STRING(1))'
              AGO  .PAST_STRING           |
.STR_LITERAL  ANOP                        |
&S_ADDR         SETC '&L_STRING(1)'         | Set addr to value.
&L              SETA 0                      | Length counter = 0.
&I              SETA 2                      | Index counter -> past '.
.STR_LOOP       AIF  (&I GE K'&S_ADDR).STR_ELOOP     Loop over STRING.
                AIF  ('&S_ADDR'(&I,1) NE '''').STR_TXT If doubled.
&I              SETA &I+1                   |             Advance.
.STR_TXT        ANOP                        |          EndIf.
&L              SETA &L+1                   |   Add one to length.
&I              SETA &I+1                   |   Advance.
                AGO  .STR_LOOP              | End of counting loop.
.STR_ELOOP      ANOP                        |
&S_LEN          SETC '=AL&(&PL_SIZELENGTH).(&L)' Set length parameter.
                AGO  .PAST_STRING
.NO_STRING    MNOTE 8,'STRING is a required keyword.'
              MEXIT
.PAST_STRING  ANOP
.*
.* Generate the call to PL_PRINT.
.*
.CALL    ANOP
         CALLX &#_IDEPA,(&#_IDTKN,&PL_PRINT,                           +
               &S_ADDR,&S_LEN),VL
         AIF    ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
         MEXIT
.NO_SIZELENGTH ANOP
         MNOTE 8,'Explicit lengths must be specified unless the SIZELEN+
               GTH keyword has been coded on the ST_ID macro.'
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_PRINT_FORMATTED                                         *
* Purpose: Format and print a data line.                              *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_PRINT_FORMATTED &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,           *
               &CONTROL=,                                              *
               &SOURCE=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_PRINT_FORMATTED
         LCLC  &C_ADDR,&C_LEN
         LCLC  &V_CONTROL(2),&PL_SIZELENGTH
         LCLC  &L_CONTROL(2)
         LCLA  &N
         LCLC  &KEYWORD
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC.
         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE
         MNOTE 8,'SRV##ID unable to set global variables.'
         MEXIT
.VALIDATE ANOP
.*
.*
.* Validate incoming parameters.
.*
.*
&PL_SIZELENGTH SETC '#$&ID.$#SIZELENGTH'  Variable for SIZELENGTH=.
               GBLC &(&PL_SIZELENGTH)     Declare global variable.
.*
.* If CONTROL= is missing, supply default values.
.*
&L_CONTROL(1)   SETC '&CONTROL(1)'
&L_CONTROL(2)   SETC '&CONTROL(2)'
                AIF ('&L_CONTROL(1)' NE '').CONTROL_NBLK
&V_CONTROL(1)   SETC '#$&ID.$#CONTROL1'    Variable for CONTROL=.
&V_CONTROL(2)   SETC '#$&ID.$#CONTROL2'    Variable for CONTROL=.
                GBLC &(&V_CONTROL(1))      Declare global variable.
                GBLC &(&V_CONTROL(2))      Declare global variable.
&L_CONTROL(1)   SETC '&(&V_CONTROL(1))'    Copy default value.
&L_CONTROL(2)   SETC '&(&V_CONTROL(2))'    Copy default value.
.CONTROL_NBLK   ANOP
.*
.*
.* Process the CONTROL keyword to get an address and length.
.*
&KEYWORD      SETC 'CONTROL'
              AIF ('&L_CONTROL(1)' EQ '').NO_CONTROL
              AIF ('&L_CONTROL(1)'(1,1) EQ '''').CTL_LITERAL
              AIF ('&L_CONTROL(2)' EQ '').CTL_TAGONLY
.CTL_TAGLEN   ANOP
&C_ADDR       SETC '&L_CONTROL(1)'        | Set addr.
&C_LEN        SETC '&L_CONTROL(2)'        | Set len.
              AGO  .PAST_CONTROL          |
.CTL_TAGONLY  AIF  ('&(&PL_SIZELENGTH)' EQ '').NO_SIZELENGTH
&C_ADDR       SETC '&L_CONTROL(1)'        | Set addr to tag_name.
&C_LEN        SETC '=AL&(&PL_SIZELENGTH).(L''&L_CONTROL(1))'
              AGO  .PAST_CONTROL          |
.CTL_LITERAL  ANOP                        |
&C_ADDR         SETC '&L_CONTROL(1)'        | Set addr to value.
&L              SETA 0                      | Length counter = 0.
&I              SETA 2                      | Index counter -> past '.
.CTL_LOOP       AIF  (&I GE K'&C_ADDR).CTL_ELOOP     Loop over CONTROL.
                AIF  ('&C_ADDR'(&I,1) NE '''').CTL_TXT If doubled.
&I              SETA &I+1                   |             Advance.
.CTL_TXT        ANOP                        |          EndIf.
&L              SETA &L+1                   |   Add one to length.
&I              SETA &I+1                   |   Advance.
                AGO  .CTL_LOOP              | End of counting loop.
.CTL_ELOOP      ANOP                        |
&C_LEN          SETC '=AL&(&PL_SIZELENGTH).(&L)' Set length parameter.
                AGO  .PAST_CONTROL
.NO_CONTROL   MNOTE 8,'CONTROL is a required keyword.'
              MEXIT
.PAST_CONTROL ANOP
.*
.* Generate the format call to the CONTROL handler.
.*
         ##PLIST START
         ##PLIST PARM,&#_IDTKN
         ##PLIST PARM,&PL_PRINT_FORMATTED
         ##PLIST PARM,&C_ADDR
         ##PLIST PARM,&C_LEN
&N       SETA  1
.PL_LOOP ANOP
         AIF   (&N GT N'&SOURCE).PL_LOOPEND
         ##PLIST PARM,&SOURCE(&N)
&N       SETA  &N+1
         AGO   .PL_LOOP
.PL_LOOPEND ANOP ,
         ##PLIST END,VL
         CALLX  &#_IDEPA
         AIF    ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
         MEXIT
.NO_SIZELENGTH ANOP
         MNOTE 8,'Explicit lengths must be specified unless the SIZELEN+
               GTH keyword has been coded on the ST_ID macro.'
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_QUERY_LINES_LEFT                                        *
* Purpose: Return # lines remaining on current page to caller.        *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_QUERY_LINES_LEFT &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,          *
               &LINES=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_QUERY_LINES_LEFT
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC
         AIF  ('&#_IDCODE' EQ 'SUCCESS').VALIDATE
         MNOTE 8,'SRV##ID unable to set global variables.'
         MEXIT
.VALIDATE ANOP
.*
.* Validate incoming parameters.
.*
         AIF   ('&LINES' EQ '').LINESERR
         AIF   ('&LINES'(1,1) NE '''').LINESOK
.LINESERR MNOTE 8,'LINES is a required parameter, and must be specified*
                as an address.'
         MEXIT
.LINESOK ANOP
.*
.* Generate the call to PL_QUERY_LINES_LEFT.
.*
.CALL    ANOP
         CALLX &#_IDEPA,(&#_IDTKN,&PL_QUERY_LINES_LEFT,                +
               &LINES),VL
         AIF    ('&#_IDEMC' EQ '').MEXIT
         &#_IDEMC.
.MEXIT   MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_GET_INFO                                                *
* Purpose: Get information about a print line session.                *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_GET_INFO &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,                  +
               &LRECL=,&RECFM=,                                        +
               &FIMSG=,&FIMSGLEN=,&FIRC=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_GET_INFO
         GBLA  &PL_GI_LRECL
         GBLA  &PL_GI_RECFM
         GBLA  &PL_GI_FIMSG
         GBLA  &PL_GI_FIRC
         LCLC  &L_ADDR,&L_LEN
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
.*
.*       Generate parameter list prelude code.
.*
         ##PLIST START
         ##PLIST PARM,&#_IDTKN,&PL_GET_INFO
.*
.* If FIMSG= was specified, generate code to get FIMSG information.
.*
              AIF ('&FIMSG' EQ '').NO_FIMSG
              AIF (N'&FIMSG EQ 1).FIMSG_TAGONLY
              AIF (N'&FIMSG EQ 2).FIMSG_TAGLEN
              MNOTE 8,'Too many subparameters for FIMSG keyword.'
              MEXIT
.FIMSG_TAGLEN ANOP
&L_ADDR       SETC '&FIMSG(1)'            | Set addr.
&L_LEN        SETC '&FIMSG(2)'            | Set len.
              AGO  .PAST_FIMSG            |
.FIMSG_TAGONLY ANOP
&L_ADDR       SETC '&FIMSG'               | Set addr to tag_FIMSG.
&L_LEN        SETC '=A(L''&FIMSG)'        | Set len to L'tag_FIMSG.
.PAST_FIMSG   AIF  ('&FIMSGLEN' NE '').CALL_FIMSG
    MNOTE 8,'FIMSGLEN must be specified if FIMSG is specified.'
              MEXIT
.CALL_FIMSG   ##PLIST PARM,&PL_GI_FIMSG,&L_ADDR,&L_LEN,&FIMSGLEN
.NO_FIMSG     ANOP
.*
.* If FIRC= was specified, generate code to get FIRC information.
.*
              AIF ('&FIRC' EQ '').NO_FIRC
.CALL_FIRC    ##PLIST PARM,&PL_GI_FIRC,&FIRC
.NO_FIRC      ANOP
.*
.* If LRECL= was specified, generate code to get it.
.*
              AIF ('&LRECL' EQ '').NO_LRECL
.CALL_LRECL   ##PLIST PARM,&PL_GI_LRECL,&LRECL
.NO_LRECL     ANOP
.*
.* If RECFM= was specified, generate code to get it.
.*
              AIF ('&RECFM' EQ '').NO_RECFM
.CALL_RECFM   ##PLIST PARM,&PL_GI_RECFM,&RECFM
.NO_RECFM     ANOP
.*
.* Complete the parameter list and generate the call.
.*
               ##PLIST END,VL
               CALLX   &#_IDEPA
               AIF   ('&#_IDEMC' EQ '').NO_EMC
               &#_IDEMC.
.NO_EMC        ANOP
.MEXIT         MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_GET_REFERENCE                                           *
* Purpose: Get reference string from file handler session.            *
*                                                                     *
*---------------------------------------------------------------------*
         MACRO
         PL_GET_REFERENCE &ID=,&SPEPA=,&SPTOKEN=,&ERRMAC=,             +
               &REFERENCE=
         GBLC  &#_IDCODE,&#_IDMAC,&#_IDESID,&#_IDESVA
         GBLC  &#_IDEPN,&#_IDEPA,&#_IDTKN,&#_IDEMC
         GBLA  &PL_GET_REFERENCE
.*
.* Obtain service processor ID values.
.*
         SRV##ID GET,REQUIRED=(SPEPA,SPTOKEN),                         +
               ID=&ID,IDMAC=PL_ID,SPEPA=&SPEPA,SPTOKEN=&SPTOKEN,       +
               ERRMAC=&ERRMAC
         AIF  ('&#_IDCODE' NE 'SUCCESS').MEXIT
         AIF  ('&REFERENCE' EQ '').NO_REF
         CALLX   &#_IDEPA,(&#_IDTKN,&PL_GET_REFERENCE,&REFERENCE),VL
              MEXIT
.NO_REF       MNOTE 8,'REFERENCE is a required keyword.'
.MEXIT         MEND
*---------------------------------------------------------------------*
*                                                                     *
* Macro:   PL_PARMLIST                                                *
* Purpose: Generate mapping fields for the parameters accepted by the *
*          PrintLine service processor.                               *
*                                                                     *
*---------------------------------------------------------------------*
                  MACRO
&LABEL            PL_PARMLIST &DSECT=YES
                  LCLC  &NAME
&NAME             SETC  'PL_PARMLIST'
                  AIF   ('&LABEL' EQ '').PAST_LABEL
&NAME             SETC  '&LABEL'
.PAST_LABEL       ANOP
                  AIF   ('&DSECT' EQ 'YES').GEN_DSECT
&NAME             DS    0F         | Parameter List:
                  AGO .GEN_FIELDS
.GEN_DSECT        ANOP
&NAME             DSECT            | Parameter List:
.GEN_FIELDS       ANOP ,           |
PL_PL_ID                      DS A    | Div identifier === PWA base
PL_FUNCTIONCODE               DS A    | Function to be performed
PL_MIN_#                      EQU (*-&NAME)/4
PL_FUNCTION_DEPT              EQU *   | Function-dependent parameters
*---------------------------------------------------------------------*
* Start function
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_START_ESV                  DS A    | Environment Support Vector.
PL_START_DDNAME               DS A    | DDName.
PL_START_MIN_#                EQU (*-&NAME)/4
PL_START_PAGESIZE             DS A    | Mode of access (U or R)
PL_START_PAGESIZE_#           EQU (*-&NAME)/4
PL_START_MAXLINESIZE          DS A    | Size return area.
PL_START_MAXLINESIZE_#        EQU (*-&NAME)/4
PL_START_SIZELENGTH           DS A    | Size return area.
PL_START_SIZELENGTH_#         EQU (*-&NAME)/4
PL_START_OPTIONS              DS A    | Options area.
PL_START_OPTIONS_#            EQU (*-&NAME)/4
PL_START_REFERENCE            DS A    | Options area.
PL_START_REFERENCE_#          EQU (*-&NAME)/4
PL_START_MAX_#                EQU (*-&NAME)/4
*---------------------------------------------------------------------*
* Terminate function
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_TERMINATE_#                EQU (*-&NAME)/4
*---------------------------------------------------------------------*
* Set_Header function
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_SETHDR_LINENBR             DS A    | Line number.
PL_SETHDR_STRING              DS A    | Unformatted string.
PL_SETHDR_STRINGLEN           DS A    | Length of string.
PL_SETHDR_MIN_#               EQU (*-&NAME)/4
PL_SETHDR_MAX_#               EQU (*-&NAME)/4
*---------------------------------------------------------------------*
* Set_Formatted_Header function.
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_SETFMTHDR_LINENBR          DS A    | Line number.
PL_SETFMTHDR_FMTSTRING        DS A    | Format string.
PL_SETFMTHDR_FMTSTRING_LEN    DS A    | Format string length.
PL_SETFMTHDR_MIN_#            EQU (*-&NAME)/4
PL_SETFMTHDR_PAGEDISP         DS A    | Page number disp or zero.
PL_SETFMTHDR_PAGEDISP_#       EQU (*-&NAME)/4
PL_SETFMTHDR_SOURCELIST       DS 50A  | Source addresses for formatter.
PL_SETFMTHDR_MAX_#            EQU (*-&NAME)/4
*---------------------------------------------------------------------*
* Reset_Header function
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_RESETHDR_LINENBR           DS A    | Line # to reset, 0 for all.
PL_RESETHDR_MIN_#             EQU (*-&NAME)/4
PL_RESETHDR_MAX_#             EQU (*-&NAME)/4
*---------------------------------------------------------------------*
* Set_Footer function
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_SETFTR_LINENBR             DS A    | Line number.
PL_SETFTR_STRING              DS A    | Unformatted string.
PL_SETFTR_STRINGLEN           DS A    | Length of string.
PL_SETFTR_MIN_#               EQU (*-&NAME)/4
PL_SETFTR_MAX_#               EQU (*-&NAME)/4
*---------------------------------------------------------------------*
* Set_Formatted_Footer function.
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_SETFMTFTR_LINENBR          DS A    | Line number.
PL_SETFMTFTR_FMTSTRING        DS A    | Format string.
PL_SETFMTFTR_FMTSTRING_LEN    DS A    | Format string length.
PL_SETFMTFTR_MIN_#            EQU (*-&NAME)/4
PL_SETFMTFTR_PAGEDISP         DS A    | Page number disp or zero.
PL_SETFMTFTR_PAGEDISP_#       EQU (*-&NAME)/4
PL_SETFMTFTR_SOURCELIST       DS 50A  | Format substitution values.
PL_SETFMTFTR_MAX_#            EQU (*-&NAME)/4
*---------------------------------------------------------------------*
* Reset_Footer function
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_RESETFTR_LINENBR           DS A    | Line # to reset, 0 for all.
PL_RESETFTR_MIN_#             EQU (*-&NAME)/4
PL_RESETFTR_MAX_#             EQU (*-&NAME)/4
*---------------------------------------------------------------------*
* Reserve_Footer function
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_RSVFTR_LINES               DS A    | Lines to reserve
PL_RSVFTR_MIN_#               EQU (*-&NAME)/4
PL_RSVFTR_MAX_#               EQU (*-&NAME)/4
*---------------------------------------------------------------------*
* Page_Break function  (no function-specific parameters)
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_PAGEBREAK_MIN_#            EQU (*-&NAME)/4
PL_PAGEBREAK_MAX_#            EQU (*-&NAME)/4
*---------------------------------------------------------------------*
* Print function
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_PRINT_STRING               DS A    | Unformatted string to print
PL_PRINT_STRINGLEN            DS A    | Length of string
PL_PRINT_MIN_#                EQU (*-&NAME)/4
PL_PRINT_MAX_#                EQU (*-&NAME)/4
*---------------------------------------------------------------------*
* Print_Formatted function.
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_PRINTFMT_FMTSTRING         DS A    | Format string.
PL_PRINTFMT_FMTSTRING_LEN     DS A    | Format string length.
PL_PRINTFMT_MIN_#             EQU (*-&NAME)/4
PL_PRINTFMT_SOURCELIST        DS 50A  | Retain ("Y" or "N")
PL_PRINTFMT_MAX_#             EQU (*-&NAME)/4
*---------------------------------------------------------------------*
* Query_Lines_Left function
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_QLINES_LINES               DS A    | Line # to reset, 0 for all.
PL_QLINES_MIN_#               EQU (*-&NAME)/4
PL_QLINES_MAX_#               EQU (*-&NAME)/4
*---------------------------------------------------------------------*
* Get_Info; multiple information sub-codes can be provided, each with
* a required return area and some with required area_size and length.
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_GI_FUNCTION    DS  A            |     Information sub-code.
PL_GI_MIN_#       EQU (*-&NAME)/4  |
PL_GI_AREA        DS  A            |     Area to return information.
PL_GI_AREA_SIZE   DS  A            |     Length of return area.
PL_GI_LENGTH      DS  A            |     Length of returned info.
*---------------------------------------------------------------------*
* Get_Info; multiple information sub-codes can be provided, each with
* a required return area and some with required area_size and length.
*---------------------------------------------------------------------*
                  ORG PL_FUNCTION_DEPT
PL_GR_REFERENCE   DS  A            |     PL_START Reference string.
PL_GR_MIN_#       EQU (*-&NAME)/4  |
PL_GR_MAX_#       EQU (*-&NAME)/4  |
                  ORG ,            |
PL_MAX_#                      EQU (*-&NAME)/4
                  ORG ,            | Adjust to final parmlist offset.
&NAME._L          EQU *-&NAME.     | Length of File Handler Parmlist.
                  MEND
