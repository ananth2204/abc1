*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
SRVMS TITLE 'MVS Message Service Processor'
         SMLIST CONVERT=YES           |
         srvmod name=srvms,dates='1989, 1990, 1995'
         gblc  &srv_modname
*---------------------------------------------------------------------*
*
*  Copyright (C) Clemson University Research Foundation 1989, 1990.
*
*  Program     SRVMS, MVS Message Service Processor.
*
*  Abstract    This service processor is MVS dependent and provides
*              standardized message services.
*
*  Parameters:
*
*    MS_Start
*      CALLX SRVMS,(MS_token,&MS_Start,ESV,
*                      msgmod_csect_list_address,maxsev,sizelength,
*                      option_byte,option_specific_parameters)
*
*    MS_Terminate
*      CALLX SRVMS,(MS_token,&MS_Terminate)
*
*
*    MS_Issue_Message
*      CALLX SRVMS,(MS_token,&MS_Issue_Message,
*                      message_ID,source1,source2,...)
*
*    MS_Get_Message
*      CALLX SRVMS,(MS_token,&MS_Get_Message,
*                      message_ID,target,target_length,result_length,
*                      source1,source2,...)
*
*    The meaning of each parameter is explained below.
*
*    MS_ID is a fullword used to uniquely identify the invocation of
*      the Print_Line service processor.  It is initialized during the
*      startup function.
*
*    FunctionCode is a fullword integer that specifies the function to
*      be performed.  Symbolic identifiers are provided for each
*      function and may be accessed by placing a COPY statement for
*      SRVMSMAC in the assembler program.  These symbols should be
*      used in place of actual integer values.  The following
*      FunctionCodes are supported:
*
*      &MS_Start                   =  1
*        Identify the ddname that points to the report file, set the
*        maximum page and line lengths.
*
*      &MS_Terminate               =  2
*        Shutdown this invocation.  This function causes any incomplete
*        pages to be completed and closes the report file.
*
*
*      &MS_Issue_Message           =  3
*        Formats and prints a message based on the user's format
*        specifications.
*
*      &MS_Get_Message             =  4
*        Formats and returns the text of a message.
*
*      &MS_Put_Message             =  5
*        Routes the message text provided by the caller to the
*        current message destination.  As this function sort of
*        defeats the purpose of Message Services, its use is not
*        recommended except for applications that really need it.
*
*    ESV is a fullword given to the application by the Server Manager
*      when it was started up.
*
*    DDName specified the DDName of the report file.  This file will
*      be a RECFM=VBA file.  Its blocksize will default to (LRECL+4),
*      unless overridden by JCL.
*
*
*  Return codes:
*
*   &MS_Invalid_Function
*      An invalid function was specified.
*   &MS_Invalid_Number_Of_Parms
*      An invalid number of parameters for a specific function was
*      specified.
*   &MS_Invalid_MS_ID
*      The service processor token does not point to the correct data.
*   &MS_Environment_Support_Error
*      The Environment Support service processor returned an error.
*   &MS_Printline_Error
*      The Printline service processor returned an error.
*   &MS_Print_Line_Truncated
*      The length of the caller-provided string or the formatted string
*      exceeded the maximum line length.  The truncated line is printed
*      before control is returned to the caller.
*
*  Program     Reentrant, key and state of caller, server linkage,
*  Attributes  authorization of caller, AMODE(any), RMODE(any)
*
*  Change
*  History   2011/10/20 JCB - Patch rollup for CBT tape distribution
*
*  Method of
*  Operation   Refer to the code
*
*
*  Special Notes:
*
*---------------------------------------------------------------------*
 space 1                              |
 print off                            |
 copy  smsyms                         | Structured Macros symbols.
 copy  srvesmac                       | Environment support symbols.
 copy  srvdtmac                       | Date services symbols.      @C2
 copy  srvstmac                       | String Formatter symbols.
 copy  srvplmac                       | Print Line symbols.
 copy  srvmsmac                       | Message symbols.
 print on,gen                         |
 eject                                |
**--------------------------------------------------------------------*
**
**  Identify the service processors that Message will use.
**
**--------------------------------------------------------------------*
       space 1                        |
 es_id         id=ES,                 |                                *
               spepa=pwa_ES_epa,      |                                *
               sptoken=pwa_ES_token,  |                                *
               esva=pwa_esv           |
       space 1                        |
 PL_id         id=PL,                 |                                *
               spepname=&Print_Line,  |                                *
               spepa=pwa_PL_epa,      |                                *
               sptoken=pwa_PL_token,  |                                *
               esid=ES                |
       space 1                        |
 st_id         id=ST,                 |                                *
               spepname=&String_Handler,                               *
               spepa=pwa_ST_epa,      |                                *
               sptoken=pwa_ST_token,  |                                *
               esid=ES                |
       space 1                        |                             @C2
 dt_id         id=DT,                 |                             @C2*
               spepa=pwa_DT_epa,      |                             @C2*
               sptoken=pwa_DT_token,  |                             @C2*
               esid=ES                |                             @C2
       space 1                        |
 eject                                |
 block name=&srv_modname,type=program,amode=31,rmode=any,              +
               options=(*srvprc,noclearpwa,(parms,(using,r11))),       +
               subopts=*swa,parmmap=parmlist,basereg=(r12,r10)
* *-------------------------------------------------------------------*
* * Determine how many parameters were passed and load r1 with
* * function code.
* *-------------------------------------------------------------------*
  la    r1,parmlist                   | Point r1 to parameter list.
  la    r15,prm_max_#                 | Load r15 with maximum # parms.
  loop bct                            | Loop
   leave loop=*,(tbit,0(r1),x'80')    |  End of parms if high bit set.
   la   r1,4(,r1)                     |  Point to next parm address.
  endloop bct,r15                     | Endloop
  la    r0,prm_max_#+1                | Calculate number of
  sr    r0,r15                        |  parms.  Ok if 2 <= num <= max
  sth   r0,pwa_number_of_parms        | Save number of parms.
  errexit (ch,r0,lt,=y(prm_min_#)),or,(ch,r0,gt,=y(prm_max_#)),        +
               code=&MS_invalid_number_of_parms
  l     r1,prm_functioncode           | Load the function code into
  l     r1,0(,r1)                     |   a register for testing.
* *-------------------------------------------------------------------*
* * If the function code is something other than start, make sure that
* * the PWA contains the eye-catcher string and the correct value for
* * MS_ID.   If not, then the MS_ID passed in is garbage.
* *-------------------------------------------------------------------*
  if (c,r1,ne,=f'&MS_start')          | If not startup function then
   errexit ((clc,pwa_visual,ne,eyecatcher),or,(c,r13,ne,pwa_MS_id)),   +
               code=&MS_invalid_MS_id |  go off and croak.
   lr    r2,r1                        |  Save function code
   es_clear_debug_info id=ES          |  Clear debug info
   lr    r1,r2                        |  Restore function code.
  endif                               | Endif.
  eject ,                             |
* *-------------------------------------------------------------------*
* * Select the code to process the function.
* *-------------------------------------------------------------------*
  caseblk reg=r1                      | Start of function case block.
  eject                               |
*  *------------------------------------------------------------------*
*  *
*  * Start function.
*  *
*  *------------------------------------------------------------------*
   case &MS_start                     |  Start function.
*   *-----------------------------------------------------------------*
*   * Set the eyecatcher and the MS_ID fields.   These are checked
*   * each time the PL server is entered to avoid integrity
*   * problems.
*   *-----------------------------------------------------------------*
    mvc   pwa_visual,eyecatcher       |   Both the eyecatcher and the
    st    r13,pwa_MS_id               |   MS_ID are for validity checks
    xc    pwa_clear_start(pwa_clear_length),pwa_clear_start
    mvi   pwaf1,x'00'                 |   Clear working flag        @C6
*   *-----------------------------------------------------------------*
*   * Make sure that a valid number of parameters are specified.
*   *-----------------------------------------------------------------*
    lh    r3,pwa_number_of_parms      |   Load r3 with number of parms.
    errexit    (ch,r3,lt,=y(prm_start_min_#)),or,   Error if out       +
               (ch,r3,gt,=y(prm_start_max_#)),      of bounds.         +
               code=&MS_invalid_number_of_parms
*   *-----------------------------------------------------------------*
*   *  Set SizeLength value.
*   *-----------------------------------------------------------------*
    la    r1,&MS_default_sizelength   | Set default sizelength
    l     r2,prm_start_sizelength     | Get the parm
    l32   r2,0(r2)                    | Get the value
    errexit (ch,r2,gt,=h'4'),         |                                *
               code=&ms_invalid_sizelength
    if    nz                          | If it's nonzero,
     lr    r1,r2                      |  we'll use that.
    endif                             |
    st    r1,pwa_sizelength           |
    bctr  r1,0                        | r1 := offset into bit-masks
    la    r1,psd_bit_mask(r1)         | r1 -> bit-mask for icm/stcm's.
    l8    r0,0(r1)                    | r0 := bit-mask for icm/stcm's.
    st    r0,pwa_size_mask            | save for dealing w/ lengths.
         eject                        |
*   *-----------------------------------------------------------------*
*   * Start the Environment Support service processor.
*   *-----------------------------------------------------------------*
*   ES_MVS_Load id=ES                 | Bootstrap in env. support
*   ES_Start   id=ES                  | Start environment support
    l    r1,prm_start_esv             |
    l    r1,0(r1)                     |
    st   r1,pwa_esv                   |
    using esv,r1                      |
    mvc   pwa_es_epa,esvesepa         |
    mvc   pwa_es_token,esvestkn       |
    drop  r1                          |
         space 1                      |
    l     r2,prm_start_dest_option    |
*   *-----------------------------------------------------------------*
*   * If MSGDEST uses a DDname, set up for starting Printline.  We
*   * won't actually start Printline until we know the FOLD option.
*   *-----------------------------------------------------------------*
    if    (cli,0(r2),eq,prm_destopt_DDname) Is MSGDEST 'DDNAME,thing?'
     sbit pwaf1spl                    | Note we need to start Printline
     l     r1,prm_start_dest_DDname   |
     mvc   pwa_ddname,0(r1)           |
     ES_Load_Module  id=ES,spid=PL    | Load Printline (we'll start
     errexit   (treg,r15,nz),         |  it a little later).           *
               code=&MS_environment_support_error
     la    r5,prm_destopt_DDname_#    |                             @C1
*   *-----------------------------------------------------------------*
*   * If MSGDEST uses an existing Printline session, save EPA, token.
*   *-----------------------------------------------------------------*
    elseif (cli,0(r2),eq,prm_destopt_pl)  Does MSGDEST say PL,stuff?
     l     r3,prm_start_dest_plepa    |  Copy existing Printline
     mvc   pwa_pl_epa,0(r3)           |  session's EPA and token.
     l     r3,prm_start_dest_pltoken  |
     mvc   pwa_pl_token,0(r3)         |
     sbit  pwaf1epl                   | Note use of existing PrintLine.
     la    r5,prm_destopt_PL_#        |                             @C1
*   *-----------------------------------------------------------------*
*   * If MSGDEST specifies CONSOLE, we don't need to do anything (now).
*   *-----------------------------------------------------------------*
    elseif (cli,0(r2),eq,prm_destopt_console)  Is MSGDEST 'CONSOLE'?
     sbit  pwaf1cns                   | Note it for later
     la    r5,prm_destopt_console_#   |                             @C1
*   *-----------------------------------------------------------------*
*   * If MSGDEST was not specified, we need to fail Issue_Msg later.
*   *-----------------------------------------------------------------*
    elseif (cli,0(r2),eq,prm_destopt_nodest)  Is MSGDEST missing?
     sbit  pwaf1nmd                   | Note it for later
     la    r5,prm_destopt_nodest_#    |                             @C1
*   *-----------------------------------------------------------------*
*   * Unknown MSGDEST option: return error to caller.
*   *-----------------------------------------------------------------*
    else                              |
     errexit code=&ms_invalid_msgdest_option
    endif                             |
    bctr  r5,0                        | Turn parm count into offset @C1
    sll   r5,2                        | * 4 for disp into parmlist  @C1
    alr   r5,r11                      | Add parmlist base for addr  @C1
    if    (tbit,0(r5),x'80',off)      | If this wasnt last parm:    @C1
     l     r1,4(r5)                   |  Next parm is OPTIONS       @C1
     mvc   pwaop,0(r1)                |  Copy options byte to PWA.  @C1
    endif                             |                             @C1
*   *---------------------------------------------------------------@C2
*   * If timestamp was specified, load and start date service       @C2
*   * processor.                                                    @C2
*   *---------------------------------------------------------------@C2
    if (tbit,pwaoptim)                |   If timestamp option:      @C2
     es_load_module  id=es,spid=dt    |    Load date srv processor. @C2
     errexit not,(%es_success),       |                             @C2*
               code=&ms_environment_support_error                   @C2
     dt_start id=dt                   |    Start date service.      @C2
     errexit not,(%es_success),code=&ms_dt_error                    @C2
    endif                             |   Endif.                    @C2
*   *-----------------------------------------------------------------*
*   * Start Printline, with or without the FOLD option as requested.
*   *-----------------------------------------------------------------*
    if    (tbit,pwaf1spl)             |  With fold option or not?   @C1
     if    (tbit,pwaopfld)            |  With fold option or not?   @C1
      PL_Start ID=PL,                 |  Start PrintLine w/FOLD     @C1*
               DDname=pwa_ddname,     |                             @C1*
               options=fold,          |                             @C1*
               SizeLength=pwa_sizelength                            @C1
     else                             | Else (boy, this is lazy)    @C1
      PL_Start ID=PL,                 |  Start PrintLine w/o FOLD.  @C1*
               DDname=pwa_ddname,     |                             @C1*
               SizeLength=pwa_sizelength                            @C1
     endif                            |                             @C1
     errexit   ((treg,r15,nz),and,not,(%pl_line_wrapping)),         @C4*
               code=&MS_Printline_error                             @C1
    endif                             | Note we started a PrintLine @C1
*   *-----------------------------------------------------------------*
*   * Always start a String Formatter session, since the caller may
*   * want to use MS_Get_Message whether he's using PrintLine or not.
*   *-----------------------------------------------------------------*
    sbit  pwaf1sst                    | Note we started a String Hdlr
    ES_Load_Module  id=ES,spid=ST     | Load string formatter.
    errexit    (treg,r15,nz),         |                                *
               code=&ms_environment_support_error
    ST_Start   ID=ST,                 | Start string formatter.        *
               SizeLength=pwa_sizelength
    errexit    (treg,r15,nz),         |                                *
               code=&ms_string_handler_error
          eject ,                     |
*   *-----------------------------------------------------------------*
*   * If MaxSev was specified, save the MaxSev halfword's address and
*   * note that it's present.
*   *-----------------------------------------------------------------*
    l32   r2,prm_start_max_severity   | Get MaxSev field's address
    if    nz                          | If parm is present
     sbit  pwaf1mxs                   |  Flag that it's there
     st    r2,pwa_maxsev_address      |   and save MaxSev's address.
    endif                             |
*   *-----------------------------------------------------------------*
*   * If PLCC was specified, copy the ASA CC byte for Printline to
*   * local storage: if not provided, default it to a blank.
*   *-----------------------------------------------------------------*
    l32   r2,prm_start_printline_cc   | Get PLCC field's address
    if    nz                          | If parm is present
     mvc   pwa_printline_cc,0(r2)     |  Copy byte to PWA
    else                              | Otherwise
     mvi   pwa_printline_cc,c' '      |  default it to a space.
    endif                             |
*   *-----------------------------------------------------------------*
*   * Load the message modules.  Validate each one as it's loaded, and
*   * complain if it doesn't have the right prolog.
*   *-----------------------------------------------------------------*
    l32  r2,prm_start_message_modlist | Get module list from caller
    errexit z,code=&ms_msgmod_missing | Parm missing? Report error.
    l32  r3,0(r2)                     | Get module count
    errexit z,code=&ms_msgmod_missing | No modules? Report error.
    errexit    (ch,r3,gt,=h'25'),     | More than we wanna handle?     *
               code=&ms_too_many_msgmods  Report as error.
    st    r3,pwa_msgmod_count         | Save module count
    la    r4,4(r2)                    | Point to 1st CL8 modulename
    fill  pwa_msgmod_list,x'00',      | Wipe out message module list   *
               length=(pwa_msgmod_list_length,medium)
    la    r5,pwa_msgmod_list          | Point to our module list
    loop  bct                         | Loop thru caller's module list:
     mvc  dsp_msgmod_name(8,r5),0(r4) |  Copy module name to local stg
     es_load_module ID=ES,            |  Load the module               *
               epname=dsp_msgmod_name(r5),                             *
               epa=dsp_msgmod_mmp(r5) |
     errexit (treg,r15,nz),           |  Not loaded? Report error.     *
               code=&ms_msgmod_not_loaded
     l     r1,dsp_msgmod_mmp(r5)      |  Point to start of MSG mod. @C3
     if (clc,=c'OF',eq,0(r1))         |  If mod begins with c'OF':  @C3
      ah    r1,2(,r1)                 |   2nd halfword is offset of @C3
      st    r1,dsp_msgmod_mmp(r5)     |   of MMP. Fixup MMP pointer.@C3
     endif                            |  Endif.                     @C3
     using mmp_start,r1               |  Ensure msg module is vaild:@C3
     st    r1,pwa_current_mmp         |  Save for ERREXIT if needed
     errexit   (clc,mmp_id,ne,=a(mmp_id_text)),or,  Make sure MMP ID & *
               (clc,mmp_module_name,ne,0(r5)),  CSECT name match what  *
               code=&ms_msgmod_not_valid        a msg module oughta be.
     drop  r1                         |
     la    r4,8(r4)                   |  Point to caller's next module
     la    r5,12(r5)                  |  Point to next modlist entry
    endloop bct,r3                    | That's it.
*   *-----------------------------------------------------------------*
   eject                              |
*  *------------------------------------------------------------------*
*  *
*  * Terminate function.
*  *
*  *------------------------------------------------------------------*
   case &MS_terminate                 |
*   *-----------------------------------------------------------------*
*   * If a PrintLine session was started, shut it down.
*   *-----------------------------------------------------------------*
    if    (tbit,pwaf1spl)             |
     PL_Terminate  ID=PL              |
     ES_Unload_Module  id=ES,spid=PL  | Get rid of PL's loadmodule
    endif                             |
*   *-----------------------------------------------------------------*
*   * If a String Handler session was started, shut it down.
*   *-----------------------------------------------------------------*
    if    (tbit,pwaf1sst)             |
     ST_Terminate ID=ST               |
     ES_Unload_Module  id=ES,spid=ST  | Get rid of ST's loadmodule
    endif                             |
*   *-----------------------------------------------------------------*
*   * Unload all message modules that MS_START loaded.
*   *-----------------------------------------------------------------*
    l     r3,pwa_msgmod_count         |
    la    r4,pwa_msgmod_list          |
    loop  bct                         |
     es_unload_module id=es,          |                                *
               epname=dsp_msgmod_name(r4)
     la    r4,12(r4)                  |
    endloop bct,r3                    |
*   *---------------------------------------------------------------@C2
*   * If timestamp was specified, terminate and unload date service @C2
*   * processor.                                                    @C2
*   *---------------------------------------------------------------@C2
    if (tbit,pwaoptim)                |   If timestamp option:      @C2
     dt_terminate id=dt               |    Terminate date service.  @C2
     errexit not,(%es_success),code=&ms_dt_error                    @C2
     es_unload_module id=es,spid=dt   |    Unload service processor.@C2
     errexit not,(%es_success),       |                             @C2*
               code=&ms_environment_support_error                   @C2
    endif                             |   Endif.                    @C2
*   *-----------------------------------------------------------------*
*   * Indicate PWA should be freed.
*   *-----------------------------------------------------------------*
    smctrl freepwa=yes                |   Free the PWA on return.
*   *-----------------------------------------------------------------*
   eject                              |
*  *------------------------------------------------------------------*
*  *
*  * Issue_Message function.
*  *
*  *------------------------------------------------------------------*
   case &MS_issue_message             |
    lh    r3,pwa_number_of_parms      |   Load number of parameters.
    errexit    (ch,r3,lt,=y(prm_issuemsg_min_#)),or,  Exit if wrong    *
               (ch,r3,gt,=y(prm_issuemsg_max_#)),      no. of parms.   *
               code=&MS_invalid_number_of_parms
        space 1                       |
    errexit    (tbit,pwaf1nmd),       |                                *
               code=&MS_msgdest_not_provided
        space 1                       |
    l     r2,prm_issuemsg_msgid       |
    callsub lookup_and_copy_message,((r2)) | See if message defined
    if    (treg,r15,nz)               | If not:
     errexit (ch,r15,eq,=h'4'),       |  If RC 4                       *
               code=&ms_message_not_found the message was not defined
     errexit (ch,r15,eq,=h'8'),       |  If RC 8                       *
               code=&ms_invalid_prefix    the prefix wasn't loaded.
    endif                             |
    lr    r3,r1                       | Copy MSE pointer
    using mse_start,r3                |  and base on it
    l     r5,pwa_base_msg_length      |
    l     r15,pwa_size_mask           |
    exi   r15,(stcm,r5,b'0000',pwa_msglength_adj)
       space 1                        |
    if    not,(tbit,(pwaf1spl+pwaf1epl),off)
*    *----------------------------------------------------------------*
*    * Build PrintLine parameter list
*    *----------------------------------------------------------------*
     plist    (pwa_PL_token,          | 1: String Formatter's token    *
               &PL_print_formatted,   | 2: Function code               *
               pwa_base_message,      | 3: Control string              *
               pwa_msglength_adj),    | 4: Adjusted msg. length        *
               pl=(pwa_PL_format_pl,57),   Build it here,              *
               novl                   | and don't flip no x'80' bits.
     lr    r7,r1                      |
     if    (clc,pwa_number_of_parms,eq,=y(prm_issuemsg_min_#))
      sbit  12(r7),x'80'              |
     else                             |
      callsub build_sourcelist,       |                                *
               (16(r7),               |                                *
               prm_issuemsg_sourcelist)
     endif                            |
     lr    r1,r7                      | Restore ptr to parmlist start
     callx pwa_pl_epa                 | Call formatted Printline.
     errexit   (treg,r15,nz),         |                                *
               code=&ms_printline_error
    elseif (tbit,pwaf1cns)            | Else if issuing to console(s)
     la    r1,l'pwa_formatted_message |
     st    r1,pwa_formatted_msg_length
     if    (clc,pwa_number_of_parms,eq,=y(prm_issuemsg_min_#))
      xr    r2,r2                     | If no sourcelist, wipe pointer
     else                             |
      la    r2,prm_issuemsg_sourcelist  Otherwise, point to the list.
     endif                            |
     callsub   format,                |  Format the message            *
               (pwa_base_message,     |                                *
               pwa_msglength_adj,     |                                *
               pwa_formatted_message, |                                *
               pwa_formatted_msg_length,                               *
               (r2))                  |
     es_display_message id=ES,        |    ... and write it out.       *
               message=(pwa_formatted_message,pwa_formatted_msg_length)
    endif                             |
*   *-----------------------------------------------------------------*
*   * If MaxSev was specified, adjust caller's MAXCC as needed.
*   *-----------------------------------------------------------------*
    if    (tbit,pwaf1mxs)             | Need to keep up w/MAXSEV?
     l     r15,pwa_maxsev_address     | Get user's maxCC halfword
     if    (clc,mse_severity,gt,0(r15)) Is it less than MSE's severity?
      mvc   0(2,r15),mse_severity     |  Then copy it over.
     endif                            |
    endif                             |
    drop  r3                          |
*   *-----------------------------------------------------------------*
   eject                              |
*  *------------------------------------------------------------------*
*  *
*  * Get_Message function.
*  *
*  *------------------------------------------------------------------*
   case &MS_get_message               |
    lh    r3,pwa_number_of_parms      |   Load number of parameters.
    errexit    (ch,r3,lt,=y(prm_getmsg_min_#)),or,  Exit if wrong      *
               (ch,r3,gt,=y(prm_getmsg_max_#)),      no. of parms.     *
               code=&MS_invalid_number_of_parms
        space 1                       |
    l     r2,prm_getmsg_msgid         |
    callsub lookup_and_copy_message,((r2)) | See if message is around
    if    (treg,r15,nz)               | If not:
     errexit (ch,r15,eq,=h'4'),       |  If RC 4                       *
               code=&ms_message_not_found the message was not defined
     errexit (ch,r15,eq,=h'8'),       |  If RC 8                       *
               code=&ms_invalid_prefix    the prefix wasn't loaded.
    endif                             |
    lr    r3,r1                       | Copy MSE pointer
    using mse_start,r3                |  and base on it
    l     r5,pwa_base_msg_length      |
    l     r15,pwa_size_mask           |
    exi   r15,(stcm,r5,b'0000',pwa_msglength_adj)
    la    r1,l'pwa_formatted_message  |
    st    r1,pwa_formatted_msg_length |
    if    (clc,pwa_number_of_parms,eq,=y(prm_getmsg_min_#))
     xr    r2,r2                      | If no sourcelist, wipe pointer
    else                              |
     la    r2,prm_getmsg_sourcelist   | Otherwise, point to the list.
    endif                             |
    callsub    format,                |  Format the message            *
               (pwa_base_message,     |                                *
               pwa_msglength_adj,     |                                *
               pwa_formatted_message, |                                *
               pwa_formatted_msg_length,                               *
               (r2))                  |
*   *-----------------------------------------------------------------*
*   * Return formatted string to caller.  It may get truncated.
*   *-----------------------------------------------------------------*
    l     r2,prm_getmsg_target        | Point to target
    l     r1,prm_getmsg_target_length | Point to target's length
    l     r1,0(r1)                    | Get target length value
    if    (c,r1,lt,pwa_formatted_msg_length)  If message won't fit
     sbit pwaf1trn                    |   Note that it got whacked
    else                              |  Otherwise
     l    r1,pwa_formatted_msg_length |   use the formatted length.
    endif                             |
    l    r14,prm_getmsg_result_length | Point to where resultlen goes
    l    r15,pwa_size_mask            | Get sizelength mask
    exi  r15,(stcm,r1,b'0000',0(r14)) | Return resultlen to caller
    bctr r1,0                         | Fix up length for EXECUTE
    exi  r1,(mvc,0(0,r2),pwa_formatted_message)  Give string to caller.
*   *-----------------------------------------------------------------*
*   * If MaxSev was specified, adjust caller's MAXCC as needed.
*   *-----------------------------------------------------------------*
    if    (tbit,pwaf1mxs)             | Need to keep up w/MAXSEV?
     l     r15,pwa_maxsev_address     | Get user's maxCC halfword
     if    (clc,mse_severity,gt,0(r15)) Is it less than MSE's severity?
      mvc   0(2,r15),mse_severity     |  Then copy it over.
     endif                            |
    endif                             |
    drop  r3                          |
*   *-----------------------------------------------------------------*
   eject                              |
*  *------------------------------------------------------------------*
*  *
*  * Put_Message function.
*  *
*  *------------------------------------------------------------------*
   case &MS_put_message               |
    lh    r3,pwa_number_of_parms      |   Load number of parameters.
    errexit    (ch,r3,lt,=y(prm_putmsg_min_#)),or,  Exit if wrong      *
               (ch,r3,gt,=y(prm_putmsg_max_#)),      no. of parms.     *
               code=&MS_invalid_number_of_parms
        space 1                       |
    errexit    (tbit,pwaf1nmd),       |                                *
               code=&MS_msgdest_not_provided
        space 1                       |
    l     r2,prm_putmsg_strlen
    l     r15,pwa_size_mask
    exi   r15,(icm,r1,0,0(r2))        | Get length of provided string
    exi   r15,(stcm,r1,0,pwa_msglength_adj)
    st    r1,pwa_formatted_msg_length | Save for later
    l     r2,prm_putmsg_string
    bctr  r1,0
    exi   r1,(mvc,pwa_formatted_message(0),0(r2))
    if    (tbit,pwaopfld)             | If folding to uppercase     @C1
     callsub fold_output,                                              *
               (pwa_formatted_message,pwa_formatted_msg_length)
    endif                             |                             @C1
    if    not,(tbit,(pwaf1spl+pwaf1epl),off)
*    *----------------------------------------------------------------*
*    * Msgdest = Printline: Build PrintLine parameter list
*    *----------------------------------------------------------------*
     callx pwa_pl_epa,                | Call basic Printline:          *
               (pwa_PL_token,         | 1: String Formatter's token    *
               &PL_print,             | 2: Function code               *
               pwa_formatted_message, | 3: Message string              *
               pwa_msglength_adj),vl  | 4: Adjusted msg. length
     errexit   (treg,r15,nz),         |                                *
               code=&ms_printline_error
    elseif (tbit,pwaf1cns)            | Else if issuing to console(s)
*    *----------------------------------------------------------------*
*    * Msgdest = Console: Call ES_Display Message to do a WTO.
*    *----------------------------------------------------------------*
     es_display_message id=ES,        |    ... and write it out.       *
               message=(pwa_formatted_message,pwa_formatted_msg_length)
    endif                             |
*   *-----------------------------------------------------------------*
   eject                              |
*  *------------------------------------------------------------------*
*  * If any other case, this is an invalid function.
*  *------------------------------------------------------------------*
   case other                         | Unknown functioncode?
    errexit code=&MS_invalid_function |  Return error to caller.
  endcase                             |
 space 1                              |
* *-------------------------------------------------------------------*
* *  When exiting, see if we truncated a print line: if so, return a
* *  "truncated" return code, else set returncode zero.
* *-------------------------------------------------------------------*
  if    (tbit,pwaf1trn)               | Did we truncate a print line?
   rbit  pwaf1trn                     |  Turn the flag off
   errexit code=&MS_print_line_truncated  and save error info
  else                                | Otherwise,
   xr    r15,r15                      |  end normally w/RC zero.
  endif                               |
 space 1                              |
 endblk block=&srv_modname,rc=(r15)   |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Build_Sourcelist
*  Purpose:    Append a list of "source" parameters to the end of a
*              standard parameter list.
*  Parameters: On entry, R1 points to the following parameter list:
*                +0 -- Address in dest. parmlist to start stuffing
*                +4 -- List of "source" parameters
*  Calls:      None
*  Notes:      There should be at least 1 parameter in the source list.
*
*---------------------------------------------------------------------*
 block name=build_sourcelist,type=subroutine
  lm    r2,r3,0(r1)                   | Get dest, source list pointers
  loop  until                         | Loop thru list til 80 bit found
   l     r14,0(r3)                    |  Get a parm
   la    r14,0(r14)                   |  Make sure the 80 bit is off
   st    r14,0(r2)                    |  Save into ST_FORMAT parmlist.
   leave loop=*,(tbit,0(r3),x'80')    |  Quit if we moved the last one
   la    r2,4(r2)                     |  Point to next dest and
   la    r3,4(r3)                     |   next sourceparm
  endloop until,leave                 |    and go move them.
  sbit  0(r2),x'80'                   |  Set VL bit at end of VL plist
 endblk                               | That's it.
        eject ,                       |
*---------------------------------------------------------------------*
*
*  Subroutine: Lookup_And_Copy_Message
*  Purpose:    Scan the message module(s) loaded by MS_START for the
*              caller-provided message ID.  If the msg is found, it is
*              copied to pwa_base_message after being prefixed by an
*              ASA CC character is needed.  The new string's length is
*              in pwa_base_msg_length.
*  Parameters: On entry, R1 points to the following parameter list:
*                +0 -- Message ID text address
*  Calls:      None
*  Returns:    R15 = 0: Message found, MSE address in R1
*              R15 = 4: Message not found
*              R15 = 8: Message's prefix not contained in any MMP
*                PWA_Base_Message contains the message, prefixed as
*                necessary with the Printline ASA CC byte.
*
*---------------------------------------------------------------------*
 block name=lookup_and_copy_message,type=subroutine,amode=31
  l     r3,pwa_msgmod_count           | Get module count
  la    r4,pwa_msgmod_list            | Point to our module list
  l     r7,0(r1)                      | Point to MSGID text
  rbit  pwaf1pfx                      |
  loop  bct,name=mmp_scan             | Loop thru caller's module list:
   l     r2,dsp_msgmod_mmp(r4)        | Ensure msg module is valid: @C3
   using mmp_start,r2                 |
   st    r2,pwa_current_mmp           |  Save MMP addr for ERREXIT
   l8    r15,mmp_prefix_length        | Get MMP's prefix length
   bctr  r15,0                        | Fix up for VL compares
   exi   r15,(clc,mmp_prefix(0),0(r7))  See if prefix is in MMP:
   if    eq                           | If so:
    sbit  pwaf1pfx                    |  Note that we found the prefix
    l     r6,mmp_first_mse            |  Get starting MSE pointer
    using mse_start,r6                |
    l32   r5,mmp_mse_count            |   and how many MSE's there are
    if    nz                          |  If any MSE's exist
     loop  bct,name=mse_scan          |   Loop thru them:
      l     r1,mse_address_text       |   Point to message text
      l8    r15,mmp_id_length         |   Get MMP's msgID length
      bctr  r15,0                     |   Fix length up for VL compare
      exi   r15,(clc,0(0,r1),0(r7))   |   Do message ID's match?
      leave loop=mmp_scan,(eq)        |    Yes: R6 points to MSE.
      ah    r6,mmp_mse_element_size   |   Otherwise, point to next MSE
     endloop bct,r5                   |  and loop through them all.
    endif                             |
    drop  r6                          |
   endif                              |
   la    r4,12(r4)                    |  Point to next modlist entry
  endloop bct,r3                      |
  if    (treg,r3,z)                   | If we ran out without a hit:
   if    (tbit,pwaf1pfx,on)           |  If we found the prefix
    la    r15,4                       |   Message ID was missing
   else                               |  Otherwise (bad prefix)
    la    r15,8                       |   Return "prefix_error"
   endif                              |
  else                                | Else (we found it)
   using mse_start,r6                 |  Base on the MSE we found
   if (tbit,pwaoptim)                 |  If timestamp option:       @C2
    fill  &w.prefix,x'40'             |   Blank out prefix.         @C2
    dt_get_current id=dt,             |   Get current time and date.@C2+
               date=(&w.date,&dt_sortdate),                         @C5+
               time=(&w.prefix_time,&dt_hhmmss)                     @C2
    errexit not,(%dt_success),code=&ms_dt_error                     @C2
    mvc  &w.prefix_date,&w.date       |???DT seems to wipe 11 bytes.@C2
    if    (tbit,(pwaf1spl+pwaf1epl),off)  If not using Printline:   @C2
     mvc   pwa_base_message(l'&w.prefix),&w.prefix                  @C2
     la    r14,pwa_base_message+l'&w.prefix      Move prefix to msg.@C2
    else                              |   Else:                     @C2
     mvc   pwa_base_message(1),pwa_printline_cc  Stuff in ASA CC    @C2
     mvc   pwa_base_message+1(l'&w.prefix),&w.prefix                @C2
     la    r14,pwa_base_message+l'&w.prefix+1    Move prefix to msg.@C2
    endif                             |   Endif.                    @C2
    la    r0,pwa_base_message+l'pwa_base_message                    @C2
    slr   r0,r14                      |   Calculate remaining len.  @C2
    l8    r15,mse_length_text         |   Get message length.       @C2
    if (cr,r15,gt,r0)                 |   If message longer than    @C2
     lr    r0,r15                     |   remaining length, use     @C2
*>>> issue error                      |   remaining length.         @C2
    endif                             |                             @C2
    bctr  r15,0                       |   Fix up for Execute        @C2
    l     r1,mse_address_text         |   Point to text itself      @C2
    exi   r15,(mvc,0(0,r14),0(r1))    |   Move message text to msg. @C2
    la    r15,1(r15,r14)              |   Calculate                 @C2
    la    r0,pwa_base_message         |   total length              @C2
    slr   r15,r0                      |   of message.               @C2
   else                               |  Else if not timestamp opt  @C2
    l8    r15,mse_length_text         |   Get message length        @C2
    bctr  r15,0                       |   Fix up for Execute        @C2
    l     r1,mse_address_text         |   Point to text itself      @C2
    if    (tbit,(pwaf1spl+pwaf1epl),off)  If not using Printline:   @C2
     exi   r15,(mvc,pwa_base_message(0),0(r1))  Copy w/o ASA CC     @C2
     la    r15,1(r15)                 |         Restore original len@C2
    else                              |   Otherwise (tag on ASA CC) @C2
     exi   r15,(mvc,pwa_base_message+1(0),0(r1)) Copy, offset by 1  @C2
     mvc   pwa_base_message(1),pwa_printline_cc  Stuff in ASA CC    @C2
     la    r15,2(r15)                 |          Add 1 to old length@C2
    endif                             |   Endif.                    @C2
   endif                              |  Endif.                     @C2
   st    r15,pwa_base_msg_length      |  Set length of base message
   lr    r1,r6                        |  Copy MSE ptr to R1 for STRSA
   strsa r1                           |  Return R1 to caller
   xr    r15,r15                      |  and set returncode zero.
   drop  r6                           |
  endif                               |
 endblk rc=(15)                       |
 space 3                              |                             @C2
         swa                          |                             @C2
&w.date         ds  cl11              |                             @C2
&w.prefix_start equ *                 |                             @C2
&w.prefix_date  ds  cl10              |                             @C5
                ds  c                 |                             @C2
&w.prefix_time  ds  cl8               |                             @C2
                ds  c                 |                             @C2
&w.prefix       equ &w.prefix_start,*-&w.prefix_start               @C2
         endswa                       |                             @C2
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Format
*  Purpose:    Call the String Formatter to format the data provided
*              by the caller.  Parameters are:
*                +0 -- Address of the entire message
*                +4 -- Address of message's length
*                +8 -- Address of target string
*               +12 -- Length of target string.  The resulting
*                      formatted string length is returned here.
*               +16 -- Address of beginning of source parm list, or 0
*  Calls:      String Formatter (external, service processor)
*
*  Notes:      This routine was modified such that the message ID can't
*              be inadvertently wiped by the String Formatter.  This is
*              done by:
*                .. Breaking the message into the message ID and text
*                .. Formatting the text as requested by the caller
*                .. Formatting the msgid and text back together,
*                   returning the result to the caller.
*
*---------------------------------------------------------------------*
 block name=format,type=subroutine,amode=31
  lm    r2,r6,0(r1)                   | Grab caller's parms
  la    r6,0(r6)                      | Kill VL bit from parmlist
  fill  0(r4),c' ',length=255         | Format may not clear printline
  fill  &w.temp_target,c' '           | Clear work text fields
  fill  &w.temp_msgid,c' '            |
  l     r15,pwa_size_mask             | Get sizemask
  la    r1,l'&w.temp_target           | Get real length of temp. target
  exi   r15,(stcm,r1,b'0000',&w.tgtsize_adj)  and set up ST's length.
  l     r7,pwa_current_mmp            | Point to current mmp
  using mmp_start,r7                  |
  l8    r1,mmp_id_length              | Get length of msgids
  exi   r1,(mvc,&w.temp_msgid(0),0(r2)) Copy out the message ID
  la    r1,1(,r1)                     | Add one for blank after msgid
  drop  r7                            |
  la    r7,0(r1,r2)                   | Point to text portion of msg
  l     r14,pwa_size_mask             | Get the size mask
  exi   r14,(icm,r15,b'0000',0(r3))   | Get length of full message
  sr    r15,r1                        | Knock off length of msgid and
  exi   r14,(stcm,r15,b'0000',&w.length_without_msgid)   save for ST.
  plist       (pwa_st_token,          | 1: String Formatter's token    *
               &st_format,            | 2: Function code               *
               &w.temp_target,        | 3: Target area                 *
               &w.tgtsize_adj,        | 4: Adjusted tgt. area size     *
               &w.result_len,         | 5: Returned result length      *
               (r7),                  | 6: Control string past msgid   *
               &w.length_without_msgid), 7: Control string length      *
               pl=(pwa_st_format_pl,57),   Build it here,              *
               novl                   | and don't flip no x'80' bits.
  lr    r7,r1                         | Save PLIST's parmlist pointer
  if    (treg,r6,z)                   |
   sbit  24(r7),x'80'                 | If no sourceparms, note end of
  else                                | list: otherwise, let build_
   callsub build_sourcelist,          | sourcelist figure it out.      *
               (28(r7),(r6))          |
  endif                               |
  lr    r1,r7                         | Restore top-of-parmlist address
  callx pwa_st_epa                    | Call ST_FORMAT w/custom parms.
  if    (treg,r15,nz)                 | If formatter found a problem
   if    (ch,r15,ne,=y(&st_truncated))   Was it truncation?
    sbit  pwaf1trn                    |   Note that it got whacked
   else                               |  Otherwise ...
    errexit code=&MS_string_handler_error              Go choke.
   endif                              |
  endif                               |
  l     r15,pwa_size_mask             | Get the size mask
  l     r1,0(,r5)                     | Get length of final target
  exi   r15,(stcm,r1,b'0000',&w.tgtsize_adj) Set it up for SRVST
  la    r1,l'&s.final_format          | Get l'2nd format string
  exi   r15,(stcm,r1,b'0000',&w.l_final_format) Set it up for SRVST
  plist       (pwa_st_token,          | 1: String Formatter's token    *
               &st_format,            | 2: Function code               *
               (r4),                  | 3: Target string               *
               &w.tgtsize_adj,        | 4: Adjusted target string len  *
               &w.result_len,         | 5: Length of returned stuff    *
               &s.final_format,       | 6: Control string              *
               &w.l_final_format,     | 7: Adjusted control string len *
               &w.temp_msgid,         | 8: Parm 1: message ID          *
               &w.temp_target),       | 9: Parm 2: message text.       *
               pl=(pwa_st_format_pl,9),vl  Build it here
  callx  pwa_st_epa                   |
* st_format    id=ST,                 |
*              control="{CL15 T} {CL255 T}",
*              source=(&w.temp_msgid,&w.temp_target),
*              string=((r4),&w.tgtsize_adj),
*              resultlen=&w.result_len
  if    (treg,r15,nz)                 | If formatter found a problem
   if    (ch,r15,eq,=y(&st_truncated))   Was it truncation?
    sbit  pwaf1trn                    |   Note that it got whacked
   else                               |  Otherwise ...
    errexit code=&MS_string_handler_error              Go choke.
   endif                              |
  endif                               |
  xr    r1,r1                         |
  l     r15,pwa_size_mask             | Get the SizeLength ICM mask
  exi   r15,(icm,r1,0,&w.result_len)  | Get the length
  st    r1,0(r5)                      | Save fullword length
  if    (tbit,pwaopfld)               | If folding to uppercase     @C1
   callsub fold_output,((r4),(r5))    |  call routine to do it.     @C1
  endif                               |                             @C1
 endblk                               |
       ssd   ,                        |
&s.final_format  dc  c"{CL15 T} {CL255 T}"
       endssd ,                       |
       swa  ,                         |
&w.tgtsize_adj  ds   f                |
&w.result_len   ds   f                |
&w.length_without_msgid  ds   f       |
&w.l_final_format        ds   f       |
&w.temp_msgid   ds   cl16             |
&w.temp_target  ds   cl255            |
       endswa ,                       |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Fold_Output
*  Purpose:    Translate caller-provided output line (or line produced
*              by String Handler) to uppercase.
*  Parameters: On entry, R1 points to the following parameter list:
*                +0 -- Address of record to translate
*                +4 -- Address of fullword length of record
*  Returned:   Output line folded in place
*  Calls:      None
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block name=Fold_Output,type=subroutine                             @C1
  lm   r3,r4,0(r1)                    | Point to record to fold     @C1
  l    r4,0(r4)                       | Get its length              @C1
  bctr r4,0                           | Subtract 4, plus 1 for EXI  @C1
  exi  r4,(tr,0(0,r3),psd_fold_table) | Make data uppercase.        @C1
 endblk rc=(r15)                      |                             @C1
 eject                                |
*---------------------------------------------------------------------*
*
*  Errexit:    Unnamed
*  Purpose:    Save debugging information and exit with the return
*              code pointed to by r14 at entry to this exit.
*  Notes:      For some cases, various registers may point to info we
*              want to display.  For example, when the MSGMOD errors
*              are detected, R4 points to the module name in error.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block type=errexit                   |
* es_display_debug_info_and_abend id=es << TESTING >>
* *-------------------------------------------------------------------*
* * Save module/offset, registers, return-code.
* *-------------------------------------------------------------------*
  st    r15,pwa_reason                | Save possible return-code.
  stm   r0,r15,gdiregs                | Save registers at time of error
  sm_lal r0,&srv_modname+4            | Point to module identification.
  st    r0,gdimodid                   | Save in general debug area.
  mvc   gdirc,0(r14)                  | Copy return code.
  sl    r14,=a(&srv_modname)          | Calculate offset at time of err
  sth   r14,gdioffst                  | Save in debug area.
  l     r2,pwaaesv                    | Point r2 to ESV.
  using esv,r2                        | Establish base for ESV.
  callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_gdi,gdi)
* *-------------------------------------------------------------------*
* * Look at the error code.  If add'l information would be useful,
* * (ie. the msgid of the message we couldn't find), stuff into the
* * debug area.
* *-------------------------------------------------------------------*
  lh    r15,gdirc                     | Get return code.
  caseblk reg=r15,mult=1              | Case on return-code.
    case &ms_message_not_found        | Message_not_found:
      l     r3,pwa_current_mmp        |
      using mmp_start,r3              |
      l     r5,prm_issuemsg_msgid     |
      fill  pwa_base_message,c' '     |
      mvc   pwa_base_message(l'psd_nomsg_1),psd_nomsg_1
      l8    r1,mmp_id_length          |
      bctr  r1,0                      |
      exi   r1,(mvc,pwa_base_message+l'psd_nomsg_1(0),0(r5))
      la    r1,pwa_base_message+l'psd_nomsg_1+1(r1)
      mvc   0(l'psd_nomsg_2,r1),psd_nomsg_2
      la    r1,l'psd_nomsg_2(r1)      |
      la    r15,pwa_base_message      |
      sr    r1,r15                    |
      st    r1,pwa_base_msg_length    |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               pwa_base_message,pwa_base_msg_length)
      drop  r3                        |
    case &ms_msgmod_not_loaded        | Msgmod_not_loaded (r4 -> name)
      fill  pwa_base_message,c' '     |
      mvc   pwa_base_message(l'psd_msgload_1),psd_msgload_1
      mvc   pwa_base_message+l'psd_msgload_1(8),0(r4)
      la    r1,pwa_base_message+l'psd_msgload_1+8
      mvc   0(l'psd_msgload_2,r1),psd_msgload_2
      la    r1,l'psd_msgload_2(r1)    |
      la    r15,pwa_base_message      |
      sr    r1,r15                    |
      st    r1,pwa_base_msg_length    |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               pwa_base_message,pwa_base_msg_length)
    case &ms_msgmod_not_valid         | Msgmod_invalid    (r4 -> name)
      fill  pwa_base_message,c' '     |
      mvc   pwa_base_message(l'psd_msgmod_1),psd_msgmod_1
      mvc   pwa_base_message+l'psd_msgmod_1(8),0(r4)
      la    r1,pwa_base_message+l'psd_msgmod_1+8
      mvc   0(l'psd_msgmod_2,r1),psd_msgmod_2
      la    r1,l'psd_msgmod_2(r1)     |
      la    r15,pwa_base_message      |
      sr    r1,r15                    |
      st    r1,pwa_base_msg_length    |
      callx esvesepa,(esvestkn,&es_save_debug_info,&es_debug_id_text,  *
               pwa_base_message,pwa_base_msg_length)
    case other                        |  Don't bother w/other errors.
  endcase                             | EndCase.
  drop r2                             |
* *-------------------------------------------------------------------*
* * Set the return-code and exit.
* *-------------------------------------------------------------------*
  lh    r15,gdirc                     | Set return code.
 endblk                               |
 eject                                |
 title "Program Static Data"          |
                psd                   |
eyecatcher      dc   cl8"MS_SP"       | Eyecatcher value for dumps.
psd_bit_mask    dc   b'0001',b'0011',b'0111',b'1111'
psd_nomsg_1     dc   c"Message ID "   |
psd_nomsg_2     dc   c" not found."   |
psd_msgmod_1    dc   c"Message module "
psd_msgmod_2    dc   c" has invalid format."
psd_msgload_1   dc   c"Message module "
psd_msgload_2   dc   c" could not be loaded."
*
psd_fold_table    dc   256al1(*-psd_fold_table)                     @C1
             org psd_fold_table+c"a"  |                             @C1
             dc   c'ABCDEFGHI'        |                             @C1
             org psd_fold_table+c"j"  |                             @C1
             dc   c'JKLMNOPQR'        |                             @C1
             org psd_fold_table+c"s"  |                             @C1
             dc   c'STUVWXYZ'         |                             @C1
             org  ,                   |                             @C1
                ltorg ,               |
                endpsd                |
          title "Dsects"              |
          ms_mmp dsect=yes,id=mmp_    |
          eject                       |
          ms_mse dsect=yes,id=mse_    |
          eject                       |
          es_esv ,                    |
         title "Parameter List"       |
parmlist                      dsect , |
prm_MS_id                     ds a    | Div identifier === PWA base
prm_functioncode              ds a    | Function to be performed
prm_min_#                     equ (*-parmlist)/4
prm_function_dept             equ *   | Function-dependent parameters
*---------------------------------------------------------------------*
*
*                  Start function parameters
*
*---------------------------------------------------------------------*
                  org prm_function_dept
prm_start_esv                 ds a    | Environment Support Vector.
prm_start_message_modlist     ds a    | Message module list address.
prm_start_sizelength          ds a    | Size return area.
prm_start_max_severity        ds a    | Halfword maxcc (optional)
prm_start_printline_cc        ds a    | ASA carriage ctl for Printline
*                                     |   messages (' ' if not spec'd)
prm_start_dest_option         ds a    | MsgDest option byte address
prm_start_min_#               equ (*-parmlist)/4
prm_start_dest_specific       equ *   | MsgDest-specific parameters:
*---------------------------------------------------------------------*
*  MsgDest option = 0:  No message destination specified.
*---------------------------------------------------------------------*
prm_destopt_nodest            equ  0  |
prm_destopt_nodest_#          equ  (*-parmlist)/4
*---------------------------------------------------------------------*
*  MsgDest option = 1:  Write message to specific DDname via Printline
*---------------------------------------------------------------------*
      org   prm_start_dest_specific   |
prm_destopt_DDname            equ  1  |
prm_start_dest_DDname         ds a    | Address of DDname to write to
prm_destopt_DDname_#          equ  (*-parmlist)/4
*---------------------------------------------------------------------*
*  MsgDest option = 2:  Write message using existing Printline session
*---------------------------------------------------------------------*
      org   prm_start_dest_specific   |
prm_destopt_PL                equ  2  |
prm_start_dest_plepa          ds a    | Address of PrintLine EPA
prm_start_dest_pltoken        ds a    | Address of PrintLine token
prm_destopt_PL_#              equ  (*-parmlist)/4
*---------------------------------------------------------------------*
*  MsgDest option = 3:  Write message to console.  (no extra parms)
*---------------------------------------------------------------------*
      org   prm_start_dest_specific   |
prm_destopt_console           equ  3  |
prm_destopt_console_#         equ  (*-parmlist)/4
      org   ,                         |
prm_start_option              ds   a  | Note: Since this parm may   @C1
*                                     |       appear behind a vari- @C1
*                                     |       able-length list, its @C1
*                                     |       position must be der- @C1
*                                     |       ived.                 @C1
prm_start_max_#               equ (*-parmlist)/4
*---------------------------------------------------------------------*
*
*                 Terminate function parameters
*
*---------------------------------------------------------------------*
                  org prm_function_dept
prm_terminate_#               equ (*-parmlist)/4
*---------------------------------------------------------------------*
*
*                Issue_Message function parameters
*
*---------------------------------------------------------------------*
                  org prm_function_dept
prm_issuemsg_msgid            ds a    | Message number
prm_issuemsg_min_#            equ (*-parmlist)/4
prm_issuemsg_sourcelist       ds 50a  |
prm_issuemsg_max_#            equ (*-parmlist)/4
*---------------------------------------------------------------------*
*
*                 Get_Message function parameters
*
*---------------------------------------------------------------------*
                  org prm_function_dept
prm_getmsg_msgid              ds a    | Message number
prm_getmsg_target             ds a    | Address of target string
prm_getmsg_target_length      ds a    | Max. length of target string
prm_getmsg_result_length      ds a    | Length of returned string
prm_getmsg_min_#              equ (*-parmlist)/4
prm_getmsg_sourcelist         ds 50a  |
prm_getmsg_max_#              equ (*-parmlist)/4
*---------------------------------------------------------------------*
*
*                Put_Message function parameters
*
*---------------------------------------------------------------------*
                  org prm_function_dept
prm_putmsg_string             ds a    | Message number
prm_putmsg_strlen             ds a    |
prm_putmsg_min_#              equ (*-parmlist)/4
prm_putmsg_max_#              equ (*-parmlist)/4
                  org ,               |
prm_max_#                     equ (*-parmlist)/4
*
          title "Program Work Area"   |
               PWA                    |
pwa_area       ds    0f               | Beginning of visible PWA stg.
pwa_visual     ds    cl8              | Character string 'DIV_SP'.
pwa_MS_id      ds    a                | Pointer to program work area.
pwa_clear_start equ  *                | This area cleared by MS_START.
pwa_ES_epa     ds    f                | Environment Support EPA.
pwa_ddname     ds    cl8              | DDname to pass to Printline.
pwa_ES_token   ds    f                | Environment Support PWA token.
pwa_MM_epa     ds    f                | Memory Manager EPA.
pwa_MM_token   ds    f                | Memory Manager PWA token.
pwa_DT_epa     ds    f                | Date services EPA.          @C2
pwa_DT_token   ds    f                | Date services PWA token.    @C2
pwa_ST_epa     ds    f                | String Formatter EPA.
pwa_ST_token   ds    f                | String Formatter PWA token.
pwa_PL_epa     ds    f                | Printline EPA.
pwa_PL_token   ds    f                | Printline PWA token.
*                                     |  is that spec'd by SizeLength.
pwa_msglength_adj    ds  f            | Adjusted MSE message length.
pwa_sizelength ds    f                |
pwa_maxsev_address ds f               | Address of MaxSev (if any)
pwa_reason     ds    f                |
pwa_size_mask  ds    f                | Mask to load lengths using ICM
pwa_current_MMP  ds  f                |
pwa_clear_end  equ  *                 | End area cleared by MS_START.
pwa_clear_length   equ   pwa_clear_end-pwa_clear_start
pwa_ESV        ds    f                |
pwa_number_of_parms ds h              | Number of parms.
*                                     |
pwa_printline_cc  ds  c               | ASA CC for Printline.
*                                     |
pwaf1        ds    x                  | General flag byte:
*                                     |
pwaf1spl     equ   x'80'  |1... ....| | . Printline session should be
*                                     |   started. This means that
*                                     |   MS_Terminate needs to shut
*                                     |   Printline down.
pwaf1epl     equ   x'40'  |.1.. ....| | . Use existing PrintLine, EPA &
*                                     |   token provided by caller.
pwaf1sst     equ   x'20'  |..1. ....| | . StringHandler session started
*                                     |   This means that MS_Terminate
*                                     |   needs to shut it down.
pwaf1cns     equ   x'10'  |...1 ....| | . MSGDEST=CONSOLE specified.
*                                     |   This means that PrintLine
*                                     |   cannot be used.
pwaf1mxs     equ   x'08'  |.... 1...| | . MaxSev was specified. This
*                                     |   means that PWA_Maxsev_Address
*                                     |   points to a 'MaxCC' halfword
*                                     |   that Message Services should
*                                     |   maintain based on messages'
*                                     |   message ID severity.
pwaf1trn     equ   x'04'  |.... .1..| | . Formatted string was trunc'd.
*                                     |   This was actually returned by
*                                     |   StringHandler.  As much data
*                                     |   as will fit is printed or
*                                     |   returned to the caller.
pwaf1nmd     equ   x'02'  |.... ..1.| | . No message destination was
*                                     |   provided.  This means that
*                                     |   we must fail ISSUE_MESSAGE
*                                     |   requests and only allow GET_
*                                     |   MESSAGE.
pwaf1pfx     equ   x'01'  |.... ...1| | . Prefix found (used internally
*                                     |   by lookup_and_copy_message).
*                                     |
*                                     |
pwaop         ds    x                 | OPTIONS from MS_START:      @C1
pwaopfld      equ   x'80' '1... ....' | . Fold msgs to uppercase.   @C1
pwaoptim      equ   x'40' '.1.. ....' | . Time stamp messages.      @C2
*             equ   x'7f' '..11 1111' | . Reserved.                 @C2
*                                     |
pwa_sourceparm_count ds f             | Count of parms in sourcelist.
*                                     |   Used by set_fmt_hdr, _ftr.
pwa_pl_format_pl  ds    0f            | Parms for Printline, -or-
pwa_st_format_pl  ds    57a           | Parms for string formatter.
*                                     |
pwa_base_msg_length       ds  f       |
pwa_base_message          ds  cl256   |
pwa_formatted_msg_length  ds  f       |
pwa_formatted_message     ds  cl512   |
*                                     |
               es_gdi dsect=no        | General debugging information.
pwa_msgmod_count  ds    f             |
pwa_msgmod_list   ds    25cl12        |
dsp_msgmod_name   equ   0             |
dsp_msgmod_mmp    equ   8             |                             @C3
pwa_msgmod_list_length equ *-pwa_msgmod_list
pwa_area_l     equ   *-pwa_area       | Length of visible PWA stg.
               endpwa                 |
               end   ,                |
