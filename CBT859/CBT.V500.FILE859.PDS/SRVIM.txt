*---------------------------------------------------------------------*
*  Copyright 2011 by Clemson University Research Foundation           *
*                                                                     *
*  Licensed under the Apache License, Version 2.0 (the "License");    *
*  you may not use this file except in compliance with the License.   *
*  You may obtain a copy of the License in this library as member     *
*  $LICENSE, or from                                                  *
*                                                                     *
*      http://www.apache.org/licenses/LICENSE-2.0                     *
*                                                                     *
*  Unless required by applicable law or agreed to in writing,         *
*  software distributed under the License is distributed on an "AS    *
*  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either    *
*  express or implied.  See the License for the specific language     *
*  governing permissions and limitations under the License.           *
*---------------------------------------------------------------------*
SRVIM    TITLE 'Item Manager Service Processor'
         SMLIST CONVERT=YES           |
         srvmod name=srvim,dates='1989, 1991, 1995'
         gblc  &srv_modname
*---------------------------------------------------------------------*
*
*  Copyright (C) Clemson University Research Foundation 1989, 1991.
*
*  Program     SRVIM, Item Manager Service Processor.
*
*  Abstract    The Item Manager Service Processor can be used to
*              manage units of storage, which this service processor
*              refers to as items.  Items are maintained in IMMS
*              (Item Manager Managed Storage).
*
*              The storage occupied by items can optionally be
*              backed on secondary storage.  To do this, the caller
*              must provide on startup to this processor, the EPA of
*              a service processor similiar to the MVS DIV Service
*              Processor (SRVMVSDV).
*
*  >>>>> Warning <<<<<
*
*  This module is still not completely developed.  It is working with
*  limited function.  The functions that are not yet available are
*  noted in the following description.
*
*  Special note:
*     This program uses registers 4 through 8 exclusively to reference
*     IMMS.  This should aid in the conversion of this program to
*     use MVS data spaces.  Because of this convention, there is
*     some code that appears to be duplicate.  Usually this is
*     because one piece of code accesses an item in IMMS and one
*     accesses it in the caller's space.
*
*  Functions, Description and Syntax:
*
*    Two parameters, ItemID and FunctionCode, are required for each
*    call to the Item manager.  Additional parameters are required
*    for different FunctionCodes.  The entire parameter list required
*    for each function is listed below. A "<" before a parameter means
*    that it is returned to the caller.  A ">" before a parameter
*    indicates that the parameter is passed to the service processor.
*    "<>" means both.  A parameter followed by an "|" is optional or
*    has a default.  If the "|" is followed by a value, that value is
*    the default.
*
*    START
*
*      The start function is used to start the item manager and
*      optionally associate a DIV manager with the item manager.
*
*      CALLX SRVIM,(<ItemID,&IM_Start,
*        <ESV,
*        >Options,
*        >DIV_EPA|,
*        >DIV_DDName|)
*
*    TERMINATE
*
*      The terminate function is used to terminate the item manager.
*
*      CALLX SRVIM,(>ItemID,&IM_Terminate)
*
*    INITIALIZE
*
*      The initialize function is used to initialize IMMS (Item manager
*      managed storage).  This function should be called immediately
*      after a &IM_ITEM_STORAGE_NOT_INITIALIZED return code from the
*      IM_START function.
*
*      CALLX SRVIM,(>ItemID,&IM_Initialize,
*        >ITDStgSize|65536,
*        >UAStgIncr|65536,
*        >SysStgIncr|4096,
*        >DUStgIncr|65536)
*
*    SAVE
*
*      The save function will use the DIV manager supplied at startup
*      to save all changes made to IMMS since startup or the
*      last save function.
*
*      CALLX SRVIM,(>ItemID,&IM_Save)
*
*    RESET
*
*      The reset function will use the DIV manager supplied at
*      startup to throw away all changes made to IMMS since
*      startup or the last save function.
*
*      CALLX SRVIM,(>ItemID,&IM_Reset)
*
*    ADD_TO_DIRECTORY
*
*      This function adds a name and token to the token directory.
*
*      CALLX SRVIM,(>ItemID,&IM_Add_To_Directory,
*        >NameLength,
*        >Name,
*        >Token)
*
*    FIND_IN_DIRECTORY
*
*      This function finds the token associated with a name in the
*      token directory.
*
*      CALLX SRVIM,(>ItemID,&IM_Find_In_Directory,
*        >NameLength,
*        >Name,
*        <Token)
*
*    REMOVE_FROM_DIRECTORY
*
*      This function removes a name from the token directory.
*
*      CALLX SRVIM,(>ItemID,&IM_Find_In_Directory,
*        >NameLength,
*        >Name)
*
*    CREATE_ITEM_TYPE_DESCRIPTOR
*
*      The create item type descriptor function will create an ITD
*      (item type descriptor) in <64K system IMMS.  All items
*      have a ITD token in the first two bytes.  This descriptor
*      contains information about a item of a given type, such as size,
*      number of links, etc.  ITD tokens will never have a value
*      greater than 65,535, which is the largest unsigned number that
*      can fit in two bytes.
*
*      CALLX SRVIM,(>ItemID,&IM_Create_Item_Type_Descriptor,
*        <DescriptorToken,
*        >Text|,
*        >Options|x'00',
*           First_Link_Has_Description
*        >GroupDescriptorToken|DefaultUserGroup,
*        >ItemLength|0,
*        >NumberOfLinks|0,
*        >FirstLinkOffset|,
*        >ItemLengthSize|,
*        >ItemLengthOffset|,
*        >NumberOfLinksSize|,
*        >NumberOfLinksOffset|,
*        >FirstLinkOffsetSize|,
*        >FirstLinkOffsetOffset|)
*
*    CREATE_GROUP_DESCRIPTOR
*
*      The create group descriptor function will create a GRD (group
*      descriptor) in system IMMS.  Groups are used to group
*      together items of certain types in IMMS.  IMMS for
*      a groups of items are obtained in increments that are the size
*      contained in the group descriptor or the size of the item,
*      whichever is larger, and is rounded up to a multiple of 4096
*      bytes.
*
*      CALLX SRVIM,(>ItemID,&IM_Create_Group_Descriptor,
*        <DescriptorToken,
*        >Text|,
*        >IncrementSize|4096)
*
*    CREATE_LINKED_LIST_DESCRIPTOR
*
*      The create linked list descriptor function will create a LLD
*      (linked list descriptor) in system IMMS.
*
*      CALLX SRVIM,(>ItemID,&IM_Create_Linked_List_Descriptor,
*        <DescriptorToken,
*        >Text|,
*        >Options|x'00',
*        >StartLinkNumber,
*        >EndLinkNumber|,
*        >ForwardLinkNumber,
*        >ReverseLinkNumber|,
*        >OwnerLinkNumber|,
*        >KeyOffset|0,
*        >KeyLength|0,
*        >KeyLengthOffset|)
*
*
*    CREATE_HASH_TABLE_DESCRIPTOR
*
*      The create hash table descriptor function will create a HTD
*      (hash table descriptor) in system IMMS.
*
*      CALLX SRVIM,(>ItemID,&IM_Create_Hash_Table_Descriptor,
*        <DescriptorToken,
*        >Text|,
*        >Options|x'00',
*        >EntriesInTable,
*        >SynonymLinkNumber,
*        >KeyOffset,
*        >KeyLength|0,       Either KeyLength or KeyLengthOffset is
*        >KeyLengthOffset|)  required.
*
*
*    CREATE_BINARY_TREE_DESCRIPTOR                (not yet supported)
*
*      The create binary tree descriptor function will create a BTD
*      (binary tree descriptor) in system IMMS.
*
*      CALLX SRVIM,(>ItemID,&IM_Create_Binary_Tree_Descriptor,
*        <DescriptorToken,
*        >Text|,
*        not defined yet.
*
*    DESTROY                                      (not yet supported)
*
*      The destroy function will destroy a descriptor created with
*      one of the create functions.
*
*      CALLX SRVIM,(>ItemID,&IM_Destroy,
*         >DescriptorToken,
*         >ForceFlag|"N")
*
*    GET_DANGEROUS_ADDRESSES
*
*      The get dangerous addresses function get the address of certain
*      internal item manager control blocks and service routines.  It
*      is only intended to allow a clean interface for writing
*      utility programs that process IMMS and is not intended
*      for normal application programs.  MOST OF THE INTEGRITY AND
*      REDUNDANCY BUILT INTO THE ITEM MANAGER CAN BE BYPASSED BY THE
*      USE OF THIS FUNCTION.  Do you get the idea that its use is
*      highly discouraged?
*
*      All right, I admit it ... I use this function.
*
*      CALLX SRVIM,(>ItemID,&IM_Get_Dangerous_Addresses,
*        >TokenConvertRoutine|)
*
*    CONNECT
*
*      The connect function will connect an item to whatever is
*      described by a descriptor.  The descriptor can be a LLD, HTD or
*      BTD.  The item will become current of descriptor.  If ItemToken
*      is not specified, the current item of item manager is used.  If
*      HeadToken is not specified and the descriptor describes a
*      multiple occurance, the current of item type of the heads,
*      as specified on the associated create funtion, is used.
*
*      CALLX SRVIM,(>ItemID,&IM_Connect,
*        >DescriptorToken,>ItemToken|,>HeadToken|)
*
*    DISCONNECT                                   (not yet supported)
*
*      The disconnect function will disconnect an item from whatever is
*      described by a descriptor.  The descriptor can be a LLD, HTD or
*      BTD.  The item will become current of descriptor.  If ItemToken
*      is not specified, the current item of item manager is used.  If
*      HeadToken is not specified and the descriptor describes a
*      multiple occurance, the current of item type of the heads,
*      as specified on the associated create funtion, is used.
*
*      CALLX SRVIM,(>ItemID,&IM_Disconnect,
*        >DescriptorToken,>ItemToken|,>HeadToken|,>PreviousToken|)
*
*    ERASE
*
*      The erase function frees the storage associated with an
*      item.  If the item token is not specified, the current item
*      of item manager is erased.  All link pointers in the item
*      must be null before the item can be erased unless the force
*      option is "Y".
*
*      CALLX SRVIM,(>ItemID,&IM_Erase,
*        >Options|x'00',>ItemToken|)
*
*    FIND
*
*      The find function will locate a given item by its item token.
*      The item will become current for item manager and current for
*      item type.
*
*      CALLX SRVIM,(>ItemID,&IM_Find,
*        >ItemToken,
*        <ActualItemSize|)
*
*    FIND_BY_KEY                                  (not yet supported)
*
*      The find by key function will obtain a given item by key, from
*      whatever is associated with a given descriptor.  The item will
*      become current for item manager, current for descriptor, and
*      current for item type.
*
*      CALLX SRVIM,(>ItemID,&IM_Find_by_Key,
*        >DescriptorToken,
*        >KeySize,
*        >Key,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    FIND_CURRENT_OF_ITEM_TYPE
*
*      The find current of item type function will locate the item
*      that is current of a given item type.  The item becomes
*      current of item manager and remains current of item type.
*
*      CALLX SRVIM,(>ItemID,&IM_Find_Current_of_Item_Type,
*        >ItemType,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    FIND_CURRENT_FOR_DESCRIPTOR
*
*      The find current of descriptor function will locate the
*      item that is current of descriptor for the descriptor
*      specified.  The item obtained becomes current of item manager
*      and current of item type and remains current of descriptor.
*
*      CALLX SRVIM,(>ItemID,&IM_Find_Current_for_Descriptor,
*        >DescriptorToken,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    FIND_NEXT
*
*      The find next function will locate the next item after the
*      item that is current of a given descriptor.  The item will
*      become current of item manager, current of item type and
*      current of descriptor.
*
*      CALLX SRVIM,(>ItemID,&IM_Find_Next,
*        >DescriptorToken,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    FIND_PRIOR
*
*      The find prior function will locate the item before the
*      item that is current of a given descriptor.  The item will
*      become current of item manager, current of item type and
*      current of descriptor.
*
*      CALLX SRVIM,(>ItemID,&IM_Find_Prior,
*        >DescriptorToken,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    FIND_OWNER
*
*      The find owner function will locate the owner of the
*      item that is current of a given descriptor.  The item will
*      become current of item manager and current of item type.
*      The item must have owner links assigned in the descriptor
*      specified to use this function.
*
*      CALLX SRVIM,(>ItemID,&IM_Find_Owner,
*        >DescriptorToken,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    FIND_FIRST
*
*      The find first function will locate the first item
*      connected to a given descriptor.  The item will become
*      current of item manager, current of item type and current of
*      descriptor.
*
*      CALLX SRVIM,(>ItemID,&IM_Find_First,
*        >DescriptorToken,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    FIND_FINAL
*
*      The find final function will locate the final item
*      connected to a given descriptor.  The item will become
*      current of item manager, current of item type and current of
*      descriptor.
*
*      CALLX SRVIM,(>ItemID,&IM_Find_Final,
*        >DescriptorToken,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    GET
*
*      The get function will get the record that is current of
*      item manager.  Currency is not changed.
*
*      CALLX SRVIM,(>ItemID,&IM_Get,
*        >ReturnSize,
*        <Item,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    MODIFY
*
*      The modify function will modify a record.  If the item token
*      is not specified, the current item of item manager is changed.
*      The item becomes current of item manager and current of item
*      type.
*
*      CALLX SRVIM,(>ItemID,&IM_Modify,
*        >ItemAddress,
*        >Options|x'00',
*        >ItemToken|)
*
*    OBTAIN
*
*      The obtain function will obtain a given item by its item token.
*      The item will become current for item manager and current for
*      item type.
*
*      CALLX SRVIM,(>ItemID,&IM_Obtain,
*        >ItemToken,
*        >ReturnSize,
*        <Item,
*        <ActualItemSize|)
*
*    OBTAIN_BY_KEY                                (not yet supported)
*
*      The obtain by key function will obtain a given item by key, from
*      whatever is associated with a given descriptor.  The item will
*      become current for item manager, current for descriptor, and
*      current for item type.
*
*      CALLX SRVIM,(>ItemID,&IM_Obtain_by_Key,
*        >DescriptorToken,
*        >KeySize,
*        >Key,
*        >ReturnSize,
*        <Item,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    OBTAIN_CURRENT_OF_ITEM_TYPE
*
*      The obtain current of item type function will obtain the item
*      that is current of a given item type.  The item becomes
*      current of item manager and remains current of item type.
*
*      CALLX SRVIM,(>ItemID,&IM_Obtain_Current_of_Item_Type,
*        >ItemType,
*        >ReturnSize,
*        <Item,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    OBTAIN_CURRENT_OF_DESCRIPTOR
*
*      The obtain current of descriptor function will obtain the
*      item that is current of descriptor for the descriptor
*      specified.  The item obtained becomes current of item manager
*      and current of item type and remains current of descriptor.
*
*      CALLX SRVIM,(>ItemID,&IM_Obtain_Current_for_Descriptor,
*        >DescriptorToken,
*        >ReturnSize,
*        <Item,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    OBTAIN_NEXT
*
*      The obtain next function will obtain the next item after the
*      item that is current of a given descriptor.  The item will
*      become current of item manager, current of item type and
*      current of descriptor.
*
*      CALLX SRVIM,(>ItemID,&IM_Obtain_Next,
*        >DescriptorToken,
*        >ReturnSize,
*        <Item,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    OBTAIN_PRIOR
*
*      The obtain prior function will obtain the item before the
*      item that is current of a given descriptor.  The item will
*      become current of item manager, current of item type and
*      current of descriptor.
*
*      CALLX SRVIM,(>ItemID,&IM_Obtain_Prior,
*        >DescriptorToken,
*        >ReturnSize,
*        <Item,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    OBTAIN_OWNER
*
*      The obtain owner function will obtain the owner of the
*      item that is current of a given descriptor.  The item will
*      become current of item manager and current of item type.
*      The item must have owner links assigned in the descriptor
*      specified to use this function.
*
*      CALLX SRVIM,(>ItemID,&IM_Obtain_Owner,
*        >DescriptorToken,
*        >ReturnSize,
*        <Item,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    OBTAIN_FIRST
*
*      The obtain first function will obtain the first item
*      connected to a given descriptor.  The item will become
*      current of item manager, current of item type and current of
*      descriptor.
*
*      CALLX SRVIM,(>ItemID,&IM_Obtain_First,
*        >DescriptorToken,
*        >ReturnSize,
*        <Item,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    OBTAIN_FINAL
*
*      The obtain final function will obtain the final item
*      connected to a given descriptor.  The item will become
*      current of item manager, current of item type and current of
*      descriptor.
*
*      CALLX SRVIM,(>ItemID,&IM_Obtain_Final,
*        >DescriptorToken,
*        >ReturnSize,
*        <Item,
*        <ActualItemSize|,
*        <ItemToken|)
*
*    SORT
*
*      The sort function will sort the items in a structure described
*      by a descriptor.
*
*      CALLX SRVIM,(>ItemID,&IM_Sort,
*        >DescriptorToken,
*        >Fieldslist,
*        >HeadToken|)
*
*    STORE
*
*      The store function will store a new item.  The item becomes
*      current of item manager and current of item type.
*
*      CALLX SRVIM,(>ItemID,&IM_Store,
*        >ItemAddress,
*        >Options|x'00',
*        >ItemToken|)
*
*
*  Special note:  Other information such as return codes can be
*                 found the the "Clemson University Service Processor
*                 User Guide and Reference" contained in the source
*                 library.
*
*  Program     reentrant, problem key and state, server linkage,
*  Attributes  non-authorized, amode(any), rmode(any)
*
*  Change
*  History     03/11/89 MGG - New
*              12/18/98 CAM - Changed to always use subpool 0
*            2001-01-16 MJM - Added type BIT to IM_SORT function.
*            2001-07-26 MJM - Updated get_itc instruction that      @C1
*                             clears itc_f to use mvi instead of    @C1
*                             mvc. Updated find_by_key to get a new @C1
*                             ITC if the item is variable sized as  @C1
*                             well as if the item's links have a    @C1
*                             variable offset.                      @C1
*
*---------------------------------------------------------------------*
 eject                                |
 gbla  &number_of_itds                | Number of ITDs.
 gbla  &number_of_itdxs               | Number of extended ITDs.
 copy  smsyms                         | Copy structured macro symbols.
 copy  srvesmac                       | Environment support macros.
 copy  srvmmmac                       | Memory manager macros.
 copy  srvimmac                       | Item manager macros.
 copy  srvimimc                       | Item manager internal macros.
 copy  srvdvmac                       | Data in virtual macros.
         macro                        |
         imlks &reg,&itc,&cb,&immwreg=r8
         gbla  &im_internal_error
         if (tbit,&cb.f1ksi)          |
          l     &immwreg,&cb.kszof    |
          al    &immwreg,&itc+itc_address-itc_
          l8    &reg,0(&immwreg)      |
         else                         |
          l     &reg,&cb.ksz          |
         endif                        |
         mend
         macro                        |
         imlla &addr,&lnk#,&itc       |
         gbla  &im_invalid_link_number
         l     r1,&lnk#               | Load link number
         if (treg,r1,nz)              | If non-zero
          errexit (c,r1,gt,&itc.+itc_number_links-itc_),               +
               code=&im_invalid_link_number
          bctr  r1,0                  |  Calculate address
          sll   r1,2                  |  of link in IMMS.
          al    r1,&itc.+itc_offset_links-itc_  Calc address
          al    r1,&itc.+itc_address-itc_       of link.
         endif                        | Endif.
         ##st  r1,&addr               | Save result.
         mend                         |
*
*
         macro
         litda &addr,&token
         ##l   r1,&token              |
         al    r1,pwa_imc_address     |
         ##st  r1,&addr               |
         mend
*
*
         macro                        |
         imlta &addr,&token           |
         gblc  &pwa                   |
         ##l   r0,&token,wreg=r1      |
         la    r1,&pwa                |
         callx pwa_im_quick_get_address
         ##st  r1,&addr               |
         mend                         |
         space 2                      |
         macro                        |
         itc   &id=itc_,&dsect=no     |
&i       setc  '&id'                  |
         aif   ('&dsect' ne 'yes').no_dsect
&i       dsect                        |
         ago   .past_header           |
.no_dsect anop                        |
&i       ds     0f                    |
.past_header anop                     |
&i.token                       ds f   | Item token.
&i.address                     ds a   | Item address.
&i.itd_address                 ds a   | ITD address.
&i.size                        ds a   | Item size.
&i.number_links                ds a   | Number of links.
&i.offset_links                ds a   | Offset of links.
&i.itype                       ds h   | Item type.
&i.f                           ds bl1 | Flags.
&i.f_variable_size         equ  b'10000000'
&i.f_variable_number_links equ  b'01000000'
&i.f_variable_links_offset equ  b'00100000'
                               ds bl1 |
&i.storage equ &i,*-&i                | Equate for storage.
         mend                         |
         macro                        |
         kpm   &id=kpm_,&dsect=no     |
&i       setc  '&id'                  |
         aif   ('&dsect' ne 'yes').no_dsect
&i       dsect                        |
         ago   .past_header           |
.no_dsect anop                        |
&i       ds     0f                    |
.past_header anop                     |
&i.first_token                  ds f  |
&i.search_key_address           ds a  |
&i.search_key_length            ds x  |
                                ds xl2
&i.key_length                   ds x  |
&i.key_length_offset            ds f  |
&i.key_offset                   ds f  |
&i.link_number                  ds f  |
&i.cbsze equ *-&i.
         mend                         |
*
*  Define L32 user cond name.
*
         defucond name=l32,macro=l32_ucond
         macro
&name    l32_ucond &expr,&s=,&f=,&l=
         aif (n'&expr ne 4).err0001   |
&name    l32   &expr(2),&expr(3)      | Load address of token value.
         ##cond &expr(4),                                              +
               s=&s,f=&f,l=&l         |
         mexit                        |
.err0001 mnote 8,"Incorrect number of parameters in %L32 expr"
         mend                         |
 eject                                |
 block name=&srv_modname,type=program,amode=31,rmode=any,              +
               options=(*srvprc,novl,long,dyn,main,                    +
               (parms,copy,(copyerror,,&im_invalid_number_of_parms),   +
               (count,pwa_number_of_parms),(using,r9),vl)),            +
               parmmap=(prm,prm_max_#*4),                              +
               subopts=(*swa,loadbase,(parms,(using,r9),prefix))
* *-------------------------------------------------------------------*
* *  Establish ids for service processors used.
* *-------------------------------------------------------------------*
  es_id id=es,spepa=pwa_es_epa,       | Environment support.           +
               sptoken=pwa_es_token,  |                                +
               esva=pwaaesv           |
  mm_id id=mm,spepa=pwa_mm_epa,       | Memory manager.                +
               spepname=&memory_manager
* *-------------------------------------------------------------------*
* * Get function code and call subroutine to process the function.
* *-------------------------------------------------------------------*
  l     r2,prm_functioncode           | Load the function code into
  l     r2,0(,r2)                     |   a register for testing.
  la    r1,prm_function_dependent     | Point r1 to function dependent
*                                     | parameters.
  caseblk reg=r2,wreg=r15             | Start of function case block.
   case &start                        |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_start_max_#)),          +
               code=&im_invalid_number_of_parms
    callsub start_function            |
   case &terminate                    |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_terminate_max_#)),      +
               code=&im_invalid_number_of_parms
    callsub terminate_function        |
   case &im_initialize                |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_initialize_max_#)),     +
               code=&im_invalid_number_of_parms
    callsub initialize_function       |
   case &im_save                      |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_save_max_#)),           +
               code=&im_invalid_number_of_parms
    callsub save_function             |
   case &im_reset                     |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_reset_max_#)),          +
               code=&im_invalid_number_of_parms
    callsub reset_function            |
   case &im_add_to_directory          |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_add_to_dir_max_#)),     +
               code=&im_invalid_number_of_parms
    callsub add_to_directory_function |
   case &im_find_in_directory         |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_find_in_dir_max_#)),    +
               code=&im_invalid_number_of_parms
    callsub find_in_directory_function
   case &im_remove_from_directory     |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_remove_from_dir_max_#)),+
               code=&im_invalid_number_of_parms
    callsub remove_from_directory_function
   case &im_create_item_type_descriptor
    errexit (clc,pwa_number_of_parms,gt,=a(prm_create_itd_max_#)),     +
               code=&im_invalid_number_of_parms
    callsub create_item_type_descriptor_function
   case &im_create_group_descriptor   |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_create_gd_max_#)),      +
               code=&im_invalid_number_of_parms
    callsub create_group_descriptor_function
   case &im_create_linked_list_descriptor
    errexit (clc,pwa_number_of_parms,gt,=a(prm_create_ld_max_#)),      +
               code=&im_invalid_number_of_parms
    callsub create_linked_list_descriptor_function
   case &im_create_hash_table_descriptor
    errexit (clc,pwa_number_of_parms,gt,=a(prm_create_ht_max_#)),      +
               code=&im_invalid_number_of_parms
    callsub create_hash_table_descriptor_function
   case &im_connect                   |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_connect_max_#)),        +
               code=&im_invalid_number_of_parms
    callsub connect_function          |
   case &im_disconnect                |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_disconnect_max_#)),     +
               code=&im_invalid_number_of_parms
    callsub disconnect_function       |
   case &im_get                       |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_get_max_#)),            +
               code=&im_invalid_number_of_parms
    callsub get_function              |
   case &im_get_dangerous_addresses   |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_gda_max_#)),            +
               code=&im_invalid_number_of_parms
    callsub get_dangerous_addresses_function
   case &im_find                      |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd_max_#)),             +
               code=&im_invalid_number_of_parms
    callsub find_function             |
   case &im_find_by_key               |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_fdky_max_#)),           +
               code=&im_invalid_number_of_parms
    callsub find_by_key_function      |
   case &im_find_current_of_item_type |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd2_max_#)),            +
               code=&im_invalid_number_of_parms
    callsub find_current_of_item_type_function
   case &im_find_current_of_descriptor
    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd2_max_#)),            +
               code=&im_invalid_number_of_parms
    callsub find_current_of_descriptor_function
   case &im_find_next                 |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd2b_max_#)),           +
               code=&im_invalid_number_of_parms
    callsub find_next_function        |
   case &im_find_prior                |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd2b_max_#)),           +
               code=&im_invalid_number_of_parms
    callsub find_prior_function       |
   case &im_find_owner                |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd2c_max_#)),           +
               code=&im_invalid_number_of_parms
    callsub find_owner_function       |
   case &im_find_first                |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd2a_max_#)),           +
               code=&im_invalid_number_of_parms
    callsub find_first_function       |
   case &im_find_final                |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_fd2a_max_#)),           +
               code=&im_invalid_number_of_parms
    callsub find_final_function       |
   case &im_obtain                    |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob_max_#)),             +
               code=&im_invalid_number_of_parms
    callsub obtain_function           |
   case &im_obtain_by_key             |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_obky_max_#)),           +
               code=&im_invalid_number_of_parms
    callsub obtain_by_key_function    |
   case &im_obtain_current_of_item_type
    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob2_max_#)),            +
               code=&im_invalid_number_of_parms
    callsub obtain_current_of_item_type_function
   case &im_obtain_current_of_descriptor
    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob2_max_#)),            +
               code=&im_invalid_number_of_parms
    callsub obtain_current_of_descriptor_function
   case &im_obtain_next               |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob2b_max_#)),           +
               code=&im_invalid_number_of_parms
    callsub obtain_next_function      |
   case &im_obtain_prior              |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob2b_max_#)),           +
               code=&im_invalid_number_of_parms
    callsub obtain_prior_function     |
   case &im_obtain_owner              |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob2c_max_#)),           +
               code=&im_invalid_number_of_parms
    callsub obtain_owner_function     |
   case &im_obtain_first              |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob2a_max_#)),           +
               code=&im_invalid_number_of_parms
    callsub obtain_first_function     |
   case &im_obtain_final              |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_ob2a_max_#)),           +
               code=&im_invalid_number_of_parms
    callsub obtain_final_function     |
   case &im_sort                      |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_sort_max_#)),           +
               code=&im_invalid_number_of_parms
    callsub sort_function             |
   case &im_store                     |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_store_max_#)),          +
               code=&im_invalid_number_of_parms
    callsub store_function            |
   case &im_modify                    |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_modify_max_#)),         +
               code=&im_invalid_number_of_parms
    callsub modify_function           |
   case &im_erase                     |
    errexit (clc,pwa_number_of_parms,gt,=a(prm_erase_max_#)),          +
               code=&im_invalid_number_of_parms
    callsub erase_function            |
   case other                         |  For all other codes
    errexit code=&im_invalid_function |  it is an invalid function.
  endcase                             | Endcase.
 space 1                              |
 endblk block=&srv_modname,rc=0       |
 drop   r9                            | Drop base for parms.
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Start_Function
*  Abstract:   This subroutine processes the start function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=start_function,                            +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * Move environment support EPA and token to PWA.
* *-------------------------------------------------------------------*
  l     r2,pwaaesv                    |
  using esv,r2                        |
  mvc   pwa_es_epa,esvesepa           | Move EPA.
  mvc   pwa_es_token,esvestkn         | Move token.
  drop  r2                            | Drop base.
* *-------------------------------------------------------------------*
* * If a DIV EPA is supplied, start the DIV Service Processor.
* *-------------------------------------------------------------------*
  mvi   &w.mode,c"U"                  | Assume update mode.
  l32   r1,prm_start_options          | If read only specified:
  if nz,and,(tbit,0(r1),prm_start_options_read_only)
   mvi   &w.mode,c"R"                 |  Make mode read.
  endif                               |
  l32   r1,prm_start_div_epa          | If DIV routine provided:
  if nz                               |
   icm   r1,b'1111',0(r1)             |
   if nz                              |
    st    r1,pwa_dv                   |  Start DIV.
    callx pwa_dv,(pwa_dv_token,       |                                +
               &start,                |                                +
               pwaaesv,               |                                +
               *prm_start_div_ddname, |                                +
               &w.mode,               |                                +
               pwa_initial_size),vl   |
    errexit (treg,r15,nz),code=&im_div_start_failed
    l     r1,pwa_initial_size         |   Adjust size
    sll   r1,12                       |   from blocks
    st    r1,pwa_initial_size         |   to bytes.
   endif                              |  Endif.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Start the memory manager.
* *-------------------------------------------------------------------*
  es_load_module id=es,spid=mm        | Load memory manager.
  errexit (treg,r15,nz),code=&im_memory_manager_load_failed
  mm_start id=mm,increment==a(4096)   | Start memory manager.
  errexit (treg,r15,nz),code=&im_memory_manager_start_failed
* *-------------------------------------------------------------------*
* * Store address of quick get address routine away.
* *-------------------------------------------------------------------*
  sm_lal r0,quick_get_address         | Load address of routine.
  l32   r1,prm_start_options          | If read only specified:
  if nz,and,(tbit,0(r1),prm_start_options_actual_address)
   sbit  pwa_f_actual_address         |  Indicate use actual address.
   sm_lal r0,quick_get_address_actual |  Use actual address routine.
  endif                               | Endif.
  st    r0,pwa_im_quick_get_address   | Save the address in PWA.
* *-------------------------------------------------------------------*
* * If the initial size is non-zero, get increment; otherwise,
* * set return code that indicates that a initialize function
* * call is required.
* *-------------------------------------------------------------------*
  l32   r0,pwa_initial_size           |
  errexit z,code=&im_item_storage_not_initialized
  callsub get_data_space_increment,   | Get a data space increment.    +
               (pwa_initial_size,,    |                                +
               pwa_imc_address)       |
  l     r4,pwa_imc_address            | Load address of IMC.
  using imc,r4                        | Establish base for IMC.
  mvc   imc4more,imc4more+imclssz     |
  es_get_time id=es,                  | Get date and time.             +
               time=pwa_time,date=pwa_date
  mvc   imclsdat,pwa_date             | Set creation date
  mvc   imclstim,pwa_time             | and time.
  drop  r4                            | Drop base for IMC.
* *-------------------------------------------------------------------*
 endblk block=start_function          |
         space 2
         swa
&w.mode  ds    cl1
         endswa
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Terminate_Function
*  Abstract:   This subroutine processes the start function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=terminate_function,                        +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * Terminate DIV SP.
* *-------------------------------------------------------------------*
  l32   r15,pwa_dv                    | Point r15 to DIV service proc.
  if nz                               | If one exist:
   callx (r15),(pwa_dv_token,&terminate),vl Call it with terminate.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Free item memory.
* *-------------------------------------------------------------------*
* callsub release_data_space
* *-------------------------------------------------------------------*
* * Terminate Memory Manager.
* *-------------------------------------------------------------------*
  l32   r15,pwa_mm_epa                | Load memory manager EPA.
  if nz                               | If it is loaded:
   mm_terminate id=mm                 |   Terminate it.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Indicate PWA should be freed.
* *-------------------------------------------------------------------*
  smctrl freepwa=yes                  | Free the PWA on return.
* *-------------------------------------------------------------------*
 endblk block=terminate_function      |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Initialize_Function
*  Abstract:   This subroutine processes the initialize function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=initialize_function,                       +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * It is a error if final setup has already taken place.
* *-------------------------------------------------------------------*
  errexit (tbit,pwa_f_final_setup),   |                                +
               code=&im_setup_already_complete
* *-------------------------------------------------------------------*
* * Get ITD storage size.
* *-------------------------------------------------------------------*
  l     r0,=a(64*1024)                | Put default in r0.
  l32   r1,prm_initialize_itd_stg_size  Point r1 to parameter.
  if nz                               | If it was specified:
   l32   r1,0(r1)                     |  Load r1 with parameter.
   if nz                              |  If it is non-zero:
    lr    r0,r1                       |   Use value supplied.
   endif                              |  Endif.
  endif                               | Endif.
  ah    r0,=f'4095'                   | Round size
  srl   r0,12                         | to multiple
  sll   r0,12                         | of 4K.
  st    r0,pwa_lt_64k_size            | Save size.
* *-------------------------------------------------------------------*
* * Get unallocated storage increment size.
* *-------------------------------------------------------------------*
  l     r0,=a(64*1024)                | Put default in r0.
  l32   r1,prm_initialize_ua_stg_incr   Point r1 to parameter.
  if nz                               | If it was specified:
   l32   r1,0(r1)                     |  Load r1 with parameter.
   if nz                              |  If it is non-zero:
    lr    r0,r1                       |   Use value supplied.
   endif                              |  Endif.
  endif                               | Endif.
  ah    r0,=f'4095'                   | Round size
  srl   r0,12                         | to multiple
  sll   r0,12                         | of 4K.
  st    r0,pwa_increment              | Save size.
* *-------------------------------------------------------------------*
* * Get system storage increment size.
* *-------------------------------------------------------------------*
  l     r0,=a(4*1024)                 | Put default in r0.
  l32   r1,prm_initialize_sys_stg_incr  Point r1 to parameter.
  if nz                               | If it was specified:
   l32   r1,0(r1)                     |  Load r1 with parameter.
   if nz                              |  If it is non-zero:
    lr    r0,r1                       |   Use value supplied.
   endif                              |  Endif.
  endif                               | Endif.
  ah    r0,=f'4095'                   | Round size
  srl   r0,12                         | to multiple
  sll   r0,12                         | of 4K.
  st    r0,pwa_system_storage_increment Save size.
* *-------------------------------------------------------------------*
* * Get default user storage increment size.
* *-------------------------------------------------------------------*
  l     r0,=a(64*1024)                | Put default in r0.
  l32   r1,prm_initialize_sys_stg_incr  Point r1 to parameter.
  if nz                               | If it was specified:
   l32   r1,0(r1)                     |  Load r1 with parameter.
   if nz                              |  If it is non-zero:
    lr    r0,r1                       |   Use value supplied.
   endif                              |  Endif.
  endif                               | Endif.
  ah    r0,=f'4095'                   | Round size
  srl   r0,12                         | to multiple
  sll   r0,12                         | of 4K.
  st    r0,pwa_default_user_storage_increment Save size.
* *-------------------------------------------------------------------*
* * Get data space large enough for first increment or <64k storage
* * plus a system storage increment, whichever is larger.
* *-------------------------------------------------------------------*
  l     r1,pwa_lt_64k_size            | Calculate size
  a     r1,pwa_system_storage_increment of initial data space.
  if (c,r1,lt,pwa_increment)          | If this is smaller than
   l     r1,pwa_increment             | the increment, use the
  endif                               | increment.
  st    r1,pwa_initial_size           | Set this to initial size.
  callsub get_data_space_increment,   | Get a data space increment.    +
               (pwa_initial_size,,    |                                +
               pwa_imc_address)       |
* *-------------------------------------------------------------------*
* * The IMC starts at start of space.
* *-------------------------------------------------------------------*
  l     r4,pwa_imc_address            | Load address of IMC.
  using imc,r4                        | Establish base for IMC.
  l     r2,pwaaesv                    | Point r2 to ESV.
  using esv,r2                        | Establish base for ESV.
  es_get_time id=es,                  | Get date and time.             +
               time=pwa_time,date=pwa_date
  mvc   imccrdat,pwa_date             | Set creation date
  mvc   imccrtim,pwa_time             | and time.
  mvc   imclsdat,pwa_date             | Set last used date
  mvc   imclstim,pwa_time             | and time.
  mvc   imcpgmnm,=cl8'&srv_modname'   | Set program name.
  la    r5,imcitmsz(,r4)              | Point r5 to next storage.
* *-------------------------------------------------------------------*
* * Assign the system storage that will be used.  This includes
* * a GRD for the 4 standard groups and a single GSS, if needed.
* * The GRDs and GSSs will be completed later.
* *-------------------------------------------------------------------*
  l     r1,pwa_lt_64k_size            | Past <64K storage is sys stg.
  if (tbit,pwa_f_actual_address)      | If actual addresses
   alr   r1,r4
*  * For "unassigned" GRD
   st    r1,imcgrdua                     Save "unassigned" GRD token.
   st    r1,imcfrgrd                     Also first GRD in chain.
   la    r2,grditmsz(r1)                 Increment.
   st    r2,grdfrgss-grd(r1)             Save token of GSS in GRD.
   la    r1,gssitmsz(r2)                 Increment.
*  * For "<64K storage" GRD
   st    r1,imcgrdls                     Save <64K GRD token.
   la    r2,grditmsz(r1)                 Increment.
   st    r2,grdfrgss-grd(r1)             Save token of GSS in GRD.
   la    r1,gssitmsz(r2)                 Increment.
*  * For "Default user storage" GRD
   st    r1,imcgrddf                     Save default group token.
   la    r1,grditmsz(r1)                 Increment.
*  * For "System storage" GRD
   st    r1,imcgrdsy                     Save token in IMC.
   la    r2,grditmsz(r1)                 Increment.
   st    r2,grdfrgss-grd(r1)             Save token of GSS in GRD.
   la    r0,gssitmsz(r2)                 Increment.
   sl    r0,imcgrdua                     Calculate sys storage used.
   st    r0,gssused-gss(r2)              Save in GSS.
   la    r1,gssitmsz(r2)                 Increment.
   st    r1,gssfrfsi-gss(r2)             Store token of FSI.
  else
*  * For "unassigned" GRD
   st    r1,imcgrdua                     Save "unassigned" GRD token.
   st    r1,imcfrgrd                     Also first GRD in chain.
   la    r2,grditmsz(r1)                 Increment.
   st    r2,grdfrgss-grd(r1,r4)          Save token of GSS in GRD.
   la    r1,gssitmsz(r2)                 Increment.
*  * For "<64K storage" GRD
   st    r1,imcgrdls                     Save <64K GRD token.
   la    r2,grditmsz(r1)                 Increment.
   st    r2,grdfrgss-grd(r1,r4)          Save token of GSS in GRD.
   la    r1,gssitmsz(r2)                 Increment.
*  * For "Default user storage" GRD
   st    r1,imcgrddf                     Save default group token.
   la    r1,grditmsz(r1)                 Increment.
*  * For "System storage" GRD
   st    r1,imcgrdsy                     Save token in IMC.
   la    r2,grditmsz(r1)                 Increment.
   st    r2,grdfrgss-grd(r1,r4)          Save token of GSS in GRD.
   la    r0,gssitmsz(r2)                 Increment.
   s     r0,pwa_lt_64k_size              Calculate sys storage used.
   st    r0,gssused-gss(r2,r4)           Save in GSS.
   la    r1,gssitmsz(r2)                 Increment.
   st    r1,gssfrfsi-gss(r2,r4)          Store token of FSI.
  endif
* *-------------------------------------------------------------------*
* * Define a macro to create the first simple ITDs.
* *-------------------------------------------------------------------*
  macro                               |
  build_simple_ITD &cb=,&class=,&token=,&grd=imcgrdls,&flag=,&num=
  gbla  &number_of_itds               | Number of ITDs.
&number_of_itds seta &number_of_itds+1  Add 1 to number.
  using itd,r5                        | Establish base for ITD.
  aif ('&token' eq '').no_token       |
  lr    r0,r5                         | Calculate token for
  slr   r0,r4                         | item type descriptor.
  st    r0,&token                     | Save token.
.no_token anop                        |
  l     r0,imctditd                   | Load token for ITD ITD.
  sth   r0,itditype                   | Store token in ITD.
  mvc   itdclass,=y(&class)           | Set item class.
  aif   ('&flag' eq '').no_flag       |
  mvi   itdf1,&flag                   | Move flag to ITD.
.no_flag  anop                        |
  mvc   itdiln,=al1(&cb.itmsz)        | Set item size.
  mvc   itdinl,=al1(&cb.#lnks)        | Set item number of links.
  mvc   itdilo,=al1(&cb.links-&cb.)   | Set item links offset.
  aif   ('&num' eq '').no_num         |
  mvc   itdnumit,&num                 | Move number of items to ITD.
.no_num   anop                        |
  aif   ('&grd' eq '').no_grd         |
  mvc   itdgrd,&grd                   | Set GRD.
.no_grd   anop                        |
  drop  r5                            | Drop base for itd.
  la    r5,itditmsz(,r5)              | Point to next storage.
  mend                                |
* *-------------------------------------------------------------------*
* * Create first item type descriptors.
* *-------------------------------------------------------------------*
  build_simple_itd cb=itd,            | Build one for ITD itself.      +
               class=&im_class_item_type_descriptor,                   +
               token=imctditd,        |                                +
               flag=itdf1dfl,         |                                +
               grd=imcgrdls,          |                                +
               num=psd_number_of_itds |
  build_simple_itd cb=itdx,           | Build one for extended ITD.    +
               class=&im_class_item_type_descriptor,                   +
               token=imctditdx,       |                                +
               flag=itdf1dfl,         |                                +
               grd=imcgrdls,          |                                +
               num=psd_number_of_itdxs
  build_simple_itd cb=grd,            | Build one for GRD.             +
               class=&im_class_group_descriptor,                       +
               token=imctdgrd,        |                                +
               flag=itdf1dfl,         |                                +
               grd=imcgrdsy,          |                                +
               num==a(4)              |
  build_simple_itd cb=gss,            | Build one for GSS.             +
               class=&im_class_unclassified,                           +
               token=imctdgss,        |                                +
               grd=imcgrdsy,          |                                +
               num==a(3)              |
  lr    r0,r5                         | Calculate token for IMC's.
  slr   r0,r4                         | item type descriptor.
  sth   r0,imcitype                   | Store token in IMC item type.
  build_simple_itd cb=imc,            | Build the ITD for the IMC.     +
               class=&im_class_unclassified,                           +
               grd=imcgrdls,          |                                +
               num==a(1)              |
* *-------------------------------------------------------------------*
* * Define a macro to create skeleton GRDs.
* *-------------------------------------------------------------------*
  macro                               |
  build_skeleton_grd &token=,&increment=,&method=2,&next=
  gbla  &im_class_freespace           | Free space class.
  gbla  &number_of_itdxs              | Number of extended ITDs.
  l     r6,&token                     | Calculate
  if not,(tbit,pwa_f_actual_address)  | address
   alr   r6,r4                        | of
  endif                               | GRD.
  using grd,r6                        | Establish base for ITD.
&number_of_itdxs seta &number_of_itdxs+1 Add 1 to number.
  using itd,r5                        | Establish base for ITD.
  lr    r0,r5                         | Calculate token for
  slr   r0,r4                         | item type descriptor.
  st    r0,grdtdfsi                   | Save token.
  l     r0,imctditdx                  | Load token for ITDX ITD.
  sth   r0,itditype                   | Store token in ITD.
  mvc   itdclass,=y(&im_class_freespace) Set item class.
  mvi   itdf1,itdf1ext+itdf1lni       | Move flag to ITD.
  mvi   itdxilnsz,4                   | Set item length size.
  mvc   itdxilnof,=a(fsisize-fsi)     | Set item length size offset.
  mvc   itdxinl,=a(fsi#lnks)          | Set item number of links.
  mvc   itdxilo,=a(fsilinks-fsi)      | Set item links offset.
  mvc   itdgrd,&token                 | Set GRD.
  drop  r5                            | Drop base for ITD.
  la    r5,itdxitmsz(,r5)             | Point to next storage.
  mvc   grditype,imctdgrd+2           | Set GRD item type token.
  mvc   grdincsz,&increment           | Set increment size.
  mvc   grdmmthd,=y(&method)          | Method.
  mvc   grdnxgrd,&next                | Next GRD pointer.
  drop  r6                            | Drop base for ITD.
  mend                                |
* *-------------------------------------------------------------------*
* * Build base skeleton GRDs.
* *-------------------------------------------------------------------*
  build_skeleton_grd token=imcgrdua,increment=pwa_increment,           +
               next=imcgrdls,method=1 |
  build_skeleton_grd token=imcgrdls,increment==a(0),                   +
               next=imcgrdsy          |
  build_skeleton_grd token=imcgrdsy,  |                                +
               increment=pwa_system_storage_increment,                 +
               next=imcgrddf          |
  build_skeleton_grd token=imcgrddf,  |                                +
               increment=pwa_default_user_storage_increment,           +
               next==a(0)             |
* *-------------------------------------------------------------------*
* * Build GSS and FSI for <64K system storage.
* *-------------------------------------------------------------------*
  using fsi,r5                        | Establish base for FSI.
  l     r6,imcgrdls                   | Calculate
  if not,(tbit,pwa_f_actual_address)  | address
   alr   r6,r4                        | of
  endif                               | GRS.
  using grd,r6                        | Establish base for GRD.
  l     r7,grdfrgss                   | Calculate
  if not,(tbit,pwa_f_actual_address)  |  address
   alr   r7,r4                        |  of
  endif                               |  GSS.
  using gss,r7                        | Establish base for GSS.
  mvc   gssitype,imctdgss+2           | Set item type for GSS.
  lr    r0,r5                         | Calculate size of
  slr   r0,r4                         | segment used.
  st    r0,gssused                    | Save size in GSS.
  st    r0,gssfrfsi                   | Store token of FSI.
  l     r0,pwa_lt_64k_size            | Load size of segment.
  st    r0,gsssize                    | Store size in GSS.
  sl    r0,gssused                    | Calculate freespace remaining
  st    r0,fsisize                    | Store amount in FSI.
  st    r0,gsslrgst                   | Set largest free space.
  mvc   fsiitype,grdtdfsi+2           | Move ITD token to free space.
  mvc   fsinu1,=h'-1'                 | Set -1 field to -1.
  drop  r5,r6,r7                      | Drop base for FSI, GRD & GSS.
* *-------------------------------------------------------------------*
* * Build GSS and free space entry for system storage.
* *-------------------------------------------------------------------*
  l     r6,imcgrdsy                   | Calculate
  if not,(tbit,pwa_f_actual_address)  |  address
   alr   r6,r4                        |  of
  endif                               |  GRS.
  using grd,r6                        | Establish base for GRD.
  l     r7,grdfrgss                   | Calculate
  if not,(tbit,pwa_f_actual_address)  |  address
   alr   r7,r4                        |  of
  endif                               |  GSS.
  using gss,r7                        | Establish base for GSS.
  mvc   gssitype,imctdgss+2           | Set item type for GSS.
  l     r0,pwa_lt_64k_size            | GSS starts
  if (tbit,pwa_f_actual_address)      | right
   alr   r0,r4                        | after
  endif                               | <64k
  st    r0,gssstart                   | storage.
  l     r5,gssfrfsi                   | Calculate
  if not,(tbit,pwa_f_actual_address)  | address
   alr   r5,r4                        | of
  endif                               | FSI.
  using fsi,r5                        | Establish base for large FSI.
  l     r0,pwa_system_storage_increment Load size of segment.
  st    r0,gsssize                    | Store size in GSS.
  sl    r0,gssused                    | Calculate freespace remaining.
  st    r0,gsslrgst                   | Set the largest free space.
  st    r0,fsisize                    | Store amount in FSI.
  mvc   fsiitype,grdtdfsi+2           | Move ITD token to free space.
  mvc   fsinu1,=h'-1'                 | Set -1 field to -1.
  drop  r5,r6,r7                      | Drop base for FSI, GRD & GSS.
* *-------------------------------------------------------------------*
* * Build GSS and FSI for unassigned storage.
* *-------------------------------------------------------------------*
  l     r6,imcgrdua                   | Calculate
  if not,(tbit,pwa_f_actual_address)  | address
   alr   r6,r4                        | of
  endif                               | GRS.
  using grd,r6                        | Establish base for GRD.
  l     r7,grdfrgss                   | Calculate
  if not,(tbit,pwa_f_actual_address)  |  address
   alr   r7,r4                        |  of
  endif                               |  GSS.
  using gss,r7                        | Establish base for GSS.
  mvc   gssitype,imctdgss+2           | Set item type for GSS.
  l     r0,pwa_initial_size           | Load size of segment.
  st    r0,gsssize                    | Store size in GSS.
  l     r1,pwa_lt_64k_size            | Calculate storage
  al    r1,pwa_system_storage_increment used.
  st    r1,gssused                    | Save in GSS.
  sr    r0,r1                         | Calculate unassigned size.
  errexit m,code=&im_internal_error   | Error if negative.
  st    r0,gsslrgst                   | This is the largest free space.
  if nz                               | If unassigned stg remains.
   if (tbit,pwa_f_actual_address)     |  If ress
    alr   r1,r4                       |   Calculate address of FSI.
    st    r1,gssfrfsi                 |   Save its address.
    lr    r5,r1                       |   Point r5 to FSI.
   else                               |  Else:
    st    r1,gssfrfsi                 |   Gssused is also token.
    lr    r5,r1                       |   Calculate address
    alr   r5,r4                       |   of FSI.
   endif                              |  Endif.
   using fsi,r5                       |  Establish base for FSI.
   st    r0,fsisize                   |  Store amount in FSI.
   mvc   fsiitype,grdtdfsi+2          |  Move ITD token to freespace.
   mvc   fsinu1,=h'-1'                |  Set -1 field to -1.
  endif                               | Endif.
  drop  r5,r6,r7                      | Drop base for FSI, GRD & GSS.
* *-------------------------------------------------------------------*
* * Make an item type descriptor for descriptions.
* *-------------------------------------------------------------------*
  mvc   &w.system_grd_token,imcgrdsy  | Get system GRD token.
  callsub create_item_type_descriptor_function,                        +
               (&w.itd,               |                                +
               ,                      | Can't make a description yet!  +
               ,                      | No options yet.                +
               &w.system_grd_token,   | Put in system storage.         +
               ,,,                    | Length, #links, links offset.  +
               1,=a(dscsize-dsc),     | Length is in item.             +
               ,,                     | Number of link are fixed (0).  +
               ,)                     | Offset of links is fixed (0).
  l16   r0,&w.itd                     | Load r0 with token of ITD.
  st    r0,imctddsc                   | Save this in IMC.
  litda r5,r0                         | Load address of ITD.
  using itd,r5                        | Establish base for ITD.
  mvc   itdclass,=y(&im_class_description) Set class.
  drop  r5                            | Endif.
* *-------------------------------------------------------------------*
* * Make an item type descriptor for link list descriptors.
* *-------------------------------------------------------------------*
  callsub create_item_type_descriptor_function,                        +
               (&w.itd,               |                                +
               &s.desc_lld,           | Description.                   +
               ,                      | No options.                    +
               &w.system_grd_token,   | Put in system storage.         +
               =a(llditmsz),          | Length of items.               +
               =a(lld#lnks),          | Number of links.               +
               =a(lldlinks-lld),      | Offset of links.               +
               ,,                     | Length is in item.             +
               ,,                     | Number of link are fixed (0).  +
               ,)                     | Offset of links is fixed (0).
  l16   r0,&w.itd                     | Load r0 with token of ITD.
  st    r0,imctdlld                   | Save this in IMC.
  litda r5,r0                         | Load address of ITD.
  using itd,r5                        | Establish base for ITD.
  mvc   itdclass,=y(&im_class_linked_list_descriptor) Set class.
  sbit  itdf1dfl                      | Description in first link.
  drop  r5                            | Endif.
* *-------------------------------------------------------------------*
* * Make an item type descriptor for hash table descriptors.
* *-------------------------------------------------------------------*
  callsub create_item_type_descriptor_function,                        +
               (&w.itd,               |                                +
               &s.desc_htd,           | Description.                   +
               ,                      | No options.                    +
               &w.system_grd_token,   | Put in system storage.         +
               ,                      | Length of item in item.        +
               ,                      | Number of links in item.       +
               =a(htdlinks-htd),      | Offset of links.               +
               =a(l'htdsize),=a(htdsize-htd),   Length is in the item. +
               =a(l'htd#lnks),=a(htd#lnks-htd), Number of links in item+
               ,)                     | Offset of links is fixed.
  l16   r0,&w.itd                     | Load r0 with token of ITD.
  st    r0,imctdhtd                   | Save this in IMC.
  litda r5,r0                         | Load address of ITD.
  using itd,r5                        | Establish base for ITD.
  mvc   itdclass,=y(&im_class_hash_table_descriptor) Set class.
  sbit  itdf1dfl                      | Description in first link.
  drop  r5                            | Endif.
* *-------------------------------------------------------------------*
* * Make an item type descriptor for directory entries.
* *-------------------------------------------------------------------*
  callsub create_item_type_descriptor_function,                        +
               (&w.itd,               |                                +
               &s.desc_dir,           | Description.                   +
               ,                      | No options.                    +
               &w.system_grd_token,   | Put in system storage.         +
               =a(diritmsz),          | Length of items.               +
               =a(dir#lnks),          | Number of links.               +
               =a(dirlinks-dir),      | Offset of links.               +
               ,,                     | Length is in item.             +
               ,,                     | Number of link are fixed (0).  +
               ,)                     | Offset of links is fixed (0).
  l16   r0,&w.itd                     | Load r0 with token of ITD.
  st    r0,imctddir                   | Save this in IMC.
  litda r5,r0                         | Load address of ITD.
  using itd,r5                        | Establish base for ITD.
  sbit  itdf1dfl                      | Description in first link.
  drop  r5                            | Endif.
* *-------------------------------------------------------------------*
* * Make a hash table descriptor for directory.
* *-------------------------------------------------------------------*
  callsub create_hash_table_descriptor_function,                       +
               (&w.token,             | Token return area.             +
               &s.desc_directory,     | Description.                   +
               ,                      | No options.                    +
               101,                   | Entries in table.              +
               =a(dirtksyn_link_number), Synonym link number.          +
               =a(dirname-dir),       | Offset of key.                 +
               ,                      | Not fixed size key.            +
               =a(dirnmsz-dir))       | Offset of key size.
  mvc   imcdsdir,&w.token             | Move token to IMC.
* *-------------------------------------------------------------------*
* * Make a description for ITD ITD and place it in first link of
* * ITD.
* *-------------------------------------------------------------------*
  la    r1,&s.desc_itd                | Point to description.
  callsub make_a_dsc                  | Make a DSC.
  lr    r3,r0                         | Save token.
  l     r1,imctditd                   | Point to
  litda r5,r1                         | ITD for
  using itd,r5                        | ITD.
  st    r3,itddesc                    | Move the token to the ITD.
  drop  r5                            | Drop base for ITD.
* *-------------------------------------------------------------------*
* * Make a description for ITDX ITD and place it in first link of
* * ITD.
* *-------------------------------------------------------------------*
  la    r1,&s.desc_itdx               | Point to description.
  callsub make_a_dsc                  | Make a DSC.
  lr    r3,r0                         | Save token.
  l     r1,imctditdx                  | Point to
  litda r5,r1                         | ITD for
  using itd,r5                        | ITDX.
  st    r3,itddesc                    | Move the token to the ITD.
  drop  r5                            | Drop base for ITD.
* *-------------------------------------------------------------------*
* * Make a description for IMC ITD and place it in first link of
* * ITD.
* *-------------------------------------------------------------------*
  la    r1,&s.desc_imc                | Point to description.
  callsub make_a_dsc                  | Make a DSC.
  lr    r3,r0                         | Save token.
  l16   r1,imcitype                   | Point to
  litda r5,r1                         | ITD for
  using itd,r5                        | IMC.
  st    r3,itddesc                    | Move the token to the ITD.
  drop  r5                            | Drop base for ITD.
* *-------------------------------------------------------------------*
* * Make a description for GRD ITD and place it in first link of
* * ITD.
* *-------------------------------------------------------------------*
  la    r1,&s.desc_grd                | Point to description.
  callsub make_a_dsc                  | Make a DSC.
  lr    r3,r0                         | Save token.
  l     r1,imctdgrd                   | Point to
  litda r5,r1                         | ITD for
  using itd,r5                        | GRD.
  st    r3,itddesc                    | Move the token to the ITD.
  drop  r5                            | Drop base for ITD.
* *-------------------------------------------------------------------*
* * Make a description for GSS ITD and place it in first link of
* * ITD.
* *-------------------------------------------------------------------*
  la    r1,&s.desc_gss                | Point to description.
  callsub make_a_dsc                  | Make a DSC.
  lr    r3,r0                         | Save token.
  l     r1,imctdgss                   | Point to
  litda r5,r1                         | ITD for
  using itd,r5                        | GSS.
  st    r3,itddesc                    | Move the token to the ITD.
  drop  r5                            | Drop base for ITD.
* *-------------------------------------------------------------------*
* * Make a description for DSC ITD and place it in first link of
* * ITD.
* *-------------------------------------------------------------------*
  la    r1,&s.desc_dsc                | Point to description.
  callsub make_a_dsc                  | Make a DSC.
  lr    r3,r0                         | Save token.
  l     r1,imctddsc                   | Point to
  litda r5,r1                         | ITD for
  using itd,r5                        | DSC.
  st    r3,itddesc                    | Move the token to the ITD.
  drop  r5                            | Drop base for ITD.
* *-------------------------------------------------------------------*
* * Indicate that initialization has been done.
* *-------------------------------------------------------------------*
  sbit  imcf1int                      | Initialization has been done.
  drop  r4                            | Drop base for IMC.
* *-------------------------------------------------------------------*
 endblk block=initialize_function     |
 space 1                              |
         ssd ,                        |
&s.desc_dsc  im_text "Description"
&s.desc_grd  im_text "Group Descriptor"
&s.desc_gss  im_text "Group Storage Segment"
&s.desc_imc  im_text "Item Manager Control"
&s.desc_itd  im_text "Item Type Descriptor"
&s.desc_itdx im_text "Item Type Descriptor - Extended"
&s.desc_lld  im_text "Linked List Descriptor"
&s.desc_htd  im_text "Hash Table Descriptor"
&s.desc_dir  im_text "Directory Entry"
&s.desc_directory im_text "Directory"
         endssd ,                     |
         swa ,                        |
&w.system_grd_token             ds f  |
&w.token                        ds f  |
&w.itd                          ds h  |
         endswa ,                     |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Save_Function
*  Abstract:   This subroutine processes the save function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=save_function,                             +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * If div manager epa was supplied, issue save.  If not, it is an
* * error.
* *-------------------------------------------------------------------*
  l32   r15,pwa_dv                    | Point r15 to div manager epa.
  errexit z,code=&im_function_requires_div
  callx (r15),(pwa_dv_token,&dv_save),vl Save.
  errexit (treg,r15,nz),code=&im_dv_save_failed
* *-------------------------------------------------------------------*
 endblk block=save_function           |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Reset_Function
*  Abstract:   This subroutine processes the reset function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=reset_function,                            +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * If div manager epa was supplied, issue save.  If not, it is an
* * error.
* *-------------------------------------------------------------------*
  l32   r15,pwa_dv                    | Point r15 to div manager epa.
  errexit z,code=&im_function_requires_div
  callx (r15),(pwa_dv_token,&dv_reset),vl Reset.
  errexit (treg,r15,nz),code=&im_dv_reset_failed
* *-------------------------------------------------------------------*
 endblk block=reset_function          |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Add_To_Directory_Function
*  Abstract:   This subroutine processes the reset function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=add_to_directory_function,                 +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* *
* *-------------------------------------------------------------------*
  errexit code=&im_not_yet_supported
* *-------------------------------------------------------------------*
 endblk block=add_to_directory_function
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Find_In_Directory_Function
*  Abstract:   This subroutine processes the reset function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=find_in_directory_function,                +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* *
* *-------------------------------------------------------------------*
  errexit code=&im_not_yet_supported
* *-------------------------------------------------------------------*
 endblk block=find_in_directory_function
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Remove_From_Directory_Function
*  Abstract:   This subroutine processes the reset function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=remove_from_directory_function,            +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* *
* *-------------------------------------------------------------------*
  errexit code=&im_not_yet_supported
* *-------------------------------------------------------------------*
 endblk block=remove_from_directory_function
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Create_Item_Type_Descriptor_Function
*  Abstract:   This subroutine processes the create item type
*              descriptor function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=create_item_type_descriptor_function,      +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * Determime if long form is required because a size/offset is
* * specified.
* *-------------------------------------------------------------------*
  sbit  pwa_f_short_itd_ok            | Assume short will be ok.
  l32   r1,prm_create_itd_item_len_size Point r1 to len size.
  if z,or,(clc,0(4,r1),eq,=a(0))      | If zero:
   l32   r2,prm_create_itd_item_len_offset Point to offset.
   errexit nz,and,(clc,0(4,r2),ne,=a(0)),  Error if offset not zero.   +
               code=&im_offset_specified_when_size_was_zero
  else                                | Else if not zero:
   rbit  pwa_f_short_itd_ok           |  Indicate long form required.
  endif                               | Endif.
  l32   r1,prm_create_itd_#_links_size  Point r1 to # links size.
  if z,or,(clc,0(4,r1),eq,=a(0))      | If zero:
   l32   r2,prm_create_itd_#_links_offset  Point to offset.
   errexit nz,and,(clc,0(4,r2),ne,=a(0)),  Error if offset not zero.   +
               code=&im_offset_specified_when_size_was_zero
  else                                | Else if not zero:
   rbit  pwa_f_short_itd_ok           |  Indicate long form required.
  endif                               | Endif.
  l32   r1,prm_create_itd_offset_size | Point r1 to offset size.
  if z,or,(clc,0(4,r1),eq,=a(0))      | If zero:
   l32   r2,prm_create_itd_offset_offset   Point to offset.
   errexit nz,and,(clc,0(4,r2),ne,=a(0)),  Error if offset not zero.   +
               code=&im_offset_specified_when_size_was_zero
  else                                | Else if not zero:
   rbit  pwa_f_short_itd_ok           |  Indicate long form required.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Determime if long form is required because a value is too large.
* *-------------------------------------------------------------------*
  if (tbit,pwa_f_short_itd_ok)        | If stort still possible:
   l32   r1,prm_create_itd_item_len   |  Point r1 to item length.
   if z,or,(clc,0(4,r1),le,=a(255))   |  If not specified or <= 255:
    l32   r1,prm_create_itd_#_links   |   Point r1 to # links.
    if z,or,(clc,0(4,r1),le,=a(255))  |   If not specified of <= 255:
     l32   r1,prm_create_itd_offset   |    Point r1 to offset.
     if nz,and,(clc,0(4,r1),gt,=a(255))    If specified and > 255:
      rbit  pwa_f_short_itd_ok        |     Indicate can't be short.
     endif                            |    Endif.
    else                              |   Else:
     rbit  pwa_f_short_itd_ok         |    Indicate can't be short.
    endif                             |   Endif.
   else                               |  Else:
    rbit  pwa_f_short_itd_ok          |   Indicate can't be short.
   endif                              |  Endif.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Build the part of the ITD that is common to a non-extended and
* * extended ITD.
* *-------------------------------------------------------------------*
  fill  pwa_itd_build_area,x'00'      | Clear build area.
  la    r3,pwa_itd_build_area         | Point r2 to build area.
  using itd,r3                        | Establish base for area.
  l     r4,pwa_imc_address            | Point r4 to IMC.
  using imc,r4                        | Establish base for IMC.
  mvc   itdclass,=y(&im_class_unclassified) Set class.
  l32   r1,prm_create_itd_description | Point r1 to description.
  if nz                               | If one was passed:
   callsub make_a_dsc                 |  Make a DSC for it.
   st    r0,itddesc                   |  Store the token in the ITD.
  endif                               | Endif.
  l32   r1,prm_create_itd_grd_token   | Point r1 to grd token.
  if z,or,(clc,0(4,r1),eq,=a(0))      | If not specified:
   mvc   itdgrd,imcgrddf              |  Set GRD to default.
  else                                | Else:
   mvc   itdgrd,0(r1)                 |  Set GRD to one passed.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * If a short form is possible, make a short ITD after doing further
* * checking.
* *-------------------------------------------------------------------*
  if (tbit,pwa_f_short_itd_ok)        | If stort still possible:
   mvc   itditype,imctditd+2          |  Move ITD token to ITD.
   l32   r1,prm_create_itd_item_len   |  Point to item length.
   errexit z,code=&im_length_required |  Error if zero.
   l32   r1,0(r1)                     |  Load item length.
   errexit z,code=&im_length_required |  Error if zero.
   stc   r1,itdiln                    |  Store length in ITD.
   slr   r0,r0                        |  Clear # links holder (r0).
   l32   r1,prm_create_itd_#_links    |  Point r1 to # links.
   if nz                              |  If specified:
    l     r0,0(,r1)                   |   Load # links.
    stc   r0,itdinl                   |   Store # in ITD.
   endif                              |  Endif.
   l32   r1,prm_create_itd_offset     |  Point r1 to offset.
   if nz                              |  If specified:
    l32   r1,0(r1)                    |   Load offset.
    stc   r1,itdilo                   |   Store offset in ITD.
   endif                              |  Endif.
   errexit z,and,(treg,r0,nz),code=&im_invalid_offset
   sll   r0,2                         |  Multiply # links by 4.
   ar    r0,r1                        |  Add to offset.
   if nz                              |  If there were specified:
    l8    r1,itdiln                   |   It is an error if
    errexit  (cli,itdilo,lt,2),or,    |   offset is < 2 or             +
               (cr,r0,gt,r1),         |   links would extend past      +
               code=&im_invalid_offset    end of item.
   endif                              |  Endif.
* *-------------------------------------------------------------------*
* * If a long form is required, make a long ITD after doing further
* * checking.
* *-------------------------------------------------------------------*
  else                                | If long form required:
*  *------------------------------------------------------------------*
*  * Set the extended flag and item type.
*  *------------------------------------------------------------------*
   sbit  itdf1ext                     |  Set extended flag.
   mvc   itditype,imctditdx+2         |  Move ITD token to ITD.
*  *------------------------------------------------------------------*
*  * Process the item length parameters.
*  *------------------------------------------------------------------*
   slr   r0,r0                        |  Load
   l32   r1,prm_create_itd_item_len   |  r0
   if nz                              |  with
    l     r0,0(,r1)                   |  item length
   endif                              |  parameter.
   l32   r1,prm_create_itd_item_len_size Load
   if nz                              |  r1 with
    l     r1,0(,r1)                   |  item length size
   endif                              |  parameter.
   l32   r2,prm_create_itd_item_len_offset Load
   if nz                              |  r2 with
    l     r2,0(,r2)                   |  item length offset
   endif                              |  parameter.
   if (treg,r0,nz)                    |  If length was specified:
      errexit  (treg,r1,nz),or,       |   It is an error if            +
               (treg,r2,nz),or,       |   item length size or          +
               (ch,r0,lt,=h'2'),      |   offset is specified.         +
               code=&im_length_parm_error
    st    r0,itdxiln                  |   Store the length.
   else                               |  If length was not specified:
    errexit  (ch,r1,lt,=h'1'),or,     |   If length size is < 1        +
               (ch,r1,gt,=h'4'),or,   |   or > 4 or if the length      +
               (ch,r2,lt,=h'2'),      |   offset < 2, it is an         +
               code=&im_length_parm_error error.
    stc   r1,itdxilnsz                |   Store the length size.
    st    r2,itdxilnof                |   Store the length offset.
    sbit  itdf1lni                    |   Indicate length in item.
   endif                              |  Endif.
*  *------------------------------------------------------------------*
*  * Process the number of links parameters.
*  *------------------------------------------------------------------*
   slr   r0,r0                        |  Load
   l32   r1,prm_create_itd_#_links    |   r0
   if nz                              |  with
    l     r0,0(,r1)                   |  number links
   endif                              |  parameter.
   l32   r1,prm_create_itd_#_links_size Load
   if nz                              |  r1 with
    l     r1,0(,r1)                   |  number links size
   endif                              |  parameter.
   l32   r2,prm_create_itd_#_links_offset Load
   if nz                              |  r2 with
    l     r2,0(,r2)                   |  number links offset
   endif                              |  parameter.
   if (treg,r0,nz)                    |  If # links was specified:
    errexit    (treg,r1,nz),or,       |   It is an error if            +
               (treg,r2,nz),          |   number links size or         +
               code=&im_#_links_parm_error offset is specified.
    st    r0,itdxinl                  |   Store the # links.
   elseif (treg,r1,nz),or,(treg,r2,nz)   If # links not specified:
    errexit    (ch,r1,lt,=h'1'),or,   |   If # links size is < 1       +
               (ch,r1,gt,=h'4'),or,   |   or > 4 or if the length      +
               (ch,r2,lt,=h'2'),      |   offset < 2, it is an         +
               code=&im_#_links_parm_error error.
    stc   r1,itdxinlsz                |   Store the # links size.
    st    r2,itdxinlof                |   Store the # links offset.
    sbit  itdf1nli                    |   Indicate # links in item.
   endif                              |  Endif.
*  *------------------------------------------------------------------*
*  * Process the links offset parameters.
*  *------------------------------------------------------------------*
   slr   r0,r0                        |  Load
   l32   r1,prm_create_itd_offset     |  r0
   if nz                              |  with
    l     r0,0(,r1)                   |  links offset
   endif                              |  parameter.
   l32   r1,prm_create_itd_offset_size Load
   if nz                              |  r1 with
    l     r1,0(,r1)                   |  links offset size
   endif                              |  parameter.
   l32   r2,prm_create_itd_offset_offset Load
   if nz                              |  r2 with
    l     r2,0(,r2)                   |  links offset offset
   endif                              |  parameter.
   if (treg,r0,nz)                    |  If offset was specified:
    errexit    (treg,r1,nz),or,       |   It is an error if            +
               (treg,r2,nz),or,       |   links offset size or         +
               (ch,r0,lt,=h'2'),      |   offset is specified.         +
               code=&im_links_offset_parm_error
    st    r0,itdxilo                  |   Store the offset.
   elseif (treg,r1,nz),or,(treg,r2,nz)   If offset was not specified:
    errexit    (ch,r1,lt,=h'1'),or,   |   If offset size is < 1        +
               (ch,r1,gt,=h'4'),or,   |   or > 4 or if the length      +
               (ch,r2,lt,=h'2'),      |   offset < 2, it is an         +
               code=&im_links_offset_parm_error error.
    stc   r1,itdxilosz                |   Store the offset size.
    st    r2,itdxiloof                |   Store the offset offset.
    sbit  itdf1loi                    |   Indicate offset in item.
   endif                              |  Endif.
*  *------------------------------------------------------------------*
*  * If item has links, links offset must be specified; otherwise,
*  * links offset must not be specified.
*  *------------------------------------------------------------------*
   if (clc,itdxinl,ne,=f'0'),or,      |  If item has links:            +
               (tbit,itdf1nli)        |
    errexit (clc,itdxilo,eq,=f'0'),and,   error if links offset        +
               not,(tbit,itdf1loi),   |   was specified.               +
               code=&im_links_offset_parm_error
   else                               |  Else:
    errexit (clc,itdxilo,ne,=f'0'),or,    error if links offset        +
               (tbit,itdf1loi),       |   was specified.               +
               code=&im_links_offset_parm_error
   endif                              |  Endif.
* *-------------------------------------------------------------------*
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Store the ITD build and return its token.
* *-------------------------------------------------------------------*
  la    r1,pwa_itd_build_area         | Point r1 to build area.
  callsub store_item                  | Store the item.
  l32   r2,prm_create_itd_descriptor_token
  if nz                               | Return the token
   sth   r0,0(,r2)                    | to the caller.
  endif                               |
* *-------------------------------------------------------------------*
 endblk block=create_item_type_descriptor_function
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Create_Group_Descriptor_Function
*  Abstract:   This subroutine processes the create group
*              descriptor function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=create_group_descriptor_function,          +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * Build the GRD.
* *-------------------------------------------------------------------*
  fill  pwa_grd_build_area,x'00'      | Clear build area.
  la    r3,pwa_grd_build_area         | Point r2 to build area.
  using grd,r3                        | Establish base for area.
  l     r4,pwa_imc_address            | Point r4 to IMC.
  using imc,r4                        | Establish base for IMC.
  mvc   grditype,imctdgrd+2           | Move type to GRD.
  mvc   grdmmthd,=a(2)                | Move standard method to GRD.
  lh    r0,=y(4096)                   | Load default inc size in r0.
  l32   r1,prm_create_gd_increment_size Point r1 to increment size.
  if nz                               | If one was passed:
   l32   r0,0(r1)                     |  Load size into r0.
   if    z                            |  If zero:
    lh    r0,=y(4096)                 |   Assume default.
   else                               |  If not zero:
    ah    r0,=y(4095)                 |   Round it up to
    srl   r0,12                       |   a multiple of
    sll   r0,12                       |   4096.
   endif                              |  Endif.
  endif                               | Endif.
  st    r0,grdincsz                   | Store inc size in GRD.
  l32   r1,prm_create_gd_description  | Point r1 to description.
  if nz                               | If one was passed:
   callsub make_a_dsc                 |  Make a DSC for it.
   st    r0,grddesc                   |  Store the token in the GRD.
  endif                               | Endif.
  mvc   grdnxgrd,imcfrgrd             | GRD will be first in chain.
*                                     | After GRD is stored, its token
*                                     | will be saved in IMCFRGRD.
* *-------------------------------------------------------------------*
* * Store the GRD, return its token and put it at head of GRD chain
* * in IMC.                           |
* *-------------------------------------------------------------------*
  drop  r3                            | Drop base for GRD.
  la    r1,pwa_grd_build_area         | Point r1 to build area.
  callsub store_item                  | Store the item.
  st    r0,&w.grd_token               | Save token in work area.
  st    r0,imcfrgrd                   | Put GRD at head of chain.
  l32   r2,prm_create_gd_descriptor_token
  if nz                               | Return the token
   st    r0,0(,r2)                    | to the caller.
  endif                               |
  imlta r5,r0                         | Get address of GRD.
  errexit nz,code=&im_internal_error  | Error if invalid.
  using grd,r5                        | Establish base for GRD.
* *-------------------------------------------------------------------*
* * Make an ITD for this GRDs free space and update the GRD.
* *-------------------------------------------------------------------*
  fill  &w.fsi_token,x'00'            | Clear token.
  callsub create_item_type_descriptor_function,                        +
               (&w.fsi_token+2,       |                                +
               ,                      | No description.                +
               ,                      | No options.                    +
               &w.grd_token,          | Put in system storage.         +
               ,                      | Length of items is in item.    +
               =a(fsi#lnks),          | Number of links.               +
               =a(fsilinks-fsi),      | Offset of links.               +
               =a(l'fsisize),         | Length is                      +
               =a(fsisize-fsi),       | in item.                       +
               ,,                     | Number of link are fixed (0).  +
               ,)                     | Offset of links is fixed (0).
  l     r0,&w.fsi_token               | Load r0 with token of FSI.
  st    r0,grdtdfsi                   | Save this in GRD.
  litda r6,r0                         | Load address of ITD.
  mvc   itdclass-itd(l'itdclass,r6),=y(&im_class_freespace) Set class.
* *-------------------------------------------------------------------*
 endblk block=create_group_descriptor_function
         swa ,                        |
&w.grd_token                     ds a |
&w.fsi_token                     ds a |
         endswa ,                     |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Create_Linked_List_Descriptor_Function
*  Abstract:   This subroutine processes the create linked list
*              descriptor function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=create_linked_list_descriptor_function,    +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * Start building the LLD based on the parameters.
* *-------------------------------------------------------------------*
  fill  pwa_lld_build_area,x'00'      | Clear build area.
  la    r3,pwa_lld_build_area         | Point r2 to build area.
  using lld,r3                        | Establish base for area.
  l     r4,pwa_imc_address            | Point r4 to IMC.
  using imc,r4                        | Establish base for IMC.
  mvc   llditype,imctdlld+2           | Move type to LLD.
  l32   r1,prm_create_ld_description  | Point r1 to description.
  if nz                               | If one was passed:
   callsub make_a_dsc                 |  Make a DSC for it.
   st    r0,llddesc                   |  Store the token in the LLD.
  endif                               | Endif.
  l32   r1,prm_create_ld_options      | Point r1 to options parm.
  if nz                               | If it was specified:
   mvc   lldop,0(r1)                  |  Move option to LLD.
  endif                               | Endif.
  l32   r1,prm_create_ld_first_link_# | Point r1 to first link # parm.
  if nz                               | If it was specified:
   mvc   lldfrlk#,0(r1)               |  Store # in LLD.
  endif                               | Endif.
  l32   r1,prm_create_ld_final_link_# | Point r1 to final link # parm.
  if nz                               | If it was specified:
   mvc   lldfnlk#,0(r1)               |  Move # to LLD.
  endif                               | Endif.
  l32   r1,prm_create_ld_next_link_# Point r1 to next link # parm
  if nz                               | If it was specified:
   mvc   lldnxlk#,0(r1)               |  Move # to LLD.
  endif                               | Endif.
  l32   r1,prm_create_ld_prior_link_# | Point r1 to prior link #
  if nz                               | If it was specified:
   mvc   lldprlk#,0(r1)               |  Move # to LLD.
  endif                               | Endif.
  l32   r1,prm_create_ld_owner_link_# | Point r1 to owner link # parm.
  if nz                               | If it was specified:
   mvc   lldowlk#,0(r1)               |  Move # to LLD.
  endif                               | Endif.
  l32   r1,prm_create_ld_itemtype     | Point r1 to item type.
  if nz                               | If it was specified:
   mvc   lldmtitd(2),2(r1)            |  Move it to LLD.
  endif                               | Endif.
* *------------------------------------------------------------------*
* * Process heads ITD token.
* *------------------------------------------------------------------*
  l32   r1,prm_create_ld_heads_item_type Point r1 to heads ITD token.
  if nz                               | If it was specified:
   fill  lldhditd,x'00'               |  Move heads ITD token
   mvc   lldhditd+2(2),0(r1)          |  to LLD.
  endif                               | Endif.
* *------------------------------------------------------------------*
* * Process the key offset parameter.
* *------------------------------------------------------------------*
  slr   r0,r0                         | Load
  l32   r1,prm_create_ld_key_offset   | r0
  if nz                               | with
   l     r0,0(,r1)                    | key
   sbit  lldf1ked                     | offset
  endif                               | parameter.
  st    r0,lldkof                     | Store the offset.
* *------------------------------------------------------------------*
* * Process the key length parameters.
* *------------------------------------------------------------------*
  slr   r0,r0                         | Load
  l32   r1,prm_create_ld_key_len      | r0
  if nz                               | with
   l     r0,0(,r1)                    | key length parameter.
   errexit code=&im_key_length_parm_error,                             +
               (ch,r0,gt,=h'255')     |  Restrict length to 255.
  endif                               |
  l32   r2,prm_create_ld_key_len_offset Load
  if nz                               | r2 with
   l     r2,0(,r2)                    | key length offset
  endif                               | parameter.
  if (treg,r0,nz)                     | If length was specified:
   errexit     (treg,r2,nz),          |  Error if both are specified.  +
               code=&im_key_length_parm_error
   st    r0,lldksz                    |  Store the offset.
  elseif (treg,r1,nz),or,(treg,r2,nz) | If length was not specified:
   errexit     (ch,r2,lt,=h'2'),      |  Error if offset < 2.          +
               code=&im_key_length_parm_error error.
   st    r2,lldkszof                  |  Store the key offset.
   sbit  lldf1ksi                     |  Indicate offset in item.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Check for errors.
* *-------------------------------------------------------------------*
*>errexit
* *-------------------------------------------------------------------*
* * Store the lld, return its token.
* *-------------------------------------------------------------------*
  drop  r3                            | Drop base for lld.
  la    r1,pwa_lld_build_area         | Point r1 to build area.
  callsub store_item                  | Store the item.
  st    r0,&w.lld_token               | Save token in work area.
  l32   r2,prm_create_ld_descriptor_token
  if nz                               | Return the token
   st    r0,0(,r2)                    | to the caller.
  endif                               |
* *-------------------------------------------------------------------*
 endblk block=create_linked_list_descriptor_function
         swa ,                        |
&w.lld_token                     ds a |
         endswa ,                     |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Create_Hash_Table_Descriptor_Function
*  Abstract:   This subroutine processes the create hash table
*              descriptor function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=create_hash_table_descriptor_function,     +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * Start building the HTD based on the parameters.
* *-------------------------------------------------------------------*
  fill  pwa_htd_build_area,x'00'      | Clear build area.
  la    r3,pwa_htd_build_area         | Point r2 to build area.
  using htd,r3                        | Establish base for area.
  l     r4,pwa_imc_address            | Point r4 to IMC.
  using imc,r4                        | Establish base for IMC.
  mvc   htditype,imctdhtd+2           | Move type to HTD.
  l32   r1,prm_create_ht_description  | Point r1 to description.
  if nz                               | If one was passed:
   callsub make_a_dsc                 |  Make a DSC for it.
   st    r0,htddesc                   |  Store the token in the HTD.
  endif                               | Endif.
  l32   r1,prm_create_ht_options      | Point r1 to options parm.
  if nz                               | If it was specified:
   mvc   htdop,0(r1)                  |  Move option to HTD.
  endif                               | Endif.
  l32   r1,prm_create_ht_entries_in_table Point r1 to # entries parm.
  if nz                               | If it was specified:
   l     r1,0(,r1)                    |  Load r1 with number.
  endif                               | Endif.
  if (treg,r1,z)                      | If not supplied:
   la    r1,101                       |  Assume 101.
  endif                               | Endif.
  ah    r1,=h'1'                      | Add 1 for descriptor link.
  st    r1,htd#lnks                   | Save in HTD.
  l32   r1,prm_create_ht_synonym_link_# Point r1 to synonym link # prm.
  if nz                               | If it was specified:
   mvc   htdsylk#,0(r1)               |  Move # to HTD.
  endif                               | Endif.
  l32   r1,prm_create_ht_itemtype     | Point r1 to item type.
  if nz                               | If it was specified:
   mvc   htdmtitd(2),2(r1)            |  Move it to LLD.
  endif                               | Endif.
* *------------------------------------------------------------------*
* * Process the key offset parameters.
* *------------------------------------------------------------------*
  slr   r0,r0                         | Load
  l32   r1,prm_create_ht_key_offset   | r0
  if nz                               | with
   l     r0,0(,r1)                    | key offset
  endif                               | parameter.
  st    r0,htdkof                     | Store the offset.
* *------------------------------------------------------------------*
* * Process the key length parameters.
* *------------------------------------------------------------------*
  slr   r0,r0                         | Load
  l32   r1,prm_create_ht_key_len      | r0
  if nz                               | with
   l     r0,0(,r1)                    | key length
   errexit code=&im_key_length_parm_error,                             +
               (ch,r0,gt,=h'255')     |  Restrict length to 255.
  endif                               | parameter.
  l32   r2,prm_create_ht_key_len_offset Load
  if nz                               | r2 with
   l     r2,0(,r2)                    | key length offset
  endif                               | parameter.
  if (treg,r0,nz)                     | If length was specified:
   errexit     (treg,r2,nz),          |  It is an error if key offset  +
               code=&im_key_length_parm_error is specified.
   st    r0,htdksz                    |  Store the offset.
  elseif (treg,r1,nz),or,(treg,r2,nz) | If length was not specified:
   errexit     (ch,r2,lt,=h'2'),      |  Error if offset < 2.          +
               code=&im_key_length_parm_error error.
   st    r2,htdkszof                  |  Store the key offset.
   sbit  htdf1ksi                     |  Indicate size in item.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Check for errors.
* *-------------------------------------------------------------------*
*>errexit
* *-------------------------------------------------------------------*
* * Calculate size of HTD and obtain IMMS.
* *-------------------------------------------------------------------*
  l     r1,htd#lnks                   | Calculate size
  sla   r1,2                          | of link area.
  errexit o,code=&im_internal_error   | Error if overflow.
  ah    r1,=y(htditmsz-4)             | Add size of rest of item.
  errexit o,code=&im_internal_error   | Error if overflow.
  st    r1,htdsize                    | Save result in item.
  mvc   &w.grd_token,imcgrdsy         | System storage GRD.
  callsub obtain_item_storage,        | Get IMMS for HTD.              +
               (&w.grd_token,         |                                +
               htdsize,               |                                +
               &w.htd_token,          |                                +
               &w.htd_address)        |
* *-------------------------------------------------------------------*
* * Increment number of HTDs and move HTD to item managed storage.
* *-------------------------------------------------------------------*
  litda r5,imctdhtd                   | Increment
  using itd,r5                        | number
  l     r1,itdnumit                   | of
  ah    r1,=h'1'                      | HTDs
  st    r1,itdnumit                   | in its
  drop  r5                            | ITD.
  l     r5,&w.htd_address             | Move ITD to IMMS.
  mvc   0(l'pwa_htd_build_area,r5),pwa_htd_build_area
* *-------------------------------------------------------------------*
* * Store HTD token and return.
* *-------------------------------------------------------------------*
  l32   r2,prm_create_ht_descriptor_token
  if nz                               | Return the token
   mvc   0(4,r2),&w.htd_token         | to the caller.
  endif                               |
* *-------------------------------------------------------------------*
 endblk block=create_hash_table_descriptor_function
         swa ,                        |
&w.grd_token                     ds f | System storage.
&w.htd_token                     ds f | HTD token.
&w.htd_address                   ds a | HTD address.
         endswa ,                     |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Connect_Function
*  Abstract:   This subroutine processes the connect function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=connect_function,                          +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * Get address of item, descriptor and descriptor's ITD.
* *-------------------------------------------------------------------*
  l32   r1,prm_connect_item_token     | Point to item token parm.
  if nz                               | If it was specified:
   l32   r1,0(r1)                     |  Put it in r1.
  endif                               | Endif.
  if z                                | If not specified:
   l32   r1,pwa_current_of_item_manager  Point r1 to current item tkn.
   errexit z,code=&im_currency_error  |  Error if nothing current.
  endif                               | Endif.
  st    r1,&w.item_token              | Save token of item to connect.
  l32   r1,prm_connect_descriptor_token Point r1 to descriptor token.
  errexit z,code=&im_invalid_descriptor_token It is also required.
  imlta r4,*r1                        | Get address of descriptor.
  errexit nz,or,(treg,r4,z),          | Error if invalid or null.      +
               code=&im_invalid_descriptor_token
  l16   r1,0(r4)                      | Get address of
  litda r5,r1                         | ITD for descriptor.
  using itd,r5                        | Establish base for ITD.
* *-------------------------------------------------------------------*
* * Process based on descriptor class.
* *-------------------------------------------------------------------*
  lh    r1,itdclass                   | Load class into r1.
  caseblk reg=r1                      | Process based on class.
  case &im_class_linked_list_descriptor For linked list:
   using lld,r4                       |  Establish base for LLD.
   if (%l32,r1,lldmtitd,nz)           |  If member type was specified:
    imlta r6,&w.item_token            |   Get address of item.
    errexit nz,or,(treg,r6,z),        |   Error if invalid or null.    +
               code=&im_invalid_item_token
    errexit (clc,0(2,r6),ne,lldmtitd),    Error if itemtype mismatch.  +
               code=&im_itemtype_mismatch
   endif                              |  Endif.
   drop   r4                          |  Drop base for LLD.
   callsub connect_to_list,           |  Connect item to list.         +
               (&w.item_token,        |                                +
               *prm_connect_descriptor_token,                          +
               *prm_connect_head_token)
  case &im_class_hash_table_descriptor  For hash table:
   l32   r1,prm_connect_head_token
   errexit nz,and,(clc,0(4,r1),ne,=f'0'),                              +
               code=&im_head_not_valid_for_this_descriptor
   using htd,r4                       |  Establish base for htd.
   if (%l32,r1,htdmtitd,nz)           |  If member type was specified:
    imlta r6,&w.item_token            |   Get address of item.
    errexit nz,or,(treg,r6,z),        |   Error if invalid or null.    +
               code=&im_invalid_item_token
    errexit (clc,0(2,r6),ne,htdmtitd),    Error if itemtype mismatch.  +
               code=&im_itemtype_mismatch
   endif                              |  Endif.
   drop   r4                          |  Drop base for htd.
   callsub connect_to_hash_table,     |  Connect item to table.        +
               (&w.item_token,                                         +
               *prm_connect_descriptor_token)
  case &im_class_binary_tree_descriptor For binary tree:
   errexit code=&im_not_yet_supported |
  case other                          | If other class of item:
   errexit code=&im_invalid_descriptor_token  It is an error.
  endcase                             | Endif.
* *-------------------------------------------------------------------*
 endblk block=connect_function        |
         swa                          |
&w.item_token                    ds f |
         endswa                       |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Disconnect_Function
*  Abstract:   This subroutine processes the disconnect function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=disconnect_function,                       +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * Get address of item, descriptor and descriptor's ITD.
* *-------------------------------------------------------------------*
  l32   r1,prm_disconnect_item_token  | Point to item token parm.
  if nz                               | If it was specified:
   l32   r1,0(r1)                     |  Put it in r1.
  endif                               | Endif.
  if z                                | If not specified:
   l32   r1,pwa_current_of_item_manager  Point r1 to current item tkn.
   errexit z,code=&im_currency_error  |  Error if nothing current.
  endif                               | Endif.
  st    r1,&w.item_token              | Save token of item to discon.
  l32   r1,prm_disconnect_descriptor_token Point r1 to descriptor token
  errexit z,code=&im_invalid_descriptor_token It is also required.
  imlta r4,*r1                        | Get address of descriptor.
  errexit nz,or,(treg,r4,z),          | Error if invalid or null.      +
               code=&im_invalid_descriptor_token
  l16   r1,0(r4)                      | Get address of
  litda r5,r1                         | ITD for descriptor.
  using itd,r5                        | Establish base for ITD.
* *-------------------------------------------------------------------*
* * Process based on descriptor class.
* *-------------------------------------------------------------------*
  lh    r1,itdclass                   | Load class into r1.
  caseblk reg=r1                      | Process based on class.
  case &im_class_linked_list_descriptor For linked list:
   using lld,r4                       |  Establish base for LLD.
   if (%l32,r1,lldmtitd,nz)           |  If member type was specified:
    imlta r6,&w.item_token            |   Get address of item.
    errexit nz,or,(treg,r6,z),        |   Error if invalid or null.    +
               code=&im_invalid_item_token
    errexit (clc,0(2,r6),ne,lldmtitd),    Error if itemtype mismatch.  +
               code=&im_itemtype_mismatch
   endif                              |  Endif.
   drop   r4                          |  Drop base for LLD.
   callsub disconnect_from_list,      |                                +
               (&w.item_token,        |                                +
               *prm_disconnect_descriptor_token,                       +
               *prm_disconnect_head_token,                             +
               *prm_disconnect_prior_token)
  case &im_class_hash_table_descriptor  For hash table:
   errexit code=&im_not_yet_supported |
  case &im_class_binary_tree_descriptor For binary tree:
   errexit code=&im_not_yet_supported |
  case other                          | If other class of item:
   errexit code=&im_invalid_descriptor_token  It is an error.
  endcase                             | Endif.
* *-------------------------------------------------------------------*
 endblk block=disconnect_function     |
         swa                          |
&w.item_token                    ds f |
         endswa                       |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Get_Function
*  Abstract:   This subroutine processes the get function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=get_function,                              +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * Get token for item and get its characteristics.
* *-------------------------------------------------------------------*
  l32    r3,pwa_current_of_item_manager Get current of item manager.
  errexit z,code=&im_currency_error   | Error if nothing current.
  st    r3,&w.itc_token               | Store token in ITC.
  la    r1,&w.itc_                    | Get the item's
  callsub get_itc                     | characteristics.
  l32   r1,prm_get_item_token         | Point r2 to token return area.
  if nz                               | If specified:
   st    r3,0(,r1)                    |  Return item token.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Copy item to caller provided return area.
* *-------------------------------------------------------------------*
  callsub copy_item,(&w.itc_,         | Copy item.                     +
               *prm_get_return_area_size,                              +
               *prm_get_return_area,  |                                +
               *prm_get_actual_item_size)
* *-------------------------------------------------------------------*
 endblk block=get_function            |
         swa ,                        |
         itc   id=&w.itc_             |
         endswa ,                     |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Get_dangerous_addresses_function
*  Abstract:   This subroutine processes the get dangerous addresses
*              function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=get_dangerous_addresses_function,          +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * Return address of token conversion routine.
* *-------------------------------------------------------------------*
  l32   r3,prm_gda_token_convert_routine
  if nz                               | If not zero:
   l     r1,pwa_im_quick_get_address  |  Return conversion routine
   st    r1,0(,r3)                    |  address to caller.
  endif                               | Endif.
* *-------------------------------------------------------------------*
 endblk block=get_dangerous_addresses_function
         swa ,                        |
         itc   id=&w.itc_             |
         endswa ,                     |
         eject
*---------------------------------------------------------------------*
*
*  Macro:      Return_results
*  Abstract:   This macro is used by other macros of return the
*              results of finds or obtains.
*
*---------------------------------------------------------------------*
         macro
         return_results &i=,&type=,&itemtkn=yes
         gblc  &w
         aif ('&type' eq 'find').find
         aif ('&type' eq 'obtain').obtain
         mnote 8,'TYPE=&TYPE is invalid.'
         mexit
.find    anop
* *-------------------------------------------------------------------*
* * Return size and token if requested.
* *-------------------------------------------------------------------*
  l32   r1,prm_fd&i._actual_item_size   Return item
  if nz                                 size if
   mvc   0(4,r1),&w.itc_size            requested.
  endif
  aif   ('&itemtkn' ne 'yes').no_find_itemtkn
  l32   r1,prm_fd&i._item_token         Return item
  if nz                                 size if
   mvc   0(4,r1),&w.itc_token           requested.
  endif
.no_find_itemtkn anop
         mexit
.obtain  anop
* *-------------------------------------------------------------------*
* * Copy item to caller provided return area if this is an obtain
* * function.  If find function, just return size if requested.
* *-------------------------------------------------------------------*
   callsub copy_item,(&w.itc_,        |  Copy item.                    +
               *prm_ob&i._return_area_size,                            +
               *prm_ob&i._return_area, |                               +
               *prm_ob&i._actual_item_size)
   aif   ('&itemtkn' ne 'yes').no_obtain_itemtkn
   l32   r1,prm_ob&i._item_token      |  Return item
   if nz                              |  size if
    mvc   0(4,r1),&w.itc_token        |  requested.
   endif                              |
.no_obtain_itemtkn anop
          mend
   eject                              |
*---------------------------------------------------------------------*
*
*  Macro:      specific_item
*  Abstract:   This macro generates common code used by
*              obtain/find subroutines.
*  Parameter:  TYPE=OBTAIN/FIND
*
*---------------------------------------------------------------------*
         macro
         specific_item &type=
         gblc  &w
         gbla  &im_class_unclassified
         gbla  &im_invalid_item
  aif ('&type' eq 'obtain').obtain
  aif ('&type' eq 'find').find
  mnote 8,'TYPE=&TYPE is invalid.'
  mexit
.obtain anop
&j       setc 'ob'
  ago  .process2
.find   anop
&j       setc 'fd'
.process2 anop
* *-------------------------------------------------------------------*
* * Get token for item and get its characteristics.
* *-------------------------------------------------------------------*
  l     r1,prm_&j._item_token         | Load address of token.
  mvc   &w.itc_token,0(r1)            | Move token to ITC.
  la    r1,&w.itc_                    | Get the item's
  callsub get_itc                     | characteristics.
* *-------------------------------------------------------------------*
* * Make sure that item is unclassified.
* *-------------------------------------------------------------------*
  l     r5,&w.itc_itd_address         | Get address of ITD.
  using itd,r5                        | Establish base for ITD.
  errexit      (clc,=y(&im_class_unclassified),ne,itdclass),           +
               code=&im_invalid_item  |
* *-------------------------------------------------------------------*
* * Copy item to caller provided return area if this is an obtain
* * function.  If find function, just return size if requested.
* *-------------------------------------------------------------------*
  return_results i=,type=&type,itemtkn=NO
* *-------------------------------------------------------------------*
* * Make the item current-of-item-manager and current-of-item-type.
* *-------------------------------------------------------------------*
  callsub make_current,(&w.itc_token,)  Make item current.
* *-------------------------------------------------------------------*
         swa  type=partial            |
         itc id=&w.itc_               |
         endswa ,                     |
         mend
         eject
*---------------------------------------------------------------------*
*
*  Subroutine: Obtain_Function
*  Abstract:   This subroutine processes the obtain function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=obtain_function,                           +
               parmmap=prm_function_dependent
  specific_item type=obtain
 endblk block=obtain_function         |
 space 1
*---------------------------------------------------------------------*
*
*  Subroutine: Find_Function
*  Abstract:   This subroutine processes the find function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=find_function,                             +
               parmmap=prm_function_dependent
  specific_item type=find
 endblk block=find_function           |
         eject
*---------------------------------------------------------------------*
*
*  Macro:      by_key
*  Abstract:   This macro generates common code used by
*              obtain/find by_key subroutines.
*  Parameter:  TYPE=OBTAIN/FIND
*
*---------------------------------------------------------------------*
         macro
         by_key &type=
         gblc  &w
         gbla  &im_invalid_descriptor_token
         gbla  &im_not_yet_supported
         gbla  &im_itemtype_mismatch
         gbla  &im_class_linked_list_descriptor
         gbla  &im_class_hash_table_descriptor
         gbla  &im_class_binary_tree_descriptor
  aif ('&type' eq 'obtain').obtain
  aif ('&type' eq 'find').find
  mnote 8,'TYPE=&TYPE is invalid.'
  mexit
.obtain anop
&j       setc 'ob'
  ago  .process2
.find   anop
&j       setc 'fd'
.process2 anop
* *-------------------------------------------------------------------*
* * Get the descriptor token and its base.
* *-------------------------------------------------------------------*
  l     r1,prm_&j.ky_descriptor_token | Load r1 with
  l     r0,0(,r1)                     | token of descriptor.
  st    r0,&w.descriptor_token        | Move token to work area.
  imlta r4,r0                         |
  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token
* *-------------------------------------------------------------------*
* * Establish base for ITD of descriptor.
* *-------------------------------------------------------------------*
  l16   r1,0(r4)                      |
  litda r5,r1                         |
  using itd,r5                        |
* *-------------------------------------------------------------------*
* * Find token of item based on descriptor class.
* *-------------------------------------------------------------------*
  lh    r1,itdclass                   | Load class into r1.
  caseblk reg=r1                      | Process based on class.
  case &im_class_linked_list_descriptor For linked list:
   errexit code=&im_not_yet_supported |
  case &im_class_hash_table_descriptor  For hash table:
   using htd,r4                       | Establish base for HTD.
   callsub find_in_hash_table,        |                                +
               (*prm_obky_key_length, |                                +
               *prm_obky_key,         |                                +
               *prm_obky_descriptor_token,                             +
               &w.itc_)               |
   if (%l32,r1,htdmtitd,nz)           |  If member type was specified:
    l    r6,&w.itc_address            |
    errexit (clc,0(2,r6),ne,htdmtitd),    Error if itemtype mismatch.  +
               code=&im_itemtype_mismatch
   endif                              |  Endif.
   drop  r4                           |  Drop base for HTD.
  case &im_class_binary_tree_descriptor For binary tree:
   errexit code=&im_not_yet_supported |
  case other                          | If other class of item:
   errexit code=&im_invalid_descriptor_token  It is an error.
  endcase                             | Endif.
* *-------------------------------------------------------------------*
* * Copy item to caller provided return area if this is an obtain
* * function.  If find function, just return size if requested.
* *-------------------------------------------------------------------*
  return_results i=ky,type=&type      | Return results.
* *-------------------------------------------------------------------*
* * Make the item current-of-item-manager and current-of-item-type.
* *-------------------------------------------------------------------*
  callsub make_current,(&w.itc_token,)  Make item current.
* *-------------------------------------------------------------------*
         swa type=partial             |
&w.descriptor_token            ds f
         itc id=&w.itc_               |
         endswa ,                     |
         mend
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Obtain_By_Key_Function
*  Abstract:   This subroutine processes the obtain_by_key function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=obtain_by_key_function,                    +
               parmmap=prm_function_dependent
  by_key type=obtain
 endblk block=obtain_by_key_function  |
 space 1
*---------------------------------------------------------------------*
*
*  Subroutine: Find_By_Key_Function
*  Abstract:   This subroutine processes the find_by_key function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=find_by_key_function,                      +
               parmmap=prm_function_dependent
  by_key type=find
 endblk block=find_by_key_function    |
   eject                              |
*---------------------------------------------------------------------*
*
*  Macro:      current_of_item_type
*  Abstract:   This macro generates common code used by
*              obtain/find current_of_item_type subroutines.
*  Parameter:  TYPE=OBTAIN/FIND
*
*---------------------------------------------------------------------*
         macro
         current_of_item_type &type=
         gblc  &w
         gbla  &im_currency_error
         gbla  &im_class_unclassified
         gbla  &im_invalid_item
  aif ('&type' eq 'obtain').obtain
  aif ('&type' eq 'find').find
  mnote 8,'TYPE=&TYPE is invalid.'
  mexit
.obtain anop
&j       setc 'ob'
  ago  .process2
.find   anop
&j       setc 'fd'
.process2 anop
* *-------------------------------------------------------------------*
* * Find the item that is current_of_item_type and get its ITC.
* *-------------------------------------------------------------------*
  l     r2,prm_&j.3_item_type         | Load pointer to item type.
  l16   r0,0(r2)                      | Move item type
  st    r0,&w.item_type               | to fullword work area.
  callsub find_current,               | Find current for type.         +
               (&w.item_type,&w.itc_token)
  errexit (treg,r15,nz),code=&im_currency_error
  la    r1,&w.itc_                    | Get the item's
  callsub get_itc                     | characteristics.
* *-------------------------------------------------------------------*
* * Make sure that item is unclassified.
* *-------------------------------------------------------------------*
  l     r5,&w.itc_itd_address         | Get address of ITD.
  using itd,r5                        | Establish base for ITD.
  errexit      (clc,=y(&im_class_unclassified),ne,itdclass),           +
               code=&im_invalid_item  |
  return_results i=3,type=&type       | Return results.
* *-------------------------------------------------------------------*
* * Make the item current-of-item-manager.
* *-------------------------------------------------------------------*
  mvc  pwa_current_of_item_manager,&w.itc_token  Make item current.
* *-------------------------------------------------------------------*
         swa type=partial             |
&w.item_type ds a                     |
         itc id=&w.itc_               |
         endswa ,                     |
         mend
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Obtain_current_of_item_type_function
*  Abstract:   This subroutine processes the
*              obtain/find_current_of_item_type functions.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=obtain_current_of_item_type_function,      +
               parmmap=prm_function_dependent
  current_of_item_type type=obtain
 endblk block=obtain_current_of_item_type_function
 space 1
*---------------------------------------------------------------------*
*
*  Subroutine: Find_current_of_item_type_function
*  Abstract:   This subroutine processes the
*              find/find_current_of_item_type functions.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=find_current_of_item_type_function,        +
               parmmap=prm_function_dependent
  current_of_item_type type=find
 endblk block=find_current_of_item_type_function
   eject                              |
*---------------------------------------------------------------------*
*
*  Macro:      current_of_descriptor
*  Abstract:   This macro generates common code used by
*              obtain/find current_of_descriptor subroutines.
*  Parameter:  TYPE=OBTAIN/FIND
*
*---------------------------------------------------------------------*
         macro
         current_of_descriptor &type=
         gblc  &w
         gbla  &im_currency_error
* *-------------------------------------------------------------------*
* * Find the item that is current_of_descriptor and get its ITC.
* *-------------------------------------------------------------------*
  aif ('&type' eq 'obtain').obtain
  aif ('&type' eq 'find').find
  mnote 8,'TYPE=&TYPE is invalid.'
  mexit
.obtain anop
&j       setc 'ob'
  ago  .process2
.find   anop
&j       setc 'fd'
.process2 anop
* *-------------------------------------------------------------------*
* * Find the item that is current_of_descriptor and get its ITC.
* *-------------------------------------------------------------------*
  l     r2,prm_&j.2_descriptor_token  | Point r1 to descriptor token.
  callsub find_current,               | Find current for descriptor.   +
               ((r2),&w.itc_token)    |
  errexit (treg,r15,nz),code=&im_currency_error
  la    r1,&w.itc_                    | Get the item's
  callsub get_itc                     | characteristics.
* *-------------------------------------------------------------------*
* * Copy item to caller provided return area if this is an obtain
* * function.  If find function, just return size if requested.
* *-------------------------------------------------------------------*
  return_results i=2,type=&type       | Return results.
* *-------------------------------------------------------------------*
* * Make the item current-of-item-manager and current-of-item-type.
* *-------------------------------------------------------------------*
  callsub make_current,(&w.itc_token,)  Make item current.
* *-------------------------------------------------------------------*
         swa type=partial             |
         itc id=&w.itc_               |
         endswa ,                     |
         mend
         eject
*---------------------------------------------------------------------*
*
*  Subroutine: Obtain_current_of_descriptor_function
*  Abstract:   This subroutine processes the
*              obtain_current_of_item_type function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=obtain_current_of_descriptor_function,     +
               parmmap=prm_function_dependent
  current_of_descriptor type=obtain
 endblk block=obtain_current_of_descriptor_function
 space 1
*---------------------------------------------------------------------*
*
*  Subroutine: Find_current_of_descriptor_function
*  Abstract:   This subroutine processes the
*              find_current_of_item_type function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=find_current_of_descriptor_function,       +
               parmmap=prm_function_dependent
  current_of_descriptor type=find
 endblk block=find_current_of_descriptor_function
   eject                              |
*---------------------------------------------------------------------*
*
*  Macro:      Owner
*  Abstract:   This macro generates common code used by
*              obtain/find owner subroutines.
*  Parameter:  TYPE=OBTAIN/FIND
*
*---------------------------------------------------------------------*
         macro
         owner &type=
         gblc  &w
         gbla  &im_invalid_descriptor_token
         gbla  &im_class_linked_list_descriptor
         gbla  &im_requires_owner_link
         gbla  &im_internal_error
         gbla  &im_not_found
         gbla  &im_itemtype_mismatch
* *-------------------------------------------------------------------*
* * Get the descriptor token and its base.
* *-------------------------------------------------------------------*
  aif ('&type' eq 'obtain').obtain
  aif ('&type' eq 'find').find
  mnote 8,'TYPE=&TYPE is invalid.'
  mexit
.obtain anop
&j       setc 'ob'
  ago  .process2
.find   anop
&j       setc 'fd'
.process2 anop
  l     r1,prm_&j.2_descriptor_token     Load r1 with
  l     r1,0(,r1)                        descriptor token
  st    r1,&w.descriptor_token           and store in work area.
  imlta r4,r1                            Establish base
  using lld,r4                           for LLD.
  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token
* *-------------------------------------------------------------------*
* * Establish base for ITD of descriptor.
* *-------------------------------------------------------------------*
  l16   r1,0(r4)
  litda r5,r1
  using itd,r5
  errexit (clc,itdclass,ne,=y(&im_class_linked_list_descriptor)),      +
               code=&im_invalid_descriptor_token
* *-------------------------------------------------------------------*
* * Find item token for find/obtain_owner.
* *-------------------------------------------------------------------*
  if (%l32,r1,prm_&j.2c_current_token,nz)
   mvc    &w.itc_token,0(r1)          | Use current token if supplied
  else                                | otherwise use current of item
   mvc    &w.itc_token,pwa_current_of_item_manager       manager.
  endif                               |
  la    r1,&w.itc_                    | Get ITC
  callsub get_itc                     | for item.
  imlla r6,lldowlk#,&w.itc_           | Point to the "owner" link.
  errexit (treg,r6,z),code=&im_requires_owner_link
  l32   r0,0(r6)                      | If link is null, then
  errexit z,code=&im_not_found        | there is on owner.
  st    r0,&w.itc_token               | Save token of owner item.
  drop  r5                            |
* *-------------------------------------------------------------------*
* * Get item's characteristics and make sure it is valid item type.
* *-------------------------------------------------------------------*
  la    r1,&w.itc_                    | Get the item's
  callsub get_itc                     | characteristics.
  if (%l32,r1,lldmtitd,nz)            | If member type was specified:
   l    r6,&w.itc_address             |
   errexit (clc,0(2,r6),ne,lldmtitd),    Error if itemtype mismatch.   +
               code=&im_itemtype_mismatch
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Copy item to caller provided return area if this is an obtain
* * function.  If find function, just return size if requested.
* *-------------------------------------------------------------------*
  return_results i=2,type=&type       | Return results.
* *-------------------------------------------------------------------*
* * Make the item current-of-item-manager and current-of-item-type.
* *-------------------------------------------------------------------*
  callsub make_current,(&w.itc_token,)
* *-------------------------------------------------------------------*
         swa   type=partial           |
&w.descriptor_token ds f              |
&w.function         ds f              |
         itc id=&w.itc_               |
         itc id=&w.itc_heads_         |
         endswa ,                     |
         mend
         eject                        |
*---------------------------------------------------------------------*
*
*  Subroutine: Obtain_owner_function
*  Abstract:   This subroutine processes the obtain owner function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=obtain_owner_function,                     +
               parmmap=prm_function_dependent
  owner type=obtain                   |
 endblk block=obtain_owner_function   |
 space 1                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Find_owner_function
*  Abstract:   This subroutine processes the find owner function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=find_owner_function,                       +
               parmmap=prm_function_dependent
  owner type=find                     |
 endblk block=find_owner_function     |
         eject                        |
*---------------------------------------------------------------------*
*
*  Macro:      First_final
*  Abstract:   This macro generates common code used by
*              obtain/find first and obtain/find final subroutines.
*  Parameter:  TYPE=OBTAIN/FIND,WHICH=FIRST/FINAL
*
*---------------------------------------------------------------------*
         macro                        |
         first_final &type=,&which=   |
         gblc  &w
         gbla  &im_invalid_descriptor_token
         gbla  &im_headtkn_invalid
         gbla  &im_class_linked_list_descriptor
         gbla  &im_currency_error
         gbla  &im_internal_error
         gbla  &im_at_end
         gbla  &im_itemtype_mismatch
         aif ('&which' eq 'first').first
         aif ('&which' eq 'final').final
         mnote 8,'which=&WHICH is invalid.'
         mexit                        |
.first   anop                         |
&i       setc 'fr'                    |
         ago  .process                |
.final   anop                         |
&i       setc 'fn'                    |
.process anop                         |
* *-------------------------------------------------------------------*
* * Move descriptor and optional head token to work area.
* *-------------------------------------------------------------------*
  aif ('&type' eq 'obtain').obtain    |
  aif ('&type' eq 'find').find        |
  mnote 8,'TYPE=&TYPE is invalid.'    |
  mexit                               |
.obtain anop                          |
&j       setc 'ob'                    |
  ago  .process2                      |
.find   anop                          |
&j       setc 'fd'                    |
.process2 anop                        |
  l     r1,prm_&j.2_descriptor_token  | Move descriptor
  l     r1,0(,r1)                     | token passed to
  st    r1,&w.descriptor_token        | work area.
* *-------------------------------------------------------------------*
* * Establish base for LLD and ITD of LLD.
* *-------------------------------------------------------------------*
  imlta r4,&w.descriptor_token        | Load address of LLD
  using lld,r4                        | and establish base.
  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token
  l16   r1,0(r4)                      | Load address of
  litda r5,r1                         | LLDs ITD and
  using itd,r5                        | establish base.
  errexit (clc,itdclass,ne,=y(&im_class_linked_list_descriptor)),      +
               code=&im_invalid_descriptor_token
* *-------------------------------------------------------------------*
* * Find the first/final item.
* *-------------------------------------------------------------------*
  l     r1,prm_&j.2a_head_token       | Move
  if (tbit,lldophid)                  | If heads in descriptor:
   errexit (treg,r1,nz),code=&im_headtkn_invalid  NO HEADTKN!
   la    r6,lld&i.lst                 |  Use first/final pointer
  else                                | Else:
   if (treg,r1,nz)                    |  If HEADTKN specified:
    l     r1,0(,r1)                   |   Use head token
    st    r1,&w.itc_heads_token       |   supplied.
    la    r1,&w.itc_heads_            |   Get ITC
    callsub get_itc                   |   for item.
    l     r6,&w.itc_heads_address     |   EIF: ITD not right for LLD.
    errexit (clc,0(2,r6),ne,lldhditd+2),code=&im_headtkn_invalid
    imlla r6,lld&i.lk#,&w.itc_heads_  |   Calcuate address of link.
    errexit (treg,r6,z),code=&im_headtkn_invalid
   else                               |  Else:
    callsub find_current,(lldhditd,&w.itc_heads_token) Find item
    errexit (treg,r15,nz),code=&im_currency_error      that has heads.
    la    r1,&w.itc_heads_            |   Get ITC
    callsub get_itc                   |   for item.
    imlla r6,lld&i.lk#,&w.itc_heads_  |   Calcuate address of link.
    errexit (treg,r6,z),code=&im_internal_error
   endif                              |  Endif.
  endif                               | Endif.
  l32   r0,0(r6)                      | If link is null, then
  errexit z,code=&im_at_end           | at end.
  st    r0,&w.itc_token               | Save token of item.
  drop  r5                            |
* *-------------------------------------------------------------------*
* * Get item characteristics, make sure it is valid item type, and
* * return results.
* *-------------------------------------------------------------------*
  la    r1,&w.itc_                    | Get the item's
  callsub get_itc                     | characteristics.
  if (%l32,r1,lldmtitd,nz)            | If member type was specified:
   l    r6,&w.itc_address             |
   errexit (clc,0(2,r6),ne,lldmtitd),    Error if itemtype mismatch.   +
               code=&im_itemtype_mismatch
  endif                               | Endif.
  return_results i=2,type=&type       | Return results.
* *-------------------------------------------------------------------*
* * Make the item current-of-item-manager, current-of-item-type,
* * and current_of_descriptor.
* *-------------------------------------------------------------------*
  callsub make_current,(&w.itc_token,&w.descriptor_token)
* *-------------------------------------------------------------------*
         swa  type=partial            |
&w.descriptor_token ds f              |
&w.function         ds f              |
&w.head_token       ds f              |
         itc id=&w.itc_               |
         itc id=&w.itc_heads_         |
         endswa ,                     |
         mend
         eject                        |
*---------------------------------------------------------------------*
*
*  Subroutine: Obtain_first_function
*  Abstract:   This subroutine processes the obtain first function.
*              functions.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=obtain_first_function,                     +
               parmmap=prm_function_dependent
  first_final type=obtain,which=first
 endblk block=obtain_first_function   |
 space 1
*---------------------------------------------------------------------*
*
*  Subroutine: Find_first_function
*  Abstract:   This subroutine processes the find first function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=find_first_function,                       +
               parmmap=prm_function_dependent
  first_final type=find,which=first
 endblk block=find_first_function     |
   space 1                            |
*---------------------------------------------------------------------*
*
*  Subroutine: Obtain_final_function
*  Abstract:   This subroutine processes the obtain final function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=obtain_final_function,                     +
               parmmap=prm_function_dependent
  first_final type=obtain,which=final
 endblk block=obtain_final_function   |
   space 1                            |
*---------------------------------------------------------------------*
*
*  Subroutine: find_final_function
*  Abstract:   This subroutine processes the find final function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=find_final_function,                       +
               parmmap=prm_function_dependent
  first_final type=find,which=final
 endblk block=find_final_function     |
         eject
*---------------------------------------------------------------------*
*
*  Macro:      next_prior
*  Abstract:   This macro generates common code used by
*              obtain/find_next and obtain/find_prior subroutine.
*  Parameter:  TYPE=OBTAIN/FIND,WHICH=NEXT/PRIOR
*
*---------------------------------------------------------------------*
         macro
         next_prior &type=,&which=
         gblc  &w
         gbla  &im_currency_error
         gbla  &im_class_linked_list_descriptor
         gbla  &im_invalid_descriptor_token
         gbla  &im_headtkn_invalid
         gbla  &im_internal_error
         gbla  &im_at_end
         gbla  &im_itemtype_mismatch
         aif ('&which' eq 'next').next
         aif ('&which' eq 'prior').prior
         mnote 8,'which=&WHICH is invalid.'
         mexit
.next    anop
&o       setc 'FR'
&i       setc 'NX'
         ago  .process
.prior   anop
&o       setc 'FN'
&i       setc 'PR'
.process anop
* *-------------------------------------------------------------------*
* * Move descriptor and optional head token to work area.
* *-------------------------------------------------------------------*
  aif ('&type' eq 'obtain').obtain
  aif ('&type' eq 'find').find
  mnote 8,'TYPE=&TYPE is invalid.'
  mexit
.obtain anop
&j       setc 'ob'
  ago  .process2
.find   anop
&j       setc 'fd'
.process2 anop
  l     r1,prm_&j.2_descriptor_token    Move descriptor
  l     r1,0(,r1)                       token passed to
  st    r1,&w.descriptor_token          work area.
* *-------------------------------------------------------------------*
* * Establish base for LLD and ITD of LLD.
* *-------------------------------------------------------------------*
  imlta r4,&w.descriptor_token        | Load address of LLD
  using lld,r4                        | and establish base.
  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token
  l16   r1,0(r4)                      | Load address of
  litda r5,r1                         | LLDs ITD and
  using itd,r5                        | establish base.
  errexit (clc,itdclass,ne,=y(&im_class_linked_list_descriptor)),      +
               code=&im_invalid_descriptor_token
* *-------------------------------------------------------------------*
* * Find next/prior item.
* *-------------------------------------------------------------------*
  if (%l32,r1,prm_&j.2b_current_token,nz) If CURTKN specified:
   mvc    &w.itc_token,0(r1)          |  Use token supplied.
  else                                | If CURTKN not specified:
   callsub find_current,              |  Find current of descriptor.   +
               (&w.descriptor_token,&w.itc_token)
   errexit (treg,r15,nz),code=&im_currency_error
  endif                               | Endif.
  if (clc,&w.itc_token,eq,=f'0')      | If actually a f/o first:
   l     r1,prm_&j.2b_head_token      |  Load ptr to headtkn supplied.
   if (tbit,lldophid)                 |  If heads in descriptor:
    errexit (treg,r1,nz),code=&im_headtkn_invalid  NO HEADTKN!
    la    r6,lld&o.lst                |   Use first pointer
   else                               |  Else:
    if (treg,r1,nz)                   |   If HEADTKN specified:
     l     r1,0(,r1)                  |    Use head token
     st    r1,&w.itc_heads_token      |    supplied.
     la    r1,&w.itc_heads_           |    Get ITC
     callsub get_itc                  |    for item.
     l     r6,&w.itc_heads_address    |    EIF: ITD not ok for LLD.
     errexit (clc,0(2,r6),ne,lldhditd+2),code=&im_headtkn_invalid
     imlla r6,lld&o.lk#,&w.itc_heads_ |    Calcuate address of link.
     errexit (treg,r6,z),code=&im_headtkn_invalid
    else                              |   Else:
     callsub find_current,(lldhditd,&w.itc_heads_token) Find item
     errexit (treg,r15,nz),code=&im_currency_error     that has heads.
     la    r1,&w.itc_heads_           |    Get ITC
     callsub get_itc                  |    for item.
     imlla r6,lld&o.lk#,&w.itc_heads_ |    Calcuate address of link.
     errexit (treg,r6,z),code=&im_internal_error
    endif                             |   Endif.
   endif                              |  Endif.
   l32   r0,0(r6)                     |  If link is null, then
   errexit z,code=&im_at_end          |  at end.
   st    r0,&w.itc_token              |  Save token of first item.
  else                                | Else:
   la    r1,&w.itc_                   |  Get ITC for item that is
   callsub get_itc                    |  current of descriptor.
   imlla r6,lld&i.lk#,&w.itc_         |  Point to the "next" link.
   aif ('&type' eq 'prior').pr0010
   errexit (treg,r6,z),code=&im_internal_error
   ago   .pr0020
.pr0010 anop
   errexit (treg,r6,z),code=&im_requires_prior_link
.pr0020 anop
   l32   r0,0(r6)                     |  If link is null, then
   errexit z,code=&im_at_end          |  at end of list.
   st    r0,&w.itc_token              |  Save token of next item.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Get item characteristics, make sure item type is valid, and
* * return results.
* *-------------------------------------------------------------------*
  la    r1,&w.itc_                    | Get the item's
  callsub get_itc                     | characteristics.
  if (%l32,r1,lldmtitd,nz)            | If member type was specified:
   l    r6,&w.itc_address             |
   errexit (clc,0(2,r6),ne,lldmtitd),    Error if itemtype mismatch.   +
               code=&im_itemtype_mismatch
  endif                               | Endif.
  return_results i=2,type=&type       | Return results.
* *-------------------------------------------------------------------*
* * Make the item current-of-item-manager, current-of-item-type,
* * and current_of_descriptor.
* *-------------------------------------------------------------------*
  callsub make_current,(&w.itc_token,&w.descriptor_token)
*---------------------------------------------------------------------*
         swa   type=partial           |
&w.descriptor_token ds f              |
&w.function         ds f              |
         itc id=&w.itc_               |
         itc id=&w.itc_heads_         |
         endswa ,                     |
         mend                         |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Obtain_next_function
*  Abstract:   This subroutine processes the obtain next function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=obtain_next_function,                      +
               parmmap=prm_function_dependent
  next_prior type=obtain,which=next   |
 endblk block=obtain_next_function    |
   space 1                            |
*---------------------------------------------------------------------*
*
*  Subroutine: Find_next_function
*  Abstract:   This subroutine processes the find next function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=find_next_function,                        +
               parmmap=prm_function_dependent
  next_prior type=find,which=next     |
 endblk block=find_next_function      |
 space 1                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Obtain_prior_function
*  Abstract:   This subroutine processes the obtain prior function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=obtain_prior_function,                     +
               parmmap=prm_function_dependent
  next_prior type=obtain,which=prior  |
 endblk block=obtain_prior_function   |
 space 1                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Find_prior_function
*  Abstract:   This subroutine processes the find prior function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=find_prior_function,                       +
               parmmap=prm_function_dependent
  next_prior type=find,which=prior
 endblk block=find_prior_function     |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Modify_Function
*  Abstract:   This subroutine processes the modify function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=modify_function,                           +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * If a item token is not specified, modify current of item manager.
* *-------------------------------------------------------------------*
  l32   r1,prm_modify_item_token      | Point to item token.
  if nz,and,(clc,=f'0',ne,0(r1))      | If token supplied:
   mvc   &w.item_token,0(r1)          |  Use it.
  else                                | Otherwise:
   l32   r1,pwa_current_of_item_manager  Use current of item manager.
   errexit z,code=&im_currency_error  |  Error if nothing current.
   st    r1,&w.item_token             |  Save token.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Make sure that this is an unclassified item.
* *-------------------------------------------------------------------*
  l32   r3,prm_modify_item_address    | Point r1 item.
  errexit z,code=&im_missing_parameter  Error if missing.
  l16   r1,0(r3)                      | Load r0 with item type token.
  litda r4,r1                         | Point r4 to item type desc.
  using itd,r4                        | Establish base for ITD.
  l     r6,pwa_imc_address            | Load pointer to IMC.
  using imc,r6                        | Establish base for IMC.
  errexit      (clc,itditype,ne,imctditd+2),and, Error if this is not  +
               (clc,itditype,ne,imctditdx+2),or, a valid unclassified  +
               (clc,itdclass,ne,=y(&im_class_unclassified)), ITD.      +
               code=&im_invalid_item_type
  drop  r6                            | Drop base for IMC.
* *-------------------------------------------------------------------*
* * Make sure that items characteristics have not changed.
* *-------------------------------------------------------------------*
  imlta r5,&w.item_token              | Point r5 to unmodified item.
  errexit nz,or,(treg,r5,z),          |                                +
               code=&im_invalid_item  |
  errexit (clc,0(2,r3),ne,0(r5)),     |                                +
               code=&im_item_characteristics_changed
* *-------------------------------------------------------------------*
* * If this is an extend ITD, make sure that length, number of links,
* * or link offset has not changed.
* *-------------------------------------------------------------------*
  if (tbit,itdf1ext)                  | If this is an extended ITD:
*  *------------------------------------------------------------------*
*  * Make sure that size has not changed.
*  *------------------------------------------------------------------*
   if (tbit,itdf1lni)                 |  If length is in item:
    l32   r1,itdxilnof                |   Get length offset.
    errexit z,code=&im_internal_error |   Error if zero.
    lr    r6,r5                       |   Calculate address of length
    alr   r6,r1                       |   in unmodified copy of item.
    al    r1,prm_modify_item_address  |   Calc same for modified copy.
    l8    r2,itdxilnsz                |   Get size of length.
    errexit np,or,(ch,r2,gt,=h'4'),code=&im_internal_error
    bctr  r2,0                        |   It is an error if the length
    exi   r2,(clc,0(*-*,r6),0(r1))    |   modified and unmodified
    errexit ne,code=&im_item_characteristics_changed item is not same.
   endif                              |  Endif.
*  *------------------------------------------------------------------*
*  * Make sure that number of links has not changed.
*  *------------------------------------------------------------------*
   if (tbit,itdf1nli)                 |  If # links is in item:
    l32   r1,itdxinlof                |   Get # links offset.
    errexit z,code=&im_internal_error |   Error if zero.
    lr    r6,r5                       |   Calculate address of # links.
    alr   r6,r1                       |   in unmodified copy of item.
    al    r1,prm_modify_item_address  |   Calc same for modified copy.
    l8    r2,itdxinlsz                |   Get size of # links.
    errexit np,or,(ch,r2,gt,=h'4'),code=&im_internal_error
    bctr  r2,0                        |   It is an error if the # links
    exi   r2,(clc,0(*-*,r6),0(r1))    |   in modified and unmodified
    errexit ne,code=&im_item_characteristics_changed items is not same.
   endif                              |  Endif.
*  *------------------------------------------------------------------*
*  * Make sure that number of links has not changed.
*  *------------------------------------------------------------------*
   if (tbit,itdf1loi)                 |  If offset is in item:
    l32   r1,itdxiloof                |   Get offset offset.
    errexit z,code=&im_internal_error |   Error if zero.
    lr    r6,r5                       |   Calculate address of offset.
    alr   r6,r1                       |   in unmodified copy of item.
    al    r1,prm_modify_item_address  |   Calc same for modified copy.
    l8    r2,itdxilosz                |   Get size of offset.
    errexit np,or,(ch,r2,gt,=h'4'),code=&im_internal_error
    bctr  r2,0                        |   It is an error if the offset
    exi   r2,(clc,0(*-*,r6),0(r1))    |   in modified and unmodified
    errexit ne,code=&im_item_characteristics_changed items is not same.
   endif                              |  Endif.
  endif                               | Endif.
* *-------------------------------------------------------------------*
  drop  r4                            | Drop base for ITD.
* *-------------------------------------------------------------------*
* * Get the characteristics of the item and validate links if
* * requested.
* *-------------------------------------------------------------------*
  mvi   &w.links_check,c"Y"           |
  l32   r1,prm_modify_options         |
  if z,or,(tbit,0(r1),                |                                +
               prm_modify_options_bypass_links_check)
   mvi   &w.links_check,c"N"          |
  endif                               |
  callsub get_characteristics_and_validate,                            +
               (*prm_modify_item_address,                              +
               &w.links_check,        |                                +
               ,                      |                                +
               &w.size_of_item,       |                                +
               &w.number_of_links,    |                                +
               &w.offset_of_links)    |
* *-------------------------------------------------------------------*
* * If links are not being updated, set up to move item in two parts.
* *-------------------------------------------------------------------*
  mvc   &w.size_of_first_part,&w.size_of_item Assume move all.
  fill  &w.size_of_second_part,x'00'  | Assume no second part.
  l32   r1,prm_modify_options         | If links not being updated:
  if z,or,not,(tbit,0(r1),            |                                +
               prm_modify_options_update_links)
   l32   r15,&w.number_of_links       |  Load r15 with number of links.
   if nz                              |  If there are links:
    l     r1,&w.offset_of_links       |   Offset of links is size
    st    r1,&w.size_of_first_part    |   of first part.
    sla   r15,2                       |   Calculate size of links.
    ar    r15,r1                      |   Add size of 1st part to size
    st    r15,&w.offset_of_second_part    of link to get 2nd offset.
    s     r15,&w.size_of_item         |   The size of the item minus
    lcr   r15,r15                     |   the size of the 2nd offset
    st    r15,&w.size_of_second_part  |   is the size of the 2nd part.
   endif                              |  Endif.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Modify the first part of the item.
* *-------------------------------------------------------------------*
  l     r15,&w.size_of_first_part     | Load size of first part.
  lr    r6,r5                         | Point r6 to unmodified item.
  l     r2,prm_modify_item_address    | Point r2 to modified item.
  loop until                          | Move modified to unmodified.
   ltr   r1,r15                       |  Load r1 with remaining
   leave np,loop=*                    |  move length.  Finished if
*                                     |  length is not positive.
   if (ch,r1,gt,=h'256')              |  Can only move
    la    r1,256                      |  up to 256 bytes
   endif                              |  at a time.
   sr    r15,r1                       |  Calc new remaining length.
   bctr  r1,0                         |  Move up to 256
   exi   r1,(mvc,0(*-*,r6),0(r2))     |  bytes of item.
   la    r2,256(,r2)                  |  Point to next 256 bytes
   la    r6,256(,r6)                  |  of item.
  endloop until,leave                 | Endloop.
* *-------------------------------------------------------------------*
* * Modify the second part of the item.
* *-------------------------------------------------------------------*
  l     r15,&w.size_of_second_part    | Load size of second part.
  lr    r6,r5                         | Point r6 to second part of
  a     r6,&w.offset_of_second_part   | unmodified item.
  l     r2,prm_modify_item_address    | Point r2 to second part of
  a     r2,&w.offset_of_second_part   | modified item.
  loop until                          | Move modified to unmodified.
   ltr   r1,r15                       |  Load r1 with remaining
   leave np,loop=*                    |  move length.  Finished if
*                                     |  length is not positive.
   if (ch,r1,gt,=h'256')              |  Can only move
    la    r1,256                      |  up to 256 bytes
   endif                              |  at a time.
   sr    r15,r1                       |  Calc new remaining length.
   bctr  r1,0                         |  Move up to 256
   exi   r1,(mvc,0(*-*,r6),0(r2))     |  bytes of item.
   la    r2,256(,r2)                  |  Point to next 256 bytes
   la    r6,256(,r6)                  |  of item.
  endloop until,leave                 | Endloop.
* *-------------------------------------------------------------------*
* * Make the item current-of-item-manager and current-of-item-type.
* *-------------------------------------------------------------------*
  callsub make_current,(&w.item_token,)
* *-------------------------------------------------------------------*
 endblk block=modify_function         |
         swa ,                        |
&w.item_token                    ds f |
&w.size_of_item                  ds f |
&w.size_of_first_part            ds f |
&w.size_of_second_part           ds f |
&w.offset_of_second_part         ds f |
&w.number_of_links               ds f |
&w.offset_of_links               ds f |
&w.links_check                   ds c |
         endswa ,                     |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Sort_Function
*  Abstract:   This subroutine processes the sort function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=sort_function,                             +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * Get address descriptor and descriptor's ITD.
* *-------------------------------------------------------------------*
  l32   r1,prm_sort_descriptor_token  | Point r1 to descriptor token.
  errexit z,code=&im_invalid_descriptor_token It is also required.
  imlta r4,*r1                        | Get address of descriptor.
  errexit nz,or,(treg,r4,z),          | Error if invalid or null.      +
               code=&im_invalid_descriptor_token
  l16   r1,0(r4)                      | Get address of
  litda r5,r1                         | ITD for descriptor.
  using itd,r5                        | Establish base for ITD.
* *-------------------------------------------------------------------*
* * Process based on descriptor class.
* *-------------------------------------------------------------------*
  lh    r1,itdclass                   | Load class into r1.
  caseblk reg=r1                      | Process based on class.
  case &im_class_linked_list_descriptor For linked list:
   callsub sort_a_list,               |                                +
               (*prm_sort_descriptor_token,                            +
               *prm_sort_fieldslist,                                   +
               *prm_sort_head_token,                                   +
               *prm_sort_technique)
  case other                          | If other class of item:
   errexit code=&im_invalid_descriptor_token  It is an error.
  endcase                             | Endif.
* *-------------------------------------------------------------------*
 endblk block=sort_function           |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Store_Function
*  Abstract:   This subroutine processes the store function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=store_function,                            +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * Make sure that this is an unclassified item.
* *-------------------------------------------------------------------*
  l32   r2,prm_store_item_address     | Point r1 item.
  errexit z,code=&im_missing_parameter  Error if missing.
  l16   r1,0(r2)                      | Load r1 with item type token.
  litda r4,r1                         | Point r4 to item type desc.
  using itd,r4                        | Establish base for ITD.
  l     r6,pwa_imc_address            | Load pointer to IMC.
  using imc,r6                        | Establish base for IMC.
  errexit      (clc,itditype,ne,imctditd+2),and, Error if this is not  +
               (clc,itditype,ne,imctditdx+2),or, a valid unclassified  +
               (clc,itdclass,ne,=y(&im_class_unclassified)), ITD.      +
               code=&im_invalid_item_type
  drop  r6                            | Drop base for IMC.
  drop  r4                            | Drop base for ITD.
* *-------------------------------------------------------------------*
* * Store the item and return its token.
* *-------------------------------------------------------------------*
  l     r1,prm_store_item_address     | Point to item.
  callsub store_item                  | Store the item.
  st    r0,&w.token                   | Save token.
  l32   r1,prm_store_item_token       | Point r1 token storage.
  if nz                               | If token should be returned:
   st    r0,0(,r1)                    |  Save token in return area.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Make the item current-of-item-manager and current-of-item-type.
* *-------------------------------------------------------------------*
  callsub make_current,(&w.token,)    |
* *-------------------------------------------------------------------*
 endblk block=store_function          |
   space 2                            |
         swa  ,                       |
&w.token ds   f                       |
         endswa ,                     |
   eject                              |
*---------------------------------------------------------------------*
*
*  Subroutine: Erase_Function
*  Abstract:   This subroutine processes the erase function.
*
*---------------------------------------------------------------------*
 block type=subroutine,name=erase_function,                            +
               parmmap=prm_function_dependent
* *-------------------------------------------------------------------*
* * Make sure that this is an unclassified item.
* *-------------------------------------------------------------------*
  l32   r1,prm_erase_item_token       | Point r1 item token.
  errexit z,code=&im_missing_parameter  Error if missing.
  imlta r5,*r1                        | Point r5 to item.
  errexit nz,or,(treg,r5,z),          | Error if invalid or null.      +
               code=&im_invalid_item_type
  l16   r1,0(r5)                      | Load r1 with item type token.
  litda r4,r1                         | Point r4 to item type desc.
  using itd,r4                        | Establish base for ITD.
  l     r6,pwa_imc_address            | Load pointer to IMC.
  using imc,r6                        | Establish base for IMC.
  errexit      (clc,itditype,ne,imctditd+2),and, Error if this is not  +
               (clc,itditype,ne,imctditdx+2),or, a valid ITD.          +
               (clc,itdclass,ne,=y(&im_class_unclassified)),           +
               code=&im_invalid_item_type
  drop  r6                            | Drop base for IMC.
  drop  r4                            | Drop base for ITD.
* *-------------------------------------------------------------------*
* * Erase the item.
* *-------------------------------------------------------------------*
  l     r0,prm_erase_item_token       | Load item token in r0.
  callsub erase_item,                 | Erase the item.                +
               (*prm_erase_item_token)
* *-------------------------------------------------------------------*
 endblk block=erase_function          |
    eject                             |
*---------------------------------------------------------------------*
*
*  Subroutine: Make a DSC.
*  Abstract:   This subroutine store an item in the group associated
*              with its ITD.
*  Input:      r1 - Address of a one byte length of text followed
*                   by the text of the description.
*  Output:     r0 - Token of description.
*
*---------------------------------------------------------------------*
 block name=make_a_dsc,type=subroutine,options=noparms
* *-------------------------------------------------------------------*
* * Build a DSC.
* *-------------------------------------------------------------------*
  fill  &w.build_area,x'00'           | Clear the build area.
  l     r4,pwa_imc_address            | Point r4 to IMC.
  using imc,r4                        | Establish base for IMC.
  la    r2,&w.build_area              | Point r2 to build area.
  using dsc,r2                        | Establish base for build area.
  mvc   dscitype,imctddsc+2           | Move type token to DSC.
  l8    r3,0(r1)                      | Load length of text.
  errexit (ch,r3,gt,=h'250'),         | Error if desc is too long.     +
               code=&im_description_too_long
  bctr  r3,0                          | Sub 1 for EX.
  exi   r3,(mvc,dsctext(*-*),1(r1))   | Move text to description.
  ah    r3,=y(l'dscitype+l'dscsize+1) | Calculate total size of DSC
  stc   r3,dscsize                    | and store that in DSC.
* *-------------------------------------------------------------------*
* * Store the DSC and return its token.
* *-------------------------------------------------------------------*
  la    r1,&w.build_area              | Point to build area.
  callsub store_item                  | Store item.
  strsa r0                            | Return to caller.
* *-------------------------------------------------------------------*
 endblk block=make_a_dsc              |
         swa ,                        |
&w.build_area                ds xl256 |
         endswa ,                     |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Store item.
*  Abstract:   This subroutine store an item in the group associated
*              with its ITD.
*  Input:      r1 - Address of item.
*  Output:     r0 - Token of item.
*
*---------------------------------------------------------------------*
 block name=store_item,type=subroutine,options=noparms
* *-------------------------------------------------------------------*
* * Establish base for parameter list.
* *-------------------------------------------------------------------*
  lr    r3,r1                         | Point r3 to item.
  st    r3,&w.item                    | Save address of item.
* *-------------------------------------------------------------------*
* * Get characteristics of item and validate it.
* *-------------------------------------------------------------------*
  callsub get_characteristics_and_validate, Validate.                  +
               (*&w.item,"Y",         |                                +
               &w.grd_token,          |                                +
               &w.size,,)             |
* *-------------------------------------------------------------------*
* * Obtain storage for the item.
* *-------------------------------------------------------------------*
  callsub obtain_item_storage,        | Get storage for item.          +
               (&w.grd_token,         |                                +
               &w.size,               |                                +
               &w.item_token,         |                                +
               &w.item_address)       |
* *-------------------------------------------------------------------*
* * Increment the number of items of this item type.
* *-------------------------------------------------------------------*
  l16   r1,0(r3)                      | Load item type token.
  litda r4,r1                         | Get its address.
  using itd,r4                        | Establish base for ITD.
  l     r1,itdnumit                   | Increment the number
  ah    r1,=h'1'                      | of items of
  st    r1,itdnumit                   | this type.
  drop  r4                            | Drop bae for ITD.
* *-------------------------------------------------------------------*
* * Move item to item storage.
* *-------------------------------------------------------------------*
  l     r15,&w.size                   | Load size of item.
  l     r6,&w.item_address            | Point r6 to new item storage.
  l     r2,&w.item                    | Point r2 to new item.
  loop until                          | Move item to item storage.
   ltr   r1,r15                       |  Load r1 with remaining
   leave np,loop=*                    |  move length.  Finished if
*                                     |  length is not positive.
   if (ch,r1,gt,=h'256')              |  Can only move
    la    r1,256                      |  up to 256 bytes
   endif                              |  at a time.
   sr    r15,r1                       |  Calc new remaining length.
   bctr  r1,0                         |  Move up to 256
   exi   r1,(mvc,0(*-*,r6),0(r2))     |  bytes of item.
   la    r2,256(,r2)                  |  Point to next 256 bytes
   la    r6,256(,r6)                  |  of item.
  endloop until,leave                 | Endloop.
* *-------------------------------------------------------------------*
* * Return the token in r0.
* *-------------------------------------------------------------------*
  l     r0,&w.item_token              | Load token.
  strsa r0                            | Return it in r0.
* *-------------------------------------------------------------------*
 endblk block=store_item              |
         swa ,                        |
&w.item                      ds a     |
&w.size                      ds f     |
&w.grd_token                 ds f     |
&w.item_token                ds f     |
&w.item_address              ds f     |
&w.item_type_token           ds f     |
         endswa ,                     |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Erase item.
*  Abstract:   This subroutine will free the storage associated with
*              an item and decrement the count of item of this type.
*  Parameters: (>item_token)
*
*---------------------------------------------------------------------*
 block name=erase_item,type=subroutine,parms=(token)
* *-------------------------------------------------------------------*
* * Get address of item.
* *-------------------------------------------------------------------*
  imlta r4,*&p.token                  | Get address of item.
  errexit nz,or,(treg,r4,z),          | Error if invalid or null.      +
               code=&im_invalid_token |
  st    r4,&w.item_address            | Save address of item.
* *-------------------------------------------------------------------*
* * Get a pointer to the ITD for the item.
* *-------------------------------------------------------------------*
  l16   r1,0(r4)                      | Load ITD token in r1.
  litda r5,r1                         | Convert to an address.
  using itd,r5                        | Establish base for ITD.
* *-------------------------------------------------------------------*
* * Establish base for IMC.
* *-------------------------------------------------------------------*
  l     r6,pwa_imc_address            | Load IMC address.
  using imc,r6                        | Establish base for IMC.
* *-------------------------------------------------------------------*
* * If this is an extend ITD, get the length the hard way.
* *-------------------------------------------------------------------*
  if (tbit,itdf1ext)                  | If this is an extended ITD:
   errexit (clc,itditype,ne,imctditdx+2), Fuss if ITD's type is not    +
               code=&im_invalid_item  |  what it should be.
   if (tbit,itdf1lni,off)             |  If length is not in item:
    l32   r0,itdxiln                  |   Get length from ITD.
    st    r0,&w.size                  |   Save length in work area.
   else                               |  If length is in item:
    l32   r6,itdxilnof                |   Load r6 with length offset.
    errexit z,code=&im_internal_error |   Error if it is zero.
    alr   r6,r4                       |   Point r6 to length in item.
    l32   r1,itdxilnsz                |   Load length size from ITD.
    errexit np,or,(ch,r1,gt,=y(4)),   |   Error if size is not between +
               code=&im_internal_error    1 and 4.
    fill  &w.size,x'00'               |   Clear size in work area.
    la    r2,&w.size+4                |   Move the length, left
    sr    r2,r1                       |   justified, in the size
    bctr  r1,0                        |   field in the
    exi   r1,(mvc,0(*-*,r2),0(r6))    |   work area.
   endif                              |  Endif.
* *-------------------------------------------------------------------*
* * If this is a normal ITD, get the length the easy way.
* *-------------------------------------------------------------------*
  else                                |  If not an extended ITD.
   errexit (clc,itditype,ne,imctditd+2),  Error if ITD item type is    +
               code=&im_invalid_item  |   not valid.
   l8    r0,itdiln                    |   Move length to
   st    r0,&w.size                   |   field in work area.
  endif                               |  Endif.
* *-------------------------------------------------------------------*
* * Free storage associated with item.
* *-------------------------------------------------------------------*
  mvc   &w.grd_token,itdgrd           | Get GRD token.
  callsub free_item_storage,          | Get storage for item.          +
               (&w.grd_token,         |                                +
               &w.size,               |                                +
               *&p.token,             |                                +
               &w.item_address)       |
* *-------------------------------------------------------------------*
* * Decrement the number of items of this item type.
* *-------------------------------------------------------------------*
  l     r1,itdnumit                   | Decrement the number
  sh    r1,=h'1'                      | of items of
  st    r1,itdnumit                   | this type.
* *-------------------------------------------------------------------*
 endblk block=erase_item              |
         swa ,                        |
&w.size                      ds f     |
&w.grd_token                 ds f     |
&w.item_address              ds a     |
         endswa ,                     |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Get_characteristics_and_validate
*  Abstract:   This subroutine will make check to help insure that
*              the a item is valid.  It will also turn the size,
*              number of links, and offset of links if the parameter
*              are present.
*  Parameters: (>item,>extensive,<size|,<number_links|,
*               <offset_of_links|)
*
*---------------------------------------------------------------------*
 block name=get_characteristics_and_validate,type=subroutine,          +
               parms=(item,option,grd,item_size,number_of_links,       +
               links_offset)          |
* *-------------------------------------------------------------------*
* * Use r4 as ITD base and r5 as IMC base.
* *-------------------------------------------------------------------*
  l32   r2,&p.item                    |
  errexit z,code=&im_invalid_item     |
  l16   r1,0(r2)                      |
  litda r4,r1                         |
  using itd,r4                        |
  l     r5,pwa_imc_address            |
  using imc,r5                        |
* *-------------------------------------------------------------------*
* * If this is an extend ITD, get the length, number of link, and
* * offset the hard way.
* *-------------------------------------------------------------------*
  if (tbit,itdf1ext)                  |
   errexit (clc,itditype,ne,imctditdx+2),                              +
               code=&im_invalid_item  |
*  *------------------------------------------------------------------*
*  * Get item size.
*  *------------------------------------------------------------------*
   if (tbit,itdf1lni,off)             |
    l32   r0,itdxiln                  |
   else                               |
    l32   r1,itdxilnof                |
    errexit z,code=&im_internal_error |
    slr   r0,r0                       |
    al    r1,&p.item                  |
    l8    r2,itdxilnsz                |
    caseblk reg=r2                    |
    case 1                            |
     ic   r0,0(,r1)                   |
    case 2                            |
     icm  r0,b'0011',0(r1)            |
    case 3                            |
     icm  r0,b'0111',0(r1)            |
    case 4                            |
     l    r0,0(r1)                    |
    case other                        |
     errexit code=&im_internal_error  |
    endcase                           |
   endif                              |
   st    r0,&w.item_size              |
*  *------------------------------------------------------------------*
*  * Get number of links.
*  *------------------------------------------------------------------*
   if (tbit,itdf1nli,off)             |
    l32   r0,itdxinl                  |
   else                               |
    l32   r1,itdxinlof                |
    errexit z,code=&im_internal_error |
    al    r1,&p.item                  |
    l8    r2,itdxinlsz                |
    slr   r0,r0                       |
    caseblk reg=r2                    |
    case 1                            |
     ic   r0,0(,r1)                   |
    case 2                            |
     icm  r0,b'0011',0(r1)            |
    case 3                            |
     icm  r0,b'0111',0(r1)            |
    case 4                            |
     l    r0,0(r1)                    |
    case other                        |
     errexit code=&im_internal_error  |
    endcase                           |
   endif                              |
   st    r0,&w.number_of_links        |
*  *------------------------------------------------------------------*
*  * Get links offset.
*  *------------------------------------------------------------------*
   if (tbit,itdf1loi,off)             |
    l32   r0,itdxilo                  |
   else                               |
    l32   r1,itdxiloof                |
    errexit z,code=&im_internal_error |
    al    r1,&p.item                  |
    l8    r2,itdxilosz                |
    slr   r0,r0                       |
    caseblk reg=r2                    |
    case 1                            |
     ic   r0,0(,r1)                   |
    case 2                            |
     icm  r0,b'0011',0(r1)            |
    case 3                            |
     icm  r0,b'0111',0(r1)            |
    case 4                            |
     l    r0,0(,r1)                   |
    case other                        |
     errexit code=&im_internal_error  |
    endcase                           |
   endif                              |
   st    r0,&w.links_offset           |
* *-------------------------------------------------------------------*
* * If this is a normal ITD, get the length, number of link, and
* * offset the easy way.
* *-------------------------------------------------------------------*
  else                                |
   errexit (clc,itditype,ne,imctditd+2),                               +
               code=&im_invalid_item  |
   l8    r0,itdiln                    |
   st    r0,&w.item_size              |
   l8    r0,itdilo                    |
   st    r0,&w.links_offset           |
   l8    r0,itdinl                    |
   st    r0,&w.number_of_links        |
  endif                               |
* *-------------------------------------------------------------------*
* * Return whatever was asked for.
* *-------------------------------------------------------------------*
  l32   r1,&p.grd                     | Load pointer to return area.
  if nz                               | If specified:
   mvc   0(l'itdgrd,r1),itdgrd        |  Return the valid.
  endif                               | Endif.
  l32   r1,&p.item_size               | Load pointer to return area.
  if nz                               | If specified:
   mvc   0(4,r1),&w.item_size         |  Return the value.
  endif                               | Endif.
  l32   r1,&p.number_of_links         | Load pointer to return area.
  if nz                               | If specified:
   mvc   0(4,r1),&w.number_of_links   | Return the value.
  endif                               | Endif.
  l32   r1,&p.links_offset            | Load pointer to return area.
  if nz                               | If specified:
   mvc   0(4,r1),&w.links_offset      |  Return the value.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* check links and length, etc.        |
 endblk block=get_characteristics_and_validate
         swa                          |
&w.item_size                    ds f  |
&w.number_of_links              ds f  |
&w.links_offset                 ds f  |
         endswa                       |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Get_ITC
*  Abstract:   This subroutine fills in the ITC for an item in
*              item managed storage.  Before calling this routine,
*              ITC_token should contain the token of the item to
*              return.
*  Parameters: R1->ITC
*
*---------------------------------------------------------------------*
 block name=get_ITC,type=subroutine,  |                                +
               options=noparms        |
* *-------------------------------------------------------------------*
* * Establish base for ITC and get address of item.  R3 will be
* * used as base for the ITC and r6 will be used as base for the item.
* * Clear ITC flag.
* *-------------------------------------------------------------------*
  lr    r3,r1                         | Point r3 to ITC.
  using itc_,r3                       | Establish base for ITC.
  imlta r6,itc_token                  | Point r6 to item.
  errexit nz,or,(treg,r6,z),code=&im_invalid_token
  st    r6,itc_address                | Save pointer to item.
* mvc   itc_f,0                       | Clear flags.                @C1
  mvi   itc_f,0                       | Clear flags.                @C1
* *-------------------------------------------------------------------*
* * Use r4 as ITD base and r5 as IMC base.
* *-------------------------------------------------------------------*
  l16   r1,0(r6)                      | Load item type into r1.
  sth   r1,itc_itype                  | Save it in ITC.
  litda r4,r1                         | Get address of ITD.
  using itd,r4                        | Establish base for ITD.
  st    r4,itc_itd_address            | Save ITD address.
  l     r5,pwa_imc_address            | Point r5 to IMC
  using imc,r5                        | and establish base.
* *-------------------------------------------------------------------*
* * If this is an extend ITD, get the length, number of link, and
* * offset the hard way.
* *-------------------------------------------------------------------*
  if (tbit,itdf1ext)                  | If extended ITC:
   errexit (clc,itditype,ne,imctditdx+2),                              +
               code=&im_invalid_item  |
*  *------------------------------------------------------------------*
*  * Get item size.
*  *------------------------------------------------------------------*
   if (tbit,itdf1lni,off)             |  If length not in item:
    l32   r0,itdxiln                  |   Use fixed lenght in ITD.
   else                               |  Else:
    sbit  itc_f_variable_size         |   Variable item size.
    l32   r1,itdxilnof                |   Load offset of length.
    errexit z,code=&im_internal_error |   Error if zero.
    slr   r0,r0                       |   Clear result register.
    al    r1,itc_address              |   Calculate address of length.
    l8    r2,itdxilnsz                |   Load r2 with size of length.
    caseblk reg=r2                    |   Process based on size.
    case 1                            |   One byte:
     ic   r0,0(,r1)                   |    Load one byte length.
    case 2                            |   Two bytes:
     icm  r0,b'0011',0(r1)            |    Load two byte length.
    case 3                            |   Three bytes:
     icm  r0,b'0111',0(r1)            |    Load three byte length.
    case 4                            |   Four bytes:
     l    r0,0(r1)                    |    Load four byte length.
    case other                        |   Other size:
     errexit code=&im_internal_error  |    This is bad news.
    endcase                           |   Endcase.
   endif                              |  Endif.
   st    r0,itc_size                  |  Save size in ITC.
*  *------------------------------------------------------------------*
*  * Get number of links.
*  *------------------------------------------------------------------*
   if (tbit,itdf1nli,off)             |  If # links not in item:
    l32   r0,itdxinl                  |   Use fixed # links from ITD.
   else                               |  Else:
    sbit  itc_f_variable_number_links |   Variable links offset.
    l32   r1,itdxinlof                |   Load offset of # links.
    errexit z,code=&im_internal_error |   Error if zero.
    slr   r0,r0                       |   Clear result register.
    al    r1,itc_address              |   Calculate address of # links.
    l8    r2,itdxinlsz                |   Load size of # links field.
    caseblk reg=r2                    |   Process based on size.
    case 1                            |   One byte:
     ic   r0,0(,r1)                   |    Load one byte # links.
    case 2                            |   Two bytes:
     icm  r0,b'0011',0(r1)            |    Load two byte # links.
    case 3                            |   Three bytes:
     icm  r0,b'0111',0(r1)            |    Load three byte # links.
    case 4                            |   Four bytes:
     l    r0,0(r1)                    |    Load four byte # links.
    case other                        |   Other size:
     errexit code=&im_internal_error  |    This is bad news.
    endcase                           |   Endcase.
   endif                              |  Endif.
   st    r0,itc_number_links          |  Save # links in ITC.
*  *------------------------------------------------------------------*
*  * Get links offset.
*  *------------------------------------------------------------------*
   if (tbit,itdf1loi,off)             |  If links offset not in item:
    l32   r0,itdxilo                  |   Use fixed offset from ITD.
   else                               |  Else:
    sbit  itc_f_variable_links_offset |   Variable links offset.
    l32   r1,itdxiloof                |   Load offset of offset.
    errexit z,code=&im_internal_error |   Error if zero.
    slr   r0,r0                       |   Clear result register.
    al    r1,itc_address              |   Calculate address if offset.
    l8    r2,itdxilosz                |   Load r2 with size of offset.
    caseblk reg=r2                    |   Process based on size.
    case 1                            |   One byte:
     ic   r0,0(,r1)                   |    Load one byte offset.
    case 2                            |   Two bytes:
     icm  r0,b'0011',0(r1)            |    Load two byte offset.
    case 3                            |   Three bytes:
     icm  r0,b'0111',0(r1)            |    Load three byte offset.
    case 4                            |   Four bytes:
     l    r0,0(,r1)                   |    Load four byte offset.
    case other                        |   Other size:
     errexit code=&im_internal_error  |    This is bad news.
    endcase                           |   Endcase.
   endif                              |  Endif.
   st    r0,itc_offset_links          |  Save offset in ITC.
* *-------------------------------------------------------------------*
* * If this is a normal ITD, get the length, number of links, and
* * offset the easy way.
* *-------------------------------------------------------------------*
  else                                | Else:
   errexit (clc,itditype,ne,imctditd+2), Error if not valid ITD.       +
               code=&im_invalid_item  |
   l8    r0,itdiln                    |  Store fixed
   st    r0,itc_size                  |  item size.
   l8    r0,itdilo                    |  Store fixed
   st    r0,itc_offset_links          |  links offset.
   l8    r0,itdinl                    |  Store fixed
   st    r0,itc_number_links          |  number of links.
  endif                               | Endif.
 endblk block=get_ITC                 |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Connect_to_list
*  Abstract:   This subroutine copys an item from item managed
*              storage to a return area that is not in item managed
*              storage.
*  Parameters: (>item_token,>descriptor_token)
*
*---------------------------------------------------------------------*
 block name=connect_to_list,type=subroutine,                           +
               parms=(item_token,descriptor_token,head_token)
* *-------------------------------------------------------------------*
* *  Get item characteristics.
* *-------------------------------------------------------------------*
  l     r1,&p.item_token              | Move item token
  mvc   &w.itc_token,0(r1)            | to work area.
  la    r1,&w.itc_                    | Get item
  callsub get_itc                     | characteristics.
* *-------------------------------------------------------------------*
* *  Get base for descriptor.
* *-------------------------------------------------------------------*
  imlta r4,*&p.descriptor_token       |
  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token
  using lld,r4                        |
* *-------------------------------------------------------------------*
* *  Get address of list heads.
* *-------------------------------------------------------------------*
  if (tbit,lldophid)                  | If heads in descriptor:
   la    r0,lldfrlst                  |  Use first pointer
   st    r0,&w.first_ptr_addr         |  in LLD.
   la    r0,lldfnlst                  |  Use final pointer
   st    r0,&w.final_ptr_addr         |  in LLD.
   errexit (%l32,r1,&p.head_token,nz),and,(clc,0(r1),ne,=f'0'),        +
               code=&im_head_not_valid_for_this_descriptor
  else                                | Else:
   if (%l32,r1,&p.head_token,nz),and, |  If head token supplied        +
               (%l32,r1,0(r1),nz)     |  by caller:
    st    r1,&w.itc_heads_token       |   Use it.
   else                               |  Else:
    callsub find_current,(lldhditd,&w.itc_heads_token) Find item
    errexit (treg,r15,nz),code=&im_currency_error      that has heads.
    errexit nz,code=&im_internal_error
   endif                              |  Endif.
   la    r1,&w.itc_heads_             |               Get ITC
   callsub get_itc                    |               for item.
   imlla &w.first_ptr_addr,lldfrlk#,&w.itc_heads_     Get links
   imlla &w.final_ptr_addr,lldfnlk#,&w.itc_heads_     from item.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* *  Get addresses of links in item.
* *-------------------------------------------------------------------*
  imlla r1,lldnxlk#,&w.itc_           | Point r1 to next link.
  st    r1,&w.next_ptr_addr           | Save it.
  ltr   r6,r1                         | Put it in r6.
  errexit z,code=&im_internal_error   | Error if no next link.
  errexit (clc,=f'0',ne,0(r6)),code=&im_link_not_null       Must be 0.
  imlla r1,lldprlk#,&w.itc_           | Point r1 to prior link.
  st    r1,&w.prior_ptr_addr          | Save it.
  ltr   r6,r1                         | Point r6 to link.
  errexit nz,and,(clc,=f'0',ne,0(r6)),code=&im_link_not_null Must be 0.
  imlla r1,lldowlk#,&w.itc_           | Point r1 to owner link.
  st    r1,&w.owner_ptr_addr          | Save it.
  ltr   r6,r1                         | Point r6 to link.
  errexit nz,and,(clc,=f'0',ne,0(r6)),code=&im_link_not_null Must be 0.
* *-------------------------------------------------------------------*
* *  Connect items based on list order.
* *-------------------------------------------------------------------*
  ic    r1,lldop                      | Load list
  n     r1,=a(lldopord)               | order.
  caseblk reg=r1                      | Process based on order.
* *-------------------------------------------------------------------*
* *  Connect order: first.
* *-------------------------------------------------------------------*
  case 0 (first)                      | Insert at start of list.
   l32   r6,&w.first_ptr_addr         |  Point r6 to first pointer.
   errexit z,code=&im_internal_error  |  Error if there is not one.
   if (clc,=f'0',eq,0(r6))            |  If list is empty:
    mvc   0(4,r6),&w.itc_token        |   Move token to first ptr.
    l32   r6,&w.final_ptr_addr        |   If there is a
    if nz                             |    final link:
     mvc   0(4,r6),&w.itc_token       |    Move token to final ptr.
    endif                             |   Endif.
   else                               |  Else if entries in list:
    l32   r5,&w.next_ptr_addr         |   Point to next ptr in item.
    errexit z,code=&im_internal_error |   Error if there is not one.
    mvc   0(4,r5),0(r6)               |   Next link <- old first link.
    mvc   0(4,r6),&w.itc_token        |   First link <- new item token.
    if (clc,=f'0',ne,lldprlk#)        |   If there are prior links:
     mvc   &w.itc_wrk_token,0(r5)     |    Get ITC
     la    r1,&w.itc_wrk_             |    for old first
     callsub get_itc                  |    item in list.
     imlla r5,lldprlk#,&w.itc_wrk_    |    Move new item token to
     mvc   0(4,r5),&w.itc_token       |    prior link in old first.
    endif                             |   Endif.
   endif                              |  Endif.
   l32   r6,&w.owner_ptr_addr         |  Point r6 to owner pointer.
   if nz,and,not,(tbit,lldophid)      |  If there is one and heads
    mvc   0(4,r6),&w.itc_heads_token  |  are not in the descriptor,
   endif                              |  move heads token to item.
* *-------------------------------------------------------------------*
* *  Connect order: final.
* *-------------------------------------------------------------------*
  case 1 (final)                      |
   l32   r6,&w.final_ptr_addr         |  Point r6 to final pointer.
   errexit z,code=&im_requires_final_link Error if there is not one.
   if (clc,=f'0',eq,0(r6))            |  If list is empty:
    mvc   0(4,r6),&w.itc_token        |   Move token to final ptr.
    l32   r6,&w.first_ptr_addr        |   Load first pointer.
    errexit z,code=&im_internal_error |   Error if missing.
    mvc   0(4,r6),&w.itc_token        |   Move token to first ptr.
   else                               |  Else if entries in list:
    mvc   &w.itc_wrk_token,0(r6)      |   Save old final token.
    l32   r5,&w.prior_ptr_addr        |   Point to prior ptr in item.
    if nz                             |   If prior link exists:
     mvc   0(4,r5),0(r6)              |    Prior link <- old final lnk.
    endif                             |   Endif.
    mvc   0(4,r6),&w.itc_token        |   Final link <- new item token.
    la    r1,&w.itc_wrk_              |   Get ITC for old final
    callsub get_itc                   |   item in list.
    imlla r5,lldnxlk#,&w.itc_wrk_     |   Move new item token to
    mvc   0(4,r5),&w.itc_token        |   next link in old final.
   endif                              |  Endif.
   l32   r6,&w.owner_ptr_addr         |  Point r6 to owner pointer.
   if nz,and,not,(tbit,lldophid)      |  If there is one and heads
    mvc   0(4,r6),&w.itc_heads_token  |  are not in the descriptor,
   endif                              |  move heads token to item.
* *-------------------------------------------------------------------*
* *  Connect order: next.
* *-------------------------------------------------------------------*
  case 2 (next)                       | Insert next in list.
   errexit code=&im_not_yet_supported |
* *-------------------------------------------------------------------*
* *  Connect order: prior.
* *-------------------------------------------------------------------*
  case 3 (prior)                      | Insert prior in list.
   errexit code=&im_not_yet_supported |
* *-------------------------------------------------------------------*
* *  Connect order: sorted ascending.
* *-------------------------------------------------------------------*
  case 4 (sorted ascending)           | Insert sorted in list.
   errexit code=&im_not_yet_supported |
* *-------------------------------------------------------------------*
* *  Connect order: sorted descending.
* *-------------------------------------------------------------------*
  case 5 (sorted descending)          | Insert sorted in list.
   errexit code=&im_not_yet_supported |
* *-------------------------------------------------------------------*
* *  Woops!
* *-------------------------------------------------------------------*
  case  other                         |
   errexit code=&im_internal_error    |
  endcase                             |
* *-------------------------------------------------------------------*
 endblk block=connect_to_list         |
         swa ,                        |
&w.first_ptr_addr ds a                |
&w.final_ptr_addr ds a                |
&w.next_ptr_addr  ds a                |
&w.prior_ptr_addr ds a                |
&w.owner_ptr_addr ds a                |
         itc id=&w.itc_               |
         itc id=&w.itc_heads_         |
         itc id=&w.itc_wrk_           |
         endswa                       |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Connect_to_hash_table
*  Abstract:   This subroutine copys an item from item managed
*              storage to a return area that is not in item managed
*              storage.
*  Parameters: (>item_token,>descriptor_token)
*
*---------------------------------------------------------------------*
 block name=connect_to_hash_table,type=subroutine,                     +
               parms=(item_token,descriptor_token)
* *-------------------------------------------------------------------*
* *  Get item characteristics.
* *-------------------------------------------------------------------*
  l     r1,&p.item_token              | Move item token
  mvc   &w.itc_token,0(r1)            | to work area.
  la    r1,&w.itc_                    | Get item
  callsub get_itc                     | characteristics.
* *-------------------------------------------------------------------*
* *  Get base for descriptor.
* *-------------------------------------------------------------------*
  imlta r4,*&p.descriptor_token       |
  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token
  using htd,r4                        |
* *-------------------------------------------------------------------*
* * Get hash info.
* *-------------------------------------------------------------------*
  callsub get_hash_info,              |                                +
               (&w.itc_,htd,          |                                +
               &w.link_address)       |
* *-------------------------------------------------------------------*
* * >>>> Need to add code to check for duplicates.
* *-------------------------------------------------------------------*
* *-------------------------------------------------------------------*
* * Link item to table.
* *-------------------------------------------------------------------*
  l     r5,&w.link_address            | Point r5 to link in hash table.
  imlla r6,htdsylk#,&w.itc_           | Point r6 to synonym link.
  mvc   0(4,r6),0(r5)                 | Place item in front
  mvc   0(4,r5),&w.itc_token          | of synonym chain.
* *-------------------------------------------------------------------*
 endblk block=connect_to_hash_table   |
         swa ,                        |
&w.link_address   ds a                |
         itc id=&w.itc_               |
         endswa                       |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Disconnect_from_list
*  Abstract:   This subroutine disconnects an item form a linked
*              list.
*  Parameters: (>item_token,>descriptor_token,>head_token,>prev_token)
*
*---------------------------------------------------------------------*
 block name=disconnect_from_list,type=subroutine,                      +
               parms=(item_token,descriptor_token,head_token,          +
               prv_token)
* *-------------------------------------------------------------------*
* *  Get item characteristics.
* *-------------------------------------------------------------------*
  l     r1,&p.item_token              | Move item token
  mvc   &w.itc_token,0(r1)            | to work area.
  la    r1,&w.itc_                    | Get item
  callsub get_itc                     | characteristics.
* *-------------------------------------------------------------------*
* *  Get base for descriptor.
* *-------------------------------------------------------------------*
  imlta r4,*&p.descriptor_token       |
  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token
  using lld,r4                        |
* *-------------------------------------------------------------------*
* *  Get address of list heads.
* *-------------------------------------------------------------------*
  if (tbit,lldophid)                  | If heads in descriptor:
   la    r0,lldfrlst                  |  Use first pointer
   st    r0,&w.first_ptr_addr         |  in LLD.
   la    r0,lldfnlst                  |  Use final pointer
   st    r0,&w.final_ptr_addr         |  in LLD.
   errexit (%l32,r1,&p.head_token,nz),and,(clc,0(4,r1),ne,=f'0'),      +
               code=&im_head_not_valid_for_this_descriptor
  else                                | Else:
   if (%l32,r1,&p.head_token,nz),and, |  If head token supplied        +
               (%l32,r1,0(r1),nz)     |  by caller:
    st    r1,&w.itc_heads_token       |   Use it.
   else                               |  Else:
    callsub find_current,(lldhditd,&w.itc_heads_token) Find item
    errexit (treg,r15,nz),code=&im_currency_error      that has heads.
    errexit nz,code=&im_internal_error
   endif                              |  Endif.
   la    r1,&w.itc_heads_             |               Get ITC
   callsub get_itc                    |               for item.
   imlla &w.first_ptr_addr,lldfrlk#,&w.itc_heads_     Get links
   imlla &w.final_ptr_addr,lldfnlk#,&w.itc_heads_     from item.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* *  Destroy currency for list.
* *-------------------------------------------------------------------*
  callsub current,(*&p.descriptor_token,=f'0')
* *-------------------------------------------------------------------*
* *  Get addresses of links in item.
* *-------------------------------------------------------------------*
  imlla &w.next_ptr_addr,lldnxlk#,&w.itc_   Get address
  imlla &w.prior_ptr_addr,lldprlk#,&w.itc_  of links in
  imlla &w.owner_ptr_addr,lldowlk#,&w.itc_  item.
* *-------------------------------------------------------------------*
* *  Load address of first and next links.
* *-------------------------------------------------------------------*
  l32   r5,&w.first_ptr_addr          | Point r5 to first link.
  errexit z,code=&im_internal_error   | Error if there is not one.
  l32   r6,&w.next_ptr_addr           | Point r6 to next link.
  errexit z,code=&im_internal_error   | Error if there is not one.
* *-------------------------------------------------------------------*
* * Process item at start of list.
* *-------------------------------------------------------------------*
  if (clc,&w.itc_token,eq,0(r5))      | If first item of list:
   errexit (%l32,r1,&p.prv_token,nz),and,                              +
               (clc,=f'0',ne,0(r1)),  |  Error if PRTKN specified and  +
               code=&im_prtkn_invalid |  it is not zero.
   mvc   0(4,r5),0(r6)                |  First link = Next link.
   if (clc,=f'0',eq,0(r6))            |  If Next link is null:
    if (%l32,r5,&w.final_ptr_addr,nz) |   If there is a final link:
     mvc   0(4,r5),0(r6)              |    Final link = Next link.
    endif                             |   Endif.
   else                               |  Else if there is a next:
    if (clc,=f'0',ne,lldprlk#)        |   If there are prior links:
     mvc   &w.itc_wrk_token,0(r6)     |    Get ITC
     la    r1,&w.itc_wrk_             |    for next
     callsub get_itc                  |    item in list.
     imlla r5,lldprlk#,&w.itc_wrk_    |    Set next's prior link
     mvc   0(4,r5),=f'0'              |    to null.
    endif                             |   Endif.
   endif                              |  Endif.
* *-------------------------------------------------------------------*
* * Process item at middle or end of list.
* *-------------------------------------------------------------------*
  else                                | Else:
   if (%l32,r1,&p.prv_token,z)        |  If PRTKN not specified:
    errexit (clc,=f'0',eq,lldprlk#),  |   Error if there are not       +
               code=&im_prtkn_required    Prior links.
    l32   r5,&w.prior_ptr_addr        |   Move prior token
    errexit z,code=&im_internal_error |   from item to
    mvc   &w.itc_wrk_token,0(r5)      |   work ITC.
   else                               |  Else if PRTKN specified:
    mvc   &w.itc_wrk_token,0(r1)      |   Move PRTKN to work ITC.
    errexit (%l32,r5,&w.prior_ptr_addr,nz),and,                        +
               (clc,0(4,r1),ne,0(r5)),    Error if PRTKN specified     +
               code=&im_prtkn_invalid |   doesn't match prior in item.
   endif                              |  Endif.
   la    r1,&w.itc_wrk_               |  Move item's
   callsub get_itc                    |  next pointer
   imlla r5,lldnxlk#,&w.itc_wrk_      |  to prior items
   mvc   0(4,r5),0(r6)                |  next pointer.
   if (clc,=f'0',eq,0(r6))            |  If at end of list:
    if (%l32,r5,&w.final_ptr_addr,nz) |   Update final
     mvc   0(4,r5),&w.itc_wrk_token   |   link if there
    endif                             |   is one.
   elseif (clc,=f'0',ne,lldprlk#)     |  Else if there are prior links:
    l     r5,&w.itc_wrk_token         |   Save prior token in r5.
    mvc   &w.itc_wrk_token,0(r6)      |   Get ITC
    la    r1,&w.itc_wrk_              |   for next
    callsub get_itc                   |   item.
    imlla r6,lldprlk#,&w.itc_wrk_     |   Store prior token in
    st    r5,0(,r6)                   |   prior link of next item.
   endif                              |  Endif.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Set links in disconnected item to null.
* *-------------------------------------------------------------------*
  if (%l32,r5,&w.next_ptr_addr,nz)    | If there is a next link:
   xc    0(4,r5),0(r5)                |  Set it to null.
  endif                               | Endif.
  if (%l32,r5,&w.prior_ptr_addr,nz)   | If there is a prior link:
   xc    0(4,r5),0(r5)                |  Set it to null.
  endif                               | Endif.
  if (%l32,r5,&w.owner_ptr_addr,nz)   | If there is an owner link:
   xc    0(4,r5),0(r5)                |  Set it to null.
  endif                               | Endif.
* *-------------------------------------------------------------------*
 endblk block=disconnect_from_list    |
         swa ,                        |
&w.first_ptr_addr ds a                |
&w.final_ptr_addr ds a                |
&w.next_ptr_addr  ds a                |
&w.prior_ptr_addr ds a                |
&w.owner_ptr_addr ds a                |
&w.prior_token    ds f                |
         itc id=&w.itc_               |
         itc id=&w.itc_heads_         |
         itc id=&w.itc_wrk_           |
         endswa                       |
         eject
*---------------------------------------------------------------------*
*
*  Subroutine: Find_in_hash_table
*  Abstract:   This subroutine locates an item by key in a hash table.
*  Parameters: (>key_length,>key_address,>descriptor_token,<itc)
*
*---------------------------------------------------------------------*
 block name=find_in_hash_table,type=subroutine,                        +
               parms=(key_length,key_address,descriptor_token,itc)
* *-------------------------------------------------------------------*
* *  Get bases.
* *-------------------------------------------------------------------*
  l     r3,&p.itc                     | Load base for ITC.
  using itc_,r3                       | Establish addressibility.
  imlta r4,*&p.descriptor_token       |
  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token
  using htd,r4                        |
* *-------------------------------------------------------------------*
* * Get hash info and calculate address of link field.
* *-------------------------------------------------------------------*
  l     r15,htd#lnks                  | Calculate
  sh    r15,=y(htdtable_link_#)       | number of entries
  st    r15,&w.entries                | in hash table.
  callsub calc_hash_key,              | Calculate hash key.            +
               (*&p.key_address,      |                                +
               *&p.key_length,        |                                +
               &w.entries,            |                                +
               &w.hash_key)           |
  l     r5,&w.hash_key                | Calculate
  sla   r5,2                          | address of
  la    r5,htdtable(r5)               | link in hash table.
  errexit (clc,=f'0',eq,0(r5)),       | Not found if link              +
               code=&im_not_found     | is zero.
  mvc   &w.kpm_first_token,0(r5)      | Save first link token.
* *-------------------------------------------------------------------*
* * Search for item in synonym chain with key matching search key.
* *-------------------------------------------------------------------*
  mvc   &w.kpm_search_key_address,&p.key_address
  errexit code=&im_key_length_parm_error,                              +
               (%l32,r1,&p.key_length,z),or,                           +
               (%l32,r1,0(r1),z),or,  | Key length is required and     +
               (ch,r1,gt,=h'255')     | must not exceed 255 bytes.
  stc   r1,&w.kpm_search_key_length   | Save key in KPM.
  if (tbit,htdf1ksi)                  | If key length in item:
   mvi   &w.kpm_key_length,0          |    Set the offset.
   mvc   &w.kpm_key_length_offset,htdkszof
  else                                | Else:
   fill  &w.kpm_key_length_offset,x'00'    Set key length.
   mvc   &w.kpm_key_length,htdksz+3   |
  endif                               | Endif.
  mvc   &w.kpm_key_offset,htdkof      | Set offset. (may be zero)
  mvc   &w.kpm_link_number,htdsylk#   | Move link number from IMMS.
  callsub find_by_key,(&w.kpm_,itc_)  | Find item.
  errexit (treg,r15,nz),code=&im_not_found Error if not found.
* *-------------------------------------------------------------------*
 endblk block=find_in_hash_table      |
         swa ,                        |
&w.entries        ds f                |
&w.hash_key       ds f                |
&w.token          ds f                |
&w.link_number    ds f                |
         kpm id=&w.kpm_               |
         endswa                       |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Find_by_key.
*  Abstract:   This subroutine locates an item by key.
*  Parameters: (>kpm,<itc)
*
*---------------------------------------------------------------------*
 block name=find_by_key,type=subroutine,                               +
               parms=(kpm,itc)        |
* *-------------------------------------------------------------------*
* * Establish base for key parm.
* *-------------------------------------------------------------------*
  l     r2,&p.itc                     | Establish base
  using itc_,r2                       | for ITC.
  l     r3,&p.kpm                     | Establish base
  using kpm_,r3                       | for KPM.
  fill  itc_storage,x'00'             | Clear ITC.
* *-------------------------------------------------------------------*
* * Move key to work area and reduce size by number of trailing
* * blanks.
* *-------------------------------------------------------------------*
  fill  &w.key_work_area,x'40'        | Fill work area with spaces.
  l     r14,kpm_search_key_address    | Point r14 to search key.
  l8    r15,kpm_search_key_length     | Load r15 with search key size.
  bctr  r15,0                         | Move search key to work area.
  exi   r15,(mvc,&w.key_work_area(*-*),0(r14))
  la    r15,1(,r15)                   |
  loop bct                            | Trim off
   la    r1,&w.key_work_area-1(r15)   | trailing
   leave loop=*,(cli,0(r1),ne,x'40')  | blanks.
  endloop bct,r15                     |
  stc   r15,&w.key_size               | Save trimmed size.
* *-------------------------------------------------------------------*
* * Search for item in chain with correct key.
* *-------------------------------------------------------------------*
  l32   r15,kpm_first_token           | Point r15 to first in chain.
  loop until                          | Search for correct item:
   if (treg,r15,z)                    |  If at end of chain:
    la    r15,4                       |   Indicate item not found.
    leave block=*                     |   Leave subroutine.
   endif                              |  Endif.
   st    r15,itc_token                |  Save token in ITC.
   imlta r1,r15                       |  Get address
   st    r1,itc_address               |  of item.
   errexit (treg,r15,nz),code=&im_invalid_token
   lr    r4,r1                        |  Point r4 to item.
   if (tbit,itc_f,itc_f_variable_links_offset),or,                  @C1+
               (clc,itc_itype,ne,0(r4))  If characteristics for     @C1
    la      r1,itc_                   |    prior item are not close @C1
    callsub get_itc                   |    enough, call get ITC.    @C1
   elseif (tbit,itc_f_variable_size)  |  ElseIf variable item size  @C1
    l     r14,itc_itd_address         |   Get ITD address.          @C1
    using itd,r14                     |   Establish base for ITD.   @C1
    l32   r1,itdxilnof                |   Load offset of length.    @C1
    errexit z,code=&im_internal_error |   Error if zero.            @C1
    slr   r0,r0                       |   Clear result register.    @C1
    al    r1,itc_address              |   Calculate addr of length. @C1
    icm   r14,b'1000',itdxilnsz       |   r14 := size of length.    @C1
    srl   r14,24                      |                             @C1
    drop  r14                         |   Drop ITD.                 @C1
    caseblk reg=r14                   |   Process based on size.    @C1
    case 1                            |   One byte:                 @C1
     ic   r0,0(,r1)                   |    Load one byte length.    @C1
    case 2                            |   Two bytes:                @C1
     icm  r0,b'0011',0(r1)            |    Load two byte length.    @C1
    case 3                            |   Three bytes:              @C1
     icm  r0,b'0111',0(r1)            |    Load three byte length.  @C1
    case 4                            |   Four bytes:               @C1
     l    r0,0(r1)                    |    Load four byte length.   @C1
    case other                        |   Other size:               @C1
     errexit code=&im_internal_error  |    This is bad news.        @C1
    endcase                           |   Endcase.                  @C1
    st    r0,itc_size                 |   Save size in ITC.         @C1
   endif                              |  EndIf.                     @C1
   l8    r1,kpm_key_length            |  Get static key length.
   if z                               |  If it is zero:
    l     r8,itc_address              |   Get key
    al    r8,kpm_key_length_offset    |   length
    l8    r1,0(r8)                    |   from item.
    errexit z,code=&im_invalid_item   |   Error if it is zero.
   endif                              |  Endif.
   if (clm,r1,b'0001',ge,&w.key_size) |  If key in item not to small:
    l     r4,itc_address              |   Point r4
    al    r4,kpm_key_offset           |   to key in item.
    bctr  r1,0                        |   Compare key in item
    exi   r1,(clc,&w.key_work_area(*-*),0(r4))    and search key.
    if eq                             |   If they match:
     sr    r15,r15                    |    The correct item
     leave block=*                    |    is found.
    endif                             |   Endif.
   endif                              |  Endif.
   imlla r4,kpm_link_number,itc_      |  Point to next
   l     r15,0(,r4)                   |  item in chain.
  endloop until,leave                 | End of search.
* *-------------------------------------------------------------------*
 endblk block=find_by_key             |
         swa ,                        |
&w.key_size       ds x                |
&w.key_work_area  ds cl256            |
         endswa                       |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Get_hash_info.
*  Abstract:   This subroutine applies the hash function to the key
*              of an item and returns the address of the link field
*              in the HTD.
*  Parameters: (>itc,>htd,<link_address)
*
*---------------------------------------------------------------------*
 block name=get_hash_info,type=subroutine,                             +
               parms=(itc,htd,link_address)
* *-------------------------------------------------------------------*
* *  Load bases.
* *-------------------------------------------------------------------*
  l     r3,&p.itc                     | Point r3 to ITC and
  using itc_,r3                       | establish addressibility.
  l     r4,&p.htd                     | Point r4 to HTD and
  using htd,r4                        | establish addressibility.
* *-------------------------------------------------------------------*
* *  Move key from IMMS to work area.
* *-------------------------------------------------------------------*
  l     r5,htdkof                     | Calculate address
  al    r5,itc_address                | of key.
  fill  pwa_key_work_area,x'40'       | Initialize work area to spaces.
  imlks r15,itc_,htd                  | Load key size.
  st    r15,&w.key_size               | Save key size.
  bctr  r15,0                         | Move key to work area.
  exi   r15,(mvc,pwa_key_work_area(*-*),0(r5))
* *-------------------------------------------------------------------*
* *  Calculate hash key.
* *-------------------------------------------------------------------*
  l     r15,htd#lnks                  | Calculate
  sh    r15,=y(htdtable_link_#)       | number of entries
  st    r15,&w.entries                | in hash table.
  callsub calc_hash_key,              | Calculate hash key.            +
               (pwa_key_work_area,    |                                +
               &w.key_size,           |                                +
               &w.entries,            |                                +
               &w.hash_key)           |
* *-------------------------------------------------------------------*
* *  Calculate link address and return it to caller.
* *-------------------------------------------------------------------*
  l     r15,&w.hash_key               | Calculate
  sla   r15,2                         | address of
  la    r15,htdtable(r15)             | link in hash table.
  l     r1,&p.link_address            | Pass back this
  st    r15,0(,r1)                    | address to caller.
* *-------------------------------------------------------------------*
 endblk block=get_hash_info           |
         swa ,                        |
&w.key_size   ds f                    |
&w.entries    ds f                    |
&w.hash_key   ds f                    |
         endswa ,                     |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Calc_hash_key.
*  Abstract:   This subroutine calculates a hash key.
*  Parameters: (>key,>key_length,>entries,<hash_key)
*
*---------------------------------------------------------------------*
 block name=calc_hash_key,type=subroutine,                             +
               parms=(key,key_length,entries,hash_key)
* *-------------------------------------------------------------------*
* *  Apply hashing function to key.
* *-------------------------------------------------------------------*
  l     r3,&p.key                     | Point r3 to key.
  l     r1,&p.key_length              | Load r15
  l     r15,0(,r1)                    | with length.
.newway  anop
  xr    r1,r1                         | Clear accumulator.
  loop until                          | Process in groups of 9 chars:
   if (ch,r15,ge,=h'9')               |  If length >= 9:
    mvc   &w.work,0(r3)               |   Move 9 bytes to work area.
    la    r3,9(,r3)                   |   Point past bytes moved.
    sh    r15,=h'9'                   |   Decrement remaining length.
   else                               |  Else if length < 9:
    la    r2,9                        |   Move
    sr    r2,r15                      |   bytes
    la    r14,&w.work(r2)             |   right
    bctr  r15,0                       |   justified
    exi   r15,(mvc,0(*-*,r14),0(r3))  |   to work area.
    bctr  r2,0                        |   Clear unused
    exi   r2,(xc,&w.work(*-*),&w.work)    bytes.
    xr    r15,r15                     |   Set remaining to zero.
   endif                              |  Endif.
   oc    &w.work,=x'f0f0f0f0f0f0f0f0f0'  Set all zones to F's.
   tr    &w.work,psd_0123456789147036 |  Translate invalid's to some-
   pack  &w.d,&w.work                 |  thing else and pack.
   cvb   r0,&w.d                      |  Convert number to binary.
   alr   r1,r0                        |  Add to accumulator.
  endloop until,(treg,r15,np)         | End loop if all processed.
  ago   .pastold                      |
.oldway  anop                         |
  slr   r0,r0                         | Clear work
  slr   r1,r1                         | registers.
  ic    r0,=x'40'                     | Insert a space into r0.
  bctr  r3,0                          | Reduce
  loop bct                            | length
   ic    r1,0(r15,r3)                 | by number
   leave loop=*,(clr,r1,ne,r0)        | of
  endloop bct,r15                     | trailing
  la    r3,1(,r3)                     | spaces.
  slr   r0,r0                         | Clear work
  slr   r1,r1                         | registers.
  loop until                          | Fold key:
   if (ch,r15,ge,=h'3')               |  If at least 3 bytes left:
    icm   r0,b'0111',0(r3)            |   Add three bytes to
    alr   r1,r0                       |   accumulated value.
    la    r3,3(,r3)                   |   Point to next 3 bytes.
    sh    r15,=h'3'                   |   Drop length by 3.
   else                               |  Else if less than 3 bytes.
    if (ch,r15,eq,=h'1')              |   If one:
     slr   r0,r0                      |    Just
     ic    r0,0(r3)                   |    add that
     alr   r1,r0                      |    one.
    elseif (ch,r15,eq,=h'2')          |   If two:
     slr   r0,r0                      |    Add
     icm   r0,b'0011',0(r3)           |    last two
     alr   r1,r0                      |    bytes.
    endif                             |   If zero: nothing to do.
    leave loop=*                      |   Loop is complete.
   endif                              |  Endif.
  endloop until,leave                 | Endloop.
.pastold anop
  l     r15,&p.entries                | Load number of
  l     r15,0(,r15)                   | entries in hash table.
  lpr   r1,r1                         | Make sure result will be >= 0.
  slr   r0,r0                         | Divide this number
  dr    r0,r15                        | into accumulated value.
*                                     | Remainder is hash key.
  l     r1,&p.hash_key                | Pass back hash
  st    r0,0(,r1)                     | key to caller.
* *-------------------------------------------------------------------*
 endblk block=calc_hash_key           |
         swa                          |
&w.d     ds    d                      |
&w.work  ds    cl9                    |
         endswa                       |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Sort_a_list.
*  Abstract:   This subroutine sorts a list.
*  Parameters: (>descriptor,>fieldslist,>head_token,>sort_technique)
*
*---------------------------------------------------------------------*
 block name=sort_a_list,type=subroutine,                               +
               parms=(descriptor_token,sfd,head_token,technique)
* *-------------------------------------------------------------------*
* *  Get base for descriptor.
* *-------------------------------------------------------------------*
  imlta r4,*&p.descriptor_token       | Get address of descriptor.
  errexit nz,or,(treg,r4,z),code=&im_invalid_descriptor_token
  using lld,r4                        | Establish base for descriptor.
* *-------------------------------------------------------------------*
* *  Get address of list heads.
* *-------------------------------------------------------------------*
  if (tbit,lldophid)                  | If heads in descriptor:
   la    r0,lldfrlst                  |  Use first pointer
   st    r0,&w.first_ptr_addr         |  in LLD.
   la    r0,lldfnlst                  |  Use final pointer
   st    r0,&w.final_ptr_addr         |  in LLD.
   errexit (%l32,r1,&p.head_token,nz),and,(clc,0(4,r1),ne,=f'0'),      +
               code=&im_head_not_valid_for_this_descriptor
  else                                | Else:
   if (%l32,r1,&p.head_token,nz),and, |  If head token supplied        +
               (%l32,r1,0(r1),nz)     |  by caller:
    st    r1,&w.itc_token             |   Use it.
   else                               |  Else:
    callsub find_current,(lldhditd,&w.itc_token)  Find item
    errexit (treg,r15,nz),code=&im_currency_error that has heads.
    errexit nz,code=&im_internal_error
   endif                              |  Endif.
   la    r1,&w.itc_                   |               Get ITC
   callsub get_itc                    |               for item.
   imlla &w.first_ptr_addr,lldfrlk#,&w.itc_           Get links
   imlla &w.final_ptr_addr,lldfnlk#,&w.itc_           from item.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Calculate offset of next and prior links within links.
* *-------------------------------------------------------------------*
  l     r1,lldnxlk#                   | Load number of next link.
  sh    r1,=h'1'                      | Sub 1.
  errexit m,code=&im_internal_error   | Bad news in negative.
  sla   r1,2                          | Multiply number by 4.
  st    r1,&w.next_link_offset_in_links Save result.
  l     r1,lldprlk#                   | Load number of prior link.
  sh    r1,=h'1'                      | Sub 1.
  sla   r1,2                          | Multiply number by 4.
  st    r1,&w.prior_link_offset_in_links Save result.
* *-------------------------------------------------------------------*
* * Save some information for the SFD and take a shoot at making
* * sure that it is valid.  Calculate how much storage will be
* * required for generated compare code.
* *-------------------------------------------------------------------*
  fill  &w.size_of_compare_code,x'00' | Set compare code size to zero.
  l     r3,&p.sfd                     | Establish base for
  using sfd_start,r3                  | Sort Fields Definition.
  l32   r0,sfd_elements_in_array      | Save number
  errexit code=&im_invalid_sfd,np     | of fields
  st    r0,&w.elements_in_array       | in SWA.
  la    r1,sfd_array_start            | Save address of first
  st    r1,&w.array_start             | SFD element in SWA.
  drop  r3                            | Drop base for SFD.
  l     r2,&w.elements_in_array       | Load r2 with # sort fields.
  l     r3,&w.array_start             | Point r3 to first element.
  using sfd_element,r3                | Establish base for element.
  loop  bct                           | Process each sort field:
   lh    r1,sfd_type                  |  Process based on
   errexit code=&im_invalid_sfd,      |  Don't support offsets > 4095. +
               (clc,sfd_offset,gt,=f'4095')
   caseblk reg=r1                     |  type of field.
   case  &im_sfd_type_character
    errexit code=&im_invalid_sfd,(clc,sfd_length,gt,=f'256')
    l     r15,&w.size_of_compare_code |   Increase
    la    r15,&s.size_for_character+&s.b_sequence_l(,r15) size of
    st    r15,&w.size_of_compare_code |   compare code.
   case  &im_sfd_type_packed
    errexit code=&im_invalid_sfd,(clc,sfd_length,gt,=f'16')
    l     r15,&w.size_of_compare_code |   Increase
    la    r15,&s.size_for_packed+&s.b_sequence_l(,r15) size of
    st    r15,&w.size_of_compare_code |   compare code.
   case  &im_sfd_type_zoned
    errexit code=&im_invalid_sfd,(clc,sfd_length,gt,=f'16')
    l     r15,&w.size_of_compare_code |   Increase
    la    r15,&s.size_for_zoned+&s.b_sequence_l(,r15) size of
    st    r15,&w.size_of_compare_code |   compare code.
   case  &im_sfd_type_fixed
    errexit code=&im_invalid_sfd,(clc,sfd_length,ne,=f'2'),and,        +
               (clc,sfd_length,ne,=f'4')
    l     r15,&w.size_of_compare_code |   Increase
    la    r15,&s.size_for_fixed+&s.b_sequence_l(,r15) | size of
    st    r15,&w.size_of_compare_code |   compare code.
   case  &im_sfd_type_bit
    l     r15,&w.size_of_compare_code |   Increase
    la    r15,&s.size_for_bit+&s.b_sequence_l(,r15) | size of
    st    r15,&w.size_of_compare_code |   compare code.
   case  other                        |  Other cases.
    errexit code=&im_invalid_sfd      |   Invalid SFD.
   endcase                            |  Endcase.
   la    r3,sfd_size_element(,r3)     |  Point to next element.
  endloop bct,r2                      | Endloop.
  drop  r3                            | Drop base for SFD element.
* *-------------------------------------------------------------------*
* * Get storage for generated compare code and build it.
* *-------------------------------------------------------------------*
  mm_obtain_storage id=mm,            | Get storage for code.          +
               address=&w.address_of_compare_code,                     +
               size=&w.size_of_compare_code
  if (treg,r15,nz)                    | If obtain failed:
   errexit (ch,r15,eq,=y(&mm_storage_not_available)),                  +
               code=&im_storage_not_available   Fail with appropriate
   errexit code=&im_internal_error    |         error code.
  endif                               | Endif.
  l     r2,&w.elements_in_array       | Load r2 with # sort fields.
  l     r3,&w.array_start             | Point r3 to first element.
  l     r14,&w.address_of_compare_code  Point r14 to build area.
  using sfd_element,r3                | Establish base for element.
  loop  bct                           | Process each sort field:
   lh    r1,sfd_type                  |  Process based on
   errexit code=&im_invalid_sfd,      |  Don't support offsets > 4095. +
               (clc,sfd_offset,gt,=f'4095')
   caseblk reg=r1,wreg=r15            |  type of field.
   case  &im_sfd_type_character       |
*   *-----------------------------------------------------------------*
*   * For character, generate a CLC instruction.
*   *
*   *  +0 CLC  offset(length,r5),offset(R6)
*   *
*   *-----------------------------------------------------------------*
    mvi   0(r14),x'D5'                |   Move opcode for CLC.
    l     r0,sfd_length               |   Set length in
    sh    r0,=h'1'                    |   CLC instruction
    stc   r0,1(,r14)                  |   to compare length - 1.
    l     r0,sfd_offset               |   Op1 is the base displacement
    o     r0,&s.base_current          |   of field in the
    sth   r0,2(,r14)                  |   current item.
    l     r0,sfd_offset               |   Op2 is the base displacement
    o     r0,&s.base_next             |   of field in the
    sth   r0,4(,r14)                  |   next item.
&s.size_for_character equ 6           |   Size of this code.
    la    r14,&s.size_for_character(,r14) Point r14 past this code.
   case  &im_sfd_type_packed          |
*   *-----------------------------------------------------------------*
*   * For packed, generate a CP instruction.
*   *
*   *  +0 CP   offset(length,r5),offset(length,R6)
*   *
*   *-----------------------------------------------------------------*
    mvi   0(r14),x'F9'                |   Move opcode for CP.
    l     r1,sfd_length               |   Set LL1
    bctr  r1,0                        |   and
    lr    r0,r1                       |   LL2
    sll   r0,4                        |   in CP
    or    r0,r1                       |   instruction
    stc   r0,1(,r14)                  |   to length - 1.
    l     r0,sfd_offset               |   Op1 is the base displacement
    o     r0,&s.base_current          |   of field in the
    sth   r0,2(,r14)                  |   current item.
    l     r0,sfd_offset               |   Op2 is the base displacement
    o     r0,&s.base_next             |   of field in the
    sth   r0,4(,r14)                  |   next item.
&s.size_for_packed    equ 6           |   Size of this code.
    la    r14,&s.size_for_packed(,r14)    Point r14 past this code.
   case  &im_sfd_type_zoned           |
*   *-----------------------------------------------------------------*
*   * For zoned, generate two PACKs and a CP instruction.
*   *
*   *  +0 PACK  0(length/2+1,R2),offset(length,R5)
*   *  +6 PACK  8(length/2+1,R2),offset(length,R6)
*   *  +C CP    0(length/2+1,R2),8(length/2+1,r2)
*   *
*   *-----------------------------------------------------------------*
    mvi   0(r14),x'F2'                |   Move opcode for PACK.
    l     r1,sfd_length               |   Set
    sra   r1,1                        |   LL1 to
    la    r1,1(,r1)                   |   length/2+1
    sll   r1,4                        |   and
    o     r1,sfd_length               |   LL2 to
    stc   r1,1(,r14)                  |   length.
    lr    r0,r1                       |   Save LL1/LL2 for later.
    mvc   2(2,r14),=s(0(r2))          |   Op1 is work field 1.
    l     r1,sfd_offset               |   Op2 is the base displacement
    o     r1,&s.base_current          |   of field in the
    sth   r1,4(,r14)                  |   current item.
    mvi   6(r14),x'F2'                |   Move opcode for PACK.
    stc   r0,7(,r14)                  |   Set LL1/LL2 the same.
    mvc   8(2,r14),=s(8(r2))          |   Op1 is work field 1.
    l     r1,sfd_offset               |   Op2 is the base displacement
    o     r1,&s.base_next             |   of field in the
    sth   r1,10(,r14)                 |   next item.
    mvi   12(r14),x'F9'               |   Move opcode for CP.
    sra   r0,4                        |   LL1 and
    lr    r1,r0                       |   LL2
    sla   r0,4                        |   are
    or    r0,r1                       |   both
    stc   r0,13(,r14)                 |   length/2+1.
    mvc   14(4,r14),=s(0(r2),8(r2))   |   OP2 and OP2 are work fields.
&s.size_for_zoned     equ 6+6+6       |   Size of this code.
    la    r14,&s.size_for_zoned(,r14) |   Point r14 past this code.
   case  &im_sfd_type_fixed           |
*   *-----------------------------------------------------------------*
*   * For fixed, generate a load and compare.
*   *
*   *  +0 L{H}  R0,mask_based_on_length,offset_in_item(R5)
*   *  +4 C{H}  R0,mask_based_on_length,offset_in_item(R6)
*   *
*   *-----------------------------------------------------------------*
    l     r1,sfd_length               |   Load mask
    if (ch,r1,eq,=h'2')               |   If halfword lengths:
     mvi   0(r14),x'48'               |    Use LH and
     mvi   4(r14),x'49'               |    CH instructions.
    else                              |   Else, must be fullword:
     mvi   0(r14),x'58'               |    Use L and
     mvi   4(r14),x'59'               |    C instructions.
    endif                             |   Endif.
    mvi   1(r14),0                    |   Load into register zero.
    l     r1,sfd_offset               |   Base displacement
    o     r1,&s.base_current          |   of field in the
    sth   r1,2(,r14)                  |   current item.
    mvi   5(r14),0                    |   Compare to register zero.
    l     r1,sfd_offset               |   Base displacement
    o     r1,&s.base_next             |   of field in the
    sth   r1,6(,r14)                  |   next item.
&s.size_for_fixed     equ 4+4         |   Size of this code.
    la    r14,&s.size_for_fixed(,r14) |   Point r14 past this code.
   case  &im_sfd_type_bit             |
*   *-----------------------------------------------------------------*
*   *
*   * For bit, generate code to compare bits within a byte.  The
*   * mask specified in the SFD can have multiple bits turned on.
*   *
*   * Generate code that performs the comparison by loading each value
*   * into a register, masking off unwanted bits, comparing values.
*   *
*   *  0  4140 00mm       LA    r1,x'mask'(0,0)
*   *  4  5010 Dxxx       ST    r1,pwa_bit_mask
*   *  8  4300 5ddd       IC    r0,offset_in_item(,r5)
*   *  C  4310 6ddd       IC    r1,offset_in_item(,r6)
*   * 10  5400 Dxxx       N     r0,pwa_bit_mask
*   * 14  5410 Dxxx       N     r1,pwa_bit_mask
*   * 18  1901            CR    r0,r1
*   *
*   *-----------------------------------------------------------------*
    mvc   x'00'(4,r14),=x'41100000'    +0   "LA r1,mask"
    oc    x'03'(1,r14),sfd_mask+3
    mvc   x'04'(4,r14),=x'5010D000'    +4   "ST r1,pwa_bit_mask"
    oc    x'06'(2,r14),=s(pwa_bit_mask)
    mvc   x'08'(2,r14),=x'4300'        +8   "IC R0,xxx(0,rx)"
    l     r1,sfd_offset                       BaseReg and Displacement
    o     r1,&s.base_current                  of field in the
    sth   r1,x'0A'(,r14)                      current item.
    mvc   x'0C'(2,r14),=x'4310'        +C   "IC R1,xxx(0,rx)"
    l     r1,sfd_offset                      BaseReg and Displacement
    o     r1,&s.base_next                    of field in the
    sth   r1,x'0E'(,r14)                     next item.
    mvc   x'10'(4,r14),=x'5400D000'   +10   "N r0,pwa_bit_mask"
    oc    x'12'(2,r14),=s(pwa_bit_mask)
    mvc   x'14'(4,r14),=x'5410D000'   +14   "N r1,pwa_bit_mask"
    oc    x'16'(2,r14),=s(pwa_bit_mask)
    mvc   x'18'(2,r14),=x'1901'       +18   "CR r0,r1".
*
&s.size_for_bit  equ 4+4+4+4+4+4+2        Size of this code.
    la    r14,&s.size_for_bit(,r14)   |   Point r14 past this code.
*   *-----------------------------------------------------------------*
   endcase                            |  Endcase.
*  *------------------------------------------------------------------*
*  * Generate a BHR-BLR sequence.
*  *------------------------------------------------------------------*
   if (tbit,sfd_f_descending)         |  If descending:
    mvc   0(&s.b_sequence_l,r14),&s.b_descending
   else                               |  Else:
    mvc   0(&s.b_sequence_l,r14),&s.b_ascending
   endif                              |  Endif.
   la    r14,&s.b_sequence_l(,r14)    |  Point r14 past this code.
*  *------------------------------------------------------------------*
*  * Point to next element and continue.
*  *------------------------------------------------------------------*
   la    r3,sfd_size_element(,r3)     |  Point to next element.
  endloop bct,r2                      | Endloop.
* *-------------------------------------------------------------------*
* *  Change last BHR R3 or BLR R3 to a BR R3.
* *-------------------------------------------------------------------*
  sh    r14,=y(&s.b_last_l)           | Patch last branch
  mvc   0(&s.b_last_l,r14),&s.b_last  | to be a BR R3.
  drop  r3                            | Drop base for SFD element.
* *-------------------------------------------------------------------*
* * Sort list based on technique.
* *-------------------------------------------------------------------*
  plist (*&w.address_of_compare_code, | Build parameter                +
               *&w.first_ptr_addr,    | list for sort                  +
               *&w.final_ptr_addr,    | routines.                      +
               *&w.next_link_offset_in_links,                          +
               *&w.prior_link_offset_in_links)
  if (%l32,r2,&p.technique,z),or,     | If this is a Quicksort:        +
               (%l32,r2,0(r2),z),or,  |  (that's the default)          +
               (ch,r2,eq,=y(&im_sort_technique_quick_sort))
   callsub Quicksort                  |  Do partition-exchange sort.
  elseif (ch,r2,eq,=y(&im_sort_technique_bubble_sort))
   callsub bubble_sort                | Else if bubble sort: do it.
  else                                | Else if invalid technique:
   errexit code=&im_invalid_sort_technique  Fail.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Release compare code storage.
* *-------------------------------------------------------------------*
  mm_release_storage id=mm,           | Release storage for code.      +
               address=&w.address_of_compare_code,                     +
               size=&w.size_of_compare_code
  errexit (treg,r15,nz),code=&im_internal_error
* *-------------------------------------------------------------------*
 endblk block=sort_a_list             |
         ssd ,                        |
&s.masks equ   *-1                    | Insert character
         dc    al1(1,3,7,15)          | masks.
&s.b_ascending    bhr  r14            |
                  blr  r3             |
&s.b_ascending_l  equ  *-&s.b_ascending
&s.b_descending   blr  r14            |
                  bhr  r3             |
&s.b_descending_l equ  *-&s.b_descending
&s.b_sequence_l   equ  &s.b_descending_l
&s.b_last         br   r3             |
&s.b_last_l       equ  *-&s.b_last    |
&s.base_current dc   a(x'00005000')   |
&s.base_next    dc   a(x'00006000')   |
         endssd ,                     |
         swa ,                        |
&w.size_of_compare_code       ds f    |
&w.address_of_compare_code    ds a    |
&w.elements_in_array          ds f    |
&w.array_start                ds a    |
&w.first_ptr_addr             ds a    |
&w.final_ptr_addr             ds a    |
&w.next_link_offset_in_links  ds a    |
&w.prior_link_offset_in_links ds a    |
         itc id=&w.itc_               |
         endswa                       |
         eject                        |
*---------------------------------------------------------------------*
*
*  Subroutine: Bubble_sort
*  Abstract:   This subroutine sorts a list using bubble sort.
*
*---------------------------------------------------------------------*
 block name=bubble_sort,type=subroutine,                               +
               parms=(compare_code,first_ptr_addr,final_ptr_addr,      +
               next_link_offset_in_links,prior_link_offset_in_links)
* *-------------------------------------------------------------------*
* *  Reset flags in ITC.
* *-------------------------------------------------------------------*
  mvi   &w.itc_f,0                    | Reset flags in ITC.
* *-------------------------------------------------------------------*
* * Sort list.
* *-------------------------------------------------------------------*
  fill  &w.last_token,x'00'           |  Set last token to null.
  l     r5,&p.first_ptr_addr          |  If the list is
  if (%l32,r0,0(r5),nz)               |  not empty:
   loop  until                        |   Loop until sorted:
    l     r5,&p.first_ptr_addr        |    Set ITC token
    l     r0,0(,r5)                   |    to first item
    st    r0,&w.itc_token             |    in list.
    imlta r1,r0                       |    Get address
    st    r1,&w.itc_address           |    of first item.
    errexit (treg,r15,nz),code=&im_invalid_token
    lr    r6,r1                       |    Point r6 to item.
    if (tbit,&w.itc_f,&w.itc_f_variable_links_offset),or,              +
               (clc,&w.itc_itype,ne,0(r6)) If characteristics
     la    r1,&w.itc_                 |    for last item are
     callsub get_itc                  |    not close enough, call
    endif                             |    subroutine to get ITC.
    mvc   &w.end_token,&w.last_token  |    Set end token to last token.
    fill  &w.last_token,x'00'         |    Set last token to null.
    mvc   &w.prior_ptr_addr,&p.first_ptr_addr Prior is head link.
*   *-----------------------------------------------------------------*
*   * Make a pass of the list.
*   *-----------------------------------------------------------------*
    loop  until                       |   Start loop:
*    *----------------------------------------------------------------*
*    * Set new current item.
*    *----------------------------------------------------------------*
     mvc   &w.current_offset_links,&w.itc_offset_links
     mvc   &w.current_token,&w.itc_token   Set &w.current_..
     lr    r5,r6                      |    Point r5 to new current
*    *----------------------------------------------------------------*
*    * This pass is finished if next token is the same as the ending
*    * token.
*    *----------------------------------------------------------------*
     lr    r7,r5                      |    Calculate address
     a     r7,&w.current_offset_links |    of next link in
     a     r7,&p.next_link_offset_in_links current item.
     leave loop=*,(clc,&w.end_token,eq,0(r7)) Finished if next is end.
*    *----------------------------------------------------------------*
*    * Get characteristics for next item.
*    *----------------------------------------------------------------*
     l     r0,0(,r7)                  |    Set ITC token
     st    r0,&w.itc_token            |    to next item token.
     imlta r1,r0                      |    Get address of next item.
     errexit (treg,r15,nz),code=&im_invalid_token
     st    r1,&w.itc_address          |    Save address of next item.
     lr    r6,r1                      |    Point r6 to next item.
     if (tbit,&w.itc_f,&w.itc_f_variable_links_offset),or,             +
               (clc,&w.itc_itype,ne,0(r6)) If characteristics
      la    r1,&w.itc_                |    for last item are not
      callsub get_itc                 |    close enough, call get_itc
     endif                            |    subroutine.
*    *----------------------------------------------------------------*
*    * At this point, r5 has the address of current item and r6 has
*    * the address of the next item.  The compare code will return
*    * after the BASR if an exchange is required, otherwise it will
*    * go past the exchange code.
*    *----------------------------------------------------------------*
     la    r2,&w.work                 |    Point r2 to work area.
     sm_lal r3,past_exchange          |    Point r3 past exchange.
     l     r15,&p.compare_code        |    Point r15 to compare code.
     basr  r14,r15                    |    Call compare code.
     lr    r7,r5                      |    Calculate address
     a     r7,&w.current_offset_links |    of next link in
     a     r7,&p.next_link_offset_in_links current item.
     lr    r8,r6                      |    Calculate address
     a     r8,&w.itc_offset_links          of next link in
     a     r8,&p.next_link_offset_in_links next item.
     mvc   0(4,r7),0(r8)              |    Set next link of current
*                                     |    item to next link of
*                                     |    next item.
     mvc   0(4,r8),&w.current_token   |    Set next link of next
*                                     |    item to current token.
     mvc   &w.last_token,0(r8)        |    Also set last to curr tkn.
     l     r8,&w.prior_ptr_addr       |    If this exchange is for
     mvc   0(4,r8),&w.itc_token       |    Update prior next token.
     if (%l32,r8,&p.final_ptr_addr,nz),    If exchanging with last     +
               and,(clc,&w.itc_token,eq,0(r8)) item in list:
      mvc   0(4,r8),&w.current_token  |     Update token of last item.
     endif                            |    Endif.
     xr    r5,r6                      |    Exchange current
     xr    r5,r6                      |    and next item
     xr    r5,r6                      |    addresses.
past_exchange ds 0h                   |    End of exchange code.
*    *---------------------------------------------------------------*
     lr    r0,r5                      |    Calculate address
     a     r0,&w.current_offset_links |    of next link in
     a     r0,&p.next_link_offset_in_links current item.
     st    r0,&w.prior_ptr_addr       |    Save as prior link address.
    endloop until,leave               |   Endloop.
   endloop until,                     |  Endloop.                      +
               (clc,&w.last_token,eq,=f'0')
*  *------------------------------------------------------------------*
*  * If this list has prior pointer, update them.
*  *------------------------------------------------------------------*
   slr   r2,r2                        |  Clear prior token holder.
   l32   r3,&p.prior_link_offset_in_links
   if nm                              |  If there are prior links:
    l     r5,&p.first_ptr_addr        |   Load r0 with
    l     r0,0(,r5)                   |   token of first item.
    loop until                        |   Process all items in list:
     st    r0,&w.itc_token            |    Save token.
     imlta r5,r0                      |    Get address of item.
     errexit (treg,r15,nz),code=&im_invalid_token
     if (tbit,&w.itc_f,&w.itc_f_variable_links_offset),or,             +
               (clc,&w.itc_itype,ne,0(r6)) If characteristics
      la    r1,&w.itc_                |    for last item are not
      callsub get_itc                 |    close enough, call get_itc
     endif                            |    subroutine.
     lr    r6,r5                      |    Calculate address
     a     r6,&w.itc_offset_links     |    of prior link in
     ar    r6,r3                      |    the item.
     st    r2,0(,r6)                  |    Save prior item token.
     l     r2,&w.itc_token            |    Set new prior item token.
     a     r5,&w.itc_offset_links     |    Load token
     a     r5,&p.next_link_offset_in_links of next
     l32   r0,0(r5)                   |    item in list.
    endloop until,z                   |   Endloop.
   endif                              |  Endif.
*  *------------------------------------------------------------------*
  endif                               | Endif.
* *-------------------------------------------------------------------*
 endblk block=bubble_sort             |
         swa ,                        |
&w.work                       ds 2d   |
&w.prior_ptr_addr             ds a    |
&w.current_offset_links       ds f    |
&w.current_token              ds f    |
&w.end_token                  ds f    |
&w.last_token                 ds f    |
         itc id=&w.itc_               |
         endswa                       |
         eject                        |
*---------------------------------------------------------------------*
*
*  Subroutine: Quicksort
*  Abstract:   This subroutine sorts a list using Quicksort with
*              Richard C. Singleton's improvements.  See ACM
*              Algorithm 347 "An Efficient Algorithm For Sorting With
*              Minimal Storage {M1}" by Richard C. Singleton.
*
*---------------------------------------------------------------------*
 block name=Quicksort,type=subroutine,                                 +
               parms=(compare_code,first_ptr_addr,final_ptr_addr,      +
               next_link_offset_in_links,prior_link_offset_in_links)
* *-------------------------------------------------------------------*
* * Initialize SWA.
* *-------------------------------------------------------------------*
  fill  &w.itc_storage,x'00'          | Clear ITC.
  fill  &w.item_counter,x'00'         | Zero out item counter.
* *-------------------------------------------------------------------*
* * Run through list getting token and address.  Count entries in list.
* *-------------------------------------------------------------------*
  la    r3,&w.dummy_qsw_head          | Point r3 to dummy QSW head.
  using qsw_head,r3                   | Establish base for head.
  mvc   qsw_id,=cl4"QSWH"             | Set its id.
  fill  qsw_next,x'00'                | Clear next and
  fill  qsw_end,x'00'                 | end pointer.
  st    r3,&w.current_qsw_segment     | Set current segment to dummy.
  st    r3,&w.end_of_segment          | Make it look full.
  l     r1,&p.first_ptr_addr          | Load r0 with
  l32   r0,0(r1)                      | first token.
  leave z,block=*                     | Leave if list is empty.
  loop while,nz                       | Pass all items in list.
*  *------------------------------------------------------------------*
*  * Get characteristics of item.
*  *------------------------------------------------------------------*
   st    r0,&w.itc_token              |  Save item token.
   imlta r1,r0                        |  Get address
   st    r1,&w.itc_address            |  of first item.
   errexit (treg,r15,nz),code=&im_invalid_token
   lr    r4,r1                        |  Point r4 to item.
   if (tbit,&w.itc_f,&w.itc_f_variable_links_offset),or,               +
               (clc,&w.itc_itype,ne,0(r4)) If characteristics
    la    r1,&w.itc_                  |  for last item are
    callsub get_itc                   |  not close enough, call
   endif                              |  subroutine to get ITC.
*  *------------------------------------------------------------------*
*  * If there is not room for element in the current segment, get a
*  * new segment.
*  *------------------------------------------------------------------*
   la    r1,qsw_element_size(,r3)     |  Point past new element.
   if (c,r1,gt,&w.end_of_segment)     |  If this would be past segemnt.
    lr    r0,r3                       |   Save
    l     r3,&w.current_qsw_segment   |   end address
    using qsw_head,r3                 |   in segment
    st    r0,qsw_end                  |   head.
    es_obtain_storage id=es,          |   Get storage for another      +
               address=qsw_next,      |   segment.  Put address in     +
               size=&s.qsw_segment_size,  next pointer of              +
               subpool=&s.sp_qsw,     |   current                      +
               boundary=page          |   segment.
    if (treg,r15,nz)                  |   If obtain failed:
     errexit (ch,r15,eq,=y(&es_storage_not_available)),                +
               code=&im_storage_not_available   Fail with appropriate
     errexit code=&im_internal_error  |           error code.
    endif                             |   Endif.
    l     r3,qsw_next                 |   Point r3 to new head.
    st    r3,&w.current_qsw_segment   |   Set new current.
    l     r1,&s.qsw_segment_size      |   Set new
    st    r1,qsw_size                 |   end of
    ar    r1,r3                       |   segment
    st    r1,&w.end_of_segment        |   and qsw_size.
    mvc   qsw_id,=a(qsw_id_text)      |   Set id.
    fill  qsw_next,x'00'              |   Clear next
    fill  qsw_end,x'00'               |   and end pointer.
    la    r3,qsw_head_size(,r3)       |   Point to first element.
    using qsw_element,r3              |   Establish base for element.
   endif                              |  Endif.
*  *------------------------------------------------------------------*
*  * Update this QSW entry, increment counter, and adjust bases for
*  * next item.
*  *------------------------------------------------------------------*
   l     r0,&w.itc_token              |  Set token
   st    r0,qsw_token                 |  in QSW entry.
   st    r4,qsw_address               |  Set address in entry.
   l     r1,&w.item_counter           |  Increment
   la    r1,1(,r1)                    |  item
   st    r1,&w.item_counter           |  counter.
   la    r3,qsw_element_size(,r3)     |  Point past this QSW element.
   drop  r3                           |  Drop base for QSW element.
   a     r4,&w.itc_offset_links       |  Load token
   a     r4,&p.next_link_offset_in_links  of
   l32   r0,0(r4)                     |  next item in list.
*  *------------------------------------------------------------------*
  endloop while                       | Endloop.
  l     r1,&w.current_qsw_segment     | Update
  st    r3,qsw_end-qsw_head(,r1)      | end.
* *-------------------------------------------------------------------*
* * If there is more than one segment, consolidate all of them into
* * one large segment.
* *-------------------------------------------------------------------*
  l     r3,&w.first_qsw_head          | Point r3 to first QSW.
  using qsw_head,r3                   | Establish base.
  if (clc,qsw_next,eq,=f'0')          | If next pointer is zero:
   st    r3,&w.work_segment_address   |  Just use this segment
   mvc   &w.work_segment_size,qsw_size   as the work segment.
  else                                | Else if more than one segment.
   l     r1,&w.item_counter           |  Calculate size
   mh    r1,=y(qsw_element_size)      |  needed for
   la    r1,qsw_head_size(,r1)        |  one large
   st    r1,&w.work_segment_size      |  segment.
   es_obtain_storage id=es,           |  Get storage for large segment.+
               address=&w.work_segment_address,                        +
               size=&w.work_segment_size,                              +
               subpool=&s.sp_qsw,     |                                +
               boundary=page          |
   if (treg,r15,nz)                   |  If obtain failed:
    errexit (ch,r15,eq,=y(&es_storage_not_available)),                 +
               code=&im_storage_not_available   Fail with appropriate
    errexit code=&im_internal_error   |          error code.
   endif                              |  Endif.
   l     r3,&w.work_segment_address   |  Point r3 to large segment.
   xc    qsw_head(l'qsw_head),qsw_head   Clear head.
   mvc   qsw_id,=a(qsw_id_text)       |  Set id.
   l     r1,&w.work_segment_size      |  Set size
   st    r1,qsw_size                  |  in new QSW.
   ar    r1,r3                        |  Set end
   st    r1,qsw_end                   |  in new QSW.
   la    r2,qsw_head_size(,r3)        |  R2 is place to start building.
   l     r3,&w.first_qsw_head         |  Point r3 to first QSW.
   loop until                         |  Move to large segment:
    st    r3,&w.current_qsw_segment   |   Save source segment address.
    l     r0,qsw_next                 |   Save next QSW
    st    r0,&w.next_qsw              |   address.
    l     r15,qsw_end                 |   Calculate size
    la    r3,qsw_head_size(,r3)       |   and address for
    sr    r15,r3                      |   move from source QSW.
    loop  until                       |   Move it:
     if (ch,r15,lt,=h'256')           |    If <= 256 bytes to move:
      la    r0,0(r15,r2)              |     Save r2 + length.
      bctr  r15,0                     |     Use EXI
      exi   r15,(mvc,0(*-*,r2),0(r3)) |     to move
      sr    r15,r15                   |     last piece.
      lr    r2,r0                     |     Point r2 to next dest.
     else                             |    Else:
      mvc  0(256,r2),0(r3)            |     Move
      la   r2,256(,r2)                |     256
      la   r3,256(,r3)                |     bytes
      sh   r15,=h'256'                |     of source.
     endif                            |    Endif.
    endloop until,(treg,r15,z)        |   Endloop.
    l     r3,&w.current_qsw_segment   |   Point r3 to source QSW.
    es_release_storage id=es,         |   Release its storage.         +
               address=&w.current_qsw_segment,                         +
               size=qsw_size,         |                                +
               subpool=&s.sp_qsw      |
    errexit (treg,r15,nz),code=&im_internal_error
   endloop until,(%l32,r3,&w.next_qsw,z) Loop for all QSWs.
  endif                               | Endif.
  drop  r3                            | Drop base for QSW.
* *-------------------------------------------------------------------*
* * Get a work stack as big as will ever be needed.
* *-------------------------------------------------------------------*
  lh    r1,=y(31*qss_element_size)    | Good for 2 to the 32th
  st    r1,&w.qss_size                | (4,294,967,296) items.
  mm_obtain_storage id=mm,            | Get storage for stack.         +
               address=&w.qss_bottom, | (240 bytes)                    +
               size=&w.qss_size       |
  if (treg,r15,nz)                    | If obtain failed:
   errexit (ch,r15,eq,=y(&mm_storage_not_available)),                  +
               code=&im_storage_not_available   Fail with appropriate
   errexit code=&im_internal_error    |         error code.
  endif                               | Endif.
  l     r3,&w.qss_bottom              | Point r3 to bottom of stack.
  st    r3,&w.qss_top                 | Set stack top.
  lr    r0,r3                         | Set
  a     r0,&w.qss_size                | stack
  st    r0,&w.qss_end                 | end.
* *-------------------------------------------------------------------*
* * Quicksort using Richard C. Singleton's improvements.
* *
* * NOTE: This code assumes that each QSW element is on a double
* *       word boundary.  Notice the SRL R1,4;SLL R1,3 to divide by 2.
* *
* * ALSO: R2 *ALWAYS* points to &w.work and R15 *ALWAYS* points to
* *       the compare code.
* *-------------------------------------------------------------------*
  l     r1,&w.item_counter            | If there is only
  ch    r1,=h'1'                      | one item,
  ##b e,singleton_end                 | it must be sorted!
  la    r2,&w.work                    | Point r2 to work area.
  l     r15,&p.compare_code           | Point r15 to compare code.
  l     r1,&w.work_segment_address    |
  la    r0,qsw_head_size(,r1)         |
  st    r0,&w.i                       | i = first element.
  l     r1,qsw_end-qsw_head(,r1)      |
  sh    r1,=y(qsw_element_size)       |
  st    r1,&w.j                       | j = last element.
  st    r0,&w.ii                      | ii = i.
  ##b u,singleton_l4                  | goto L4.
singleton_l1 equ *                    |L1:
  l     r0,&w.i                       |
  st    r0,&w.k                       | k = i.
  l     r1,&w.j                       |
  st    r1,&w.L                       | L = j.
  alr   r1,r0                         |
  srl   r1,4                          |
  sll   r1,3                          |
  st    r1,&w.ij                      | ij = (i+j)/2
  mvc   &w.t,0(r1)                    | t = A(ij)
  l     r1,&w.i                       |
  l     r5,qsw_address-qsw_element(,r1)
  l     r6,&w.t+qsw_address-qsw_element
  sm_lal r3,singleton_l1_a            |
  basr  r14,r15                       | if A(i) > t:
  l     r1,&w.ij                      |
  l     r14,&w.i                      |
  mvc   0(qsw_element_size,r1),0(r14) |  A(ij) = A(i).
  mvc   0(qsw_element_size,r14),&w.t  |  A(i)  = t.
  mvc   &w.t,0(r1)                    |  t = A(ij).
singleton_l1_a equ *                  | endif.
  l     r5,&w.t+qsw_address-qsw_element
  l     r1,&w.j                       |
  l     r6,qsw_address-qsw_element(,r1)
  sm_lal r3,singleton_l1_b            |
  basr  r14,r15                       | if A(j) < t:
  l     r1,&w.ij                      |
  l     r14,&w.j                      |
  mvc   0(qsw_element_size,r1),0(r14) |  A(ij) = A(j).
  mvc   0(qsw_element_size,r14),&w.t  |  A(j)  = t.
  mvc   &w.t,0(r1)                    |  t = A(ij).
  l     r1,&w.i                       |
  l     r5,qsw_address-qsw_element(,r1)
  l     r6,&w.t+qsw_address-qsw_element
  sm_lal r3,singleton_l1_c            |
  basr  r14,r15                       |  if A(i) > t:
  l     r1,&w.ij                      |
  l     r14,&w.i                      |
  mvc   0(qsw_element_size,r1),0(r14) |   A(ij) = A(i).
  mvc   0(qsw_element_size,r14),&w.t  |   A(i)  = t.
  mvc   &w.t,0(r1)                    |   t = A(ij).
singleton_l1_c equ *                  |  endif.
singleton_l1_b equ *                  | endif.
singleton_l2   equ *                  |L2:
  sm_lal r14,singleton_l2_a           |
  sm_lal r3,singleton_l2_b            | {Some setup}
  l     r6,&w.t+qsw_address-qsw_element
singleton_l2_a equ *                  |
  l     r1,&w.L                       |
  sh    r1,=y(qsw_element_size)       |
  st    r1,&w.L                       | L = L - 1.
  l     r5,qsw_address-qsw_element(,r1)
  br    r15                           | if A(L) > t then goto L2.
singleton_l2_b equ *                  |
  l     r1,&w.L                       |
  mvc   &w.tt,0(r1)                   | tt = A(L).
singleton_l3   equ *                  |L3:
  sm_lal r14,singleton_l3_a           |
  sm_lal r3,singleton_l3_b            | {Some setup}
  l     r5,&w.t+qsw_address-qsw_element
singleton_l3_a equ *                  |
  l     r1,&w.k                       |
  la    r1,qsw_element_size(,r1)      |
  st    r1,&w.k                       | k = k + 1.
  l     r6,qsw_address-qsw_element(,r1)
  br    r15                           | if A(k) < t then goto L3:
singleton_l3_b equ *                  |
  l     r1,&w.k                       |
  l     r14,&w.L                      |
  if (cr,r1,le,r14)                   | if k <= L:
   mvc   0(qsw_element_size,r14),0(r1)   A(L) = A(k).
   mvc   0(qsw_element_size,r1),&w.tt |  A(k) = tt.
   ##b u,singleton_l2                 |  goto L2.
  endif                               | endif.
  l     r0,&w.L                       |
  s     r0,&w.i                       |
  l     r1,&w.j                       |
  s     r1,&w.k                       |
  l     r14,&w.qss_top                |
  using qss,r14                       |
  if (cr,r0,gt,r1)                    | if L - i > j - k :
   l     r0,&w.i                      |
   st    r0,qss_IL                    |  IL(m) = i.
   l     r0,&w.L                      |
   st    r0,qss_IU                    |  IU(m) = L.
   l     r0,&w.k                      |
   st    r0,&w.i                      |  i = k.
  else                                | else:
   l     r0,&w.k                      |
   st    r0,qss_IL                    |  IL(m) = k.
   l     r0,&w.j                      |
   st    r0,qss_IU                    |  IU(m) = j.
   l     r0,&w.L                      |
   st    r0,&w.j                      |  j = L.
  endif                               | endif.
  la    r14,qss_element_size(,r14)    |
  st    r14,&w.qss_top                | m = m + 1.
  drop  r14                           |
singleton_l4 equ *                    |L4:
  l     r1,&w.j                       |
  s     r1,&w.i                       |
  ch    r1,=y(qsw_element_size*10)    | if j - i > 10 then
  ##b h,singleton_l1                  |   goto L1.
  l     r1,&w.i                       |
  if (c,r1,eq,&w.ii)                  | if i = ii :
   c     r1,&w.j                      |  if i < j then
   ##b l,singleton_l1                 |    goto L1.
  endif                               | endif.
  loop until                          | for i = i + 1 step 1 until j:
   l     r1,&w.i                      |
   la    r1,qsw_element_size(,r1)     |
   st    r1,&w.i                      |
   leave loop=*,(c,r1,gt,&w.j)        |
   mvc   &w.t,0(r1)                   |  t = A(i).
   sh    r1,=y(qsw_element_size)      |
   st    r1,&w.k                      |  k = i - 1.
   l     r5,qsw_address-qsw_element(,r1)
   l     r6,&w.t+qsw_address-qsw_element
   sm_lal r3,singleton_l5_a           |
   basr  r14,r15                      |  if A(k) > t:
singleton_l5 equ *                    |L5:
   l     r1,&w.k                      |
   la    r14,qsw_element_size(,r1)    |
   mvc   0(qsw_element_size,r14),0(r1)    A(k+1) = A(k).
   sh    r1,=y(qsw_element_size)      |
   st    r1,&w.k                      |   k = k - 1.
   l     r5,qsw_address-qsw_element(,r1)
   sm_lal r14,singleton_l5            |
   basr  r3,r15                       |   if A(k) > t then goto L5.
   l     r1,&w.k                      |
   la    r1,qsw_element_size(,r1)     |
   mvc   0(qsw_element_size,r1),&w.t  |   A(k+1) = t.
singleton_l5_a equ *                  |  endif.
  endloop until,leave                 | endfor.
  l     r1,&w.qss_top                 |
  if (c,r1,gt,&w.qss_bottom)          |
   sh    r1,=y(qss_element_size)      | m = m - 1.
   st    r1,&w.qss_top                |
   using qss_element,r1               | if m >= 0:
   l     r0,qss_IL                    |
   st    r0,&w.i                      |  i = IL(m).
   l     r0,qss_IU                    |
   st    r0,&w.j                      |  j = IU(m).
   drop  r1                           |
   ##b u,singleton_l4                 |  goto L4.
  endif                               | endif.
singleton_end equ *                   | End of sort.
* *-------------------------------------------------------------------*
* * Now update links in list.
* *-------------------------------------------------------------------*
  l     r3,&w.work_segment_address    | Point r3 to
  la    r3,qsw_head_size(,r3)         | first qsw element.
  using qsw_element,r3                | Establish base.
  l     r4,&p.first_ptr_addr          | Update pointer
  mvc   0(4,r4),qsw_token             | in head for first item.
  sr    r2,r2                         | Set prior item to null.
  l     r15,&w.item_counter           | Load r15 with number of items.
  loop bct                            | Process each item in list:
   l     r4,qsw_address               |  Calculate
   if (tbit,&w.itc_f,&w.itc_f_variable_links_offset),or,               +
               (clc,&w.itc_itype,ne,0(r4)) If characteristics
    l     r1,qsw_token                |    for last
    st    r1,&w.itc_token             |    item are
    la    r1,&w.itc_                  |    not close
    callsub get_itc                   |    enough, call
   endif                              |    subroutine to get ITC.
   a     r4,&w.itc_offset_links       |  address
   a     r4,&p.next_link_offset_in_links of next link.
   if (ch,r15,gt,=h'1')               |  If this is not last item:
    l     r0,qsw_token+qsw_element_size   Use token in next QSW elem.
   else                               |  Else:
    l32   r5,&p.final_ptr_addr        |   Update pointer
    if    nz,then                     |    in head for final
      mvc 0(4,r5),qsw_token           |    item if there is a
    endif                             |    final link in the head.
    sr    r0,r0                       |   Next link is zero.
   endif                              |  Endif.
   st    r0,0(,r4)                    |  Store next link in item.
   l32   r4,&p.prior_link_offset_in_links
   if nm                              |  If there are prior links:
    l     r4,qsw_address              |   Point r4 to item.
    if (tbit,&w.itc_f,&w.itc_f_variable_links_offset),or,              +
               (clc,&w.itc_itype,ne,0(r4)) If characteristics
     l     r1,qsw_token               |     for last
     st    r1,&w.itc_token            |     item are
     la    r1,&w.itc_                 |     not close
     callsub get_itc                  |     enough, call
    endif                             |     subroutine to get ITC.
    a     r4,&p.prior_link_offset_in_links Calculate address
    a     r4,&w.itc_offset_links      |   of prior link.
    st    r2,0(,r4)                   |   Store token of prior item.
    l     r2,qsw_token                |   Set new prior for next time.
   endif                              |  Endif.
   la     r3,qsw_element_size(,r3)    |  Point to next QSW.
  endloop bct,r15                     | Endloop.
  drop  r3                            | Drop base for QSW element.
* *-------------------------------------------------------------------*
* * Free Quicksort work area and stack.
* *-------------------------------------------------------------------*
  es_release_storage id=es,           |  Release Quicksort work area.  +
               address=&w.work_segment_address,                        +
               size=&w.work_segment_size,                              +
               subpool=&s.sp_qsw      |
  errexit (treg,r15,nz),code=&im_internal_error
  mm_release_storage id=mm,           |  Release Quicksort stack.      +
               address=&w.qss_bottom, |                                +
               size=&w.qss_size       |
  errexit (treg,r15,nz),code=&im_internal_error
* *-------------------------------------------------------------------*
 endblk block=Quicksort               |
         ssd ,                        |
&s.qsw_segment_size   dc a(16*1024)   |
&s.sp_qsw             dc f'0'         | Subpool for QSW.
         endssd ,                     |
qsw      dsect ,                      |
qsw_head                    ds    0f  |
qsw_id                      ds    f   |
qsw_id_text             equ c"QSW "   |
qsw_size                    ds    f   |
qsw_next                    ds    a   |
qsw_end                     ds    a   |
                            ds    0d  |
qsw_head_size equ *-qsw_head          |
qsw_head_end  equ *                   |
qsw_element                 ds    0f  |
qsw_token                   ds    f   |
qsw_address                 ds    a   |
qsw_element_size equ *-qsw_element    |
qss      dsect ,                      |
qss_element                 ds    0f  |
qss_IL                      ds    a   |
qss_IU                      ds    a   |
qss_element_size equ *-qss_element    |
         swa ,                        |
&w.work                       ds 2d   |
&w.dummy_qsw_head ds 0f,xl(qsw_head_size)
&w.first_qsw_head equ &w.dummy_qsw_head+qsw_next-qsw_head,4,c"X"
&w.current_qsw_segment        ds a    |
&w.end_of_segment             ds a    |
&w.work_segment_address       ds a    |
&w.work_segment_size          ds f    |
&w.item_counter               ds f    |
&w.next_qsw                   ds a    |
&w.qss_size                   ds f    |
&w.qss_bottom                 ds a    |
&w.qss_top                    ds a    |
&w.qss_end                    ds a    |
&w.i                          ds a    |
&w.j                          ds a    |
&w.ii                         ds a    |
&w.ij                         ds a    |
&w.k                          ds a    |
&w.L                          ds a    |
&w.t            ds xl(qsw_element_size)
&w.tt           ds xl(qsw_element_size)
         itc id=&w.itc_               |
         endswa                       |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Copy_item
*  Abstract:   This subroutine copys an item from item managed
*              storage to a return area that is not in item managed
*              storage.
*  Parameters: (>itc,>return_area_size,<return_area,<actual_item_size|)
*
*---------------------------------------------------------------------*
 block name=copy_item,type=subroutine,                                 +
               parms=(itc,return_area_size,return_area,                +
               actual_item_size)      |
* *-------------------------------------------------------------------*
* * Make sure that return area is large enough.  Return actual size
* * if requested.
* *-------------------------------------------------------------------*
  l     r3,&p.itc                     | Point r3 to ITD.
  using itc_,r3                       | Establish base for ITD.
  l32   r1,&p.return_area_size        | Load r1 with
  errexit z,code=&im_invalid_return_area_size
  l     r1,0(,r1)                     | return area size.
  errexit (c,r1,lt,itc_size),         | Error if area is not large     +
               code=&im_invalid_return_area_size   enough.
  l32   r1,&p.actual_item_size        | Move size of
  if nz                               |  item to return
   mvc   0(4,r1),itc_size             |  field, if
  endif                               |  requested.
* *-------------------------------------------------------------------*
* * Copy the item.
* *-------------------------------------------------------------------*
  l     r15,itc_size                  | Load size of item.
  l     r6,itc_address                | Point r6 to item in storage.
  l     r2,&p.return_area             | Point r2 to return area.
  loop until                          | Move item to return area.
   ltr   r1,r15                       |  Load r1 with remaining
   leave np,loop=*                    |  move length.  Finished if
*                                     |  length is not positive.
   if (ch,r1,gt,=h'256')              |  Can only move
    la    r1,256                      |  up to 256 bytes
   endif                              |  at a time.
   sr    r15,r1                       |  Calc new remaining length.
   bctr  r1,0                         |  Move up to 256
   exi   r1,(mvc,0(*-*,r2),0(r6))     |  bytes of item.
   la    r2,256(,r2)                  |  Point to next 256 bytes
   la    r6,256(,r6)                  |  of item.
  endloop until,leave                 | Endloop.
* *-------------------------------------------------------------------*
 endblk block=copy_item               |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Obtain_item_storage
*  Abstract:   This subroutine will get some item storage of the
*              specified size.
*  Parameters: (>grd_token,>size,<Item_token,<Item_address)
*  Returncode: 0 - Went ok.
*              4 - Could not obtain memory.
*              CC - Set to reflect return code.
*
*---------------------------------------------------------------------*
 block name=obtain_item_storage,type=subroutine,                       +
               parms=(grd_token,item_size,item_token,item_address)
          space 1                     |
* *-------------------------------------------------------------------*
* * If the number of spare GSS entries is below min, get more in case
* * they are needed.
* *-------------------------------------------------------------------*
  l     r4,pwa_imc_address            | Point r4 to IMC.
  using imc,r4                        | Establish base for IMC.
  if (clc,imc#sgss,lt,psd_min_spare_gsss) If the number of spare GSSs
   callsub replenish_spare_gsss       |   is below min, get more.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Get and adjust item size.
* *-------------------------------------------------------------------*
  l     r1,&p.item_size               | Load pointer to item size.
  l     r1,0(,r1)                     | Load item size.
  callsub adjust_item_size            | Adjust size to valid size.
  st    r1,&w.item_size               | Save item size in SWA.
* *-------------------------------------------------------------------*
* * Get storage for item.
* *-------------------------------------------------------------------*
  callsub get_free_storage,           | Locate some free storage.      +
               (*&p.grd_token,        |                                +
               &w.item_size,          |                                +
               *&p.item_token,        |                                +
               *&p.item_address)      |
* *-------------------------------------------------------------------*
* * If there was not enough free space, get a new segment for the
* * group.
* *-------------------------------------------------------------------*
  if (treg,r15,nz)                    | If there was not freespace:
*  *------------------------------------------------------------------*
*  * Get a new segment.
*  *------------------------------------------------------------------*
   callsub get_a_new_segment,         | Make a new segment             +
               (*&p.grd_token,        |                                +
               &w.item_size)          |
   errexit (treg,r15,nz),code=&im_internal_error
*  *------------------------------------------------------------------*
*  * Try again to locate storage for the item.  If storage is still
*  * not available, there is an internal error.
*  *------------------------------------------------------------------*
   callsub get_free_storage,          | Locate some free storage.      +
               (*&p.grd_token,        |                                +
               &w.item_size,          |                                +
               *&p.item_token,        |                                +
               *&p.item_address)      |
   errexit (treg,r15,nz),code=&im_internal_error
*  *------------------------------------------------------------------*
  endif                               |
 endblk block=obtain_item_storage     |
 space 1                              |
          swa   ,                     |
&w.item_size                 ds  a    |
          endswa ,                    |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Free_item_storage
*  Abstract:   This subroutine will free item storage for the
*              specified size.
*  Parameters: (>grd_token,>size,>Item_token,>Item_address)
*
*---------------------------------------------------------------------*
 block name=free_item_storage,type=subroutine,                         +
               parms=(grd_token,item_size,item_token,item_address)
* *-------------------------------------------------------------------*
* * Move parameters to work area.
* *-------------------------------------------------------------------*
  mvi   &w.f1,0                       | Reset all flag.
  l     r1,&p.item_token              | Move item token to
  mvc   &w.fsi_token,0(r1)            | work area.
  l     r1,&p.item_size               | Load size
  l     r1,0(,r1)                     | of item.
  callsub adjust_item_size            | Adjust the size.
  st    r1,&w.item_size               | Store it in SWA.
  l     r1,&p.grd_token               | Move GRD token
  mvc   &w.grd_token,0(r1)            | to work area.
  l     r1,&p.item_address            | Move item address
  mvc   &w.item_address,0(r1)         | to work area.
* *-------------------------------------------------------------------*
* * Establish base for GRD and find appropriate GSS.
* *-------------------------------------------------------------------*
  imlta r4,&w.grd_token               | Point r4 to GRD.
  errexit nz,or,(treg,r4,z),          | Error if invalid or null.      +
               code=&im_internal_error
  using grd,r4                        | Establish base for GRD.
  using gss,r5                        | R5 will be used for GSS base.
  l    r3,grdfrgss                    | Set r3 to token of first GSS.
  fill &w.previous_gss_address,x'00'  | Clear GSS previous address.
  loop until                          | Loop searching for correct GSS.
   imlta r5,r3                        |  Convert GSS token to address.
   errexit nz,or,(treg,r5,z),         |  Error if invalid or null.     +
               code=&im_internal_error
   l     r1,&w.fsi_token              |  Load r1 with token of item.
   l     r2,gssstart                  |  If the new token
   if (clr,r1,ge,r2)                  |  is within the bounds
    a     r2,gsssize                  |  of the segment described
    leave loop=*,(cr,r1,lt,r2)        |  by this GSS, the search
   endif                              |  is over.
   st    r5,&w.previous_gss_address   |  Save this address as previous.
   l     r3,gssnxgss                  |  Load token of next GSS.
  endloop until,leave                 | Endloop.
  st    r3,&w.gss_token               | Save GSS token.
* *-------------------------------------------------------------------*
* * Clear the item storage.
* *-------------------------------------------------------------------*
  l     r6,&w.item_address            | Point r6 to item.
  l     r15,&w.item_size              | Load r15 with size of item.
  loop until                          | Clear item storage.
   ltr   r1,r15                       |  Load r1 with remaining
   leave np,loop=*                    |  length.  Finished if
*                                     |  length is not positive.
   if (ch,r1,gt,=h'256')              |  Can only clear
    la    r1,256                      |  up to 256 bytes
   endif                              |  at a time.
   sr    r15,r1                       |  Calc new remaining length.
   bctr  r1,0                         |  Clear up to 256
   exi   r1,(xc,0(*-*,r6),0(r6))      |  bytes of item.
   la    r6,256(,r6)                  |  of item.
  endloop until,leave                 | Endloop.
* *-------------------------------------------------------------------*
* * Update the GSSUSED field.  If it has gone to zero, set up to
* * free the whole segment instead of just the item.
* *-------------------------------------------------------------------*
  l     r1,gssused                    | Update
  s     r1,&w.item_size               | GSS used
  st    r1,gssused                    | field.
  if (treg,r1,z)                      | If the amount used is zero:
*  *------------------------------------------------------------------*
*  * Clear storage of FSIs in segment.
*  *------------------------------------------------------------------*
   l     r0,gssfrfsi                  |  Load r0 with first FSI token.
   loop until                         |  Loop through all FSI in group.
    imlta r6,r0                       |   Convert token to address.
    errexit nz,code=&im_internal_error    Error if invalid.
    leave loop=*,(treg,r6,z)          |   Finished if end of chain.
    using fsi,r6                      |   Establish base for FSI.
    l     r0,fsinxfsi                 |   Load r0 with next FSI token.
    xc    fsi(fsiitmsz),fsi           |   Clear this FSI.
    drop  r6                          |   Drop base for FSI.
   endloop until,leave                |  Endloop.
*  *------------------------------------------------------------------*
*  * Set up to free the whole segment.
*  *------------------------------------------------------------------*
   mvc   &w.item_size,gsssize         |  Make it look to
   mvc   &w.fsi_token,gssstart        |  the rest of the
   imlta &w.item_address,gssstart     |  block like the
   errexit nz,code=&im_internal_error |  whole segment is
   l32   r6,&w.previous_gss_address   |  the item to free.
   if z                               |  If this is first GSS in chain,
    mvc   grdfrgss,gssnxgss           |  update first GSS token in GRD;
   else                               |  otherwise, update next GSS
    mvc   gssnxgss-gss(4,r6),gssnxgss |  token in previous GSS.
   endif                              |
   xc    gss+2(gssitmsz-2),gss+2      |  Clear the GSS except for type.
   using imc,r4                       |  Use r4 as base for IMC.
   l     r4,pwa_imc_address           |  Change the GRD
   l     r0,imcgrdua                  |  token to be used to
   st    r0,&w.grd_token              |  the unallocated group's GRD.
   mvc   gssnxgss,imcspgss            |  Chain GSS on free chain of
   mvc   imcspgss,&w.gss_token        |  GSSs.
   drop  r4                           |  Drop base for IMC.
   imlta r4,r0                        |  Point r4 to unallocated GRD.
   using grd,r4                       |  Establish base for GRD.
   errexit nz,or,(treg,r4,z),         |  Error if invalid or null.     +
               code=&im_internal_error
*  *------------------------------------------------------------------*
*  * Unchain the GSS from GRD GSS chain and place the GSS on the
*  * free GSS chain.
*  *------------------------------------------------------------------*
   l    r3,grdfrgss                   |  Set r3 to token of first GSS.
   fill &w.previous_gss_address,x'00' |  Clear GSS previous token.
   loop until                         |  Loop searching for correct GSS
    imlta r5,r3                       |   Convert GSS token to address.
    errexit nz,or,(treg,r5,z),        |   Error if invalid or null.    +
               code=&im_internal_error
    l     r1,&w.fsi_token             |   Load r1 with token of item.
    l     r2,gssstart                 |   If the new token
    if (clr,r1,ge,r2)                 |   is within the bounds
     a     r2,gsssize                 |   of the segment described
     leave loop=*,(cr,r1,lt,r2)       |   by this GSS, the search
    endif                             |   is over.
    st    r5,&w.previous_gss_address  |   Save this address as prev.
    l     r3,gssnxgss                 |   Load token of next GSS.
   endloop until,leave                |  Endloop.
   st    r3,&w.gss_token              |  Save GSS token.
   l     r1,gssused                   |  Update
   s     r1,&w.item_size              |  GSS used
   if z                               |  field and
    sbit  &w.f1,&w.f1_ua_segment_free |  set flag
   endif                              |  if it is
   st    r1,gssused                   |  zero.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Make a free space item in the item storage.
* *-------------------------------------------------------------------*
  l     r6,&w.item_address            | Point r6 to free space.
  using fsi,r6                        | Establish base for FSI.
  mvc   fsiitype,grdtdfsi+2           | Move item type to FSI.
  mvc   fsinu1,=h'-1'                 | Set unused field to -1.
  mvc   fsisize,&w.item_size          | Move size to FSI.
* *-------------------------------------------------------------------*
* * Put this FSI in the free space chain.  The Free space chain is
* * keep in accending order.  Maintain the GSSLRGST.
* *-------------------------------------------------------------------*
  l     r1,&w.fsi_token               | Load r1 with token of new FSI.
  l32   r3,gssfrfsi                   | FSI chained off of GSS.
  if z                                | If chain is empty:
   st    r1,gssfrfsi                  |  The new FSI is whole chain.
* *-------------------------------------------------------------------*
* * If chain is not empty, find place to put FSI.
* *-------------------------------------------------------------------*
  else                                | If the chain is not empty:
*  *------------------------------------------------------------------*
*  * If this FSI should be the new first in chain, put it there.
*  *------------------------------------------------------------------*
   if (clr,r1,lt,r3)                  |  If new FSI should go at start
    st    r3,fsinxfsi                 |  of chain, link it in.
    st    r1,gssfrfsi                 |
*  *------------------------------------------------------------------*
*  * If the FSI should not be ther first, find where it belongs and
*  * put it there.
*  *------------------------------------------------------------------*
   else                               |  If should not go at head:
*   *-----------------------------------------------------------------*
*   * Loop through FSIs until the correct place for the new FSI is
*   * found and place it there.
*   *-----------------------------------------------------------------*
    loop until                        |   Search for correct place.
*    *----------------------------------------------------------------*
*    * R6 will point to the new FSI.  R7 will be used to point to the
*    * current FSI in the chain.
*    *----------------------------------------------------------------*
     imlta r7,r3                      |    Point r7 to current FSI.
     errexit nz,code=&im_internal_error    Error if invalid.
*    *----------------------------------------------------------------*
*    * If the new FSI is immediately after the current FSI, consolidate
*    * them and leave loop.
*    *----------------------------------------------------------------*
     l     r1,&w.fsi_token            |    Load r1 with tkn of new FSI.
     lr    r0,r3                      |    Calculate token of next
     al    r0,fsisize-fsi(,r7)        |    item after current FSI.
     if (clr,r0,eq,r1)                |    If it is the new FSI:
      l     r0,fsisize-fsi(,r7)       |     Consolidate
      al    r0,fsisize                |     the
      st    r0,fsisize-fsi(,r7)       |     two
      xc    0(fsiitmsz,r6),0(r6)      |     FSIs.
      lr    r1,r3                     |     Consolidated FSI will be
      lr    r6,r7                     |     treated as new FSI now.
      st    r1,&w.fsi_token           |     Save token of new FSI.
      leave loop=*                    |     Leave loop.
     endif                            |    Endif.
*    *----------------------------------------------------------------*
*    * Load token of next FSI in chain.  If the new FSI should go
*    * before this next FSI, chain it in and leave the loop.
*    *----------------------------------------------------------------*
     l32   r3,fsinxfsi-fsi(r7)        |    Load r3 with next FSI token.
     if (clr,r1,lt,r3),or,            |    If new FSI should go before:+
               (treg,r3,z)            |
      st    r0,fsinxfsi               |     Chain the new
      st    r1,fsinxfsi-fsi(,r7)      |     FSI after the current
      leave loop=*                    |     FSI.
     endif                            |    Endif.
*    *----------------------------------------------------------------*
    endloop until,leave               |   Endloop.
   endif                              |  Endif.
*  *------------------------------------------------------------------*
*  * If an FSI immediately follows the new FSI, consolidate it into
*  * the new FSI.
*  *------------------------------------------------------------------*
   l     r1,&w.fsi_token              |  Load r1 with tkn of new FSI.
   al    r1,fsisize                   |  If next item after the new
   if (cl,r1,eq,fsinxfsi)             |  FSI is the next FSI:
    lr    r7,r6                       |   Consolidate
    al    r7,fsisize                  |   the
    mvc   fsinxfsi,fsinxfsi-fsi(r7)   |   next
    l     r0,fsisize-fsi(,r7)         |   FSI
    al    r0,fsisize                  |   into
    st    r0,fsisize                  |   the
    xc    0(fsiitmsz,r7),0(r7)        |   new FSI.
   endif                              |  Endif.
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * If a whole segment is being freed and the amount used in the
* * resulting unassigned storage segment is zero, consolidate the
* * previous and next unassigned segment if they are back to back.
* *-------------------------------------------------------------------*
  if (tbit,&w.f1,&w.f1_ua_segment_free) If condition is met:
*  *------------------------------------------------------------------*
*  * If previous segment in just before this one and it is empty,
*  * consolidate it with this one.
*  *------------------------------------------------------------------*
   l32   r7,&w.previous_gss_address   |  Point r7 to previous GSS.
   if nz,and,(clc,gssused-gss(4,r7),eq,=f'0') If prev segment empty:
    l     r0,gssstart-gss(,r7)        |   If previous segment
    al    r0,gsssize-gss(,r7)         |   is just before
    if (cl,r0,eq,&w.fsi_token)        |   this segment:
     imlta r8,gssfrfsi-gss(,r7)       |    Point r8 to previous FSI.
     errexit nz,code=&im_internal_error    Error if invalid.
     l     r0,fsisize-fsi(,r8)        |    Adjust size of free space
     al    r0,fsisize                 |    in previous segment
     st    r0,fsisize-fsi(,r8)        |    to include new free space.
     st    r0,gsssize-gss(,r7)        |    Update size and
     st    r0,gsslrgst-gss(,r7)       |    largest.
     mvc   gssnxgss-gss(4,r7),gssnxgss     Set next pointer.
     xc    fsi(fsiitmsz),fsi          |    Clear unused FSI storage.
     lr    r6,r8                      |    Point r6 to consolidated FS.
     xc    gss+2(gssitmsz-2),gss      |    Clear unused GSS.
     l     r8,pwa_imc_address         |    Point r8 to IMC.
     using imc,r8                     |    Establish base for IMC.
     mvc   gssnxgss,imcspgss          |    Chain unused GSS onto
     mvc   imcspgss,&w.gss_token      |    spare GSS chain.
     drop  r8                         |    Drop base for IMC.
     lr    r5,r7                      |    Point to consolidated GSS.
    endif                             |   Endif.
   endif                              |  Endif.
*  *------------------------------------------------------------------*
*  * If next segment is just after this one, consolidate it with
*  * this one.
*  *------------------------------------------------------------------*
   imlta r7,gssnxgss                  |  Point r7 to next GSS.
   errexit nz,code=&im_internal_error |  Error if invalid.
   if (treg,r7,nz),and,               |  If next segment is empty:     +
               (clc,gssused-gss(4,r7),eq,=f'0')
    l     r0,gssstart                 |   If segment is
    al    r0,gsssize                  |   just after
    if (cl,r0,eq,gssstart-gss(,r7))   |   this one:
     imlta r8,gssfrfsi-gss(,r7)       |    Point r8 to next FSI.
     errexit nz,code=&im_internal_error    Error if invalid.
     l     r0,fsisize-fsi(,r8)        |    Adjust size of free space
     al    r0,fsisize                 |    to include free space
     st    r0,fsisize                 |    in next segment.
     st    r0,gsssize                 |    Update size and
     st    r0,gsslrgst                |    largest.
     l     r0,gssnxgss                |    Save token of next GSS.
     mvc   gssnxgss,gssnxgss-gss(r7)  |    Unchain next GSS.
     xc    0(fsiitmsz,r8),0(r8)       |    Clear unused FSI storage.
     xc    2(gssitmsz-2,r7),2(r7)     |    Clear unused GSS.
     l     r8,pwa_imc_address         |    Point r8 to IMC.
     using imc,r8                     |    Establish base for IMC.
     mvc   gssnxgss-gss(4,r7),imcspgss     Chain unused GSS onto
     st    r0,imcspgss                |    spare GSS chain.
     drop  r8                         |    Drop base for IMC.
    endif                             |   Endif.
   endif                              |  Endif.
*  *------------------------------------------------------------------*
*  * If this GSS is at end of chain, release the storage and leave
*  * the block.
*  *------------------------------------------------------------------*
   if (clc,gssnxgss,eq,=f'0')         |
*>>> need code.                       |
   endif                              |
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * If this FSI is larger then the previous largest FSI, update
* * GSSLRGST.
* *-------------------------------------------------------------------*
  if (clc,fsisize,gt,gsslrgst)        | If this new FSI is largest:
   mvc   gsslrgst,fsisize             |  Indicate this in GSS.
  endif                               | Endif.
* *-------------------------------------------------------------------*
 endblk block=free_item_storage       |
 space 1                              |
          swa   ,                     |
&w.fsi_token                 ds  f    |
&w.grd_token                 ds  f    |
&w.gss_token                 ds  f    |
&w.previous_gss_address      ds  f    |
&w.item_address              ds  f    |
&w.item_size                 ds  f    |
&w.f1                        ds  bl1  |
&w.f1_ua_segment_free equ b'10000000' |
          endswa ,                    |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Replenish_Spare_GSSs
*  Abstract:   This subroutine will get some item storage of the
*              specified size.
*
*---------------------------------------------------------------------*
 block name=replenish_spare_gsss,type=subroutine,options=noparms
* *-------------------------------------------------------------------*
* * Establish base for IMC.
* *-------------------------------------------------------------------*
  l     r4,pwa_imc_address            | Point r4 to IMC.
  using imc,r4                        | Establish base for IMC.
* *-------------------------------------------------------------------*
* * Calculate number of GSSs needed to get back up to max and the
* * amount of storage that will be required.
* *-------------------------------------------------------------------*
  l     r1,psd_max_spare_gsss         | Calcuate the number
  s     r1,imc#sgss                   | needed to get back to max.
  errexit np,code=&im_internal_error  | Error if not a postive number.
  st    r1,&w.number_needed           | Save the number.
  mh    r1,=y(gssitmsz)               | Calculate the storage needed.
  callsub adjust_item_size            | Adjust size to valid size.
  st    r1,&w.storage_needed          | Save item size in SWA.
* *-------------------------------------------------------------------*
* * Get storage for new GSSs in system storage.
* *-------------------------------------------------------------------*
  callsub get_free_storage,           | Locate some free storage.      +
               (imcgrdsy,             |                                +
               &w.storage_needed,     |                                +
               &w.gsss_token,         |                                +
               &w.gsss_address)       |
* *-------------------------------------------------------------------*
* * If there was not enough free space, get a new segment of system
* * storage.
* *-------------------------------------------------------------------*
  if (treg,r15,nz)                    | If there was not freespace:
*  *------------------------------------------------------------------*
*  * Get a new segment.
*  *------------------------------------------------------------------*
   callsub get_a_new_segment,         | Make a new segment             +
               (imcgrdsy,&w.storage_needed)
   errexit (treg,r15,nz),code=&im_internal_error
*  *------------------------------------------------------------------*
*  * Try again to locate storage for the item.  If storage is still
*  * not available, there is an internal error.
*  *------------------------------------------------------------------*
   callsub get_free_storage,          | Locate some free storage.      +
               (imcgrdsy,             |                                +
               &w.storage_needed,     |                                +
               &w.gsss_token,         |                                +
               &w.gsss_address)       |
   errexit (treg,r15,nz),code=&im_internal_error
*  *------------------------------------------------------------------*
  endif                               |
* *-------------------------------------------------------------------*
* * Initialize the new spare GSSs and add to spare chain.
* *-------------------------------------------------------------------*
  l     r5,&w.gsss_address            | Point r5 to new storage.
  l     r15,&w.number_needed          | Load r15 with number.
  l     r0,imcspgss                   | Load r0 with first old spare.
  l     r1,&w.gsss_token              | Load r1 with token of first new
  using gss,r5                        | Establish base for GSS.
  loop bct                            | Loop the "number needed" times.
   mvc   gssitype,imctdgss+2          |  Set item type for GSS.
   st    r0,gssnxgss                  |  Set next GSS.
   la    r5,gssitmsz(,r5)             |  Increment to
   lr    r0,r1                        |  next GSS address
   la    r1,gssitmsz(r1)              |  and token.
  endloop bct,r15                     | Endloop.
  st   r0,imcspgss                    | Store new head in IMC.
  mvc  imc#sgss,psd_max_spare_gsss    | Set the number of spare GSSs.
* *-------------------------------------------------------------------*
 endblk block=replenish_spare_gsss    |
 space 1                              |
          swa   ,                     |
&w.storage_needed            ds  a    |
&w.number_needed             ds  f    |
&w.gsss_token                ds  f    |
&w.gsss_address              ds  a    |
          endswa ,                    |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Get_a_new_segment
*  Abstract:   This subroutine will get a new segment of storage.
*  Parameters: (>grd_token,<segment_token,<segment_address)
*  Returncode: 0 - Went ok.
*              4 - Could not obtain memory.
*              CC - Set to reflect return code.
*
*---------------------------------------------------------------------*
 block name=get_a_new_segment,type=subroutine,                         +
               parms=(grd_token,min_size)
* *-------------------------------------------------------------------*
* * Use r5 as base for IMC and r6 as base for the GRD associated
* * with the segment being created.
* *-------------------------------------------------------------------*
  l     r5,pwa_imc_address            | Load r5 with address of IMC.
  using imc,r5                        | Establish base for IMC.
  imlta r6,*&p.grd_token              | Load r6 with addr of item's
  using grd,r6                        | GRD and establish base.
  errexit nz,code=&im_internal_error  | Bad news if not valid token.
* *-------------------------------------------------------------------*
* * Locate free storage for the new segment from unassigned storage.
* *-------------------------------------------------------------------*
  l     r1,&p.min_size                | If size
  l     r1,0(,r1)                     | needed is
  l     r0,grdincsz                   | larger than
  if (cr,r1,gt,r0)                    | a normal
   la    r0,4095(,r1)                 | segement,
   srl   r0,12                        | get a
   sll   r0,12                        | larger
  endif                               | segment.
  st    r0,&w.size_needed             | Save size needed.
  callsub get_free_storage,           | Locate some free storage.      +
               (imcgrdua,             |                                +
               &w.size_needed,        |                                +
               &w.segment_token,      |                                +
               &w.segment_address)    |
* *-------------------------------------------------------------------*
* * If there is not room for the segment in the unallocated group,
* * get a new segment for the unallocated group and try again.
* *-------------------------------------------------------------------*
  if (treg,r15,nz)                    | If there was not free space:
*  *------------------------------------------------------------------*
*  * Use r7 as base for unallocated group's GRD.  Make sure that the
*  * increment is large enough to hold a new segement for the
*  * group.
*  *------------------------------------------------------------------*
   imlta r7,imcgrdua                  |  Point r7 to GRD for
   errexit nz,code=&im_internal_error |  unassigned storage.
   l     r0,grdincsz-grd(,r7)         |  Load increment
   if (c,r0,lt,&w.size_needed)        |  size and make
    l     r0,&w.size_needed           |  sure that it
    ah    r0,=h'4095'                 |  is large enough to
    srl   r0,12                       |  hold the new increment
    sll   r0,12                       |  for the item's group.
   endif                              |
   st    r0,&w.increment_needed       |  Save increment needed.
*  *------------------------------------------------------------------*
*  * Extend the size of the data space.
*  *------------------------------------------------------------------*
   callsub get_data_space_increment,  |  Extend data space.            +
               (&w.increment_needed,  |                                +
               &w.increment_token,    |                                +
               &w.increment_address)  |
*  *------------------------------------------------------------------*
*  * Make a new freespace for the unassigned group in this space.
*  *------------------------------------------------------------------*
   callsub initialize_new_freespace,  |  Make a free space in          +
               (imcgrdua,             |   the new extention for        +
               &w.increment_needed,   |   unassigned storage.          +
               &w.increment_token,    |                                +
               &w.increment_address)  |
*  *------------------------------------------------------------------*
*  * Try again to get space for a new segment of the group associated
*  * with the item being obtained.  If there is still no space, there
*  * is an internal error.
*  *------------------------------------------------------------------*
   callsub get_free_storage,          |  Locate some free storage.     +
               (imcgrdua,             |                                +
               &w.size_needed,        |                                +
               &w.segment_token,      |                                +
               &w.segment_address)    |
   errexit (treg,r15,nz),code=&im_internal_error
*  *------------------------------------------------------------------*
  endif                               | Endif.
* *-------------------------------------------------------------------*
* * Make a new freespace for the item's group in the space obtained
* * from the unassigned storage group.
* *-------------------------------------------------------------------*
  callsub initialize_new_freespace,   | Make a new free space for      +
               (*&p.grd_token,        |  item's group.                 +
               &w.size_needed,        |                                +
               &w.segment_token,      |                                +
               &w.segment_address)    |
**--------------------------------------------------------------------*
 endblk block=get_a_new_segment       |
 space 1                              |
          swa   ,                     |
&w.segment_token             ds  a    |
&w.segment_address           ds  a    |
&w.size_needed               ds  f    |
&w.increment_needed          ds  f    |
&w.increment_token           ds  f    |
&w.increment_address         ds  a    |
          endswa ,                    |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: adjust_item_size
*  Abstract:   This subroutine adjusts the item size to an internal
*              item storage size.  Internal sizes are multiples of
*              4 and no less then the size of a FSI.
*  Parameters: R1 should have size on input and will contain adjusted
*              size on output.
*
*---------------------------------------------------------------------*
 block name=adjust_item_size,type=subroutine,options=*nosubopts
  if (ch,r1,lt,=y(fsiitmsz))          | If size < size of FSI:
   la    r1,fsiitmsz                  |  Set size to size of FSI.
  else                                | Else:
   al    r1,=f'3'                     |  Round to
   srl   r1,2                         |  a multiple
   sll   r1,2                         |  of 4.
  endif                               | Endif.
 endblk block=adjust_item_size        |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: get_free_storage
*  Abstract:   Get the request amount of storage.
*  Parameters: (>grd_token,>size_to_obtain,<token,<address)
*
*---------------------------------------------------------------------*
 block name=get_free_storage,type=subroutine,                          +
               parms=(grd_token,size_to_obtain,token,address)
* *-------------------------------------------------------------------*
* * Adjust the size to a legal size and save in work area.  Also,
* * calculate the space required for the item plus a minimum sized
* * free space.
* *-------------------------------------------------------------------*
  l     r1,&p.size_to_obtain          | Load r1 with
  l     r1,0(,r1)                     | item size needed.
  callsub adjust_item_size            | Adjust item size.
  st    r1,&w.actual_size             | Save this size.
  la    r1,fsiitmsz(r1)               | Save this size added to the
  st    r1,&w.size_plus_min_freespace | size of the smallest freespace.
  imlta r4,*&p.grd_token              | Point r4 to GRD.
  errexit nz,code=&im_internal_error  | Error if invalid.
* *-------------------------------------------------------------------*
* * Loop processing all GSS entries for this group, until space is
* * found.
* *-------------------------------------------------------------------*
  using grd,r4                        | Establish base for GRD.
  imlta r5,grdfrgss                   | Point r5 to GSS.
  errexit nz,code=&im_internal_error  | Error if invalid.
  using gss,r5                        | Establish base for GSS.
  loop while,(treg,r5,nz)             | Loop while not EOC GSS chain.
*  *------------------------------------------------------------------*
*  * If there is a large enough freespace in this segment to satisfy
*  * the request, loop through the FSI entries for this segment and
*  * use the first one that is large enough.
*  *------------------------------------------------------------------*
   if (clc,gsslrgst,eq,&w.actual_size),  If this segment has a large   +
               or,(clc,gsslrgst,ge,&w.size_plus_min_freespace)
*                                     |  enough free space:
    l     r2,gssfrfsi                 |   Load r2 with 1st FSI token.
    imlta r6,r2                       |   Point r6 to 1st FSI.
    errexit nz,code=&im_internal_error    Error if invalid.
    using fsi,r6                      |   Establish base for FSI.
    slr   r7,r7                       |   Set previous pointer to zero.
    loop while,(treg,r6,nz)           |   Loop through FSI chain.
*    *----------------------------------------------------------------*
*    * If space is found, adjust the free space chain as required, and
*    * return the token and address of the item storage.
*    *----------------------------------------------------------------*
     if (clc,fsisize,eq,&w.actual_size),   If FS large enough:         +
               or,(clc,fsisize,ge,&w.size_plus_min_freespace)
*     *---------------------------------------------------------------*
*     * Adjust the space used in this segment.  If this freespace
*     * was the largest, indicate that we will need to determine
*     * what is the largest free space again.
*     *---------------------------------------------------------------*
      l     r1,gssused                |     Add size of item
      al    r1,&w.actual_size         |     storage to size used
      st    r1,gssused                |     in this segment.
      rbit  &w.f1,&w.f1_find_largest  |     Reset flag.
      if (clc,fsisize,eq,gsslrgst)    |     If this was largest FSI:
       sbit  &w.f1,&w.f1_find_largest |      Set a flag for later use.
      endif                           |     Endif.
*     *---------------------------------------------------------------*
*     * If the free space is exactly the correct size, unchain the FSI
*     *---------------------------------------------------------------*
      if (clc,fsisize,eq,&w.actual_size)    if exactly room for item:
       if (treg,r7,z)                 |      if FSI at head of chain:
        mvc   gssfrfsi,fsinxfsi       |       Make next FSI the first.
       else                           |      Else:
        mvc   fsinxfsi-fsi(4,r7),fsinxfsi     Move next FSI to prv FSI.
       endif                          |      Endif.
*     *---------------------------------------------------------------*
*     * If the free space is larger than needed, carve an item from
*     * the start of the free space.
*     *---------------------------------------------------------------*
      else                            |     Else if just a smaller FS:
       l     r1,fsisize               |      Decrease the
       sl    r1,&w.actual_size        |      size in the
       st    r1,fsisize               |      freespace entry.
       lr    r8,r6                    |      Scoot the
       al    r8,&w.actual_size        |      FSI past the
       mvc   0(fsiitmsz,r8),0(r6)     |      item storage.
       xc    0(fsiitmsz,r6),0(r6)     |      Clear the old FSI.
       lr    r1,r2                    |      Calculate token
       al    r1,&w.actual_size        |      of FSI.
       if (treg,r7,z)                 |      If it is first in chain:
        st    r1,gssfrfsi             |       Store token in GSS.
       else                           |      If not first in chain:
        st    r1,fsinxfsi-fsi(,r7)    |       Store token in last FSI.
       endif                          |      Endif.
      endif                           |     Endif.
*     *---------------------------------------------------------------*
*     * Return the token and address of the item storage.
*     *---------------------------------------------------------------*
      l     r1,&p.token               |     Return token address
      st    r2,0(,r1)                 |     for item.
      l     r1,&p.address             |     Return item address
      st    r6,0(,r1)                 |     for item.
*     *---------------------------------------------------------------*
*     * If this was the largest FSI, determine what the largest one
*     * is now.
*     *---------------------------------------------------------------*
      if (tbit,&w.f1,&w.f1_find_largest)    If this was the largest.
       fill  gsslrgst,x'00'           |      Set the largest to zero.
       l32   r2,gssfrfsi              |      Load r2 with first FSI.
       loop  while,nz                 |      Search for largest.
        imlta r6,r2                   |       Get address of this FSI.
        errexit nz,code=&im_internal_error    Error if invalid.
        if (clc,fsisize,gt,gsslrgst)  |       If this FSI larger:
         mvc   gsslrgst,fsisize       |        Put its size in GSS.
        endif                         |       Endif.
        l32   r2,fsinxfsi             |       Load next FSI token.
       endloop while                  |      Endloop.
      endif                           |     Endif.
*     *---------------------------------------------------------------*
*     * Return to caller with a zero return code.
*     *---------------------------------------------------------------*
      sr    r15,15                    |     Set return code to zero.
      leave block=get_free_storage    |     Leave block.
*     *---------------------------------------------------------------*
     endif                            |    Endif.
     lr    r7,r6                      |    Set previous pointer.
     l     r2,fsinxfsi                |    Load next token in r2.
     imlta r6,r2                      |    Point to next FSI.
     errexit nz,code=&im_internal_error    Error if invalid.
    endloop while                     |   Endloop.
    errexit code=&im_internal_error   |   Error if fell through.
   endif                              |
*  *------------------------------------------------------------------*
   imlta r5,gssnxgss                  |  Point to next GSS.
   errexit nz,code=&im_internal_error |  Error if invalid.
  endloop while                       | Endloop.
* *-------------------------------------------------------------------*
* * If we fell thru, there was not room.
* *-------------------------------------------------------------------*
  la    r15,&im_no_room               | No room if fell thru.
* *-------------------------------------------------------------------*
 endblk block=get_free_storage,rc=(r15)
*---------------------------------------------------------------------*
* Subroutine Work Area.               |
*---------------------------------------------------------------------*
         swa ,                        |
&w.actual_size               ds  f    |
&w.size_plus_min_freespace   ds  f    |
&w.f1                  ds  b          |
&w.f1_find_largest     equ b'10000000'
         endswa ,                     |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: initialize_new_freespace
*  Abstract:   Initialize a new free space in the storage provided
*              and chain it to GSS off of GRD.
*  Parameters: (>grd_token,>size_to_make_free,>token,>address)
*
*---------------------------------------------------------------------*
 block name=initialize_new_freespace,type=subroutine,                  +
               parms=(grd_token,grd_size_to_make_free,                 +
               free_space_token,free_space_address)
* *-------------------------------------------------------------------*
* * Set up various bases and get a spare GSS to use for new segment.
* *-------------------------------------------------------------------*
  imlta r4,*&p.grd_token              | Point r4 to GRD.
  errexit nz,code=&im_internal_error  | Internal error if invalid.
  using grd,r4                        | Establish base for GRD.
  l     r5,pwa_imc_address            | Point r5 to IMC.
  using imc,r5                        | Establish base for IMC.
  l32   r0,imcspgss                   | Load r0 with token of spare GSS
  errexit z,code=&im_internal_error   | Internal error if none.
  st    r0,&w.gss_token               | Save token for later use.
  imlta r6,r0                         | Get address of spare GSS.
  errexit nz,code=&im_internal_error  | Internal error if failed.
  using gss,r6                        | Establish base for GSS.
  mvc   imcspgss,gssnxgss             | Remove GSS from spare chain.
  l     r1,imc#sgss                   | Decrement the
  bctr  r1,0                          | number of spare GSSs
  st    r1,imc#sgss                   | by one.
* *-------------------------------------------------------------------*
* * Initialize the FSI.
* *-------------------------------------------------------------------*
  l     r1,&p.free_space_address      | Point r7 to new
  l     r7,0(,r1)                     | segment.
  using fsi,r7                        | Establish base for FSI.
  xc    fsi(fsiitmsz),fsi             | Clear it out.
  mvc   fsiitype,grdtdfsi+2           | Set item type in FSI.
  mvc   fsinu1,=h'-1'                 | Set unused field to -1.
  l     r1,&p.grd_size_to_make_free   | Store size of
  l     r1,0(,r1)                     | segment as size of
  st    r1,fsisize                    | freespace.
* *-------------------------------------------------------------------*
* * Initialize the GSS and chain it into the GSS chain off of the
* * GRD in ascending order.
* *-------------------------------------------------------------------*
  xc    gss(gssitmsz),gss             | Clear GSS.
  mvc   gssitype,imctdgss+2           | Set item type in GSS.
  l     r1,fsisize                    | Load r1 with segment size.
  drop  r7                            | Drop base for FSI.
  st    r1,gsssize                    | Set this in GSS.
  st    r1,gsslrgst                   | Set largest free space.
  l     r1,&p.free_space_token        | Move free
  l     r1,0(,r1)                     | space token
  st    r1,gssfrfsi                   | to GSS first FSI and
  st    r1,gssstart                   | GSS start fields.
  l32   r3,grdfrgss                   | Load first gss chained to GRD.
  if z                                | If chain empty:
   mvc   grdfrgss,&w.gss_token        |  This one is the first.
  else                                | If not empty:
   fill  &w.previous_gss_address,x'00'   Set previous GSS to zero.
   loop until                         |  Search for good place.
    imlta r7,r3                       |   Get address of next GSS.
    errexit nz,code=&im_internal_error    Internal error if failed.
    if (treg,r7,z)                    |   If null GSS pointer:
     l32   r7,&w.previous_gss_address |    Put this GSS at
     mvc   gssnxgss-gss(4,r7),&w.gss_token the end of the chain.
     leave loop=*                     |    Loop is complete.
    elseif (clc,gssstart,lt,gssstart-gss(r7)) If this GSS describes
     st    r3,gssnxgss                |    a higher segment then
     l32   r7,&w.previous_gss_address |    the new GSS, chain the
     if z                             |    new GSS ahead of it.  If
      mvc   grdfrgss,&w.gss_token     |    then new GSS is at the start
     else                             |    of the chain, put its token
      mvc   gssnxgss-gss(4,r7),&w.gss_token in the GRD first GSS
     endif                            |    pointer.
     leave loop=*                     |    Loop is complete.
    endif                             |   Endif.
    st    r7,&w.previous_gss_address  |   Save pointer to GSS.
    l     r3,gssnxgss-gss(,r7)        |   Point to next GSS.
   endloop until,leave                |  End of loop.
  endif                               | Endif.
* *-------------------------------------------------------------------*
 endblk block=initialize_new_freespace
 eject                                |
         space 1                      |
         swa ,                        |
&w.gss_token                 ds  f    |
&w.previous_gss_address      ds  a    |
         endswa ,                     |
         eject                        |
*---------------------------------------------------------------------*
*
*  Subroutine: Get_data_space_increment
*  Abstract:   This subroutine gets storage for a data space
*              increment.
*  Inputs:     (>increment_size,<token|,<address)
*  Outputs:    None.
*  Special     This routine will eventually support ESA style data
*  Notes:      spaces and may be moved to another module or server.
*
*---------------------------------------------------------------------*
 block name=get_data_space_increment,type=subroutine,                  +
               parms=(increment_size,increment_token,                  +
               increment_address)     |
          space 1                     |
  mm_obtain_storage id=mm,            | Get storage for a DSE.         +
               size==a(dsecblen),     |                                +
               address=&w.addr        |
  if (treg,r15,nz)                    | If obtain failed:
   errexit (ch,r15,eq,=y(&mm_storage_not_available)),                  +
               code=&im_storage_not_available   Fail with appropriate
   errexit code=&im_internal_error    |         error code.
  endif                               | Endif.
  l     r3,&w.addr                    | Load address of DSE storage.
  using dse,r3                        | Establish base for DSE.
  l32   r1,pwa_final_dse              | Point r1 to last DSE on chain.
  if z                                | If chain is empty.
   slr   r0,r0                        |  Set offset to zero.
   st    r3,pwa_first_dse             |  This dse is first in chain.
  else                                | Else if chain is not empty.
   l     r0,dseoffset-dse(,r1)        |  Calculate offset of new
   al    r0,dsespan-dse(,r1)          |  increment by adding offset
   st    r3,dsenext-dse(,r1)          |  and span in last DSE and add
  endif                               |  this DSE to chain.
  st    r0,dseoffset                  | Store offset in new DSE.
  sll   r0,12                         | Calculate token.
  st    r0,dsetoken                   | Save token.
  st    r3,pwa_final_dse              | Set last DSE pointer.
  mvc   dsecbid,=a(dsecbidt)          | Move id to DSE.
  l     r1,&p.increment_size          | Point to increment size.
  l     r0,0(,r1)                     | Load size of increment.
  st    r0,dsesize                    | Store size in DSE.
  srl   r0,12                         | Calculate size in blocks.
  st    r0,dsespan                    | Store this as span.
  xc    dsenext,dsenext               | Clear next pointer.
  es_obtain_storage id=es,            | Get storage for increment      +
               subpool=0,             |                                +
               size=dsesize,          |                                +
               address=dsestart       |
  if (treg,r15,nz)                    | If obtain failed:
   errexit (ch,r15,eq,=y(&es_storage_not_available)),                  +
               code=&im_storage_not_available   Fail with appropriate
   errexit code=&im_internal_error    |         error code.
  endif                               | Endif.
  l     r1,&p.increment_address       | Point to address return area.
  mvc   0(l'dsestart,r1),dsestart     | Return increment address.
  l32   r1,&p.increment_token         | Point to token return area.
  if nz                               | If token is requested:
   mvc   0(l'dsetoken,r1),dsetoken    |  Return it also.
   if (tbit,pwa_f_actual_address)     |  Return address instead
    mvc   0(l'dsetoken,r1),dsestart   |  if using
   endif                              |  actual addresses.
  endif                               | Endif.
  l32   r15,pwa_dv                    | Point r15 to div manager epa.
  if nz                               | If one exist.
   callx (r15),(pwa_dv_token,         |  Open a window for this        +
               &dv_open_window,       |  increment.                    +
               dsestart,              |                                +
               dsespan,               |                                +
               dseoffset),vl          |
   errexit (treg,r15,nz),code=&im_dv_open_window_failed
   l     r1,dsestart                  | Point r1
   al    r1,dsesize                   | to last byte
   bctr  r1,0                         | in increment.
   mvi   0(r1),255                    | Change it so DIV will
   mvi   0(r1),0                      | save it.
  endif                               | Endif.
 endblk block=get_data_space_increment
          space 1                     |
          swa   ,                     |
&w.addr   ds    a                     |
          endswa ,                    |
         eject                        |
*---------------------------------------------------------------------*
*
*  Subroutine: Make_current
*  Abstract:   This subroutine will make an item
*              current-of-item-manager, current-of-item-type, and
*              optionally, current-of-descriptor.
*  Inputs:     (>token,>desctkn|)
*  Outputs:    None.
*---------------------------------------------------------------------*
 block name=make_current,type=subroutine,                              +
               parms=(item_token,desc_token)
  l     r3,&p.item_token              | Load r3 with
  l     r3,0(,r3)                     |  item token.
  st    r3,pwa_current_of_item_manager  Make current-of-item-manager.
  imlta r4,r3                         | Get address of item.
  errexit nz,or,(treg,r4,z),          | Fail if there is an error.     +
               code=&im_invalid_token |
  l16   r1,0(r4)                      | Get the item-type token.
  st    r1,&w.token                   | Save it in work area.
  callsub current,(*&p.item_token,&w.token) Make current-of-item-type.
  l32   r2,&p.desc_token              | If descriptor is specified:
  if nz                               |
   callsub current,(*&p.item_token,(r2)) Make current-of-descriptor.
  endif                               | Endif.
 endblk block=make_current            |
 space 2                              |
 swa ,                                |
&w.token ds a                         |
 endswa ,                             |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: current
*  Abstract:   This subroutine maintaines the item currency elements.
*              Call this to make an item current "of" something.
*  Inputs:     (>item,>of)
*  Outputs:    None.
*---------------------------------------------------------------------*
 block name=current,type=subroutine,parms=(item,of)
  l     r1,pwa_current_of             | Load pointer to chain.
  slr   r2,r2                         | Clear prior pointer.
  l     r3,&p.of                      | Load search
  l     r3,0(,r3)                     | argument.
  using ice,r1                        | Establish base for ICE.
  loop until                          | Search for hit.
   if (treg,r1,z)                     |  If hit not found:
    l     r2,pwa_current_of           |   Save head of chain pointer.
    mm_obtain_storage id=mm,          |   Get storage for a ICE.       +
               size==a(icecblen),     |                                +
               address=pwa_current_of |
    if (treg,r15,nz)                  |   If obtain failed:
     errexit (ch,r15,eq,=y(&mm_storage_not_available)),                +
               code=&im_storage_not_available   Fail with appropriate
     errexit code=&im_internal_error  |           error code.
    endif                             |   Endif.
    l     r1,pwa_current_of           |   Load pointer to new ICE.
    xc    ice(icecblen),ice           |   Clear it.
    st    r2,icenext                  |   Insert at start of chain.
    st    r3,iceof                    |   Store "of" field.
    l     r3,&p.item                  |   Make item current
    mvc   iceitem,0(r3)               |   "of".
    leave loop=*                      |   Finished.
   else                               |  If not at end of list:
    if (cl,r3,eq,iceof)               |   If this is the "of" ICE:
     l     r3,&p.item                 |    Make item current
     mvc   iceitem,0(r3)              |    "of".
     if (treg,r2,nz)                  |    If there is a prior:
      mvc   icenext-ice(l'icenext,r2),icenext Unchain ICE.
     endif                            |    Endif.
     if (cl,r1,ne,pwa_current_of)     |    If not already at start:
      mvc   icenext,pwa_current_of    |     Put ICE at
      st    r1,pwa_current_of         |     front of chain.
     endif                            |    Endif.
     leave loop=*                     |    Finished.
    else                              |   If not correct ICE:
     lr    r2,r1                      |    Save this ICE as prior.
     l     r1,icenext                 |    Point to next ICE.
    endif                             |   Endif.
   endif                              |  Endif.
  endloop until,leave                 | Endloop.
 endblk block=current                 |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: find_current
*  Abstract:   This subroutine maintaines the item currency elements.
*              Call this to make an item current "of" something.
*  Parameters: (>current_of_what,<is_what)
*
*---------------------------------------------------------------------*
 block name=find_current,type=subroutine,parms=(of,is)
  l     r3,pwa_current_of             | Load pointer to chain.
  l     r1,&p.of                      | Load r0 with
  l     r0,0(,r1)                     | thing to search for.
  using ice,r3                        | Using ICE.
  loop until                          | Search for correct ICE.
   if (treg,r3,z)                     |  If at end of chain:
    la    r15,4                       |   Set return code
    leave loop=*                      |   to 4 and return.
   elseif (cl,r0,eq,iceof)            |  Else if match:
    l     r1,&p.is                    |   Move item token
    mvc   0(4,r1),iceitem             |   to return area.
    sr    r15,r15                     |   Assume current found.
    if (clc,iceitem,eq,=f'0')         |   If item token is zero:
     la    r15,4                      |    Currency has been removed.
    endif                             |   Endif.
    leave loop=*                      |   to zero and return.
   else                               |  Else
    l     r3,icenext                  |   Point to next ICE.
   endif                              |  Endif.
  endloop until,leave                 | End of search code.
 endblk block=find_current,rc=(r15)   |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Quick_get_address
*  Abstract:   This is a routine to quickly convert a token into a
*              virtual storage address.
*  Inputs:     r0  - Item token to convert.
*              r1  - Token of item manager service processor.
*              r14 - Return address.
*              r15 - EPA.
*  Outputs:    r0  - Unpredictable.
*              r1  - Virtual address of item.
*              r14 - Unchanged.
*              r15 - 0 - Conversion went ok.
*                    &im_invalid_token - Conversion did not go ok.
*              Condition code - Set to reflect return code.
*  Special     This routine is provided with speed in mind.  It is
*  Notes:      believed that converting tokens to addresses will be
*              very heavily used.
*
*              If a zero token is passed in to this routine in r0,
*              the return code will be zero, and r1 will be set to
*              zero.  This is considered a "null".
*
*---------------------------------------------------------------------*
 block name=quick_get_address,type=subroutine,                         +
               options=(*nosubopts,custom)
  push  using                         | Push usings.
  drop  ,                             | Drop all bases.
  using quick_get_address,r15         | Establish base.
  if (treg,r0,nz)                     |
   icm   r1,b'1111',pwa_first_dse-&pwa.(r1) Point to first DSE.
   using dse,r1                       |  Establish base for DSE.
   if nz                              |  If one exist:
    loop until                        |   Loop until:
     if (c,r0,lt,dsesize)             |    If token within this extent:
      l     r1,dsestart               |     Calculate address
      alr   r1,r0                     |     associated with item.
      sr    r15,r15                   |     Set RC and CC to zero.
      br    r14                       |     Return to caller.
     endif                            |    Endif.
     s     r0,dsesize                 |    Sub off size of this extent.
     icm   r1,b'1111',dsenext         |    Point to next DSE.
    endloop until,z                   |   Endloop until end of chain.
   endif                              |  Endif.
   la    r15,&im_invalid_token        |  Bad return code if here.
   treg  r15                          |  Set CC.
   br    r14                          |  Return to caller.
  else                                | Else
   slr   r1,r1                        |  Set address to zero.
   sr    r15,r15                      |  Set return code to zero.
  endif                               | Endif.
  treg  r15                           | Set CC.
  br    r14                           | Return to caller.
  pop   using                         | Pop usings.
 endblk block=quick_get_address       |
 eject                                |
*---------------------------------------------------------------------*
*
*  Subroutine: Quick_get_address_actual
*  Abstract:   This is a routine to stub that is used when tokens are
*              already virtual storage address.
*  Inputs:     r0  - Item token to convert.
*              r14 - Return address.
*              r15 - EPA.
*  Outputs:    r0  - Unpredictable. (actually unchanged)
*              r1  - Virtual address of item.
*              r14 - Unchanged.
*              r15 - 0
*
*---------------------------------------------------------------------*
 block name=quick_get_address_actual,type=subroutine,                  +
               options=(*nosubopts,custom)
  push  using                         | Push usings.
  drop  ,                             | Drop all bases.
  using quick_get_address_actual,r15  | Establish base.
  if (treg,r0,nz),and,(c,r0,lt,pwa_lt_64k_size-&pwa.(r1))
   al    r0,pwa_imc_address-&pwa.(r1)    Item type tokens are relative
  endif                               |  byte addresses.
  lr    r1,r0                         | Put address in R1.
  sr    r15,r15                       | Set return code to zero.
  br    r14                           | Return.
  pop   using                         | Pop usings.
 endblk block=quick_get_address_actual
 eject                                |
*---------------------------------------------------------------------*
*
*  Errexit:    Unnamed
*  Purpose:    Save debugging information and exit with the return
*              code pointed to by r14 at entry to this exit.
*
*---------------------------------------------------------------------*
         SPACE 1                      |
 block type=errexit                   |
* *-------------------------------------------------------------------*
* * Save module/offset, registers, return-code.
* *-------------------------------------------------------------------*
  st    r15,pwa_reason                | Save possible return-code.
  stm   r0,r15,gdiregs                | Save registers at time of error
  sm_lal r0,&srv_modname+4            | Point to module iden
  st    r0,gdimodid                   | Save in general debug area.
  mvc   gdirc,0(r14)                  | Copy return code.
  sl    r14,=a(&srv_modname)          | Calculate offset at time of err
  sth   r14,gdioffst                  | Save in debug area.
  es_save_debug_info id=es,gdi=gdi    | Save debug information.
* *-------------------------------------------------------------------*
* * Look at the error code.  Some errors imply that the DIV Server
* * has lost its cookies and should not attempt to do anything other
* * than shut-down (if it can even do that).
* *-------------------------------------------------------------------*
  lh    r15,gdirc                     | Get return code.
  caseblk reg=r15,mult=1              | Case on return-code.
    case &dv_not_useable              |
      rbit  pwa_f_useable             | Indicate DIV Server unsafe.
*>>>  es_save_debug_info id=es,hex=(pwa_reason,4),label=("REASON",6)
      callx pwa_es_epa,(pwa_es_token,&es_save_debug_info,              +
               &es_debug_id_hex,pwa_reason,4,"REASON",6),vl
    case other                        |  Don't bother w/other errors.
  endcase                             | EndCase.
* *-------------------------------------------------------------------*
* * Set the return-code and exit.
* *-------------------------------------------------------------------*
  lh    r15,gdirc                     | Set return code.
 endblk                               |
 eject                                |
 title "Program Static Data"          |
                psd                   |
psd_div_lf      dc    8a(0)           |
psd_div_lf_length equ *-psd_div_lf    |
psd_min_spare_gsss                  dc a(4)
psd_max_spare_gsss                  dc a(10)
psd_number_of_itds                  dc a(&number_of_itds)
psd_number_of_itdxs                 dc a(&number_of_itdxs)
psd_0123456789147036 equ *-c'0'
                dc c'0123456789147036'
                ltorg ,               |
                endpsd                |
          title "Dsects"              |
          im_sfd ,                    |
ice       dsect ,                     | Item Currency Element.
icenext   ds    a                     | Next ICE.
iceitem   ds    a                     | Item.
iceof     ds    a                     | Current "of"
icecblen  equ   *-ice                 | Control block size.
          space 3                     |
dir       dsect ,                     | Directory Entry.
diritype  ds    h                     | Item type of DIR.
dirnmsz   ds    x                     | Size of name.
dirname   ds    cl255                 | Name of Item.
dirlinks  ds    0f                    | Start of nodes.
dirdesc   ds    f                     | Item description.
diritkn   ds    f                     | Item token.
dirtksyn  ds    f                     | Synonym chain.
dirtksyn_link_number equ (*-dirlinks)/4 Link number of synonym chain.
dir#lnks  equ   (*-dirlinks)/4        | Item number of links.
diritmsz  equ   *-dir                 | Size of a DIR.
          space 3                     |
dse       dsect ,                     | Data space extent.
dsecbid   ds    f                     | Control block id.
dsecbidt  equ   c"DSE "               | Control block id text.
dsestart  ds    a                     | Start of extent in storage.
dsetoken  ds    f                     | Token of first item in extent.
dseoffset ds    f                     | Offset in data space (blocks).
dsespan   ds    f                     | Span (blocks).
dsesize   ds    f                     | Size of extent.
dsenext   ds    a                     | Address of next DSE.
dsecblen  equ   *-dse                 | Size of a DSE.
          space 1
*--------------------------------------------------------------------*
*  Parameter list work area.
*--------------------------------------------------------------------*
prm                           dsect , |
prm_ItemID                    ds a    | Div identifier === PWA base
prm_functioncode              ds a    | Function to be performed
prm_min_#                     equ (*-prm)/4
prm_function_dependent        equ *   | Function-dependent parameters
* Start function
                  org prm_function_dependent
prm_start_esv                 ds a    | Environment Support Vector.
prm_start_options             ds a    | Options.
prm_start_options_read_only      equ b'10000000'
prm_start_options_actual_address equ b'01000000'
prm_start_div_epa             ds a    | DIV service process EPA.
prm_start_div_ddname          ds a    | DIV DDName.
prm_start_max_#               equ (*-prm)/4
* Terminate function
                  org prm_function_dependent
prm_terminate_max_#           equ (*-prm)/4
* Initialize function
                  org prm_function_dependent
prm_initialize_itd_stg_size   ds a    | ITD storage size.
prm_initialize_ua_stg_incr    ds a    | Unallocated stg increment size.
prm_initialize_sys_stg_incr   ds a    | System stg increment size.
prm_initialize_du_stg_incr    ds a    | Dflt user stg increment size.
prm_initialize_max_#          equ (*-prm)/4
* Save function
                  org prm_function_dependent
prm_save_max_#                equ (*-prm)/4
* Reset function
                  org prm_function_dependent
prm_reset_max_#               equ (*-prm)/4
* Add to directory function
                  org prm_function_dependent
prm_add_to_dir_name_length      ds a  | Name Length.
prm_add_to_dir_name             ds a  | Name.
prm_add_to_dir_token            ds a  | Token.
prm_add_to_dir_max_#          equ (*-prm)/4
* Find in directory function
                  org prm_function_dependent
prm_find_in_dir_name_length     ds a  | Name Length.
prm_find_in_dir_name            ds a  | Name.
prm_find_in_dir_token           ds a  | Token.
prm_find_in_dir_max_#         equ (*-prm)/4
* Remove from directory function
                  org prm_function_dependent
prm_remove_from_dir_name_length ds a  | Name Length.
prm_remove_from_dir_name        ds a  | Name.
prm_remove_from_dir_max_#     equ (*-prm)/4
* Create item type descriptor function
                  org prm_function_dependent
prm_create_itd_descriptor_token ds a  | Descriptor token.
prm_create_itd_description      ds a  | Description.
prm_create_itd_options          ds a  | Options.
prm_create_itd_options_first_link_has_description equ b'10000000'
prm_create_itd_grd_token        ds a  | Group descriptor token.
prm_create_itd_item_len         ds a  | Item length.
prm_create_itd_#_links          ds a  | Number of links in item.
prm_create_itd_offset           ds a  | First link offset.
prm_create_itd_item_len_size    ds a  | Item length size.
prm_create_itd_item_len_offset  ds a  | Item length offset.
prm_create_itd_#_links_size     ds a  | Number of links size.
prm_create_itd_#_links_offset   ds a  | Number of links offset.
prm_create_itd_offset_size      ds a  | First link offset size.
prm_create_itd_offset_offset    ds a  | First link offset offset.
prm_create_itd_max_#          equ (*-prm)/4
* Create group descriptor function
                  org prm_function_dependent
prm_create_gd_descriptor_token ds a   | Descriptor token.
prm_create_gd_description      ds a   | Description.
prm_create_gd_increment_size  ds a    | Storage increment size.
prm_create_gd_max_#           equ (*-prm)/4
* Create linked list function
                  org prm_function_dependent
prm_create_ld_descriptor_token ds a   | Descriptor token.
prm_create_ld_description      ds a   | Description.
prm_create_ld_options         ds a    | Options.
prm_create_ld_first_link_#    ds a    | First    link number.
prm_create_ld_final_link_#    ds a    | Final    link number.
prm_create_ld_next_link_#     ds a    | Next     link number.
prm_create_ld_prior_link_# ds a       | prior link number.
prm_create_ld_owner_link_#    ds a    | Owner    link number.
prm_create_ld_heads_item_type ds a    | Item type of heads items.
prm_create_ld_key_offset      ds a    | Key offset.
prm_create_ld_key_len         ds a    | Key length.
prm_create_ld_key_len_offset  ds a    | Key length offset.
prm_create_ld_itemtype        ds a    | Itemtype.
prm_create_ld_max_#           equ (*-prm)/4
* Create hash table function
                  org prm_function_dependent
prm_create_ht_descriptor_token ds a   | Descriptor token.
prm_create_ht_description      ds a   | Description.
prm_create_ht_options         ds a    | Options.
prm_create_ht_entries_in_table ds a   | Number of entries in table.
prm_create_ht_synonym_link_#  ds a    | Synonym  link number.
prm_create_ht_key_offset      ds a    | Key offset.
prm_create_ht_key_len         ds a    | Key length.
prm_create_ht_key_len_offset  ds a    | Key length offset.
prm_create_ht_itemtype        ds a    | Itemtype.
prm_create_ht_max_#           equ (*-prm)/4
* Create binary tree function
                  org prm_function_dependent
prm_create_bt_descriptor_token ds a   | Descriptor token.
prm_create_bt_description      ds a   | Description.
*> not defined
prm_create_bt_max_#           equ (*-prm)/4
* Destroy function
                  org prm_function_dependent
prm_destroy_descriptor_token  ds a    | Descriptor token.
prm_destroy_force             ds a    | Force flag.
prm_destroy_max_#             equ (*-prm)/4
* Connect function
                  org prm_function_dependent
prm_connect_descriptor_token  ds a    | Descriptor token.
prm_connect_item_token        ds a    | Item to connect.
prm_connect_head_token        ds a    | Head item.
prm_connect_max_#             equ (*-prm)/4
* Disconnect function
                  org prm_function_dependent
prm_disconnect_descriptor_token  ds a | Descriptor token.
prm_disconnect_item_token        ds a | Item to connect.
prm_disconnect_head_token        ds a | Head item.
prm_disconnect_prior_token       ds a | Token of prior item.
prm_disconnect_max_#             equ (*-prm)/4
* Obtain function
                  org prm_function_dependent
prm_ob_item_token             ds a    | Item token.
prm_ob_return_area_size       ds a    | Return area size.
prm_ob_return_area            ds a    | Return area.
prm_ob_actual_item_size       ds a    | Actual item size.
prm_ob_max_#                  equ (*-prm)/4
* Obtain by key function
                  org prm_function_dependent
prm_obky_descriptor_token     ds a    | Descriptor token.
prm_obky_key_length           ds a    | Key size.
prm_obky_key                  ds a    | Key.
prm_obky_return_area_size     ds a    | Return area size.
prm_obky_return_area          ds a    | Return area.
prm_obky_actual_item_size     ds a    | Actual item size.
prm_obky_item_token           ds a    | Item token.
prm_obky_max_#                equ (*-prm)/4
* Obtain current_of_descriptor, next, prior, owner, first and final.
* 2a is for first and final. 2b is for next and prior. 2c for owner.
                  org prm_function_dependent
prm_ob2_descriptor_token      ds a    | Descriptor token.
prm_ob2_return_area_size      ds a    | Return area size.
prm_ob2_return_area           ds a    | Return area.
prm_ob2_actual_item_size      ds a    | Actual item size.
prm_ob2_item_token            ds a    | Item token.
prm_ob2_max_#                 equ (*-prm)/4
prm_ob2b_current_token        ds 0a   | Current token
prm_ob2c_current_token        ds 0a   | Current token
prm_ob2a_head_token           ds a    | Head token.
prm_ob2c_max_#                equ (*-prm)/4
prm_ob2a_max_#                equ (*-prm)/4
prm_ob2b_head_token           ds a    | Head token.
prm_ob2b_max_#                equ (*-prm)/4
* Obtain current_of_item_type.
                  org prm_function_dependent
prm_ob3_item_type             ds a    | Item type.
prm_ob3_return_area_size      ds a    | Return area size.
prm_ob3_return_area           ds a    | Return area.
prm_ob3_actual_item_size      ds a    | Actual item size.
prm_ob3_item_token            ds a    | Item token.
prm_ob3_max_#                 equ (*-prm)/4
* Find function
                  org prm_function_dependent
prm_fd_item_token             ds a    | Item token.
prm_fd_actual_item_size       ds a    | Actual item size.
prm_fd_max_#                  equ (*-prm)/4
* Find by key function
                  org prm_function_dependent
prm_fdky_descriptor_token     ds a    | Descriptor token.
prm_fdky_key_length           ds a    | Key size.
prm_fdky_key                  ds a    | Key.
prm_fdky_actual_item_size     ds a    | Actual item size.
prm_fdky_item_token           ds a    | Item token.
prm_fdky_max_#                equ (*-prm)/4
* Find current_of_descriptor, next, prior, owner, first and final.
* 2a is for first and final. 2b is for next and prior. 2c for owner.
                  org prm_function_dependent
prm_fd2_descriptor_token      ds a    | Descriptor token.
prm_fd2_actual_item_size      ds a    | Actual item size.
prm_fd2_item_token            ds a    | Item token.
prm_fd2_max_#                 equ (*-prm)/4
prm_fd2c_current_token        ds 0a   | Current token
prm_fd2b_current_token        ds 0a   | Current token
prm_fd2a_head_token           ds a    | Head token.
prm_fd2c_max_#                equ (*-prm)/4
prm_fd2a_max_#                equ (*-prm)/4
prm_fd2b_head_token           ds a    | Head token.
prm_fd2b_max_#                equ (*-prm)/4
* Find current_of_item_type.
                  org prm_function_dependent
prm_fd3_item_type             ds a    | Item type.
prm_fd3_actual_item_size      ds a    | Actual item size.
prm_fd3_item_token            ds a    | Item token.
prm_fd3_max_#                 equ (*-prm)/4
* Get function
                  org prm_function_dependent
prm_get_return_area_size      ds a    | Return area size.
prm_get_return_area           ds a    | Return area.
prm_get_actual_item_size      ds a    | Actual item size.
prm_get_item_token            ds a    | Item token.
prm_get_max_#                 equ (*-prm)/4
* Get dangerous addresses function
                  org prm_function_dependent
prm_gda_token_convert_routine ds a    | Token convert routine.
prm_gda_max_#                 equ (*-prm)/4
* Modify function
                  org prm_function_dependent
prm_modify_item_address       ds a    | Item address.
prm_modify_options            ds a    | Options.
prm_modify_options_bypass_links_check equ b'10000000'
prm_modify_options_update_links       equ b'01000000'
prm_modify_item_token         ds a    | Item token.
prm_modify_max_#              equ (*-prm)/4
* Sort function
                  org prm_function_dependent
prm_sort_descriptor_token     ds a    | Item address.
prm_sort_fieldslist           ds a    | Options.
prm_sort_head_token           ds a    | Head item.
prm_sort_technique            ds a    | Sort technique.
prm_sort_max_#                equ (*-prm)/4
* Store function
                  org prm_function_dependent
prm_store_item_address        ds a    | Item address.
prm_store_options             ds a    | Options.
prm_store_options_links_can_be_nonnull equ b'10000000'
prm_store_item_token          ds a    | Item token.
prm_store_max_#               equ (*-prm)/4
* Erase function
                  org prm_function_dependent
prm_erase_options             ds a    | Options.
prm_erase_options_bypass_links_check  equ b'10000000'
prm_erase_item_token          ds a    | Item token.
prm_erase_max_#               equ (*-prm)/4
                  org ,               |
prm_max_#                     equ (*-prm)/4
          space 1                     |
          es_esv ,                    |
          itc dsect=yes               |
          kpm dsect=yes               |
          im_fsi ,                    |
          im_grd ,                    |
          im_gss ,                    |
          im_htd ,                    |
          im_imc ,                    |
          im_itd ,                    |
          im_lld ,                    |
          im_dsc ,                    |
          title "Program Work Area"   |
               PWA                    |
pwa_area       ds    0f               | Beginning of visible PWA stg.
pwa_f          ds    bl1              | Flags for DIV Server.
pwa_f_useable         equ b'10000000' | DIV Server is useable.
pwa_f_final_setup     equ b'01000000' |
pwa_f_short_itd_ok    equ b'00100000' |
pwa_f_actual_address  equ b'00010000' | Actual addresses are used.
               ds    bl1              | Not used.
pwa_number_of_parms ds f              | Number of parms.
pwa_im_token                  ds f    | Pointer to program work area.
pwa_reason                    ds f    | Reason Item Manager died.
pwa_dv                        ds a    | Div SP epa.
pwa_dv_token                  ds f    | Div SP token.
pwa_es_epa                    ds a    | Environment support EPA.
pwa_es_token                  ds f    | Environment support token.
pwa_mm_epa                    ds a    | Memory manager epa.
pwa_initial_size              ds a    | Initial size of DIV area.
pwa_im_quick_get_address      ds a    | Address of quick get addr rtn.
pwa_increment                 ds f    | Main increment size.
pwa_system_storage_increment       ds f System storage increment.
pwa_default_user_storage_increment ds f Default user storage increment.
pwa_lt_64k_size               ds f    | <64k storage size.
pwa_first_dse                 ds a    | First DSE in chain.
pwa_final_dse                 ds a    | Final DSE in chain.
pwa_time                      ds f    | Time (used during initialize)
pwa_date                      ds pl4  | Date (used during initialize)
pwa_bit_mask                  ds f    | Use by BIT compare code.
               es_gdi dsect=no        | General debugging information.
pwa_build_area ds 0f                  |
pwa_itd_build_area ds xl(itdxitmsz)   |
               org pwa_build_area     |
pwa_grd_build_area ds xl(grditmsz)    |
               org pwa_build_area     |
pwa_lld_build_area ds xl(llditmsz)    |
               org pwa_build_area     |
pwa_htd_build_area ds xl(htditmsz)    |
               org pwa_build_area     |
pwa_key_work_area  ds xl256           |
               org ,                  |
pwa_imc_address               ds a    |
pwa_current_of                ds a    | Head of current "of" chain.
pwa_current_of_item_manager   ds f    | Current of item manager.
*--------------------------------------------------------------------*
pwa_area_l     equ   *-pwa_area       | Length of visible PWA stg.
               endpwa                 |
               end   ,                |
